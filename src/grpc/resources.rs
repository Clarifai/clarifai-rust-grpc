// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/clarifai/api/resources.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

///  Annotation of an asset with metadata
// @@protoc_insertion_point(message:clarifai.api.Annotation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Annotation {
    // message fields
    ///  The ID for the annotation
    // @@protoc_insertion_point(field:clarifai.api.Annotation.id)
    pub id: ::std::string::String,
    ///  ID of the input this annotation is tied to
    // @@protoc_insertion_point(field:clarifai.api.Annotation.input_id)
    pub input_id: ::std::string::String,
    ///  The data passed along in this annotation.
    // @@protoc_insertion_point(field:clarifai.api.Annotation.data)
    pub data: ::protobuf::MessageField<Data>,
    ///  task_id is deprecated in annotation_info. Use task_id
    // @@protoc_insertion_point(field:clarifai.api.Annotation.annotation_info)
    pub annotation_info: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  ID of the user this annotation is created by
    // @@protoc_insertion_point(field:clarifai.api.Annotation.user_id)
    pub user_id: ::std::string::String,
    ///  ID of the model version this annotation is created by
    // @@protoc_insertion_point(field:clarifai.api.Annotation.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  DEPRECATED.
    // @@protoc_insertion_point(field:clarifai.api.Annotation.embed_model_version_id)
    pub embed_model_version_id: ::std::string::String,
    ///  Annotation Status
    // @@protoc_insertion_point(field:clarifai.api.Annotation.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  When the annotation was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.Annotation.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the annotation was modified.
    // @@protoc_insertion_point(field:clarifai.api.Annotation.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Whether or not this annotation is trusted
    ///  Will be deprecated
    // @@protoc_insertion_point(field:clarifai.api.Annotation.trusted)
    pub trusted: bool,
    ///  Is this the input level annotation.
    // @@protoc_insertion_point(field:clarifai.api.Annotation.input_level)
    pub input_level: bool,
    ///  Consensus review related information, e.g.
    ///  * annotation group
    ///  * id of annotation parent, in case the annotation was split from another annotation
    // @@protoc_insertion_point(field:clarifai.api.Annotation.consensus_info)
    pub consensus_info: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  The id of the task annotation belongs to
    // @@protoc_insertion_point(field:clarifai.api.Annotation.task_id)
    pub task_id: ::std::string::String,
    ///  ID of the workflow version this annotation is created by
    // @@protoc_insertion_point(field:clarifai.api.Annotation.workflow_version_id)
    pub workflow_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Annotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Annotation {
    fn default() -> &'a Annotation {
        <Annotation as ::protobuf::Message>::default_instance()
    }
}

impl Annotation {
    pub fn new() -> Annotation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Annotation| { &m.id },
            |m: &mut Annotation| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &Annotation| { &m.input_id },
            |m: &mut Annotation| { &mut m.input_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &Annotation| { &m.data },
            |m: &mut Annotation| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "annotation_info",
            |m: &Annotation| { &m.annotation_info },
            |m: &mut Annotation| { &mut m.annotation_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Annotation| { &m.user_id },
            |m: &mut Annotation| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &Annotation| { &m.model_version_id },
            |m: &mut Annotation| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "embed_model_version_id",
            |m: &Annotation| { &m.embed_model_version_id },
            |m: &mut Annotation| { &mut m.embed_model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &Annotation| { &m.status },
            |m: &mut Annotation| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Annotation| { &m.created_at },
            |m: &mut Annotation| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Annotation| { &m.modified_at },
            |m: &mut Annotation| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trusted",
            |m: &Annotation| { &m.trusted },
            |m: &mut Annotation| { &mut m.trusted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_level",
            |m: &Annotation| { &m.input_level },
            |m: &mut Annotation| { &mut m.input_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "consensus_info",
            |m: &Annotation| { &m.consensus_info },
            |m: &mut Annotation| { &mut m.consensus_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &Annotation| { &m.task_id },
            |m: &mut Annotation| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_version_id",
            |m: &Annotation| { &m.workflow_version_id },
            |m: &mut Annotation| { &mut m.workflow_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Annotation>(
            "Annotation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Annotation {
    const NAME: &'static str = "Annotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation_info)?;
                },
                122 => {
                    self.user_id = is.read_string()?;
                },
                130 => {
                    self.model_version_id = is.read_string()?;
                },
                114 => {
                    self.embed_model_version_id = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                80 => {
                    self.trusted = is.read_bool()?;
                },
                136 => {
                    self.input_level = is.read_bool()?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.consensus_info)?;
                },
                154 => {
                    self.task_id = is.read_string()?;
                },
                162 => {
                    self.workflow_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.annotation_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.user_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.model_version_id);
        }
        if !self.embed_model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.embed_model_version_id);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.trusted != false {
            my_size += 1 + 1;
        }
        if self.input_level != false {
            my_size += 2 + 1;
        }
        if let Some(v) = self.consensus_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.task_id);
        }
        if !self.workflow_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.workflow_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.annotation_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(15, &self.user_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(16, &self.model_version_id)?;
        }
        if !self.embed_model_version_id.is_empty() {
            os.write_string(14, &self.embed_model_version_id)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if self.trusted != false {
            os.write_bool(10, self.trusted)?;
        }
        if self.input_level != false {
            os.write_bool(17, self.input_level)?;
        }
        if let Some(v) = self.consensus_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(19, &self.task_id)?;
        }
        if !self.workflow_version_id.is_empty() {
            os.write_string(20, &self.workflow_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Annotation {
        Annotation::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.input_id.clear();
        self.data.clear();
        self.annotation_info.clear();
        self.user_id.clear();
        self.model_version_id.clear();
        self.embed_model_version_id.clear();
        self.status.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.trusted = false;
        self.input_level = false;
        self.consensus_info.clear();
        self.task_id.clear();
        self.workflow_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Annotation {
        static instance: Annotation = Annotation {
            id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            annotation_info: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            embed_model_version_id: ::std::string::String::new(),
            status: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            trusted: false,
            input_level: false,
            consensus_info: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            workflow_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Annotation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Annotation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Annotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Worker is the author of an annotation.
// @@protoc_insertion_point(message:clarifai.api.Worker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Worker {
    // message oneof groups
    pub worker: ::std::option::Option<worker::Worker>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Worker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Worker {
    fn default() -> &'a Worker {
        <Worker as ::protobuf::Message>::default_instance()
    }
}

impl Worker {
    pub fn new() -> Worker {
        ::std::default::Default::default()
    }

    // .clarifai.api.User user = 1;

    pub fn user(&self) -> &User {
        match self.worker {
            ::std::option::Option::Some(worker::Worker::User(ref v)) => v,
            _ => <User as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_user(&mut self) {
        self.worker = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        match self.worker {
            ::std::option::Option::Some(worker::Worker::User(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.worker = ::std::option::Option::Some(worker::Worker::User(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user(&mut self) -> &mut User {
        if let ::std::option::Option::Some(worker::Worker::User(_)) = self.worker {
        } else {
            self.worker = ::std::option::Option::Some(worker::Worker::User(User::new()));
        }
        match self.worker {
            ::std::option::Option::Some(worker::Worker::User(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        if self.has_user() {
            match self.worker.take() {
                ::std::option::Option::Some(worker::Worker::User(v)) => v,
                _ => panic!(),
            }
        } else {
            User::new()
        }
    }

    // .clarifai.api.Model model = 2;

    pub fn model(&self) -> &Model {
        match self.worker {
            ::std::option::Option::Some(worker::Worker::Model(ref v)) => v,
            _ => <Model as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_model(&mut self) {
        self.worker = ::std::option::Option::None;
    }

    pub fn has_model(&self) -> bool {
        match self.worker {
            ::std::option::Option::Some(worker::Worker::Model(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: Model) {
        self.worker = ::std::option::Option::Some(worker::Worker::Model(v))
    }

    // Mutable pointer to the field.
    pub fn mut_model(&mut self) -> &mut Model {
        if let ::std::option::Option::Some(worker::Worker::Model(_)) = self.worker {
        } else {
            self.worker = ::std::option::Option::Some(worker::Worker::Model(Model::new()));
        }
        match self.worker {
            ::std::option::Option::Some(worker::Worker::Model(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_model(&mut self) -> Model {
        if self.has_model() {
            match self.worker.take() {
                ::std::option::Option::Some(worker::Worker::Model(v)) => v,
                _ => panic!(),
            }
        } else {
            Model::new()
        }
    }

    // .clarifai.api.Workflow workflow = 3;

    pub fn workflow(&self) -> &Workflow {
        match self.worker {
            ::std::option::Option::Some(worker::Worker::Workflow(ref v)) => v,
            _ => <Workflow as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_workflow(&mut self) {
        self.worker = ::std::option::Option::None;
    }

    pub fn has_workflow(&self) -> bool {
        match self.worker {
            ::std::option::Option::Some(worker::Worker::Workflow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_workflow(&mut self, v: Workflow) {
        self.worker = ::std::option::Option::Some(worker::Worker::Workflow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_workflow(&mut self) -> &mut Workflow {
        if let ::std::option::Option::Some(worker::Worker::Workflow(_)) = self.worker {
        } else {
            self.worker = ::std::option::Option::Some(worker::Worker::Workflow(Workflow::new()));
        }
        match self.worker {
            ::std::option::Option::Some(worker::Worker::Workflow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_workflow(&mut self) -> Workflow {
        if self.has_workflow() {
            match self.worker.take() {
                ::std::option::Option::Some(worker::Worker::Workflow(v)) => v,
                _ => panic!(),
            }
        } else {
            Workflow::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, User>(
            "user",
            Worker::has_user,
            Worker::user,
            Worker::mut_user,
            Worker::set_user,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Model>(
            "model",
            Worker::has_model,
            Worker::model,
            Worker::mut_model,
            Worker::set_model,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Workflow>(
            "workflow",
            Worker::has_workflow,
            Worker::workflow,
            Worker::mut_workflow,
            Worker::set_workflow,
        ));
        oneofs.push(worker::Worker::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Worker>(
            "Worker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Worker {
    const NAME: &'static str = "Worker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.worker = ::std::option::Option::Some(worker::Worker::User(is.read_message()?));
                },
                18 => {
                    self.worker = ::std::option::Option::Some(worker::Worker::Model(is.read_message()?));
                },
                26 => {
                    self.worker = ::std::option::Option::Some(worker::Worker::Workflow(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.worker {
            match v {
                &worker::Worker::User(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &worker::Worker::Model(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &worker::Worker::Workflow(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.worker {
            match v {
                &worker::Worker::User(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &worker::Worker::Model(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &worker::Worker::Workflow(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Worker {
        Worker::new()
    }

    fn clear(&mut self) {
        self.worker = ::std::option::Option::None;
        self.worker = ::std::option::Option::None;
        self.worker = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Worker {
        static instance: Worker = Worker {
            worker: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Worker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Worker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Worker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Worker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Worker`
pub mod worker {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.Worker.worker)
    pub enum Worker {
        // @@protoc_insertion_point(oneof_field:clarifai.api.Worker.user)
        User(super::User),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Worker.model)
        Model(super::Model),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Worker.workflow)
        Workflow(super::Workflow),
    }

    impl ::protobuf::Oneof for Worker {
    }

    impl ::protobuf::OneofFull for Worker {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Worker as ::protobuf::MessageFull>::descriptor().oneof_by_name("worker").unwrap()).clone()
        }
    }

    impl Worker {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Worker>("worker")
        }
    }
}

///  Application with tasks and datasets
// @@protoc_insertion_point(message:clarifai.api.App)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct App {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.App.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.App.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.App.default_language)
    pub default_language: ::std::string::String,
    ///  Default workflow id deprecated in favor of default_workflow
    // @@protoc_insertion_point(field:clarifai.api.App.default_workflow_id)
    pub default_workflow_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.App.default_workflow)
    pub default_workflow: ::protobuf::MessageField<Workflow>,
    ///  why is user_id present here when this message type is used in PostApps but completely ignored there? PostApp already
    ///  specifies the userid in path but doesn't even actually use neither of userids, it instead used the id from auth context.
    ///  This creates a lot of ambiguity, should always have different message types for Post/Get endpoints so that the minimum interface for each op can be described
    // @@protoc_insertion_point(field:clarifai.api.App.user_id)
    pub user_id: ::std::string::String,
    ///  When the app was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.App.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the app was last modified
    // @@protoc_insertion_point(field:clarifai.api.App.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  if user accept legal consent for face recognition
    // @@protoc_insertion_point(field:clarifai.api.App.legal_consent_status)
    pub legal_consent_status: u32,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.App.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  short description about the app.
    // @@protoc_insertion_point(field:clarifai.api.App.description)
    pub description: ::std::string::String,
    ///  Default value for model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
    // @@protoc_insertion_point(field:clarifai.api.App.sample_ms)
    pub sample_ms: u32,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.App.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  data tier id this app is using.
    // @@protoc_insertion_point(field:clarifai.api.App.data_tier_id)
    pub data_tier_id: ::std::string::String,
    ///  Is starred by the requesting user (only showed on get/list requests)
    ///  Please use PostAppStars/DeleteAppStars endpoints to star/unstar an app
    // @@protoc_insertion_point(field:clarifai.api.App.is_starred)
    pub is_starred: bool,
    ///  How many users have starred the app (only showed on get/list requests)
    ///  Computed value, not editable
    // @@protoc_insertion_point(field:clarifai.api.App.star_count)
    pub star_count: i32,
    ///  Notes for the application
    ///  This field should be used for in-depth notes and supports up to 64Kbs.
    // @@protoc_insertion_point(field:clarifai.api.App.notes)
    pub notes: ::std::string::String,
    ///  Representative image for this app
    // @@protoc_insertion_point(field:clarifai.api.App.image)
    pub image: ::protobuf::MessageField<Image>,
    ///  An app marked as a template can be duplicated by any user that can see it,
    ///  including all visible resources within it.
    // @@protoc_insertion_point(field:clarifai.api.App.is_template)
    pub is_template: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::BoolValue>,
    // @@protoc_insertion_point(field:clarifai.api.App.extra_info)
    pub extra_info: ::protobuf::MessageField<AppExtraInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.App.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a App {
    fn default() -> &'a App {
        <App as ::protobuf::Message>::default_instance()
    }
}

impl App {
    pub fn new() -> App {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &App| { &m.id },
            |m: &mut App| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &App| { &m.name },
            |m: &mut App| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "default_language",
            |m: &App| { &m.default_language },
            |m: &mut App| { &mut m.default_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "default_workflow_id",
            |m: &App| { &m.default_workflow_id },
            |m: &mut App| { &mut m.default_workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Workflow>(
            "default_workflow",
            |m: &App| { &m.default_workflow },
            |m: &mut App| { &mut m.default_workflow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &App| { &m.user_id },
            |m: &mut App| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &App| { &m.created_at },
            |m: &mut App| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &App| { &m.modified_at },
            |m: &mut App| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legal_consent_status",
            |m: &App| { &m.legal_consent_status },
            |m: &mut App| { &mut m.legal_consent_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &App| { &m.metadata },
            |m: &mut App| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &App| { &m.description },
            |m: &mut App| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_ms",
            |m: &App| { &m.sample_ms },
            |m: &mut App| { &mut m.sample_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &App| { &m.visibility },
            |m: &mut App| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_tier_id",
            |m: &App| { &m.data_tier_id },
            |m: &mut App| { &mut m.data_tier_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_starred",
            |m: &App| { &m.is_starred },
            |m: &mut App| { &mut m.is_starred },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "star_count",
            |m: &App| { &m.star_count },
            |m: &mut App| { &mut m.star_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "notes",
            |m: &App| { &m.notes },
            |m: &mut App| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &App| { &m.image },
            |m: &mut App| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::BoolValue>(
            "is_template",
            |m: &App| { &m.is_template },
            |m: &mut App| { &mut m.is_template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppExtraInfo>(
            "extra_info",
            |m: &App| { &m.extra_info },
            |m: &mut App| { &mut m.extra_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<App>(
            "App",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for App {
    const NAME: &'static str = "App";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.default_language = is.read_string()?;
                },
                34 => {
                    self.default_workflow_id = is.read_string()?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_workflow)?;
                },
                42 => {
                    self.user_id = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                56 => {
                    self.legal_consent_status = is.read_uint32()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                114 => {
                    self.description = is.read_string()?;
                },
                120 => {
                    self.sample_ms = is.read_uint32()?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                146 => {
                    self.data_tier_id = is.read_string()?;
                },
                152 => {
                    self.is_starred = is.read_bool()?;
                },
                160 => {
                    self.star_count = is.read_int32()?;
                },
                170 => {
                    self.notes = is.read_string()?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.is_template)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extra_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.default_language.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.default_language);
        }
        if !self.default_workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.default_workflow_id);
        }
        if let Some(v) = self.default_workflow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.legal_consent_status != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.legal_consent_status);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.description);
        }
        if self.sample_ms != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.sample_ms);
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.data_tier_id.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.data_tier_id);
        }
        if self.is_starred != false {
            my_size += 2 + 1;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::int32_size(20, self.star_count);
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.notes);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.is_template.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.extra_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.default_language.is_empty() {
            os.write_string(3, &self.default_language)?;
        }
        if !self.default_workflow_id.is_empty() {
            os.write_string(4, &self.default_workflow_id)?;
        }
        if let Some(v) = self.default_workflow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(5, &self.user_id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if self.legal_consent_status != 0 {
            os.write_uint32(7, self.legal_consent_status)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if !self.description.is_empty() {
            os.write_string(14, &self.description)?;
        }
        if self.sample_ms != 0 {
            os.write_uint32(15, self.sample_ms)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if !self.data_tier_id.is_empty() {
            os.write_string(18, &self.data_tier_id)?;
        }
        if self.is_starred != false {
            os.write_bool(19, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(20, self.star_count)?;
        }
        if !self.notes.is_empty() {
            os.write_string(21, &self.notes)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.is_template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.extra_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> App {
        App::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.default_language.clear();
        self.default_workflow_id.clear();
        self.default_workflow.clear();
        self.user_id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.legal_consent_status = 0;
        self.metadata.clear();
        self.description.clear();
        self.sample_ms = 0;
        self.visibility.clear();
        self.data_tier_id.clear();
        self.is_starred = false;
        self.star_count = 0;
        self.notes.clear();
        self.image.clear();
        self.is_template.clear();
        self.extra_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static App {
        static instance: App = App {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            default_language: ::std::string::String::new(),
            default_workflow_id: ::std::string::String::new(),
            default_workflow: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            legal_consent_status: 0,
            metadata: ::protobuf::MessageField::none(),
            description: ::std::string::String::new(),
            sample_ms: 0,
            visibility: ::protobuf::MessageField::none(),
            data_tier_id: ::std::string::String::new(),
            is_starred: false,
            star_count: 0,
            notes: ::std::string::String::new(),
            image: ::protobuf::MessageField::none(),
            is_template: ::protobuf::MessageField::none(),
            extra_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for App {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("App").unwrap()).clone()
    }
}

impl ::std::fmt::Display for App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for App {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.AppExtraInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AppExtraInfo {
    // message fields
    ///  Revision marker for this application.
    ///  The value of the revision changes when
    ///  * inputs are added, updated or deleted
    ///  * annotations are added, updated or deleted
    ///  * inputs are added to or removed from datasets
    ///  For example, this value can be used to detect if client side caches related to searching should be invalidated.
    ///  Field not filled in for list endpoints, use GetApp
    // @@protoc_insertion_point(field:clarifai.api.AppExtraInfo.search_revision_marker)
    pub search_revision_marker: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.AppExtraInfo.counts)
    pub counts: ::protobuf::MessageField<AppResourceCounts>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AppExtraInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppExtraInfo {
    fn default() -> &'a AppExtraInfo {
        <AppExtraInfo as ::protobuf::Message>::default_instance()
    }
}

impl AppExtraInfo {
    pub fn new() -> AppExtraInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search_revision_marker",
            |m: &AppExtraInfo| { &m.search_revision_marker },
            |m: &mut AppExtraInfo| { &mut m.search_revision_marker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppResourceCounts>(
            "counts",
            |m: &AppExtraInfo| { &m.counts },
            |m: &mut AppExtraInfo| { &mut m.counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppExtraInfo>(
            "AppExtraInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppExtraInfo {
    const NAME: &'static str = "AppExtraInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.search_revision_marker = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.counts)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.search_revision_marker.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.search_revision_marker);
        }
        if let Some(v) = self.counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.search_revision_marker.is_empty() {
            os.write_string(1, &self.search_revision_marker)?;
        }
        if let Some(v) = self.counts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppExtraInfo {
        AppExtraInfo::new()
    }

    fn clear(&mut self) {
        self.search_revision_marker.clear();
        self.counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppExtraInfo {
        static instance: AppExtraInfo = AppExtraInfo {
            search_revision_marker: ::std::string::String::new(),
            counts: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppExtraInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppExtraInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppExtraInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppExtraInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  App query
// @@protoc_insertion_point(message:clarifai.api.AppQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AppQuery {
    // message fields
    ///  Query by application name. This supports wildcard queries like "gen*" to match "general" as an example.
    // @@protoc_insertion_point(field:clarifai.api.AppQuery.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AppQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppQuery {
    fn default() -> &'a AppQuery {
        <AppQuery as ::protobuf::Message>::default_instance()
    }
}

impl AppQuery {
    pub fn new() -> AppQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AppQuery| { &m.name },
            |m: &mut AppQuery| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppQuery>(
            "AppQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppQuery {
    const NAME: &'static str = "AppQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppQuery {
        AppQuery::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppQuery {
        static instance: AppQuery = AppQuery {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.AppResourceCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AppResourceCounts {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.AppResourceCounts.datasets)
    pub datasets: i64,
    // @@protoc_insertion_point(field:clarifai.api.AppResourceCounts.models)
    pub models: i64,
    // @@protoc_insertion_point(field:clarifai.api.AppResourceCounts.workflows)
    pub workflows: i64,
    // @@protoc_insertion_point(field:clarifai.api.AppResourceCounts.modules)
    pub modules: i64,
    // @@protoc_insertion_point(field:clarifai.api.AppResourceCounts.inputs)
    pub inputs: i64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AppResourceCounts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppResourceCounts {
    fn default() -> &'a AppResourceCounts {
        <AppResourceCounts as ::protobuf::Message>::default_instance()
    }
}

impl AppResourceCounts {
    pub fn new() -> AppResourceCounts {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "datasets",
            |m: &AppResourceCounts| { &m.datasets },
            |m: &mut AppResourceCounts| { &mut m.datasets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "models",
            |m: &AppResourceCounts| { &m.models },
            |m: &mut AppResourceCounts| { &mut m.models },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflows",
            |m: &AppResourceCounts| { &m.workflows },
            |m: &mut AppResourceCounts| { &mut m.workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modules",
            |m: &AppResourceCounts| { &m.modules },
            |m: &mut AppResourceCounts| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs",
            |m: &AppResourceCounts| { &m.inputs },
            |m: &mut AppResourceCounts| { &mut m.inputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppResourceCounts>(
            "AppResourceCounts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppResourceCounts {
    const NAME: &'static str = "AppResourceCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.datasets = is.read_int64()?;
                },
                16 => {
                    self.models = is.read_int64()?;
                },
                24 => {
                    self.workflows = is.read_int64()?;
                },
                32 => {
                    self.modules = is.read_int64()?;
                },
                40 => {
                    self.inputs = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.datasets != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.datasets);
        }
        if self.models != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.models);
        }
        if self.workflows != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.workflows);
        }
        if self.modules != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.modules);
        }
        if self.inputs != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.inputs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.datasets != 0 {
            os.write_int64(1, self.datasets)?;
        }
        if self.models != 0 {
            os.write_int64(2, self.models)?;
        }
        if self.workflows != 0 {
            os.write_int64(3, self.workflows)?;
        }
        if self.modules != 0 {
            os.write_int64(4, self.modules)?;
        }
        if self.inputs != 0 {
            os.write_int64(5, self.inputs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppResourceCounts {
        AppResourceCounts::new()
    }

    fn clear(&mut self) {
        self.datasets = 0;
        self.models = 0;
        self.workflows = 0;
        self.modules = 0;
        self.inputs = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppResourceCounts {
        static instance: AppResourceCounts = AppResourceCounts {
            datasets: 0,
            models: 0,
            workflows: 0,
            modules: 0,
            inputs: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppResourceCounts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppResourceCounts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppResourceCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppResourceCounts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Collaborator - invited user, who shares an access to an application
// @@protoc_insertion_point(message:clarifai.api.Collaborator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Collaborator {
    // message fields
    ///  id of this collaborator
    // @@protoc_insertion_point(field:clarifai.api.Collaborator.id)
    pub id: ::std::string::String,
    ///  the app this collaborator has access to
    ///  FIXME(zeiler): this should be in the user_app_id.app_id already from the endpoint.
    // @@protoc_insertion_point(field:clarifai.api.Collaborator.app)
    pub app: ::protobuf::MessageField<App>,
    ///  who is this collaborator
    // @@protoc_insertion_point(field:clarifai.api.Collaborator.user)
    pub user: ::protobuf::MessageField<User>,
    ///  the permission this collaborator
    // @@protoc_insertion_point(field:clarifai.api.Collaborator.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.Collaborator.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    ///  When the app was shared with. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.Collaborator.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the collaborator was updated.
    // @@protoc_insertion_point(field:clarifai.api.Collaborator.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the collaborator was removed from app.
    // @@protoc_insertion_point(field:clarifai.api.Collaborator.deleted_at)
    pub deleted_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Collaborator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Collaborator {
    fn default() -> &'a Collaborator {
        <Collaborator as ::protobuf::Message>::default_instance()
    }
}

impl Collaborator {
    pub fn new() -> Collaborator {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Collaborator| { &m.id },
            |m: &mut Collaborator| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, App>(
            "app",
            |m: &Collaborator| { &m.app },
            |m: &mut Collaborator| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "user",
            |m: &Collaborator| { &m.user },
            |m: &mut Collaborator| { &mut m.user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &Collaborator| { &m.scopes },
            |m: &mut Collaborator| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &Collaborator| { &m.endpoints },
            |m: &mut Collaborator| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Collaborator| { &m.created_at },
            |m: &mut Collaborator| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Collaborator| { &m.modified_at },
            |m: &mut Collaborator| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "deleted_at",
            |m: &Collaborator| { &m.deleted_at },
            |m: &mut Collaborator| { &mut m.deleted_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Collaborator>(
            "Collaborator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Collaborator {
    const NAME: &'static str = "Collaborator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                34 => {
                    self.scopes.push(is.read_string()?);
                },
                42 => {
                    self.endpoints.push(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deleted_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deleted_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(4, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.deleted_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Collaborator {
        Collaborator::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.app.clear();
        self.user.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.deleted_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Collaborator {
        static instance: Collaborator = Collaborator {
            id: ::std::string::String::new(),
            app: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            deleted_at: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Collaborator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Collaborator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Collaborator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collaborator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  collaboration includes an app you're invited to work on.
// @@protoc_insertion_point(message:clarifai.api.Collaboration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Collaboration {
    // message fields
    ///  the application
    // @@protoc_insertion_point(field:clarifai.api.Collaboration.app)
    pub app: ::protobuf::MessageField<App>,
    ///  the app owner's info(including user_unique_id, first_name, last_name, primary_email)
    // @@protoc_insertion_point(field:clarifai.api.Collaboration.app_owner)
    pub app_owner: ::protobuf::MessageField<User>,
    ///  the low-level scope users are shared with for this collaboration
    // @@protoc_insertion_point(field:clarifai.api.Collaboration.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  the endpoint-level scopes users are shared with for this collaboration
    // @@protoc_insertion_point(field:clarifai.api.Collaboration.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    ///  when is the collaboration created
    // @@protoc_insertion_point(field:clarifai.api.Collaboration.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Collaboration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Collaboration {
    fn default() -> &'a Collaboration {
        <Collaboration as ::protobuf::Message>::default_instance()
    }
}

impl Collaboration {
    pub fn new() -> Collaboration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, App>(
            "app",
            |m: &Collaboration| { &m.app },
            |m: &mut Collaboration| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, User>(
            "app_owner",
            |m: &Collaboration| { &m.app_owner },
            |m: &mut Collaboration| { &mut m.app_owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &Collaboration| { &m.scopes },
            |m: &mut Collaboration| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &Collaboration| { &m.endpoints },
            |m: &mut Collaboration| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Collaboration| { &m.created_at },
            |m: &mut Collaboration| { &mut m.created_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Collaboration>(
            "Collaboration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Collaboration {
    const NAME: &'static str = "Collaboration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_owner)?;
                },
                26 => {
                    self.scopes.push(is.read_string()?);
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app_owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app_owner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(3, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Collaboration {
        Collaboration::new()
    }

    fn clear(&mut self) {
        self.app.clear();
        self.app_owner.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.created_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Collaboration {
        static instance: Collaboration = Collaboration {
            app: ::protobuf::MessageField::none(),
            app_owner: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            created_at: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Collaboration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Collaboration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Collaboration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collaboration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Audio asset struct
// @@protoc_insertion_point(message:clarifai.api.Audio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Audio {
    // message fields
    ///  This is a URL to a publicly accessible image file. The platform will download this file server
    ///  side and then process.
    // @@protoc_insertion_point(field:clarifai.api.Audio.url)
    pub url: ::std::string::String,
    ///  The base64 field is using image file bytes directly in the request.
    ///  NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
    ///  the name here).
    ///  When using our grpc clients, you DO NOT need to base64 encode
    ///  it yourself since the clients know how to do this for you automatically and will avoid the
    ///  base64 encoding if they send a binary request.
    // @@protoc_insertion_point(field:clarifai.api.Audio.base64)
    pub base64: ::std::vec::Vec<u8>,
    ///  If True then you will be allowed to have multiple urls.
    // @@protoc_insertion_point(field:clarifai.api.Audio.allow_duplicate_url)
    pub allow_duplicate_url: bool,
    ///  The hosted field lists original audio hosted in Clarifai storage. This field is currently used
    ///  only in response.
    // @@protoc_insertion_point(field:clarifai.api.Audio.hosted)
    pub hosted: ::protobuf::MessageField<HostedURL>,
    ///  audio info
    // @@protoc_insertion_point(field:clarifai.api.Audio.audio_info)
    pub audio_info: ::protobuf::MessageField<AudioInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Audio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Audio {
    fn default() -> &'a Audio {
        <Audio as ::protobuf::Message>::default_instance()
    }
}

impl Audio {
    pub fn new() -> Audio {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Audio| { &m.url },
            |m: &mut Audio| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "base64",
            |m: &Audio| { &m.base64 },
            |m: &mut Audio| { &mut m.base64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_duplicate_url",
            |m: &Audio| { &m.allow_duplicate_url },
            |m: &mut Audio| { &mut m.allow_duplicate_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HostedURL>(
            "hosted",
            |m: &Audio| { &m.hosted },
            |m: &mut Audio| { &mut m.hosted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AudioInfo>(
            "audio_info",
            |m: &Audio| { &m.audio_info },
            |m: &mut Audio| { &mut m.audio_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Audio>(
            "Audio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Audio {
    const NAME: &'static str = "Audio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                18 => {
                    self.base64 = is.read_bytes()?;
                },
                32 => {
                    self.allow_duplicate_url = is.read_bool()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hosted)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.base64.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.base64);
        }
        if self.allow_duplicate_url != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hosted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.audio_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.base64.is_empty() {
            os.write_bytes(2, &self.base64)?;
        }
        if self.allow_duplicate_url != false {
            os.write_bool(4, self.allow_duplicate_url)?;
        }
        if let Some(v) = self.hosted.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.audio_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Audio {
        Audio::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.base64.clear();
        self.allow_duplicate_url = false;
        self.hosted.clear();
        self.audio_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Audio {
        static instance: Audio = Audio {
            url: ::std::string::String::new(),
            base64: ::std::vec::Vec::new(),
            allow_duplicate_url: false,
            hosted: ::protobuf::MessageField::none(),
            audio_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Audio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Audio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Audio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Audio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.AudioInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioInfo {
    // message fields
    ///  audio format
    // @@protoc_insertion_point(field:clarifai.api.AudioInfo.audio_format)
    pub audio_format: ::std::string::String,
    ///  sample rate
    // @@protoc_insertion_point(field:clarifai.api.AudioInfo.sample_rate)
    pub sample_rate: i32,
    ///  audio track duration in seconds
    // @@protoc_insertion_point(field:clarifai.api.AudioInfo.duration_seconds)
    pub duration_seconds: f32,
    ///  audio track bit rate
    // @@protoc_insertion_point(field:clarifai.api.AudioInfo.bit_rate)
    pub bit_rate: i32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AudioInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioInfo {
    fn default() -> &'a AudioInfo {
        <AudioInfo as ::protobuf::Message>::default_instance()
    }
}

impl AudioInfo {
    pub fn new() -> AudioInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "audio_format",
            |m: &AudioInfo| { &m.audio_format },
            |m: &mut AudioInfo| { &mut m.audio_format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_rate",
            |m: &AudioInfo| { &m.sample_rate },
            |m: &mut AudioInfo| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration_seconds",
            |m: &AudioInfo| { &m.duration_seconds },
            |m: &mut AudioInfo| { &mut m.duration_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bit_rate",
            |m: &AudioInfo| { &m.bit_rate },
            |m: &mut AudioInfo| { &mut m.bit_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioInfo>(
            "AudioInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioInfo {
    const NAME: &'static str = "AudioInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.audio_format = is.read_string()?;
                },
                16 => {
                    self.sample_rate = is.read_int32()?;
                },
                29 => {
                    self.duration_seconds = is.read_float()?;
                },
                32 => {
                    self.bit_rate = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.audio_format.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.audio_format);
        }
        if self.sample_rate != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.sample_rate);
        }
        if self.duration_seconds != 0. {
            my_size += 1 + 4;
        }
        if self.bit_rate != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.bit_rate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.audio_format.is_empty() {
            os.write_string(1, &self.audio_format)?;
        }
        if self.sample_rate != 0 {
            os.write_int32(2, self.sample_rate)?;
        }
        if self.duration_seconds != 0. {
            os.write_float(3, self.duration_seconds)?;
        }
        if self.bit_rate != 0 {
            os.write_int32(4, self.bit_rate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioInfo {
        AudioInfo::new()
    }

    fn clear(&mut self) {
        self.audio_format.clear();
        self.sample_rate = 0;
        self.duration_seconds = 0.;
        self.bit_rate = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioInfo {
        static instance: AudioInfo = AudioInfo {
            audio_format: ::std::string::String::new(),
            sample_rate: 0,
            duration_seconds: 0.,
            bit_rate: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Track proto encodes information of a track over a number of frames
// @@protoc_insertion_point(message:clarifai.api.Track)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Track {
    // message fields
    ///  track id
    // @@protoc_insertion_point(field:clarifai.api.Track.id)
    pub id: ::std::string::String,
    ///  This is a recursive definition which can contain all the concepts,
    ///  embeddings, etc. that are computed within this track.
    // @@protoc_insertion_point(field:clarifai.api.Track.data)
    pub data: ::protobuf::MessageField<Data>,
    // @@protoc_insertion_point(field:clarifai.api.Track.time_info)
    pub time_info: ::protobuf::MessageField<TimeInfo>,
    // @@protoc_insertion_point(field:clarifai.api.Track.quality)
    pub quality: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Track.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Track {
    fn default() -> &'a Track {
        <Track as ::protobuf::Message>::default_instance()
    }
}

impl Track {
    pub fn new() -> Track {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Track| { &m.id },
            |m: &mut Track| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &Track| { &m.data },
            |m: &mut Track| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TimeInfo>(
            "time_info",
            |m: &Track| { &m.time_info },
            |m: &mut Track| { &mut m.time_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "quality",
            |m: &Track| { &m.quality },
            |m: &mut Track| { &mut m.quality },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Track>(
            "Track",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Track {
    const NAME: &'static str = "Track";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time_info)?;
                },
                45 => {
                    self.quality = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.quality != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.time_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.quality != 0. {
            os.write_float(5, self.quality)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Track {
        Track::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.data.clear();
        self.time_info.clear();
        self.quality = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Track {
        static instance: Track = Track {
            id: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            time_info: ::protobuf::MessageField::none(),
            quality: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Track {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Track").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Track {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Track {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Cluster data
// @@protoc_insertion_point(message:clarifai.api.Cluster)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Cluster {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.Cluster.id)
    pub id: ::std::string::String,
    ///  Number of annotations tied to the cluster in the app
    // @@protoc_insertion_point(field:clarifai.api.Cluster.count)
    pub count: u32,
    ///  The score assigned to this cluster.
    ///  For List Clusters endpoint, this represents percentage of inputs in the app assigned to this cluster.
    // @@protoc_insertion_point(field:clarifai.api.Cluster.score)
    pub score: f32,
    ///  Representative hits for cluster (for now we only return 1)
    // @@protoc_insertion_point(field:clarifai.api.Cluster.hits)
    pub hits: ::std::vec::Vec<Hit>,
    // @@protoc_insertion_point(field:clarifai.api.Cluster.projection)
    pub projection: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Cluster.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cluster {
    fn default() -> &'a Cluster {
        <Cluster as ::protobuf::Message>::default_instance()
    }
}

impl Cluster {
    pub fn new() -> Cluster {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Cluster| { &m.id },
            |m: &mut Cluster| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &Cluster| { &m.count },
            |m: &mut Cluster| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score",
            |m: &Cluster| { &m.score },
            |m: &mut Cluster| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hits",
            |m: &Cluster| { &m.hits },
            |m: &mut Cluster| { &mut m.hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "projection",
            |m: &Cluster| { &m.projection },
            |m: &mut Cluster| { &mut m.projection },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cluster>(
            "Cluster",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cluster {
    const NAME: &'static str = "Cluster";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.count = is.read_uint32()?;
                },
                29 => {
                    self.score = is.read_float()?;
                },
                34 => {
                    self.hits.push(is.read_message()?);
                },
                42 => {
                    is.read_repeated_packed_float_into(&mut self.projection)?;
                },
                45 => {
                    self.projection.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.count);
        }
        if self.score != 0. {
            my_size += 1 + 4;
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 5 * self.projection.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.count != 0 {
            os.write_uint32(2, self.count)?;
        }
        if self.score != 0. {
            os.write_float(3, self.score)?;
        }
        for v in &self.hits {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.projection {
            os.write_float(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cluster {
        Cluster::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.count = 0;
        self.score = 0.;
        self.hits.clear();
        self.projection.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cluster {
        static instance: Cluster = Cluster {
            id: ::std::string::String::new(),
            count: 0,
            score: 0.,
            hits: ::std::vec::Vec::new(),
            projection: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Cluster {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cluster").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Color data
// @@protoc_insertion_point(message:clarifai.api.Color)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Color {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.Color.raw_hex)
    pub raw_hex: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.Color.w3c)
    pub w3c: ::protobuf::MessageField<W3C>,
    // @@protoc_insertion_point(field:clarifai.api.Color.value)
    pub value: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Color.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Color {
    fn default() -> &'a Color {
        <Color as ::protobuf::Message>::default_instance()
    }
}

impl Color {
    pub fn new() -> Color {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "raw_hex",
            |m: &Color| { &m.raw_hex },
            |m: &mut Color| { &mut m.raw_hex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, W3C>(
            "w3c",
            |m: &Color| { &m.w3c },
            |m: &mut Color| { &mut m.w3c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Color| { &m.value },
            |m: &mut Color| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Color>(
            "Color",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Color {
    const NAME: &'static str = "Color";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.raw_hex = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.w3c)?;
                },
                29 => {
                    self.value = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.raw_hex.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.raw_hex);
        }
        if let Some(v) = self.w3c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.value != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.raw_hex.is_empty() {
            os.write_string(1, &self.raw_hex)?;
        }
        if let Some(v) = self.w3c.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.value != 0. {
            os.write_float(3, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Color {
        Color::new()
    }

    fn clear(&mut self) {
        self.raw_hex.clear();
        self.w3c.clear();
        self.value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Color {
        static instance: Color = Color {
            raw_hex: ::std::string::String::new(),
            w3c: ::protobuf::MessageField::none(),
            value: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Color {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Color").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Color {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Color {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.W3C)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct W3C {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.W3C.hex)
    pub hex: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.W3C.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.W3C.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a W3C {
    fn default() -> &'a W3C {
        <W3C as ::protobuf::Message>::default_instance()
    }
}

impl W3C {
    pub fn new() -> W3C {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hex",
            |m: &W3C| { &m.hex },
            |m: &mut W3C| { &mut m.hex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &W3C| { &m.name },
            |m: &mut W3C| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<W3C>(
            "W3C",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for W3C {
    const NAME: &'static str = "W3C";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hex = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hex.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hex);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hex.is_empty() {
            os.write_string(1, &self.hex)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> W3C {
        W3C::new()
    }

    fn clear(&mut self) {
        self.hex.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static W3C {
        static instance: W3C = W3C {
            hex: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for W3C {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("W3C").unwrap()).clone()
    }
}

impl ::std::fmt::Display for W3C {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for W3C {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Common message to identify the app in a url endpoint.
// @@protoc_insertion_point(message:clarifai.api.UserAppIDSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserAppIDSet {
    // message fields
    ///  Note user_id 'me' is reserved - it is the alias for the id of authorized user
    // @@protoc_insertion_point(field:clarifai.api.UserAppIDSet.user_id)
    pub user_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.UserAppIDSet.app_id)
    pub app_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.UserAppIDSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAppIDSet {
    fn default() -> &'a UserAppIDSet {
        <UserAppIDSet as ::protobuf::Message>::default_instance()
    }
}

impl UserAppIDSet {
    pub fn new() -> UserAppIDSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &UserAppIDSet| { &m.user_id },
            |m: &mut UserAppIDSet| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &UserAppIDSet| { &m.app_id },
            |m: &mut UserAppIDSet| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAppIDSet>(
            "UserAppIDSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAppIDSet {
    const NAME: &'static str = "UserAppIDSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.user_id = is.read_string()?;
                },
                18 => {
                    self.app_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAppIDSet {
        UserAppIDSet::new()
    }

    fn clear(&mut self) {
        self.user_id.clear();
        self.app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAppIDSet {
        static instance: UserAppIDSet = UserAppIDSet {
            user_id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAppIDSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAppIDSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAppIDSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAppIDSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAction
// @@protoc_insertion_point(message:clarifai.api.PatchAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAction {
    // message fields
    ///  The operation to perform on the patched metadata given a path
    ///  For now only operations 'overwrite', 'delete, and 'merge' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAction.op)
    pub op: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchAction.merge_conflict_resolution)
    pub merge_conflict_resolution: ::std::string::String,
    ///  Path for the change. For example 'tag[1].data' is a valid path in above example.
    ///  Default path is root level i.e. ''.
    // @@protoc_insertion_point(field:clarifai.api.PatchAction.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAction {
    fn default() -> &'a PatchAction {
        <PatchAction as ::protobuf::Message>::default_instance()
    }
}

impl PatchAction {
    pub fn new() -> PatchAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "op",
            |m: &PatchAction| { &m.op },
            |m: &mut PatchAction| { &mut m.op },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "merge_conflict_resolution",
            |m: &PatchAction| { &m.merge_conflict_resolution },
            |m: &mut PatchAction| { &mut m.merge_conflict_resolution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &PatchAction| { &m.path },
            |m: &mut PatchAction| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAction>(
            "PatchAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAction {
    const NAME: &'static str = "PatchAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.op = is.read_string()?;
                },
                18 => {
                    self.merge_conflict_resolution = is.read_string()?;
                },
                26 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.op);
        }
        if !self.merge_conflict_resolution.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.merge_conflict_resolution);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.op.is_empty() {
            os.write_string(1, &self.op)?;
        }
        if !self.merge_conflict_resolution.is_empty() {
            os.write_string(2, &self.merge_conflict_resolution)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAction {
        PatchAction::new()
    }

    fn clear(&mut self) {
        self.op.clear();
        self.merge_conflict_resolution.clear();
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAction {
        static instance: PatchAction = PatchAction {
            op: ::std::string::String::new(),
            merge_conflict_resolution: ::std::string::String::new(),
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Concept or tag
// @@protoc_insertion_point(message:clarifai.api.Concept)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Concept {
    // message fields
    ///  The concept's unique id.
    // @@protoc_insertion_point(field:clarifai.api.Concept.id)
    pub id: ::std::string::String,
    ///  The name of the concept in the given language.
    // @@protoc_insertion_point(field:clarifai.api.Concept.name)
    pub name: ::std::string::String,
    ///  Used to indicate presence (1.0) or not (0.0) of this concept when making a request.
    ///  This is also the prediction probability when returning predictions from our API.
    ///  For convenience we use the default of 1.0 when making requests so the concept you provide is
    ///  is treated as a positive (1.0) and not a negative (which would be value == 0.0).
    // @@protoc_insertion_point(field:clarifai.api.Concept.value)
    pub value: f32,
    ///  When the concept was created. The format is https://www.ietf.org/rfc/rfc3339.txt .
    ///  Example: "2006-01-02T15:04:05.999999Z". This field is used only in a response.
    // @@protoc_insertion_point(field:clarifai.api.Concept.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The language in which the concept name is in. This is *ONLY* used in the response and setting
    ///  it in a request is ignored since the default language of your app is used when creating
    ///  or patching a Concept. To set other languages for your concept use the ConceptLanguage object
    ///  and its corresponding endpoints.
    // @@protoc_insertion_point(field:clarifai.api.Concept.language)
    pub language: ::std::string::String,
    ///  The application id that this concept is within. This can be ignored by most users.
    // @@protoc_insertion_point(field:clarifai.api.Concept.app_id)
    pub app_id: ::std::string::String,
    ///  The definition for the concept. Similar to name. This can be ignored by most users.
    // @@protoc_insertion_point(field:clarifai.api.Concept.definition)
    pub definition: ::std::string::String,
    ///  The vocabulary that this concept belongs to. This is useful if you have different unique sets
    ///  of concepts that you can separate out based on this field. For example "age_appearance" vs
    ///  "gender_appearance" in a list of concept returned from the demographics model.
    // @@protoc_insertion_point(field:clarifai.api.Concept.vocab_id)
    pub vocab_id: ::std::string::String,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.Concept.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  The user the concept belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Concept.user_id)
    pub user_id: ::std::string::String,
    ///  Information about keypoints for this concept
    // @@protoc_insertion_point(field:clarifai.api.Concept.keypoint_info)
    pub keypoint_info: ::protobuf::MessageField<KeypointInfo>,
    ///  Optional extra info.
    // @@protoc_insertion_point(field:clarifai.api.Concept.extra_info)
    pub extra_info: ::protobuf::MessageField<ConceptExtraInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Concept.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Concept {
    fn default() -> &'a Concept {
        <Concept as ::protobuf::Message>::default_instance()
    }
}

impl Concept {
    pub fn new() -> Concept {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Concept| { &m.id },
            |m: &mut Concept| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Concept| { &m.name },
            |m: &mut Concept| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Concept| { &m.value },
            |m: &mut Concept| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Concept| { &m.created_at },
            |m: &mut Concept| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &Concept| { &m.language },
            |m: &mut Concept| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &Concept| { &m.app_id },
            |m: &mut Concept| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "definition",
            |m: &Concept| { &m.definition },
            |m: &mut Concept| { &mut m.definition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vocab_id",
            |m: &Concept| { &m.vocab_id },
            |m: &mut Concept| { &mut m.vocab_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &Concept| { &m.visibility },
            |m: &mut Concept| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Concept| { &m.user_id },
            |m: &mut Concept| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeypointInfo>(
            "keypoint_info",
            |m: &Concept| { &m.keypoint_info },
            |m: &mut Concept| { &mut m.keypoint_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptExtraInfo>(
            "extra_info",
            |m: &Concept| { &m.extra_info },
            |m: &mut Concept| { &mut m.extra_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Concept>(
            "Concept",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Concept {
    const NAME: &'static str = "Concept";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                29 => {
                    self.value = is.read_float()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                42 => {
                    self.language = is.read_string()?;
                },
                50 => {
                    self.app_id = is.read_string()?;
                },
                58 => {
                    self.definition = is.read_string()?;
                },
                66 => {
                    self.vocab_id = is.read_string()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                82 => {
                    self.user_id = is.read_string()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keypoint_info)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extra_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.value != 0. {
            my_size += 1 + 4;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.language);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.app_id);
        }
        if !self.definition.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.definition);
        }
        if !self.vocab_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.vocab_id);
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.user_id);
        }
        if let Some(v) = self.keypoint_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.extra_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.value != 0. {
            os.write_float(3, self.value)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.language.is_empty() {
            os.write_string(5, &self.language)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(6, &self.app_id)?;
        }
        if !self.definition.is_empty() {
            os.write_string(7, &self.definition)?;
        }
        if !self.vocab_id.is_empty() {
            os.write_string(8, &self.vocab_id)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(10, &self.user_id)?;
        }
        if let Some(v) = self.keypoint_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.extra_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Concept {
        Concept::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.value = 0.;
        self.created_at.clear();
        self.language.clear();
        self.app_id.clear();
        self.definition.clear();
        self.vocab_id.clear();
        self.visibility.clear();
        self.user_id.clear();
        self.keypoint_info.clear();
        self.extra_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Concept {
        static instance: Concept = Concept {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            value: 0.,
            created_at: ::protobuf::MessageField::none(),
            language: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            definition: ::std::string::String::new(),
            vocab_id: ::std::string::String::new(),
            visibility: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            keypoint_info: ::protobuf::MessageField::none(),
            extra_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Concept {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Concept").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Concept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Concept {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.KeypointInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeypointInfo {
    // message fields
    ///  Names of the keypoints
    // @@protoc_insertion_point(field:clarifai.api.KeypointInfo.keypoint_names)
    pub keypoint_names: ::std::vec::Vec<::std::string::String>,
    ///  Defines the connections between keypoint_names. Each value represents the index in keypoint_names.
    // @@protoc_insertion_point(field:clarifai.api.KeypointInfo.skeleton)
    pub skeleton: ::std::vec::Vec<KeypointEdge>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.KeypointInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeypointInfo {
    fn default() -> &'a KeypointInfo {
        <KeypointInfo as ::protobuf::Message>::default_instance()
    }
}

impl KeypointInfo {
    pub fn new() -> KeypointInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keypoint_names",
            |m: &KeypointInfo| { &m.keypoint_names },
            |m: &mut KeypointInfo| { &mut m.keypoint_names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "skeleton",
            |m: &KeypointInfo| { &m.skeleton },
            |m: &mut KeypointInfo| { &mut m.skeleton },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeypointInfo>(
            "KeypointInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeypointInfo {
    const NAME: &'static str = "KeypointInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keypoint_names.push(is.read_string()?);
                },
                18 => {
                    self.skeleton.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.keypoint_names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.skeleton {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.keypoint_names {
            os.write_string(1, &v)?;
        };
        for v in &self.skeleton {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeypointInfo {
        KeypointInfo::new()
    }

    fn clear(&mut self) {
        self.keypoint_names.clear();
        self.skeleton.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeypointInfo {
        static instance: KeypointInfo = KeypointInfo {
            keypoint_names: ::std::vec::Vec::new(),
            skeleton: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeypointInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeypointInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeypointInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeypointInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.KeypointEdge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeypointEdge {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.KeypointEdge.k1)
    pub k1: u32,
    // @@protoc_insertion_point(field:clarifai.api.KeypointEdge.k2)
    pub k2: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.KeypointEdge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeypointEdge {
    fn default() -> &'a KeypointEdge {
        <KeypointEdge as ::protobuf::Message>::default_instance()
    }
}

impl KeypointEdge {
    pub fn new() -> KeypointEdge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "k1",
            |m: &KeypointEdge| { &m.k1 },
            |m: &mut KeypointEdge| { &mut m.k1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "k2",
            |m: &KeypointEdge| { &m.k2 },
            |m: &mut KeypointEdge| { &mut m.k2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeypointEdge>(
            "KeypointEdge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeypointEdge {
    const NAME: &'static str = "KeypointEdge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.k1 = is.read_uint32()?;
                },
                16 => {
                    self.k2 = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.k1 != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.k1);
        }
        if self.k2 != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.k2);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.k1 != 0 {
            os.write_uint32(1, self.k1)?;
        }
        if self.k2 != 0 {
            os.write_uint32(2, self.k2)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeypointEdge {
        KeypointEdge::new()
    }

    fn clear(&mut self) {
        self.k1 = 0;
        self.k2 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeypointEdge {
        static instance: KeypointEdge = KeypointEdge {
            k1: 0,
            k2: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeypointEdge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeypointEdge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeypointEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeypointEdge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConceptExtraInfo represents extra information related to a concept that is context-dependent.
///  It is only set when requested in ConceptExtraInfoRequest.
// @@protoc_insertion_point(message:clarifai.api.ConceptExtraInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptExtraInfo {
    // message fields
    ///  Whether this concept is rankable based on ConceptExtraInfoRequest configuration.
    // @@protoc_insertion_point(field:clarifai.api.ConceptExtraInfo.is_rankable)
    pub is_rankable: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptExtraInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptExtraInfo {
    fn default() -> &'a ConceptExtraInfo {
        <ConceptExtraInfo as ::protobuf::Message>::default_instance()
    }
}

impl ConceptExtraInfo {
    pub fn new() -> ConceptExtraInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_rankable",
            |m: &ConceptExtraInfo| { &m.is_rankable },
            |m: &mut ConceptExtraInfo| { &mut m.is_rankable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptExtraInfo>(
            "ConceptExtraInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptExtraInfo {
    const NAME: &'static str = "ConceptExtraInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_rankable = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_rankable != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_rankable != false {
            os.write_bool(1, self.is_rankable)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptExtraInfo {
        ConceptExtraInfo::new()
    }

    fn clear(&mut self) {
        self.is_rankable = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptExtraInfo {
        static instance: ConceptExtraInfo = ConceptExtraInfo {
            is_rankable: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptExtraInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptExtraInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptExtraInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptExtraInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConceptCount
// @@protoc_insertion_point(message:clarifai.api.ConceptCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptCount {
    // message fields
    ///  The concept's unique id.
    // @@protoc_insertion_point(field:clarifai.api.ConceptCount.id)
    pub id: ::std::string::String,
    ///  The name of the concept.
    // @@protoc_insertion_point(field:clarifai.api.ConceptCount.name)
    pub name: ::std::string::String,
    ///  The total count for concepts labeled for all asset statues (processing, to_process, processed, error)
    // @@protoc_insertion_point(field:clarifai.api.ConceptCount.concept_type_count)
    pub concept_type_count: ::protobuf::MessageField<ConceptTypeCount>,
    ///  The detail count for different assets status
    // @@protoc_insertion_point(field:clarifai.api.ConceptCount.detail_concept_count)
    pub detail_concept_count: ::protobuf::MessageField<DetailConceptCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptCount {
    fn default() -> &'a ConceptCount {
        <ConceptCount as ::protobuf::Message>::default_instance()
    }
}

impl ConceptCount {
    pub fn new() -> ConceptCount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ConceptCount| { &m.id },
            |m: &mut ConceptCount| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ConceptCount| { &m.name },
            |m: &mut ConceptCount| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptTypeCount>(
            "concept_type_count",
            |m: &ConceptCount| { &m.concept_type_count },
            |m: &mut ConceptCount| { &mut m.concept_type_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DetailConceptCount>(
            "detail_concept_count",
            |m: &ConceptCount| { &m.detail_concept_count },
            |m: &mut ConceptCount| { &mut m.detail_concept_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptCount>(
            "ConceptCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptCount {
    const NAME: &'static str = "ConceptCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept_type_count)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.detail_concept_count)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(v) = self.concept_type_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.detail_concept_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(v) = self.concept_type_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.detail_concept_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptCount {
        ConceptCount::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.concept_type_count.clear();
        self.detail_concept_count.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptCount {
        static instance: ConceptCount = ConceptCount {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            concept_type_count: ::protobuf::MessageField::none(),
            detail_concept_count: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConceptTypeCount
// @@protoc_insertion_point(message:clarifai.api.ConceptTypeCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptTypeCount {
    // message fields
    ///  The number of inputs that have a concept with a value of 1.0 (indicating presence of the
    ///  concept in an input).
    // @@protoc_insertion_point(field:clarifai.api.ConceptTypeCount.positive)
    pub positive: u32,
    ///  The number of inputs that have a concept with a value of 0.0 (indicating absence of the
    ///  concept in an input).
    // @@protoc_insertion_point(field:clarifai.api.ConceptTypeCount.negative)
    pub negative: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptTypeCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptTypeCount {
    fn default() -> &'a ConceptTypeCount {
        <ConceptTypeCount as ::protobuf::Message>::default_instance()
    }
}

impl ConceptTypeCount {
    pub fn new() -> ConceptTypeCount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "positive",
            |m: &ConceptTypeCount| { &m.positive },
            |m: &mut ConceptTypeCount| { &mut m.positive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "negative",
            |m: &ConceptTypeCount| { &m.negative },
            |m: &mut ConceptTypeCount| { &mut m.negative },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptTypeCount>(
            "ConceptTypeCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptTypeCount {
    const NAME: &'static str = "ConceptTypeCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.positive = is.read_uint32()?;
                },
                16 => {
                    self.negative = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.positive != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.positive);
        }
        if self.negative != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.negative);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.positive != 0 {
            os.write_uint32(1, self.positive)?;
        }
        if self.negative != 0 {
            os.write_uint32(2, self.negative)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptTypeCount {
        ConceptTypeCount::new()
    }

    fn clear(&mut self) {
        self.positive = 0;
        self.negative = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptTypeCount {
        static instance: ConceptTypeCount = ConceptTypeCount {
            positive: 0,
            negative: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptTypeCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptTypeCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptTypeCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptTypeCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DetailConceptCount
// @@protoc_insertion_point(message:clarifai.api.DetailConceptCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DetailConceptCount {
    // message fields
    ///  The concept count for processed assets
    // @@protoc_insertion_point(field:clarifai.api.DetailConceptCount.processed)
    pub processed: ::protobuf::MessageField<ConceptTypeCount>,
    ///  The concept count for to process assets
    // @@protoc_insertion_point(field:clarifai.api.DetailConceptCount.to_process)
    pub to_process: ::protobuf::MessageField<ConceptTypeCount>,
    ///  The concept count for assets with status error
    // @@protoc_insertion_point(field:clarifai.api.DetailConceptCount.errors)
    pub errors: ::protobuf::MessageField<ConceptTypeCount>,
    ///  The concept count for processing assets
    // @@protoc_insertion_point(field:clarifai.api.DetailConceptCount.processing)
    pub processing: ::protobuf::MessageField<ConceptTypeCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DetailConceptCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DetailConceptCount {
    fn default() -> &'a DetailConceptCount {
        <DetailConceptCount as ::protobuf::Message>::default_instance()
    }
}

impl DetailConceptCount {
    pub fn new() -> DetailConceptCount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptTypeCount>(
            "processed",
            |m: &DetailConceptCount| { &m.processed },
            |m: &mut DetailConceptCount| { &mut m.processed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptTypeCount>(
            "to_process",
            |m: &DetailConceptCount| { &m.to_process },
            |m: &mut DetailConceptCount| { &mut m.to_process },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptTypeCount>(
            "errors",
            |m: &DetailConceptCount| { &m.errors },
            |m: &mut DetailConceptCount| { &mut m.errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptTypeCount>(
            "processing",
            |m: &DetailConceptCount| { &m.processing },
            |m: &mut DetailConceptCount| { &mut m.processing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DetailConceptCount>(
            "DetailConceptCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DetailConceptCount {
    const NAME: &'static str = "DetailConceptCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.processed)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.to_process)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.errors)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.processing)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.processed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.to_process.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.errors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.processing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.processed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.to_process.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.errors.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.processing.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DetailConceptCount {
        DetailConceptCount::new()
    }

    fn clear(&mut self) {
        self.processed.clear();
        self.to_process.clear();
        self.errors.clear();
        self.processing.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DetailConceptCount {
        static instance: DetailConceptCount = DetailConceptCount {
            processed: ::protobuf::MessageField::none(),
            to_process: ::protobuf::MessageField::none(),
            errors: ::protobuf::MessageField::none(),
            processing: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DetailConceptCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DetailConceptCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DetailConceptCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailConceptCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConceptQuery
// @@protoc_insertion_point(message:clarifai.api.ConceptQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptQuery {
    // message fields
    ///  The name of the concept to search.
    // @@protoc_insertion_point(field:clarifai.api.ConceptQuery.name)
    pub name: ::std::string::String,
    ///  The language of the concept name in a search. Defaults to English.
    // @@protoc_insertion_point(field:clarifai.api.ConceptQuery.language)
    pub language: ::std::string::String,
    ///  The id of workflow. If no id is provided, then application base workflow is used.
    // @@protoc_insertion_point(field:clarifai.api.ConceptQuery.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  The concepts must belong to workflow models with specified use cases.
    ///  Multiple values are joined using an OR condition.
    // @@protoc_insertion_point(field:clarifai.api.ConceptQuery.use_cases)
    pub use_cases: ::std::vec::Vec<::protobuf::EnumOrUnknown<WorkflowModelUseCase>>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptQuery {
    fn default() -> &'a ConceptQuery {
        <ConceptQuery as ::protobuf::Message>::default_instance()
    }
}

impl ConceptQuery {
    pub fn new() -> ConceptQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ConceptQuery| { &m.name },
            |m: &mut ConceptQuery| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &ConceptQuery| { &m.language },
            |m: &mut ConceptQuery| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &ConceptQuery| { &m.workflow_id },
            |m: &mut ConceptQuery| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "use_cases",
            |m: &ConceptQuery| { &m.use_cases },
            |m: &mut ConceptQuery| { &mut m.use_cases },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptQuery>(
            "ConceptQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptQuery {
    const NAME: &'static str = "ConceptQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.language = is.read_string()?;
                },
                26 => {
                    self.workflow_id = is.read_string()?;
                },
                32 => {
                    self.use_cases.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.use_cases)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language);
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.workflow_id);
        }
        for value in &self.use_cases {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.language.is_empty() {
            os.write_string(2, &self.language)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(3, &self.workflow_id)?;
        }
        for v in &self.use_cases {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptQuery {
        ConceptQuery::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.language.clear();
        self.workflow_id.clear();
        self.use_cases.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptQuery {
        static instance: ConceptQuery = ConceptQuery {
            name: ::std::string::String::new(),
            language: ::std::string::String::new(),
            workflow_id: ::std::string::String::new(),
            use_cases: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This represents a relation (i.e. edge) between the subject concept and the object concept
// @@protoc_insertion_point(message:clarifai.api.ConceptRelation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptRelation {
    // message fields
    ///  ID of the concept relation
    // @@protoc_insertion_point(field:clarifai.api.ConceptRelation.id)
    pub id: ::std::string::String,
    ///  The subject concept (i.e. source) of the concept relation
    // @@protoc_insertion_point(field:clarifai.api.ConceptRelation.subject_concept)
    pub subject_concept: ::protobuf::MessageField<Concept>,
    ///  The subject concept (i.e. destination) of the concept relation
    // @@protoc_insertion_point(field:clarifai.api.ConceptRelation.object_concept)
    pub object_concept: ::protobuf::MessageField<Concept>,
    ///  The predicate (i.e. edge) linking the subject and the object
    ///  Both subject_concept and object_concept are concepts.
    ///  The predicate is the type of relationship.
    ///  That predicate acts on the subject.
    ///
    ///  There are three current types of predicates:
    ///  1) "hyponym"
    ///  2) "hypernym"
    ///  3) "synonym"
    ///
    ///  1) For example, 'hyponym' is a type of predicate which represents 'is_a_kind_of' relation so
    ///  the following relationship:
    ///  'honey' (subject), 'hyponym' (predicate), 'food' (object)
    ///  Can more easily be read as:
    ///  'honey' 'is a kind of' 'food'
    ///
    ///
    ///  2) The 'hypernym' relation is the opposite of 'hyponym' and when you add one of the
    ///  relationships the opposite will automatically appear for you in queries.
    ///
    ///  The 'hypernym' can be read as 'is a parent of' so:
    ///  'food' (subject), 'hypernym' (predicate), 'honey' (object)
    ///  Can more easily be read as:
    ///  'food' is a parent of 'honey'
    ///
    ///  3) The 'synonym' relation defines two concepts that essential mean the same thing. This
    ///  is more like a "is" relationship. So for example a 'synonym' relationship could be:
    ///  "puppy" is "pup"
    ///  The reverse is also true once the former is added so:
    ///  "pup" is "puppy"
    ///  will appear in queries as well.
    // @@protoc_insertion_point(field:clarifai.api.ConceptRelation.predicate)
    pub predicate: ::std::string::String,
    ///  The knowledge graph id that this edge belongs to. If using the app's global knowledge graph
    ///  and not a specific one then this should be the empty string "".
    // @@protoc_insertion_point(field:clarifai.api.ConceptRelation.knowledge_graph_id)
    pub knowledge_graph_id: ::std::string::String,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.ConceptRelation.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptRelation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptRelation {
    fn default() -> &'a ConceptRelation {
        <ConceptRelation as ::protobuf::Message>::default_instance()
    }
}

impl ConceptRelation {
    pub fn new() -> ConceptRelation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ConceptRelation| { &m.id },
            |m: &mut ConceptRelation| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Concept>(
            "subject_concept",
            |m: &ConceptRelation| { &m.subject_concept },
            |m: &mut ConceptRelation| { &mut m.subject_concept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Concept>(
            "object_concept",
            |m: &ConceptRelation| { &m.object_concept },
            |m: &mut ConceptRelation| { &mut m.object_concept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "predicate",
            |m: &ConceptRelation| { &m.predicate },
            |m: &mut ConceptRelation| { &mut m.predicate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "knowledge_graph_id",
            |m: &ConceptRelation| { &m.knowledge_graph_id },
            |m: &mut ConceptRelation| { &mut m.knowledge_graph_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &ConceptRelation| { &m.visibility },
            |m: &mut ConceptRelation| { &mut m.visibility },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptRelation>(
            "ConceptRelation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptRelation {
    const NAME: &'static str = "ConceptRelation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subject_concept)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.object_concept)?;
                },
                34 => {
                    self.predicate = is.read_string()?;
                },
                42 => {
                    self.knowledge_graph_id = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.subject_concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.object_concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.predicate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.predicate);
        }
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.knowledge_graph_id);
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.subject_concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.object_concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.predicate.is_empty() {
            os.write_string(4, &self.predicate)?;
        }
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(5, &self.knowledge_graph_id)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptRelation {
        ConceptRelation::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.subject_concept.clear();
        self.object_concept.clear();
        self.predicate.clear();
        self.knowledge_graph_id.clear();
        self.visibility.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptRelation {
        static instance: ConceptRelation = ConceptRelation {
            id: ::std::string::String::new(),
            subject_concept: ::protobuf::MessageField::none(),
            object_concept: ::protobuf::MessageField::none(),
            predicate: ::std::string::String::new(),
            knowledge_graph_id: ::std::string::String::new(),
            visibility: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptRelation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptRelation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptRelation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptRelation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A Knowledge Graph is a logical subsets of edges in the overall Concept Graph
// @@protoc_insertion_point(message:clarifai.api.KnowledgeGraph)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KnowledgeGraph {
    // message fields
    ///  ID of the knowledge graph
    // @@protoc_insertion_point(field:clarifai.api.KnowledgeGraph.id)
    pub id: ::std::string::String,
    ///  Name of the knowledge graph
    // @@protoc_insertion_point(field:clarifai.api.KnowledgeGraph.name)
    pub name: ::std::string::String,
    ///  Human readable description of the knowledge graph
    // @@protoc_insertion_point(field:clarifai.api.KnowledgeGraph.description)
    pub description: ::std::string::String,
    ///  The app that contains the images that correspond to the concepts in the knowledge graph
    // @@protoc_insertion_point(field:clarifai.api.KnowledgeGraph.examples_app_id)
    pub examples_app_id: ::std::string::String,
    ///  The app that contains the sample images that we want to show the customer for the concepts in the knowledge graph
    // @@protoc_insertion_point(field:clarifai.api.KnowledgeGraph.sampled_examples_app_id)
    pub sampled_examples_app_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.KnowledgeGraph.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KnowledgeGraph {
    fn default() -> &'a KnowledgeGraph {
        <KnowledgeGraph as ::protobuf::Message>::default_instance()
    }
}

impl KnowledgeGraph {
    pub fn new() -> KnowledgeGraph {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &KnowledgeGraph| { &m.id },
            |m: &mut KnowledgeGraph| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &KnowledgeGraph| { &m.name },
            |m: &mut KnowledgeGraph| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &KnowledgeGraph| { &m.description },
            |m: &mut KnowledgeGraph| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "examples_app_id",
            |m: &KnowledgeGraph| { &m.examples_app_id },
            |m: &mut KnowledgeGraph| { &mut m.examples_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sampled_examples_app_id",
            |m: &KnowledgeGraph| { &m.sampled_examples_app_id },
            |m: &mut KnowledgeGraph| { &mut m.sampled_examples_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KnowledgeGraph>(
            "KnowledgeGraph",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KnowledgeGraph {
    const NAME: &'static str = "KnowledgeGraph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                34 => {
                    self.examples_app_id = is.read_string()?;
                },
                42 => {
                    self.sampled_examples_app_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.examples_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.examples_app_id);
        }
        if !self.sampled_examples_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sampled_examples_app_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.examples_app_id.is_empty() {
            os.write_string(4, &self.examples_app_id)?;
        }
        if !self.sampled_examples_app_id.is_empty() {
            os.write_string(5, &self.sampled_examples_app_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KnowledgeGraph {
        KnowledgeGraph::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.examples_app_id.clear();
        self.sampled_examples_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KnowledgeGraph {
        static instance: KnowledgeGraph = KnowledgeGraph {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            examples_app_id: ::std::string::String::new(),
            sampled_examples_app_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KnowledgeGraph {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KnowledgeGraph").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KnowledgeGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KnowledgeGraph {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConceptMappingJob
// @@protoc_insertion_point(message:clarifai.api.ConceptMappingJob)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptMappingJob {
    // message fields
    ///  The id of the knowledge graph being used for this concept mapping job
    // @@protoc_insertion_point(field:clarifai.api.ConceptMappingJob.knowledge_graph_id)
    pub knowledge_graph_id: ::std::string::String,
    ///  The ids of the concepts being mapped
    // @@protoc_insertion_point(field:clarifai.api.ConceptMappingJob.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptMappingJob.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptMappingJob {
    fn default() -> &'a ConceptMappingJob {
        <ConceptMappingJob as ::protobuf::Message>::default_instance()
    }
}

impl ConceptMappingJob {
    pub fn new() -> ConceptMappingJob {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "knowledge_graph_id",
            |m: &ConceptMappingJob| { &m.knowledge_graph_id },
            |m: &mut ConceptMappingJob| { &mut m.knowledge_graph_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &ConceptMappingJob| { &m.concept_ids },
            |m: &mut ConceptMappingJob| { &mut m.concept_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptMappingJob>(
            "ConceptMappingJob",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptMappingJob {
    const NAME: &'static str = "ConceptMappingJob";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.knowledge_graph_id = is.read_string()?;
                },
                18 => {
                    self.concept_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.knowledge_graph_id);
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(1, &self.knowledge_graph_id)?;
        }
        for v in &self.concept_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptMappingJob {
        ConceptMappingJob::new()
    }

    fn clear(&mut self) {
        self.knowledge_graph_id.clear();
        self.concept_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptMappingJob {
        static instance: ConceptMappingJob = ConceptMappingJob {
            knowledge_graph_id: ::std::string::String::new(),
            concept_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptMappingJob {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptMappingJob").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptMappingJob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptMappingJob {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This represents a link to an outside source for the given concept.
///  The values from here are sticked into Concept message into the name and definition fields when
///  returning from the API in your default language. The "id" field here becomes the "language"
///  field of the Concept message which is a little weird.
// @@protoc_insertion_point(message:clarifai.api.ConceptLanguage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptLanguage {
    // message fields
    ///  This is the language code for the language such as "en".
    // @@protoc_insertion_point(field:clarifai.api.ConceptLanguage.id)
    pub id: ::std::string::String,
    ///  The type of the outside source.
    // @@protoc_insertion_point(field:clarifai.api.ConceptLanguage.name)
    pub name: ::std::string::String,
    ///  The ID that is referenced in the source.
    // @@protoc_insertion_point(field:clarifai.api.ConceptLanguage.definition)
    pub definition: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptLanguage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptLanguage {
    fn default() -> &'a ConceptLanguage {
        <ConceptLanguage as ::protobuf::Message>::default_instance()
    }
}

impl ConceptLanguage {
    pub fn new() -> ConceptLanguage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ConceptLanguage| { &m.id },
            |m: &mut ConceptLanguage| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ConceptLanguage| { &m.name },
            |m: &mut ConceptLanguage| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "definition",
            |m: &ConceptLanguage| { &m.definition },
            |m: &mut ConceptLanguage| { &mut m.definition },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptLanguage>(
            "ConceptLanguage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptLanguage {
    const NAME: &'static str = "ConceptLanguage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.definition = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.definition.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.definition);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.definition.is_empty() {
            os.write_string(3, &self.definition)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptLanguage {
        ConceptLanguage::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.definition.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptLanguage {
        static instance: ConceptLanguage = ConceptLanguage {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            definition: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptLanguage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptLanguage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptLanguage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptLanguage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Data
// @@protoc_insertion_point(message:clarifai.api.Data)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Data {
    // message fields
    ///  Input and output images.
    // @@protoc_insertion_point(field:clarifai.api.Data.image)
    pub image: ::protobuf::MessageField<Image>,
    ///  Input and output videos.
    // @@protoc_insertion_point(field:clarifai.api.Data.video)
    pub video: ::protobuf::MessageField<Video>,
    ///  A list of concepts.
    // @@protoc_insertion_point(field:clarifai.api.Data.concepts)
    pub concepts: ::std::vec::Vec<Concept>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.Data.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  Geography information.
    // @@protoc_insertion_point(field:clarifai.api.Data.geo)
    pub geo: ::protobuf::MessageField<Geo>,
    ///  The dominant colors within an image.
    // @@protoc_insertion_point(field:clarifai.api.Data.colors)
    pub colors: ::std::vec::Vec<Color>,
    ///  Clustering centroids for inputs.
    // @@protoc_insertion_point(field:clarifai.api.Data.clusters)
    pub clusters: ::std::vec::Vec<Cluster>,
    ///  Embedding vectors representing each input.
    // @@protoc_insertion_point(field:clarifai.api.Data.embeddings)
    pub embeddings: ::std::vec::Vec<Embedding>,
    ///  For recursing into localized regions of an input.
    // @@protoc_insertion_point(field:clarifai.api.Data.regions)
    pub regions: ::std::vec::Vec<Region>,
    ///  For temporal content like video.
    // @@protoc_insertion_point(field:clarifai.api.Data.frames)
    pub frames: ::std::vec::Vec<Frame>,
    ///  Input, output or annotation text.
    // @@protoc_insertion_point(field:clarifai.api.Data.text)
    pub text: ::protobuf::MessageField<Text>,
    ///  Input and output audio.
    // @@protoc_insertion_point(field:clarifai.api.Data.audio)
    pub audio: ::protobuf::MessageField<Audio>,
    ///  Track information.
    // @@protoc_insertion_point(field:clarifai.api.Data.tracks)
    pub tracks: ::std::vec::Vec<Track>,
    ///  Time segments information.
    // @@protoc_insertion_point(field:clarifai.api.Data.time_segments)
    pub time_segments: ::std::vec::Vec<TimeSegment>,
    ///  Holds score, rank, and user, app, input IDs and search hit data
    // @@protoc_insertion_point(field:clarifai.api.Data.hits)
    pub hits: ::std::vec::Vec<Hit>,
    ///  Heatmap as 2d image
    // @@protoc_insertion_point(field:clarifai.api.Data.heatmaps)
    pub heatmaps: ::std::vec::Vec<Image>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Data.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Data {
    fn default() -> &'a Data {
        <Data as ::protobuf::Message>::default_instance()
    }
}

impl Data {
    pub fn new() -> Data {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &Data| { &m.image },
            |m: &mut Data| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Video>(
            "video",
            |m: &Data| { &m.video },
            |m: &mut Data| { &mut m.video },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &Data| { &m.concepts },
            |m: &mut Data| { &mut m.concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &Data| { &m.metadata },
            |m: &mut Data| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Geo>(
            "geo",
            |m: &Data| { &m.geo },
            |m: &mut Data| { &mut m.geo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colors",
            |m: &Data| { &m.colors },
            |m: &mut Data| { &mut m.colors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "clusters",
            |m: &Data| { &m.clusters },
            |m: &mut Data| { &mut m.clusters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "embeddings",
            |m: &Data| { &m.embeddings },
            |m: &mut Data| { &mut m.embeddings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "regions",
            |m: &Data| { &m.regions },
            |m: &mut Data| { &mut m.regions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "frames",
            |m: &Data| { &m.frames },
            |m: &mut Data| { &mut m.frames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Text>(
            "text",
            |m: &Data| { &m.text },
            |m: &mut Data| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Audio>(
            "audio",
            |m: &Data| { &m.audio },
            |m: &mut Data| { &mut m.audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tracks",
            |m: &Data| { &m.tracks },
            |m: &mut Data| { &mut m.tracks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "time_segments",
            |m: &Data| { &m.time_segments },
            |m: &mut Data| { &mut m.time_segments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hits",
            |m: &Data| { &m.hits },
            |m: &mut Data| { &mut m.hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "heatmaps",
            |m: &Data| { &m.heatmaps },
            |m: &mut Data| { &mut m.heatmaps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Data>(
            "Data",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Data {
    const NAME: &'static str = "Data";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.video)?;
                },
                26 => {
                    self.concepts.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.geo)?;
                },
                58 => {
                    self.colors.push(is.read_message()?);
                },
                66 => {
                    self.clusters.push(is.read_message()?);
                },
                74 => {
                    self.embeddings.push(is.read_message()?);
                },
                90 => {
                    self.regions.push(is.read_message()?);
                },
                98 => {
                    self.frames.push(is.read_message()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.text)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio)?;
                },
                122 => {
                    self.tracks.push(is.read_message()?);
                },
                130 => {
                    self.time_segments.push(is.read_message()?);
                },
                138 => {
                    self.hits.push(is.read_message()?);
                },
                146 => {
                    self.heatmaps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.video.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.geo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.embeddings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.regions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tracks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.time_segments {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.heatmaps {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.video.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.geo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.colors {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.clusters {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.embeddings {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.regions {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.frames {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.audio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.tracks {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.time_segments {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.hits {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        for v in &self.heatmaps {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Data {
        Data::new()
    }

    fn clear(&mut self) {
        self.image.clear();
        self.video.clear();
        self.concepts.clear();
        self.metadata.clear();
        self.geo.clear();
        self.colors.clear();
        self.clusters.clear();
        self.embeddings.clear();
        self.regions.clear();
        self.frames.clear();
        self.text.clear();
        self.audio.clear();
        self.tracks.clear();
        self.time_segments.clear();
        self.hits.clear();
        self.heatmaps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Data {
        static instance: Data = Data {
            image: ::protobuf::MessageField::none(),
            video: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            metadata: ::protobuf::MessageField::none(),
            geo: ::protobuf::MessageField::none(),
            colors: ::std::vec::Vec::new(),
            clusters: ::std::vec::Vec::new(),
            embeddings: ::std::vec::Vec::new(),
            regions: ::std::vec::Vec::new(),
            frames: ::std::vec::Vec::new(),
            text: ::protobuf::MessageField::none(),
            audio: ::protobuf::MessageField::none(),
            tracks: ::std::vec::Vec::new(),
            time_segments: ::std::vec::Vec::new(),
            hits: ::std::vec::Vec::new(),
            heatmaps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Data {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Data").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Data {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Data {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A region within the data.
// @@protoc_insertion_point(message:clarifai.api.Region)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Region {
    // message fields
    ///  A unique id for the region.
    // @@protoc_insertion_point(field:clarifai.api.Region.id)
    pub id: ::std::string::String,
    ///  The details about the location of the region.
    // @@protoc_insertion_point(field:clarifai.api.Region.region_info)
    pub region_info: ::protobuf::MessageField<RegionInfo>,
    ///  A recursive definition of the data within the Region. For example, this will contain
    ///  data.concepts if the region also has annotations or predictions of concepts within it.
    // @@protoc_insertion_point(field:clarifai.api.Region.data)
    pub data: ::protobuf::MessageField<Data>,
    ///  This is the confidence score of the overall Region.
    // @@protoc_insertion_point(field:clarifai.api.Region.value)
    pub value: f32,
    ///  For tracking algorithsm and annotations we tie regions together with this track id.
    // @@protoc_insertion_point(field:clarifai.api.Region.track_id)
    pub track_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Region.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Region {
    fn default() -> &'a Region {
        <Region as ::protobuf::Message>::default_instance()
    }
}

impl Region {
    pub fn new() -> Region {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Region| { &m.id },
            |m: &mut Region| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RegionInfo>(
            "region_info",
            |m: &Region| { &m.region_info },
            |m: &mut Region| { &mut m.region_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &Region| { &m.data },
            |m: &mut Region| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Region| { &m.value },
            |m: &mut Region| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "track_id",
            |m: &Region| { &m.track_id },
            |m: &mut Region| { &mut m.track_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Region>(
            "Region",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Region {
    const NAME: &'static str = "Region";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.region_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                37 => {
                    self.value = is.read_float()?;
                },
                42 => {
                    self.track_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.region_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.value != 0. {
            my_size += 1 + 4;
        }
        if !self.track_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.track_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.region_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.value != 0. {
            os.write_float(4, self.value)?;
        }
        if !self.track_id.is_empty() {
            os.write_string(5, &self.track_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Region {
        Region::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.region_info.clear();
        self.data.clear();
        self.value = 0.;
        self.track_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Region {
        static instance: Region = Region {
            id: ::std::string::String::new(),
            region_info: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            value: 0.,
            track_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Region {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Region").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Region {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Region {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The information of the location of the Region.
// @@protoc_insertion_point(message:clarifai.api.RegionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RegionInfo {
    // message fields
    ///  Details of the region's rectangular bounding box.
    // @@protoc_insertion_point(field:clarifai.api.RegionInfo.bounding_box)
    pub bounding_box: ::protobuf::MessageField<BoundingBox>,
    ///  Details of the region's segmentation mask.
    // @@protoc_insertion_point(field:clarifai.api.RegionInfo.mask)
    pub mask: ::protobuf::MessageField<Mask>,
    ///  A polygon of points.
    // @@protoc_insertion_point(field:clarifai.api.RegionInfo.polygon)
    pub polygon: ::protobuf::MessageField<Polygon>,
    ///  A landmark point location.
    // @@protoc_insertion_point(field:clarifai.api.RegionInfo.point)
    pub point: ::protobuf::MessageField<Point>,
    ///  Span char sequence for NLP.
    // @@protoc_insertion_point(field:clarifai.api.RegionInfo.span)
    pub span: ::protobuf::MessageField<Span>,
    ///  Token char sequence for NLP.
    // @@protoc_insertion_point(field:clarifai.api.RegionInfo.token)
    pub token: ::protobuf::MessageField<Token>,
    ///  The locations of detected keypoints, which are to be used in conjunction with the detected concept's skeleton to connect the keypoint locations.
    ///  These will be in the same order as the respective keypoint_names inside the concept.
    // @@protoc_insertion_point(field:clarifai.api.RegionInfo.keypoint_locations)
    pub keypoint_locations: ::std::vec::Vec<Point>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.RegionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegionInfo {
    fn default() -> &'a RegionInfo {
        <RegionInfo as ::protobuf::Message>::default_instance()
    }
}

impl RegionInfo {
    pub fn new() -> RegionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BoundingBox>(
            "bounding_box",
            |m: &RegionInfo| { &m.bounding_box },
            |m: &mut RegionInfo| { &mut m.bounding_box },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Mask>(
            "mask",
            |m: &RegionInfo| { &m.mask },
            |m: &mut RegionInfo| { &mut m.mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Polygon>(
            "polygon",
            |m: &RegionInfo| { &m.polygon },
            |m: &mut RegionInfo| { &mut m.polygon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Point>(
            "point",
            |m: &RegionInfo| { &m.point },
            |m: &mut RegionInfo| { &mut m.point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Span>(
            "span",
            |m: &RegionInfo| { &m.span },
            |m: &mut RegionInfo| { &mut m.span },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Token>(
            "token",
            |m: &RegionInfo| { &m.token },
            |m: &mut RegionInfo| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keypoint_locations",
            |m: &RegionInfo| { &m.keypoint_locations },
            |m: &mut RegionInfo| { &mut m.keypoint_locations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegionInfo>(
            "RegionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegionInfo {
    const NAME: &'static str = "RegionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bounding_box)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mask)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.polygon)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.point)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.span)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token)?;
                },
                74 => {
                    self.keypoint_locations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bounding_box.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.polygon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.span.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.token.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keypoint_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bounding_box.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.polygon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.point.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.span.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.token.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.keypoint_locations {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegionInfo {
        RegionInfo::new()
    }

    fn clear(&mut self) {
        self.bounding_box.clear();
        self.mask.clear();
        self.polygon.clear();
        self.point.clear();
        self.span.clear();
        self.token.clear();
        self.keypoint_locations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegionInfo {
        static instance: RegionInfo = RegionInfo {
            bounding_box: ::protobuf::MessageField::none(),
            mask: ::protobuf::MessageField::none(),
            polygon: ::protobuf::MessageField::none(),
            point: ::protobuf::MessageField::none(),
            span: ::protobuf::MessageField::none(),
            token: ::protobuf::MessageField::none(),
            keypoint_locations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Rectangular bounding box for a region.
// @@protoc_insertion_point(message:clarifai.api.BoundingBox)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BoundingBox {
    // message fields
    ///  The top left of the bounding box normalized to the data dimension to be within [0-1.0]
    // @@protoc_insertion_point(field:clarifai.api.BoundingBox.top_row)
    pub top_row: f32,
    ///  The left column of the bounding box normalized to the data dimension to be within [0-1.0]
    // @@protoc_insertion_point(field:clarifai.api.BoundingBox.left_col)
    pub left_col: f32,
    ///  The bottom row of the bounding box normalized to the data dimension to be within [0-1.0]
    // @@protoc_insertion_point(field:clarifai.api.BoundingBox.bottom_row)
    pub bottom_row: f32,
    ///  The right col of the bounding box normalized to the data dimension to be within [0-1.0]
    // @@protoc_insertion_point(field:clarifai.api.BoundingBox.right_col)
    pub right_col: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.BoundingBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BoundingBox {
    fn default() -> &'a BoundingBox {
        <BoundingBox as ::protobuf::Message>::default_instance()
    }
}

impl BoundingBox {
    pub fn new() -> BoundingBox {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "top_row",
            |m: &BoundingBox| { &m.top_row },
            |m: &mut BoundingBox| { &mut m.top_row },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "left_col",
            |m: &BoundingBox| { &m.left_col },
            |m: &mut BoundingBox| { &mut m.left_col },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bottom_row",
            |m: &BoundingBox| { &m.bottom_row },
            |m: &mut BoundingBox| { &mut m.bottom_row },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "right_col",
            |m: &BoundingBox| { &m.right_col },
            |m: &mut BoundingBox| { &mut m.right_col },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BoundingBox>(
            "BoundingBox",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BoundingBox {
    const NAME: &'static str = "BoundingBox";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.top_row = is.read_float()?;
                },
                21 => {
                    self.left_col = is.read_float()?;
                },
                29 => {
                    self.bottom_row = is.read_float()?;
                },
                37 => {
                    self.right_col = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.top_row != 0. {
            my_size += 1 + 4;
        }
        if self.left_col != 0. {
            my_size += 1 + 4;
        }
        if self.bottom_row != 0. {
            my_size += 1 + 4;
        }
        if self.right_col != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.top_row != 0. {
            os.write_float(1, self.top_row)?;
        }
        if self.left_col != 0. {
            os.write_float(2, self.left_col)?;
        }
        if self.bottom_row != 0. {
            os.write_float(3, self.bottom_row)?;
        }
        if self.right_col != 0. {
            os.write_float(4, self.right_col)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BoundingBox {
        BoundingBox::new()
    }

    fn clear(&mut self) {
        self.top_row = 0.;
        self.left_col = 0.;
        self.bottom_row = 0.;
        self.right_col = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BoundingBox {
        static instance: BoundingBox = BoundingBox {
            top_row: 0.,
            left_col: 0.,
            bottom_row: 0.,
            right_col: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BoundingBox {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BoundingBox").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BoundingBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BoundingBox {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The information of the location of the Frame.
// @@protoc_insertion_point(message:clarifai.api.FrameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FrameInfo {
    // message fields
    ///  Deprecated. Use Time instead.
    ///  The index of the frame, informational and optional.
    ///  Depends on the sampling rate used during processing
    ///  May be 0 for interpolated frames that are generated for brief time (training) or if new frame is manually added
    // @@protoc_insertion_point(field:clarifai.api.FrameInfo.index)
    pub index: u32,
    ///  time in the video in milliseconds. This is independent of the sampling rates used during
    ///  processing.
    // @@protoc_insertion_point(field:clarifai.api.FrameInfo.time)
    pub time: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.FrameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FrameInfo {
    fn default() -> &'a FrameInfo {
        <FrameInfo as ::protobuf::Message>::default_instance()
    }
}

impl FrameInfo {
    pub fn new() -> FrameInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index",
            |m: &FrameInfo| { &m.index },
            |m: &mut FrameInfo| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &FrameInfo| { &m.time },
            |m: &mut FrameInfo| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FrameInfo>(
            "FrameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FrameInfo {
    const NAME: &'static str = "FrameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = is.read_uint32()?;
                },
                16 => {
                    self.time = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.index);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        if self.time != 0 {
            os.write_uint32(2, self.time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FrameInfo {
        FrameInfo::new()
    }

    fn clear(&mut self) {
        self.index = 0;
        self.time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FrameInfo {
        static instance: FrameInfo = FrameInfo {
            index: 0,
            time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FrameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FrameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FrameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A Frame of time-series Data such as a Video.
// @@protoc_insertion_point(message:clarifai.api.Frame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Frame {
    // message fields
    ///  Information aboue frame such as number and time.
    // @@protoc_insertion_point(field:clarifai.api.Frame.frame_info)
    pub frame_info: ::protobuf::MessageField<FrameInfo>,
    ///  A recursive definition of the data within the Frame. For example, this will contain
    ///  data.concepts if the Frame also has annotations or predictions of concepts within it.
    ///  This can also have data.regions for annotation or predictions of detection regions, which can
    ///  then recursively have their data field filled in as well.
    // @@protoc_insertion_point(field:clarifai.api.Frame.data)
    pub data: ::protobuf::MessageField<Data>,
    ///  An ID for the frame.
    // @@protoc_insertion_point(field:clarifai.api.Frame.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Frame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Frame {
    fn default() -> &'a Frame {
        <Frame as ::protobuf::Message>::default_instance()
    }
}

impl Frame {
    pub fn new() -> Frame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FrameInfo>(
            "frame_info",
            |m: &Frame| { &m.frame_info },
            |m: &mut Frame| { &mut m.frame_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &Frame| { &m.data },
            |m: &mut Frame| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Frame| { &m.id },
            |m: &mut Frame| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Frame>(
            "Frame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Frame {
    const NAME: &'static str = "Frame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.frame_info)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                26 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frame_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Frame {
        Frame::new()
    }

    fn clear(&mut self) {
        self.frame_info.clear();
        self.data.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Frame {
        static instance: Frame = Frame {
            frame_info: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Frame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Frame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Frame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Frame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Segmentation mask.
// @@protoc_insertion_point(message:clarifai.api.Mask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Mask {
    // message fields
    ///  The image of the mask in a non-raster format.
    // @@protoc_insertion_point(field:clarifai.api.Mask.image)
    pub image: ::protobuf::MessageField<Image>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Mask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Mask {
    fn default() -> &'a Mask {
        <Mask as ::protobuf::Message>::default_instance()
    }
}

impl Mask {
    pub fn new() -> Mask {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &Mask| { &m.image },
            |m: &mut Mask| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Mask>(
            "Mask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Mask {
    const NAME: &'static str = "Mask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Mask {
        Mask::new()
    }

    fn clear(&mut self) {
        self.image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Mask {
        static instance: Mask = Mask {
            image: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Mask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Mask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Mask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Polygon
// @@protoc_insertion_point(message:clarifai.api.Polygon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Polygon {
    // message fields
    ///  A list of points connected together to form the polygon.
    // @@protoc_insertion_point(field:clarifai.api.Polygon.points)
    pub points: ::std::vec::Vec<Point>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Polygon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Polygon {
    fn default() -> &'a Polygon {
        <Polygon as ::protobuf::Message>::default_instance()
    }
}

impl Polygon {
    pub fn new() -> Polygon {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "points",
            |m: &Polygon| { &m.points },
            |m: &mut Polygon| { &mut m.points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Polygon>(
            "Polygon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Polygon {
    const NAME: &'static str = "Polygon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.points.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Polygon {
        Polygon::new()
    }

    fn clear(&mut self) {
        self.points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Polygon {
        static instance: Polygon = Polygon {
            points: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Polygon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Polygon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Polygon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Polygon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Point
// @@protoc_insertion_point(message:clarifai.api.Point)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Point {
    // message fields
    ///  The row location of the point. This has a [0.0-1.0] range with 0.0 being top row and 1.0
    ///  being the bottom row.
    // @@protoc_insertion_point(field:clarifai.api.Point.row)
    pub row: f32,
    ///  The column location of the point. This has a [0.0-1.0] range with 0.0 being left col and 1.0
    ///  being the right col.
    // @@protoc_insertion_point(field:clarifai.api.Point.col)
    pub col: f32,
    ///  Depth if applicable for the point.
    // @@protoc_insertion_point(field:clarifai.api.Point.z)
    pub z: f32,
    // @@protoc_insertion_point(field:clarifai.api.Point.visibility)
    pub visibility: ::protobuf::EnumOrUnknown<point::Visibility>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Point.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "row",
            |m: &Point| { &m.row },
            |m: &mut Point| { &mut m.row },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "col",
            |m: &Point| { &m.col },
            |m: &mut Point| { &mut m.col },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "z",
            |m: &Point| { &m.z },
            |m: &mut Point| { &mut m.z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visibility",
            |m: &Point| { &m.visibility },
            |m: &mut Point| { &mut m.visibility },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Point>(
            "Point",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Point {
    const NAME: &'static str = "Point";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.row = is.read_float()?;
                },
                21 => {
                    self.col = is.read_float()?;
                },
                29 => {
                    self.z = is.read_float()?;
                },
                32 => {
                    self.visibility = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.row != 0. {
            my_size += 1 + 4;
        }
        if self.col != 0. {
            my_size += 1 + 4;
        }
        if self.z != 0. {
            my_size += 1 + 4;
        }
        if self.visibility != ::protobuf::EnumOrUnknown::new(point::Visibility::NOT_SET) {
            my_size += ::protobuf::rt::int32_size(4, self.visibility.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.row != 0. {
            os.write_float(1, self.row)?;
        }
        if self.col != 0. {
            os.write_float(2, self.col)?;
        }
        if self.z != 0. {
            os.write_float(3, self.z)?;
        }
        if self.visibility != ::protobuf::EnumOrUnknown::new(point::Visibility::NOT_SET) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.visibility))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point {
        Point::new()
    }

    fn clear(&mut self) {
        self.row = 0.;
        self.col = 0.;
        self.z = 0.;
        self.visibility = ::protobuf::EnumOrUnknown::new(point::Visibility::NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point {
        static instance: Point = Point {
            row: 0.,
            col: 0.,
            z: 0.,
            visibility: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Point {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Point").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Point`
pub mod point {
    ///  Whether this point is visible or occluded
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.Point.Visibility)
    pub enum Visibility {
        // @@protoc_insertion_point(enum_value:clarifai.api.Point.Visibility.NOT_SET)
        NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.Point.Visibility.VISIBLE)
        VISIBLE = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.Point.Visibility.NOT_VISIBLE)
        NOT_VISIBLE = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.Point.Visibility.NOT_PRESENT)
        NOT_PRESENT = 3,
    }

    impl ::protobuf::Enum for Visibility {
        const NAME: &'static str = "Visibility";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Visibility> {
            match value {
                0 => ::std::option::Option::Some(Visibility::NOT_SET),
                1 => ::std::option::Option::Some(Visibility::VISIBLE),
                2 => ::std::option::Option::Some(Visibility::NOT_VISIBLE),
                3 => ::std::option::Option::Some(Visibility::NOT_PRESENT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Visibility> {
            match str {
                "NOT_SET" => ::std::option::Option::Some(Visibility::NOT_SET),
                "VISIBLE" => ::std::option::Option::Some(Visibility::VISIBLE),
                "NOT_VISIBLE" => ::std::option::Option::Some(Visibility::NOT_VISIBLE),
                "NOT_PRESENT" => ::std::option::Option::Some(Visibility::NOT_PRESENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Visibility] = &[
            Visibility::NOT_SET,
            Visibility::VISIBLE,
            Visibility::NOT_VISIBLE,
            Visibility::NOT_PRESENT,
        ];
    }

    impl ::protobuf::EnumFull for Visibility {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Point.Visibility").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Visibility {
        fn default() -> Self {
            Visibility::NOT_SET
        }
    }

    impl Visibility {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Visibility>("Point.Visibility")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.Span)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Span {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.Span.char_start)
    pub char_start: u32,
    // @@protoc_insertion_point(field:clarifai.api.Span.char_end)
    pub char_end: u32,
    // @@protoc_insertion_point(field:clarifai.api.Span.raw_text)
    pub raw_text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Span.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Span {
    fn default() -> &'a Span {
        <Span as ::protobuf::Message>::default_instance()
    }
}

impl Span {
    pub fn new() -> Span {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "char_start",
            |m: &Span| { &m.char_start },
            |m: &mut Span| { &mut m.char_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "char_end",
            |m: &Span| { &m.char_end },
            |m: &mut Span| { &mut m.char_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "raw_text",
            |m: &Span| { &m.raw_text },
            |m: &mut Span| { &mut m.raw_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Span>(
            "Span",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Span {
    const NAME: &'static str = "Span";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.char_start = is.read_uint32()?;
                },
                16 => {
                    self.char_end = is.read_uint32()?;
                },
                26 => {
                    self.raw_text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.char_start != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.char_start);
        }
        if self.char_end != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.char_end);
        }
        if !self.raw_text.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.raw_text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.char_start != 0 {
            os.write_uint32(1, self.char_start)?;
        }
        if self.char_end != 0 {
            os.write_uint32(2, self.char_end)?;
        }
        if !self.raw_text.is_empty() {
            os.write_string(3, &self.raw_text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Span {
        Span::new()
    }

    fn clear(&mut self) {
        self.char_start = 0;
        self.char_end = 0;
        self.raw_text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Span {
        static instance: Span = Span {
            char_start: 0,
            char_end: 0,
            raw_text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Span {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Span").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Span {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.Token)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Token {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.Token.char_start)
    pub char_start: u32,
    // @@protoc_insertion_point(field:clarifai.api.Token.char_end)
    pub char_end: u32,
    // @@protoc_insertion_point(field:clarifai.api.Token.raw_text)
    pub raw_text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Token.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Token {
    fn default() -> &'a Token {
        <Token as ::protobuf::Message>::default_instance()
    }
}

impl Token {
    pub fn new() -> Token {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "char_start",
            |m: &Token| { &m.char_start },
            |m: &mut Token| { &mut m.char_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "char_end",
            |m: &Token| { &m.char_end },
            |m: &mut Token| { &mut m.char_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "raw_text",
            |m: &Token| { &m.raw_text },
            |m: &mut Token| { &mut m.raw_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Token>(
            "Token",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Token {
    const NAME: &'static str = "Token";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.char_start = is.read_uint32()?;
                },
                16 => {
                    self.char_end = is.read_uint32()?;
                },
                26 => {
                    self.raw_text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.char_start != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.char_start);
        }
        if self.char_end != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.char_end);
        }
        if !self.raw_text.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.raw_text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.char_start != 0 {
            os.write_uint32(1, self.char_start)?;
        }
        if self.char_end != 0 {
            os.write_uint32(2, self.char_end)?;
        }
        if !self.raw_text.is_empty() {
            os.write_string(3, &self.raw_text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Token {
        Token::new()
    }

    fn clear(&mut self) {
        self.char_start = 0;
        self.char_end = 0;
        self.raw_text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Token {
        static instance: Token = Token {
            char_start: 0,
            char_end: 0,
            raw_text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Token {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Token").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Token {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Token {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Embedding
// @@protoc_insertion_point(message:clarifai.api.Embedding)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Embedding {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.Embedding.vector)
    pub vector: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:clarifai.api.Embedding.num_dimensions)
    pub num_dimensions: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Embedding.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Embedding {
    fn default() -> &'a Embedding {
        <Embedding as ::protobuf::Message>::default_instance()
    }
}

impl Embedding {
    pub fn new() -> Embedding {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vector",
            |m: &Embedding| { &m.vector },
            |m: &mut Embedding| { &mut m.vector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_dimensions",
            |m: &Embedding| { &m.num_dimensions },
            |m: &mut Embedding| { &mut m.num_dimensions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Embedding>(
            "Embedding",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Embedding {
    const NAME: &'static str = "Embedding";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.vector)?;
                },
                13 => {
                    self.vector.push(is.read_float()?);
                },
                16 => {
                    self.num_dimensions = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_float_size(1, &self.vector);
        if self.num_dimensions != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.num_dimensions);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_float(1, &self.vector)?;
        if self.num_dimensions != 0 {
            os.write_uint32(2, self.num_dimensions)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Embedding {
        Embedding::new()
    }

    fn clear(&mut self) {
        self.vector.clear();
        self.num_dimensions = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Embedding {
        static instance: Embedding = Embedding {
            vector: ::std::vec::Vec::new(),
            num_dimensions: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Embedding {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Embedding").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Embedding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Embedding {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GeoPoint
// @@protoc_insertion_point(message:clarifai.api.GeoPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GeoPoint {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GeoPoint.longitude)
    pub longitude: f32,
    // @@protoc_insertion_point(field:clarifai.api.GeoPoint.latitude)
    pub latitude: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GeoPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GeoPoint {
    fn default() -> &'a GeoPoint {
        <GeoPoint as ::protobuf::Message>::default_instance()
    }
}

impl GeoPoint {
    pub fn new() -> GeoPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "longitude",
            |m: &GeoPoint| { &m.longitude },
            |m: &mut GeoPoint| { &mut m.longitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latitude",
            |m: &GeoPoint| { &m.latitude },
            |m: &mut GeoPoint| { &mut m.latitude },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GeoPoint>(
            "GeoPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GeoPoint {
    const NAME: &'static str = "GeoPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.longitude = is.read_float()?;
                },
                21 => {
                    self.latitude = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.longitude != 0. {
            my_size += 1 + 4;
        }
        if self.latitude != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.longitude != 0. {
            os.write_float(1, self.longitude)?;
        }
        if self.latitude != 0. {
            os.write_float(2, self.latitude)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GeoPoint {
        GeoPoint::new()
    }

    fn clear(&mut self) {
        self.longitude = 0.;
        self.latitude = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GeoPoint {
        static instance: GeoPoint = GeoPoint {
            longitude: 0.,
            latitude: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GeoPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GeoPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GeoPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GeoLimit
// @@protoc_insertion_point(message:clarifai.api.GeoLimit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GeoLimit {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GeoLimit.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GeoLimit.value)
    pub value: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GeoLimit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GeoLimit {
    fn default() -> &'a GeoLimit {
        <GeoLimit as ::protobuf::Message>::default_instance()
    }
}

impl GeoLimit {
    pub fn new() -> GeoLimit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &GeoLimit| { &m.type_ },
            |m: &mut GeoLimit| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &GeoLimit| { &m.value },
            |m: &mut GeoLimit| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GeoLimit>(
            "GeoLimit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GeoLimit {
    const NAME: &'static str = "GeoLimit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                21 => {
                    self.value = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if self.value != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if self.value != 0. {
            os.write_float(2, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GeoLimit {
        GeoLimit::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GeoLimit {
        static instance: GeoLimit = GeoLimit {
            type_: ::std::string::String::new(),
            value: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GeoLimit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GeoLimit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GeoLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoLimit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GeoBoxedPoint
// @@protoc_insertion_point(message:clarifai.api.GeoBoxedPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GeoBoxedPoint {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GeoBoxedPoint.geo_point)
    pub geo_point: ::protobuf::MessageField<GeoPoint>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GeoBoxedPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GeoBoxedPoint {
    fn default() -> &'a GeoBoxedPoint {
        <GeoBoxedPoint as ::protobuf::Message>::default_instance()
    }
}

impl GeoBoxedPoint {
    pub fn new() -> GeoBoxedPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GeoPoint>(
            "geo_point",
            |m: &GeoBoxedPoint| { &m.geo_point },
            |m: &mut GeoBoxedPoint| { &mut m.geo_point },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GeoBoxedPoint>(
            "GeoBoxedPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GeoBoxedPoint {
    const NAME: &'static str = "GeoBoxedPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.geo_point)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.geo_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.geo_point.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GeoBoxedPoint {
        GeoBoxedPoint::new()
    }

    fn clear(&mut self) {
        self.geo_point.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GeoBoxedPoint {
        static instance: GeoBoxedPoint = GeoBoxedPoint {
            geo_point: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GeoBoxedPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GeoBoxedPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GeoBoxedPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoBoxedPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Geo
// @@protoc_insertion_point(message:clarifai.api.Geo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Geo {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.Geo.geo_point)
    pub geo_point: ::protobuf::MessageField<GeoPoint>,
    // @@protoc_insertion_point(field:clarifai.api.Geo.geo_limit)
    pub geo_limit: ::protobuf::MessageField<GeoLimit>,
    ///  NOTE: inconsistency: should have been geo_boxed_points
    // @@protoc_insertion_point(field:clarifai.api.Geo.geo_box)
    pub geo_box: ::std::vec::Vec<GeoBoxedPoint>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Geo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Geo {
    fn default() -> &'a Geo {
        <Geo as ::protobuf::Message>::default_instance()
    }
}

impl Geo {
    pub fn new() -> Geo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GeoPoint>(
            "geo_point",
            |m: &Geo| { &m.geo_point },
            |m: &mut Geo| { &mut m.geo_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GeoLimit>(
            "geo_limit",
            |m: &Geo| { &m.geo_limit },
            |m: &mut Geo| { &mut m.geo_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "geo_box",
            |m: &Geo| { &m.geo_box },
            |m: &mut Geo| { &mut m.geo_box },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Geo>(
            "Geo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Geo {
    const NAME: &'static str = "Geo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.geo_point)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.geo_limit)?;
                },
                26 => {
                    self.geo_box.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.geo_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.geo_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.geo_box {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.geo_point.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.geo_limit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.geo_box {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Geo {
        Geo::new()
    }

    fn clear(&mut self) {
        self.geo_point.clear();
        self.geo_limit.clear();
        self.geo_box.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Geo {
        static instance: Geo = Geo {
            geo_point: ::protobuf::MessageField::none(),
            geo_limit: ::protobuf::MessageField::none(),
            geo_box: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Geo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Geo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Geo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Geo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Image
// @@protoc_insertion_point(message:clarifai.api.Image)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Image {
    // message fields
    ///  This is a URL to a publicly accessible image file. The platform will download this file server
    ///  side and then process.
    // @@protoc_insertion_point(field:clarifai.api.Image.url)
    pub url: ::std::string::String,
    ///  The base64 field is using image file bytes directly in the request.
    ///  NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
    ///  the name here).
    ///  When using our grpc clients, you DO NOT need to base64 encode
    ///  it yourself since the clients know how to do this for you automatically and will avoid the
    ///  base64 encoding if they send a binary request.
    // @@protoc_insertion_point(field:clarifai.api.Image.base64)
    pub base64: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:clarifai.api.Image.allow_duplicate_url)
    pub allow_duplicate_url: bool,
    ///  The hosted field lists images in different sizes hosted in Clarifai storage.
    // @@protoc_insertion_point(field:clarifai.api.Image.hosted)
    pub hosted: ::protobuf::MessageField<HostedURL>,
    ///  image info
    // @@protoc_insertion_point(field:clarifai.api.Image.image_info)
    pub image_info: ::protobuf::MessageField<ImageInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Image.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Image| { &m.url },
            |m: &mut Image| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "base64",
            |m: &Image| { &m.base64 },
            |m: &mut Image| { &mut m.base64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_duplicate_url",
            |m: &Image| { &m.allow_duplicate_url },
            |m: &mut Image| { &mut m.allow_duplicate_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HostedURL>(
            "hosted",
            |m: &Image| { &m.hosted },
            |m: &mut Image| { &mut m.hosted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageInfo>(
            "image_info",
            |m: &Image| { &m.image_info },
            |m: &mut Image| { &mut m.image_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Image>(
            "Image",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Image {
    const NAME: &'static str = "Image";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                18 => {
                    self.base64 = is.read_bytes()?;
                },
                32 => {
                    self.allow_duplicate_url = is.read_bool()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hosted)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.base64.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.base64);
        }
        if self.allow_duplicate_url != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hosted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.base64.is_empty() {
            os.write_bytes(2, &self.base64)?;
        }
        if self.allow_duplicate_url != false {
            os.write_bool(4, self.allow_duplicate_url)?;
        }
        if let Some(v) = self.hosted.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.image_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Image {
        Image::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.base64.clear();
        self.allow_duplicate_url = false;
        self.hosted.clear();
        self.image_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Image {
        static instance: Image = Image {
            url: ::std::string::String::new(),
            base64: ::std::vec::Vec::new(),
            allow_duplicate_url: false,
            hosted: ::protobuf::MessageField::none(),
            image_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Image {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Image").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ImageInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ImageInfo {
    // message fields
    ///  width
    // @@protoc_insertion_point(field:clarifai.api.ImageInfo.width)
    pub width: i32,
    ///  height
    // @@protoc_insertion_point(field:clarifai.api.ImageInfo.height)
    pub height: i32,
    ///  image format
    // @@protoc_insertion_point(field:clarifai.api.ImageInfo.format)
    pub format: ::std::string::String,
    ///  image color mode
    // @@protoc_insertion_point(field:clarifai.api.ImageInfo.color_mode)
    pub color_mode: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ImageInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ImageInfo {
    fn default() -> &'a ImageInfo {
        <ImageInfo as ::protobuf::Message>::default_instance()
    }
}

impl ImageInfo {
    pub fn new() -> ImageInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &ImageInfo| { &m.width },
            |m: &mut ImageInfo| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &ImageInfo| { &m.height },
            |m: &mut ImageInfo| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &ImageInfo| { &m.format },
            |m: &mut ImageInfo| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_mode",
            |m: &ImageInfo| { &m.color_mode },
            |m: &mut ImageInfo| { &mut m.color_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImageInfo>(
            "ImageInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ImageInfo {
    const NAME: &'static str = "ImageInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = is.read_int32()?;
                },
                16 => {
                    self.height = is.read_int32()?;
                },
                26 => {
                    self.format = is.read_string()?;
                },
                34 => {
                    self.color_mode = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.height);
        }
        if !self.format.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.format);
        }
        if !self.color_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.color_mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.width != 0 {
            os.write_int32(1, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        if !self.format.is_empty() {
            os.write_string(3, &self.format)?;
        }
        if !self.color_mode.is_empty() {
            os.write_string(4, &self.color_mode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ImageInfo {
        ImageInfo::new()
    }

    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.format.clear();
        self.color_mode.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ImageInfo {
        static instance: ImageInfo = ImageInfo {
            width: 0,
            height: 0,
            format: ::std::string::String::new(),
            color_mode: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ImageInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ImageInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ImageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  HostedURL
// @@protoc_insertion_point(message:clarifai.api.HostedURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HostedURL {
    // message fields
    ///  Prefix of the URL of every hosted image.
    // @@protoc_insertion_point(field:clarifai.api.HostedURL.prefix)
    pub prefix: ::std::string::String,
    ///  Suffix of an image stored in different sizes.
    // @@protoc_insertion_point(field:clarifai.api.HostedURL.suffix)
    pub suffix: ::std::string::String,
    ///  The sizes field lists which images of the different sizes are hosted in our storage. The URL
    ///  of each hosted image can be obtained by joining the prefix, one of the sizes and suffix.
    // @@protoc_insertion_point(field:clarifai.api.HostedURL.sizes)
    pub sizes: ::std::vec::Vec<::std::string::String>,
    ///  The crossorigin property of html media tag
    ///  For Secure Data Hosting this needs to be set to 'use-credentials'
    // @@protoc_insertion_point(field:clarifai.api.HostedURL.crossorigin)
    pub crossorigin: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.HostedURL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HostedURL {
    fn default() -> &'a HostedURL {
        <HostedURL as ::protobuf::Message>::default_instance()
    }
}

impl HostedURL {
    pub fn new() -> HostedURL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &HostedURL| { &m.prefix },
            |m: &mut HostedURL| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "suffix",
            |m: &HostedURL| { &m.suffix },
            |m: &mut HostedURL| { &mut m.suffix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sizes",
            |m: &HostedURL| { &m.sizes },
            |m: &mut HostedURL| { &mut m.sizes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "crossorigin",
            |m: &HostedURL| { &m.crossorigin },
            |m: &mut HostedURL| { &mut m.crossorigin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HostedURL>(
            "HostedURL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HostedURL {
    const NAME: &'static str = "HostedURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.prefix = is.read_string()?;
                },
                18 => {
                    self.suffix = is.read_string()?;
                },
                26 => {
                    self.sizes.push(is.read_string()?);
                },
                34 => {
                    self.crossorigin = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if !self.suffix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.suffix);
        }
        for value in &self.sizes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.crossorigin.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.crossorigin);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if !self.suffix.is_empty() {
            os.write_string(2, &self.suffix)?;
        }
        for v in &self.sizes {
            os.write_string(3, &v)?;
        };
        if !self.crossorigin.is_empty() {
            os.write_string(4, &self.crossorigin)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HostedURL {
        HostedURL::new()
    }

    fn clear(&mut self) {
        self.prefix.clear();
        self.suffix.clear();
        self.sizes.clear();
        self.crossorigin.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HostedURL {
        static instance: HostedURL = HostedURL {
            prefix: ::std::string::String::new(),
            suffix: ::std::string::String::new(),
            sizes: ::std::vec::Vec::new(),
            crossorigin: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HostedURL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HostedURL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HostedURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostedURL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Input
// @@protoc_insertion_point(message:clarifai.api.Input)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Input {
    // message fields
    ///  The ID for the input
    // @@protoc_insertion_point(field:clarifai.api.Input.id)
    pub id: ::std::string::String,
    ///  The data passed along in this input.
    // @@protoc_insertion_point(field:clarifai.api.Input.data)
    pub data: ::protobuf::MessageField<Data>,
    ///  When the input was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.Input.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the input was modified.
    // @@protoc_insertion_point(field:clarifai.api.Input.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  This is the status at a per Input level which allows for
    ///  partial failures.
    // @@protoc_insertion_point(field:clarifai.api.Input.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  List of dataset IDs that this input is part of
    ///  Currently, this field is ONLY used to
    ///  * search inputs part of dataset(s), e.g. in `PostSearches`, `PostInputsSearches` and `PostAnnotationsSearches` endpoints, and
    ///  * to add inputs to dataset(s) in `PostInputs` endpoint.
    ///  Note that this field is ignored for other endpoints, e.g. `GetInput`, `ListInputs` and `PatchInputs`.
    // @@protoc_insertion_point(field:clarifai.api.Input.dataset_ids)
    pub dataset_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Input.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Input {
    fn default() -> &'a Input {
        <Input as ::protobuf::Message>::default_instance()
    }
}

impl Input {
    pub fn new() -> Input {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Input| { &m.id },
            |m: &mut Input| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &Input| { &m.data },
            |m: &mut Input| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Input| { &m.created_at },
            |m: &mut Input| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Input| { &m.modified_at },
            |m: &mut Input| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &Input| { &m.status },
            |m: &mut Input| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_ids",
            |m: &Input| { &m.dataset_ids },
            |m: &mut Input| { &mut m.dataset_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Input>(
            "Input",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Input {
    const NAME: &'static str = "Input";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                58 => {
                    self.dataset_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_ids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.dataset_ids {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Input {
        Input::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.data.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.status.clear();
        self.dataset_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Input {
        static instance: Input = Input {
            id: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            dataset_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Input {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Input").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Input {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Input {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  InputBatch is a batch of Input resources. Large amounts of inputs are usually
///  divided into multiple InputBatches.
// @@protoc_insertion_point(message:clarifai.api.InputBatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputBatch {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.InputBatch.inputs)
    pub inputs: ::std::vec::Vec<Input>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputBatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputBatch {
    fn default() -> &'a InputBatch {
        <InputBatch as ::protobuf::Message>::default_instance()
    }
}

impl InputBatch {
    pub fn new() -> InputBatch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &InputBatch| { &m.inputs },
            |m: &mut InputBatch| { &mut m.inputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputBatch>(
            "InputBatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputBatch {
    const NAME: &'static str = "InputBatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.inputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputBatch {
        InputBatch::new()
    }

    fn clear(&mut self) {
        self.inputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputBatch {
        static instance: InputBatch = InputBatch {
            inputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputBatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputBatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputBatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputBatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  NOTE: inconsistency: this is weird mix of plural and singular words.
// @@protoc_insertion_point(message:clarifai.api.InputCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputCount {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.InputCount.processed)
    pub processed: u32,
    // @@protoc_insertion_point(field:clarifai.api.InputCount.to_process)
    pub to_process: u32,
    // @@protoc_insertion_point(field:clarifai.api.InputCount.errors)
    pub errors: u32,
    // @@protoc_insertion_point(field:clarifai.api.InputCount.processing)
    pub processing: u32,
    // @@protoc_insertion_point(field:clarifai.api.InputCount.reindexed)
    pub reindexed: u32,
    // @@protoc_insertion_point(field:clarifai.api.InputCount.to_reindex)
    pub to_reindex: u32,
    // @@protoc_insertion_point(field:clarifai.api.InputCount.reindex_errors)
    pub reindex_errors: u32,
    // @@protoc_insertion_point(field:clarifai.api.InputCount.reindexing)
    pub reindexing: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputCount {
    fn default() -> &'a InputCount {
        <InputCount as ::protobuf::Message>::default_instance()
    }
}

impl InputCount {
    pub fn new() -> InputCount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "processed",
            |m: &InputCount| { &m.processed },
            |m: &mut InputCount| { &mut m.processed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to_process",
            |m: &InputCount| { &m.to_process },
            |m: &mut InputCount| { &mut m.to_process },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errors",
            |m: &InputCount| { &m.errors },
            |m: &mut InputCount| { &mut m.errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "processing",
            |m: &InputCount| { &m.processing },
            |m: &mut InputCount| { &mut m.processing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindexed",
            |m: &InputCount| { &m.reindexed },
            |m: &mut InputCount| { &mut m.reindexed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to_reindex",
            |m: &InputCount| { &m.to_reindex },
            |m: &mut InputCount| { &mut m.to_reindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindex_errors",
            |m: &InputCount| { &m.reindex_errors },
            |m: &mut InputCount| { &mut m.reindex_errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindexing",
            |m: &InputCount| { &m.reindexing },
            |m: &mut InputCount| { &mut m.reindexing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputCount>(
            "InputCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputCount {
    const NAME: &'static str = "InputCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.processed = is.read_uint32()?;
                },
                16 => {
                    self.to_process = is.read_uint32()?;
                },
                24 => {
                    self.errors = is.read_uint32()?;
                },
                32 => {
                    self.processing = is.read_uint32()?;
                },
                40 => {
                    self.reindexed = is.read_uint32()?;
                },
                48 => {
                    self.to_reindex = is.read_uint32()?;
                },
                56 => {
                    self.reindex_errors = is.read_uint32()?;
                },
                64 => {
                    self.reindexing = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.processed != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.processed);
        }
        if self.to_process != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.to_process);
        }
        if self.errors != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.errors);
        }
        if self.processing != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.processing);
        }
        if self.reindexed != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.reindexed);
        }
        if self.to_reindex != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.to_reindex);
        }
        if self.reindex_errors != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.reindex_errors);
        }
        if self.reindexing != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.reindexing);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.processed != 0 {
            os.write_uint32(1, self.processed)?;
        }
        if self.to_process != 0 {
            os.write_uint32(2, self.to_process)?;
        }
        if self.errors != 0 {
            os.write_uint32(3, self.errors)?;
        }
        if self.processing != 0 {
            os.write_uint32(4, self.processing)?;
        }
        if self.reindexed != 0 {
            os.write_uint32(5, self.reindexed)?;
        }
        if self.to_reindex != 0 {
            os.write_uint32(6, self.to_reindex)?;
        }
        if self.reindex_errors != 0 {
            os.write_uint32(7, self.reindex_errors)?;
        }
        if self.reindexing != 0 {
            os.write_uint32(8, self.reindexing)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputCount {
        InputCount::new()
    }

    fn clear(&mut self) {
        self.processed = 0;
        self.to_process = 0;
        self.errors = 0;
        self.processing = 0;
        self.reindexed = 0;
        self.to_reindex = 0;
        self.reindex_errors = 0;
        self.reindexing = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputCount {
        static instance: InputCount = InputCount {
            processed: 0,
            to_process: 0,
            errors: 0,
            processing: 0,
            reindexed: 0,
            to_reindex: 0,
            reindex_errors: 0,
            reindexing: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Dataset
// @@protoc_insertion_point(message:clarifai.api.Dataset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Dataset {
    // message fields
    ///  The ID for the dataset
    // @@protoc_insertion_point(field:clarifai.api.Dataset.id)
    pub id: ::std::string::String,
    ///  When the dataset was created.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.Dataset.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the dataset was modified.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.Dataset.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The app the dataset belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.app_id)
    pub app_id: ::std::string::String,
    ///  The user the dataset belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.user_id)
    pub user_id: ::std::string::String,
    ///  Description of the dataset
    // @@protoc_insertion_point(field:clarifai.api.Dataset.description)
    pub description: ::std::string::String,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.Dataset.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  Default annotation filter used for this dataset.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.default_annotation_filter)
    pub default_annotation_filter: ::protobuf::MessageField<AnnotationFilter>,
    ///  Default processing info used for this dataset.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.default_processing_info)
    pub default_processing_info: ::protobuf::MessageField<DatasetVersionProcessingInfo>,
    ///  Notes for the dataset
    ///  This field should be used for in-depth notes and supports up to 64Kbs.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.notes)
    pub notes: ::std::string::String,
    ///  Dataset version associated with this dataset. This is used in listing Datasets
    ///  and including the latest version.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.version)
    pub version: ::protobuf::MessageField<DatasetVersion>,
    ///  Whether the dataset is starred by the requesting user.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.is_starred)
    pub is_starred: bool,
    ///  Number of users that starred this dataset.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.star_count)
    pub star_count: i32,
    ///  bookmark info. When set, this dataset is a bookmarked dataset of this app.
    ///  Info in this field will allow you to find/access original dataset.
    // @@protoc_insertion_point(field:clarifai.api.Dataset.bookmark_origin)
    pub bookmark_origin: ::protobuf::MessageField<BookmarkOrigin>,
    ///  Representative image for this dataset
    // @@protoc_insertion_point(field:clarifai.api.Dataset.image)
    pub image: ::protobuf::MessageField<Image>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Dataset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Dataset {
    fn default() -> &'a Dataset {
        <Dataset as ::protobuf::Message>::default_instance()
    }
}

impl Dataset {
    pub fn new() -> Dataset {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Dataset| { &m.id },
            |m: &mut Dataset| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Dataset| { &m.created_at },
            |m: &mut Dataset| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Dataset| { &m.modified_at },
            |m: &mut Dataset| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &Dataset| { &m.app_id },
            |m: &mut Dataset| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Dataset| { &m.user_id },
            |m: &mut Dataset| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Dataset| { &m.description },
            |m: &mut Dataset| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &Dataset| { &m.metadata },
            |m: &mut Dataset| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &Dataset| { &m.visibility },
            |m: &mut Dataset| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AnnotationFilter>(
            "default_annotation_filter",
            |m: &Dataset| { &m.default_annotation_filter },
            |m: &mut Dataset| { &mut m.default_annotation_filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DatasetVersionProcessingInfo>(
            "default_processing_info",
            |m: &Dataset| { &m.default_processing_info },
            |m: &mut Dataset| { &mut m.default_processing_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "notes",
            |m: &Dataset| { &m.notes },
            |m: &mut Dataset| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DatasetVersion>(
            "version",
            |m: &Dataset| { &m.version },
            |m: &mut Dataset| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_starred",
            |m: &Dataset| { &m.is_starred },
            |m: &mut Dataset| { &mut m.is_starred },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "star_count",
            |m: &Dataset| { &m.star_count },
            |m: &mut Dataset| { &mut m.star_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BookmarkOrigin>(
            "bookmark_origin",
            |m: &Dataset| { &m.bookmark_origin },
            |m: &mut Dataset| { &mut m.bookmark_origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &Dataset| { &m.image },
            |m: &mut Dataset| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Dataset>(
            "Dataset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Dataset {
    const NAME: &'static str = "Dataset";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                34 => {
                    self.app_id = is.read_string()?;
                },
                42 => {
                    self.user_id = is.read_string()?;
                },
                58 => {
                    self.description = is.read_string()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_annotation_filter)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_processing_info)?;
                },
                90 => {
                    self.notes = is.read_string()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                112 => {
                    self.is_starred = is.read_bool()?;
                },
                120 => {
                    self.star_count = is.read_int32()?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bookmark_origin)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.description);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.default_annotation_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.default_processing_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.notes);
        }
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.is_starred != false {
            my_size += 1 + 1;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::int32_size(15, self.star_count);
        }
        if let Some(v) = self.bookmark_origin.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(4, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(5, &self.user_id)?;
        }
        if !self.description.is_empty() {
            os.write_string(7, &self.description)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.default_annotation_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.default_processing_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if !self.notes.is_empty() {
            os.write_string(11, &self.notes)?;
        }
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if self.is_starred != false {
            os.write_bool(14, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(15, self.star_count)?;
        }
        if let Some(v) = self.bookmark_origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Dataset {
        Dataset::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.description.clear();
        self.metadata.clear();
        self.visibility.clear();
        self.default_annotation_filter.clear();
        self.default_processing_info.clear();
        self.notes.clear();
        self.version.clear();
        self.is_starred = false;
        self.star_count = 0;
        self.bookmark_origin.clear();
        self.image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Dataset {
        static instance: Dataset = Dataset {
            id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            metadata: ::protobuf::MessageField::none(),
            visibility: ::protobuf::MessageField::none(),
            default_annotation_filter: ::protobuf::MessageField::none(),
            default_processing_info: ::protobuf::MessageField::none(),
            notes: ::std::string::String::new(),
            version: ::protobuf::MessageField::none(),
            is_starred: false,
            star_count: 0,
            bookmark_origin: ::protobuf::MessageField::none(),
            image: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Dataset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Dataset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Dataset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dataset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  AnnotationFilter is used to create a new dataset version.
///  For now, the filter is simply a wrapper over a Search.
///  In the future, we may add extra fields to customize the filtering.
// @@protoc_insertion_point(message:clarifai.api.AnnotationFilter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AnnotationFilter {
    // message fields
    ///  The ID for the annotation filter
    // @@protoc_insertion_point(field:clarifai.api.AnnotationFilter.id)
    pub id: ::std::string::String,
    ///  When the annotation filter was created.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.AnnotationFilter.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the annotation filter was modified.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.AnnotationFilter.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The user the annotation filter belongs to.
    // @@protoc_insertion_point(field:clarifai.api.AnnotationFilter.user_id)
    pub user_id: ::std::string::String,
    ///  The app the annotation filter belongs to.
    // @@protoc_insertion_point(field:clarifai.api.AnnotationFilter.app_id)
    pub app_id: ::std::string::String,
    ///  The search that this filter uses.
    // @@protoc_insertion_point(field:clarifai.api.AnnotationFilter.search)
    pub search: ::protobuf::MessageField<Search>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AnnotationFilter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AnnotationFilter {
    fn default() -> &'a AnnotationFilter {
        <AnnotationFilter as ::protobuf::Message>::default_instance()
    }
}

impl AnnotationFilter {
    pub fn new() -> AnnotationFilter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AnnotationFilter| { &m.id },
            |m: &mut AnnotationFilter| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &AnnotationFilter| { &m.created_at },
            |m: &mut AnnotationFilter| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &AnnotationFilter| { &m.modified_at },
            |m: &mut AnnotationFilter| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &AnnotationFilter| { &m.user_id },
            |m: &mut AnnotationFilter| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &AnnotationFilter| { &m.app_id },
            |m: &mut AnnotationFilter| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Search>(
            "search",
            |m: &AnnotationFilter| { &m.search },
            |m: &mut AnnotationFilter| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnnotationFilter>(
            "AnnotationFilter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AnnotationFilter {
    const NAME: &'static str = "AnnotationFilter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                34 => {
                    self.user_id = is.read_string()?;
                },
                42 => {
                    self.app_id = is.read_string()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.app_id);
        }
        if let Some(v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(4, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(5, &self.app_id)?;
        }
        if let Some(v) = self.search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AnnotationFilter {
        AnnotationFilter::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.user_id.clear();
        self.app_id.clear();
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AnnotationFilter {
        static instance: AnnotationFilter = AnnotationFilter {
            id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            search: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AnnotationFilter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AnnotationFilter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AnnotationFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotationFilter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DatasetInput
// @@protoc_insertion_point(message:clarifai.api.DatasetInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetInput {
    // message fields
    ///  When the input was added to the dataset.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.DatasetInput.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The input data.
    // @@protoc_insertion_point(field:clarifai.api.DatasetInput.input)
    pub input: ::protobuf::MessageField<Input>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetInput {
    fn default() -> &'a DatasetInput {
        <DatasetInput as ::protobuf::Message>::default_instance()
    }
}

impl DatasetInput {
    pub fn new() -> DatasetInput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &DatasetInput| { &m.created_at },
            |m: &mut DatasetInput| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input",
            |m: &DatasetInput| { &m.input },
            |m: &mut DatasetInput| { &mut m.input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetInput>(
            "DatasetInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetInput {
    const NAME: &'static str = "DatasetInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetInput {
        DatasetInput::new()
    }

    fn clear(&mut self) {
        self.created_at.clear();
        self.input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetInput {
        static instance: DatasetInput = DatasetInput {
            created_at: ::protobuf::MessageField::none(),
            input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DatasetInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DatasetVersion
// @@protoc_insertion_point(message:clarifai.api.DatasetVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetVersion {
    // message fields
    ///  The ID for the dataset version
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.id)
    pub id: ::std::string::String,
    ///  When the dataset version was created.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the dataset version was modified.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The app the dataset version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.app_id)
    pub app_id: ::std::string::String,
    ///  The user the dataset version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.user_id)
    pub user_id: ::std::string::String,
    ///  The dataset the dataset version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Status for this dataset version.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  Description of the dataset version
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.description)
    pub description: ::std::string::String,
    ///  Dataset version processing. If this is not set when the dataset version is
    ///  created, then the dataset default_processing_info is copied instead. Later
    ///  updates to default_processing_info will not apply to existing versions.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.processing_info)
    pub processing_info: ::protobuf::MessageField<DatasetVersionProcessingInfo>,
    ///  Dataset version metrics
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.metrics)
    pub metrics: ::std::collections::HashMap<::std::string::String, DatasetVersionMetrics>,
    ///  Dataset version exports
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.export_info)
    pub export_info: ::protobuf::MessageField<DatasetVersionExportInfo>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  The embedding models to return embeddings for. If empty, no embeddings are returned.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.embed_model_version_ids)
    pub embed_model_version_ids: ::std::vec::Vec<::std::string::String>,
    ///  Read Only. Cannot be Set
    ///  Origin of request for new dataset version
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersion.request_origin)
    pub request_origin: ::protobuf::EnumOrUnknown<DatasetVersionRequestOrigin>,
    // message oneof groups
    pub data_config: ::std::option::Option<dataset_version::Data_config>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetVersion {
    fn default() -> &'a DatasetVersion {
        <DatasetVersion as ::protobuf::Message>::default_instance()
    }
}

impl DatasetVersion {
    pub fn new() -> DatasetVersion {
        ::std::default::Default::default()
    }

    // .clarifai.api.AnnotationFilterConfig annotation_filter_config = 15;

    pub fn annotation_filter_config(&self) -> &AnnotationFilterConfig {
        match self.data_config {
            ::std::option::Option::Some(dataset_version::Data_config::AnnotationFilterConfig(ref v)) => v,
            _ => <AnnotationFilterConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_annotation_filter_config(&mut self) {
        self.data_config = ::std::option::Option::None;
    }

    pub fn has_annotation_filter_config(&self) -> bool {
        match self.data_config {
            ::std::option::Option::Some(dataset_version::Data_config::AnnotationFilterConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_annotation_filter_config(&mut self, v: AnnotationFilterConfig) {
        self.data_config = ::std::option::Option::Some(dataset_version::Data_config::AnnotationFilterConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_filter_config(&mut self) -> &mut AnnotationFilterConfig {
        if let ::std::option::Option::Some(dataset_version::Data_config::AnnotationFilterConfig(_)) = self.data_config {
        } else {
            self.data_config = ::std::option::Option::Some(dataset_version::Data_config::AnnotationFilterConfig(AnnotationFilterConfig::new()));
        }
        match self.data_config {
            ::std::option::Option::Some(dataset_version::Data_config::AnnotationFilterConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_annotation_filter_config(&mut self) -> AnnotationFilterConfig {
        if self.has_annotation_filter_config() {
            match self.data_config.take() {
                ::std::option::Option::Some(dataset_version::Data_config::AnnotationFilterConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            AnnotationFilterConfig::new()
        }
    }

    // .clarifai.api.ModelPredictConfig model_predict_config = 18;

    pub fn model_predict_config(&self) -> &ModelPredictConfig {
        match self.data_config {
            ::std::option::Option::Some(dataset_version::Data_config::ModelPredictConfig(ref v)) => v,
            _ => <ModelPredictConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_model_predict_config(&mut self) {
        self.data_config = ::std::option::Option::None;
    }

    pub fn has_model_predict_config(&self) -> bool {
        match self.data_config {
            ::std::option::Option::Some(dataset_version::Data_config::ModelPredictConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_model_predict_config(&mut self, v: ModelPredictConfig) {
        self.data_config = ::std::option::Option::Some(dataset_version::Data_config::ModelPredictConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_model_predict_config(&mut self) -> &mut ModelPredictConfig {
        if let ::std::option::Option::Some(dataset_version::Data_config::ModelPredictConfig(_)) = self.data_config {
        } else {
            self.data_config = ::std::option::Option::Some(dataset_version::Data_config::ModelPredictConfig(ModelPredictConfig::new()));
        }
        match self.data_config {
            ::std::option::Option::Some(dataset_version::Data_config::ModelPredictConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_model_predict_config(&mut self) -> ModelPredictConfig {
        if self.has_model_predict_config() {
            match self.data_config.take() {
                ::std::option::Option::Some(dataset_version::Data_config::ModelPredictConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ModelPredictConfig::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DatasetVersion| { &m.id },
            |m: &mut DatasetVersion| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &DatasetVersion| { &m.created_at },
            |m: &mut DatasetVersion| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &DatasetVersion| { &m.modified_at },
            |m: &mut DatasetVersion| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &DatasetVersion| { &m.app_id },
            |m: &mut DatasetVersion| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &DatasetVersion| { &m.user_id },
            |m: &mut DatasetVersion| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DatasetVersion| { &m.dataset_id },
            |m: &mut DatasetVersion| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AnnotationFilterConfig>(
            "annotation_filter_config",
            DatasetVersion::has_annotation_filter_config,
            DatasetVersion::annotation_filter_config,
            DatasetVersion::mut_annotation_filter_config,
            DatasetVersion::set_annotation_filter_config,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ModelPredictConfig>(
            "model_predict_config",
            DatasetVersion::has_model_predict_config,
            DatasetVersion::model_predict_config,
            DatasetVersion::mut_model_predict_config,
            DatasetVersion::set_model_predict_config,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &DatasetVersion| { &m.status },
            |m: &mut DatasetVersion| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &DatasetVersion| { &m.description },
            |m: &mut DatasetVersion| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DatasetVersionProcessingInfo>(
            "processing_info",
            |m: &DatasetVersion| { &m.processing_info },
            |m: &mut DatasetVersion| { &mut m.processing_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "metrics",
            |m: &DatasetVersion| { &m.metrics },
            |m: &mut DatasetVersion| { &mut m.metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DatasetVersionExportInfo>(
            "export_info",
            |m: &DatasetVersion| { &m.export_info },
            |m: &mut DatasetVersion| { &mut m.export_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &DatasetVersion| { &m.metadata },
            |m: &mut DatasetVersion| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &DatasetVersion| { &m.visibility },
            |m: &mut DatasetVersion| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "embed_model_version_ids",
            |m: &DatasetVersion| { &m.embed_model_version_ids },
            |m: &mut DatasetVersion| { &mut m.embed_model_version_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_origin",
            |m: &DatasetVersion| { &m.request_origin },
            |m: &mut DatasetVersion| { &mut m.request_origin },
        ));
        oneofs.push(dataset_version::Data_config::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetVersion>(
            "DatasetVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetVersion {
    const NAME: &'static str = "DatasetVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                34 => {
                    self.app_id = is.read_string()?;
                },
                42 => {
                    self.user_id = is.read_string()?;
                },
                50 => {
                    self.dataset_id = is.read_string()?;
                },
                122 => {
                    self.data_config = ::std::option::Option::Some(dataset_version::Data_config::AnnotationFilterConfig(is.read_message()?));
                },
                146 => {
                    self.data_config = ::std::option::Option::Some(dataset_version::Data_config::ModelPredictConfig(is.read_message()?));
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                82 => {
                    self.description = is.read_string()?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.processing_info)?;
                },
                130 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metrics.insert(key, value);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.export_info)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                114 => {
                    self.embed_model_version_ids.push(is.read_string()?);
                },
                160 => {
                    self.request_origin = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_id);
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.dataset_id);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.description);
        }
        if let Some(v) = self.processing_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.metrics {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.export_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.embed_model_version_ids {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if self.request_origin != ::protobuf::EnumOrUnknown::new(DatasetVersionRequestOrigin::DATASET_VERSION_REQUEST_ORIGIN_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(20, self.request_origin.value());
        }
        if let ::std::option::Option::Some(ref v) = self.data_config {
            match v {
                &dataset_version::Data_config::AnnotationFilterConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &dataset_version::Data_config::ModelPredictConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(4, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(5, &self.user_id)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(6, &self.dataset_id)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if !self.description.is_empty() {
            os.write_string(10, &self.description)?;
        }
        if let Some(v) = self.processing_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        for (k, v) in &self.metrics {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(130)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.export_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        for v in &self.embed_model_version_ids {
            os.write_string(14, &v)?;
        };
        if self.request_origin != ::protobuf::EnumOrUnknown::new(DatasetVersionRequestOrigin::DATASET_VERSION_REQUEST_ORIGIN_NOT_SET) {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&self.request_origin))?;
        }
        if let ::std::option::Option::Some(ref v) = self.data_config {
            match v {
                &dataset_version::Data_config::AnnotationFilterConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &dataset_version::Data_config::ModelPredictConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetVersion {
        DatasetVersion::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.dataset_id.clear();
        self.data_config = ::std::option::Option::None;
        self.data_config = ::std::option::Option::None;
        self.status.clear();
        self.description.clear();
        self.processing_info.clear();
        self.metrics.clear();
        self.export_info.clear();
        self.metadata.clear();
        self.visibility.clear();
        self.embed_model_version_ids.clear();
        self.request_origin = ::protobuf::EnumOrUnknown::new(DatasetVersionRequestOrigin::DATASET_VERSION_REQUEST_ORIGIN_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetVersion {
        static instance: ::protobuf::rt::Lazy<DatasetVersion> = ::protobuf::rt::Lazy::new();
        instance.get(DatasetVersion::new)
    }
}

impl ::protobuf::MessageFull for DatasetVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DatasetVersion`
pub mod dataset_version {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.DatasetVersion.data_config)
    pub enum Data_config {
        // @@protoc_insertion_point(oneof_field:clarifai.api.DatasetVersion.annotation_filter_config)
        AnnotationFilterConfig(super::AnnotationFilterConfig),
        // @@protoc_insertion_point(oneof_field:clarifai.api.DatasetVersion.model_predict_config)
        ModelPredictConfig(super::ModelPredictConfig),
    }

    impl ::protobuf::Oneof for Data_config {
    }

    impl ::protobuf::OneofFull for Data_config {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DatasetVersion as ::protobuf::MessageFull>::descriptor().oneof_by_name("data_config").unwrap()).clone()
        }
    }

    impl Data_config {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data_config>("data_config")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.AnnotationFilterConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AnnotationFilterConfig {
    // message fields
    ///  The annotation filter that is used.
    // @@protoc_insertion_point(field:clarifai.api.AnnotationFilterConfig.annotation_filter)
    pub annotation_filter: ::protobuf::MessageField<AnnotationFilter>,
    ///  If true, empty inputs are not included in the dataset version.
    ///  If false, empty inputs are included in the dataset version.
    ///  We define an empty input as an input without any annotations after annotation filter is applied.
    // @@protoc_insertion_point(field:clarifai.api.AnnotationFilterConfig.ignore_empty_inputs)
    pub ignore_empty_inputs: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AnnotationFilterConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AnnotationFilterConfig {
    fn default() -> &'a AnnotationFilterConfig {
        <AnnotationFilterConfig as ::protobuf::Message>::default_instance()
    }
}

impl AnnotationFilterConfig {
    pub fn new() -> AnnotationFilterConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AnnotationFilter>(
            "annotation_filter",
            |m: &AnnotationFilterConfig| { &m.annotation_filter },
            |m: &mut AnnotationFilterConfig| { &mut m.annotation_filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ignore_empty_inputs",
            |m: &AnnotationFilterConfig| { &m.ignore_empty_inputs },
            |m: &mut AnnotationFilterConfig| { &mut m.ignore_empty_inputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnnotationFilterConfig>(
            "AnnotationFilterConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AnnotationFilterConfig {
    const NAME: &'static str = "AnnotationFilterConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation_filter)?;
                },
                16 => {
                    self.ignore_empty_inputs = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.annotation_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.ignore_empty_inputs != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.annotation_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.ignore_empty_inputs != false {
            os.write_bool(2, self.ignore_empty_inputs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AnnotationFilterConfig {
        AnnotationFilterConfig::new()
    }

    fn clear(&mut self) {
        self.annotation_filter.clear();
        self.ignore_empty_inputs = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AnnotationFilterConfig {
        static instance: AnnotationFilterConfig = AnnotationFilterConfig {
            annotation_filter: ::protobuf::MessageField::none(),
            ignore_empty_inputs: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AnnotationFilterConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AnnotationFilterConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AnnotationFilterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotationFilterConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ModelPredictConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelPredictConfig {
    // message fields
    ///  Assumed to be owned by the calling users app unless user_id and app_id are filled out.
    // @@protoc_insertion_point(field:clarifai.api.ModelPredictConfig.model)
    pub model: ::protobuf::MessageField<Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelPredictConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelPredictConfig {
    fn default() -> &'a ModelPredictConfig {
        <ModelPredictConfig as ::protobuf::Message>::default_instance()
    }
}

impl ModelPredictConfig {
    pub fn new() -> ModelPredictConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Model>(
            "model",
            |m: &ModelPredictConfig| { &m.model },
            |m: &mut ModelPredictConfig| { &mut m.model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelPredictConfig>(
            "ModelPredictConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelPredictConfig {
    const NAME: &'static str = "ModelPredictConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelPredictConfig {
        ModelPredictConfig::new()
    }

    fn clear(&mut self) {
        self.model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelPredictConfig {
        static instance: ModelPredictConfig = ModelPredictConfig {
            model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelPredictConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelPredictConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelPredictConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelPredictConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.DatasetVersionMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetVersionMetrics {
    // message fields
    ///  Number of inputs
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.inputs_count)
    pub inputs_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of unlabeled inputs
    ///  An input is considered unlabeled if it there are no annotations with positive labels for that input.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.unlabeled_inputs_count)
    pub unlabeled_inputs_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of inputs that have metadata
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.inputs_with_metadata_count)
    pub inputs_with_metadata_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of inputs that have geo information
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.inputs_with_geo_count)
    pub inputs_with_geo_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of regions
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.regions_count)
    pub regions_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  The matrix shows where the regions are located.
    ///  Example: If the matrix has 2x2 dimensions, then
    ///  * region_location_matrix[0][0] = the number of regions that appear in the top left corner, i.e. [0,0]..(0.5,0.5)
    ///  * region_location_matrix[0][1] = the number of regions that appear in the top right corner, i.e. [0,0.5]..[0.5,1]
    ///  * region_location_matrix[1][0] = the number of regions that appear in the bottom left corner, i.e. [0.5,0]..[1,0.5)
    ///  * region_location_matrix[1][1] = the number of regions that appear in the bottom right corner, i.e. [0.5,0.5]..[1,1]
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.region_location_matrix)
    pub region_location_matrix: ::protobuf::MessageField<super::matrix::MatrixUint64>,
    ///  Number of bounding boxes
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.bounding_boxes_count)
    pub bounding_boxes_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of polygons
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.polygons_count)
    pub polygons_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of points
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.points_count)
    pub points_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of masks
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.masks_count)
    pub masks_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of inputs that have regions attached
    ///  Note that this is not a recursive count: if an input contains frames that contains regions, then the region_frames_count is increased, but region_inputs_count is not increased.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.region_inputs_count)
    pub region_inputs_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of frames that have regions attached
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.region_frames_count)
    pub region_frames_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of frames
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.frames_count)
    pub frames_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of inputs that have frames attached
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.frame_inputs_count)
    pub frame_inputs_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of embeddings
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.embeddings_count)
    pub embeddings_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of positive tags added at input-level
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.positive_input_tags_count)
    pub positive_input_tags_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of positive tags added at region-level
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.positive_region_tags_count)
    pub positive_region_tags_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    ///  Number of positive tags added at frame-level
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetrics.positive_frame_tags_count)
    pub positive_frame_tags_count: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::UInt64Value>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetVersionMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetVersionMetrics {
    fn default() -> &'a DatasetVersionMetrics {
        <DatasetVersionMetrics as ::protobuf::Message>::default_instance()
    }
}

impl DatasetVersionMetrics {
    pub fn new() -> DatasetVersionMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "inputs_count",
            |m: &DatasetVersionMetrics| { &m.inputs_count },
            |m: &mut DatasetVersionMetrics| { &mut m.inputs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "unlabeled_inputs_count",
            |m: &DatasetVersionMetrics| { &m.unlabeled_inputs_count },
            |m: &mut DatasetVersionMetrics| { &mut m.unlabeled_inputs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "inputs_with_metadata_count",
            |m: &DatasetVersionMetrics| { &m.inputs_with_metadata_count },
            |m: &mut DatasetVersionMetrics| { &mut m.inputs_with_metadata_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "inputs_with_geo_count",
            |m: &DatasetVersionMetrics| { &m.inputs_with_geo_count },
            |m: &mut DatasetVersionMetrics| { &mut m.inputs_with_geo_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "regions_count",
            |m: &DatasetVersionMetrics| { &m.regions_count },
            |m: &mut DatasetVersionMetrics| { &mut m.regions_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::matrix::MatrixUint64>(
            "region_location_matrix",
            |m: &DatasetVersionMetrics| { &m.region_location_matrix },
            |m: &mut DatasetVersionMetrics| { &mut m.region_location_matrix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "bounding_boxes_count",
            |m: &DatasetVersionMetrics| { &m.bounding_boxes_count },
            |m: &mut DatasetVersionMetrics| { &mut m.bounding_boxes_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "polygons_count",
            |m: &DatasetVersionMetrics| { &m.polygons_count },
            |m: &mut DatasetVersionMetrics| { &mut m.polygons_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "points_count",
            |m: &DatasetVersionMetrics| { &m.points_count },
            |m: &mut DatasetVersionMetrics| { &mut m.points_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "masks_count",
            |m: &DatasetVersionMetrics| { &m.masks_count },
            |m: &mut DatasetVersionMetrics| { &mut m.masks_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "region_inputs_count",
            |m: &DatasetVersionMetrics| { &m.region_inputs_count },
            |m: &mut DatasetVersionMetrics| { &mut m.region_inputs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "region_frames_count",
            |m: &DatasetVersionMetrics| { &m.region_frames_count },
            |m: &mut DatasetVersionMetrics| { &mut m.region_frames_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "frames_count",
            |m: &DatasetVersionMetrics| { &m.frames_count },
            |m: &mut DatasetVersionMetrics| { &mut m.frames_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "frame_inputs_count",
            |m: &DatasetVersionMetrics| { &m.frame_inputs_count },
            |m: &mut DatasetVersionMetrics| { &mut m.frame_inputs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "embeddings_count",
            |m: &DatasetVersionMetrics| { &m.embeddings_count },
            |m: &mut DatasetVersionMetrics| { &mut m.embeddings_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "positive_input_tags_count",
            |m: &DatasetVersionMetrics| { &m.positive_input_tags_count },
            |m: &mut DatasetVersionMetrics| { &mut m.positive_input_tags_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "positive_region_tags_count",
            |m: &DatasetVersionMetrics| { &m.positive_region_tags_count },
            |m: &mut DatasetVersionMetrics| { &mut m.positive_region_tags_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::UInt64Value>(
            "positive_frame_tags_count",
            |m: &DatasetVersionMetrics| { &m.positive_frame_tags_count },
            |m: &mut DatasetVersionMetrics| { &mut m.positive_frame_tags_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetVersionMetrics>(
            "DatasetVersionMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetVersionMetrics {
    const NAME: &'static str = "DatasetVersionMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_count)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unlabeled_inputs_count)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_with_metadata_count)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_with_geo_count)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.regions_count)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.region_location_matrix)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bounding_boxes_count)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.polygons_count)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.points_count)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.masks_count)?;
                },
                482 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.region_inputs_count)?;
                },
                490 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.region_frames_count)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.frames_count)?;
                },
                562 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.frame_inputs_count)?;
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.embeddings_count)?;
                },
                402 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.positive_input_tags_count)?;
                },
                410 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.positive_region_tags_count)?;
                },
                418 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.positive_frame_tags_count)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inputs_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unlabeled_inputs_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inputs_with_metadata_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inputs_with_geo_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.regions_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.region_location_matrix.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bounding_boxes_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.polygons_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.points_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.masks_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.region_inputs_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.region_frames_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.frames_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.frame_inputs_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.embeddings_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.positive_input_tags_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.positive_region_tags_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.positive_frame_tags_count.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inputs_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.unlabeled_inputs_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.inputs_with_metadata_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.inputs_with_geo_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.regions_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.region_location_matrix.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.bounding_boxes_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.polygons_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.points_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.masks_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.region_inputs_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(60, v, os)?;
        }
        if let Some(v) = self.region_frames_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(61, v, os)?;
        }
        if let Some(v) = self.frames_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.frame_inputs_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(70, v, os)?;
        }
        if let Some(v) = self.embeddings_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.positive_input_tags_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        if let Some(v) = self.positive_region_tags_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        }
        if let Some(v) = self.positive_frame_tags_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(52, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetVersionMetrics {
        DatasetVersionMetrics::new()
    }

    fn clear(&mut self) {
        self.inputs_count.clear();
        self.unlabeled_inputs_count.clear();
        self.inputs_with_metadata_count.clear();
        self.inputs_with_geo_count.clear();
        self.regions_count.clear();
        self.region_location_matrix.clear();
        self.bounding_boxes_count.clear();
        self.polygons_count.clear();
        self.points_count.clear();
        self.masks_count.clear();
        self.region_inputs_count.clear();
        self.region_frames_count.clear();
        self.frames_count.clear();
        self.frame_inputs_count.clear();
        self.embeddings_count.clear();
        self.positive_input_tags_count.clear();
        self.positive_region_tags_count.clear();
        self.positive_frame_tags_count.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetVersionMetrics {
        static instance: DatasetVersionMetrics = DatasetVersionMetrics {
            inputs_count: ::protobuf::MessageField::none(),
            unlabeled_inputs_count: ::protobuf::MessageField::none(),
            inputs_with_metadata_count: ::protobuf::MessageField::none(),
            inputs_with_geo_count: ::protobuf::MessageField::none(),
            regions_count: ::protobuf::MessageField::none(),
            region_location_matrix: ::protobuf::MessageField::none(),
            bounding_boxes_count: ::protobuf::MessageField::none(),
            polygons_count: ::protobuf::MessageField::none(),
            points_count: ::protobuf::MessageField::none(),
            masks_count: ::protobuf::MessageField::none(),
            region_inputs_count: ::protobuf::MessageField::none(),
            region_frames_count: ::protobuf::MessageField::none(),
            frames_count: ::protobuf::MessageField::none(),
            frame_inputs_count: ::protobuf::MessageField::none(),
            embeddings_count: ::protobuf::MessageField::none(),
            positive_input_tags_count: ::protobuf::MessageField::none(),
            positive_region_tags_count: ::protobuf::MessageField::none(),
            positive_frame_tags_count: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DatasetVersionMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetVersionMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetVersionMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersionMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.DatasetVersionMetricsGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetVersionMetricsGroup {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetricsGroup.parent_path)
    pub parent_path: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetricsGroup.type)
    pub type_: ::protobuf::EnumOrUnknown<DatasetVersionMetricsGroupType>,
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetricsGroup.value)
    pub value: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Value>,
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionMetricsGroup.metrics)
    pub metrics: ::protobuf::MessageField<DatasetVersionMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetVersionMetricsGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetVersionMetricsGroup {
    fn default() -> &'a DatasetVersionMetricsGroup {
        <DatasetVersionMetricsGroup as ::protobuf::Message>::default_instance()
    }
}

impl DatasetVersionMetricsGroup {
    pub fn new() -> DatasetVersionMetricsGroup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_path",
            |m: &DatasetVersionMetricsGroup| { &m.parent_path },
            |m: &mut DatasetVersionMetricsGroup| { &mut m.parent_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &DatasetVersionMetricsGroup| { &m.type_ },
            |m: &mut DatasetVersionMetricsGroup| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Value>(
            "value",
            |m: &DatasetVersionMetricsGroup| { &m.value },
            |m: &mut DatasetVersionMetricsGroup| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DatasetVersionMetrics>(
            "metrics",
            |m: &DatasetVersionMetricsGroup| { &m.metrics },
            |m: &mut DatasetVersionMetricsGroup| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetVersionMetricsGroup>(
            "DatasetVersionMetricsGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetVersionMetricsGroup {
    const NAME: &'static str = "DatasetVersionMetricsGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.parent_path = is.read_string()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.parent_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent_path);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(DatasetVersionMetricsGroupType::DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.parent_path.is_empty() {
            os.write_string(1, &self.parent_path)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(DatasetVersionMetricsGroupType::DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetVersionMetricsGroup {
        DatasetVersionMetricsGroup::new()
    }

    fn clear(&mut self) {
        self.parent_path.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(DatasetVersionMetricsGroupType::DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET);
        self.value.clear();
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetVersionMetricsGroup {
        static instance: DatasetVersionMetricsGroup = DatasetVersionMetricsGroup {
            parent_path: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::protobuf::MessageField::none(),
            metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DatasetVersionMetricsGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetVersionMetricsGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetVersionMetricsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersionMetricsGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DatasetVersionExportInfo contains information about all exports of a dataset version.
///
///  If the dataset version has not been exported in a format, then the DatasetVersionExport
///  field for that format is empty instead of having a "not exported" status.
// @@protoc_insertion_point(message:clarifai.api.DatasetVersionExportInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetVersionExportInfo {
    // message fields
    ///  clarifai_data_protobuf is a CLARIFAI_DATA_PROTOBUF export of the dataset version.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionExportInfo.clarifai_data_protobuf)
    pub clarifai_data_protobuf: ::protobuf::MessageField<DatasetVersionExport>,
    ///  clarifai_data_json is a CLARIFAI_DATA_JSON export of the dataset version.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionExportInfo.clarifai_data_json)
    pub clarifai_data_json: ::protobuf::MessageField<DatasetVersionExport>,
    ///  coco is a COCO export of the dataset version.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionExportInfo.coco)
    pub coco: ::protobuf::MessageField<DatasetVersionExport>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetVersionExportInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetVersionExportInfo {
    fn default() -> &'a DatasetVersionExportInfo {
        <DatasetVersionExportInfo as ::protobuf::Message>::default_instance()
    }
}

impl DatasetVersionExportInfo {
    pub fn new() -> DatasetVersionExportInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DatasetVersionExport>(
            "clarifai_data_protobuf",
            |m: &DatasetVersionExportInfo| { &m.clarifai_data_protobuf },
            |m: &mut DatasetVersionExportInfo| { &mut m.clarifai_data_protobuf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DatasetVersionExport>(
            "clarifai_data_json",
            |m: &DatasetVersionExportInfo| { &m.clarifai_data_json },
            |m: &mut DatasetVersionExportInfo| { &mut m.clarifai_data_json },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DatasetVersionExport>(
            "coco",
            |m: &DatasetVersionExportInfo| { &m.coco },
            |m: &mut DatasetVersionExportInfo| { &mut m.coco },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetVersionExportInfo>(
            "DatasetVersionExportInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetVersionExportInfo {
    const NAME: &'static str = "DatasetVersionExportInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clarifai_data_protobuf)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clarifai_data_json)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.coco)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clarifai_data_protobuf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clarifai_data_json.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.coco.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clarifai_data_protobuf.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.clarifai_data_json.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.coco.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetVersionExportInfo {
        DatasetVersionExportInfo::new()
    }

    fn clear(&mut self) {
        self.clarifai_data_protobuf.clear();
        self.clarifai_data_json.clear();
        self.coco.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetVersionExportInfo {
        static instance: DatasetVersionExportInfo = DatasetVersionExportInfo {
            clarifai_data_protobuf: ::protobuf::MessageField::none(),
            clarifai_data_json: ::protobuf::MessageField::none(),
            coco: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DatasetVersionExportInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetVersionExportInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetVersionExportInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersionExportInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DatasetVersionExport contains metadata for a single dataset version export.
// @@protoc_insertion_point(message:clarifai.api.DatasetVersionExport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetVersionExport {
    // message fields
    ///  format is the format of the dataset version export.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionExport.format)
    pub format: ::protobuf::EnumOrUnknown<DatasetVersionExportFormat>,
    ///  status is the current status of the dataset version export.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionExport.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  url is the URL from where the dataset version export can be downloaded.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionExport.url)
    pub url: ::std::string::String,
    ///  size is the size of the dataset version export in number of bytes.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionExport.size)
    pub size: u64,
    ///  whether to include embeddings in the export or not.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionExport.include_embeddings)
    pub include_embeddings: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetVersionExport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetVersionExport {
    fn default() -> &'a DatasetVersionExport {
        <DatasetVersionExport as ::protobuf::Message>::default_instance()
    }
}

impl DatasetVersionExport {
    pub fn new() -> DatasetVersionExport {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &DatasetVersionExport| { &m.format },
            |m: &mut DatasetVersionExport| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &DatasetVersionExport| { &m.status },
            |m: &mut DatasetVersionExport| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &DatasetVersionExport| { &m.url },
            |m: &mut DatasetVersionExport| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &DatasetVersionExport| { &m.size },
            |m: &mut DatasetVersionExport| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_embeddings",
            |m: &DatasetVersionExport| { &m.include_embeddings },
            |m: &mut DatasetVersionExport| { &mut m.include_embeddings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetVersionExport>(
            "DatasetVersionExport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetVersionExport {
    const NAME: &'static str = "DatasetVersionExport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.format = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                26 => {
                    self.url = is.read_string()?;
                },
                32 => {
                    self.size = is.read_uint64()?;
                },
                40 => {
                    self.include_embeddings = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.format != ::protobuf::EnumOrUnknown::new(DatasetVersionExportFormat::DATASET_VERSION_EXPORT_FORMAT_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.format.value());
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.size);
        }
        if self.include_embeddings != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.format != ::protobuf::EnumOrUnknown::new(DatasetVersionExportFormat::DATASET_VERSION_EXPORT_FORMAT_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.format))?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        if self.size != 0 {
            os.write_uint64(4, self.size)?;
        }
        if self.include_embeddings != false {
            os.write_bool(5, self.include_embeddings)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetVersionExport {
        DatasetVersionExport::new()
    }

    fn clear(&mut self) {
        self.format = ::protobuf::EnumOrUnknown::new(DatasetVersionExportFormat::DATASET_VERSION_EXPORT_FORMAT_NOT_SET);
        self.status.clear();
        self.url.clear();
        self.size = 0;
        self.include_embeddings = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetVersionExport {
        static instance: DatasetVersionExport = DatasetVersionExport {
            format: ::protobuf::EnumOrUnknown::from_i32(0),
            status: ::protobuf::MessageField::none(),
            url: ::std::string::String::new(),
            size: 0,
            include_embeddings: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DatasetVersionExport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetVersionExport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetVersionExport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersionExport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DatasetVersionProcessingInfo contains information about processing applied
///  to a dataset version.
// @@protoc_insertion_point(message:clarifai.api.DatasetVersionProcessingInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetVersionProcessingInfo {
    // message fields
    ///  If frame_interpolation_info is set, then these settings are used to
    ///  interpolate new frame annotation from other video annotations.
    ///
    ///  If frame_interpolation_info is set in the dataset default_processing_info,
    ///  then it can be disabled for a single dataset version by setting
    ///  processing_info but not setting processing_info.frame_interpolation_info.
    // @@protoc_insertion_point(field:clarifai.api.DatasetVersionProcessingInfo.frame_interpolation_info)
    pub frame_interpolation_info: ::protobuf::MessageField<FrameInterpolationInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetVersionProcessingInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetVersionProcessingInfo {
    fn default() -> &'a DatasetVersionProcessingInfo {
        <DatasetVersionProcessingInfo as ::protobuf::Message>::default_instance()
    }
}

impl DatasetVersionProcessingInfo {
    pub fn new() -> DatasetVersionProcessingInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FrameInterpolationInfo>(
            "frame_interpolation_info",
            |m: &DatasetVersionProcessingInfo| { &m.frame_interpolation_info },
            |m: &mut DatasetVersionProcessingInfo| { &mut m.frame_interpolation_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetVersionProcessingInfo>(
            "DatasetVersionProcessingInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetVersionProcessingInfo {
    const NAME: &'static str = "DatasetVersionProcessingInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.frame_interpolation_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_interpolation_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frame_interpolation_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetVersionProcessingInfo {
        DatasetVersionProcessingInfo::new()
    }

    fn clear(&mut self) {
        self.frame_interpolation_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetVersionProcessingInfo {
        static instance: DatasetVersionProcessingInfo = DatasetVersionProcessingInfo {
            frame_interpolation_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DatasetVersionProcessingInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetVersionProcessingInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetVersionProcessingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersionProcessingInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  FrameInterpolationInfo contains information about frame annotations
///  interpolated from other video annotations, such as image object-detection
///  regions generated from video object-tracking regions.
// @@protoc_insertion_point(message:clarifai.api.FrameInterpolationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FrameInterpolationInfo {
    // message fields
    ///  sample_ms is the sampling rate at which frame annotations are interpolated.
    ///  If sample_ms is zero, then the dataset default_processing_info value is used.
    ///  If the dataset default is zero or not set, then the input frame prediction
    ///  sampling rate is used.
    // @@protoc_insertion_point(field:clarifai.api.FrameInterpolationInfo.sample_ms)
    pub sample_ms: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.FrameInterpolationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FrameInterpolationInfo {
    fn default() -> &'a FrameInterpolationInfo {
        <FrameInterpolationInfo as ::protobuf::Message>::default_instance()
    }
}

impl FrameInterpolationInfo {
    pub fn new() -> FrameInterpolationInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_ms",
            |m: &FrameInterpolationInfo| { &m.sample_ms },
            |m: &mut FrameInterpolationInfo| { &mut m.sample_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FrameInterpolationInfo>(
            "FrameInterpolationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FrameInterpolationInfo {
    const NAME: &'static str = "FrameInterpolationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sample_ms = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sample_ms != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sample_ms);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sample_ms != 0 {
            os.write_uint32(1, self.sample_ms)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FrameInterpolationInfo {
        FrameInterpolationInfo::new()
    }

    fn clear(&mut self) {
        self.sample_ms = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FrameInterpolationInfo {
        static instance: FrameInterpolationInfo = FrameInterpolationInfo {
            sample_ms: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FrameInterpolationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FrameInterpolationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FrameInterpolationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameInterpolationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  WorkflowResultsSimilarity
// @@protoc_insertion_point(message:clarifai.api.WorkflowResultsSimilarity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowResultsSimilarity {
    // message fields
    ///  The input with the specific data compare against all pool results
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResultsSimilarity.probe_input)
    pub probe_input: ::protobuf::MessageField<Input>,
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResultsSimilarity.pool_results)
    pub pool_results: ::std::vec::Vec<Hit>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowResultsSimilarity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowResultsSimilarity {
    fn default() -> &'a WorkflowResultsSimilarity {
        <WorkflowResultsSimilarity as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowResultsSimilarity {
    pub fn new() -> WorkflowResultsSimilarity {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "probe_input",
            |m: &WorkflowResultsSimilarity| { &m.probe_input },
            |m: &mut WorkflowResultsSimilarity| { &mut m.probe_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pool_results",
            |m: &WorkflowResultsSimilarity| { &m.pool_results },
            |m: &mut WorkflowResultsSimilarity| { &mut m.pool_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowResultsSimilarity>(
            "WorkflowResultsSimilarity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowResultsSimilarity {
    const NAME: &'static str = "WorkflowResultsSimilarity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.probe_input)?;
                },
                18 => {
                    self.pool_results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.probe_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.pool_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.probe_input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.pool_results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowResultsSimilarity {
        WorkflowResultsSimilarity::new()
    }

    fn clear(&mut self) {
        self.probe_input.clear();
        self.pool_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowResultsSimilarity {
        static instance: WorkflowResultsSimilarity = WorkflowResultsSimilarity {
            probe_input: ::protobuf::MessageField::none(),
            pool_results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowResultsSimilarity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowResultsSimilarity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowResultsSimilarity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowResultsSimilarity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Key
// @@protoc_insertion_point(message:clarifai.api.Key)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Key {
    // message fields
    ///  The id of this key, it is used for authorization.
    // @@protoc_insertion_point(field:clarifai.api.Key.id)
    pub id: ::std::string::String,
    ///  The type of key, it can be api_key or personal_access_token, the default value is api_key
    // @@protoc_insertion_point(field:clarifai.api.Key.type)
    pub type_: ::std::string::String,
    ///  The description
    // @@protoc_insertion_point(field:clarifai.api.Key.description)
    pub description: ::std::string::String,
    ///  The low-level scopes this key has
    // @@protoc_insertion_point(field:clarifai.api.Key.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  The endpoint-level scopes this key has
    // @@protoc_insertion_point(field:clarifai.api.Key.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    ///  The apps that this key give you access to, it is empty if this key is personal_access_token
    ///  API key can only give you access to a single app.
    // @@protoc_insertion_point(field:clarifai.api.Key.apps)
    pub apps: ::std::vec::Vec<App>,
    ///  When the key was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.Key.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When does the key expires, the key won't expire if this is empty
    // @@protoc_insertion_point(field:clarifai.api.Key.expires_at)
    pub expires_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  list of idp ids at which key is currently authorized
    // @@protoc_insertion_point(field:clarifai.api.Key.authorized_idp_ids)
    pub authorized_idp_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Key.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Key| { &m.id },
            |m: &mut Key| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Key| { &m.type_ },
            |m: &mut Key| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Key| { &m.description },
            |m: &mut Key| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &Key| { &m.scopes },
            |m: &mut Key| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &Key| { &m.endpoints },
            |m: &mut Key| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &Key| { &m.apps },
            |m: &mut Key| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Key| { &m.created_at },
            |m: &mut Key| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "expires_at",
            |m: &Key| { &m.expires_at },
            |m: &mut Key| { &mut m.expires_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "authorized_idp_ids",
            |m: &Key| { &m.authorized_idp_ids },
            |m: &mut Key| { &mut m.authorized_idp_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key>(
            "Key",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Key {
    const NAME: &'static str = "Key";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                66 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    self.scopes.push(is.read_string()?);
                },
                58 => {
                    self.endpoints.push(is.read_string()?);
                },
                34 => {
                    self.apps.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.expires_at)?;
                },
                74 => {
                    self.authorized_idp_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.type_);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expires_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.authorized_idp_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.type_.is_empty() {
            os.write_string(8, &self.type_)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.scopes {
            os.write_string(3, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(7, &v)?;
        };
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.expires_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.authorized_idp_ids {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Key {
        Key::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.type_.clear();
        self.description.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.apps.clear();
        self.created_at.clear();
        self.expires_at.clear();
        self.authorized_idp_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Key {
        static instance: Key = Key {
            id: ::std::string::String::new(),
            type_: ::std::string::String::new(),
            description: ::std::string::String::new(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            apps: ::std::vec::Vec::new(),
            created_at: ::protobuf::MessageField::none(),
            expires_at: ::protobuf::MessageField::none(),
            authorized_idp_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Key {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Key").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.Model)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Model {
    // message fields
    ///  The model's ID. Must be unique within a particular app and URL-friendly.
    // @@protoc_insertion_point(field:clarifai.api.Model.id)
    pub id: ::std::string::String,
    ///  DEPRECATED: Please use the model id to name the model.
    // @@protoc_insertion_point(field:clarifai.api.Model.name)
    pub name: ::std::string::String,
    ///  When the model was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///   the following from the API:
    ///   "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.Model.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When was the most recent model version created at
    // @@protoc_insertion_point(field:clarifai.api.Model.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The app the model belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Model.app_id)
    pub app_id: ::std::string::String,
    ///  Info about the model's output and configuration.
    ///  DEPRECATED: Will be moved to model version
    // @@protoc_insertion_point(field:clarifai.api.Model.output_info)
    pub output_info: ::protobuf::MessageField<OutputInfo>,
    ///  A particular version of the model, e.g., to specify the version when creating a workflow or
    ///  when listing Models to include the latest ModelVersion of the model in the response.
    // @@protoc_insertion_point(field:clarifai.api.Model.model_version)
    pub model_version: ::protobuf::MessageField<ModelVersion>,
    ///  DEPRECATED: Please use the model id to name the model.
    // @@protoc_insertion_point(field:clarifai.api.Model.display_name)
    pub display_name: ::std::string::String,
    ///  The user id that the model belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Model.user_id)
    pub user_id: ::std::string::String,
    ///  The default evaluation info. Can be overwritten by eval request.
    // @@protoc_insertion_point(field:clarifai.api.Model.default_eval_info)
    pub default_eval_info: ::protobuf::MessageField<EvalInfo>,
    ///  The ModelType.Id that is used for this model. This is used for all versions and you cannot
    ///  change model_type_id between versions of the same model.
    // @@protoc_insertion_point(field:clarifai.api.Model.model_type_id)
    pub model_type_id: ::std::string::String,
    ///  The task the model was trained to do
    // @@protoc_insertion_point(field:clarifai.api.Model.task)
    pub task: ::std::string::String,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.Model.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  Short description about this model
    // @@protoc_insertion_point(field:clarifai.api.Model.description)
    pub description: ::std::string::String,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.Model.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // @@protoc_insertion_point(field:clarifai.api.Model.presets)
    pub presets: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  Notes for the model
    ///  This field should be used for in-depth notes and supports up to 64Kbs.
    // @@protoc_insertion_point(field:clarifai.api.Model.notes)
    pub notes: ::std::string::String,
    ///  Tags from toolkits category
    // @@protoc_insertion_point(field:clarifai.api.Model.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    ///  Tags from use_cases category
    // @@protoc_insertion_point(field:clarifai.api.Model.use_cases)
    pub use_cases: ::std::vec::Vec<::std::string::String>,
    ///  Tags from languages category.
    // @@protoc_insertion_point(field:clarifai.api.Model.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    ///  Tags from languages category with names, only used in responses.
    // @@protoc_insertion_point(field:clarifai.api.Model.languages_full)
    pub languages_full: ::std::vec::Vec<FullTag>,
    // @@protoc_insertion_point(field:clarifai.api.Model.check_consents)
    pub check_consents: ::std::vec::Vec<::std::string::String>,
    ///  Is starred by the requesting user (only showed on get/list requests)
    ///  Please use PostModelStars/DeleteModelStars endpoints to star/unstar a model
    // @@protoc_insertion_point(field:clarifai.api.Model.is_starred)
    pub is_starred: bool,
    ///  How many users have starred the model (only showed on get/list requests)
    ///  Computed value, not editable
    // @@protoc_insertion_point(field:clarifai.api.Model.star_count)
    pub star_count: i32,
    ///  Whether it's recommended that this model is used within a workflow
    // @@protoc_insertion_point(field:clarifai.api.Model.workflow_recommended)
    pub workflow_recommended: ::protobuf::MessageField<::protobuf::well_known_types::wrappers::BoolValue>,
    ///  bookmark info. When set, this model is a bookmarked model of this app.
    ///  Info in this field will allow you to find/access original model.
    // @@protoc_insertion_point(field:clarifai.api.Model.bookmark_origin)
    pub bookmark_origin: ::protobuf::MessageField<BookmarkOrigin>,
    ///  Representative image for this model
    // @@protoc_insertion_point(field:clarifai.api.Model.image)
    pub image: ::protobuf::MessageField<Image>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Model.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Model {
    fn default() -> &'a Model {
        <Model as ::protobuf::Message>::default_instance()
    }
}

impl Model {
    pub fn new() -> Model {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Model| { &m.id },
            |m: &mut Model| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Model| { &m.name },
            |m: &mut Model| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Model| { &m.created_at },
            |m: &mut Model| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Model| { &m.modified_at },
            |m: &mut Model| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &Model| { &m.app_id },
            |m: &mut Model| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OutputInfo>(
            "output_info",
            |m: &Model| { &m.output_info },
            |m: &mut Model| { &mut m.output_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ModelVersion>(
            "model_version",
            |m: &Model| { &m.model_version },
            |m: &mut Model| { &mut m.model_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "display_name",
            |m: &Model| { &m.display_name },
            |m: &mut Model| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Model| { &m.user_id },
            |m: &mut Model| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EvalInfo>(
            "default_eval_info",
            |m: &Model| { &m.default_eval_info },
            |m: &mut Model| { &mut m.default_eval_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &Model| { &m.model_type_id },
            |m: &mut Model| { &mut m.model_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task",
            |m: &Model| { &m.task },
            |m: &mut Model| { &mut m.task },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &Model| { &m.visibility },
            |m: &mut Model| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Model| { &m.description },
            |m: &mut Model| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &Model| { &m.metadata },
            |m: &mut Model| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "presets",
            |m: &Model| { &m.presets },
            |m: &mut Model| { &mut m.presets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "notes",
            |m: &Model| { &m.notes },
            |m: &mut Model| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &Model| { &m.toolkits },
            |m: &mut Model| { &mut m.toolkits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "use_cases",
            |m: &Model| { &m.use_cases },
            |m: &mut Model| { &mut m.use_cases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &Model| { &m.languages },
            |m: &mut Model| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages_full",
            |m: &Model| { &m.languages_full },
            |m: &mut Model| { &mut m.languages_full },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "check_consents",
            |m: &Model| { &m.check_consents },
            |m: &mut Model| { &mut m.check_consents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_starred",
            |m: &Model| { &m.is_starred },
            |m: &mut Model| { &mut m.is_starred },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "star_count",
            |m: &Model| { &m.star_count },
            |m: &mut Model| { &mut m.star_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::wrappers::BoolValue>(
            "workflow_recommended",
            |m: &Model| { &m.workflow_recommended },
            |m: &mut Model| { &mut m.workflow_recommended },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BookmarkOrigin>(
            "bookmark_origin",
            |m: &Model| { &m.bookmark_origin },
            |m: &mut Model| { &mut m.bookmark_origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &Model| { &m.image },
            |m: &mut Model| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Model>(
            "Model",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Model {
    const NAME: &'static str = "Model";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                34 => {
                    self.app_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_info)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_version)?;
                },
                58 => {
                    self.display_name = is.read_string()?;
                },
                74 => {
                    self.user_id = is.read_string()?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_eval_info)?;
                },
                114 => {
                    self.model_type_id = is.read_string()?;
                },
                210 => {
                    self.task = is.read_string()?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                130 => {
                    self.description = is.read_string()?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                218 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.presets)?;
                },
                146 => {
                    self.notes = is.read_string()?;
                },
                162 => {
                    self.toolkits.push(is.read_string()?);
                },
                170 => {
                    self.use_cases.push(is.read_string()?);
                },
                202 => {
                    self.languages.push(is.read_string()?);
                },
                250 => {
                    self.languages_full.push(is.read_message()?);
                },
                258 => {
                    self.check_consents.push(is.read_string()?);
                },
                176 => {
                    self.is_starred = is.read_bool()?;
                },
                184 => {
                    self.star_count = is.read_int32()?;
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_recommended)?;
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bookmark_origin)?;
                },
                274 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_id);
        }
        if let Some(v) = self.output_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.display_name);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.user_id);
        }
        if let Some(v) = self.default_eval_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.model_type_id);
        }
        if !self.task.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.task);
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.description);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.presets.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.notes);
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.use_cases {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(25, &value);
        };
        for value in &self.languages_full {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.check_consents {
            my_size += ::protobuf::rt::string_size(32, &value);
        };
        if self.is_starred != false {
            my_size += 2 + 1;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::int32_size(23, self.star_count);
        }
        if let Some(v) = self.workflow_recommended.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bookmark_origin.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(4, &self.app_id)?;
        }
        if let Some(v) = self.output_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.model_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(7, &self.display_name)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(9, &self.user_id)?;
        }
        if let Some(v) = self.default_eval_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(14, &self.model_type_id)?;
        }
        if !self.task.is_empty() {
            os.write_string(26, &self.task)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if !self.description.is_empty() {
            os.write_string(16, &self.description)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.presets.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if !self.notes.is_empty() {
            os.write_string(18, &self.notes)?;
        }
        for v in &self.toolkits {
            os.write_string(20, &v)?;
        };
        for v in &self.use_cases {
            os.write_string(21, &v)?;
        };
        for v in &self.languages {
            os.write_string(25, &v)?;
        };
        for v in &self.languages_full {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        };
        for v in &self.check_consents {
            os.write_string(32, &v)?;
        };
        if self.is_starred != false {
            os.write_bool(22, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(23, self.star_count)?;
        }
        if let Some(v) = self.workflow_recommended.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.bookmark_origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Model {
        Model::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.app_id.clear();
        self.output_info.clear();
        self.model_version.clear();
        self.display_name.clear();
        self.user_id.clear();
        self.default_eval_info.clear();
        self.model_type_id.clear();
        self.task.clear();
        self.visibility.clear();
        self.description.clear();
        self.metadata.clear();
        self.presets.clear();
        self.notes.clear();
        self.toolkits.clear();
        self.use_cases.clear();
        self.languages.clear();
        self.languages_full.clear();
        self.check_consents.clear();
        self.is_starred = false;
        self.star_count = 0;
        self.workflow_recommended.clear();
        self.bookmark_origin.clear();
        self.image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Model {
        static instance: Model = Model {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            output_info: ::protobuf::MessageField::none(),
            model_version: ::protobuf::MessageField::none(),
            display_name: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            default_eval_info: ::protobuf::MessageField::none(),
            model_type_id: ::std::string::String::new(),
            task: ::std::string::String::new(),
            visibility: ::protobuf::MessageField::none(),
            description: ::std::string::String::new(),
            metadata: ::protobuf::MessageField::none(),
            presets: ::protobuf::MessageField::none(),
            notes: ::std::string::String::new(),
            toolkits: ::std::vec::Vec::new(),
            use_cases: ::std::vec::Vec::new(),
            languages: ::std::vec::Vec::new(),
            languages_full: ::std::vec::Vec::new(),
            check_consents: ::std::vec::Vec::new(),
            is_starred: false,
            star_count: 0,
            workflow_recommended: ::protobuf::MessageField::none(),
            bookmark_origin: ::protobuf::MessageField::none(),
            image: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Model {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Model").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Model {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Model {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A link to a html/markdown/text file that stores reference material tied to a model.
// @@protoc_insertion_point(message:clarifai.api.ModelReference)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelReference {
    // message fields
    ///  Id of the reference
    // @@protoc_insertion_point(field:clarifai.api.ModelReference.id)
    pub id: ::std::string::String,
    ///  The id of the model this Model reference is tied to.
    // @@protoc_insertion_point(field:clarifai.api.ModelReference.model_id)
    pub model_id: ::std::string::String,
    ///  address of resource
    // @@protoc_insertion_point(field:clarifai.api.ModelReference.url)
    pub url: ::std::string::String,
    ///  name of link
    // @@protoc_insertion_point(field:clarifai.api.ModelReference.name)
    pub name: ::std::string::String,
    ///  To handle arbitrary json metadata:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.ModelReference.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelReference {
    fn default() -> &'a ModelReference {
        <ModelReference as ::protobuf::Message>::default_instance()
    }
}

impl ModelReference {
    pub fn new() -> ModelReference {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ModelReference| { &m.id },
            |m: &mut ModelReference| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ModelReference| { &m.model_id },
            |m: &mut ModelReference| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &ModelReference| { &m.url },
            |m: &mut ModelReference| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ModelReference| { &m.name },
            |m: &mut ModelReference| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &ModelReference| { &m.metadata },
            |m: &mut ModelReference| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelReference>(
            "ModelReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelReference {
    const NAME: &'static str = "ModelReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.url = is.read_string()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelReference {
        ModelReference::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.model_id.clear();
        self.url.clear();
        self.name.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelReference {
        static instance: ModelReference = ModelReference {
            id: ::std::string::String::new(),
            model_id: ::std::string::String::new(),
            url: ::std::string::String::new(),
            name: ::std::string::String::new(),
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersionInputExample
// @@protoc_insertion_point(message:clarifai.api.ModelVersionInputExample)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelVersionInputExample {
    // message fields
    ///  user unique id
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionInputExample.id)
    pub id: ::std::string::String,
    ///  external id of model
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionInputExample.model_id)
    pub model_id: ::std::string::String,
    ///  external id of model version
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionInputExample.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  data to store as example input for model
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionInputExample.data)
    pub data: ::protobuf::MessageField<Data>,
    ///  name of link for display
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionInputExample.name)
    pub name: ::std::string::String,
    ///  description of link contents
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionInputExample.description)
    pub description: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersionInputExample.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersionInputExample {
    fn default() -> &'a ModelVersionInputExample {
        <ModelVersionInputExample as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionInputExample {
    pub fn new() -> ModelVersionInputExample {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ModelVersionInputExample| { &m.id },
            |m: &mut ModelVersionInputExample| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ModelVersionInputExample| { &m.model_id },
            |m: &mut ModelVersionInputExample| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &ModelVersionInputExample| { &m.model_version_id },
            |m: &mut ModelVersionInputExample| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &ModelVersionInputExample| { &m.data },
            |m: &mut ModelVersionInputExample| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ModelVersionInputExample| { &m.name },
            |m: &mut ModelVersionInputExample| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ModelVersionInputExample| { &m.description },
            |m: &mut ModelVersionInputExample| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersionInputExample>(
            "ModelVersionInputExample",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersionInputExample {
    const NAME: &'static str = "ModelVersionInputExample";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                42 => {
                    self.name = is.read_string()?;
                },
                50 => {
                    self.description = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersionInputExample {
        ModelVersionInputExample::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.data.clear();
        self.name.clear();
        self.description.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersionInputExample {
        static instance: ModelVersionInputExample = ModelVersionInputExample {
            id: ::std::string::String::new(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersionInputExample {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersionInputExample").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersionInputExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionInputExample {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  OutputInfo defines some of the settings for each model version that PatchModels can effect. These
///  parameters control some of the training or inference operations that this model can do.
///  As the number of parameters continued to grow when we launched more ModelTypes we decided to move
///  to using the OutputInfo.params field which is a Struct (or JSON object if you're using
///  our JSON REST APIs). This allows each ModelType to define the set of fields, their default values
///  and description of each field so that we can display those in Portal and make the creation of
///  Model's very extensible. The OutputConfig object will eventually go away in favor of
///  infer_params struct.
// @@protoc_insertion_point(message:clarifai.api.OutputInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OutputInfo {
    // message fields
    ///  List of concepts or other output related data for the model.
    // @@protoc_insertion_point(field:clarifai.api.OutputInfo.data)
    pub data: ::protobuf::MessageField<Data>,
    ///  Model configuration...going away in favor of infer_params and train_params over time.
    ///  TO BE DEPRECATED
    // @@protoc_insertion_point(field:clarifai.api.OutputInfo.output_config)
    pub output_config: ::protobuf::MessageField<OutputConfig>,
    ///  For returning where to look for the Output info if not returning it.
    // @@protoc_insertion_point(field:clarifai.api.OutputInfo.message)
    pub message: ::std::string::String,
    ///  Map from the api.Data field names to the underlying model graph's outputs. When using a
    ///  PretrainedModelConfig the values in this map need to match the Triton config.pbtxt output names.
    // @@protoc_insertion_point(field:clarifai.api.OutputInfo.fields_map)
    pub fields_map: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  For predicting with the various ModelType's we accept a Struct (JSON object) worth of args
    ///  that the ModelTypeField defines. During inference, the settings contained within are sent
    ///  to the model predictor to alter predictions from this Model.
    // @@protoc_insertion_point(field:clarifai.api.OutputInfo.params)
    pub params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // @@protoc_insertion_point(field:clarifai.api.OutputInfo.params_specs)
    pub params_specs: ::std::vec::Vec<ModelTypeField>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.OutputInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OutputInfo {
    fn default() -> &'a OutputInfo {
        <OutputInfo as ::protobuf::Message>::default_instance()
    }
}

impl OutputInfo {
    pub fn new() -> OutputInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &OutputInfo| { &m.data },
            |m: &mut OutputInfo| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OutputConfig>(
            "output_config",
            |m: &OutputInfo| { &m.output_config },
            |m: &mut OutputInfo| { &mut m.output_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &OutputInfo| { &m.message },
            |m: &mut OutputInfo| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "fields_map",
            |m: &OutputInfo| { &m.fields_map },
            |m: &mut OutputInfo| { &mut m.fields_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "params",
            |m: &OutputInfo| { &m.params },
            |m: &mut OutputInfo| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params_specs",
            |m: &OutputInfo| { &m.params_specs },
            |m: &mut OutputInfo| { &mut m.params_specs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OutputInfo>(
            "OutputInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OutputInfo {
    const NAME: &'static str = "OutputInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_config)?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields_map)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                66 => {
                    self.params_specs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if let Some(v) = self.fields_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.params_specs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.output_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if let Some(v) = self.fields_map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.params_specs {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OutputInfo {
        OutputInfo::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.output_config.clear();
        self.message.clear();
        self.fields_map.clear();
        self.params.clear();
        self.params_specs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OutputInfo {
        static instance: OutputInfo = OutputInfo {
            data: ::protobuf::MessageField::none(),
            output_config: ::protobuf::MessageField::none(),
            message: ::std::string::String::new(),
            fields_map: ::protobuf::MessageField::none(),
            params: ::protobuf::MessageField::none(),
            params_specs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OutputInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OutputInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OutputInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  InputInfo
// @@protoc_insertion_point(message:clarifai.api.InputInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputInfo {
    // message fields
    ///  Map from the api.Data field names to the underlying model graph's inputs. When using a
    ///  PretrainedModelConfig the values in this map need to match the Triton config.pbtxt input names.
    // @@protoc_insertion_point(field:clarifai.api.InputInfo.fields_map)
    pub fields_map: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  To control the inputs to the given model we allow a list of parameters
    ///  defined for each ModelType as a Struct (JSON object) here. During training or inference, the
    ///  settings contained within are sent to the training processor to alter the training process.
    // @@protoc_insertion_point(field:clarifai.api.InputInfo.params)
    pub params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  For base model to get embeddings from for transfer learned models.
    // @@protoc_insertion_point(field:clarifai.api.InputInfo.base_embed_model)
    pub base_embed_model: ::protobuf::MessageField<Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputInfo {
    fn default() -> &'a InputInfo {
        <InputInfo as ::protobuf::Message>::default_instance()
    }
}

impl InputInfo {
    pub fn new() -> InputInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "fields_map",
            |m: &InputInfo| { &m.fields_map },
            |m: &mut InputInfo| { &mut m.fields_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "params",
            |m: &InputInfo| { &m.params },
            |m: &mut InputInfo| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Model>(
            "base_embed_model",
            |m: &InputInfo| { &m.base_embed_model },
            |m: &mut InputInfo| { &mut m.base_embed_model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputInfo>(
            "InputInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputInfo {
    const NAME: &'static str = "InputInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields_map)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_embed_model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fields_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.base_embed_model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fields_map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.base_embed_model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputInfo {
        InputInfo::new()
    }

    fn clear(&mut self) {
        self.fields_map.clear();
        self.params.clear();
        self.base_embed_model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputInfo {
        static instance: InputInfo = InputInfo {
            fields_map: ::protobuf::MessageField::none(),
            params: ::protobuf::MessageField::none(),
            base_embed_model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.TrainInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainInfo {
    // message fields
    ///  To control the training process when PostModelVersions is used we allow a list of parameters
    ///  defined for each ModelType as a Struct (JSON object) here. During training, the settings
    ///  contained within are sent to the training processor to alter the training process.
    // @@protoc_insertion_point(field:clarifai.api.TrainInfo.params)
    pub params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  The dataset and dataset version this model version was or will be trained on
    // @@protoc_insertion_point(field:clarifai.api.TrainInfo.dataset)
    pub dataset: ::protobuf::MessageField<Dataset>,
    ///  The model to resume training from.
    // @@protoc_insertion_point(field:clarifai.api.TrainInfo.resume_from_model)
    pub resume_from_model: ::protobuf::MessageField<Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TrainInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainInfo {
    fn default() -> &'a TrainInfo {
        <TrainInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainInfo {
    pub fn new() -> TrainInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "params",
            |m: &TrainInfo| { &m.params },
            |m: &mut TrainInfo| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Dataset>(
            "dataset",
            |m: &TrainInfo| { &m.dataset },
            |m: &mut TrainInfo| { &mut m.dataset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Model>(
            "resume_from_model",
            |m: &TrainInfo| { &m.resume_from_model },
            |m: &mut TrainInfo| { &mut m.resume_from_model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainInfo>(
            "TrainInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainInfo {
    const NAME: &'static str = "TrainInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resume_from_model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.resume_from_model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.resume_from_model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainInfo {
        TrainInfo::new()
    }

    fn clear(&mut self) {
        self.params.clear();
        self.dataset.clear();
        self.resume_from_model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainInfo {
        static instance: TrainInfo = TrainInfo {
            params: ::protobuf::MessageField::none(),
            dataset: ::protobuf::MessageField::none(),
            resume_from_model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.EvalInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvalInfo {
    // message fields
    ///  To control the evaluation process.
    ///  Allow a list of parameters.
    // @@protoc_insertion_point(field:clarifai.api.EvalInfo.params)
    pub params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.EvalInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvalInfo {
    fn default() -> &'a EvalInfo {
        <EvalInfo as ::protobuf::Message>::default_instance()
    }
}

impl EvalInfo {
    pub fn new() -> EvalInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "params",
            |m: &EvalInfo| { &m.params },
            |m: &mut EvalInfo| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvalInfo>(
            "EvalInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvalInfo {
    const NAME: &'static str = "EvalInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvalInfo {
        EvalInfo::new()
    }

    fn clear(&mut self) {
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvalInfo {
        static instance: EvalInfo = EvalInfo {
            params: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvalInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvalInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvalInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvalInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ImportInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ImportInfo {
    // message fields
    ///  Used to configure model imports from third-party toolkits.
    // @@protoc_insertion_point(field:clarifai.api.ImportInfo.params)
    pub params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ImportInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ImportInfo {
    fn default() -> &'a ImportInfo {
        <ImportInfo as ::protobuf::Message>::default_instance()
    }
}

impl ImportInfo {
    pub fn new() -> ImportInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "params",
            |m: &ImportInfo| { &m.params },
            |m: &mut ImportInfo| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImportInfo>(
            "ImportInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ImportInfo {
    const NAME: &'static str = "ImportInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ImportInfo {
        ImportInfo::new()
    }

    fn clear(&mut self) {
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ImportInfo {
        static instance: ImportInfo = ImportInfo {
            params: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ImportInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ImportInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ImportInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  OutputConfig is a collection of parameters controlling either inference or training settings for
///  the given Model. This message will be deprecated over time in favor or infer_params and
///  train_params in OutputInfo which are cleaner and more extensible for many ModelTypes.
// @@protoc_insertion_point(message:clarifai.api.OutputConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OutputConfig {
    // message fields
    ///  For custom concept model training: whether the concept predictions must sum to 1.
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.concepts_mutually_exclusive)
    pub concepts_mutually_exclusive: bool,
    ///  DEPRECATED: For custom models, this is the base model to use for image embeddings.
    ///  Default is general model.
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.existing_model_id)
    pub existing_model_id: ::std::string::String,
    ///  For concept model predictions: Overrides the default_language for the app in a predict call.
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.language)
    pub language: ::std::string::String,
    ///  DEPRECATED: Hyper-parameters for custom training.
    ///  Use new hyper_params field instead.
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.hyper_parameters)
    pub hyper_parameters: ::std::string::String,
    ///  For concept model predictions:  Maximum number of concepts in result. Defaults to 0 which under
    ///  the hood will return default of 20. We do a server side default in order to control this
    ///  feature in the future.
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.max_concepts)
    pub max_concepts: u32,
    ///  For concept model predictions: Minimum value of concept's probability score in result.
    ///  Defaults to 0.0 which means we won't do any thresholding as all probabilities will
    ///  likely be > 0.0.
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.min_value)
    pub min_value: f32,
    ///  For concept model predictions: Select concepts in result by name or by id
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.select_concepts)
    pub select_concepts: ::std::vec::Vec<Concept>,
    ///  For custom concept model training: Training timeout of the model (in seconds)
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.training_timeout)
    pub training_timeout: u32,
    ///  For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.sample_ms)
    pub sample_ms: u32,
    ///  For custom model training: Hyperparameters for custom training
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.hyper_params)
    pub hyper_params: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  For custom model training: this is the base model version to use for image embeddings.
    ///  This has to be one of the embed models in the app workflow.
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.embed_model_version_id)
    pub embed_model_version_id: ::std::string::String,
    ///  For custom model training: Use this flag to fail on missing positive examples
    ///  By default we fill in the missing with random examples
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.fail_on_missing_positive_examples)
    pub fail_on_missing_positive_examples: bool,
    ///  For custom model training: This is any additional metadata as a JSON object that we want
    ///  want to persist in the model's output config. This is a useful quick way to set fields for
    ///  introducing fields for new model types so we don't have to add a new proto field and DB field
    ///  each time. Please refer to the documentation or model implementation internally for more
    ///  details on what fields are supported for which models.
    ///  TODO(zeiler): remove this field after Portal is updated.
    // @@protoc_insertion_point(field:clarifai.api.OutputConfig.model_metadata)
    pub model_metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.OutputConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OutputConfig {
    fn default() -> &'a OutputConfig {
        <OutputConfig as ::protobuf::Message>::default_instance()
    }
}

impl OutputConfig {
    pub fn new() -> OutputConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concepts_mutually_exclusive",
            |m: &OutputConfig| { &m.concepts_mutually_exclusive },
            |m: &mut OutputConfig| { &mut m.concepts_mutually_exclusive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "existing_model_id",
            |m: &OutputConfig| { &m.existing_model_id },
            |m: &mut OutputConfig| { &mut m.existing_model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &OutputConfig| { &m.language },
            |m: &mut OutputConfig| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hyper_parameters",
            |m: &OutputConfig| { &m.hyper_parameters },
            |m: &mut OutputConfig| { &mut m.hyper_parameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_concepts",
            |m: &OutputConfig| { &m.max_concepts },
            |m: &mut OutputConfig| { &mut m.max_concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_value",
            |m: &OutputConfig| { &m.min_value },
            |m: &mut OutputConfig| { &mut m.min_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "select_concepts",
            |m: &OutputConfig| { &m.select_concepts },
            |m: &mut OutputConfig| { &mut m.select_concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "training_timeout",
            |m: &OutputConfig| { &m.training_timeout },
            |m: &mut OutputConfig| { &mut m.training_timeout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_ms",
            |m: &OutputConfig| { &m.sample_ms },
            |m: &mut OutputConfig| { &mut m.sample_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "hyper_params",
            |m: &OutputConfig| { &m.hyper_params },
            |m: &mut OutputConfig| { &mut m.hyper_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "embed_model_version_id",
            |m: &OutputConfig| { &m.embed_model_version_id },
            |m: &mut OutputConfig| { &mut m.embed_model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fail_on_missing_positive_examples",
            |m: &OutputConfig| { &m.fail_on_missing_positive_examples },
            |m: &mut OutputConfig| { &mut m.fail_on_missing_positive_examples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "model_metadata",
            |m: &OutputConfig| { &m.model_metadata },
            |m: &mut OutputConfig| { &mut m.model_metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OutputConfig>(
            "OutputConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OutputConfig {
    const NAME: &'static str = "OutputConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.concepts_mutually_exclusive = is.read_bool()?;
                },
                26 => {
                    self.existing_model_id = is.read_string()?;
                },
                34 => {
                    self.language = is.read_string()?;
                },
                42 => {
                    self.hyper_parameters = is.read_string()?;
                },
                48 => {
                    self.max_concepts = is.read_uint32()?;
                },
                61 => {
                    self.min_value = is.read_float()?;
                },
                66 => {
                    self.select_concepts.push(is.read_message()?);
                },
                72 => {
                    self.training_timeout = is.read_uint32()?;
                },
                80 => {
                    self.sample_ms = is.read_uint32()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hyper_params)?;
                },
                114 => {
                    self.embed_model_version_id = is.read_string()?;
                },
                120 => {
                    self.fail_on_missing_positive_examples = is.read_bool()?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.concepts_mutually_exclusive != false {
            my_size += 1 + 1;
        }
        if !self.existing_model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.existing_model_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language);
        }
        if !self.hyper_parameters.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.hyper_parameters);
        }
        if self.max_concepts != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.max_concepts);
        }
        if self.min_value != 0. {
            my_size += 1 + 4;
        }
        for value in &self.select_concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.training_timeout != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.training_timeout);
        }
        if self.sample_ms != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.sample_ms);
        }
        if let Some(v) = self.hyper_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.embed_model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.embed_model_version_id);
        }
        if self.fail_on_missing_positive_examples != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.model_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.concepts_mutually_exclusive != false {
            os.write_bool(1, self.concepts_mutually_exclusive)?;
        }
        if !self.existing_model_id.is_empty() {
            os.write_string(3, &self.existing_model_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(4, &self.language)?;
        }
        if !self.hyper_parameters.is_empty() {
            os.write_string(5, &self.hyper_parameters)?;
        }
        if self.max_concepts != 0 {
            os.write_uint32(6, self.max_concepts)?;
        }
        if self.min_value != 0. {
            os.write_float(7, self.min_value)?;
        }
        for v in &self.select_concepts {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if self.training_timeout != 0 {
            os.write_uint32(9, self.training_timeout)?;
        }
        if self.sample_ms != 0 {
            os.write_uint32(10, self.sample_ms)?;
        }
        if let Some(v) = self.hyper_params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if !self.embed_model_version_id.is_empty() {
            os.write_string(14, &self.embed_model_version_id)?;
        }
        if self.fail_on_missing_positive_examples != false {
            os.write_bool(15, self.fail_on_missing_positive_examples)?;
        }
        if let Some(v) = self.model_metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OutputConfig {
        OutputConfig::new()
    }

    fn clear(&mut self) {
        self.concepts_mutually_exclusive = false;
        self.existing_model_id.clear();
        self.language.clear();
        self.hyper_parameters.clear();
        self.max_concepts = 0;
        self.min_value = 0.;
        self.select_concepts.clear();
        self.training_timeout = 0;
        self.sample_ms = 0;
        self.hyper_params.clear();
        self.embed_model_version_id.clear();
        self.fail_on_missing_positive_examples = false;
        self.model_metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OutputConfig {
        static instance: OutputConfig = OutputConfig {
            concepts_mutually_exclusive: false,
            existing_model_id: ::std::string::String::new(),
            language: ::std::string::String::new(),
            hyper_parameters: ::std::string::String::new(),
            max_concepts: 0,
            min_value: 0.,
            select_concepts: ::std::vec::Vec::new(),
            training_timeout: 0,
            sample_ms: 0,
            hyper_params: ::protobuf::MessageField::none(),
            embed_model_version_id: ::std::string::String::new(),
            fail_on_missing_positive_examples: false,
            model_metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OutputConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OutputConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelType is a definition of a set of models that generally have the same input and output fields.
///  This is used to understand more about the possible models in our platform.
// @@protoc_insertion_point(message:clarifai.api.ModelType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelType {
    // message fields
    ///  A unique identifier for this model type.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.id)
    pub id: ::std::string::String,
    ///  A display title for this model.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.title)
    pub title: ::std::string::String,
    ///  Description of this model type.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.description)
    pub description: ::std::string::String,
    ///  The list of input fields that this model expects as inputs.
    ///  Used to validate that request input data has the expected fields.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.input_fields)
    pub input_fields: ::std::vec::Vec<::std::string::String>,
    ///  The list of output fields that this model accepts.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.output_fields)
    pub output_fields: ::std::vec::Vec<::std::string::String>,
    ///  Is this model trainable in our platform.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.trainable)
    pub trainable: bool,
    ///  Is this model creatable. We have some pre-trained model types that users cannot create yet in
    ///  model mode.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.creatable)
    pub creatable: bool,
    ///  Is this model type only for internal users at this time.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.internal_only)
    pub internal_only: bool,
    ///  The remaining fields are definitions of the configurable fields that exist.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.model_type_fields)
    pub model_type_fields: ::std::vec::Vec<ModelTypeField>,
    ///  For sequence models we need to know when processing that they require temporal time frames
    ///  in sequential order. This will be true for model types like trackers as an example.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.requires_sequential_frames)
    pub requires_sequential_frames: bool,
    ///  Expected input layers of an uploaded model.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.expected_input_layers)
    pub expected_input_layers: ::std::vec::Vec<ModelLayerInfo>,
    ///  Expected output layers of an uploaded model
    // @@protoc_insertion_point(field:clarifai.api.ModelType.expected_output_layers)
    pub expected_output_layers: ::std::vec::Vec<ModelLayerInfo>,
    ///  What type of evaluation is supported for this model type.
    // @@protoc_insertion_point(field:clarifai.api.ModelType.evaluation_type)
    pub evaluation_type: ::protobuf::EnumOrUnknown<EvaluationType>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelType {
    fn default() -> &'a ModelType {
        <ModelType as ::protobuf::Message>::default_instance()
    }
}

impl ModelType {
    pub fn new() -> ModelType {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ModelType| { &m.id },
            |m: &mut ModelType| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ModelType| { &m.title },
            |m: &mut ModelType| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ModelType| { &m.description },
            |m: &mut ModelType| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_fields",
            |m: &ModelType| { &m.input_fields },
            |m: &mut ModelType| { &mut m.input_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_fields",
            |m: &ModelType| { &m.output_fields },
            |m: &mut ModelType| { &mut m.output_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trainable",
            |m: &ModelType| { &m.trainable },
            |m: &mut ModelType| { &mut m.trainable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creatable",
            |m: &ModelType| { &m.creatable },
            |m: &mut ModelType| { &mut m.creatable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "internal_only",
            |m: &ModelType| { &m.internal_only },
            |m: &mut ModelType| { &mut m.internal_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_type_fields",
            |m: &ModelType| { &m.model_type_fields },
            |m: &mut ModelType| { &mut m.model_type_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_sequential_frames",
            |m: &ModelType| { &m.requires_sequential_frames },
            |m: &mut ModelType| { &mut m.requires_sequential_frames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "expected_input_layers",
            |m: &ModelType| { &m.expected_input_layers },
            |m: &mut ModelType| { &mut m.expected_input_layers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "expected_output_layers",
            |m: &ModelType| { &m.expected_output_layers },
            |m: &mut ModelType| { &mut m.expected_output_layers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_type",
            |m: &ModelType| { &m.evaluation_type },
            |m: &mut ModelType| { &mut m.evaluation_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelType>(
            "ModelType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelType {
    const NAME: &'static str = "ModelType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.title = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                42 => {
                    self.input_fields.push(is.read_string()?);
                },
                50 => {
                    self.output_fields.push(is.read_string()?);
                },
                64 => {
                    self.trainable = is.read_bool()?;
                },
                72 => {
                    self.creatable = is.read_bool()?;
                },
                80 => {
                    self.internal_only = is.read_bool()?;
                },
                90 => {
                    self.model_type_fields.push(is.read_message()?);
                },
                96 => {
                    self.requires_sequential_frames = is.read_bool()?;
                },
                130 => {
                    self.expected_input_layers.push(is.read_message()?);
                },
                138 => {
                    self.expected_output_layers.push(is.read_message()?);
                },
                144 => {
                    self.evaluation_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        for value in &self.input_fields {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.output_fields {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.trainable != false {
            my_size += 1 + 1;
        }
        if self.creatable != false {
            my_size += 1 + 1;
        }
        if self.internal_only != false {
            my_size += 1 + 1;
        }
        for value in &self.model_type_fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.requires_sequential_frames != false {
            my_size += 1 + 1;
        }
        for value in &self.expected_input_layers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.expected_output_layers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.evaluation_type != ::protobuf::EnumOrUnknown::new(EvaluationType::Undefined) {
            my_size += ::protobuf::rt::int32_size(18, self.evaluation_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        for v in &self.input_fields {
            os.write_string(5, &v)?;
        };
        for v in &self.output_fields {
            os.write_string(6, &v)?;
        };
        if self.trainable != false {
            os.write_bool(8, self.trainable)?;
        }
        if self.creatable != false {
            os.write_bool(9, self.creatable)?;
        }
        if self.internal_only != false {
            os.write_bool(10, self.internal_only)?;
        }
        for v in &self.model_type_fields {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if self.requires_sequential_frames != false {
            os.write_bool(12, self.requires_sequential_frames)?;
        }
        for v in &self.expected_input_layers {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.expected_output_layers {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if self.evaluation_type != ::protobuf::EnumOrUnknown::new(EvaluationType::Undefined) {
            os.write_enum(18, ::protobuf::EnumOrUnknown::value(&self.evaluation_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelType {
        ModelType::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.title.clear();
        self.description.clear();
        self.input_fields.clear();
        self.output_fields.clear();
        self.trainable = false;
        self.creatable = false;
        self.internal_only = false;
        self.model_type_fields.clear();
        self.requires_sequential_frames = false;
        self.expected_input_layers.clear();
        self.expected_output_layers.clear();
        self.evaluation_type = ::protobuf::EnumOrUnknown::new(EvaluationType::Undefined);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelType {
        static instance: ModelType = ModelType {
            id: ::std::string::String::new(),
            title: ::std::string::String::new(),
            description: ::std::string::String::new(),
            input_fields: ::std::vec::Vec::new(),
            output_fields: ::std::vec::Vec::new(),
            trainable: false,
            creatable: false,
            internal_only: false,
            model_type_fields: ::std::vec::Vec::new(),
            requires_sequential_frames: false,
            expected_input_layers: ::std::vec::Vec::new(),
            expected_output_layers: ::std::vec::Vec::new(),
            evaluation_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ModelLayerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelLayerInfo {
    // message fields
    ///  The api.Data field this layer will be parsed into
    // @@protoc_insertion_point(field:clarifai.api.ModelLayerInfo.data_field_name)
    pub data_field_name: ::std::string::String,
    ///  Description of the expected shape. Can support multiple support layer shapes.
    // @@protoc_insertion_point(field:clarifai.api.ModelLayerInfo.shapes)
    pub shapes: ::std::vec::Vec<LayerShape>,
    ///  Brief description about the layer if needed
    // @@protoc_insertion_point(field:clarifai.api.ModelLayerInfo.description)
    pub description: ::std::string::String,
    ///  Whether this layer should have a label_filename specified and provided
    // @@protoc_insertion_point(field:clarifai.api.ModelLayerInfo.requires_label_filename)
    pub requires_label_filename: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelLayerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelLayerInfo {
    fn default() -> &'a ModelLayerInfo {
        <ModelLayerInfo as ::protobuf::Message>::default_instance()
    }
}

impl ModelLayerInfo {
    pub fn new() -> ModelLayerInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_field_name",
            |m: &ModelLayerInfo| { &m.data_field_name },
            |m: &mut ModelLayerInfo| { &mut m.data_field_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shapes",
            |m: &ModelLayerInfo| { &m.shapes },
            |m: &mut ModelLayerInfo| { &mut m.shapes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ModelLayerInfo| { &m.description },
            |m: &mut ModelLayerInfo| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_label_filename",
            |m: &ModelLayerInfo| { &m.requires_label_filename },
            |m: &mut ModelLayerInfo| { &mut m.requires_label_filename },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelLayerInfo>(
            "ModelLayerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelLayerInfo {
    const NAME: &'static str = "ModelLayerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_field_name = is.read_string()?;
                },
                18 => {
                    self.shapes.push(is.read_message()?);
                },
                26 => {
                    self.description = is.read_string()?;
                },
                32 => {
                    self.requires_label_filename = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data_field_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.data_field_name);
        }
        for value in &self.shapes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.requires_label_filename != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data_field_name.is_empty() {
            os.write_string(1, &self.data_field_name)?;
        }
        for v in &self.shapes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.requires_label_filename != false {
            os.write_bool(4, self.requires_label_filename)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelLayerInfo {
        ModelLayerInfo::new()
    }

    fn clear(&mut self) {
        self.data_field_name.clear();
        self.shapes.clear();
        self.description.clear();
        self.requires_label_filename = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelLayerInfo {
        static instance: ModelLayerInfo = ModelLayerInfo {
            data_field_name: ::std::string::String::new(),
            shapes: ::std::vec::Vec::new(),
            description: ::std::string::String::new(),
            requires_label_filename: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelLayerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelLayerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelLayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelLayerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.TritonCondaEnvInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TritonCondaEnvInfo {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.TritonCondaEnvInfo.conda_pack_url)
    pub conda_pack_url: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.TritonCondaEnvInfo.conda_yaml_url)
    pub conda_yaml_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TritonCondaEnvInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TritonCondaEnvInfo {
    fn default() -> &'a TritonCondaEnvInfo {
        <TritonCondaEnvInfo as ::protobuf::Message>::default_instance()
    }
}

impl TritonCondaEnvInfo {
    pub fn new() -> TritonCondaEnvInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conda_pack_url",
            |m: &TritonCondaEnvInfo| { &m.conda_pack_url },
            |m: &mut TritonCondaEnvInfo| { &mut m.conda_pack_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conda_yaml_url",
            |m: &TritonCondaEnvInfo| { &m.conda_yaml_url },
            |m: &mut TritonCondaEnvInfo| { &mut m.conda_yaml_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TritonCondaEnvInfo>(
            "TritonCondaEnvInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TritonCondaEnvInfo {
    const NAME: &'static str = "TritonCondaEnvInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conda_pack_url = is.read_string()?;
                },
                18 => {
                    self.conda_yaml_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.conda_pack_url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.conda_pack_url);
        }
        if !self.conda_yaml_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.conda_yaml_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.conda_pack_url.is_empty() {
            os.write_string(1, &self.conda_pack_url)?;
        }
        if !self.conda_yaml_url.is_empty() {
            os.write_string(2, &self.conda_yaml_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TritonCondaEnvInfo {
        TritonCondaEnvInfo::new()
    }

    fn clear(&mut self) {
        self.conda_pack_url.clear();
        self.conda_yaml_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TritonCondaEnvInfo {
        static instance: TritonCondaEnvInfo = TritonCondaEnvInfo {
            conda_pack_url: ::std::string::String::new(),
            conda_yaml_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TritonCondaEnvInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TritonCondaEnvInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TritonCondaEnvInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TritonCondaEnvInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.LayerShape)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LayerShape {
    // message fields
    ///  Supported dimensions
    ///  Example: [-1,4] is a 2-dimensional array with the first dimension of variablesize, but second dimension with a static size: [[1,2,3,4],[4,5,6,7],...]
    // @@protoc_insertion_point(field:clarifai.api.LayerShape.dims)
    pub dims: ::std::vec::Vec<i32>,
    ///  Max dimension size, applicable to layers that can have flexible sizes.
    // @@protoc_insertion_point(field:clarifai.api.LayerShape.max_dims)
    pub max_dims: ::std::vec::Vec<i32>,
    ///  The triton data type
    // @@protoc_insertion_point(field:clarifai.api.LayerShape.data_type)
    pub data_type: ::protobuf::EnumOrUnknown<DataType>,
    ///  Description about the dimensions
    // @@protoc_insertion_point(field:clarifai.api.LayerShape.description)
    pub description: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.LayerShape.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LayerShape {
    fn default() -> &'a LayerShape {
        <LayerShape as ::protobuf::Message>::default_instance()
    }
}

impl LayerShape {
    pub fn new() -> LayerShape {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dims",
            |m: &LayerShape| { &m.dims },
            |m: &mut LayerShape| { &mut m.dims },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "max_dims",
            |m: &LayerShape| { &m.max_dims },
            |m: &mut LayerShape| { &mut m.max_dims },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_type",
            |m: &LayerShape| { &m.data_type },
            |m: &mut LayerShape| { &mut m.data_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &LayerShape| { &m.description },
            |m: &mut LayerShape| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LayerShape>(
            "LayerShape",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LayerShape {
    const NAME: &'static str = "LayerShape";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.dims)?;
                },
                8 => {
                    self.dims.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.max_dims)?;
                },
                16 => {
                    self.max_dims.push(is.read_int32()?);
                },
                24 => {
                    self.data_type = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.description = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dims {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        for value in &self.max_dims {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        if self.data_type != ::protobuf::EnumOrUnknown::new(DataType::UNDEFINED) {
            my_size += ::protobuf::rt::int32_size(3, self.data_type.value());
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dims {
            os.write_int32(1, *v)?;
        };
        for v in &self.max_dims {
            os.write_int32(2, *v)?;
        };
        if self.data_type != ::protobuf::EnumOrUnknown::new(DataType::UNDEFINED) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.data_type))?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LayerShape {
        LayerShape::new()
    }

    fn clear(&mut self) {
        self.dims.clear();
        self.max_dims.clear();
        self.data_type = ::protobuf::EnumOrUnknown::new(DataType::UNDEFINED);
        self.description.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LayerShape {
        static instance: LayerShape = LayerShape {
            dims: ::std::vec::Vec::new(),
            max_dims: ::std::vec::Vec::new(),
            data_type: ::protobuf::EnumOrUnknown::from_i32(0),
            description: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LayerShape {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LayerShape").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LayerShape {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LayerShape {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelTypeField stores a field value of a configurable type.
// @@protoc_insertion_point(message:clarifai.api.ModelTypeField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelTypeField {
    // message fields
    ///  The path where the value of the field will be stored in the model version object.
    ///  Example:
    ///  "output_info.data" would be the Data message in the OutputInfo message.
    ///  "output_info.output_config.language" is in the OutputConfig message within OutputInfo
    ///  "input_info.params" is in the params struct within InputInfo.
    ///  "output_info.params" is in the params struct within OutputInfo.
    ///  "train_info.params" is in the params struct within TrainInfo.
    ///  and so on.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.path)
    pub path: ::std::string::String,
    ///  The field for this field.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.field_type)
    pub field_type: ::protobuf::EnumOrUnknown<model_type_field::ModelTypeFieldType>,
    ///  A default value. We use the Value field because we want to have structured data (just like
    ///  google.protobuf.Struct but this is just a single value).
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.default_value)
    pub default_value: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Value>,
    ///  Description for this field.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.description)
    pub description: ::std::string::String,
    ///  Placeholder text for the UI element.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.placeholder)
    pub placeholder: ::std::string::String,
    ///  List of options of the ENUM type and potentially additional fields they bring with them.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.model_type_enum_options)
    pub model_type_enum_options: ::std::vec::Vec<ModelTypeEnumOption>,
    ///  If this field should appear for internal users only.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.internal_only)
    pub internal_only: bool,
    ///  If this field is a required field. If True then during validation you won't be able to create
    ///  a model of this type with providing a value for this field. When False, the ModelType's
    ///  default_value will be used for this field.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.required)
    pub required: bool,
    ///  If the field_type is RANGE, this must be filled in.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeField.model_type_range_info)
    pub model_type_range_info: ::protobuf::MessageField<ModelTypeRangeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelTypeField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelTypeField {
    fn default() -> &'a ModelTypeField {
        <ModelTypeField as ::protobuf::Message>::default_instance()
    }
}

impl ModelTypeField {
    pub fn new() -> ModelTypeField {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ModelTypeField| { &m.path },
            |m: &mut ModelTypeField| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "field_type",
            |m: &ModelTypeField| { &m.field_type },
            |m: &mut ModelTypeField| { &mut m.field_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Value>(
            "default_value",
            |m: &ModelTypeField| { &m.default_value },
            |m: &mut ModelTypeField| { &mut m.default_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ModelTypeField| { &m.description },
            |m: &mut ModelTypeField| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "placeholder",
            |m: &ModelTypeField| { &m.placeholder },
            |m: &mut ModelTypeField| { &mut m.placeholder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_type_enum_options",
            |m: &ModelTypeField| { &m.model_type_enum_options },
            |m: &mut ModelTypeField| { &mut m.model_type_enum_options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "internal_only",
            |m: &ModelTypeField| { &m.internal_only },
            |m: &mut ModelTypeField| { &mut m.internal_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "required",
            |m: &ModelTypeField| { &m.required },
            |m: &mut ModelTypeField| { &mut m.required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ModelTypeRangeInfo>(
            "model_type_range_info",
            |m: &ModelTypeField| { &m.model_type_range_info },
            |m: &mut ModelTypeField| { &mut m.model_type_range_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelTypeField>(
            "ModelTypeField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelTypeField {
    const NAME: &'static str = "ModelTypeField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                16 => {
                    self.field_type = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.default_value)?;
                },
                34 => {
                    self.description = is.read_string()?;
                },
                42 => {
                    self.placeholder = is.read_string()?;
                },
                50 => {
                    self.model_type_enum_options.push(is.read_message()?);
                },
                56 => {
                    self.internal_only = is.read_bool()?;
                },
                64 => {
                    self.required = is.read_bool()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_type_range_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.field_type != ::protobuf::EnumOrUnknown::new(model_type_field::ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE) {
            my_size += ::protobuf::rt::int32_size(2, self.field_type.value());
        }
        if let Some(v) = self.default_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if !self.placeholder.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.placeholder);
        }
        for value in &self.model_type_enum_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.internal_only != false {
            my_size += 1 + 1;
        }
        if self.required != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.model_type_range_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.field_type != ::protobuf::EnumOrUnknown::new(model_type_field::ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.field_type))?;
        }
        if let Some(v) = self.default_value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if !self.placeholder.is_empty() {
            os.write_string(5, &self.placeholder)?;
        }
        for v in &self.model_type_enum_options {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.internal_only != false {
            os.write_bool(7, self.internal_only)?;
        }
        if self.required != false {
            os.write_bool(8, self.required)?;
        }
        if let Some(v) = self.model_type_range_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelTypeField {
        ModelTypeField::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.field_type = ::protobuf::EnumOrUnknown::new(model_type_field::ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE);
        self.default_value.clear();
        self.description.clear();
        self.placeholder.clear();
        self.model_type_enum_options.clear();
        self.internal_only = false;
        self.required = false;
        self.model_type_range_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelTypeField {
        static instance: ModelTypeField = ModelTypeField {
            path: ::std::string::String::new(),
            field_type: ::protobuf::EnumOrUnknown::from_i32(0),
            default_value: ::protobuf::MessageField::none(),
            description: ::std::string::String::new(),
            placeholder: ::std::string::String::new(),
            model_type_enum_options: ::std::vec::Vec::new(),
            internal_only: false,
            required: false,
            model_type_range_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelTypeField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelTypeField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelTypeField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelTypeField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ModelTypeField`
pub mod model_type_field {
    ///  These are various types of fields that we have UIs for.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.ModelTypeField.ModelTypeFieldType)
    pub enum ModelTypeFieldType {
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.INVALID_MODEL_TYPE_FIELD_TYPE)
        INVALID_MODEL_TYPE_FIELD_TYPE = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.BOOLEAN)
        BOOLEAN = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.STRING)
        STRING = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.NUMBER)
        NUMBER = 3,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.ARRAY_OF_CONCEPTS)
        ARRAY_OF_CONCEPTS = 4,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.ARRAY_OF_CONCEPTS_WITH_THRESHOLD)
        ARRAY_OF_CONCEPTS_WITH_THRESHOLD = 5,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.RANGE)
        RANGE = 7,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.ENUM)
        ENUM = 8,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.COLLABORATORS)
        COLLABORATORS = 9,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.JSON)
        JSON = 10,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.ARRAY_OF_NUMBERS)
        ARRAY_OF_NUMBERS = 11,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.WORKFLOW_EMBED_MODELS)
        WORKFLOW_EMBED_MODELS = 12,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.ARRAY_OF_STRINGS)
        ARRAY_OF_STRINGS = 13,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.RECURSIVE_ENUM)
        RECURSIVE_ENUM = 14,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.PYTHON_CODE)
        PYTHON_CODE = 15,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.DATASET_ID)
        DATASET_ID = 16,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.DATASET_VERSION_ID)
        DATASET_VERSION_ID = 17,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.ARRAY_OF_MODEL_CONCEPTS)
        ARRAY_OF_MODEL_CONCEPTS = 18,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.DATASET)
        DATASET = 19,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.DATASET_VERSION)
        DATASET_VERSION = 20,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.ENCRYPTED_STRING)
        ENCRYPTED_STRING = 21,
        // @@protoc_insertion_point(enum_value:clarifai.api.ModelTypeField.ModelTypeFieldType.CHECKPOINT_MODEL)
        CHECKPOINT_MODEL = 22,
    }

    impl ::protobuf::Enum for ModelTypeFieldType {
        const NAME: &'static str = "ModelTypeFieldType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ModelTypeFieldType> {
            match value {
                0 => ::std::option::Option::Some(ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE),
                1 => ::std::option::Option::Some(ModelTypeFieldType::BOOLEAN),
                2 => ::std::option::Option::Some(ModelTypeFieldType::STRING),
                3 => ::std::option::Option::Some(ModelTypeFieldType::NUMBER),
                4 => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_CONCEPTS),
                5 => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_CONCEPTS_WITH_THRESHOLD),
                7 => ::std::option::Option::Some(ModelTypeFieldType::RANGE),
                8 => ::std::option::Option::Some(ModelTypeFieldType::ENUM),
                9 => ::std::option::Option::Some(ModelTypeFieldType::COLLABORATORS),
                10 => ::std::option::Option::Some(ModelTypeFieldType::JSON),
                11 => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_NUMBERS),
                12 => ::std::option::Option::Some(ModelTypeFieldType::WORKFLOW_EMBED_MODELS),
                13 => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_STRINGS),
                14 => ::std::option::Option::Some(ModelTypeFieldType::RECURSIVE_ENUM),
                15 => ::std::option::Option::Some(ModelTypeFieldType::PYTHON_CODE),
                16 => ::std::option::Option::Some(ModelTypeFieldType::DATASET_ID),
                17 => ::std::option::Option::Some(ModelTypeFieldType::DATASET_VERSION_ID),
                18 => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_MODEL_CONCEPTS),
                19 => ::std::option::Option::Some(ModelTypeFieldType::DATASET),
                20 => ::std::option::Option::Some(ModelTypeFieldType::DATASET_VERSION),
                21 => ::std::option::Option::Some(ModelTypeFieldType::ENCRYPTED_STRING),
                22 => ::std::option::Option::Some(ModelTypeFieldType::CHECKPOINT_MODEL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ModelTypeFieldType> {
            match str {
                "INVALID_MODEL_TYPE_FIELD_TYPE" => ::std::option::Option::Some(ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE),
                "BOOLEAN" => ::std::option::Option::Some(ModelTypeFieldType::BOOLEAN),
                "STRING" => ::std::option::Option::Some(ModelTypeFieldType::STRING),
                "NUMBER" => ::std::option::Option::Some(ModelTypeFieldType::NUMBER),
                "ARRAY_OF_CONCEPTS" => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_CONCEPTS),
                "ARRAY_OF_CONCEPTS_WITH_THRESHOLD" => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_CONCEPTS_WITH_THRESHOLD),
                "RANGE" => ::std::option::Option::Some(ModelTypeFieldType::RANGE),
                "ENUM" => ::std::option::Option::Some(ModelTypeFieldType::ENUM),
                "COLLABORATORS" => ::std::option::Option::Some(ModelTypeFieldType::COLLABORATORS),
                "JSON" => ::std::option::Option::Some(ModelTypeFieldType::JSON),
                "ARRAY_OF_NUMBERS" => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_NUMBERS),
                "WORKFLOW_EMBED_MODELS" => ::std::option::Option::Some(ModelTypeFieldType::WORKFLOW_EMBED_MODELS),
                "ARRAY_OF_STRINGS" => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_STRINGS),
                "RECURSIVE_ENUM" => ::std::option::Option::Some(ModelTypeFieldType::RECURSIVE_ENUM),
                "PYTHON_CODE" => ::std::option::Option::Some(ModelTypeFieldType::PYTHON_CODE),
                "DATASET_ID" => ::std::option::Option::Some(ModelTypeFieldType::DATASET_ID),
                "DATASET_VERSION_ID" => ::std::option::Option::Some(ModelTypeFieldType::DATASET_VERSION_ID),
                "ARRAY_OF_MODEL_CONCEPTS" => ::std::option::Option::Some(ModelTypeFieldType::ARRAY_OF_MODEL_CONCEPTS),
                "DATASET" => ::std::option::Option::Some(ModelTypeFieldType::DATASET),
                "DATASET_VERSION" => ::std::option::Option::Some(ModelTypeFieldType::DATASET_VERSION),
                "ENCRYPTED_STRING" => ::std::option::Option::Some(ModelTypeFieldType::ENCRYPTED_STRING),
                "CHECKPOINT_MODEL" => ::std::option::Option::Some(ModelTypeFieldType::CHECKPOINT_MODEL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ModelTypeFieldType] = &[
            ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE,
            ModelTypeFieldType::BOOLEAN,
            ModelTypeFieldType::STRING,
            ModelTypeFieldType::NUMBER,
            ModelTypeFieldType::ARRAY_OF_CONCEPTS,
            ModelTypeFieldType::ARRAY_OF_CONCEPTS_WITH_THRESHOLD,
            ModelTypeFieldType::RANGE,
            ModelTypeFieldType::ENUM,
            ModelTypeFieldType::COLLABORATORS,
            ModelTypeFieldType::JSON,
            ModelTypeFieldType::ARRAY_OF_NUMBERS,
            ModelTypeFieldType::WORKFLOW_EMBED_MODELS,
            ModelTypeFieldType::ARRAY_OF_STRINGS,
            ModelTypeFieldType::RECURSIVE_ENUM,
            ModelTypeFieldType::PYTHON_CODE,
            ModelTypeFieldType::DATASET_ID,
            ModelTypeFieldType::DATASET_VERSION_ID,
            ModelTypeFieldType::ARRAY_OF_MODEL_CONCEPTS,
            ModelTypeFieldType::DATASET,
            ModelTypeFieldType::DATASET_VERSION,
            ModelTypeFieldType::ENCRYPTED_STRING,
            ModelTypeFieldType::CHECKPOINT_MODEL,
        ];
    }

    impl ::protobuf::EnumFull for ModelTypeFieldType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ModelTypeField.ModelTypeFieldType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE => 0,
                ModelTypeFieldType::BOOLEAN => 1,
                ModelTypeFieldType::STRING => 2,
                ModelTypeFieldType::NUMBER => 3,
                ModelTypeFieldType::ARRAY_OF_CONCEPTS => 4,
                ModelTypeFieldType::ARRAY_OF_CONCEPTS_WITH_THRESHOLD => 5,
                ModelTypeFieldType::RANGE => 6,
                ModelTypeFieldType::ENUM => 7,
                ModelTypeFieldType::COLLABORATORS => 8,
                ModelTypeFieldType::JSON => 9,
                ModelTypeFieldType::ARRAY_OF_NUMBERS => 10,
                ModelTypeFieldType::WORKFLOW_EMBED_MODELS => 11,
                ModelTypeFieldType::ARRAY_OF_STRINGS => 12,
                ModelTypeFieldType::RECURSIVE_ENUM => 13,
                ModelTypeFieldType::PYTHON_CODE => 14,
                ModelTypeFieldType::DATASET_ID => 15,
                ModelTypeFieldType::DATASET_VERSION_ID => 16,
                ModelTypeFieldType::ARRAY_OF_MODEL_CONCEPTS => 17,
                ModelTypeFieldType::DATASET => 18,
                ModelTypeFieldType::DATASET_VERSION => 19,
                ModelTypeFieldType::ENCRYPTED_STRING => 20,
                ModelTypeFieldType::CHECKPOINT_MODEL => 21,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ModelTypeFieldType {
        fn default() -> Self {
            ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE
        }
    }

    impl ModelTypeFieldType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ModelTypeFieldType>("ModelTypeField.ModelTypeFieldType")
        }
    }
}

///  ModelTypeRangeInfo
// @@protoc_insertion_point(message:clarifai.api.ModelTypeRangeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelTypeRangeInfo {
    // message fields
    ///  The start of the range as a float.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeRangeInfo.min)
    pub min: f32,
    ///  The end of the range as a float.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeRangeInfo.max)
    pub max: f32,
    ///  An optional step size for the range. If provided then only values at that step size will be
    ///  rounded to. For example if step is 0.02 then 0.0245 will round to 0.02.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeRangeInfo.step)
    pub step: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelTypeRangeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelTypeRangeInfo {
    fn default() -> &'a ModelTypeRangeInfo {
        <ModelTypeRangeInfo as ::protobuf::Message>::default_instance()
    }
}

impl ModelTypeRangeInfo {
    pub fn new() -> ModelTypeRangeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min",
            |m: &ModelTypeRangeInfo| { &m.min },
            |m: &mut ModelTypeRangeInfo| { &mut m.min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max",
            |m: &ModelTypeRangeInfo| { &m.max },
            |m: &mut ModelTypeRangeInfo| { &mut m.max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step",
            |m: &ModelTypeRangeInfo| { &m.step },
            |m: &mut ModelTypeRangeInfo| { &mut m.step },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelTypeRangeInfo>(
            "ModelTypeRangeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelTypeRangeInfo {
    const NAME: &'static str = "ModelTypeRangeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.min = is.read_float()?;
                },
                21 => {
                    self.max = is.read_float()?;
                },
                29 => {
                    self.step = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.min != 0. {
            my_size += 1 + 4;
        }
        if self.max != 0. {
            my_size += 1 + 4;
        }
        if self.step != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.min != 0. {
            os.write_float(1, self.min)?;
        }
        if self.max != 0. {
            os.write_float(2, self.max)?;
        }
        if self.step != 0. {
            os.write_float(3, self.step)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelTypeRangeInfo {
        ModelTypeRangeInfo::new()
    }

    fn clear(&mut self) {
        self.min = 0.;
        self.max = 0.;
        self.step = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelTypeRangeInfo {
        static instance: ModelTypeRangeInfo = ModelTypeRangeInfo {
            min: 0.,
            max: 0.,
            step: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelTypeRangeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelTypeRangeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelTypeRangeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelTypeRangeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelTypeEnumOption
// @@protoc_insertion_point(message:clarifai.api.ModelTypeEnumOption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelTypeEnumOption {
    // message fields
    ///  The unique value of the enum option.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeEnumOption.id)
    pub id: ::std::string::String,
    ///  List of other ID values that are equivalent with this ID.
    ///  This allows the user to choose this option by multiple IDs.
    ///  Example: if enum is "Phone Number Prefix", you could add an option that is selectable by two values:
    ///  1. ID: "Estonia"
    ///  2. Alias: 37
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeEnumOption.aliases)
    pub aliases: ::std::vec::Vec<ModelTypeEnumOptionAlias>,
    ///  Optional description for this enum option.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeEnumOption.description)
    pub description: ::std::string::String,
    ///  These are additional fields that are specific to this enum choice. This allows
    ///  us to use enums to control configuration settings as well.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeEnumOption.model_type_fields)
    pub model_type_fields: ::std::vec::Vec<ModelTypeField>,
    ///  If this enum option should be internal only.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeEnumOption.internal_only)
    pub internal_only: bool,
    ///  Whether this is the recommended enum option. Set to `true` when there
    ///  are multiple options, and one is shown to be better than the others.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeEnumOption.recommended)
    pub recommended: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelTypeEnumOption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelTypeEnumOption {
    fn default() -> &'a ModelTypeEnumOption {
        <ModelTypeEnumOption as ::protobuf::Message>::default_instance()
    }
}

impl ModelTypeEnumOption {
    pub fn new() -> ModelTypeEnumOption {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ModelTypeEnumOption| { &m.id },
            |m: &mut ModelTypeEnumOption| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "aliases",
            |m: &ModelTypeEnumOption| { &m.aliases },
            |m: &mut ModelTypeEnumOption| { &mut m.aliases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ModelTypeEnumOption| { &m.description },
            |m: &mut ModelTypeEnumOption| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_type_fields",
            |m: &ModelTypeEnumOption| { &m.model_type_fields },
            |m: &mut ModelTypeEnumOption| { &mut m.model_type_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "internal_only",
            |m: &ModelTypeEnumOption| { &m.internal_only },
            |m: &mut ModelTypeEnumOption| { &mut m.internal_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recommended",
            |m: &ModelTypeEnumOption| { &m.recommended },
            |m: &mut ModelTypeEnumOption| { &mut m.recommended },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelTypeEnumOption>(
            "ModelTypeEnumOption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelTypeEnumOption {
    const NAME: &'static str = "ModelTypeEnumOption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                42 => {
                    self.aliases.push(is.read_message()?);
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    self.model_type_fields.push(is.read_message()?);
                },
                32 => {
                    self.internal_only = is.read_bool()?;
                },
                48 => {
                    self.recommended = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        for value in &self.aliases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.model_type_fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.internal_only != false {
            my_size += 1 + 1;
        }
        if self.recommended != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        for v in &self.aliases {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.model_type_fields {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.internal_only != false {
            os.write_bool(4, self.internal_only)?;
        }
        if self.recommended != false {
            os.write_bool(6, self.recommended)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelTypeEnumOption {
        ModelTypeEnumOption::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.aliases.clear();
        self.description.clear();
        self.model_type_fields.clear();
        self.internal_only = false;
        self.recommended = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelTypeEnumOption {
        static instance: ModelTypeEnumOption = ModelTypeEnumOption {
            id: ::std::string::String::new(),
            aliases: ::std::vec::Vec::new(),
            description: ::std::string::String::new(),
            model_type_fields: ::std::vec::Vec::new(),
            internal_only: false,
            recommended: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelTypeEnumOption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelTypeEnumOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelTypeEnumOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelTypeEnumOption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ModelTypeEnumOptionAlias)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelTypeEnumOptionAlias {
    // message fields
    ///  Integer alias for id.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeEnumOptionAlias.id_int)
    pub id_int: i64,
    ///  String that can contain wild cards and the regex needs to match.
    // @@protoc_insertion_point(field:clarifai.api.ModelTypeEnumOptionAlias.wildcard_string)
    pub wildcard_string: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelTypeEnumOptionAlias.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelTypeEnumOptionAlias {
    fn default() -> &'a ModelTypeEnumOptionAlias {
        <ModelTypeEnumOptionAlias as ::protobuf::Message>::default_instance()
    }
}

impl ModelTypeEnumOptionAlias {
    pub fn new() -> ModelTypeEnumOptionAlias {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id_int",
            |m: &ModelTypeEnumOptionAlias| { &m.id_int },
            |m: &mut ModelTypeEnumOptionAlias| { &mut m.id_int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wildcard_string",
            |m: &ModelTypeEnumOptionAlias| { &m.wildcard_string },
            |m: &mut ModelTypeEnumOptionAlias| { &mut m.wildcard_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelTypeEnumOptionAlias>(
            "ModelTypeEnumOptionAlias",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelTypeEnumOptionAlias {
    const NAME: &'static str = "ModelTypeEnumOptionAlias";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id_int = is.read_int64()?;
                },
                18 => {
                    self.wildcard_string = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id_int != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id_int);
        }
        if !self.wildcard_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.wildcard_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id_int != 0 {
            os.write_int64(1, self.id_int)?;
        }
        if !self.wildcard_string.is_empty() {
            os.write_string(2, &self.wildcard_string)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelTypeEnumOptionAlias {
        ModelTypeEnumOptionAlias::new()
    }

    fn clear(&mut self) {
        self.id_int = 0;
        self.wildcard_string.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelTypeEnumOptionAlias {
        static instance: ModelTypeEnumOptionAlias = ModelTypeEnumOptionAlias {
            id_int: 0,
            wildcard_string: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelTypeEnumOptionAlias {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelTypeEnumOptionAlias").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelTypeEnumOptionAlias {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelTypeEnumOptionAlias {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelQuery
// @@protoc_insertion_point(message:clarifai.api.ModelQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelQuery {
    // message fields
    ///  The name ofthe field. This supports wilcard queries like "gen*" to match "general" as an example.
    // @@protoc_insertion_point(field:clarifai.api.ModelQuery.name)
    pub name: ::std::string::String,
    ///  Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
    ///  supported.
    // @@protoc_insertion_point(field:clarifai.api.ModelQuery.model_type_id)
    pub model_type_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelQuery {
    fn default() -> &'a ModelQuery {
        <ModelQuery as ::protobuf::Message>::default_instance()
    }
}

impl ModelQuery {
    pub fn new() -> ModelQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ModelQuery| { &m.name },
            |m: &mut ModelQuery| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &ModelQuery| { &m.model_type_id },
            |m: &mut ModelQuery| { &mut m.model_type_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelQuery>(
            "ModelQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelQuery {
    const NAME: &'static str = "ModelQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.model_type_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_type_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(3, &self.model_type_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelQuery {
        ModelQuery::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.model_type_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelQuery {
        static instance: ModelQuery = ModelQuery {
            name: ::std::string::String::new(),
            model_type_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersion
// @@protoc_insertion_point(message:clarifai.api.ModelVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelVersion {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.id)
    pub id: ::std::string::String,
    ///  When the version was created.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The status of the version (whether it's untrained, training, trained, etc.).
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.active_concept_count)
    pub active_concept_count: u32,
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.metrics)
    pub metrics: ::protobuf::MessageField<EvalMetrics>,
    ///  number of inputs in the model version
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.total_input_count)
    pub total_input_count: u32,
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.pretrained_model_config)
    pub pretrained_model_config: ::protobuf::MessageField<PretrainedModelConfig>,
    ///  When training of this version was completed.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.completed_at)
    pub completed_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Description about this version
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.description)
    pub description: ::std::string::String,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  The app the model version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.app_id)
    pub app_id: ::std::string::String,
    ///  The user the model version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.user_id)
    pub user_id: ::std::string::String,
    ///  When this model version was last modified
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.license)
    pub license: ::std::string::String,
    ///  Info about the model's output. Besides `output_info.data`, these fields should
    ///  be reserved for parameters that affect the models outputs when inferencing.
    ///  `output_info.data` is used to specify the training concepts for this model version.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.output_info)
    pub output_info: ::protobuf::MessageField<OutputInfo>,
    ///  Info about preprocessing the models inputs, before they are sent to this model for training or inferencing.
    ///  E.g.: `input_info.base_embed_model` lets us know inputs should be ran through a base model before being sent to an embedding-classifier.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.input_info)
    pub input_info: ::protobuf::MessageField<InputInfo>,
    ///  Configuration for the training process of this model version.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.train_info)
    pub train_info: ::protobuf::MessageField<TrainInfo>,
    ///  Configuration used to import model from third-party toolkits
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.import_info)
    pub import_info: ::protobuf::MessageField<ImportInfo>,
    ///  Contains the training logs if available
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.train_log)
    pub train_log: ::std::string::String,
    ///  The minimum required compute resource for this model for inference.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.inference_compute_info)
    pub inference_compute_info: ::protobuf::MessageField<ComputeInfo>,
    ///  Build information for the model version
    // @@protoc_insertion_point(field:clarifai.api.ModelVersion.build_info)
    pub build_info: ::protobuf::MessageField<BuildInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersion {
    fn default() -> &'a ModelVersion {
        <ModelVersion as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersion {
    pub fn new() -> ModelVersion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ModelVersion| { &m.id },
            |m: &mut ModelVersion| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &ModelVersion| { &m.created_at },
            |m: &mut ModelVersion| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ModelVersion| { &m.status },
            |m: &mut ModelVersion| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_concept_count",
            |m: &ModelVersion| { &m.active_concept_count },
            |m: &mut ModelVersion| { &mut m.active_concept_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EvalMetrics>(
            "metrics",
            |m: &ModelVersion| { &m.metrics },
            |m: &mut ModelVersion| { &mut m.metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_input_count",
            |m: &ModelVersion| { &m.total_input_count },
            |m: &mut ModelVersion| { &mut m.total_input_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PretrainedModelConfig>(
            "pretrained_model_config",
            |m: &ModelVersion| { &m.pretrained_model_config },
            |m: &mut ModelVersion| { &mut m.pretrained_model_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "completed_at",
            |m: &ModelVersion| { &m.completed_at },
            |m: &mut ModelVersion| { &mut m.completed_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ModelVersion| { &m.description },
            |m: &mut ModelVersion| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &ModelVersion| { &m.visibility },
            |m: &mut ModelVersion| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &ModelVersion| { &m.app_id },
            |m: &mut ModelVersion| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &ModelVersion| { &m.user_id },
            |m: &mut ModelVersion| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &ModelVersion| { &m.modified_at },
            |m: &mut ModelVersion| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &ModelVersion| { &m.metadata },
            |m: &mut ModelVersion| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "license",
            |m: &ModelVersion| { &m.license },
            |m: &mut ModelVersion| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OutputInfo>(
            "output_info",
            |m: &ModelVersion| { &m.output_info },
            |m: &mut ModelVersion| { &mut m.output_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InputInfo>(
            "input_info",
            |m: &ModelVersion| { &m.input_info },
            |m: &mut ModelVersion| { &mut m.input_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrainInfo>(
            "train_info",
            |m: &ModelVersion| { &m.train_info },
            |m: &mut ModelVersion| { &mut m.train_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImportInfo>(
            "import_info",
            |m: &ModelVersion| { &m.import_info },
            |m: &mut ModelVersion| { &mut m.import_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "train_log",
            |m: &ModelVersion| { &m.train_log },
            |m: &mut ModelVersion| { &mut m.train_log },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ComputeInfo>(
            "inference_compute_info",
            |m: &ModelVersion| { &m.inference_compute_info },
            |m: &mut ModelVersion| { &mut m.inference_compute_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BuildInfo>(
            "build_info",
            |m: &ModelVersion| { &m.build_info },
            |m: &mut ModelVersion| { &mut m.build_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersion>(
            "ModelVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersion {
    const NAME: &'static str = "ModelVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                32 => {
                    self.active_concept_count = is.read_uint32()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                48 => {
                    self.total_input_count = is.read_uint32()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pretrained_model_config)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.completed_at)?;
                },
                90 => {
                    self.description = is.read_string()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                106 => {
                    self.app_id = is.read_string()?;
                },
                114 => {
                    self.user_id = is.read_string()?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                138 => {
                    self.license = is.read_string()?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_info)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input_info)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.train_info)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.import_info)?;
                },
                186 => {
                    self.train_log = is.read_string()?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inference_compute_info)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.active_concept_count != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.active_concept_count);
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total_input_count != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.total_input_count);
        }
        if let Some(v) = self.pretrained_model_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.completed_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.description);
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.user_id);
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.license);
        }
        if let Some(v) = self.output_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.train_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.import_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.train_log.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.train_log);
        }
        if let Some(v) = self.inference_compute_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.build_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.active_concept_count != 0 {
            os.write_uint32(4, self.active_concept_count)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.total_input_count != 0 {
            os.write_uint32(6, self.total_input_count)?;
        }
        if let Some(v) = self.pretrained_model_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.completed_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if !self.description.is_empty() {
            os.write_string(11, &self.description)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(13, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(14, &self.user_id)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if !self.license.is_empty() {
            os.write_string(17, &self.license)?;
        }
        if let Some(v) = self.output_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.input_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.train_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.import_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if !self.train_log.is_empty() {
            os.write_string(23, &self.train_log)?;
        }
        if let Some(v) = self.inference_compute_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.build_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersion {
        ModelVersion::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.status.clear();
        self.active_concept_count = 0;
        self.metrics.clear();
        self.total_input_count = 0;
        self.pretrained_model_config.clear();
        self.completed_at.clear();
        self.description.clear();
        self.visibility.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.modified_at.clear();
        self.metadata.clear();
        self.license.clear();
        self.output_info.clear();
        self.input_info.clear();
        self.train_info.clear();
        self.import_info.clear();
        self.train_log.clear();
        self.inference_compute_info.clear();
        self.build_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersion {
        static instance: ModelVersion = ModelVersion {
            id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            active_concept_count: 0,
            metrics: ::protobuf::MessageField::none(),
            total_input_count: 0,
            pretrained_model_config: ::protobuf::MessageField::none(),
            completed_at: ::protobuf::MessageField::none(),
            description: ::std::string::String::new(),
            visibility: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            modified_at: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            license: ::std::string::String::new(),
            output_info: ::protobuf::MessageField::none(),
            input_info: ::protobuf::MessageField::none(),
            train_info: ::protobuf::MessageField::none(),
            import_info: ::protobuf::MessageField::none(),
            train_log: ::std::string::String::new(),
            inference_compute_info: ::protobuf::MessageField::none(),
            build_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.BuildInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BuildInfo {
    // message fields
    ///  Docker image name
    // @@protoc_insertion_point(field:clarifai.api.BuildInfo.docker_image_name)
    pub docker_image_name: ::std::string::String,
    ///  Docker image tag
    // @@protoc_insertion_point(field:clarifai.api.BuildInfo.docker_image_tag)
    pub docker_image_tag: ::std::string::String,
    ///  Docker image digest
    // @@protoc_insertion_point(field:clarifai.api.BuildInfo.docker_image_digest)
    pub docker_image_digest: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.BuildInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildInfo {
    fn default() -> &'a BuildInfo {
        <BuildInfo as ::protobuf::Message>::default_instance()
    }
}

impl BuildInfo {
    pub fn new() -> BuildInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "docker_image_name",
            |m: &BuildInfo| { &m.docker_image_name },
            |m: &mut BuildInfo| { &mut m.docker_image_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "docker_image_tag",
            |m: &BuildInfo| { &m.docker_image_tag },
            |m: &mut BuildInfo| { &mut m.docker_image_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "docker_image_digest",
            |m: &BuildInfo| { &m.docker_image_digest },
            |m: &mut BuildInfo| { &mut m.docker_image_digest },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildInfo>(
            "BuildInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildInfo {
    const NAME: &'static str = "BuildInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.docker_image_name = is.read_string()?;
                },
                18 => {
                    self.docker_image_tag = is.read_string()?;
                },
                26 => {
                    self.docker_image_digest = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.docker_image_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.docker_image_name);
        }
        if !self.docker_image_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.docker_image_tag);
        }
        if !self.docker_image_digest.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.docker_image_digest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.docker_image_name.is_empty() {
            os.write_string(1, &self.docker_image_name)?;
        }
        if !self.docker_image_tag.is_empty() {
            os.write_string(2, &self.docker_image_tag)?;
        }
        if !self.docker_image_digest.is_empty() {
            os.write_string(3, &self.docker_image_digest)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildInfo {
        BuildInfo::new()
    }

    fn clear(&mut self) {
        self.docker_image_name.clear();
        self.docker_image_tag.clear();
        self.docker_image_digest.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildInfo {
        static instance: BuildInfo = BuildInfo {
            docker_image_name: ::std::string::String::new(),
            docker_image_tag: ::std::string::String::new(),
            docker_image_digest: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersionExport contains metadata for a single Model version export.
// @@protoc_insertion_point(message:clarifai.api.ModelVersionExport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelVersionExport {
    // message fields
    ///  status is the current status of the dataset version export.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionExport.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  url is the URL from where the model version export can be downloaded.
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionExport.url)
    pub url: ::std::string::String,
    ///  size of model file
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionExport.size)
    pub size: i64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersionExport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersionExport {
    fn default() -> &'a ModelVersionExport {
        <ModelVersionExport as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionExport {
    pub fn new() -> ModelVersionExport {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ModelVersionExport| { &m.status },
            |m: &mut ModelVersionExport| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &ModelVersionExport| { &m.url },
            |m: &mut ModelVersionExport| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &ModelVersionExport| { &m.size },
            |m: &mut ModelVersionExport| { &mut m.size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersionExport>(
            "ModelVersionExport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersionExport {
    const NAME: &'static str = "ModelVersionExport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.url = is.read_string()?;
                },
                24 => {
                    self.size = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if self.size != 0 {
            os.write_int64(3, self.size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersionExport {
        ModelVersionExport::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.url.clear();
        self.size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersionExport {
        static instance: ModelVersionExport = ModelVersionExport {
            status: ::protobuf::MessageField::none(),
            url: ::std::string::String::new(),
            size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersionExport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersionExport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersionExport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionExport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PretrainedModelConfig
// @@protoc_insertion_point(message:clarifai.api.PretrainedModelConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PretrainedModelConfig {
    // message fields
    ///  This is the internal id of the pretrained model.
    ///  Map from the api.Data field names to the Triton config.pbtxt input.
    // @@protoc_insertion_point(field:clarifai.api.PretrainedModelConfig.input_fields_map)
    pub input_fields_map: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  Map from the api.Data field names to the Triton config.pbtxt output.
    // @@protoc_insertion_point(field:clarifai.api.PretrainedModelConfig.output_fields_map)
    pub output_fields_map: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  Url to a zipped up model in triton format with the following files and folders at the root:
    ///   config.pbtxt
    ///   version 1 folder that contains model files (onnx graph, torch script, python BE model, and etc.)
    // @@protoc_insertion_point(field:clarifai.api.PretrainedModelConfig.model_zip_url)
    pub model_zip_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PretrainedModelConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PretrainedModelConfig {
    fn default() -> &'a PretrainedModelConfig {
        <PretrainedModelConfig as ::protobuf::Message>::default_instance()
    }
}

impl PretrainedModelConfig {
    pub fn new() -> PretrainedModelConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "input_fields_map",
            |m: &PretrainedModelConfig| { &m.input_fields_map },
            |m: &mut PretrainedModelConfig| { &mut m.input_fields_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "output_fields_map",
            |m: &PretrainedModelConfig| { &m.output_fields_map },
            |m: &mut PretrainedModelConfig| { &mut m.output_fields_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_zip_url",
            |m: &PretrainedModelConfig| { &m.model_zip_url },
            |m: &mut PretrainedModelConfig| { &mut m.model_zip_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PretrainedModelConfig>(
            "PretrainedModelConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PretrainedModelConfig {
    const NAME: &'static str = "PretrainedModelConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input_fields_map)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_fields_map)?;
                },
                50 => {
                    self.model_zip_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_fields_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output_fields_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_zip_url.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model_zip_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input_fields_map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.output_fields_map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.model_zip_url.is_empty() {
            os.write_string(6, &self.model_zip_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PretrainedModelConfig {
        PretrainedModelConfig::new()
    }

    fn clear(&mut self) {
        self.input_fields_map.clear();
        self.output_fields_map.clear();
        self.model_zip_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PretrainedModelConfig {
        static instance: PretrainedModelConfig = PretrainedModelConfig {
            input_fields_map: ::protobuf::MessageField::none(),
            output_fields_map: ::protobuf::MessageField::none(),
            model_zip_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PretrainedModelConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PretrainedModelConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PretrainedModelConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PretrainedModelConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TrainStats
// @@protoc_insertion_point(message:clarifai.api.TrainStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrainStats {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.TrainStats.loss_curve)
    pub loss_curve: ::std::vec::Vec<LossCurveEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TrainStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainStats {
    fn default() -> &'a TrainStats {
        <TrainStats as ::protobuf::Message>::default_instance()
    }
}

impl TrainStats {
    pub fn new() -> TrainStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "loss_curve",
            |m: &TrainStats| { &m.loss_curve },
            |m: &mut TrainStats| { &mut m.loss_curve },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainStats>(
            "TrainStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrainStats {
    const NAME: &'static str = "TrainStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.loss_curve.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.loss_curve {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.loss_curve {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainStats {
        TrainStats::new()
    }

    fn clear(&mut self) {
        self.loss_curve.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainStats {
        static instance: TrainStats = TrainStats {
            loss_curve: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrainStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrainStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrainStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  LossCurveEntry
// @@protoc_insertion_point(message:clarifai.api.LossCurveEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LossCurveEntry {
    // message fields
    ///  current epoch
    // @@protoc_insertion_point(field:clarifai.api.LossCurveEntry.epoch)
    pub epoch: u32,
    ///  current global step
    // @@protoc_insertion_point(field:clarifai.api.LossCurveEntry.global_step)
    pub global_step: u32,
    ///  current cost
    ///  FIXME(rigel): this should be loss instead of cost.
    // @@protoc_insertion_point(field:clarifai.api.LossCurveEntry.cost)
    pub cost: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.LossCurveEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LossCurveEntry {
    fn default() -> &'a LossCurveEntry {
        <LossCurveEntry as ::protobuf::Message>::default_instance()
    }
}

impl LossCurveEntry {
    pub fn new() -> LossCurveEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch",
            |m: &LossCurveEntry| { &m.epoch },
            |m: &mut LossCurveEntry| { &mut m.epoch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "global_step",
            |m: &LossCurveEntry| { &m.global_step },
            |m: &mut LossCurveEntry| { &mut m.global_step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cost",
            |m: &LossCurveEntry| { &m.cost },
            |m: &mut LossCurveEntry| { &mut m.cost },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LossCurveEntry>(
            "LossCurveEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LossCurveEntry {
    const NAME: &'static str = "LossCurveEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.epoch = is.read_uint32()?;
                },
                16 => {
                    self.global_step = is.read_uint32()?;
                },
                29 => {
                    self.cost = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.epoch != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.epoch);
        }
        if self.global_step != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.global_step);
        }
        if self.cost != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.epoch != 0 {
            os.write_uint32(1, self.epoch)?;
        }
        if self.global_step != 0 {
            os.write_uint32(2, self.global_step)?;
        }
        if self.cost != 0. {
            os.write_float(3, self.cost)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LossCurveEntry {
        LossCurveEntry::new()
    }

    fn clear(&mut self) {
        self.epoch = 0;
        self.global_step = 0;
        self.cost = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LossCurveEntry {
        static instance: LossCurveEntry = LossCurveEntry {
            epoch: 0,
            global_step: 0,
            cost: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LossCurveEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LossCurveEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LossCurveEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LossCurveEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  LabelCount
// @@protoc_insertion_point(message:clarifai.api.LabelCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LabelCount {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.LabelCount.concept_name)
    pub concept_name: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.LabelCount.count)
    pub count: u32,
    // @@protoc_insertion_point(field:clarifai.api.LabelCount.concept)
    pub concept: ::protobuf::MessageField<Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.LabelCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelCount {
    fn default() -> &'a LabelCount {
        <LabelCount as ::protobuf::Message>::default_instance()
    }
}

impl LabelCount {
    pub fn new() -> LabelCount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_name",
            |m: &LabelCount| { &m.concept_name },
            |m: &mut LabelCount| { &mut m.concept_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &LabelCount| { &m.count },
            |m: &mut LabelCount| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Concept>(
            "concept",
            |m: &LabelCount| { &m.concept },
            |m: &mut LabelCount| { &mut m.concept },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelCount>(
            "LabelCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelCount {
    const NAME: &'static str = "LabelCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.concept_name = is.read_string()?;
                },
                16 => {
                    self.count = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.concept_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.concept_name);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.count);
        }
        if let Some(v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.concept_name.is_empty() {
            os.write_string(1, &self.concept_name)?;
        }
        if self.count != 0 {
            os.write_uint32(2, self.count)?;
        }
        if let Some(v) = self.concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelCount {
        LabelCount::new()
    }

    fn clear(&mut self) {
        self.concept_name.clear();
        self.count = 0;
        self.concept.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelCount {
        static instance: LabelCount = LabelCount {
            concept_name: ::std::string::String::new(),
            count: 0,
            concept: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  LabelDistribution
// @@protoc_insertion_point(message:clarifai.api.LabelDistribution)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LabelDistribution {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.LabelDistribution.positive_label_counts)
    pub positive_label_counts: ::std::vec::Vec<LabelCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.LabelDistribution.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelDistribution {
    fn default() -> &'a LabelDistribution {
        <LabelDistribution as ::protobuf::Message>::default_instance()
    }
}

impl LabelDistribution {
    pub fn new() -> LabelDistribution {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positive_label_counts",
            |m: &LabelDistribution| { &m.positive_label_counts },
            |m: &mut LabelDistribution| { &mut m.positive_label_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelDistribution>(
            "LabelDistribution",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelDistribution {
    const NAME: &'static str = "LabelDistribution";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.positive_label_counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.positive_label_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.positive_label_counts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelDistribution {
        LabelDistribution::new()
    }

    fn clear(&mut self) {
        self.positive_label_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelDistribution {
        static instance: LabelDistribution = LabelDistribution {
            positive_label_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelDistribution {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelDistribution").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelDistribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelDistribution {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  NOTE: this is inefficient, should just have the order of the rows/cols
// @@protoc_insertion_point(message:clarifai.api.CooccurrenceMatrixEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CooccurrenceMatrixEntry {
    // message fields
    ///  concept_id for the row
    // @@protoc_insertion_point(field:clarifai.api.CooccurrenceMatrixEntry.row)
    pub row: ::std::string::String,
    ///  concept_id for the col
    // @@protoc_insertion_point(field:clarifai.api.CooccurrenceMatrixEntry.col)
    pub col: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.CooccurrenceMatrixEntry.count)
    pub count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CooccurrenceMatrixEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CooccurrenceMatrixEntry {
    fn default() -> &'a CooccurrenceMatrixEntry {
        <CooccurrenceMatrixEntry as ::protobuf::Message>::default_instance()
    }
}

impl CooccurrenceMatrixEntry {
    pub fn new() -> CooccurrenceMatrixEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "row",
            |m: &CooccurrenceMatrixEntry| { &m.row },
            |m: &mut CooccurrenceMatrixEntry| { &mut m.row },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "col",
            |m: &CooccurrenceMatrixEntry| { &m.col },
            |m: &mut CooccurrenceMatrixEntry| { &mut m.col },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &CooccurrenceMatrixEntry| { &m.count },
            |m: &mut CooccurrenceMatrixEntry| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CooccurrenceMatrixEntry>(
            "CooccurrenceMatrixEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CooccurrenceMatrixEntry {
    const NAME: &'static str = "CooccurrenceMatrixEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.row = is.read_string()?;
                },
                18 => {
                    self.col = is.read_string()?;
                },
                24 => {
                    self.count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.row.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.row);
        }
        if !self.col.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.col);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.row.is_empty() {
            os.write_string(1, &self.row)?;
        }
        if !self.col.is_empty() {
            os.write_string(2, &self.col)?;
        }
        if self.count != 0 {
            os.write_uint32(3, self.count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CooccurrenceMatrixEntry {
        CooccurrenceMatrixEntry::new()
    }

    fn clear(&mut self) {
        self.row.clear();
        self.col.clear();
        self.count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CooccurrenceMatrixEntry {
        static instance: CooccurrenceMatrixEntry = CooccurrenceMatrixEntry {
            row: ::std::string::String::new(),
            col: ::std::string::String::new(),
            count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CooccurrenceMatrixEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CooccurrenceMatrixEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CooccurrenceMatrixEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CooccurrenceMatrixEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  CooccurrenceMatrix
// @@protoc_insertion_point(message:clarifai.api.CooccurrenceMatrix)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CooccurrenceMatrix {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CooccurrenceMatrix.matrix)
    pub matrix: ::std::vec::Vec<CooccurrenceMatrixEntry>,
    ///  These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix.
    // @@protoc_insertion_point(field:clarifai.api.CooccurrenceMatrix.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CooccurrenceMatrix.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CooccurrenceMatrix {
    fn default() -> &'a CooccurrenceMatrix {
        <CooccurrenceMatrix as ::protobuf::Message>::default_instance()
    }
}

impl CooccurrenceMatrix {
    pub fn new() -> CooccurrenceMatrix {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matrix",
            |m: &CooccurrenceMatrix| { &m.matrix },
            |m: &mut CooccurrenceMatrix| { &mut m.matrix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &CooccurrenceMatrix| { &m.concept_ids },
            |m: &mut CooccurrenceMatrix| { &mut m.concept_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CooccurrenceMatrix>(
            "CooccurrenceMatrix",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CooccurrenceMatrix {
    const NAME: &'static str = "CooccurrenceMatrix";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matrix.push(is.read_message()?);
                },
                18 => {
                    self.concept_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matrix {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matrix {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.concept_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CooccurrenceMatrix {
        CooccurrenceMatrix::new()
    }

    fn clear(&mut self) {
        self.matrix.clear();
        self.concept_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CooccurrenceMatrix {
        static instance: CooccurrenceMatrix = CooccurrenceMatrix {
            matrix: ::std::vec::Vec::new(),
            concept_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CooccurrenceMatrix {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CooccurrenceMatrix").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CooccurrenceMatrix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CooccurrenceMatrix {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConfusionMatrixEntry
// @@protoc_insertion_point(message:clarifai.api.ConfusionMatrixEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfusionMatrixEntry {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ConfusionMatrixEntry.predicted)
    pub predicted: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ConfusionMatrixEntry.actual)
    pub actual: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ConfusionMatrixEntry.value)
    pub value: f32,
    // @@protoc_insertion_point(field:clarifai.api.ConfusionMatrixEntry.predicted_concept)
    pub predicted_concept: ::protobuf::MessageField<Concept>,
    // @@protoc_insertion_point(field:clarifai.api.ConfusionMatrixEntry.actual_concept)
    pub actual_concept: ::protobuf::MessageField<Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConfusionMatrixEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfusionMatrixEntry {
    fn default() -> &'a ConfusionMatrixEntry {
        <ConfusionMatrixEntry as ::protobuf::Message>::default_instance()
    }
}

impl ConfusionMatrixEntry {
    pub fn new() -> ConfusionMatrixEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "predicted",
            |m: &ConfusionMatrixEntry| { &m.predicted },
            |m: &mut ConfusionMatrixEntry| { &mut m.predicted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "actual",
            |m: &ConfusionMatrixEntry| { &m.actual },
            |m: &mut ConfusionMatrixEntry| { &mut m.actual },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &ConfusionMatrixEntry| { &m.value },
            |m: &mut ConfusionMatrixEntry| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Concept>(
            "predicted_concept",
            |m: &ConfusionMatrixEntry| { &m.predicted_concept },
            |m: &mut ConfusionMatrixEntry| { &mut m.predicted_concept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Concept>(
            "actual_concept",
            |m: &ConfusionMatrixEntry| { &m.actual_concept },
            |m: &mut ConfusionMatrixEntry| { &mut m.actual_concept },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfusionMatrixEntry>(
            "ConfusionMatrixEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfusionMatrixEntry {
    const NAME: &'static str = "ConfusionMatrixEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.predicted = is.read_string()?;
                },
                18 => {
                    self.actual = is.read_string()?;
                },
                37 => {
                    self.value = is.read_float()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.predicted_concept)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.actual_concept)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.predicted.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.predicted);
        }
        if !self.actual.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actual);
        }
        if self.value != 0. {
            my_size += 1 + 4;
        }
        if let Some(v) = self.predicted_concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.actual_concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.predicted.is_empty() {
            os.write_string(1, &self.predicted)?;
        }
        if !self.actual.is_empty() {
            os.write_string(2, &self.actual)?;
        }
        if self.value != 0. {
            os.write_float(4, self.value)?;
        }
        if let Some(v) = self.predicted_concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.actual_concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfusionMatrixEntry {
        ConfusionMatrixEntry::new()
    }

    fn clear(&mut self) {
        self.predicted.clear();
        self.actual.clear();
        self.value = 0.;
        self.predicted_concept.clear();
        self.actual_concept.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfusionMatrixEntry {
        static instance: ConfusionMatrixEntry = ConfusionMatrixEntry {
            predicted: ::std::string::String::new(),
            actual: ::std::string::String::new(),
            value: 0.,
            predicted_concept: ::protobuf::MessageField::none(),
            actual_concept: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfusionMatrixEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfusionMatrixEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfusionMatrixEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfusionMatrixEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ConfusionMatrix
// @@protoc_insertion_point(message:clarifai.api.ConfusionMatrix)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfusionMatrix {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ConfusionMatrix.matrix)
    pub matrix: ::std::vec::Vec<ConfusionMatrixEntry>,
    ///  These concept_ids are ordered by the strength of the diagonal in the ConfusionMatrix.
    // @@protoc_insertion_point(field:clarifai.api.ConfusionMatrix.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConfusionMatrix.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfusionMatrix {
    fn default() -> &'a ConfusionMatrix {
        <ConfusionMatrix as ::protobuf::Message>::default_instance()
    }
}

impl ConfusionMatrix {
    pub fn new() -> ConfusionMatrix {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matrix",
            |m: &ConfusionMatrix| { &m.matrix },
            |m: &mut ConfusionMatrix| { &mut m.matrix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &ConfusionMatrix| { &m.concept_ids },
            |m: &mut ConfusionMatrix| { &mut m.concept_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfusionMatrix>(
            "ConfusionMatrix",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfusionMatrix {
    const NAME: &'static str = "ConfusionMatrix";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matrix.push(is.read_message()?);
                },
                18 => {
                    self.concept_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matrix {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matrix {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.concept_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfusionMatrix {
        ConfusionMatrix::new()
    }

    fn clear(&mut self) {
        self.matrix.clear();
        self.concept_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfusionMatrix {
        static instance: ConfusionMatrix = ConfusionMatrix {
            matrix: ::std::vec::Vec::new(),
            concept_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfusionMatrix {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfusionMatrix").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfusionMatrix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfusionMatrix {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ROC
// @@protoc_insertion_point(message:clarifai.api.ROC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ROC {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ROC.fpr)
    pub fpr: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:clarifai.api.ROC.tpr)
    pub tpr: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:clarifai.api.ROC.thresholds)
    pub thresholds: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:clarifai.api.ROC.fpr_per_image)
    pub fpr_per_image: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:clarifai.api.ROC.fpr_per_object)
    pub fpr_per_object: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ROC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ROC {
    fn default() -> &'a ROC {
        <ROC as ::protobuf::Message>::default_instance()
    }
}

impl ROC {
    pub fn new() -> ROC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fpr",
            |m: &ROC| { &m.fpr },
            |m: &mut ROC| { &mut m.fpr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tpr",
            |m: &ROC| { &m.tpr },
            |m: &mut ROC| { &mut m.tpr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "thresholds",
            |m: &ROC| { &m.thresholds },
            |m: &mut ROC| { &mut m.thresholds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fpr_per_image",
            |m: &ROC| { &m.fpr_per_image },
            |m: &mut ROC| { &mut m.fpr_per_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fpr_per_object",
            |m: &ROC| { &m.fpr_per_object },
            |m: &mut ROC| { &mut m.fpr_per_object },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ROC>(
            "ROC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ROC {
    const NAME: &'static str = "ROC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.fpr)?;
                },
                13 => {
                    self.fpr.push(is.read_float()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.tpr)?;
                },
                21 => {
                    self.tpr.push(is.read_float()?);
                },
                26 => {
                    is.read_repeated_packed_float_into(&mut self.thresholds)?;
                },
                29 => {
                    self.thresholds.push(is.read_float()?);
                },
                34 => {
                    is.read_repeated_packed_float_into(&mut self.fpr_per_image)?;
                },
                37 => {
                    self.fpr_per_image.push(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_float_into(&mut self.fpr_per_object)?;
                },
                45 => {
                    self.fpr_per_object.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.fpr.len() as u64;
        my_size += 5 * self.tpr.len() as u64;
        my_size += 5 * self.thresholds.len() as u64;
        my_size += 5 * self.fpr_per_image.len() as u64;
        my_size += 5 * self.fpr_per_object.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fpr {
            os.write_float(1, *v)?;
        };
        for v in &self.tpr {
            os.write_float(2, *v)?;
        };
        for v in &self.thresholds {
            os.write_float(3, *v)?;
        };
        for v in &self.fpr_per_image {
            os.write_float(4, *v)?;
        };
        for v in &self.fpr_per_object {
            os.write_float(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ROC {
        ROC::new()
    }

    fn clear(&mut self) {
        self.fpr.clear();
        self.tpr.clear();
        self.thresholds.clear();
        self.fpr_per_image.clear();
        self.fpr_per_object.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ROC {
        static instance: ROC = ROC {
            fpr: ::std::vec::Vec::new(),
            tpr: ::std::vec::Vec::new(),
            thresholds: ::std::vec::Vec::new(),
            fpr_per_image: ::std::vec::Vec::new(),
            fpr_per_object: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ROC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ROC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ROC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ROC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PrecisionRecallCurve
// @@protoc_insertion_point(message:clarifai.api.PrecisionRecallCurve)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrecisionRecallCurve {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PrecisionRecallCurve.recall)
    pub recall: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:clarifai.api.PrecisionRecallCurve.precision)
    pub precision: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:clarifai.api.PrecisionRecallCurve.thresholds)
    pub thresholds: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PrecisionRecallCurve.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrecisionRecallCurve {
    fn default() -> &'a PrecisionRecallCurve {
        <PrecisionRecallCurve as ::protobuf::Message>::default_instance()
    }
}

impl PrecisionRecallCurve {
    pub fn new() -> PrecisionRecallCurve {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "recall",
            |m: &PrecisionRecallCurve| { &m.recall },
            |m: &mut PrecisionRecallCurve| { &mut m.recall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "precision",
            |m: &PrecisionRecallCurve| { &m.precision },
            |m: &mut PrecisionRecallCurve| { &mut m.precision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "thresholds",
            |m: &PrecisionRecallCurve| { &m.thresholds },
            |m: &mut PrecisionRecallCurve| { &mut m.thresholds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrecisionRecallCurve>(
            "PrecisionRecallCurve",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrecisionRecallCurve {
    const NAME: &'static str = "PrecisionRecallCurve";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.recall)?;
                },
                13 => {
                    self.recall.push(is.read_float()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.precision)?;
                },
                21 => {
                    self.precision.push(is.read_float()?);
                },
                26 => {
                    is.read_repeated_packed_float_into(&mut self.thresholds)?;
                },
                29 => {
                    self.thresholds.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.recall.len() as u64;
        my_size += 5 * self.precision.len() as u64;
        my_size += 5 * self.thresholds.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.recall {
            os.write_float(1, *v)?;
        };
        for v in &self.precision {
            os.write_float(2, *v)?;
        };
        for v in &self.thresholds {
            os.write_float(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrecisionRecallCurve {
        PrecisionRecallCurve::new()
    }

    fn clear(&mut self) {
        self.recall.clear();
        self.precision.clear();
        self.thresholds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrecisionRecallCurve {
        static instance: PrecisionRecallCurve = PrecisionRecallCurve {
            recall: ::std::vec::Vec::new(),
            precision: ::std::vec::Vec::new(),
            thresholds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrecisionRecallCurve {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrecisionRecallCurve").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrecisionRecallCurve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrecisionRecallCurve {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  BinaryMetrics
// @@protoc_insertion_point(message:clarifai.api.BinaryMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryMetrics {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.num_pos)
    pub num_pos: u32,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.num_neg)
    pub num_neg: u32,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.num_tot)
    pub num_tot: u32,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.roc_auc)
    pub roc_auc: f32,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.f1)
    pub f1: f32,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.concept)
    pub concept: ::protobuf::MessageField<Concept>,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.roc_curve)
    pub roc_curve: ::protobuf::MessageField<ROC>,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.precision_recall_curve)
    pub precision_recall_curve: ::protobuf::MessageField<PrecisionRecallCurve>,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.avg_precision)
    pub avg_precision: f32,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.area_name)
    pub area_name: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.area_min)
    pub area_min: f64,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.area_max)
    pub area_max: f64,
    // @@protoc_insertion_point(field:clarifai.api.BinaryMetrics.iou)
    pub iou: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.BinaryMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BinaryMetrics {
    fn default() -> &'a BinaryMetrics {
        <BinaryMetrics as ::protobuf::Message>::default_instance()
    }
}

impl BinaryMetrics {
    pub fn new() -> BinaryMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_pos",
            |m: &BinaryMetrics| { &m.num_pos },
            |m: &mut BinaryMetrics| { &mut m.num_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_neg",
            |m: &BinaryMetrics| { &m.num_neg },
            |m: &mut BinaryMetrics| { &mut m.num_neg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_tot",
            |m: &BinaryMetrics| { &m.num_tot },
            |m: &mut BinaryMetrics| { &mut m.num_tot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "roc_auc",
            |m: &BinaryMetrics| { &m.roc_auc },
            |m: &mut BinaryMetrics| { &mut m.roc_auc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "f1",
            |m: &BinaryMetrics| { &m.f1 },
            |m: &mut BinaryMetrics| { &mut m.f1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Concept>(
            "concept",
            |m: &BinaryMetrics| { &m.concept },
            |m: &mut BinaryMetrics| { &mut m.concept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ROC>(
            "roc_curve",
            |m: &BinaryMetrics| { &m.roc_curve },
            |m: &mut BinaryMetrics| { &mut m.roc_curve },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PrecisionRecallCurve>(
            "precision_recall_curve",
            |m: &BinaryMetrics| { &m.precision_recall_curve },
            |m: &mut BinaryMetrics| { &mut m.precision_recall_curve },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avg_precision",
            |m: &BinaryMetrics| { &m.avg_precision },
            |m: &mut BinaryMetrics| { &mut m.avg_precision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_name",
            |m: &BinaryMetrics| { &m.area_name },
            |m: &mut BinaryMetrics| { &mut m.area_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_min",
            |m: &BinaryMetrics| { &m.area_min },
            |m: &mut BinaryMetrics| { &mut m.area_min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_max",
            |m: &BinaryMetrics| { &m.area_max },
            |m: &mut BinaryMetrics| { &mut m.area_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iou",
            |m: &BinaryMetrics| { &m.iou },
            |m: &mut BinaryMetrics| { &mut m.iou },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BinaryMetrics>(
            "BinaryMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BinaryMetrics {
    const NAME: &'static str = "BinaryMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_pos = is.read_uint32()?;
                },
                16 => {
                    self.num_neg = is.read_uint32()?;
                },
                24 => {
                    self.num_tot = is.read_uint32()?;
                },
                37 => {
                    self.roc_auc = is.read_float()?;
                },
                45 => {
                    self.f1 = is.read_float()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.roc_curve)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.precision_recall_curve)?;
                },
                77 => {
                    self.avg_precision = is.read_float()?;
                },
                82 => {
                    self.area_name = is.read_string()?;
                },
                89 => {
                    self.area_min = is.read_double()?;
                },
                97 => {
                    self.area_max = is.read_double()?;
                },
                109 => {
                    self.iou = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.num_pos != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.num_pos);
        }
        if self.num_neg != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.num_neg);
        }
        if self.num_tot != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.num_tot);
        }
        if self.roc_auc != 0. {
            my_size += 1 + 4;
        }
        if self.f1 != 0. {
            my_size += 1 + 4;
        }
        if let Some(v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.roc_curve.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.precision_recall_curve.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.avg_precision != 0. {
            my_size += 1 + 4;
        }
        if !self.area_name.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.area_name);
        }
        if self.area_min != 0. {
            my_size += 1 + 8;
        }
        if self.area_max != 0. {
            my_size += 1 + 8;
        }
        if self.iou != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.num_pos != 0 {
            os.write_uint32(1, self.num_pos)?;
        }
        if self.num_neg != 0 {
            os.write_uint32(2, self.num_neg)?;
        }
        if self.num_tot != 0 {
            os.write_uint32(3, self.num_tot)?;
        }
        if self.roc_auc != 0. {
            os.write_float(4, self.roc_auc)?;
        }
        if self.f1 != 0. {
            os.write_float(5, self.f1)?;
        }
        if let Some(v) = self.concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.roc_curve.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.precision_recall_curve.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.avg_precision != 0. {
            os.write_float(9, self.avg_precision)?;
        }
        if !self.area_name.is_empty() {
            os.write_string(10, &self.area_name)?;
        }
        if self.area_min != 0. {
            os.write_double(11, self.area_min)?;
        }
        if self.area_max != 0. {
            os.write_double(12, self.area_max)?;
        }
        if self.iou != 0. {
            os.write_float(13, self.iou)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BinaryMetrics {
        BinaryMetrics::new()
    }

    fn clear(&mut self) {
        self.num_pos = 0;
        self.num_neg = 0;
        self.num_tot = 0;
        self.roc_auc = 0.;
        self.f1 = 0.;
        self.concept.clear();
        self.roc_curve.clear();
        self.precision_recall_curve.clear();
        self.avg_precision = 0.;
        self.area_name.clear();
        self.area_min = 0.;
        self.area_max = 0.;
        self.iou = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BinaryMetrics {
        static instance: BinaryMetrics = BinaryMetrics {
            num_pos: 0,
            num_neg: 0,
            num_tot: 0,
            roc_auc: 0.,
            f1: 0.,
            concept: ::protobuf::MessageField::none(),
            roc_curve: ::protobuf::MessageField::none(),
            precision_recall_curve: ::protobuf::MessageField::none(),
            avg_precision: 0.,
            area_name: ::std::string::String::new(),
            area_min: 0.,
            area_max: 0.,
            iou: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BinaryMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BinaryMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BinaryMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TrackerMetrics
// @@protoc_insertion_point(message:clarifai.api.TrackerMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrackerMetrics {
    // message fields
    ///  Multiple object tracking accuracy
    // @@protoc_insertion_point(field:clarifai.api.TrackerMetrics.mot_mota)
    pub mot_mota: f32,
    ///  Number of switches between tracks
    // @@protoc_insertion_point(field:clarifai.api.TrackerMetrics.mot_num_switches)
    pub mot_num_switches: i32,
    ///  MORSE fragmentation rate (a.k.a unique switch rate, only calculated in public sector)
    // @@protoc_insertion_point(field:clarifai.api.TrackerMetrics.morse_frag)
    pub morse_frag: f32,
    ///  Average precision calculated from all processed frames
    // @@protoc_insertion_point(field:clarifai.api.TrackerMetrics.avg_precision)
    pub avg_precision: f32,
    ///  The concept that we are evaluating the tracker
    // @@protoc_insertion_point(field:clarifai.api.TrackerMetrics.aiid)
    pub aiid: ::std::string::String,
    ///  Same as morse_frag but calculated using MOT mapping/metrics
    // @@protoc_insertion_point(field:clarifai.api.TrackerMetrics.unique_switch_rate)
    pub unique_switch_rate: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TrackerMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrackerMetrics {
    fn default() -> &'a TrackerMetrics {
        <TrackerMetrics as ::protobuf::Message>::default_instance()
    }
}

impl TrackerMetrics {
    pub fn new() -> TrackerMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mot_mota",
            |m: &TrackerMetrics| { &m.mot_mota },
            |m: &mut TrackerMetrics| { &mut m.mot_mota },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mot_num_switches",
            |m: &TrackerMetrics| { &m.mot_num_switches },
            |m: &mut TrackerMetrics| { &mut m.mot_num_switches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "morse_frag",
            |m: &TrackerMetrics| { &m.morse_frag },
            |m: &mut TrackerMetrics| { &mut m.morse_frag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "avg_precision",
            |m: &TrackerMetrics| { &m.avg_precision },
            |m: &mut TrackerMetrics| { &mut m.avg_precision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aiid",
            |m: &TrackerMetrics| { &m.aiid },
            |m: &mut TrackerMetrics| { &mut m.aiid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_switch_rate",
            |m: &TrackerMetrics| { &m.unique_switch_rate },
            |m: &mut TrackerMetrics| { &mut m.unique_switch_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrackerMetrics>(
            "TrackerMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrackerMetrics {
    const NAME: &'static str = "TrackerMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.mot_mota = is.read_float()?;
                },
                16 => {
                    self.mot_num_switches = is.read_int32()?;
                },
                29 => {
                    self.morse_frag = is.read_float()?;
                },
                37 => {
                    self.avg_precision = is.read_float()?;
                },
                42 => {
                    self.aiid = is.read_string()?;
                },
                53 => {
                    self.unique_switch_rate = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mot_mota != 0. {
            my_size += 1 + 4;
        }
        if self.mot_num_switches != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.mot_num_switches);
        }
        if self.morse_frag != 0. {
            my_size += 1 + 4;
        }
        if self.avg_precision != 0. {
            my_size += 1 + 4;
        }
        if !self.aiid.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.aiid);
        }
        if self.unique_switch_rate != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mot_mota != 0. {
            os.write_float(1, self.mot_mota)?;
        }
        if self.mot_num_switches != 0 {
            os.write_int32(2, self.mot_num_switches)?;
        }
        if self.morse_frag != 0. {
            os.write_float(3, self.morse_frag)?;
        }
        if self.avg_precision != 0. {
            os.write_float(4, self.avg_precision)?;
        }
        if !self.aiid.is_empty() {
            os.write_string(5, &self.aiid)?;
        }
        if self.unique_switch_rate != 0. {
            os.write_float(6, self.unique_switch_rate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrackerMetrics {
        TrackerMetrics::new()
    }

    fn clear(&mut self) {
        self.mot_mota = 0.;
        self.mot_num_switches = 0;
        self.morse_frag = 0.;
        self.avg_precision = 0.;
        self.aiid.clear();
        self.unique_switch_rate = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrackerMetrics {
        static instance: TrackerMetrics = TrackerMetrics {
            mot_mota: 0.,
            mot_num_switches: 0,
            morse_frag: 0.,
            avg_precision: 0.,
            aiid: ::std::string::String::new(),
            unique_switch_rate: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrackerMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrackerMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrackerMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrackerMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  EvalTestSetEntry
// @@protoc_insertion_point(message:clarifai.api.EvalTestSetEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvalTestSetEntry {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.EvalTestSetEntry.input)
    pub input: ::protobuf::MessageField<Input>,
    // @@protoc_insertion_point(field:clarifai.api.EvalTestSetEntry.predicted_concepts)
    pub predicted_concepts: ::std::vec::Vec<Concept>,
    ///  All the ground truth concepts will be show on the top level
    // @@protoc_insertion_point(field:clarifai.api.EvalTestSetEntry.ground_truth_concepts)
    pub ground_truth_concepts: ::std::vec::Vec<Concept>,
    ///  Only region-based/frame-based app contains this annotation
    ///  Each annotation only contains one region
    ///  And the concepts is in ground_truth_concepts instead of this annotation
    // @@protoc_insertion_point(field:clarifai.api.EvalTestSetEntry.annotation)
    pub annotation: ::protobuf::MessageField<Annotation>,
    ///  For region based models, region and associated concepts are stored together.
    // @@protoc_insertion_point(field:clarifai.api.EvalTestSetEntry.predicted_annotation)
    pub predicted_annotation: ::protobuf::MessageField<Annotation>,
    // @@protoc_insertion_point(field:clarifai.api.EvalTestSetEntry.ground_truth_annotation)
    pub ground_truth_annotation: ::protobuf::MessageField<Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.EvalTestSetEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvalTestSetEntry {
    fn default() -> &'a EvalTestSetEntry {
        <EvalTestSetEntry as ::protobuf::Message>::default_instance()
    }
}

impl EvalTestSetEntry {
    pub fn new() -> EvalTestSetEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input",
            |m: &EvalTestSetEntry| { &m.input },
            |m: &mut EvalTestSetEntry| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "predicted_concepts",
            |m: &EvalTestSetEntry| { &m.predicted_concepts },
            |m: &mut EvalTestSetEntry| { &mut m.predicted_concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ground_truth_concepts",
            |m: &EvalTestSetEntry| { &m.ground_truth_concepts },
            |m: &mut EvalTestSetEntry| { &mut m.ground_truth_concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Annotation>(
            "annotation",
            |m: &EvalTestSetEntry| { &m.annotation },
            |m: &mut EvalTestSetEntry| { &mut m.annotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Annotation>(
            "predicted_annotation",
            |m: &EvalTestSetEntry| { &m.predicted_annotation },
            |m: &mut EvalTestSetEntry| { &mut m.predicted_annotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Annotation>(
            "ground_truth_annotation",
            |m: &EvalTestSetEntry| { &m.ground_truth_annotation },
            |m: &mut EvalTestSetEntry| { &mut m.ground_truth_annotation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvalTestSetEntry>(
            "EvalTestSetEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvalTestSetEntry {
    const NAME: &'static str = "EvalTestSetEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                26 => {
                    self.predicted_concepts.push(is.read_message()?);
                },
                34 => {
                    self.ground_truth_concepts.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.predicted_annotation)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ground_truth_annotation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.predicted_concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ground_truth_concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.predicted_annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ground_truth_annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.predicted_concepts {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.ground_truth_concepts {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.predicted_annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.ground_truth_annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvalTestSetEntry {
        EvalTestSetEntry::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.predicted_concepts.clear();
        self.ground_truth_concepts.clear();
        self.annotation.clear();
        self.predicted_annotation.clear();
        self.ground_truth_annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvalTestSetEntry {
        static instance: EvalTestSetEntry = EvalTestSetEntry {
            input: ::protobuf::MessageField::none(),
            predicted_concepts: ::std::vec::Vec::new(),
            ground_truth_concepts: ::std::vec::Vec::new(),
            annotation: ::protobuf::MessageField::none(),
            predicted_annotation: ::protobuf::MessageField::none(),
            ground_truth_annotation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvalTestSetEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvalTestSetEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvalTestSetEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvalTestSetEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  LOPQEvalResult
// @@protoc_insertion_point(message:clarifai.api.LOPQEvalResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LOPQEvalResult {
    // message fields
    ///  Rank k for which all metrics are reported.
    // @@protoc_insertion_point(field:clarifai.api.LOPQEvalResult.k)
    pub k: i32,
    ///  Recall @ k assuming the brute force search is the ground truth.
    // @@protoc_insertion_point(field:clarifai.api.LOPQEvalResult.recall_vs_brute_force)
    pub recall_vs_brute_force: f32,
    ///  Kendall's tau correlation @ k assuming the brute force search is the ground truth.
    // @@protoc_insertion_point(field:clarifai.api.LOPQEvalResult.kendall_tau_vs_brute_force)
    pub kendall_tau_vs_brute_force: f32,
    ///  The percentage of the most frequent code in the indexed part of evaluation data.
    // @@protoc_insertion_point(field:clarifai.api.LOPQEvalResult.most_frequent_code_percent)
    pub most_frequent_code_percent: f32,
    ///  Normalized Discounted Cumulative Gain (NDCG) @ k with a ground truth inferred from annotations
    ///  and/or prediction for this evaluation LOPQ model.
    ///  NDCG uses individual relevance scores of each returned image to evaluate the usefulness, or
    ///  gain, of a document based on its position in the result list. The premise of DCG is that
    ///  highly relevant documents appearing lower in a search result list should be penalized as the
    ///  graded relevance value is reduced logarithmically proportional to the position of the result.
    ///  See: https://en.wikipedia.org/wiki/Information_retrieval#Discounted_cumulative_gain
    ///
    ///  To compute the relevance score between two images we consider two cases:
    ///  1) Only one label for each image
    ///  An image is relevant to an image query iff they are labeled the same (score 1), and
    ///  not relevant otherwise (score 0)
    ///  2) Multiple labels for each image
    ///  Here an image relevancy with respect to a single image query is measured by f-beta score
    ///  assuming the query image list of labels as ground truth and comparing them with that of
    ///  the search result. These labels can come from image annotations or if substitute_annotation_misses
    ///  is set, predictions of base classifier where any prediction with prob < prob_threshold are
    ///  discarded. To quantify the relevancy score of a single search result we opt to compute precision
    ///  and recall @ k for simplicity, and combine them with f-beta score to obtain a single number.
    // @@protoc_insertion_point(field:clarifai.api.LOPQEvalResult.lopq_ndcg)
    pub lopq_ndcg: f32,
    ///  Brute force NDCG which gives a baseline to compare to and is a measure of how good
    ///  the embeddings are.
    // @@protoc_insertion_point(field:clarifai.api.LOPQEvalResult.brute_force_ndcg)
    pub brute_force_ndcg: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.LOPQEvalResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LOPQEvalResult {
    fn default() -> &'a LOPQEvalResult {
        <LOPQEvalResult as ::protobuf::Message>::default_instance()
    }
}

impl LOPQEvalResult {
    pub fn new() -> LOPQEvalResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "k",
            |m: &LOPQEvalResult| { &m.k },
            |m: &mut LOPQEvalResult| { &mut m.k },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recall_vs_brute_force",
            |m: &LOPQEvalResult| { &m.recall_vs_brute_force },
            |m: &mut LOPQEvalResult| { &mut m.recall_vs_brute_force },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "kendall_tau_vs_brute_force",
            |m: &LOPQEvalResult| { &m.kendall_tau_vs_brute_force },
            |m: &mut LOPQEvalResult| { &mut m.kendall_tau_vs_brute_force },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "most_frequent_code_percent",
            |m: &LOPQEvalResult| { &m.most_frequent_code_percent },
            |m: &mut LOPQEvalResult| { &mut m.most_frequent_code_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lopq_ndcg",
            |m: &LOPQEvalResult| { &m.lopq_ndcg },
            |m: &mut LOPQEvalResult| { &mut m.lopq_ndcg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brute_force_ndcg",
            |m: &LOPQEvalResult| { &m.brute_force_ndcg },
            |m: &mut LOPQEvalResult| { &mut m.brute_force_ndcg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LOPQEvalResult>(
            "LOPQEvalResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LOPQEvalResult {
    const NAME: &'static str = "LOPQEvalResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.k = is.read_int32()?;
                },
                21 => {
                    self.recall_vs_brute_force = is.read_float()?;
                },
                29 => {
                    self.kendall_tau_vs_brute_force = is.read_float()?;
                },
                37 => {
                    self.most_frequent_code_percent = is.read_float()?;
                },
                45 => {
                    self.lopq_ndcg = is.read_float()?;
                },
                53 => {
                    self.brute_force_ndcg = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.k != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.k);
        }
        if self.recall_vs_brute_force != 0. {
            my_size += 1 + 4;
        }
        if self.kendall_tau_vs_brute_force != 0. {
            my_size += 1 + 4;
        }
        if self.most_frequent_code_percent != 0. {
            my_size += 1 + 4;
        }
        if self.lopq_ndcg != 0. {
            my_size += 1 + 4;
        }
        if self.brute_force_ndcg != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.k != 0 {
            os.write_int32(1, self.k)?;
        }
        if self.recall_vs_brute_force != 0. {
            os.write_float(2, self.recall_vs_brute_force)?;
        }
        if self.kendall_tau_vs_brute_force != 0. {
            os.write_float(3, self.kendall_tau_vs_brute_force)?;
        }
        if self.most_frequent_code_percent != 0. {
            os.write_float(4, self.most_frequent_code_percent)?;
        }
        if self.lopq_ndcg != 0. {
            os.write_float(5, self.lopq_ndcg)?;
        }
        if self.brute_force_ndcg != 0. {
            os.write_float(6, self.brute_force_ndcg)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LOPQEvalResult {
        LOPQEvalResult::new()
    }

    fn clear(&mut self) {
        self.k = 0;
        self.recall_vs_brute_force = 0.;
        self.kendall_tau_vs_brute_force = 0.;
        self.most_frequent_code_percent = 0.;
        self.lopq_ndcg = 0.;
        self.brute_force_ndcg = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LOPQEvalResult {
        static instance: LOPQEvalResult = LOPQEvalResult {
            k: 0,
            recall_vs_brute_force: 0.,
            kendall_tau_vs_brute_force: 0.,
            most_frequent_code_percent: 0.,
            lopq_ndcg: 0.,
            brute_force_ndcg: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LOPQEvalResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LOPQEvalResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LOPQEvalResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LOPQEvalResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MetricsSummary
// @@protoc_insertion_point(message:clarifai.api.MetricsSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MetricsSummary {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.top1_accuracy)
    pub top1_accuracy: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.top5_accuracy)
    pub top5_accuracy: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.macro_avg_roc_auc)
    pub macro_avg_roc_auc: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.macro_std_roc_auc)
    pub macro_std_roc_auc: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.macro_avg_f1_score)
    pub macro_avg_f1_score: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.macro_std_f1_score)
    pub macro_std_f1_score: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.macro_avg_precision)
    pub macro_avg_precision: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.macro_avg_recall)
    pub macro_avg_recall: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.mean_avg_precision_iou_50)
    pub mean_avg_precision_iou_50: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.mean_avg_precision_iou_range)
    pub mean_avg_precision_iou_range: f32,
    // @@protoc_insertion_point(field:clarifai.api.MetricsSummary.lopq_metrics)
    pub lopq_metrics: ::std::vec::Vec<LOPQEvalResult>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MetricsSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetricsSummary {
    fn default() -> &'a MetricsSummary {
        <MetricsSummary as ::protobuf::Message>::default_instance()
    }
}

impl MetricsSummary {
    pub fn new() -> MetricsSummary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "top1_accuracy",
            |m: &MetricsSummary| { &m.top1_accuracy },
            |m: &mut MetricsSummary| { &mut m.top1_accuracy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "top5_accuracy",
            |m: &MetricsSummary| { &m.top5_accuracy },
            |m: &mut MetricsSummary| { &mut m.top5_accuracy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "macro_avg_roc_auc",
            |m: &MetricsSummary| { &m.macro_avg_roc_auc },
            |m: &mut MetricsSummary| { &mut m.macro_avg_roc_auc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "macro_std_roc_auc",
            |m: &MetricsSummary| { &m.macro_std_roc_auc },
            |m: &mut MetricsSummary| { &mut m.macro_std_roc_auc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "macro_avg_f1_score",
            |m: &MetricsSummary| { &m.macro_avg_f1_score },
            |m: &mut MetricsSummary| { &mut m.macro_avg_f1_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "macro_std_f1_score",
            |m: &MetricsSummary| { &m.macro_std_f1_score },
            |m: &mut MetricsSummary| { &mut m.macro_std_f1_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "macro_avg_precision",
            |m: &MetricsSummary| { &m.macro_avg_precision },
            |m: &mut MetricsSummary| { &mut m.macro_avg_precision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "macro_avg_recall",
            |m: &MetricsSummary| { &m.macro_avg_recall },
            |m: &mut MetricsSummary| { &mut m.macro_avg_recall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mean_avg_precision_iou_50",
            |m: &MetricsSummary| { &m.mean_avg_precision_iou_50 },
            |m: &mut MetricsSummary| { &mut m.mean_avg_precision_iou_50 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mean_avg_precision_iou_range",
            |m: &MetricsSummary| { &m.mean_avg_precision_iou_range },
            |m: &mut MetricsSummary| { &mut m.mean_avg_precision_iou_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lopq_metrics",
            |m: &MetricsSummary| { &m.lopq_metrics },
            |m: &mut MetricsSummary| { &mut m.lopq_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricsSummary>(
            "MetricsSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetricsSummary {
    const NAME: &'static str = "MetricsSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.top1_accuracy = is.read_float()?;
                },
                21 => {
                    self.top5_accuracy = is.read_float()?;
                },
                29 => {
                    self.macro_avg_roc_auc = is.read_float()?;
                },
                37 => {
                    self.macro_std_roc_auc = is.read_float()?;
                },
                45 => {
                    self.macro_avg_f1_score = is.read_float()?;
                },
                53 => {
                    self.macro_std_f1_score = is.read_float()?;
                },
                61 => {
                    self.macro_avg_precision = is.read_float()?;
                },
                69 => {
                    self.macro_avg_recall = is.read_float()?;
                },
                85 => {
                    self.mean_avg_precision_iou_50 = is.read_float()?;
                },
                93 => {
                    self.mean_avg_precision_iou_range = is.read_float()?;
                },
                74 => {
                    self.lopq_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.top1_accuracy != 0. {
            my_size += 1 + 4;
        }
        if self.top5_accuracy != 0. {
            my_size += 1 + 4;
        }
        if self.macro_avg_roc_auc != 0. {
            my_size += 1 + 4;
        }
        if self.macro_std_roc_auc != 0. {
            my_size += 1 + 4;
        }
        if self.macro_avg_f1_score != 0. {
            my_size += 1 + 4;
        }
        if self.macro_std_f1_score != 0. {
            my_size += 1 + 4;
        }
        if self.macro_avg_precision != 0. {
            my_size += 1 + 4;
        }
        if self.macro_avg_recall != 0. {
            my_size += 1 + 4;
        }
        if self.mean_avg_precision_iou_50 != 0. {
            my_size += 1 + 4;
        }
        if self.mean_avg_precision_iou_range != 0. {
            my_size += 1 + 4;
        }
        for value in &self.lopq_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.top1_accuracy != 0. {
            os.write_float(1, self.top1_accuracy)?;
        }
        if self.top5_accuracy != 0. {
            os.write_float(2, self.top5_accuracy)?;
        }
        if self.macro_avg_roc_auc != 0. {
            os.write_float(3, self.macro_avg_roc_auc)?;
        }
        if self.macro_std_roc_auc != 0. {
            os.write_float(4, self.macro_std_roc_auc)?;
        }
        if self.macro_avg_f1_score != 0. {
            os.write_float(5, self.macro_avg_f1_score)?;
        }
        if self.macro_std_f1_score != 0. {
            os.write_float(6, self.macro_std_f1_score)?;
        }
        if self.macro_avg_precision != 0. {
            os.write_float(7, self.macro_avg_precision)?;
        }
        if self.macro_avg_recall != 0. {
            os.write_float(8, self.macro_avg_recall)?;
        }
        if self.mean_avg_precision_iou_50 != 0. {
            os.write_float(10, self.mean_avg_precision_iou_50)?;
        }
        if self.mean_avg_precision_iou_range != 0. {
            os.write_float(11, self.mean_avg_precision_iou_range)?;
        }
        for v in &self.lopq_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetricsSummary {
        MetricsSummary::new()
    }

    fn clear(&mut self) {
        self.top1_accuracy = 0.;
        self.top5_accuracy = 0.;
        self.macro_avg_roc_auc = 0.;
        self.macro_std_roc_auc = 0.;
        self.macro_avg_f1_score = 0.;
        self.macro_std_f1_score = 0.;
        self.macro_avg_precision = 0.;
        self.macro_avg_recall = 0.;
        self.mean_avg_precision_iou_50 = 0.;
        self.mean_avg_precision_iou_range = 0.;
        self.lopq_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetricsSummary {
        static instance: MetricsSummary = MetricsSummary {
            top1_accuracy: 0.,
            top5_accuracy: 0.,
            macro_avg_roc_auc: 0.,
            macro_std_roc_auc: 0.,
            macro_avg_f1_score: 0.,
            macro_std_f1_score: 0.,
            macro_avg_precision: 0.,
            macro_avg_recall: 0.,
            mean_avg_precision_iou_50: 0.,
            mean_avg_precision_iou_range: 0.,
            lopq_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetricsSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetricsSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetricsSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricsSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  EvalMetrics
// @@protoc_insertion_point(message:clarifai.api.EvalMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EvalMetrics {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  user id that owns this evaluation
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.user_id)
    pub user_id: ::std::string::String,
    ///  app id that owns this evaluation
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.app_id)
    pub app_id: ::std::string::String,
    ///  Id of this evaluation
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.id)
    pub id: ::std::string::String,
    ///  Model to evaluate
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.model)
    pub model: ::protobuf::MessageField<Model>,
    ///  The ground truth dataset
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.ground_truth_dataset)
    pub ground_truth_dataset: ::protobuf::MessageField<Dataset>,
    ///  The dataset with predictions
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.predictions_dataset)
    pub predictions_dataset: ::protobuf::MessageField<Dataset>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.summary)
    pub summary: ::protobuf::MessageField<MetricsSummary>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.confusion_matrix)
    pub confusion_matrix: ::protobuf::MessageField<ConfusionMatrix>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.cooccurrence_matrix)
    pub cooccurrence_matrix: ::protobuf::MessageField<CooccurrenceMatrix>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.label_counts)
    pub label_counts: ::protobuf::MessageField<LabelDistribution>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.binary_metrics)
    pub binary_metrics: ::std::vec::Vec<BinaryMetrics>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.test_set)
    pub test_set: ::std::vec::Vec<EvalTestSetEntry>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.metrics_by_area)
    pub metrics_by_area: ::std::vec::Vec<BinaryMetrics>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.metrics_by_class)
    pub metrics_by_class: ::std::vec::Vec<BinaryMetrics>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.tracker_metrics)
    pub tracker_metrics: ::std::vec::Vec<TrackerMetrics>,
    ///  Evaluation parameters to pass. Expected to match what
    ///  is defined in the model type for the respective model.
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.eval_info)
    pub eval_info: ::protobuf::MessageField<EvalInfo>,
    // @@protoc_insertion_point(field:clarifai.api.EvalMetrics.extended_metrics)
    pub extended_metrics: ::protobuf::MessageField<ExtendedMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.EvalMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EvalMetrics {
    fn default() -> &'a EvalMetrics {
        <EvalMetrics as ::protobuf::Message>::default_instance()
    }
}

impl EvalMetrics {
    pub fn new() -> EvalMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &EvalMetrics| { &m.status },
            |m: &mut EvalMetrics| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &EvalMetrics| { &m.user_id },
            |m: &mut EvalMetrics| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &EvalMetrics| { &m.app_id },
            |m: &mut EvalMetrics| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &EvalMetrics| { &m.id },
            |m: &mut EvalMetrics| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Model>(
            "model",
            |m: &EvalMetrics| { &m.model },
            |m: &mut EvalMetrics| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Dataset>(
            "ground_truth_dataset",
            |m: &EvalMetrics| { &m.ground_truth_dataset },
            |m: &mut EvalMetrics| { &mut m.ground_truth_dataset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Dataset>(
            "predictions_dataset",
            |m: &EvalMetrics| { &m.predictions_dataset },
            |m: &mut EvalMetrics| { &mut m.predictions_dataset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MetricsSummary>(
            "summary",
            |m: &EvalMetrics| { &m.summary },
            |m: &mut EvalMetrics| { &mut m.summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfusionMatrix>(
            "confusion_matrix",
            |m: &EvalMetrics| { &m.confusion_matrix },
            |m: &mut EvalMetrics| { &mut m.confusion_matrix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CooccurrenceMatrix>(
            "cooccurrence_matrix",
            |m: &EvalMetrics| { &m.cooccurrence_matrix },
            |m: &mut EvalMetrics| { &mut m.cooccurrence_matrix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LabelDistribution>(
            "label_counts",
            |m: &EvalMetrics| { &m.label_counts },
            |m: &mut EvalMetrics| { &mut m.label_counts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "binary_metrics",
            |m: &EvalMetrics| { &m.binary_metrics },
            |m: &mut EvalMetrics| { &mut m.binary_metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "test_set",
            |m: &EvalMetrics| { &m.test_set },
            |m: &mut EvalMetrics| { &mut m.test_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics_by_area",
            |m: &EvalMetrics| { &m.metrics_by_area },
            |m: &mut EvalMetrics| { &mut m.metrics_by_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics_by_class",
            |m: &EvalMetrics| { &m.metrics_by_class },
            |m: &mut EvalMetrics| { &mut m.metrics_by_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tracker_metrics",
            |m: &EvalMetrics| { &m.tracker_metrics },
            |m: &mut EvalMetrics| { &mut m.tracker_metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EvalInfo>(
            "eval_info",
            |m: &EvalMetrics| { &m.eval_info },
            |m: &mut EvalMetrics| { &mut m.eval_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExtendedMetrics>(
            "extended_metrics",
            |m: &EvalMetrics| { &m.extended_metrics },
            |m: &mut EvalMetrics| { &mut m.extended_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EvalMetrics>(
            "EvalMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EvalMetrics {
    const NAME: &'static str = "EvalMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                122 => {
                    self.user_id = is.read_string()?;
                },
                130 => {
                    self.app_id = is.read_string()?;
                },
                82 => {
                    self.id = is.read_string()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ground_truth_dataset)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.predictions_dataset)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.summary)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.confusion_matrix)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cooccurrence_matrix)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.label_counts)?;
                },
                50 => {
                    self.binary_metrics.push(is.read_message()?);
                },
                58 => {
                    self.test_set.push(is.read_message()?);
                },
                66 => {
                    self.metrics_by_area.push(is.read_message()?);
                },
                74 => {
                    self.metrics_by_class.push(is.read_message()?);
                },
                90 => {
                    self.tracker_metrics.push(is.read_message()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_info)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extended_metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.app_id);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.id);
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ground_truth_dataset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.predictions_dataset.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.confusion_matrix.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cooccurrence_matrix.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.label_counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.binary_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.test_set {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.metrics_by_area {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.metrics_by_class {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tracker_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.eval_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.extended_metrics.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(15, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(16, &self.app_id)?;
        }
        if !self.id.is_empty() {
            os.write_string(10, &self.id)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.ground_truth_dataset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.predictions_dataset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.confusion_matrix.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.cooccurrence_matrix.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.label_counts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.binary_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.test_set {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.metrics_by_area {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        for v in &self.metrics_by_class {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.tracker_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.eval_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.extended_metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EvalMetrics {
        EvalMetrics::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.user_id.clear();
        self.app_id.clear();
        self.id.clear();
        self.model.clear();
        self.ground_truth_dataset.clear();
        self.predictions_dataset.clear();
        self.summary.clear();
        self.confusion_matrix.clear();
        self.cooccurrence_matrix.clear();
        self.label_counts.clear();
        self.binary_metrics.clear();
        self.test_set.clear();
        self.metrics_by_area.clear();
        self.metrics_by_class.clear();
        self.tracker_metrics.clear();
        self.eval_info.clear();
        self.extended_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EvalMetrics {
        static instance: EvalMetrics = EvalMetrics {
            status: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            id: ::std::string::String::new(),
            model: ::protobuf::MessageField::none(),
            ground_truth_dataset: ::protobuf::MessageField::none(),
            predictions_dataset: ::protobuf::MessageField::none(),
            summary: ::protobuf::MessageField::none(),
            confusion_matrix: ::protobuf::MessageField::none(),
            cooccurrence_matrix: ::protobuf::MessageField::none(),
            label_counts: ::protobuf::MessageField::none(),
            binary_metrics: ::std::vec::Vec::new(),
            test_set: ::std::vec::Vec::new(),
            metrics_by_area: ::std::vec::Vec::new(),
            metrics_by_class: ::std::vec::Vec::new(),
            tracker_metrics: ::std::vec::Vec::new(),
            eval_info: ::protobuf::MessageField::none(),
            extended_metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EvalMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EvalMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EvalMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvalMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ExtendedMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExtendedMetrics {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ExtendedMetrics.user_metrics)
    pub user_metrics: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ExtendedMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtendedMetrics {
    fn default() -> &'a ExtendedMetrics {
        <ExtendedMetrics as ::protobuf::Message>::default_instance()
    }
}

impl ExtendedMetrics {
    pub fn new() -> ExtendedMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "user_metrics",
            |m: &ExtendedMetrics| { &m.user_metrics },
            |m: &mut ExtendedMetrics| { &mut m.user_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtendedMetrics>(
            "ExtendedMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExtendedMetrics {
    const NAME: &'static str = "ExtendedMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtendedMetrics {
        ExtendedMetrics::new()
    }

    fn clear(&mut self) {
        self.user_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtendedMetrics {
        static instance: ExtendedMetrics = ExtendedMetrics {
            user_metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExtendedMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtendedMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtendedMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendedMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  FieldsValue
// @@protoc_insertion_point(message:clarifai.api.FieldsValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldsValue {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.FieldsValue.confusion_matrix)
    pub confusion_matrix: bool,
    // @@protoc_insertion_point(field:clarifai.api.FieldsValue.cooccurrence_matrix)
    pub cooccurrence_matrix: bool,
    // @@protoc_insertion_point(field:clarifai.api.FieldsValue.label_counts)
    pub label_counts: bool,
    // @@protoc_insertion_point(field:clarifai.api.FieldsValue.binary_metrics)
    pub binary_metrics: bool,
    // @@protoc_insertion_point(field:clarifai.api.FieldsValue.test_set)
    pub test_set: bool,
    // @@protoc_insertion_point(field:clarifai.api.FieldsValue.metrics_by_area)
    pub metrics_by_area: bool,
    // @@protoc_insertion_point(field:clarifai.api.FieldsValue.metrics_by_class)
    pub metrics_by_class: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.FieldsValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldsValue {
    fn default() -> &'a FieldsValue {
        <FieldsValue as ::protobuf::Message>::default_instance()
    }
}

impl FieldsValue {
    pub fn new() -> FieldsValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "confusion_matrix",
            |m: &FieldsValue| { &m.confusion_matrix },
            |m: &mut FieldsValue| { &mut m.confusion_matrix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cooccurrence_matrix",
            |m: &FieldsValue| { &m.cooccurrence_matrix },
            |m: &mut FieldsValue| { &mut m.cooccurrence_matrix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label_counts",
            |m: &FieldsValue| { &m.label_counts },
            |m: &mut FieldsValue| { &mut m.label_counts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "binary_metrics",
            |m: &FieldsValue| { &m.binary_metrics },
            |m: &mut FieldsValue| { &mut m.binary_metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "test_set",
            |m: &FieldsValue| { &m.test_set },
            |m: &mut FieldsValue| { &mut m.test_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metrics_by_area",
            |m: &FieldsValue| { &m.metrics_by_area },
            |m: &mut FieldsValue| { &mut m.metrics_by_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metrics_by_class",
            |m: &FieldsValue| { &m.metrics_by_class },
            |m: &mut FieldsValue| { &mut m.metrics_by_class },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FieldsValue>(
            "FieldsValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FieldsValue {
    const NAME: &'static str = "FieldsValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.confusion_matrix = is.read_bool()?;
                },
                16 => {
                    self.cooccurrence_matrix = is.read_bool()?;
                },
                24 => {
                    self.label_counts = is.read_bool()?;
                },
                32 => {
                    self.binary_metrics = is.read_bool()?;
                },
                40 => {
                    self.test_set = is.read_bool()?;
                },
                48 => {
                    self.metrics_by_area = is.read_bool()?;
                },
                56 => {
                    self.metrics_by_class = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.confusion_matrix != false {
            my_size += 1 + 1;
        }
        if self.cooccurrence_matrix != false {
            my_size += 1 + 1;
        }
        if self.label_counts != false {
            my_size += 1 + 1;
        }
        if self.binary_metrics != false {
            my_size += 1 + 1;
        }
        if self.test_set != false {
            my_size += 1 + 1;
        }
        if self.metrics_by_area != false {
            my_size += 1 + 1;
        }
        if self.metrics_by_class != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.confusion_matrix != false {
            os.write_bool(1, self.confusion_matrix)?;
        }
        if self.cooccurrence_matrix != false {
            os.write_bool(2, self.cooccurrence_matrix)?;
        }
        if self.label_counts != false {
            os.write_bool(3, self.label_counts)?;
        }
        if self.binary_metrics != false {
            os.write_bool(4, self.binary_metrics)?;
        }
        if self.test_set != false {
            os.write_bool(5, self.test_set)?;
        }
        if self.metrics_by_area != false {
            os.write_bool(6, self.metrics_by_area)?;
        }
        if self.metrics_by_class != false {
            os.write_bool(7, self.metrics_by_class)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldsValue {
        FieldsValue::new()
    }

    fn clear(&mut self) {
        self.confusion_matrix = false;
        self.cooccurrence_matrix = false;
        self.label_counts = false;
        self.binary_metrics = false;
        self.test_set = false;
        self.metrics_by_area = false;
        self.metrics_by_class = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldsValue {
        static instance: FieldsValue = FieldsValue {
            confusion_matrix: false,
            cooccurrence_matrix: false,
            label_counts: false,
            binary_metrics: false,
            test_set: false,
            metrics_by_area: false,
            metrics_by_class: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FieldsValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldsValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldsValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldsValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Output
// @@protoc_insertion_point(message:clarifai.api.Output)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Output {
    // message fields
    ///  One of these outputs per Input
    // @@protoc_insertion_point(field:clarifai.api.Output.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.Output.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  When the object was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.Output.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The model that created this Output.
    // @@protoc_insertion_point(field:clarifai.api.Output.model)
    pub model: ::protobuf::MessageField<Model>,
    ///  The input that was passed to the model to create this Output. For example if we have an image
    ///  model then it will take as input here an Input object with Image filled in.
    // @@protoc_insertion_point(field:clarifai.api.Output.input)
    pub input: ::protobuf::MessageField<Input>,
    ///  The output data for this Output. For example if we have a concept model then the predicted
    ///  concepts will appear here.
    // @@protoc_insertion_point(field:clarifai.api.Output.data)
    pub data: ::protobuf::MessageField<Data>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Output.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Output {
    fn default() -> &'a Output {
        <Output as ::protobuf::Message>::default_instance()
    }
}

impl Output {
    pub fn new() -> Output {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Output| { &m.id },
            |m: &mut Output| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &Output| { &m.status },
            |m: &mut Output| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Output| { &m.created_at },
            |m: &mut Output| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Model>(
            "model",
            |m: &Output| { &m.model },
            |m: &mut Output| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input",
            |m: &Output| { &m.input },
            |m: &mut Output| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &Output| { &m.data },
            |m: &mut Output| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Output>(
            "Output",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Output {
    const NAME: &'static str = "Output";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Output {
        Output::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.status.clear();
        self.created_at.clear();
        self.model.clear();
        self.input.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Output {
        static instance: Output = Output {
            id: ::std::string::String::new(),
            status: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            model: ::protobuf::MessageField::none(),
            input: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Output {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Output").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Output {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Output {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ScopeDeps
// @@protoc_insertion_point(message:clarifai.api.ScopeDeps)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScopeDeps {
    // message fields
    ///  The scope
    // @@protoc_insertion_point(field:clarifai.api.ScopeDeps.scope)
    pub scope: ::std::string::String,
    ///  Other scopes that are required.
    // @@protoc_insertion_point(field:clarifai.api.ScopeDeps.depending_scopes)
    pub depending_scopes: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ScopeDeps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScopeDeps {
    fn default() -> &'a ScopeDeps {
        <ScopeDeps as ::protobuf::Message>::default_instance()
    }
}

impl ScopeDeps {
    pub fn new() -> ScopeDeps {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scope",
            |m: &ScopeDeps| { &m.scope },
            |m: &mut ScopeDeps| { &mut m.scope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "depending_scopes",
            |m: &ScopeDeps| { &m.depending_scopes },
            |m: &mut ScopeDeps| { &mut m.depending_scopes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScopeDeps>(
            "ScopeDeps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScopeDeps {
    const NAME: &'static str = "ScopeDeps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.scope = is.read_string()?;
                },
                18 => {
                    self.depending_scopes.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        for value in &self.depending_scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        for v in &self.depending_scopes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScopeDeps {
        ScopeDeps::new()
    }

    fn clear(&mut self) {
        self.scope.clear();
        self.depending_scopes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScopeDeps {
        static instance: ScopeDeps = ScopeDeps {
            scope: ::std::string::String::new(),
            depending_scopes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScopeDeps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScopeDeps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScopeDeps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopeDeps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  EndpointDeps
// @@protoc_insertion_point(message:clarifai.api.EndpointDeps)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EndpointDeps {
    // message fields
    ///  The fully qualified endpoint to
    // @@protoc_insertion_point(field:clarifai.api.EndpointDeps.endpoint)
    pub endpoint: ::std::string::String,
    ///  Other scopes that are required.
    // @@protoc_insertion_point(field:clarifai.api.EndpointDeps.depending_scopes)
    pub depending_scopes: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.EndpointDeps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndpointDeps {
    fn default() -> &'a EndpointDeps {
        <EndpointDeps as ::protobuf::Message>::default_instance()
    }
}

impl EndpointDeps {
    pub fn new() -> EndpointDeps {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "endpoint",
            |m: &EndpointDeps| { &m.endpoint },
            |m: &mut EndpointDeps| { &mut m.endpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "depending_scopes",
            |m: &EndpointDeps| { &m.depending_scopes },
            |m: &mut EndpointDeps| { &mut m.depending_scopes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EndpointDeps>(
            "EndpointDeps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EndpointDeps {
    const NAME: &'static str = "EndpointDeps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.endpoint = is.read_string()?;
                },
                18 => {
                    self.depending_scopes.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.endpoint);
        }
        for value in &self.depending_scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.endpoint.is_empty() {
            os.write_string(1, &self.endpoint)?;
        }
        for v in &self.depending_scopes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndpointDeps {
        EndpointDeps::new()
    }

    fn clear(&mut self) {
        self.endpoint.clear();
        self.depending_scopes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndpointDeps {
        static instance: EndpointDeps = EndpointDeps {
            endpoint: ::std::string::String::new(),
            depending_scopes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EndpointDeps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EndpointDeps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EndpointDeps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointDeps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Hit
// @@protoc_insertion_point(message:clarifai.api.Hit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Hit {
    // message fields
    ///  This is the score for the ranked Hit results of the search query. This score is a number
    ///  between 0.0 and 1.0 as it represents a confidence in the search Hit. For example, if you search
    ///  for "car" and get a close matching Hit, the score should be close to 1.0. If you get a score
    ///  of close to 0.0 that means it's very disimilar to your query, in this case NOT a "car". There
    ///  is a special intermediate score of 0.5 that means that the Hit is not really correlated with
    ///  your search query (ie. not similar or dissimlar to the query) which is a common occurrence
    ///  when using negate queries.
    ///  Note: some queries that are just filtering down your app of inputs may just return a score of
    ///  1.0 for all Hits.
    // @@protoc_insertion_point(field:clarifai.api.Hit.score)
    pub score: f32,
    ///  This is the matched input returned from the search query. This will contain information about
    ///  the Input such as the url, created_at time and trusted annotation information (for backwards
    ///  compatibility with apps that existed before Annotations were introduced.
    // @@protoc_insertion_point(field:clarifai.api.Hit.input)
    pub input: ::protobuf::MessageField<Input>,
    ///  We also provide back the specific matched annotation for the above input. We do this in order
    ///  to support more complex Annotation queries in the And message below. For example if we match
    ///  the search results to a region in your input, or a frame in a video input, this annotation
    ///  field will be that matched annotation info and the input will be the image/video that the user
    ///  originally added which contains those regions / frames.
    // @@protoc_insertion_point(field:clarifai.api.Hit.annotation)
    pub annotation: ::protobuf::MessageField<Annotation>,
    ///  The customer-facing id of the user who owns the app the asset came from.
    // @@protoc_insertion_point(field:clarifai.api.Hit.user_id)
    pub user_id: ::std::string::String,
    ///  The cfid of the app the asset came from.
    // @@protoc_insertion_point(field:clarifai.api.Hit.app_id)
    pub app_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Hit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Hit {
    fn default() -> &'a Hit {
        <Hit as ::protobuf::Message>::default_instance()
    }
}

impl Hit {
    pub fn new() -> Hit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score",
            |m: &Hit| { &m.score },
            |m: &mut Hit| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input",
            |m: &Hit| { &m.input },
            |m: &mut Hit| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Annotation>(
            "annotation",
            |m: &Hit| { &m.annotation },
            |m: &mut Hit| { &mut m.annotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Hit| { &m.user_id },
            |m: &mut Hit| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &Hit| { &m.app_id },
            |m: &mut Hit| { &mut m.app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Hit>(
            "Hit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Hit {
    const NAME: &'static str = "Hit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.score = is.read_float()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation)?;
                },
                34 => {
                    self.user_id = is.read_string()?;
                },
                42 => {
                    self.app_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.score != 0. {
            my_size += 1 + 4;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.app_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.score != 0. {
            os.write_float(1, self.score)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(4, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(5, &self.app_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Hit {
        Hit::new()
    }

    fn clear(&mut self) {
        self.score = 0.;
        self.input.clear();
        self.annotation.clear();
        self.user_id.clear();
        self.app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Hit {
        static instance: Hit = Hit {
            score: 0.,
            input: ::protobuf::MessageField::none(),
            annotation: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Hit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Hit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Hit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.HitCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HitCount {
    // message fields
    ///  The estimated total number of hits for the search query, not just the current page.
    // @@protoc_insertion_point(field:clarifai.api.HitCount.estimated_total)
    pub estimated_total: u64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.HitCount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HitCount {
    fn default() -> &'a HitCount {
        <HitCount as ::protobuf::Message>::default_instance()
    }
}

impl HitCount {
    pub fn new() -> HitCount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "estimated_total",
            |m: &HitCount| { &m.estimated_total },
            |m: &mut HitCount| { &mut m.estimated_total },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HitCount>(
            "HitCount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HitCount {
    const NAME: &'static str = "HitCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.estimated_total = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.estimated_total != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.estimated_total);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.estimated_total != 0 {
            os.write_uint64(1, self.estimated_total)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HitCount {
        HitCount::new()
    }

    fn clear(&mut self) {
        self.estimated_total = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HitCount {
        static instance: HitCount = HitCount {
            estimated_total: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HitCount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HitCount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HitCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HitCount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is the common building block of a query which is a sequence of And messages ANDed together.
///  Note that some fields are used too RANK results (affect the scores) and some are used to FILTER
///  results (unordered subset of your app's contents). In general, FILTER operations are more
///  efficient queries at scale and when combined with RANK operations can speed up search performance
///  as you effectively operate on a smaller sub-set of your entire app.
// @@protoc_insertion_point(message:clarifai.api.And)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct And {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.And.input)
    pub input: ::protobuf::MessageField<Input>,
    ///  RANK based predicted outputs from models such as custom trained models, pre-trained models,
    ///  etc. This is also where you enter the image url for a visual search because what we're asking
    ///  the system to do is find output embedding most visually similar to the provided input (that
    ///  input being in And.output.input.data.image.url for example). This will return the Hits
    ///  sorted by visual similarity (1.0 being very similar or exact match and 0.0 being very
    ///  dissimlar). For a search by Output concept, this means we're asking the system to rank
    ///  the Hits by confidence of our model's predicted Outputs. So for example if the model
    ///  predicts an image is 0.95 likely there is a "dog" present, that should related directly
    ///  to the score returned if you search for Output concept "dog" in your query. This provides
    ///  a natural ranking to search results based on confidence of predictions from the models and
    ///  is used when ANDing multiple of these types of RANK by Output queries together as well.
    ///
    ///  ########## Supported fields ##########
    ///   - data.clusters[].id
    ///   - data.concepts[].id
    ///   - data.concepts[].name
    ///   - data.concepts[].value
    ///   - input.data.image - empty image is required when searching by input ID
    ///   - input.data.image.base64[]
    ///   - input.data.image.url
    ///   - input.id
    // @@protoc_insertion_point(field:clarifai.api.And.output)
    pub output: ::protobuf::MessageField<Output>,
    ///  If True then this will flip the meaning of this part of the
    ///  query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
    // @@protoc_insertion_point(field:clarifai.api.And.negate)
    pub negate: bool,
    // @@protoc_insertion_point(field:clarifai.api.And.annotation)
    pub annotation: ::protobuf::MessageField<Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.And.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a And {
    fn default() -> &'a And {
        <And as ::protobuf::Message>::default_instance()
    }
}

impl And {
    pub fn new() -> And {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input",
            |m: &And| { &m.input },
            |m: &mut And| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Output>(
            "output",
            |m: &And| { &m.output },
            |m: &mut And| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "negate",
            |m: &And| { &m.negate },
            |m: &mut And| { &mut m.negate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Annotation>(
            "annotation",
            |m: &And| { &m.annotation },
            |m: &mut And| { &mut m.annotation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<And>(
            "And",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for And {
    const NAME: &'static str = "And";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output)?;
                },
                24 => {
                    self.negate = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.negate != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.output.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.negate != false {
            os.write_bool(3, self.negate)?;
        }
        if let Some(v) = self.annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> And {
        And::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.output.clear();
        self.negate = false;
        self.annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static And {
        static instance: And = And {
            input: ::protobuf::MessageField::none(),
            output: ::protobuf::MessageField::none(),
            negate: false,
            annotation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for And {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("And").unwrap()).clone()
    }
}

impl ::std::fmt::Display for And {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for And {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is the search query used in /searches, model training requests, bulk data exports, etc.
// @@protoc_insertion_point(message:clarifai.api.Query)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Query {
    // message fields
    ///  The query syntax is simply a list of And operatiosn that will be ANDed together to fetch
    ///  results which are returned to the user as Hit messages.
    ///
    ///  Deprecated: Only used by the deprecated PostSearches endpoint. Use filters
    ///  and ranks instead with PostInputsSearches or PostAnnotationsSearches.
    // @@protoc_insertion_point(field:clarifai.api.Query.ands)
    pub ands: ::std::vec::Vec<And>,
    ///  This allows the query to override any default language the app was setup in when doing Concept
    ///  based searches. This currently only affects public Models Output searches when those public
    ///  Models have translations for their Concepts.
    // @@protoc_insertion_point(field:clarifai.api.Query.language)
    pub language: ::std::string::String,
    ///  filters in this query
    ///  e.q. only fetch annotations that have certain metadata
    // @@protoc_insertion_point(field:clarifai.api.Query.filters)
    pub filters: ::std::vec::Vec<Filter>,
    ///  rankings in this query
    ///  e.g. visual search by a url
    // @@protoc_insertion_point(field:clarifai.api.Query.ranks)
    pub ranks: ::std::vec::Vec<Rank>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Query.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Query {
    fn default() -> &'a Query {
        <Query as ::protobuf::Message>::default_instance()
    }
}

impl Query {
    pub fn new() -> Query {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ands",
            |m: &Query| { &m.ands },
            |m: &mut Query| { &mut m.ands },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &Query| { &m.language },
            |m: &mut Query| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filters",
            |m: &Query| { &m.filters },
            |m: &mut Query| { &mut m.filters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ranks",
            |m: &Query| { &m.ranks },
            |m: &mut Query| { &mut m.ranks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Query>(
            "Query",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Query {
    const NAME: &'static str = "Query";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ands.push(is.read_message()?);
                },
                18 => {
                    self.language = is.read_string()?;
                },
                26 => {
                    self.filters.push(is.read_message()?);
                },
                34 => {
                    self.ranks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ands {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ranks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ands {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.language.is_empty() {
            os.write_string(2, &self.language)?;
        }
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.ranks {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Query {
        Query::new()
    }

    fn clear(&mut self) {
        self.ands.clear();
        self.language.clear();
        self.filters.clear();
        self.ranks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Query {
        static instance: Query = Query {
            ands: ::std::vec::Vec::new(),
            language: ::std::string::String::new(),
            filters: ::std::vec::Vec::new(),
            ranks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Query {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Query").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Query {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is the new Search object used in saved searches.
// @@protoc_insertion_point(message:clarifai.api.Search)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Search {
    // message fields
    ///  Search query.
    // @@protoc_insertion_point(field:clarifai.api.Search.query)
    pub query: ::protobuf::MessageField<Query>,
    ///  Customer facing, external ID for search to be saved. Provided by the user, e.g. "saved-search-1.
    ///  It is unique per application.
    // @@protoc_insertion_point(field:clarifai.api.Search.id)
    pub id: ::std::string::String,
    ///  Application that owns this saved search.
    // @@protoc_insertion_point(field:clarifai.api.Search.application_id)
    pub application_id: ::std::string::String,
    ///  Human readable display name of the saved search.
    // @@protoc_insertion_point(field:clarifai.api.Search.name)
    pub name: ::std::string::String,
    ///  "As of" timestamp, indicating a time in the past as of which we want to
    ///  retrieve the annotations satisfying the query.
    // @@protoc_insertion_point(field:clarifai.api.Search.as_of)
    pub as_of: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Git hash of the code that ran the filter.
    // @@protoc_insertion_point(field:clarifai.api.Search.git_hash)
    pub git_hash: ::std::string::String,
    ///  When the saved search was created.
    // @@protoc_insertion_point(field:clarifai.api.Search.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the saved search was updated.
    // @@protoc_insertion_point(field:clarifai.api.Search.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The search algorithm to be used.
    ///  Options are are 'nearest_neighbor', 'brute_force', and 'avg_concept_brute_force'
    ///  The last two perform a brute force search visual search instead of a more scalable distributed
    ///  nearest neighbor search and should be used by advanced users only.
    ///  If not specified we default to nearest neighbor
    // @@protoc_insertion_point(field:clarifai.api.Search.algorithm)
    pub algorithm: ::std::string::String,
    ///  If true, save this search, and exit without executing the search.
    ///  If false execute the query
    // @@protoc_insertion_point(field:clarifai.api.Search.save)
    pub save: bool,
    ///  Minimum value of confidence threshold score in result.
    ///  Defaults to 0.0 which means we won't do any thresholding as all probabilities will
    ///  likely be > 0.0.
    // @@protoc_insertion_point(field:clarifai.api.Search.min_value)
    pub min_value: f32,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.Search.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    // @@protoc_insertion_point(field:clarifai.api.Search.metric)
    pub metric: ::protobuf::EnumOrUnknown<search::Metric>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Search.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Search {
    fn default() -> &'a Search {
        <Search as ::protobuf::Message>::default_instance()
    }
}

impl Search {
    pub fn new() -> Search {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Query>(
            "query",
            |m: &Search| { &m.query },
            |m: &mut Search| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Search| { &m.id },
            |m: &mut Search| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "application_id",
            |m: &Search| { &m.application_id },
            |m: &mut Search| { &mut m.application_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Search| { &m.name },
            |m: &mut Search| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "as_of",
            |m: &Search| { &m.as_of },
            |m: &mut Search| { &mut m.as_of },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "git_hash",
            |m: &Search| { &m.git_hash },
            |m: &mut Search| { &mut m.git_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Search| { &m.created_at },
            |m: &mut Search| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Search| { &m.modified_at },
            |m: &mut Search| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "algorithm",
            |m: &Search| { &m.algorithm },
            |m: &mut Search| { &mut m.algorithm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "save",
            |m: &Search| { &m.save },
            |m: &mut Search| { &mut m.save },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_value",
            |m: &Search| { &m.min_value },
            |m: &mut Search| { &mut m.min_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &Search| { &m.visibility },
            |m: &mut Search| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metric",
            |m: &Search| { &m.metric },
            |m: &mut Search| { &mut m.metric },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Search>(
            "Search",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Search {
    const NAME: &'static str = "Search";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    self.application_id = is.read_string()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.as_of)?;
                },
                50 => {
                    self.git_hash = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                74 => {
                    self.algorithm = is.read_string()?;
                },
                80 => {
                    self.save = is.read_bool()?;
                },
                93 => {
                    self.min_value = is.read_float()?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                104 => {
                    self.metric = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if !self.application_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.application_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if let Some(v) = self.as_of.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.git_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.git_hash);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.algorithm.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.algorithm);
        }
        if self.save != false {
            my_size += 1 + 1;
        }
        if self.min_value != 0. {
            my_size += 1 + 4;
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.metric != ::protobuf::EnumOrUnknown::new(search::Metric::METRIC_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(13, self.metric.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if !self.application_id.is_empty() {
            os.write_string(3, &self.application_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if let Some(v) = self.as_of.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.git_hash.is_empty() {
            os.write_string(6, &self.git_hash)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if !self.algorithm.is_empty() {
            os.write_string(9, &self.algorithm)?;
        }
        if self.save != false {
            os.write_bool(10, self.save)?;
        }
        if self.min_value != 0. {
            os.write_float(11, self.min_value)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if self.metric != ::protobuf::EnumOrUnknown::new(search::Metric::METRIC_NOT_SET) {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&self.metric))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Search {
        Search::new()
    }

    fn clear(&mut self) {
        self.query.clear();
        self.id.clear();
        self.application_id.clear();
        self.name.clear();
        self.as_of.clear();
        self.git_hash.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.algorithm.clear();
        self.save = false;
        self.min_value = 0.;
        self.visibility.clear();
        self.metric = ::protobuf::EnumOrUnknown::new(search::Metric::METRIC_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Search {
        static instance: Search = Search {
            query: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            application_id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            as_of: ::protobuf::MessageField::none(),
            git_hash: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            algorithm: ::std::string::String::new(),
            save: false,
            min_value: 0.,
            visibility: ::protobuf::MessageField::none(),
            metric: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Search {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Search").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Search {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Search {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Search`
pub mod search {
    ///  Metric used for search. Can be EUCLIDEAN_DISTANCE (default) or COSINE_DISTANCE.
    ///  Currently only brute force search supports non-eudlicean metrics.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.Search.Metric)
    pub enum Metric {
        // @@protoc_insertion_point(enum_value:clarifai.api.Search.Metric.METRIC_NOT_SET)
        METRIC_NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.Search.Metric.EUCLIDEAN_DISTANCE)
        EUCLIDEAN_DISTANCE = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.Search.Metric.COSINE_DISTANCE)
        COSINE_DISTANCE = 2,
    }

    impl ::protobuf::Enum for Metric {
        const NAME: &'static str = "Metric";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Metric> {
            match value {
                0 => ::std::option::Option::Some(Metric::METRIC_NOT_SET),
                1 => ::std::option::Option::Some(Metric::EUCLIDEAN_DISTANCE),
                2 => ::std::option::Option::Some(Metric::COSINE_DISTANCE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Metric> {
            match str {
                "METRIC_NOT_SET" => ::std::option::Option::Some(Metric::METRIC_NOT_SET),
                "EUCLIDEAN_DISTANCE" => ::std::option::Option::Some(Metric::EUCLIDEAN_DISTANCE),
                "COSINE_DISTANCE" => ::std::option::Option::Some(Metric::COSINE_DISTANCE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Metric] = &[
            Metric::METRIC_NOT_SET,
            Metric::EUCLIDEAN_DISTANCE,
            Metric::COSINE_DISTANCE,
        ];
    }

    impl ::protobuf::EnumFull for Metric {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Search.Metric").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Metric {
        fn default() -> Self {
            Metric::METRIC_NOT_SET
        }
    }

    impl Metric {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Metric>("Search.Metric")
        }
    }
}

///  Filter
// @@protoc_insertion_point(message:clarifai.api.Filter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Filter {
    // message fields
    ///  If True then this will flip the meaning of this part of the
    ///  query. This allow for queries such as dog AND ! metadata=={"blah":"value"}
    // @@protoc_insertion_point(field:clarifai.api.Filter.negate)
    pub negate: bool,
    // @@protoc_insertion_point(field:clarifai.api.Filter.annotation)
    pub annotation: ::protobuf::MessageField<Annotation>,
    // @@protoc_insertion_point(field:clarifai.api.Filter.input)
    pub input: ::protobuf::MessageField<Input>,
    ///  Filter by annotation last updated time range.
    // @@protoc_insertion_point(field:clarifai.api.Filter.last_updated_time_range)
    pub last_updated_time_range: ::protobuf::MessageField<TimeRange>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Filter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Filter {
    fn default() -> &'a Filter {
        <Filter as ::protobuf::Message>::default_instance()
    }
}

impl Filter {
    pub fn new() -> Filter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "negate",
            |m: &Filter| { &m.negate },
            |m: &mut Filter| { &mut m.negate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Annotation>(
            "annotation",
            |m: &Filter| { &m.annotation },
            |m: &mut Filter| { &mut m.annotation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input",
            |m: &Filter| { &m.input },
            |m: &mut Filter| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TimeRange>(
            "last_updated_time_range",
            |m: &Filter| { &m.last_updated_time_range },
            |m: &mut Filter| { &mut m.last_updated_time_range },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Filter>(
            "Filter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Filter {
    const NAME: &'static str = "Filter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.negate = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_updated_time_range)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.negate != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_updated_time_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.negate != false {
            os.write_bool(3, self.negate)?;
        }
        if let Some(v) = self.annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.last_updated_time_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Filter {
        Filter::new()
    }

    fn clear(&mut self) {
        self.negate = false;
        self.annotation.clear();
        self.input.clear();
        self.last_updated_time_range.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Filter {
        static instance: Filter = Filter {
            negate: false,
            annotation: ::protobuf::MessageField::none(),
            input: ::protobuf::MessageField::none(),
            last_updated_time_range: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Filter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Filter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Filter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TimeRange
// @@protoc_insertion_point(message:clarifai.api.TimeRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TimeRange {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.TimeRange.start_time)
    pub start_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:clarifai.api.TimeRange.end_time)
    pub end_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TimeRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeRange {
    fn default() -> &'a TimeRange {
        <TimeRange as ::protobuf::Message>::default_instance()
    }
}

impl TimeRange {
    pub fn new() -> TimeRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "start_time",
            |m: &TimeRange| { &m.start_time },
            |m: &mut TimeRange| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "end_time",
            |m: &TimeRange| { &m.end_time },
            |m: &mut TimeRange| { &mut m.end_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeRange>(
            "TimeRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeRange {
    const NAME: &'static str = "TimeRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeRange {
        TimeRange::new()
    }

    fn clear(&mut self) {
        self.start_time.clear();
        self.end_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeRange {
        static instance: TimeRange = TimeRange {
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Rank
// @@protoc_insertion_point(message:clarifai.api.Rank)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rank {
    // message fields
    ///  If True then this will flip the meaning of this part of the
    ///  query. This allow for queries such as !dog
    // @@protoc_insertion_point(field:clarifai.api.Rank.negate)
    pub negate: bool,
    ///  RANK by annotation information.
    ///  ########## Supported fields ##########
    ///   - data.concepts[].id
    ///   - data.concepts[].name
    ///   - data.concepts[].value
    ///   - data.embeddings[].num_dimensions
    ///   - data.embeddings[].vector[]
    ///   - data.image.base64[]
    ///   - data.image.url
    ///   - data.text.raw
    ///   - input_id
    ///   - model_version_id
    // @@protoc_insertion_point(field:clarifai.api.Rank.annotation)
    pub annotation: ::protobuf::MessageField<Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Rank.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rank {
    fn default() -> &'a Rank {
        <Rank as ::protobuf::Message>::default_instance()
    }
}

impl Rank {
    pub fn new() -> Rank {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "negate",
            |m: &Rank| { &m.negate },
            |m: &mut Rank| { &mut m.negate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Annotation>(
            "annotation",
            |m: &Rank| { &m.annotation },
            |m: &mut Rank| { &mut m.annotation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rank>(
            "Rank",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rank {
    const NAME: &'static str = "Rank";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.negate = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.negate != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.negate != false {
            os.write_bool(3, self.negate)?;
        }
        if let Some(v) = self.annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rank {
        Rank::new()
    }

    fn clear(&mut self) {
        self.negate = false;
        self.annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rank {
        static instance: Rank = Rank {
            negate: false,
            annotation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rank {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rank").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rank {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rank {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  AnnotationSearchMetrics
// @@protoc_insertion_point(message:clarifai.api.AnnotationSearchMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AnnotationSearchMetrics {
    // message fields
    ///  The ground truth we are evaluating against
    // @@protoc_insertion_point(field:clarifai.api.AnnotationSearchMetrics.ground_truth)
    pub ground_truth: ::protobuf::MessageField<Search>,
    ///  The set we are evaluating
    // @@protoc_insertion_point(field:clarifai.api.AnnotationSearchMetrics.search_to_eval)
    pub search_to_eval: ::protobuf::MessageField<Search>,
    ///  The metric result
    // @@protoc_insertion_point(field:clarifai.api.AnnotationSearchMetrics.metrics)
    pub metrics: ::protobuf::MessageField<EvalMetrics>,
    ///  data is filled out with the concepts used for this evaluation
    // @@protoc_insertion_point(field:clarifai.api.AnnotationSearchMetrics.data)
    pub data: ::protobuf::MessageField<Data>,
    ///  active_concept_count is the number of concepts for this evaluation
    // @@protoc_insertion_point(field:clarifai.api.AnnotationSearchMetrics.active_concept_count)
    pub active_concept_count: u32,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.AnnotationSearchMetrics.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AnnotationSearchMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AnnotationSearchMetrics {
    fn default() -> &'a AnnotationSearchMetrics {
        <AnnotationSearchMetrics as ::protobuf::Message>::default_instance()
    }
}

impl AnnotationSearchMetrics {
    pub fn new() -> AnnotationSearchMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Search>(
            "ground_truth",
            |m: &AnnotationSearchMetrics| { &m.ground_truth },
            |m: &mut AnnotationSearchMetrics| { &mut m.ground_truth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Search>(
            "search_to_eval",
            |m: &AnnotationSearchMetrics| { &m.search_to_eval },
            |m: &mut AnnotationSearchMetrics| { &mut m.search_to_eval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EvalMetrics>(
            "metrics",
            |m: &AnnotationSearchMetrics| { &m.metrics },
            |m: &mut AnnotationSearchMetrics| { &mut m.metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &AnnotationSearchMetrics| { &m.data },
            |m: &mut AnnotationSearchMetrics| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_concept_count",
            |m: &AnnotationSearchMetrics| { &m.active_concept_count },
            |m: &mut AnnotationSearchMetrics| { &mut m.active_concept_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &AnnotationSearchMetrics| { &m.visibility },
            |m: &mut AnnotationSearchMetrics| { &mut m.visibility },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnnotationSearchMetrics>(
            "AnnotationSearchMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AnnotationSearchMetrics {
    const NAME: &'static str = "AnnotationSearchMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ground_truth)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search_to_eval)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                40 => {
                    self.active_concept_count = is.read_uint32()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ground_truth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.search_to_eval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.active_concept_count != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.active_concept_count);
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ground_truth.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.search_to_eval.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.active_concept_count != 0 {
            os.write_uint32(5, self.active_concept_count)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AnnotationSearchMetrics {
        AnnotationSearchMetrics::new()
    }

    fn clear(&mut self) {
        self.ground_truth.clear();
        self.search_to_eval.clear();
        self.metrics.clear();
        self.data.clear();
        self.active_concept_count = 0;
        self.visibility.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AnnotationSearchMetrics {
        static instance: AnnotationSearchMetrics = AnnotationSearchMetrics {
            ground_truth: ::protobuf::MessageField::none(),
            search_to_eval: ::protobuf::MessageField::none(),
            metrics: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            active_concept_count: 0,
            visibility: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AnnotationSearchMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AnnotationSearchMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AnnotationSearchMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotationSearchMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Text
// @@protoc_insertion_point(message:clarifai.api.Text)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Text {
    // message fields
    ///  This is a raw text string.
    // @@protoc_insertion_point(field:clarifai.api.Text.raw)
    pub raw: ::std::string::String,
    ///  Url to a text file
    // @@protoc_insertion_point(field:clarifai.api.Text.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.Text.allow_duplicate_url)
    pub allow_duplicate_url: bool,
    ///  The hosted field lists original text hosted in Clarifai storage. This field is currently used
    ///  only in response.
    // @@protoc_insertion_point(field:clarifai.api.Text.hosted)
    pub hosted: ::protobuf::MessageField<HostedURL>,
    ///  text info
    // @@protoc_insertion_point(field:clarifai.api.Text.text_info)
    pub text_info: ::protobuf::MessageField<TextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Text.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Text {
    fn default() -> &'a Text {
        <Text as ::protobuf::Message>::default_instance()
    }
}

impl Text {
    pub fn new() -> Text {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "raw",
            |m: &Text| { &m.raw },
            |m: &mut Text| { &mut m.raw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Text| { &m.url },
            |m: &mut Text| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_duplicate_url",
            |m: &Text| { &m.allow_duplicate_url },
            |m: &mut Text| { &mut m.allow_duplicate_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HostedURL>(
            "hosted",
            |m: &Text| { &m.hosted },
            |m: &mut Text| { &mut m.hosted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TextInfo>(
            "text_info",
            |m: &Text| { &m.text_info },
            |m: &mut Text| { &mut m.text_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Text>(
            "Text",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Text {
    const NAME: &'static str = "Text";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.raw = is.read_string()?;
                },
                18 => {
                    self.url = is.read_string()?;
                },
                24 => {
                    self.allow_duplicate_url = is.read_bool()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hosted)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.text_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.raw.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.raw);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if self.allow_duplicate_url != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hosted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.raw.is_empty() {
            os.write_string(1, &self.raw)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if self.allow_duplicate_url != false {
            os.write_bool(3, self.allow_duplicate_url)?;
        }
        if let Some(v) = self.hosted.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.text_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Text {
        Text::new()
    }

    fn clear(&mut self) {
        self.raw.clear();
        self.url.clear();
        self.allow_duplicate_url = false;
        self.hosted.clear();
        self.text_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Text {
        static instance: Text = Text {
            raw: ::std::string::String::new(),
            url: ::std::string::String::new(),
            allow_duplicate_url: false,
            hosted: ::protobuf::MessageField::none(),
            text_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Text {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Text").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Text {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Text {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.TextInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TextInfo {
    // message fields
    ///  count of characters in text
    // @@protoc_insertion_point(field:clarifai.api.TextInfo.char_count)
    pub char_count: i32,
    ///  text encoding
    // @@protoc_insertion_point(field:clarifai.api.TextInfo.encoding)
    pub encoding: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TextInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TextInfo {
    fn default() -> &'a TextInfo {
        <TextInfo as ::protobuf::Message>::default_instance()
    }
}

impl TextInfo {
    pub fn new() -> TextInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "char_count",
            |m: &TextInfo| { &m.char_count },
            |m: &mut TextInfo| { &mut m.char_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "encoding",
            |m: &TextInfo| { &m.encoding },
            |m: &mut TextInfo| { &mut m.encoding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextInfo>(
            "TextInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TextInfo {
    const NAME: &'static str = "TextInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.char_count = is.read_int32()?;
                },
                18 => {
                    self.encoding = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.char_count != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.char_count);
        }
        if !self.encoding.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.encoding);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.char_count != 0 {
            os.write_int32(1, self.char_count)?;
        }
        if !self.encoding.is_empty() {
            os.write_string(2, &self.encoding)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TextInfo {
        TextInfo::new()
    }

    fn clear(&mut self) {
        self.char_count = 0;
        self.encoding.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TextInfo {
        static instance: TextInfo = TextInfo {
            char_count: 0,
            encoding: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TextInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TextInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TextInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  User
// @@protoc_insertion_point(message:clarifai.api.User)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct User {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.User.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.User.primary_email)
    pub primary_email: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.User.first_name)
    pub first_name: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.User.last_name)
    pub last_name: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.User.company_name)
    pub company_name: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.User.job_title)
    pub job_title: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.User.job_role)
    pub job_role: ::std::string::String,
    ///  This specifies user intent when registering on clarifai
    // @@protoc_insertion_point(field:clarifai.api.User.intention)
    pub intention: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.User.bill_type)
    pub bill_type: ::std::string::String,
    ///  When the user was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.User.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:clarifai.api.User.date_gdpr_consent)
    pub date_gdpr_consent: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:clarifai.api.User.date_tos_consent)
    pub date_tos_consent: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:clarifai.api.User.date_marketing_consent)
    pub date_marketing_consent: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:clarifai.api.User.date_pii_consent)
    pub date_pii_consent: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.User.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // @@protoc_insertion_point(field:clarifai.api.User.email_addresses)
    pub email_addresses: ::std::vec::Vec<EmailAddress>,
    // @@protoc_insertion_point(field:clarifai.api.User.two_factor_auth_enabled)
    pub two_factor_auth_enabled: bool,
    // @@protoc_insertion_point(field:clarifai.api.User.teams_count)
    pub teams_count: u32,
    ///  Is starred by the requesting user (only showed on get/list requests)
    ///  Please use PostUserStars/DeleteUserStars endpoints to star/unstar an user
    // @@protoc_insertion_point(field:clarifai.api.User.is_starred)
    pub is_starred: bool,
    ///  How many users have starred the user (only showed on get/list requests)
    ///  Computed value, not editable
    // @@protoc_insertion_point(field:clarifai.api.User.star_count)
    pub star_count: i32,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.User.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  This is all the personal information of a user. GetUser/ListUsers will not return this
    ///  information unless the caller has the UserAccounts_Get scope on their key or is the user
    ///  themselves.
    // @@protoc_insertion_point(field:clarifai.api.User.user_detail)
    pub user_detail: ::protobuf::MessageField<UserDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.User.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a User {
    fn default() -> &'a User {
        <User as ::protobuf::Message>::default_instance()
    }
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &User| { &m.id },
            |m: &mut User| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "primary_email",
            |m: &User| { &m.primary_email },
            |m: &mut User| { &mut m.primary_email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "first_name",
            |m: &User| { &m.first_name },
            |m: &mut User| { &mut m.first_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_name",
            |m: &User| { &m.last_name },
            |m: &mut User| { &mut m.last_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "company_name",
            |m: &User| { &m.company_name },
            |m: &mut User| { &mut m.company_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "job_title",
            |m: &User| { &m.job_title },
            |m: &mut User| { &mut m.job_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "job_role",
            |m: &User| { &m.job_role },
            |m: &mut User| { &mut m.job_role },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intention",
            |m: &User| { &m.intention },
            |m: &mut User| { &mut m.intention },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bill_type",
            |m: &User| { &m.bill_type },
            |m: &mut User| { &mut m.bill_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &User| { &m.created_at },
            |m: &mut User| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "date_gdpr_consent",
            |m: &User| { &m.date_gdpr_consent },
            |m: &mut User| { &mut m.date_gdpr_consent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "date_tos_consent",
            |m: &User| { &m.date_tos_consent },
            |m: &mut User| { &mut m.date_tos_consent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "date_marketing_consent",
            |m: &User| { &m.date_marketing_consent },
            |m: &mut User| { &mut m.date_marketing_consent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "date_pii_consent",
            |m: &User| { &m.date_pii_consent },
            |m: &mut User| { &mut m.date_pii_consent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &User| { &m.metadata },
            |m: &mut User| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "email_addresses",
            |m: &User| { &m.email_addresses },
            |m: &mut User| { &mut m.email_addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "two_factor_auth_enabled",
            |m: &User| { &m.two_factor_auth_enabled },
            |m: &mut User| { &mut m.two_factor_auth_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "teams_count",
            |m: &User| { &m.teams_count },
            |m: &mut User| { &mut m.teams_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_starred",
            |m: &User| { &m.is_starred },
            |m: &mut User| { &mut m.is_starred },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "star_count",
            |m: &User| { &m.star_count },
            |m: &mut User| { &mut m.star_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &User| { &m.visibility },
            |m: &mut User| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserDetail>(
            "user_detail",
            |m: &User| { &m.user_detail },
            |m: &mut User| { &mut m.user_detail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<User>(
            "User",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for User {
    const NAME: &'static str = "User";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.primary_email = is.read_string()?;
                },
                26 => {
                    self.first_name = is.read_string()?;
                },
                34 => {
                    self.last_name = is.read_string()?;
                },
                42 => {
                    self.company_name = is.read_string()?;
                },
                154 => {
                    self.job_title = is.read_string()?;
                },
                162 => {
                    self.job_role = is.read_string()?;
                },
                194 => {
                    self.intention = is.read_string()?;
                },
                58 => {
                    self.bill_type = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date_gdpr_consent)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date_tos_consent)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date_marketing_consent)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date_pii_consent)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                98 => {
                    self.email_addresses.push(is.read_message()?);
                },
                120 => {
                    self.two_factor_auth_enabled = is.read_bool()?;
                },
                128 => {
                    self.teams_count = is.read_uint32()?;
                },
                168 => {
                    self.is_starred = is.read_bool()?;
                },
                176 => {
                    self.star_count = is.read_int32()?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_detail)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.primary_email.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.primary_email);
        }
        if !self.first_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.first_name);
        }
        if !self.last_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.last_name);
        }
        if !self.company_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.company_name);
        }
        if !self.job_title.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.job_title);
        }
        if !self.job_role.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.job_role);
        }
        if !self.intention.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.intention);
        }
        if !self.bill_type.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.bill_type);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.date_gdpr_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.date_tos_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.date_marketing_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.date_pii_consent.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.email_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.two_factor_auth_enabled != false {
            my_size += 1 + 1;
        }
        if self.teams_count != 0 {
            my_size += ::protobuf::rt::uint32_size(16, self.teams_count);
        }
        if self.is_starred != false {
            my_size += 2 + 1;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::int32_size(22, self.star_count);
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_detail.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.primary_email.is_empty() {
            os.write_string(2, &self.primary_email)?;
        }
        if !self.first_name.is_empty() {
            os.write_string(3, &self.first_name)?;
        }
        if !self.last_name.is_empty() {
            os.write_string(4, &self.last_name)?;
        }
        if !self.company_name.is_empty() {
            os.write_string(5, &self.company_name)?;
        }
        if !self.job_title.is_empty() {
            os.write_string(19, &self.job_title)?;
        }
        if !self.job_role.is_empty() {
            os.write_string(20, &self.job_role)?;
        }
        if !self.intention.is_empty() {
            os.write_string(24, &self.intention)?;
        }
        if !self.bill_type.is_empty() {
            os.write_string(7, &self.bill_type)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.date_gdpr_consent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.date_tos_consent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.date_marketing_consent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.date_pii_consent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        for v in &self.email_addresses {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if self.two_factor_auth_enabled != false {
            os.write_bool(15, self.two_factor_auth_enabled)?;
        }
        if self.teams_count != 0 {
            os.write_uint32(16, self.teams_count)?;
        }
        if self.is_starred != false {
            os.write_bool(21, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(22, self.star_count)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.user_detail.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> User {
        User::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.primary_email.clear();
        self.first_name.clear();
        self.last_name.clear();
        self.company_name.clear();
        self.job_title.clear();
        self.job_role.clear();
        self.intention.clear();
        self.bill_type.clear();
        self.created_at.clear();
        self.date_gdpr_consent.clear();
        self.date_tos_consent.clear();
        self.date_marketing_consent.clear();
        self.date_pii_consent.clear();
        self.metadata.clear();
        self.email_addresses.clear();
        self.two_factor_auth_enabled = false;
        self.teams_count = 0;
        self.is_starred = false;
        self.star_count = 0;
        self.visibility.clear();
        self.user_detail.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static User {
        static instance: User = User {
            id: ::std::string::String::new(),
            primary_email: ::std::string::String::new(),
            first_name: ::std::string::String::new(),
            last_name: ::std::string::String::new(),
            company_name: ::std::string::String::new(),
            job_title: ::std::string::String::new(),
            job_role: ::std::string::String::new(),
            intention: ::std::string::String::new(),
            bill_type: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            date_gdpr_consent: ::protobuf::MessageField::none(),
            date_tos_consent: ::protobuf::MessageField::none(),
            date_marketing_consent: ::protobuf::MessageField::none(),
            date_pii_consent: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            email_addresses: ::std::vec::Vec::new(),
            two_factor_auth_enabled: false,
            teams_count: 0,
            is_starred: false,
            star_count: 0,
            visibility: ::protobuf::MessageField::none(),
            user_detail: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for User {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("User").unwrap()).clone()
    }
}

impl ::std::fmt::Display for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This message holds the confidential information from the User object that we don't want to expose
///  to other users. It will be accessible only from /users/{user_id}/account and with the User scopes.
// @@protoc_insertion_point(message:clarifai.api.UserDetail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserDetail {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.primary_email)
    pub primary_email: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.bill_type)
    pub bill_type: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.date_gdpr_consent)
    pub date_gdpr_consent: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.date_tos_consent)
    pub date_tos_consent: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.date_marketing_consent)
    pub date_marketing_consent: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.date_pii_consent)
    pub date_pii_consent: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.email_addresses)
    pub email_addresses: ::std::vec::Vec<EmailAddress>,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.two_factor_auth_enabled)
    pub two_factor_auth_enabled: bool,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.teams_count)
    pub teams_count: u32,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.country)
    pub country: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.UserDetail.state)
    pub state: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.UserDetail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserDetail {
    fn default() -> &'a UserDetail {
        <UserDetail as ::protobuf::Message>::default_instance()
    }
}

impl UserDetail {
    pub fn new() -> UserDetail {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "primary_email",
            |m: &UserDetail| { &m.primary_email },
            |m: &mut UserDetail| { &mut m.primary_email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bill_type",
            |m: &UserDetail| { &m.bill_type },
            |m: &mut UserDetail| { &mut m.bill_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "date_gdpr_consent",
            |m: &UserDetail| { &m.date_gdpr_consent },
            |m: &mut UserDetail| { &mut m.date_gdpr_consent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "date_tos_consent",
            |m: &UserDetail| { &m.date_tos_consent },
            |m: &mut UserDetail| { &mut m.date_tos_consent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "date_marketing_consent",
            |m: &UserDetail| { &m.date_marketing_consent },
            |m: &mut UserDetail| { &mut m.date_marketing_consent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "date_pii_consent",
            |m: &UserDetail| { &m.date_pii_consent },
            |m: &mut UserDetail| { &mut m.date_pii_consent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &UserDetail| { &m.metadata },
            |m: &mut UserDetail| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "email_addresses",
            |m: &UserDetail| { &m.email_addresses },
            |m: &mut UserDetail| { &mut m.email_addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "two_factor_auth_enabled",
            |m: &UserDetail| { &m.two_factor_auth_enabled },
            |m: &mut UserDetail| { &mut m.two_factor_auth_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "teams_count",
            |m: &UserDetail| { &m.teams_count },
            |m: &mut UserDetail| { &mut m.teams_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "country",
            |m: &UserDetail| { &m.country },
            |m: &mut UserDetail| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &UserDetail| { &m.state },
            |m: &mut UserDetail| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserDetail>(
            "UserDetail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserDetail {
    const NAME: &'static str = "UserDetail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.primary_email = is.read_string()?;
                },
                18 => {
                    self.bill_type = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date_gdpr_consent)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date_tos_consent)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date_marketing_consent)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.date_pii_consent)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                58 => {
                    self.email_addresses.push(is.read_message()?);
                },
                72 => {
                    self.two_factor_auth_enabled = is.read_bool()?;
                },
                80 => {
                    self.teams_count = is.read_uint32()?;
                },
                90 => {
                    self.country = is.read_string()?;
                },
                98 => {
                    self.state = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.primary_email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.primary_email);
        }
        if !self.bill_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bill_type);
        }
        if let Some(v) = self.date_gdpr_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.date_tos_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.date_marketing_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.date_pii_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.email_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.two_factor_auth_enabled != false {
            my_size += 1 + 1;
        }
        if self.teams_count != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.teams_count);
        }
        if !self.country.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.country);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.primary_email.is_empty() {
            os.write_string(1, &self.primary_email)?;
        }
        if !self.bill_type.is_empty() {
            os.write_string(2, &self.bill_type)?;
        }
        if let Some(v) = self.date_gdpr_consent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.date_tos_consent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.date_marketing_consent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.date_pii_consent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.email_addresses {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.two_factor_auth_enabled != false {
            os.write_bool(9, self.two_factor_auth_enabled)?;
        }
        if self.teams_count != 0 {
            os.write_uint32(10, self.teams_count)?;
        }
        if !self.country.is_empty() {
            os.write_string(11, &self.country)?;
        }
        if !self.state.is_empty() {
            os.write_string(12, &self.state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserDetail {
        UserDetail::new()
    }

    fn clear(&mut self) {
        self.primary_email.clear();
        self.bill_type.clear();
        self.date_gdpr_consent.clear();
        self.date_tos_consent.clear();
        self.date_marketing_consent.clear();
        self.date_pii_consent.clear();
        self.metadata.clear();
        self.email_addresses.clear();
        self.two_factor_auth_enabled = false;
        self.teams_count = 0;
        self.country.clear();
        self.state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserDetail {
        static instance: UserDetail = UserDetail {
            primary_email: ::std::string::String::new(),
            bill_type: ::std::string::String::new(),
            date_gdpr_consent: ::protobuf::MessageField::none(),
            date_tos_consent: ::protobuf::MessageField::none(),
            date_marketing_consent: ::protobuf::MessageField::none(),
            date_pii_consent: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            email_addresses: ::std::vec::Vec::new(),
            two_factor_auth_enabled: false,
            teams_count: 0,
            country: ::std::string::String::new(),
            state: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserDetail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserDetail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDetail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  EmailAddress
// @@protoc_insertion_point(message:clarifai.api.EmailAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EmailAddress {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.EmailAddress.email)
    pub email: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.EmailAddress.primary)
    pub primary: bool,
    // @@protoc_insertion_point(field:clarifai.api.EmailAddress.verified)
    pub verified: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.EmailAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmailAddress {
    fn default() -> &'a EmailAddress {
        <EmailAddress as ::protobuf::Message>::default_instance()
    }
}

impl EmailAddress {
    pub fn new() -> EmailAddress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &EmailAddress| { &m.email },
            |m: &mut EmailAddress| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "primary",
            |m: &EmailAddress| { &m.primary },
            |m: &mut EmailAddress| { &mut m.primary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "verified",
            |m: &EmailAddress| { &m.verified },
            |m: &mut EmailAddress| { &mut m.verified },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmailAddress>(
            "EmailAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmailAddress {
    const NAME: &'static str = "EmailAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.email = is.read_string()?;
                },
                16 => {
                    self.primary = is.read_bool()?;
                },
                24 => {
                    self.verified = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email);
        }
        if self.primary != false {
            my_size += 1 + 1;
        }
        if self.verified != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.email.is_empty() {
            os.write_string(1, &self.email)?;
        }
        if self.primary != false {
            os.write_bool(2, self.primary)?;
        }
        if self.verified != false {
            os.write_bool(3, self.verified)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmailAddress {
        EmailAddress::new()
    }

    fn clear(&mut self) {
        self.email.clear();
        self.primary = false;
        self.verified = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmailAddress {
        static instance: EmailAddress = EmailAddress {
            email: ::std::string::String::new(),
            primary: false,
            verified: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmailAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmailAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmailAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmailAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Password
// @@protoc_insertion_point(message:clarifai.api.Password)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Password {
    // message fields
    ///  unencrypted password string
    // @@protoc_insertion_point(field:clarifai.api.Password.plaintext)
    pub plaintext: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Password.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Password {
    fn default() -> &'a Password {
        <Password as ::protobuf::Message>::default_instance()
    }
}

impl Password {
    pub fn new() -> Password {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "plaintext",
            |m: &Password| { &m.plaintext },
            |m: &mut Password| { &mut m.plaintext },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Password>(
            "Password",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Password {
    const NAME: &'static str = "Password";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.plaintext = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.plaintext.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.plaintext);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.plaintext.is_empty() {
            os.write_string(1, &self.plaintext)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Password {
        Password::new()
    }

    fn clear(&mut self) {
        self.plaintext.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Password {
        static instance: Password = Password {
            plaintext: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Password {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Password").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Password {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Password {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PasswordViolations
// @@protoc_insertion_point(message:clarifai.api.PasswordViolations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PasswordViolations {
    // message fields
    ///  when new password length is shorter than minimum length set
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.minimum_length)
    pub minimum_length: bool,
    ///  when new password length is longer than maximum length set
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.maximum_length)
    pub maximum_length: bool,
    ///  there is no upper case letter in the new password when there should be at least one
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.upper_case_needed)
    pub upper_case_needed: bool,
    ///  there is no lower case letter in the new password when there should be at least one
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.lower_case_needed)
    pub lower_case_needed: bool,
    ///  there is no numerics in the new password when there should be at least one
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.numeric_needed)
    pub numeric_needed: bool,
    ///  there is no special character in the new password when there should be at least one
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.non_alphanumeric_needed)
    pub non_alphanumeric_needed: bool,
    ///  when one of the N most recent old password is reused, N is specified by password_reuse_epoch in db.password_policies
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.password_reuse)
    pub password_reuse: bool,
    ///  when either user's first, middle or last name is used in the new password
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.exclude_names)
    pub exclude_names: bool,
    ///  when first part of user's email (exact string or after removing special characters) is used in the new password
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.exclude_email)
    pub exclude_email: bool,
    ///  when there are confusing letters in the new password, such as o (first character of 'omega') vs 0 (zero)
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.no_confusing_letters)
    pub no_confusing_letters: bool,
    ///  when there are simple password patterns used, such as 12345678 or aaaaaaa1
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.no_simple_passwords)
    pub no_simple_passwords: bool,
    ///  when there are common vocabs from the common vocab list used
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.no_common_vocabs)
    pub no_common_vocabs: bool,
    ///  when the current password is contained in the new password or vice versa
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.no_overlap_with_old)
    pub no_overlap_with_old: bool,
    ///  when password has to be changed becauase it's too old
    // @@protoc_insertion_point(field:clarifai.api.PasswordViolations.password_lifespan)
    pub password_lifespan: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PasswordViolations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PasswordViolations {
    fn default() -> &'a PasswordViolations {
        <PasswordViolations as ::protobuf::Message>::default_instance()
    }
}

impl PasswordViolations {
    pub fn new() -> PasswordViolations {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minimum_length",
            |m: &PasswordViolations| { &m.minimum_length },
            |m: &mut PasswordViolations| { &mut m.minimum_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "maximum_length",
            |m: &PasswordViolations| { &m.maximum_length },
            |m: &mut PasswordViolations| { &mut m.maximum_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upper_case_needed",
            |m: &PasswordViolations| { &m.upper_case_needed },
            |m: &mut PasswordViolations| { &mut m.upper_case_needed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lower_case_needed",
            |m: &PasswordViolations| { &m.lower_case_needed },
            |m: &mut PasswordViolations| { &mut m.lower_case_needed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "numeric_needed",
            |m: &PasswordViolations| { &m.numeric_needed },
            |m: &mut PasswordViolations| { &mut m.numeric_needed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "non_alphanumeric_needed",
            |m: &PasswordViolations| { &m.non_alphanumeric_needed },
            |m: &mut PasswordViolations| { &mut m.non_alphanumeric_needed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password_reuse",
            |m: &PasswordViolations| { &m.password_reuse },
            |m: &mut PasswordViolations| { &mut m.password_reuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exclude_names",
            |m: &PasswordViolations| { &m.exclude_names },
            |m: &mut PasswordViolations| { &mut m.exclude_names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exclude_email",
            |m: &PasswordViolations| { &m.exclude_email },
            |m: &mut PasswordViolations| { &mut m.exclude_email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "no_confusing_letters",
            |m: &PasswordViolations| { &m.no_confusing_letters },
            |m: &mut PasswordViolations| { &mut m.no_confusing_letters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "no_simple_passwords",
            |m: &PasswordViolations| { &m.no_simple_passwords },
            |m: &mut PasswordViolations| { &mut m.no_simple_passwords },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "no_common_vocabs",
            |m: &PasswordViolations| { &m.no_common_vocabs },
            |m: &mut PasswordViolations| { &mut m.no_common_vocabs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "no_overlap_with_old",
            |m: &PasswordViolations| { &m.no_overlap_with_old },
            |m: &mut PasswordViolations| { &mut m.no_overlap_with_old },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password_lifespan",
            |m: &PasswordViolations| { &m.password_lifespan },
            |m: &mut PasswordViolations| { &mut m.password_lifespan },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PasswordViolations>(
            "PasswordViolations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PasswordViolations {
    const NAME: &'static str = "PasswordViolations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minimum_length = is.read_bool()?;
                },
                16 => {
                    self.maximum_length = is.read_bool()?;
                },
                24 => {
                    self.upper_case_needed = is.read_bool()?;
                },
                32 => {
                    self.lower_case_needed = is.read_bool()?;
                },
                40 => {
                    self.numeric_needed = is.read_bool()?;
                },
                48 => {
                    self.non_alphanumeric_needed = is.read_bool()?;
                },
                56 => {
                    self.password_reuse = is.read_bool()?;
                },
                64 => {
                    self.exclude_names = is.read_bool()?;
                },
                72 => {
                    self.exclude_email = is.read_bool()?;
                },
                80 => {
                    self.no_confusing_letters = is.read_bool()?;
                },
                88 => {
                    self.no_simple_passwords = is.read_bool()?;
                },
                96 => {
                    self.no_common_vocabs = is.read_bool()?;
                },
                104 => {
                    self.no_overlap_with_old = is.read_bool()?;
                },
                112 => {
                    self.password_lifespan = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.minimum_length != false {
            my_size += 1 + 1;
        }
        if self.maximum_length != false {
            my_size += 1 + 1;
        }
        if self.upper_case_needed != false {
            my_size += 1 + 1;
        }
        if self.lower_case_needed != false {
            my_size += 1 + 1;
        }
        if self.numeric_needed != false {
            my_size += 1 + 1;
        }
        if self.non_alphanumeric_needed != false {
            my_size += 1 + 1;
        }
        if self.password_reuse != false {
            my_size += 1 + 1;
        }
        if self.exclude_names != false {
            my_size += 1 + 1;
        }
        if self.exclude_email != false {
            my_size += 1 + 1;
        }
        if self.no_confusing_letters != false {
            my_size += 1 + 1;
        }
        if self.no_simple_passwords != false {
            my_size += 1 + 1;
        }
        if self.no_common_vocabs != false {
            my_size += 1 + 1;
        }
        if self.no_overlap_with_old != false {
            my_size += 1 + 1;
        }
        if self.password_lifespan != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.minimum_length != false {
            os.write_bool(1, self.minimum_length)?;
        }
        if self.maximum_length != false {
            os.write_bool(2, self.maximum_length)?;
        }
        if self.upper_case_needed != false {
            os.write_bool(3, self.upper_case_needed)?;
        }
        if self.lower_case_needed != false {
            os.write_bool(4, self.lower_case_needed)?;
        }
        if self.numeric_needed != false {
            os.write_bool(5, self.numeric_needed)?;
        }
        if self.non_alphanumeric_needed != false {
            os.write_bool(6, self.non_alphanumeric_needed)?;
        }
        if self.password_reuse != false {
            os.write_bool(7, self.password_reuse)?;
        }
        if self.exclude_names != false {
            os.write_bool(8, self.exclude_names)?;
        }
        if self.exclude_email != false {
            os.write_bool(9, self.exclude_email)?;
        }
        if self.no_confusing_letters != false {
            os.write_bool(10, self.no_confusing_letters)?;
        }
        if self.no_simple_passwords != false {
            os.write_bool(11, self.no_simple_passwords)?;
        }
        if self.no_common_vocabs != false {
            os.write_bool(12, self.no_common_vocabs)?;
        }
        if self.no_overlap_with_old != false {
            os.write_bool(13, self.no_overlap_with_old)?;
        }
        if self.password_lifespan != false {
            os.write_bool(14, self.password_lifespan)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PasswordViolations {
        PasswordViolations::new()
    }

    fn clear(&mut self) {
        self.minimum_length = false;
        self.maximum_length = false;
        self.upper_case_needed = false;
        self.lower_case_needed = false;
        self.numeric_needed = false;
        self.non_alphanumeric_needed = false;
        self.password_reuse = false;
        self.exclude_names = false;
        self.exclude_email = false;
        self.no_confusing_letters = false;
        self.no_simple_passwords = false;
        self.no_common_vocabs = false;
        self.no_overlap_with_old = false;
        self.password_lifespan = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PasswordViolations {
        static instance: PasswordViolations = PasswordViolations {
            minimum_length: false,
            maximum_length: false,
            upper_case_needed: false,
            lower_case_needed: false,
            numeric_needed: false,
            non_alphanumeric_needed: false,
            password_reuse: false,
            exclude_names: false,
            exclude_email: false,
            no_confusing_letters: false,
            no_simple_passwords: false,
            no_common_vocabs: false,
            no_overlap_with_old: false,
            password_lifespan: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PasswordViolations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PasswordViolations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PasswordViolations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PasswordViolations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Video
// @@protoc_insertion_point(message:clarifai.api.Video)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Video {
    // message fields
    ///  This is a URL to a publicly accessible video file. The platform will download this file server
    ///  side and then process.
    // @@protoc_insertion_point(field:clarifai.api.Video.url)
    pub url: ::std::string::String,
    ///  The base64 field is using video file bytes directly in the request.
    ///  NOTE: if you're sending a json request, then this MUST be base64 encoded before sending (hence
    ///  the name here).
    ///  When using our grpc clients, you DO NOT need to base64 encode
    ///  it yourself since the clients know how to do this for you automatically and will avoid the
    ///  base64 encoding if they send a binary request.
    // @@protoc_insertion_point(field:clarifai.api.Video.base64)
    pub base64: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:clarifai.api.Video.allow_duplicate_url)
    pub allow_duplicate_url: bool,
    ///  URL of thumbnail image, which is currently frame at position of 1s. This field is currently
    ///  used only in response.
    ///  Deprecated in favour of thumbnail_hosted, which also contains alternate sizes of thumbnail
    // @@protoc_insertion_point(field:clarifai.api.Video.thumbnail_url)
    pub thumbnail_url: ::std::string::String,
    ///  The hosted field lists original video hosted in Clarifai storage. This field is currently used
    ///  only in response.
    // @@protoc_insertion_point(field:clarifai.api.Video.hosted)
    pub hosted: ::protobuf::MessageField<HostedURL>,
    ///  The hosted field lists various sizes of the vide thumbnail hosted in Clarifai storage, with 'thumbnail' as the full size
    ///  This field is currently used only in response.
    // @@protoc_insertion_point(field:clarifai.api.Video.hosted_thumbnail)
    pub hosted_thumbnail: ::protobuf::MessageField<HostedURL>,
    ///  video info
    // @@protoc_insertion_point(field:clarifai.api.Video.video_info)
    pub video_info: ::protobuf::MessageField<VideoInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Video.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Video {
    fn default() -> &'a Video {
        <Video as ::protobuf::Message>::default_instance()
    }
}

impl Video {
    pub fn new() -> Video {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Video| { &m.url },
            |m: &mut Video| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "base64",
            |m: &Video| { &m.base64 },
            |m: &mut Video| { &mut m.base64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_duplicate_url",
            |m: &Video| { &m.allow_duplicate_url },
            |m: &mut Video| { &mut m.allow_duplicate_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "thumbnail_url",
            |m: &Video| { &m.thumbnail_url },
            |m: &mut Video| { &mut m.thumbnail_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HostedURL>(
            "hosted",
            |m: &Video| { &m.hosted },
            |m: &mut Video| { &mut m.hosted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HostedURL>(
            "hosted_thumbnail",
            |m: &Video| { &m.hosted_thumbnail },
            |m: &mut Video| { &mut m.hosted_thumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VideoInfo>(
            "video_info",
            |m: &Video| { &m.video_info },
            |m: &mut Video| { &mut m.video_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Video>(
            "Video",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Video {
    const NAME: &'static str = "Video";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                18 => {
                    self.base64 = is.read_bytes()?;
                },
                32 => {
                    self.allow_duplicate_url = is.read_bool()?;
                },
                42 => {
                    self.thumbnail_url = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hosted)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hosted_thumbnail)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.video_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.base64.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.base64);
        }
        if self.allow_duplicate_url != false {
            my_size += 1 + 1;
        }
        if !self.thumbnail_url.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.thumbnail_url);
        }
        if let Some(v) = self.hosted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hosted_thumbnail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.video_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.base64.is_empty() {
            os.write_bytes(2, &self.base64)?;
        }
        if self.allow_duplicate_url != false {
            os.write_bool(4, self.allow_duplicate_url)?;
        }
        if !self.thumbnail_url.is_empty() {
            os.write_string(5, &self.thumbnail_url)?;
        }
        if let Some(v) = self.hosted.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.hosted_thumbnail.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.video_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Video {
        Video::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.base64.clear();
        self.allow_duplicate_url = false;
        self.thumbnail_url.clear();
        self.hosted.clear();
        self.hosted_thumbnail.clear();
        self.video_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Video {
        static instance: Video = Video {
            url: ::std::string::String::new(),
            base64: ::std::vec::Vec::new(),
            allow_duplicate_url: false,
            thumbnail_url: ::std::string::String::new(),
            hosted: ::protobuf::MessageField::none(),
            hosted_thumbnail: ::protobuf::MessageField::none(),
            video_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Video {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Video").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Video {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Video {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.VideoInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VideoInfo {
    // message fields
    ///  width
    // @@protoc_insertion_point(field:clarifai.api.VideoInfo.width)
    pub width: i32,
    ///  height
    // @@protoc_insertion_point(field:clarifai.api.VideoInfo.height)
    pub height: i32,
    ///  Frames per second of the video.
    // @@protoc_insertion_point(field:clarifai.api.VideoInfo.fps)
    pub fps: f32,
    ///  video format
    // @@protoc_insertion_point(field:clarifai.api.VideoInfo.video_format)
    pub video_format: ::std::string::String,
    ///  video track bit rate
    // @@protoc_insertion_point(field:clarifai.api.VideoInfo.bit_rate)
    pub bit_rate: i32,
    ///  video frame count
    // @@protoc_insertion_point(field:clarifai.api.VideoInfo.frame_count)
    pub frame_count: i32,
    ///  video duration in seconds
    // @@protoc_insertion_point(field:clarifai.api.VideoInfo.duration_seconds)
    pub duration_seconds: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.VideoInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoInfo {
    fn default() -> &'a VideoInfo {
        <VideoInfo as ::protobuf::Message>::default_instance()
    }
}

impl VideoInfo {
    pub fn new() -> VideoInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &VideoInfo| { &m.width },
            |m: &mut VideoInfo| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &VideoInfo| { &m.height },
            |m: &mut VideoInfo| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fps",
            |m: &VideoInfo| { &m.fps },
            |m: &mut VideoInfo| { &mut m.fps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "video_format",
            |m: &VideoInfo| { &m.video_format },
            |m: &mut VideoInfo| { &mut m.video_format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bit_rate",
            |m: &VideoInfo| { &m.bit_rate },
            |m: &mut VideoInfo| { &mut m.bit_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "frame_count",
            |m: &VideoInfo| { &m.frame_count },
            |m: &mut VideoInfo| { &mut m.frame_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration_seconds",
            |m: &VideoInfo| { &m.duration_seconds },
            |m: &mut VideoInfo| { &mut m.duration_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoInfo>(
            "VideoInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoInfo {
    const NAME: &'static str = "VideoInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = is.read_int32()?;
                },
                16 => {
                    self.height = is.read_int32()?;
                },
                29 => {
                    self.fps = is.read_float()?;
                },
                34 => {
                    self.video_format = is.read_string()?;
                },
                40 => {
                    self.bit_rate = is.read_int32()?;
                },
                48 => {
                    self.frame_count = is.read_int32()?;
                },
                61 => {
                    self.duration_seconds = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.height);
        }
        if self.fps != 0. {
            my_size += 1 + 4;
        }
        if !self.video_format.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.video_format);
        }
        if self.bit_rate != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.bit_rate);
        }
        if self.frame_count != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.frame_count);
        }
        if self.duration_seconds != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.width != 0 {
            os.write_int32(1, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        if self.fps != 0. {
            os.write_float(3, self.fps)?;
        }
        if !self.video_format.is_empty() {
            os.write_string(4, &self.video_format)?;
        }
        if self.bit_rate != 0 {
            os.write_int32(5, self.bit_rate)?;
        }
        if self.frame_count != 0 {
            os.write_int32(6, self.frame_count)?;
        }
        if self.duration_seconds != 0. {
            os.write_float(7, self.duration_seconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoInfo {
        VideoInfo::new()
    }

    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.fps = 0.;
        self.video_format.clear();
        self.bit_rate = 0;
        self.frame_count = 0;
        self.duration_seconds = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoInfo {
        static instance: VideoInfo = VideoInfo {
            width: 0,
            height: 0,
            fps: 0.,
            video_format: ::std::string::String::new(),
            bit_rate: 0,
            frame_count: 0,
            duration_seconds: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Workflow
// @@protoc_insertion_point(message:clarifai.api.Workflow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Workflow {
    // message fields
    ///  The workflows's unique id.
    // @@protoc_insertion_point(field:clarifai.api.Workflow.id)
    pub id: ::std::string::String,
    ///  The app the workflow belongs to
    // @@protoc_insertion_point(field:clarifai.api.Workflow.app_id)
    pub app_id: ::std::string::String,
    ///  When the workflow was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.Workflow.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The list of nodes retrieved from latest workflow version.
    ///  Each node can specify an input node that it connects to in order to define the graph.
    // @@protoc_insertion_point(field:clarifai.api.Workflow.nodes)
    pub nodes: ::std::vec::Vec<WorkflowNode>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.Workflow.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.Workflow.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  The user the workflow belongs to
    // @@protoc_insertion_point(field:clarifai.api.Workflow.user_id)
    pub user_id: ::std::string::String,
    ///  When the workflow was last modified
    // @@protoc_insertion_point(field:clarifai.api.Workflow.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Info about the workflow version used to return the latest version when listing Workflows.
    // @@protoc_insertion_point(field:clarifai.api.Workflow.version)
    pub version: ::protobuf::MessageField<WorkflowVersion>,
    ///  Is starred by the requesting user (only showed on get/list requests)
    ///  Please use PostWorkflowStars/DeleteWorkflowStars endpoints to star/unstar a workflow
    // @@protoc_insertion_point(field:clarifai.api.Workflow.is_starred)
    pub is_starred: bool,
    ///  How many users have starred the workflow (only showed on get/list requests)
    ///  Computed value, not editable
    // @@protoc_insertion_point(field:clarifai.api.Workflow.star_count)
    pub star_count: i32,
    ///  Short description about this workflow
    // @@protoc_insertion_point(field:clarifai.api.Workflow.description)
    pub description: ::std::string::String,
    ///  Notes for the workflow
    ///  This field should be used for in-depth notes and supports up to 64Kbs.
    // @@protoc_insertion_point(field:clarifai.api.Workflow.notes)
    pub notes: ::std::string::String,
    ///  Tags from use_cases category
    // @@protoc_insertion_point(field:clarifai.api.Workflow.use_cases)
    pub use_cases: ::std::vec::Vec<::std::string::String>,
    ///  Tags for check consents
    // @@protoc_insertion_point(field:clarifai.api.Workflow.check_consents)
    pub check_consents: ::std::vec::Vec<::std::string::String>,
    ///  bookmark info. When set, this workflow is a bookmarked workflow of this app.
    ///  Info in this field will allow you to find/access original workflow.
    // @@protoc_insertion_point(field:clarifai.api.Workflow.bookmark_origin)
    pub bookmark_origin: ::protobuf::MessageField<BookmarkOrigin>,
    ///  Representative image for this workflow
    // @@protoc_insertion_point(field:clarifai.api.Workflow.image)
    pub image: ::protobuf::MessageField<Image>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Workflow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Workflow {
    fn default() -> &'a Workflow {
        <Workflow as ::protobuf::Message>::default_instance()
    }
}

impl Workflow {
    pub fn new() -> Workflow {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Workflow| { &m.id },
            |m: &mut Workflow| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &Workflow| { &m.app_id },
            |m: &mut Workflow| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Workflow| { &m.created_at },
            |m: &mut Workflow| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &Workflow| { &m.nodes },
            |m: &mut Workflow| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &Workflow| { &m.metadata },
            |m: &mut Workflow| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &Workflow| { &m.visibility },
            |m: &mut Workflow| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Workflow| { &m.user_id },
            |m: &mut Workflow| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Workflow| { &m.modified_at },
            |m: &mut Workflow| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WorkflowVersion>(
            "version",
            |m: &Workflow| { &m.version },
            |m: &mut Workflow| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_starred",
            |m: &Workflow| { &m.is_starred },
            |m: &mut Workflow| { &mut m.is_starred },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "star_count",
            |m: &Workflow| { &m.star_count },
            |m: &mut Workflow| { &mut m.star_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Workflow| { &m.description },
            |m: &mut Workflow| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "notes",
            |m: &Workflow| { &m.notes },
            |m: &mut Workflow| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "use_cases",
            |m: &Workflow| { &m.use_cases },
            |m: &mut Workflow| { &mut m.use_cases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "check_consents",
            |m: &Workflow| { &m.check_consents },
            |m: &mut Workflow| { &mut m.check_consents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BookmarkOrigin>(
            "bookmark_origin",
            |m: &Workflow| { &m.bookmark_origin },
            |m: &mut Workflow| { &mut m.bookmark_origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &Workflow| { &m.image },
            |m: &mut Workflow| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Workflow>(
            "Workflow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Workflow {
    const NAME: &'static str = "Workflow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.app_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                34 => {
                    self.nodes.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                58 => {
                    self.user_id = is.read_string()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                80 => {
                    self.is_starred = is.read_bool()?;
                },
                88 => {
                    self.star_count = is.read_int32()?;
                },
                98 => {
                    self.description = is.read_string()?;
                },
                106 => {
                    self.notes = is.read_string()?;
                },
                114 => {
                    self.use_cases.push(is.read_string()?);
                },
                122 => {
                    self.check_consents.push(is.read_string()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bookmark_origin)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.user_id);
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.is_starred != false {
            my_size += 1 + 1;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.star_count);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.description);
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.notes);
        }
        for value in &self.use_cases {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.check_consents {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.bookmark_origin.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(7, &self.user_id)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if self.is_starred != false {
            os.write_bool(10, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(11, self.star_count)?;
        }
        if !self.description.is_empty() {
            os.write_string(12, &self.description)?;
        }
        if !self.notes.is_empty() {
            os.write_string(13, &self.notes)?;
        }
        for v in &self.use_cases {
            os.write_string(14, &v)?;
        };
        for v in &self.check_consents {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.bookmark_origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Workflow {
        Workflow::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.app_id.clear();
        self.created_at.clear();
        self.nodes.clear();
        self.metadata.clear();
        self.visibility.clear();
        self.user_id.clear();
        self.modified_at.clear();
        self.version.clear();
        self.is_starred = false;
        self.star_count = 0;
        self.description.clear();
        self.notes.clear();
        self.use_cases.clear();
        self.check_consents.clear();
        self.bookmark_origin.clear();
        self.image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Workflow {
        static instance: Workflow = Workflow {
            id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            nodes: ::std::vec::Vec::new(),
            metadata: ::protobuf::MessageField::none(),
            visibility: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            modified_at: ::protobuf::MessageField::none(),
            version: ::protobuf::MessageField::none(),
            is_starred: false,
            star_count: 0,
            description: ::std::string::String::new(),
            notes: ::std::string::String::new(),
            use_cases: ::std::vec::Vec::new(),
            check_consents: ::std::vec::Vec::new(),
            bookmark_origin: ::protobuf::MessageField::none(),
            image: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Workflow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Workflow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Workflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Workflow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  WorkflowVersion
// @@protoc_insertion_point(message:clarifai.api.WorkflowVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowVersion {
    // message fields
    ///  Id of this version.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.id)
    pub id: ::std::string::String,
    ///  Workflow id for this version.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  When the version was created.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Most recent time when the version was updated.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  The list of nodes that make up the workflow version. Each node can specify an input node
    ///  that it connects to in order to define the graph.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.nodes)
    pub nodes: ::std::vec::Vec<WorkflowNode>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  The app the workflow version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.app_id)
    pub app_id: ::std::string::String,
    ///  The user the workflow version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.user_id)
    pub user_id: ::std::string::String,
    ///  Short description about this workflow version
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.description)
    pub description: ::std::string::String,
    ///  License associated to this workflow version
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersion.license)
    pub license: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowVersion {
    fn default() -> &'a WorkflowVersion {
        <WorkflowVersion as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowVersion {
    pub fn new() -> WorkflowVersion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WorkflowVersion| { &m.id },
            |m: &mut WorkflowVersion| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &WorkflowVersion| { &m.workflow_id },
            |m: &mut WorkflowVersion| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &WorkflowVersion| { &m.created_at },
            |m: &mut WorkflowVersion| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &WorkflowVersion| { &m.modified_at },
            |m: &mut WorkflowVersion| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &WorkflowVersion| { &m.visibility },
            |m: &mut WorkflowVersion| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &WorkflowVersion| { &m.nodes },
            |m: &mut WorkflowVersion| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &WorkflowVersion| { &m.metadata },
            |m: &mut WorkflowVersion| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &WorkflowVersion| { &m.app_id },
            |m: &mut WorkflowVersion| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &WorkflowVersion| { &m.user_id },
            |m: &mut WorkflowVersion| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &WorkflowVersion| { &m.description },
            |m: &mut WorkflowVersion| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "license",
            |m: &WorkflowVersion| { &m.license },
            |m: &mut WorkflowVersion| { &mut m.license },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowVersion>(
            "WorkflowVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowVersion {
    const NAME: &'static str = "WorkflowVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                50 => {
                    self.nodes.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                66 => {
                    self.app_id = is.read_string()?;
                },
                74 => {
                    self.user_id = is.read_string()?;
                },
                82 => {
                    self.description = is.read_string()?;
                },
                90 => {
                    self.license = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.user_id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.description);
        }
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.license);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(8, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(9, &self.user_id)?;
        }
        if !self.description.is_empty() {
            os.write_string(10, &self.description)?;
        }
        if !self.license.is_empty() {
            os.write_string(11, &self.license)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowVersion {
        WorkflowVersion::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.workflow_id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.visibility.clear();
        self.nodes.clear();
        self.metadata.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.description.clear();
        self.license.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowVersion {
        static instance: WorkflowVersion = WorkflowVersion {
            id: ::std::string::String::new(),
            workflow_id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            visibility: ::protobuf::MessageField::none(),
            nodes: ::std::vec::Vec::new(),
            metadata: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            license: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  WorkflowNode
// @@protoc_insertion_point(message:clarifai.api.WorkflowNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowNode {
    // message fields
    ///  An identifier for this node in the graph. This is used when connecting NodeInputs
    ///  together.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowNode.id)
    pub id: ::std::string::String,
    ///  The model that will do the processing at this node. We only vlidate the model.id and
    ///  model.model_version.id fields.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowNode.model)
    pub model: ::protobuf::MessageField<Model>,
    ///  Each WorkflowNode can connect to multiple input nodes so that we can handle multi-model data
    ///  and more complex workflow operations.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowNode.node_inputs)
    pub node_inputs: ::std::vec::Vec<NodeInput>,
    ///  suppress the output for workflow prediction
    // @@protoc_insertion_point(field:clarifai.api.WorkflowNode.suppress_output)
    pub suppress_output: bool,
    ///  Used to override the output_info.data and output_info.params of the model specified by the node.
    ///  Values for fields_map, message, and output_config are ignored.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowNode.output_info_override)
    pub output_info_override: ::protobuf::MessageField<OutputInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowNode {
    fn default() -> &'a WorkflowNode {
        <WorkflowNode as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowNode {
    pub fn new() -> WorkflowNode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WorkflowNode| { &m.id },
            |m: &mut WorkflowNode| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Model>(
            "model",
            |m: &WorkflowNode| { &m.model },
            |m: &mut WorkflowNode| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node_inputs",
            |m: &WorkflowNode| { &m.node_inputs },
            |m: &mut WorkflowNode| { &mut m.node_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "suppress_output",
            |m: &WorkflowNode| { &m.suppress_output },
            |m: &mut WorkflowNode| { &mut m.suppress_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OutputInfo>(
            "output_info_override",
            |m: &WorkflowNode| { &m.output_info_override },
            |m: &mut WorkflowNode| { &mut m.output_info_override },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowNode>(
            "WorkflowNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowNode {
    const NAME: &'static str = "WorkflowNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                26 => {
                    self.node_inputs.push(is.read_message()?);
                },
                32 => {
                    self.suppress_output = is.read_bool()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_info_override)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.node_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.suppress_output != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.output_info_override.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.node_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.suppress_output != false {
            os.write_bool(4, self.suppress_output)?;
        }
        if let Some(v) = self.output_info_override.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowNode {
        WorkflowNode::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.model.clear();
        self.node_inputs.clear();
        self.suppress_output = false;
        self.output_info_override.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowNode {
        static instance: WorkflowNode = WorkflowNode {
            id: ::std::string::String::new(),
            model: ::protobuf::MessageField::none(),
            node_inputs: ::std::vec::Vec::new(),
            suppress_output: false,
            output_info_override: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  NodeInput represents inputs to a node of the graph.
// @@protoc_insertion_point(message:clarifai.api.NodeInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NodeInput {
    // message fields
    ///  The id to a connected WorkflowNode which will be used as an input for current WorkflowNode.
    // @@protoc_insertion_point(field:clarifai.api.NodeInput.node_id)
    pub node_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.NodeInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeInput {
    fn default() -> &'a NodeInput {
        <NodeInput as ::protobuf::Message>::default_instance()
    }
}

impl NodeInput {
    pub fn new() -> NodeInput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_id",
            |m: &NodeInput| { &m.node_id },
            |m: &mut NodeInput| { &mut m.node_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeInput>(
            "NodeInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeInput {
    const NAME: &'static str = "NodeInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeInput {
        NodeInput::new()
    }

    fn clear(&mut self) {
        self.node_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeInput {
        static instance: NodeInput = NodeInput {
            node_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  WorkflowResult
///  One result per input in the workflow.
// @@protoc_insertion_point(message:clarifai.api.WorkflowResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowResult {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResult.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResult.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  When the object was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResult.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The model that this WorkflowResult is for.
    ///  DEPRECATED: not sure why there ever was a model here because each output shows the model
    ///  that process this given input.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResult.model)
    pub model: ::protobuf::MessageField<Model>,
    ///  The input that ran through the workflow to generate the outputs in this WorkflowResult.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResult.input)
    pub input: ::protobuf::MessageField<Input>,
    ///  For each model in the workflow we return an Output.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResult.outputs)
    pub outputs: ::std::vec::Vec<Output>,
    ///  Indicate if the output of this model is suppressed.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowResult.suppress_output)
    pub suppress_output: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowResult {
    fn default() -> &'a WorkflowResult {
        <WorkflowResult as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowResult {
    pub fn new() -> WorkflowResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WorkflowResult| { &m.id },
            |m: &mut WorkflowResult| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &WorkflowResult| { &m.status },
            |m: &mut WorkflowResult| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &WorkflowResult| { &m.created_at },
            |m: &mut WorkflowResult| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Model>(
            "model",
            |m: &WorkflowResult| { &m.model },
            |m: &mut WorkflowResult| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input",
            |m: &WorkflowResult| { &m.input },
            |m: &mut WorkflowResult| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &WorkflowResult| { &m.outputs },
            |m: &mut WorkflowResult| { &mut m.outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "suppress_output",
            |m: &WorkflowResult| { &m.suppress_output },
            |m: &mut WorkflowResult| { &mut m.suppress_output },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowResult>(
            "WorkflowResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowResult {
    const NAME: &'static str = "WorkflowResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                50 => {
                    self.outputs.push(is.read_message()?);
                },
                56 => {
                    self.suppress_output = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.suppress_output != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.suppress_output != false {
            os.write_bool(7, self.suppress_output)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowResult {
        WorkflowResult::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.status.clear();
        self.created_at.clear();
        self.model.clear();
        self.input.clear();
        self.outputs.clear();
        self.suppress_output = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowResult {
        static instance: WorkflowResult = WorkflowResult {
            id: ::std::string::String::new(),
            status: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            model: ::protobuf::MessageField::none(),
            input: ::protobuf::MessageField::none(),
            outputs: ::std::vec::Vec::new(),
            suppress_output: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  WorkflowState
// @@protoc_insertion_point(message:clarifai.api.WorkflowState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowState {
    // message fields
    ///  A unique ID for the workflow state.
    ///  To start saving a state in a PostWorkflowResults request set this ID to "init"
    ///  and it will return a newly generated unique state id that you can then pass in subsequent
    ///  PostWorkflowResults calls. These state expire after 5 minutes between calls.
    // @@protoc_insertion_point(field:clarifai.api.WorkflowState.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowState {
    fn default() -> &'a WorkflowState {
        <WorkflowState as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowState {
    pub fn new() -> WorkflowState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WorkflowState| { &m.id },
            |m: &mut WorkflowState| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowState>(
            "WorkflowState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowState {
    const NAME: &'static str = "WorkflowState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowState {
        WorkflowState::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowState {
        static instance: WorkflowState = WorkflowState {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  AppDuplication
// @@protoc_insertion_point(message:clarifai.api.AppDuplication)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AppDuplication {
    // message fields
    ///  The unique identifier of an app duplication job.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.id)
    pub id: ::std::string::String,
    ///  The destination application where resources are written.
    ///
    ///  If the destination does not exist, then the fields from the request are
    ///  used to create the application. If a field is not set or not supported,
    ///  then it will be copied from the source app, unless otherwise noted.
    ///
    ///  Note: this field can be empty when reading app duplication jobs in cases
    ///  where the app has been deleted or is just not visible to the caller.
    ///
    ///  ########## Supported fields ##########
    ///   - description
    ///   - id      - if not set, then generated automatically
    ///   - user_id - if not set, then the calling user is used as the app owner
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.destination_app)
    pub destination_app: ::protobuf::MessageField<App>,
    ///  The ID of an existing app you want to copy data into.
    ///
    ///  If not provided, then we will create a new application as the destination instead.
    ///  The various new_app_* fields can be used to set fields of this new application.
    ///
    ///  Deprecated: Use destination_app.id with an existing ID instead.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.existing_app_id)
    pub existing_app_id: ::std::string::String,
    ///  The ID to use when creating a new application.
    ///  You cannot set this field when copying into an existing app, i.e., when existing_app_is is set.
    ///
    ///  If not provided, then it will be generated automatically.
    ///
    ///  Deprecated: Use destination_app.id with a new ID instead.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.new_app_id)
    pub new_app_id: ::std::string::String,
    ///  The name to use when creating a new application.
    ///  You cannot set this field when copying into an existing app, i.e., when existing_app_is is set.
    ///
    ///  If not provided, then the ID of the new application is also used as the name.
    ///
    ///  Deprecated: Application names are deprecated, use application IDs instead.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.new_app_name)
    pub new_app_name: ::std::string::String,
    ///  The status of the app duplication job.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The time when the app duplication job was created.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The last time when the app duplication job status was updated.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.last_modified_at)
    pub last_modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The filter specifies which resources are copied by the app duplication job.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.filter)
    pub filter: ::protobuf::MessageField<AppDuplicationFilters>,
    ///  Copy progress for each resource type requested by the filter. Possible fields:
    ///   - inputs
    ///   - concepts
    ///   - annotations
    ///   - models
    ///   - workflows
    ///   - installed_module_versions
    // @@protoc_insertion_point(field:clarifai.api.AppDuplication.progress)
    pub progress: ::std::vec::Vec<AppCopyProgress>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AppDuplication.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppDuplication {
    fn default() -> &'a AppDuplication {
        <AppDuplication as ::protobuf::Message>::default_instance()
    }
}

impl AppDuplication {
    pub fn new() -> AppDuplication {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AppDuplication| { &m.id },
            |m: &mut AppDuplication| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, App>(
            "destination_app",
            |m: &AppDuplication| { &m.destination_app },
            |m: &mut AppDuplication| { &mut m.destination_app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "existing_app_id",
            |m: &AppDuplication| { &m.existing_app_id },
            |m: &mut AppDuplication| { &mut m.existing_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_app_id",
            |m: &AppDuplication| { &m.new_app_id },
            |m: &mut AppDuplication| { &mut m.new_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_app_name",
            |m: &AppDuplication| { &m.new_app_name },
            |m: &mut AppDuplication| { &mut m.new_app_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &AppDuplication| { &m.status },
            |m: &mut AppDuplication| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &AppDuplication| { &m.created_at },
            |m: &mut AppDuplication| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "last_modified_at",
            |m: &AppDuplication| { &m.last_modified_at },
            |m: &mut AppDuplication| { &mut m.last_modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppDuplicationFilters>(
            "filter",
            |m: &AppDuplication| { &m.filter },
            |m: &mut AppDuplication| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "progress",
            |m: &AppDuplication| { &m.progress },
            |m: &mut AppDuplication| { &mut m.progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppDuplication>(
            "AppDuplication",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppDuplication {
    const NAME: &'static str = "AppDuplication";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.destination_app)?;
                },
                66 => {
                    self.existing_app_id = is.read_string()?;
                },
                18 => {
                    self.new_app_id = is.read_string()?;
                },
                26 => {
                    self.new_app_name = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_modified_at)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                74 => {
                    self.progress.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.destination_app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.existing_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.existing_app_id);
        }
        if !self.new_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new_app_id);
        }
        if !self.new_app_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.new_app_name);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.progress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.destination_app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if !self.existing_app_id.is_empty() {
            os.write_string(8, &self.existing_app_id)?;
        }
        if !self.new_app_id.is_empty() {
            os.write_string(2, &self.new_app_id)?;
        }
        if !self.new_app_name.is_empty() {
            os.write_string(3, &self.new_app_name)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.last_modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.progress {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppDuplication {
        AppDuplication::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.destination_app.clear();
        self.existing_app_id.clear();
        self.new_app_id.clear();
        self.new_app_name.clear();
        self.status.clear();
        self.created_at.clear();
        self.last_modified_at.clear();
        self.filter.clear();
        self.progress.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppDuplication {
        static instance: AppDuplication = AppDuplication {
            id: ::std::string::String::new(),
            destination_app: ::protobuf::MessageField::none(),
            existing_app_id: ::std::string::String::new(),
            new_app_id: ::std::string::String::new(),
            new_app_name: ::std::string::String::new(),
            status: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            last_modified_at: ::protobuf::MessageField::none(),
            filter: ::protobuf::MessageField::none(),
            progress: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppDuplication {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppDuplication").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppDuplication {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDuplication {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.AppCopyProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AppCopyProgress {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.AppCopyProgress.field)
    pub field: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.AppCopyProgress.value)
    pub value: i32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AppCopyProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppCopyProgress {
    fn default() -> &'a AppCopyProgress {
        <AppCopyProgress as ::protobuf::Message>::default_instance()
    }
}

impl AppCopyProgress {
    pub fn new() -> AppCopyProgress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "field",
            |m: &AppCopyProgress| { &m.field },
            |m: &mut AppCopyProgress| { &mut m.field },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &AppCopyProgress| { &m.value },
            |m: &mut AppCopyProgress| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppCopyProgress>(
            "AppCopyProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppCopyProgress {
    const NAME: &'static str = "AppCopyProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.field = is.read_string()?;
                },
                16 => {
                    self.value = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.field.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.field.is_empty() {
            os.write_string(1, &self.field)?;
        }
        if self.value != 0 {
            os.write_int32(2, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppCopyProgress {
        AppCopyProgress::new()
    }

    fn clear(&mut self) {
        self.field.clear();
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppCopyProgress {
        static instance: AppCopyProgress = AppCopyProgress {
            field: ::std::string::String::new(),
            value: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppCopyProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppCopyProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppCopyProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppCopyProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  AppDuplicationFilters
// @@protoc_insertion_point(message:clarifai.api.AppDuplicationFilters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AppDuplicationFilters {
    // message fields
    ///  Copy inputs. Requires that copy_concepts is also set.
    ///  Note that this will still copy input-level annotations even if copy_annotations is not set.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplicationFilters.copy_inputs)
    pub copy_inputs: bool,
    ///  Copy concepts.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplicationFilters.copy_concepts)
    pub copy_concepts: bool,
    ///  Copy annotations. Requires that copy_inputs and copy_concepts are also set.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplicationFilters.copy_annotations)
    pub copy_annotations: bool,
    ///  Copy models. Requires that copy_concepts is also set.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplicationFilters.copy_models)
    pub copy_models: bool,
    ///  Copy workflows.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplicationFilters.copy_workflows)
    pub copy_workflows: bool,
    ///  Copy installed module versions.
    // @@protoc_insertion_point(field:clarifai.api.AppDuplicationFilters.copy_installed_module_versions)
    pub copy_installed_module_versions: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AppDuplicationFilters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppDuplicationFilters {
    fn default() -> &'a AppDuplicationFilters {
        <AppDuplicationFilters as ::protobuf::Message>::default_instance()
    }
}

impl AppDuplicationFilters {
    pub fn new() -> AppDuplicationFilters {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copy_inputs",
            |m: &AppDuplicationFilters| { &m.copy_inputs },
            |m: &mut AppDuplicationFilters| { &mut m.copy_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copy_concepts",
            |m: &AppDuplicationFilters| { &m.copy_concepts },
            |m: &mut AppDuplicationFilters| { &mut m.copy_concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copy_annotations",
            |m: &AppDuplicationFilters| { &m.copy_annotations },
            |m: &mut AppDuplicationFilters| { &mut m.copy_annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copy_models",
            |m: &AppDuplicationFilters| { &m.copy_models },
            |m: &mut AppDuplicationFilters| { &mut m.copy_models },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copy_workflows",
            |m: &AppDuplicationFilters| { &m.copy_workflows },
            |m: &mut AppDuplicationFilters| { &mut m.copy_workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copy_installed_module_versions",
            |m: &AppDuplicationFilters| { &m.copy_installed_module_versions },
            |m: &mut AppDuplicationFilters| { &mut m.copy_installed_module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppDuplicationFilters>(
            "AppDuplicationFilters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppDuplicationFilters {
    const NAME: &'static str = "AppDuplicationFilters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.copy_inputs = is.read_bool()?;
                },
                16 => {
                    self.copy_concepts = is.read_bool()?;
                },
                24 => {
                    self.copy_annotations = is.read_bool()?;
                },
                32 => {
                    self.copy_models = is.read_bool()?;
                },
                40 => {
                    self.copy_workflows = is.read_bool()?;
                },
                48 => {
                    self.copy_installed_module_versions = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.copy_inputs != false {
            my_size += 1 + 1;
        }
        if self.copy_concepts != false {
            my_size += 1 + 1;
        }
        if self.copy_annotations != false {
            my_size += 1 + 1;
        }
        if self.copy_models != false {
            my_size += 1 + 1;
        }
        if self.copy_workflows != false {
            my_size += 1 + 1;
        }
        if self.copy_installed_module_versions != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.copy_inputs != false {
            os.write_bool(1, self.copy_inputs)?;
        }
        if self.copy_concepts != false {
            os.write_bool(2, self.copy_concepts)?;
        }
        if self.copy_annotations != false {
            os.write_bool(3, self.copy_annotations)?;
        }
        if self.copy_models != false {
            os.write_bool(4, self.copy_models)?;
        }
        if self.copy_workflows != false {
            os.write_bool(5, self.copy_workflows)?;
        }
        if self.copy_installed_module_versions != false {
            os.write_bool(6, self.copy_installed_module_versions)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppDuplicationFilters {
        AppDuplicationFilters::new()
    }

    fn clear(&mut self) {
        self.copy_inputs = false;
        self.copy_concepts = false;
        self.copy_annotations = false;
        self.copy_models = false;
        self.copy_workflows = false;
        self.copy_installed_module_versions = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppDuplicationFilters {
        static instance: AppDuplicationFilters = AppDuplicationFilters {
            copy_inputs: false,
            copy_concepts: false,
            copy_annotations: false,
            copy_models: false,
            copy_workflows: false,
            copy_installed_module_versions: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppDuplicationFilters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppDuplicationFilters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppDuplicationFilters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDuplicationFilters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  LabelOrder
// @@protoc_insertion_point(message:clarifai.api.LabelOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LabelOrder {
    // message fields
    ///  id of the order
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.id)
    pub id: ::std::string::String,
    ///  name of the order
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.name)
    pub name: ::std::string::String,
    ///  status of the order.
    ///  pending (QA lead review the order),
    ///  in progress (labeling in progress),
    ///  ready for release (passed clarifai QA and client can review)
    ///  success (released)
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  if set to true, automatically release the labels once passed clarifai review.
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.auto_release)
    pub auto_release: bool,
    ///  allow input without any tag.
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.allow_empty_tag)
    pub allow_empty_tag: bool,
    ///  User desired estimation when the task should be done
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.desired_fulfill_time)
    pub desired_fulfill_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Clarifai estimation when the task should be done .
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.estimate_fulfill_time)
    pub estimate_fulfill_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  task for this label order
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.task)
    pub task: ::protobuf::MessageField<Task>,
    ///  When the label order was created.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Most recent time when the label order was updated.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.LabelOrder.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.LabelOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelOrder {
    fn default() -> &'a LabelOrder {
        <LabelOrder as ::protobuf::Message>::default_instance()
    }
}

impl LabelOrder {
    pub fn new() -> LabelOrder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &LabelOrder| { &m.id },
            |m: &mut LabelOrder| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &LabelOrder| { &m.name },
            |m: &mut LabelOrder| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &LabelOrder| { &m.status },
            |m: &mut LabelOrder| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auto_release",
            |m: &LabelOrder| { &m.auto_release },
            |m: &mut LabelOrder| { &mut m.auto_release },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_empty_tag",
            |m: &LabelOrder| { &m.allow_empty_tag },
            |m: &mut LabelOrder| { &mut m.allow_empty_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "desired_fulfill_time",
            |m: &LabelOrder| { &m.desired_fulfill_time },
            |m: &mut LabelOrder| { &mut m.desired_fulfill_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "estimate_fulfill_time",
            |m: &LabelOrder| { &m.estimate_fulfill_time },
            |m: &mut LabelOrder| { &mut m.estimate_fulfill_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Task>(
            "task",
            |m: &LabelOrder| { &m.task },
            |m: &mut LabelOrder| { &mut m.task },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &LabelOrder| { &m.created_at },
            |m: &mut LabelOrder| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &LabelOrder| { &m.modified_at },
            |m: &mut LabelOrder| { &mut m.modified_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelOrder>(
            "LabelOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelOrder {
    const NAME: &'static str = "LabelOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                32 => {
                    self.auto_release = is.read_bool()?;
                },
                40 => {
                    self.allow_empty_tag = is.read_bool()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.desired_fulfill_time)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.estimate_fulfill_time)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.task)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.auto_release != false {
            my_size += 1 + 1;
        }
        if self.allow_empty_tag != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.desired_fulfill_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.estimate_fulfill_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.task.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.auto_release != false {
            os.write_bool(4, self.auto_release)?;
        }
        if self.allow_empty_tag != false {
            os.write_bool(5, self.allow_empty_tag)?;
        }
        if let Some(v) = self.desired_fulfill_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.estimate_fulfill_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.task.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelOrder {
        LabelOrder::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.status.clear();
        self.auto_release = false;
        self.allow_empty_tag = false;
        self.desired_fulfill_time.clear();
        self.estimate_fulfill_time.clear();
        self.task.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelOrder {
        static instance: LabelOrder = LabelOrder {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            status: ::protobuf::MessageField::none(),
            auto_release: false,
            allow_empty_tag: false,
            desired_fulfill_time: ::protobuf::MessageField::none(),
            estimate_fulfill_time: ::protobuf::MessageField::none(),
            task: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Task is the work that needs to be done for labeling the inputs in an app.
// @@protoc_insertion_point(message:clarifai.api.Task)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Task {
    // message fields
    ///  Unique ID for the task.
    // @@protoc_insertion_point(field:clarifai.api.Task.id)
    pub id: ::std::string::String,
    ///  When the task was created.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.Task.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Most recent time when the task was updated.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.Task.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Task type.
    // @@protoc_insertion_point(field:clarifai.api.Task.type)
    pub type_: ::protobuf::EnumOrUnknown<task::TaskType>,
    ///  Description of the task.
    // @@protoc_insertion_point(field:clarifai.api.Task.description)
    pub description: ::std::string::String,
    ///  Worker details.
    // @@protoc_insertion_point(field:clarifai.api.Task.worker)
    pub worker: ::protobuf::MessageField<TaskWorker>,
    ///  List of concept ids used in the work of this task.
    ///  DEPRECATED: Use task.concepts instead.
    // @@protoc_insertion_point(field:clarifai.api.Task.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    ///  List of inputs used in this task will be taken from this source.
    // @@protoc_insertion_point(field:clarifai.api.Task.input_source)
    pub input_source: ::protobuf::MessageField<TaskInputSource>,
    ///  For model predictions on video: Sample delay for video predicting (1 frame per N milliseconds)
    // @@protoc_insertion_point(field:clarifai.api.Task.sample_ms)
    pub sample_ms: u32,
    ///  AI assistant details.
    // @@protoc_insertion_point(field:clarifai.api.Task.ai_assistant)
    pub ai_assistant: ::protobuf::MessageField<TaskAIAssistant>,
    ///  Review details.
    // @@protoc_insertion_point(field:clarifai.api.Task.review)
    pub review: ::protobuf::MessageField<TaskReview>,
    ///  Status of this task.
    // @@protoc_insertion_point(field:clarifai.api.Task.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  Add a title for this task to quickly recognise it in a list of tasks.
    // @@protoc_insertion_point(field:clarifai.api.Task.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.Task.ai_assist_params)
    pub ai_assist_params: ::protobuf::MessageField<AiAssistParameters>,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    // @@protoc_insertion_point(field:clarifai.api.Task.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  The app the task belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Task.app_id)
    pub app_id: ::std::string::String,
    ///  The user the task belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Task.user_id)
    pub user_id: ::std::string::String,
    ///  The label order the task belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Task.label_order_id)
    pub label_order_id: ::std::string::String,
    ///  Ignore Task.concept_ids field if Task.TaskConcept are supplied.
    // @@protoc_insertion_point(field:clarifai.api.Task.concepts)
    pub concepts: ::std::vec::Vec<TaskConcept>,
    ///  Specify whether existing Annotations within the same app that are generated by other auto annotation tasks
    ///  with the specified Concept from the selected Model or Workflow should deleted before executing the Task
    // @@protoc_insertion_point(field:clarifai.api.Task.delete_previous_annotations)
    pub delete_previous_annotations: bool,
    ///  Tasks metrics are filled in upon user-request.
    // @@protoc_insertion_point(field:clarifai.api.Task.metrics)
    pub metrics: ::protobuf::MessageField<TaskMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Task.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Task {
    fn default() -> &'a Task {
        <Task as ::protobuf::Message>::default_instance()
    }
}

impl Task {
    pub fn new() -> Task {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Task| { &m.id },
            |m: &mut Task| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Task| { &m.created_at },
            |m: &mut Task| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Task| { &m.modified_at },
            |m: &mut Task| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Task| { &m.type_ },
            |m: &mut Task| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Task| { &m.description },
            |m: &mut Task| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TaskWorker>(
            "worker",
            |m: &Task| { &m.worker },
            |m: &mut Task| { &mut m.worker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &Task| { &m.concept_ids },
            |m: &mut Task| { &mut m.concept_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TaskInputSource>(
            "input_source",
            |m: &Task| { &m.input_source },
            |m: &mut Task| { &mut m.input_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_ms",
            |m: &Task| { &m.sample_ms },
            |m: &mut Task| { &mut m.sample_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TaskAIAssistant>(
            "ai_assistant",
            |m: &Task| { &m.ai_assistant },
            |m: &mut Task| { &mut m.ai_assistant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TaskReview>(
            "review",
            |m: &Task| { &m.review },
            |m: &mut Task| { &mut m.review },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &Task| { &m.status },
            |m: &mut Task| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Task| { &m.name },
            |m: &mut Task| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AiAssistParameters>(
            "ai_assist_params",
            |m: &Task| { &m.ai_assist_params },
            |m: &mut Task| { &mut m.ai_assist_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &Task| { &m.visibility },
            |m: &mut Task| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &Task| { &m.app_id },
            |m: &mut Task| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Task| { &m.user_id },
            |m: &mut Task| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label_order_id",
            |m: &Task| { &m.label_order_id },
            |m: &mut Task| { &mut m.label_order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &Task| { &m.concepts },
            |m: &mut Task| { &mut m.concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_previous_annotations",
            |m: &Task| { &m.delete_previous_annotations },
            |m: &mut Task| { &mut m.delete_previous_annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TaskMetrics>(
            "metrics",
            |m: &Task| { &m.metrics },
            |m: &mut Task| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Task>(
            "Task",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Task {
    const NAME: &'static str = "Task";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                32 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.description = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.worker)?;
                },
                58 => {
                    self.concept_ids.push(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input_source)?;
                },
                72 => {
                    self.sample_ms = is.read_uint32()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ai_assistant)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.review)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                106 => {
                    self.name = is.read_string()?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ai_assist_params)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                130 => {
                    self.app_id = is.read_string()?;
                },
                138 => {
                    self.user_id = is.read_string()?;
                },
                146 => {
                    self.label_order_id = is.read_string()?;
                },
                154 => {
                    self.concepts.push(is.read_message()?);
                },
                160 => {
                    self.delete_previous_annotations = is.read_bool()?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(task::TaskType::TYPE_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(4, self.type_.value());
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.description);
        }
        if let Some(v) = self.worker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.input_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.sample_ms != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.sample_ms);
        }
        if let Some(v) = self.ai_assistant.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.review.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.name);
        }
        if let Some(v) = self.ai_assist_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.user_id);
        }
        if !self.label_order_id.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.label_order_id);
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.delete_previous_annotations != false {
            my_size += 2 + 1;
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(task::TaskType::TYPE_NOT_SET) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.description.is_empty() {
            os.write_string(5, &self.description)?;
        }
        if let Some(v) = self.worker.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.concept_ids {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.input_source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.sample_ms != 0 {
            os.write_uint32(9, self.sample_ms)?;
        }
        if let Some(v) = self.ai_assistant.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.review.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(13, &self.name)?;
        }
        if let Some(v) = self.ai_assist_params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(16, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(17, &self.user_id)?;
        }
        if !self.label_order_id.is_empty() {
            os.write_string(18, &self.label_order_id)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        if self.delete_previous_annotations != false {
            os.write_bool(20, self.delete_previous_annotations)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Task {
        Task::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(task::TaskType::TYPE_NOT_SET);
        self.description.clear();
        self.worker.clear();
        self.concept_ids.clear();
        self.input_source.clear();
        self.sample_ms = 0;
        self.ai_assistant.clear();
        self.review.clear();
        self.status.clear();
        self.name.clear();
        self.ai_assist_params.clear();
        self.visibility.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.label_order_id.clear();
        self.concepts.clear();
        self.delete_previous_annotations = false;
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Task {
        static instance: Task = Task {
            id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            description: ::std::string::String::new(),
            worker: ::protobuf::MessageField::none(),
            concept_ids: ::std::vec::Vec::new(),
            input_source: ::protobuf::MessageField::none(),
            sample_ms: 0,
            ai_assistant: ::protobuf::MessageField::none(),
            review: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            ai_assist_params: ::protobuf::MessageField::none(),
            visibility: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            label_order_id: ::std::string::String::new(),
            concepts: ::std::vec::Vec::new(),
            delete_previous_annotations: false,
            metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Task {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Task").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Task {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Task {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Task`
pub mod task {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.Task.TaskType)
    pub enum TaskType {
        // @@protoc_insertion_point(enum_value:clarifai.api.Task.TaskType.TYPE_NOT_SET)
        TYPE_NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.Task.TaskType.CONCEPTS_CLASSIFICATION)
        CONCEPTS_CLASSIFICATION = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.Task.TaskType.BOUNDING_BOX_DETECTION)
        BOUNDING_BOX_DETECTION = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.Task.TaskType.POLYGON_DETECTION)
        POLYGON_DETECTION = 3,
    }

    impl ::protobuf::Enum for TaskType {
        const NAME: &'static str = "TaskType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TaskType> {
            match value {
                0 => ::std::option::Option::Some(TaskType::TYPE_NOT_SET),
                1 => ::std::option::Option::Some(TaskType::CONCEPTS_CLASSIFICATION),
                2 => ::std::option::Option::Some(TaskType::BOUNDING_BOX_DETECTION),
                3 => ::std::option::Option::Some(TaskType::POLYGON_DETECTION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<TaskType> {
            match str {
                "TYPE_NOT_SET" => ::std::option::Option::Some(TaskType::TYPE_NOT_SET),
                "CONCEPTS_CLASSIFICATION" => ::std::option::Option::Some(TaskType::CONCEPTS_CLASSIFICATION),
                "BOUNDING_BOX_DETECTION" => ::std::option::Option::Some(TaskType::BOUNDING_BOX_DETECTION),
                "POLYGON_DETECTION" => ::std::option::Option::Some(TaskType::POLYGON_DETECTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TaskType] = &[
            TaskType::TYPE_NOT_SET,
            TaskType::CONCEPTS_CLASSIFICATION,
            TaskType::BOUNDING_BOX_DETECTION,
            TaskType::POLYGON_DETECTION,
        ];
    }

    impl ::protobuf::EnumFull for TaskType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Task.TaskType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TaskType {
        fn default() -> Self {
            TaskType::TYPE_NOT_SET
        }
    }

    impl TaskType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TaskType>("Task.TaskType")
        }
    }
}

///  AiAssistParameters
// @@protoc_insertion_point(message:clarifai.api.AiAssistParameters)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AiAssistParameters {
    // message fields
    ///  Min and max threshold values for approving annotations by default based on prediction score
    // @@protoc_insertion_point(field:clarifai.api.AiAssistParameters.min_threshold)
    pub min_threshold: f32,
    // @@protoc_insertion_point(field:clarifai.api.AiAssistParameters.max_threshold)
    pub max_threshold: f32,
    ///  ids of concept relations. Used in AI assist workflow
    // @@protoc_insertion_point(field:clarifai.api.AiAssistParameters.concept_relation_ids)
    pub concept_relation_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AiAssistParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AiAssistParameters {
    fn default() -> &'a AiAssistParameters {
        <AiAssistParameters as ::protobuf::Message>::default_instance()
    }
}

impl AiAssistParameters {
    pub fn new() -> AiAssistParameters {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_threshold",
            |m: &AiAssistParameters| { &m.min_threshold },
            |m: &mut AiAssistParameters| { &mut m.min_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_threshold",
            |m: &AiAssistParameters| { &m.max_threshold },
            |m: &mut AiAssistParameters| { &mut m.max_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_relation_ids",
            |m: &AiAssistParameters| { &m.concept_relation_ids },
            |m: &mut AiAssistParameters| { &mut m.concept_relation_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AiAssistParameters>(
            "AiAssistParameters",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AiAssistParameters {
    const NAME: &'static str = "AiAssistParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.min_threshold = is.read_float()?;
                },
                21 => {
                    self.max_threshold = is.read_float()?;
                },
                26 => {
                    self.concept_relation_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.min_threshold != 0. {
            my_size += 1 + 4;
        }
        if self.max_threshold != 0. {
            my_size += 1 + 4;
        }
        for value in &self.concept_relation_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.min_threshold != 0. {
            os.write_float(1, self.min_threshold)?;
        }
        if self.max_threshold != 0. {
            os.write_float(2, self.max_threshold)?;
        }
        for v in &self.concept_relation_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AiAssistParameters {
        AiAssistParameters::new()
    }

    fn clear(&mut self) {
        self.min_threshold = 0.;
        self.max_threshold = 0.;
        self.concept_relation_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AiAssistParameters {
        static instance: AiAssistParameters = AiAssistParameters {
            min_threshold: 0.,
            max_threshold: 0.,
            concept_relation_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AiAssistParameters {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AiAssistParameters").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AiAssistParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AiAssistParameters {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TaskWorker includes information about the workers that will work on this task.
// @@protoc_insertion_point(message:clarifai.api.TaskWorker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskWorker {
    // message fields
    ///  Worker strategy.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorker.strategy)
    pub strategy: ::protobuf::EnumOrUnknown<task_worker::TaskWorkerStrategy>,
    ///  Who will work on this task.
    ///  DEPRECATED: Use workers.user.id instead.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorker.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Users who will work on this task.
    ///  When the 'worker.users' field is additionally requested, then all user
    ///  info is filled for the workers. Otherwise, only the user 'id' is filled.
    ///  DEPRECATED: Use workers.user instead.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorker.users)
    pub users: ::std::vec::Vec<User>,
    ///  Workers that will work on this task.
    ///
    ///  For Auto Annotation Tasks:
    ///    the worker can be either a model or a workflow;
    ///    currently only supports 1 worker.
    ///  For manual labeling Tasks:
    ///    the workers can only be users;
    ///    no limitation on number of workers.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorker.workers)
    pub workers: ::std::vec::Vec<Worker>,
    // message oneof groups
    pub strategy_info: ::std::option::Option<task_worker::Strategy_info>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskWorker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskWorker {
    fn default() -> &'a TaskWorker {
        <TaskWorker as ::protobuf::Message>::default_instance()
    }
}

impl TaskWorker {
    pub fn new() -> TaskWorker {
        ::std::default::Default::default()
    }

    // .clarifai.api.TaskWorkerPartitionedStrategyInfo partitioned_strategy_info = 3;

    pub fn partitioned_strategy_info(&self) -> &TaskWorkerPartitionedStrategyInfo {
        match self.strategy_info {
            ::std::option::Option::Some(task_worker::Strategy_info::PartitionedStrategyInfo(ref v)) => v,
            _ => <TaskWorkerPartitionedStrategyInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_partitioned_strategy_info(&mut self) {
        self.strategy_info = ::std::option::Option::None;
    }

    pub fn has_partitioned_strategy_info(&self) -> bool {
        match self.strategy_info {
            ::std::option::Option::Some(task_worker::Strategy_info::PartitionedStrategyInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_partitioned_strategy_info(&mut self, v: TaskWorkerPartitionedStrategyInfo) {
        self.strategy_info = ::std::option::Option::Some(task_worker::Strategy_info::PartitionedStrategyInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_partitioned_strategy_info(&mut self) -> &mut TaskWorkerPartitionedStrategyInfo {
        if let ::std::option::Option::Some(task_worker::Strategy_info::PartitionedStrategyInfo(_)) = self.strategy_info {
        } else {
            self.strategy_info = ::std::option::Option::Some(task_worker::Strategy_info::PartitionedStrategyInfo(TaskWorkerPartitionedStrategyInfo::new()));
        }
        match self.strategy_info {
            ::std::option::Option::Some(task_worker::Strategy_info::PartitionedStrategyInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_partitioned_strategy_info(&mut self) -> TaskWorkerPartitionedStrategyInfo {
        if self.has_partitioned_strategy_info() {
            match self.strategy_info.take() {
                ::std::option::Option::Some(task_worker::Strategy_info::PartitionedStrategyInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            TaskWorkerPartitionedStrategyInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "strategy",
            |m: &TaskWorker| { &m.strategy },
            |m: &mut TaskWorker| { &mut m.strategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &TaskWorker| { &m.user_ids },
            |m: &mut TaskWorker| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "users",
            |m: &TaskWorker| { &m.users },
            |m: &mut TaskWorker| { &mut m.users },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TaskWorkerPartitionedStrategyInfo>(
            "partitioned_strategy_info",
            TaskWorker::has_partitioned_strategy_info,
            TaskWorker::partitioned_strategy_info,
            TaskWorker::mut_partitioned_strategy_info,
            TaskWorker::set_partitioned_strategy_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workers",
            |m: &TaskWorker| { &m.workers },
            |m: &mut TaskWorker| { &mut m.workers },
        ));
        oneofs.push(task_worker::Strategy_info::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskWorker>(
            "TaskWorker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskWorker {
    const NAME: &'static str = "TaskWorker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strategy = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.user_ids.push(is.read_string()?);
                },
                34 => {
                    self.users.push(is.read_message()?);
                },
                26 => {
                    self.strategy_info = ::std::option::Option::Some(task_worker::Strategy_info::PartitionedStrategyInfo(is.read_message()?));
                },
                58 => {
                    self.workers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.strategy != ::protobuf::EnumOrUnknown::new(task_worker::TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.strategy.value());
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.workers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.strategy_info {
            match v {
                &task_worker::Strategy_info::PartitionedStrategyInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.strategy != ::protobuf::EnumOrUnknown::new(task_worker::TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.strategy))?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.users {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.workers {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.strategy_info {
            match v {
                &task_worker::Strategy_info::PartitionedStrategyInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskWorker {
        TaskWorker::new()
    }

    fn clear(&mut self) {
        self.strategy = ::protobuf::EnumOrUnknown::new(task_worker::TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET);
        self.user_ids.clear();
        self.users.clear();
        self.strategy_info = ::std::option::Option::None;
        self.workers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskWorker {
        static instance: TaskWorker = TaskWorker {
            strategy: ::protobuf::EnumOrUnknown::from_i32(0),
            user_ids: ::std::vec::Vec::new(),
            users: ::std::vec::Vec::new(),
            workers: ::std::vec::Vec::new(),
            strategy_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskWorker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskWorker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskWorker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskWorker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TaskWorker`
pub mod task_worker {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.TaskWorker.strategy_info)
    pub enum Strategy_info {
        // @@protoc_insertion_point(oneof_field:clarifai.api.TaskWorker.partitioned_strategy_info)
        PartitionedStrategyInfo(super::TaskWorkerPartitionedStrategyInfo),
    }

    impl ::protobuf::Oneof for Strategy_info {
    }

    impl ::protobuf::OneofFull for Strategy_info {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TaskWorker as ::protobuf::MessageFull>::descriptor().oneof_by_name("strategy_info").unwrap()).clone()
        }
    }

    impl Strategy_info {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Strategy_info>("strategy_info")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.TaskWorker.TaskWorkerStrategy)
    pub enum TaskWorkerStrategy {
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskWorker.TaskWorkerStrategy.WORKER_STRATEGY_NOT_SET)
        WORKER_STRATEGY_NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskWorker.TaskWorkerStrategy.PARTITIONED)
        PARTITIONED = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskWorker.TaskWorkerStrategy.FULL)
        FULL = 3,
    }

    impl ::protobuf::Enum for TaskWorkerStrategy {
        const NAME: &'static str = "TaskWorkerStrategy";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TaskWorkerStrategy> {
            match value {
                0 => ::std::option::Option::Some(TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET),
                2 => ::std::option::Option::Some(TaskWorkerStrategy::PARTITIONED),
                3 => ::std::option::Option::Some(TaskWorkerStrategy::FULL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<TaskWorkerStrategy> {
            match str {
                "WORKER_STRATEGY_NOT_SET" => ::std::option::Option::Some(TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET),
                "PARTITIONED" => ::std::option::Option::Some(TaskWorkerStrategy::PARTITIONED),
                "FULL" => ::std::option::Option::Some(TaskWorkerStrategy::FULL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TaskWorkerStrategy] = &[
            TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET,
            TaskWorkerStrategy::PARTITIONED,
            TaskWorkerStrategy::FULL,
        ];
    }

    impl ::protobuf::EnumFull for TaskWorkerStrategy {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TaskWorker.TaskWorkerStrategy").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET => 0,
                TaskWorkerStrategy::PARTITIONED => 1,
                TaskWorkerStrategy::FULL => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TaskWorkerStrategy {
        fn default() -> Self {
            TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET
        }
    }

    impl TaskWorkerStrategy {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TaskWorkerStrategy>("TaskWorker.TaskWorkerStrategy")
        }
    }
}

///  TaskWorkerPartitionedStrategyInfo
// @@protoc_insertion_point(message:clarifai.api.TaskWorkerPartitionedStrategyInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskWorkerPartitionedStrategyInfo {
    // message fields
    ///  Define how the partitioning should work.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorkerPartitionedStrategyInfo.type)
    pub type_: ::protobuf::EnumOrUnknown<task_worker_partitioned_strategy_info::TaskWorkerPartitionedStrategy>,
    ///  How many workers will label each input.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorkerPartitionedStrategyInfo.workers_per_input)
    pub workers_per_input: i32,
    ///  In case of weighted partitioning, map user ids to weights.
    ///  Each labeler will be assigned work proportional to its own weight as compared to the sum of total weight.
    ///
    ///  EXAMPLE:
    ///  If we have 3 workers, and weights = {1: 30, 2: 30, 3: 40},
    ///  then first worker will have assigned 30% of the work,
    ///  second worker will have assigned 30% of the work,
    ///  and third worker will have assigned 40% of the work.
    ///  You may use weights which add up to 100, but it's not necessary.
    ///  For example, weights {1: 30, 2: 30, 3: 40} are equivalent with {1: 3, 2: 3, 3: 4}
    ///  because they represent the same percentages: {1: 30%, 2: 30%, 3: 40%}.
    ///
    ///  NOTE:
    ///  Note that no worker should be assigned a weight percentage greater than 1/workers_per_input.
    ///  It is mathematically impossible to partition the work in such a case.
    ///  Why? Say, we have 3 workers. And workers_per_input = 2, i.e. each input must be labeled by 2 workers.
    ///  Let's assign weights {1: 51%, 2: 25%, 3: 24%}.
    ///  Note that first worker has a weight percentage higher than 1/workers_per_input = 1/2 = 50%.
    ///  If we have 100 inputs, then a total of 100 * workers_per_input = 200 cumulative inputs will be labeled by these 3 workers.
    ///  Worker 1 should label 102 cumulative inputs, while worker 2 and worker 3 will label 98 cumulative inputs together.
    ///  No matter how we assign the 98 cumulative inputs, the 2 workers will be able to label up to 98 actual inputs.
    ///  This means the remaining 2 inputs will be labeled only by worker 1. This contradicts the worker_per_input = 2 requirement.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorkerPartitionedStrategyInfo.weights)
    pub weights: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskWorkerPartitionedStrategyInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskWorkerPartitionedStrategyInfo {
    fn default() -> &'a TaskWorkerPartitionedStrategyInfo {
        <TaskWorkerPartitionedStrategyInfo as ::protobuf::Message>::default_instance()
    }
}

impl TaskWorkerPartitionedStrategyInfo {
    pub fn new() -> TaskWorkerPartitionedStrategyInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TaskWorkerPartitionedStrategyInfo| { &m.type_ },
            |m: &mut TaskWorkerPartitionedStrategyInfo| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workers_per_input",
            |m: &TaskWorkerPartitionedStrategyInfo| { &m.workers_per_input },
            |m: &mut TaskWorkerPartitionedStrategyInfo| { &mut m.workers_per_input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "weights",
            |m: &TaskWorkerPartitionedStrategyInfo| { &m.weights },
            |m: &mut TaskWorkerPartitionedStrategyInfo| { &mut m.weights },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskWorkerPartitionedStrategyInfo>(
            "TaskWorkerPartitionedStrategyInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskWorkerPartitionedStrategyInfo {
    const NAME: &'static str = "TaskWorkerPartitionedStrategyInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.workers_per_input = is.read_int32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.weights)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(task_worker_partitioned_strategy_info::TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.workers_per_input != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.workers_per_input);
        }
        if let Some(v) = self.weights.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(task_worker_partitioned_strategy_info::TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.workers_per_input != 0 {
            os.write_int32(2, self.workers_per_input)?;
        }
        if let Some(v) = self.weights.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskWorkerPartitionedStrategyInfo {
        TaskWorkerPartitionedStrategyInfo::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(task_worker_partitioned_strategy_info::TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET);
        self.workers_per_input = 0;
        self.weights.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskWorkerPartitionedStrategyInfo {
        static instance: TaskWorkerPartitionedStrategyInfo = TaskWorkerPartitionedStrategyInfo {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            workers_per_input: 0,
            weights: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskWorkerPartitionedStrategyInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskWorkerPartitionedStrategyInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskWorkerPartitionedStrategyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskWorkerPartitionedStrategyInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TaskWorkerPartitionedStrategyInfo`
pub mod task_worker_partitioned_strategy_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy)
    pub enum TaskWorkerPartitionedStrategy {
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy.PARTITIONED_WORKER_STRATEGY_NOT_SET)
        PARTITIONED_WORKER_STRATEGY_NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy.EVENLY)
        EVENLY = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy.WEIGHTED)
        WEIGHTED = 2,
    }

    impl ::protobuf::Enum for TaskWorkerPartitionedStrategy {
        const NAME: &'static str = "TaskWorkerPartitionedStrategy";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TaskWorkerPartitionedStrategy> {
            match value {
                0 => ::std::option::Option::Some(TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET),
                1 => ::std::option::Option::Some(TaskWorkerPartitionedStrategy::EVENLY),
                2 => ::std::option::Option::Some(TaskWorkerPartitionedStrategy::WEIGHTED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<TaskWorkerPartitionedStrategy> {
            match str {
                "PARTITIONED_WORKER_STRATEGY_NOT_SET" => ::std::option::Option::Some(TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET),
                "EVENLY" => ::std::option::Option::Some(TaskWorkerPartitionedStrategy::EVENLY),
                "WEIGHTED" => ::std::option::Option::Some(TaskWorkerPartitionedStrategy::WEIGHTED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TaskWorkerPartitionedStrategy] = &[
            TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET,
            TaskWorkerPartitionedStrategy::EVENLY,
            TaskWorkerPartitionedStrategy::WEIGHTED,
        ];
    }

    impl ::protobuf::EnumFull for TaskWorkerPartitionedStrategy {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TaskWorkerPartitionedStrategy {
        fn default() -> Self {
            TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET
        }
    }

    impl TaskWorkerPartitionedStrategy {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TaskWorkerPartitionedStrategy>("TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy")
        }
    }
}

///  TaskInputSource
// @@protoc_insertion_point(message:clarifai.api.TaskInputSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskInputSource {
    // message fields
    ///  Type of input source.
    // @@protoc_insertion_point(field:clarifai.api.TaskInputSource.type)
    pub type_: ::protobuf::EnumOrUnknown<task_input_source::TaskInputSourceType>,
    ///  If type is SAVED_SEARCH, then this is the saved search id.
    // @@protoc_insertion_point(field:clarifai.api.TaskInputSource.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskInputSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskInputSource {
    fn default() -> &'a TaskInputSource {
        <TaskInputSource as ::protobuf::Message>::default_instance()
    }
}

impl TaskInputSource {
    pub fn new() -> TaskInputSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TaskInputSource| { &m.type_ },
            |m: &mut TaskInputSource| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &TaskInputSource| { &m.id },
            |m: &mut TaskInputSource| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskInputSource>(
            "TaskInputSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskInputSource {
    const NAME: &'static str = "TaskInputSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(task_input_source::TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(task_input_source::TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskInputSource {
        TaskInputSource::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(task_input_source::TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET);
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskInputSource {
        static instance: TaskInputSource = TaskInputSource {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskInputSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskInputSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskInputSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskInputSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TaskInputSource`
pub mod task_input_source {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.TaskInputSource.TaskInputSourceType)
    pub enum TaskInputSourceType {
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskInputSource.TaskInputSourceType.INPUT_SOURCE_TYPE_NOT_SET)
        INPUT_SOURCE_TYPE_NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskInputSource.TaskInputSourceType.ALL_INPUTS)
        ALL_INPUTS = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskInputSource.TaskInputSourceType.SAVED_SEARCH)
        SAVED_SEARCH = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskInputSource.TaskInputSourceType.DATASET)
        DATASET = 3,
    }

    impl ::protobuf::Enum for TaskInputSourceType {
        const NAME: &'static str = "TaskInputSourceType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TaskInputSourceType> {
            match value {
                0 => ::std::option::Option::Some(TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET),
                1 => ::std::option::Option::Some(TaskInputSourceType::ALL_INPUTS),
                2 => ::std::option::Option::Some(TaskInputSourceType::SAVED_SEARCH),
                3 => ::std::option::Option::Some(TaskInputSourceType::DATASET),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<TaskInputSourceType> {
            match str {
                "INPUT_SOURCE_TYPE_NOT_SET" => ::std::option::Option::Some(TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET),
                "ALL_INPUTS" => ::std::option::Option::Some(TaskInputSourceType::ALL_INPUTS),
                "SAVED_SEARCH" => ::std::option::Option::Some(TaskInputSourceType::SAVED_SEARCH),
                "DATASET" => ::std::option::Option::Some(TaskInputSourceType::DATASET),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TaskInputSourceType] = &[
            TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET,
            TaskInputSourceType::ALL_INPUTS,
            TaskInputSourceType::SAVED_SEARCH,
            TaskInputSourceType::DATASET,
        ];
    }

    impl ::protobuf::EnumFull for TaskInputSourceType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TaskInputSource.TaskInputSourceType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TaskInputSourceType {
        fn default() -> Self {
            TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET
        }
    }

    impl TaskInputSourceType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TaskInputSourceType>("TaskInputSource.TaskInputSourceType")
        }
    }
}

///  TaskReview
// @@protoc_insertion_point(message:clarifai.api.TaskReview)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskReview {
    // message fields
    ///  Task review strategy.
    // @@protoc_insertion_point(field:clarifai.api.TaskReview.strategy)
    pub strategy: ::protobuf::EnumOrUnknown<task_review::TaskReviewStrategy>,
    ///  Who will review this task.
    ///  DEPRECATED: Use users.id instead.
    // @@protoc_insertion_point(field:clarifai.api.TaskReview.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Users who will review this task.
    ///  When the 'review.users' field is additionally requested, then all user
    ///  info is filled for the reviewers. Otherwise, only the user 'id' is filled.
    // @@protoc_insertion_point(field:clarifai.api.TaskReview.users)
    pub users: ::std::vec::Vec<User>,
    // message oneof groups
    pub strategy_info: ::std::option::Option<task_review::Strategy_info>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskReview.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskReview {
    fn default() -> &'a TaskReview {
        <TaskReview as ::protobuf::Message>::default_instance()
    }
}

impl TaskReview {
    pub fn new() -> TaskReview {
        ::std::default::Default::default()
    }

    // .clarifai.api.TaskReviewManualStrategyInfo manual_strategy_info = 3;

    pub fn manual_strategy_info(&self) -> &TaskReviewManualStrategyInfo {
        match self.strategy_info {
            ::std::option::Option::Some(task_review::Strategy_info::ManualStrategyInfo(ref v)) => v,
            _ => <TaskReviewManualStrategyInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_manual_strategy_info(&mut self) {
        self.strategy_info = ::std::option::Option::None;
    }

    pub fn has_manual_strategy_info(&self) -> bool {
        match self.strategy_info {
            ::std::option::Option::Some(task_review::Strategy_info::ManualStrategyInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_manual_strategy_info(&mut self, v: TaskReviewManualStrategyInfo) {
        self.strategy_info = ::std::option::Option::Some(task_review::Strategy_info::ManualStrategyInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_manual_strategy_info(&mut self) -> &mut TaskReviewManualStrategyInfo {
        if let ::std::option::Option::Some(task_review::Strategy_info::ManualStrategyInfo(_)) = self.strategy_info {
        } else {
            self.strategy_info = ::std::option::Option::Some(task_review::Strategy_info::ManualStrategyInfo(TaskReviewManualStrategyInfo::new()));
        }
        match self.strategy_info {
            ::std::option::Option::Some(task_review::Strategy_info::ManualStrategyInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_manual_strategy_info(&mut self) -> TaskReviewManualStrategyInfo {
        if self.has_manual_strategy_info() {
            match self.strategy_info.take() {
                ::std::option::Option::Some(task_review::Strategy_info::ManualStrategyInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            TaskReviewManualStrategyInfo::new()
        }
    }

    // .clarifai.api.TaskReviewConsensusStrategyInfo consensus_strategy_info = 4;

    pub fn consensus_strategy_info(&self) -> &TaskReviewConsensusStrategyInfo {
        match self.strategy_info {
            ::std::option::Option::Some(task_review::Strategy_info::ConsensusStrategyInfo(ref v)) => v,
            _ => <TaskReviewConsensusStrategyInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_consensus_strategy_info(&mut self) {
        self.strategy_info = ::std::option::Option::None;
    }

    pub fn has_consensus_strategy_info(&self) -> bool {
        match self.strategy_info {
            ::std::option::Option::Some(task_review::Strategy_info::ConsensusStrategyInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_consensus_strategy_info(&mut self, v: TaskReviewConsensusStrategyInfo) {
        self.strategy_info = ::std::option::Option::Some(task_review::Strategy_info::ConsensusStrategyInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_consensus_strategy_info(&mut self) -> &mut TaskReviewConsensusStrategyInfo {
        if let ::std::option::Option::Some(task_review::Strategy_info::ConsensusStrategyInfo(_)) = self.strategy_info {
        } else {
            self.strategy_info = ::std::option::Option::Some(task_review::Strategy_info::ConsensusStrategyInfo(TaskReviewConsensusStrategyInfo::new()));
        }
        match self.strategy_info {
            ::std::option::Option::Some(task_review::Strategy_info::ConsensusStrategyInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_consensus_strategy_info(&mut self) -> TaskReviewConsensusStrategyInfo {
        if self.has_consensus_strategy_info() {
            match self.strategy_info.take() {
                ::std::option::Option::Some(task_review::Strategy_info::ConsensusStrategyInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            TaskReviewConsensusStrategyInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "strategy",
            |m: &TaskReview| { &m.strategy },
            |m: &mut TaskReview| { &mut m.strategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &TaskReview| { &m.user_ids },
            |m: &mut TaskReview| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "users",
            |m: &TaskReview| { &m.users },
            |m: &mut TaskReview| { &mut m.users },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TaskReviewManualStrategyInfo>(
            "manual_strategy_info",
            TaskReview::has_manual_strategy_info,
            TaskReview::manual_strategy_info,
            TaskReview::mut_manual_strategy_info,
            TaskReview::set_manual_strategy_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TaskReviewConsensusStrategyInfo>(
            "consensus_strategy_info",
            TaskReview::has_consensus_strategy_info,
            TaskReview::consensus_strategy_info,
            TaskReview::mut_consensus_strategy_info,
            TaskReview::set_consensus_strategy_info,
        ));
        oneofs.push(task_review::Strategy_info::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskReview>(
            "TaskReview",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskReview {
    const NAME: &'static str = "TaskReview";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strategy = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.user_ids.push(is.read_string()?);
                },
                42 => {
                    self.users.push(is.read_message()?);
                },
                26 => {
                    self.strategy_info = ::std::option::Option::Some(task_review::Strategy_info::ManualStrategyInfo(is.read_message()?));
                },
                34 => {
                    self.strategy_info = ::std::option::Option::Some(task_review::Strategy_info::ConsensusStrategyInfo(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.strategy != ::protobuf::EnumOrUnknown::new(task_review::TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.strategy.value());
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.strategy_info {
            match v {
                &task_review::Strategy_info::ManualStrategyInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &task_review::Strategy_info::ConsensusStrategyInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.strategy != ::protobuf::EnumOrUnknown::new(task_review::TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.strategy))?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.users {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.strategy_info {
            match v {
                &task_review::Strategy_info::ManualStrategyInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &task_review::Strategy_info::ConsensusStrategyInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskReview {
        TaskReview::new()
    }

    fn clear(&mut self) {
        self.strategy = ::protobuf::EnumOrUnknown::new(task_review::TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET);
        self.user_ids.clear();
        self.users.clear();
        self.strategy_info = ::std::option::Option::None;
        self.strategy_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskReview {
        static instance: TaskReview = TaskReview {
            strategy: ::protobuf::EnumOrUnknown::from_i32(0),
            user_ids: ::std::vec::Vec::new(),
            users: ::std::vec::Vec::new(),
            strategy_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskReview {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskReview").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskReview {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TaskReview`
pub mod task_review {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.TaskReview.strategy_info)
    pub enum Strategy_info {
        // @@protoc_insertion_point(oneof_field:clarifai.api.TaskReview.manual_strategy_info)
        ManualStrategyInfo(super::TaskReviewManualStrategyInfo),
        // @@protoc_insertion_point(oneof_field:clarifai.api.TaskReview.consensus_strategy_info)
        ConsensusStrategyInfo(super::TaskReviewConsensusStrategyInfo),
    }

    impl ::protobuf::Oneof for Strategy_info {
    }

    impl ::protobuf::OneofFull for Strategy_info {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TaskReview as ::protobuf::MessageFull>::descriptor().oneof_by_name("strategy_info").unwrap()).clone()
        }
    }

    impl Strategy_info {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Strategy_info>("strategy_info")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.TaskReview.TaskReviewStrategy)
    pub enum TaskReviewStrategy {
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskReview.TaskReviewStrategy.TASK_REVIEW_STRATEGY_NOT_SET)
        TASK_REVIEW_STRATEGY_NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskReview.TaskReviewStrategy.NONE)
        NONE = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskReview.TaskReviewStrategy.MANUAL)
        MANUAL = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.TaskReview.TaskReviewStrategy.CONSENSUS)
        CONSENSUS = 3,
    }

    impl ::protobuf::Enum for TaskReviewStrategy {
        const NAME: &'static str = "TaskReviewStrategy";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TaskReviewStrategy> {
            match value {
                0 => ::std::option::Option::Some(TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET),
                1 => ::std::option::Option::Some(TaskReviewStrategy::NONE),
                2 => ::std::option::Option::Some(TaskReviewStrategy::MANUAL),
                3 => ::std::option::Option::Some(TaskReviewStrategy::CONSENSUS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<TaskReviewStrategy> {
            match str {
                "TASK_REVIEW_STRATEGY_NOT_SET" => ::std::option::Option::Some(TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET),
                "NONE" => ::std::option::Option::Some(TaskReviewStrategy::NONE),
                "MANUAL" => ::std::option::Option::Some(TaskReviewStrategy::MANUAL),
                "CONSENSUS" => ::std::option::Option::Some(TaskReviewStrategy::CONSENSUS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TaskReviewStrategy] = &[
            TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET,
            TaskReviewStrategy::NONE,
            TaskReviewStrategy::MANUAL,
            TaskReviewStrategy::CONSENSUS,
        ];
    }

    impl ::protobuf::EnumFull for TaskReviewStrategy {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TaskReview.TaskReviewStrategy").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TaskReviewStrategy {
        fn default() -> Self {
            TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET
        }
    }

    impl TaskReviewStrategy {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TaskReviewStrategy>("TaskReview.TaskReviewStrategy")
        }
    }
}

///  TaskReviewManualStrategyInfo
// @@protoc_insertion_point(message:clarifai.api.TaskReviewManualStrategyInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskReviewManualStrategyInfo {
    // message fields
    ///  This field represents the percentage of inputs that will be reviewed by reviewers. It is a value between 0 and 1.
    // @@protoc_insertion_point(field:clarifai.api.TaskReviewManualStrategyInfo.sample_percentage)
    pub sample_percentage: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskReviewManualStrategyInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskReviewManualStrategyInfo {
    fn default() -> &'a TaskReviewManualStrategyInfo {
        <TaskReviewManualStrategyInfo as ::protobuf::Message>::default_instance()
    }
}

impl TaskReviewManualStrategyInfo {
    pub fn new() -> TaskReviewManualStrategyInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_percentage",
            |m: &TaskReviewManualStrategyInfo| { &m.sample_percentage },
            |m: &mut TaskReviewManualStrategyInfo| { &mut m.sample_percentage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskReviewManualStrategyInfo>(
            "TaskReviewManualStrategyInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskReviewManualStrategyInfo {
    const NAME: &'static str = "TaskReviewManualStrategyInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.sample_percentage = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sample_percentage != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sample_percentage != 0. {
            os.write_float(1, self.sample_percentage)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskReviewManualStrategyInfo {
        TaskReviewManualStrategyInfo::new()
    }

    fn clear(&mut self) {
        self.sample_percentage = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskReviewManualStrategyInfo {
        static instance: TaskReviewManualStrategyInfo = TaskReviewManualStrategyInfo {
            sample_percentage: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskReviewManualStrategyInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskReviewManualStrategyInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskReviewManualStrategyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskReviewManualStrategyInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TaskReviewConsensusStrategyInfo
// @@protoc_insertion_point(message:clarifai.api.TaskReviewConsensusStrategyInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskReviewConsensusStrategyInfo {
    // message fields
    ///  The number of labelers that need to agree in order to automatically approve an annotation.
    // @@protoc_insertion_point(field:clarifai.api.TaskReviewConsensusStrategyInfo.approval_threshold)
    pub approval_threshold: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskReviewConsensusStrategyInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskReviewConsensusStrategyInfo {
    fn default() -> &'a TaskReviewConsensusStrategyInfo {
        <TaskReviewConsensusStrategyInfo as ::protobuf::Message>::default_instance()
    }
}

impl TaskReviewConsensusStrategyInfo {
    pub fn new() -> TaskReviewConsensusStrategyInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "approval_threshold",
            |m: &TaskReviewConsensusStrategyInfo| { &m.approval_threshold },
            |m: &mut TaskReviewConsensusStrategyInfo| { &mut m.approval_threshold },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskReviewConsensusStrategyInfo>(
            "TaskReviewConsensusStrategyInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskReviewConsensusStrategyInfo {
    const NAME: &'static str = "TaskReviewConsensusStrategyInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.approval_threshold = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.approval_threshold != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.approval_threshold);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.approval_threshold != 0 {
            os.write_uint32(2, self.approval_threshold)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskReviewConsensusStrategyInfo {
        TaskReviewConsensusStrategyInfo::new()
    }

    fn clear(&mut self) {
        self.approval_threshold = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskReviewConsensusStrategyInfo {
        static instance: TaskReviewConsensusStrategyInfo = TaskReviewConsensusStrategyInfo {
            approval_threshold: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskReviewConsensusStrategyInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskReviewConsensusStrategyInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskReviewConsensusStrategyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskReviewConsensusStrategyInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TaskAIAssistant
// @@protoc_insertion_point(message:clarifai.api.TaskAIAssistant)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskAIAssistant {
    // message fields
    ///  The worker is helped by an AI assistant.
    ///  This field is the workflow id which is used to assist the worker with predictions.
    ///  If empty, then AI assistant is disabled.
    // @@protoc_insertion_point(field:clarifai.api.TaskAIAssistant.workflow_id)
    pub workflow_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskAIAssistant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskAIAssistant {
    fn default() -> &'a TaskAIAssistant {
        <TaskAIAssistant as ::protobuf::Message>::default_instance()
    }
}

impl TaskAIAssistant {
    pub fn new() -> TaskAIAssistant {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &TaskAIAssistant| { &m.workflow_id },
            |m: &mut TaskAIAssistant| { &mut m.workflow_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskAIAssistant>(
            "TaskAIAssistant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskAIAssistant {
    const NAME: &'static str = "TaskAIAssistant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.workflow_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.workflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.workflow_id.is_empty() {
            os.write_string(1, &self.workflow_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskAIAssistant {
        TaskAIAssistant::new()
    }

    fn clear(&mut self) {
        self.workflow_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskAIAssistant {
        static instance: TaskAIAssistant = TaskAIAssistant {
            workflow_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskAIAssistant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskAIAssistant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskAIAssistant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskAIAssistant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.TaskAssignment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskAssignment {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.TaskAssignment.id)
    pub id: ::std::string::String,
    ///  Creation time.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.TaskAssignment.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Most recent modification time.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.TaskAssignment.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Assigned worker.
    // @@protoc_insertion_point(field:clarifai.api.TaskAssignment.worker)
    pub worker: ::protobuf::MessageField<Worker>,
    ///  Assigned input.
    // @@protoc_insertion_point(field:clarifai.api.TaskAssignment.input)
    pub input: ::protobuf::MessageField<Input>,
    ///  Assignment status.
    ///  Read as: This is the status of the work assigned to worker W, on input I in task T.
    // @@protoc_insertion_point(field:clarifai.api.TaskAssignment.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskAssignment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskAssignment {
    fn default() -> &'a TaskAssignment {
        <TaskAssignment as ::protobuf::Message>::default_instance()
    }
}

impl TaskAssignment {
    pub fn new() -> TaskAssignment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &TaskAssignment| { &m.id },
            |m: &mut TaskAssignment| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &TaskAssignment| { &m.created_at },
            |m: &mut TaskAssignment| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &TaskAssignment| { &m.modified_at },
            |m: &mut TaskAssignment| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Worker>(
            "worker",
            |m: &TaskAssignment| { &m.worker },
            |m: &mut TaskAssignment| { &mut m.worker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input",
            |m: &TaskAssignment| { &m.input },
            |m: &mut TaskAssignment| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &TaskAssignment| { &m.status },
            |m: &mut TaskAssignment| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskAssignment>(
            "TaskAssignment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskAssignment {
    const NAME: &'static str = "TaskAssignment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.worker)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.worker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.worker.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskAssignment {
        TaskAssignment::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.worker.clear();
        self.input.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskAssignment {
        static instance: TaskAssignment = TaskAssignment {
            id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            worker: ::protobuf::MessageField::none(),
            input: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskAssignment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskAssignment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskAssignment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskAssignment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TaskStatusCountPerUser can represent one of the following:
///  * count of task annotations created by a worker for each valid status,
///  * count of task inputs assigned to a worker  (i.e. task assignments) for each valid status
// @@protoc_insertion_point(message:clarifai.api.TaskStatusCountPerUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskStatusCountPerUser {
    // message fields
    ///  Deprecated: Use worker instead.
    // @@protoc_insertion_point(field:clarifai.api.TaskStatusCountPerUser.user_id)
    pub user_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.TaskStatusCountPerUser.pending)
    pub pending: u32,
    // @@protoc_insertion_point(field:clarifai.api.TaskStatusCountPerUser.awaiting_review)
    pub awaiting_review: u32,
    // @@protoc_insertion_point(field:clarifai.api.TaskStatusCountPerUser.success)
    pub success: u32,
    // @@protoc_insertion_point(field:clarifai.api.TaskStatusCountPerUser.review_denied)
    pub review_denied: u32,
    // @@protoc_insertion_point(field:clarifai.api.TaskStatusCountPerUser.awaiting_consensus_review)
    pub awaiting_consensus_review: u32,
    // @@protoc_insertion_point(field:clarifai.api.TaskStatusCountPerUser.worker)
    pub worker: ::protobuf::MessageField<Worker>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskStatusCountPerUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskStatusCountPerUser {
    fn default() -> &'a TaskStatusCountPerUser {
        <TaskStatusCountPerUser as ::protobuf::Message>::default_instance()
    }
}

impl TaskStatusCountPerUser {
    pub fn new() -> TaskStatusCountPerUser {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &TaskStatusCountPerUser| { &m.user_id },
            |m: &mut TaskStatusCountPerUser| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pending",
            |m: &TaskStatusCountPerUser| { &m.pending },
            |m: &mut TaskStatusCountPerUser| { &mut m.pending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "awaiting_review",
            |m: &TaskStatusCountPerUser| { &m.awaiting_review },
            |m: &mut TaskStatusCountPerUser| { &mut m.awaiting_review },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &TaskStatusCountPerUser| { &m.success },
            |m: &mut TaskStatusCountPerUser| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "review_denied",
            |m: &TaskStatusCountPerUser| { &m.review_denied },
            |m: &mut TaskStatusCountPerUser| { &mut m.review_denied },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "awaiting_consensus_review",
            |m: &TaskStatusCountPerUser| { &m.awaiting_consensus_review },
            |m: &mut TaskStatusCountPerUser| { &mut m.awaiting_consensus_review },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Worker>(
            "worker",
            |m: &TaskStatusCountPerUser| { &m.worker },
            |m: &mut TaskStatusCountPerUser| { &mut m.worker },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskStatusCountPerUser>(
            "TaskStatusCountPerUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskStatusCountPerUser {
    const NAME: &'static str = "TaskStatusCountPerUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.user_id = is.read_string()?;
                },
                16 => {
                    self.pending = is.read_uint32()?;
                },
                24 => {
                    self.awaiting_review = is.read_uint32()?;
                },
                32 => {
                    self.success = is.read_uint32()?;
                },
                40 => {
                    self.review_denied = is.read_uint32()?;
                },
                48 => {
                    self.awaiting_consensus_review = is.read_uint32()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.worker)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if self.pending != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.pending);
        }
        if self.awaiting_review != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.awaiting_review);
        }
        if self.success != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.success);
        }
        if self.review_denied != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.review_denied);
        }
        if self.awaiting_consensus_review != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.awaiting_consensus_review);
        }
        if let Some(v) = self.worker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if self.pending != 0 {
            os.write_uint32(2, self.pending)?;
        }
        if self.awaiting_review != 0 {
            os.write_uint32(3, self.awaiting_review)?;
        }
        if self.success != 0 {
            os.write_uint32(4, self.success)?;
        }
        if self.review_denied != 0 {
            os.write_uint32(5, self.review_denied)?;
        }
        if self.awaiting_consensus_review != 0 {
            os.write_uint32(6, self.awaiting_consensus_review)?;
        }
        if let Some(v) = self.worker.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskStatusCountPerUser {
        TaskStatusCountPerUser::new()
    }

    fn clear(&mut self) {
        self.user_id.clear();
        self.pending = 0;
        self.awaiting_review = 0;
        self.success = 0;
        self.review_denied = 0;
        self.awaiting_consensus_review = 0;
        self.worker.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskStatusCountPerUser {
        static instance: TaskStatusCountPerUser = TaskStatusCountPerUser {
            user_id: ::std::string::String::new(),
            pending: 0,
            awaiting_review: 0,
            success: 0,
            review_denied: 0,
            awaiting_consensus_review: 0,
            worker: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskStatusCountPerUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskStatusCountPerUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskStatusCountPerUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskStatusCountPerUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ThresholdRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ThresholdRange {
    // message fields
    ///  The range used to filter over concept values.
    ///  e.g. GREATER_THAN_OR_EQUAL_TO 0.7 -> is_lower_inclusive = true, lower = 0.7, is_upper_inclusive = true, upper = 1.0
    ///  e.g. (0.3, 0.75] -> is_lower_inclusive = false, lower = 0.3, is_upper_inclusive = true, upper = 0.75
    // @@protoc_insertion_point(field:clarifai.api.ThresholdRange.is_lower_inclusive)
    pub is_lower_inclusive: bool,
    // @@protoc_insertion_point(field:clarifai.api.ThresholdRange.is_upper_inclusive)
    pub is_upper_inclusive: bool,
    // @@protoc_insertion_point(field:clarifai.api.ThresholdRange.lower)
    pub lower: f32,
    // @@protoc_insertion_point(field:clarifai.api.ThresholdRange.upper)
    pub upper: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ThresholdRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ThresholdRange {
    fn default() -> &'a ThresholdRange {
        <ThresholdRange as ::protobuf::Message>::default_instance()
    }
}

impl ThresholdRange {
    pub fn new() -> ThresholdRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_lower_inclusive",
            |m: &ThresholdRange| { &m.is_lower_inclusive },
            |m: &mut ThresholdRange| { &mut m.is_lower_inclusive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_upper_inclusive",
            |m: &ThresholdRange| { &m.is_upper_inclusive },
            |m: &mut ThresholdRange| { &mut m.is_upper_inclusive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lower",
            |m: &ThresholdRange| { &m.lower },
            |m: &mut ThresholdRange| { &mut m.lower },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upper",
            |m: &ThresholdRange| { &m.upper },
            |m: &mut ThresholdRange| { &mut m.upper },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ThresholdRange>(
            "ThresholdRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ThresholdRange {
    const NAME: &'static str = "ThresholdRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_lower_inclusive = is.read_bool()?;
                },
                16 => {
                    self.is_upper_inclusive = is.read_bool()?;
                },
                29 => {
                    self.lower = is.read_float()?;
                },
                37 => {
                    self.upper = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_lower_inclusive != false {
            my_size += 1 + 1;
        }
        if self.is_upper_inclusive != false {
            my_size += 1 + 1;
        }
        if self.lower != 0. {
            my_size += 1 + 4;
        }
        if self.upper != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_lower_inclusive != false {
            os.write_bool(1, self.is_lower_inclusive)?;
        }
        if self.is_upper_inclusive != false {
            os.write_bool(2, self.is_upper_inclusive)?;
        }
        if self.lower != 0. {
            os.write_float(3, self.lower)?;
        }
        if self.upper != 0. {
            os.write_float(4, self.upper)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ThresholdRange {
        ThresholdRange::new()
    }

    fn clear(&mut self) {
        self.is_lower_inclusive = false;
        self.is_upper_inclusive = false;
        self.lower = 0.;
        self.upper = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ThresholdRange {
        static instance: ThresholdRange = ThresholdRange {
            is_lower_inclusive: false,
            is_upper_inclusive: false,
            lower: 0.,
            upper: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ThresholdRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ThresholdRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ThresholdRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThresholdRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.TaskConceptAutoAnnotationConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskConceptAutoAnnotationConfig {
    // message fields
    ///  Filter annotations by their annotation data type.
    ///  This is a bit-mask field that holds multiple AnnotationDataType values that are combined in an OR fashion.
    ///  Example: if annotation_data_types = 34, then we filter annotations that appear as a mask or a bounding box,
    ///  because MASK = 32 and BOUNDING_BOX = 2.
    // @@protoc_insertion_point(field:clarifai.api.TaskConceptAutoAnnotationConfig.annotation_data_types)
    pub annotation_data_types: u32,
    ///  Filter annotations by concept value.
    ///  Only concepts that fit in the threshold will be used to generate annotations.
    // @@protoc_insertion_point(field:clarifai.api.TaskConceptAutoAnnotationConfig.threshold_range)
    pub threshold_range: ::protobuf::MessageField<ThresholdRange>,
    ///  The output annotations will be created using this status code.
    // @@protoc_insertion_point(field:clarifai.api.TaskConceptAutoAnnotationConfig.status_code)
    pub status_code: ::protobuf::EnumOrUnknown<super::status_code::StatusCode>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskConceptAutoAnnotationConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskConceptAutoAnnotationConfig {
    fn default() -> &'a TaskConceptAutoAnnotationConfig {
        <TaskConceptAutoAnnotationConfig as ::protobuf::Message>::default_instance()
    }
}

impl TaskConceptAutoAnnotationConfig {
    pub fn new() -> TaskConceptAutoAnnotationConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_data_types",
            |m: &TaskConceptAutoAnnotationConfig| { &m.annotation_data_types },
            |m: &mut TaskConceptAutoAnnotationConfig| { &mut m.annotation_data_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ThresholdRange>(
            "threshold_range",
            |m: &TaskConceptAutoAnnotationConfig| { &m.threshold_range },
            |m: &mut TaskConceptAutoAnnotationConfig| { &mut m.threshold_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_code",
            |m: &TaskConceptAutoAnnotationConfig| { &m.status_code },
            |m: &mut TaskConceptAutoAnnotationConfig| { &mut m.status_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskConceptAutoAnnotationConfig>(
            "TaskConceptAutoAnnotationConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskConceptAutoAnnotationConfig {
    const NAME: &'static str = "TaskConceptAutoAnnotationConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.annotation_data_types = is.read_uint32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.threshold_range)?;
                },
                24 => {
                    self.status_code = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.annotation_data_types != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.annotation_data_types);
        }
        if let Some(v) = self.threshold_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.status_code != ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO) {
            my_size += ::protobuf::rt::int32_size(3, self.status_code.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.annotation_data_types != 0 {
            os.write_uint32(1, self.annotation_data_types)?;
        }
        if let Some(v) = self.threshold_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.status_code != ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.status_code))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskConceptAutoAnnotationConfig {
        TaskConceptAutoAnnotationConfig::new()
    }

    fn clear(&mut self) {
        self.annotation_data_types = 0;
        self.threshold_range.clear();
        self.status_code = ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskConceptAutoAnnotationConfig {
        static instance: TaskConceptAutoAnnotationConfig = TaskConceptAutoAnnotationConfig {
            annotation_data_types: 0,
            threshold_range: ::protobuf::MessageField::none(),
            status_code: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskConceptAutoAnnotationConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskConceptAutoAnnotationConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskConceptAutoAnnotationConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskConceptAutoAnnotationConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.TaskConcept)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskConcept {
    // message fields
    ///  For auto annotation, id/name and value, user + app id must be specified. For other tasks, only the id field is required.
    // @@protoc_insertion_point(field:clarifai.api.TaskConcept.concept)
    pub concept: ::protobuf::MessageField<Concept>,
    // @@protoc_insertion_point(field:clarifai.api.TaskConcept.auto_annotation_config)
    pub auto_annotation_config: ::protobuf::MessageField<TaskConceptAutoAnnotationConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskConcept.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskConcept {
    fn default() -> &'a TaskConcept {
        <TaskConcept as ::protobuf::Message>::default_instance()
    }
}

impl TaskConcept {
    pub fn new() -> TaskConcept {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Concept>(
            "concept",
            |m: &TaskConcept| { &m.concept },
            |m: &mut TaskConcept| { &mut m.concept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TaskConceptAutoAnnotationConfig>(
            "auto_annotation_config",
            |m: &TaskConcept| { &m.auto_annotation_config },
            |m: &mut TaskConcept| { &mut m.auto_annotation_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskConcept>(
            "TaskConcept",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskConcept {
    const NAME: &'static str = "TaskConcept";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auto_annotation_config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.auto_annotation_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.auto_annotation_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskConcept {
        TaskConcept::new()
    }

    fn clear(&mut self) {
        self.concept.clear();
        self.auto_annotation_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskConcept {
        static instance: TaskConcept = TaskConcept {
            concept: ::protobuf::MessageField::none(),
            auto_annotation_config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskConcept {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskConcept").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskConcept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskConcept {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.TaskMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskMetrics {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.TaskMetrics.work)
    pub work: ::protobuf::MessageField<TaskWorkMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskMetrics {
    fn default() -> &'a TaskMetrics {
        <TaskMetrics as ::protobuf::Message>::default_instance()
    }
}

impl TaskMetrics {
    pub fn new() -> TaskMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TaskWorkMetrics>(
            "work",
            |m: &TaskMetrics| { &m.work },
            |m: &mut TaskMetrics| { &mut m.work },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskMetrics>(
            "TaskMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskMetrics {
    const NAME: &'static str = "TaskMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.work)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.work.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.work.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskMetrics {
        TaskMetrics::new()
    }

    fn clear(&mut self) {
        self.work.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskMetrics {
        static instance: TaskMetrics = TaskMetrics {
            work: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.TaskWorkMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TaskWorkMetrics {
    // message fields
    ///  Estimated number of inputs that workers have worked on.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorkMetrics.inputs_count_estimated)
    pub inputs_count_estimated: u64,
    ///  Estimated percent of inputs that workers have worked on.
    ///  This is a value between 0 and 100, where 0 = 0% and 100 = 100%.
    // @@protoc_insertion_point(field:clarifai.api.TaskWorkMetrics.inputs_percent_estimated)
    pub inputs_percent_estimated: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TaskWorkMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TaskWorkMetrics {
    fn default() -> &'a TaskWorkMetrics {
        <TaskWorkMetrics as ::protobuf::Message>::default_instance()
    }
}

impl TaskWorkMetrics {
    pub fn new() -> TaskWorkMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_count_estimated",
            |m: &TaskWorkMetrics| { &m.inputs_count_estimated },
            |m: &mut TaskWorkMetrics| { &mut m.inputs_count_estimated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_percent_estimated",
            |m: &TaskWorkMetrics| { &m.inputs_percent_estimated },
            |m: &mut TaskWorkMetrics| { &mut m.inputs_percent_estimated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TaskWorkMetrics>(
            "TaskWorkMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TaskWorkMetrics {
    const NAME: &'static str = "TaskWorkMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.inputs_count_estimated = is.read_uint64()?;
                },
                16 => {
                    self.inputs_percent_estimated = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.inputs_count_estimated != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.inputs_count_estimated);
        }
        if self.inputs_percent_estimated != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.inputs_percent_estimated);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.inputs_count_estimated != 0 {
            os.write_uint64(1, self.inputs_count_estimated)?;
        }
        if self.inputs_percent_estimated != 0 {
            os.write_uint32(2, self.inputs_percent_estimated)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TaskWorkMetrics {
        TaskWorkMetrics::new()
    }

    fn clear(&mut self) {
        self.inputs_count_estimated = 0;
        self.inputs_percent_estimated = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TaskWorkMetrics {
        static instance: TaskWorkMetrics = TaskWorkMetrics {
            inputs_count_estimated: 0,
            inputs_percent_estimated: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TaskWorkMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TaskWorkMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TaskWorkMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskWorkMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Collector is a data pathway from a CollectorSource to an app to collect data automatically.
///  For example, a CollectorSource
// @@protoc_insertion_point(message:clarifai.api.Collector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Collector {
    // message fields
    ///  Unique ID for the collector.
    // @@protoc_insertion_point(field:clarifai.api.Collector.id)
    pub id: ::std::string::String,
    ///  Human readable description for the collector.
    // @@protoc_insertion_point(field:clarifai.api.Collector.description)
    pub description: ::std::string::String,
    ///  When the collector is created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.Collector.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  This is a workflow to run inline in model predict calls. It should ONLY have very fast and
    ///  light-weight models in it as it will effect the speed of the predictions being made.
    ///  This workflow's purpose is to filter down the inputs to queue for the collector to process.
    ///  The input to this workflow is going to be the OUTPUT of the model, not the input to the model
    ///  since we want to encourage having fast workflows that can also take advantage of the model
    ///  outputs to make deciions (for example: thresholding based on concepts). If the workflow
    ///  output has any field that is non-empty then the input will be queued for the collector
    ///  to process with the post_queue_workflow_id.
    ///
    ///  As a simpler alternative, pre_queue_random_sample can be set to just use random sampling instead.
    // @@protoc_insertion_point(field:clarifai.api.Collector.pre_queue_workflow_id)
    pub pre_queue_workflow_id: ::std::string::String,
    ///  Instead of needing to create a new workflow for pre_queue_workflow_id, if just random sampling
    ///  of the model inputs is required, then pre_queue_random_sample can be set to a value from (0-1]
    ///  to denote the fraction of inputs to collect.
    // @@protoc_insertion_point(field:clarifai.api.Collector.pre_queue_random_sample)
    pub pre_queue_random_sample: f32,
    ///  A workflow to run to after the collector is processing the queued input. This workflow
    ///  uses the original input to the model as input to the workflow so that you can run additional
    ///  models as well on that input to decide whether to queue the model or not. If the workflow
    ///  output has any field that is non-empty then it will be passed on to POST /inputs to
    ///  the destination app.
    // @@protoc_insertion_point(field:clarifai.api.Collector.post_queue_workflow_id)
    pub post_queue_workflow_id: ::std::string::String,
    ///  The source of the collector to feed data into this app.
    ///  Note(zeiler): if we wanted more than one source per collector we could make this it's own
    ///  object and introduce /collectors/{collector_id}/sources
    ///  We will keep it simple for now and have just one source per collector since a user can make
    ///  more than one collector in the same app anyways.
    // @@protoc_insertion_point(field:clarifai.api.Collector.collector_source)
    pub collector_source: ::protobuf::MessageField<CollectorSource>,
    ///  Status for the collector. This allows you to pause a collector without having to delete it as
    ///  an example.
    // @@protoc_insertion_point(field:clarifai.api.Collector.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  Whether to collect outputs or not. Default is false. If selected, outputs from the
    ///  original model predict call will be posted as annotations along with the input with success status.
    // @@protoc_insertion_point(field:clarifai.api.Collector.collect_outputs)
    pub collect_outputs: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Collector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Collector {
    fn default() -> &'a Collector {
        <Collector as ::protobuf::Message>::default_instance()
    }
}

impl Collector {
    pub fn new() -> Collector {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Collector| { &m.id },
            |m: &mut Collector| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Collector| { &m.description },
            |m: &mut Collector| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Collector| { &m.created_at },
            |m: &mut Collector| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pre_queue_workflow_id",
            |m: &Collector| { &m.pre_queue_workflow_id },
            |m: &mut Collector| { &mut m.pre_queue_workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pre_queue_random_sample",
            |m: &Collector| { &m.pre_queue_random_sample },
            |m: &mut Collector| { &mut m.pre_queue_random_sample },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "post_queue_workflow_id",
            |m: &Collector| { &m.post_queue_workflow_id },
            |m: &mut Collector| { &mut m.post_queue_workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CollectorSource>(
            "collector_source",
            |m: &Collector| { &m.collector_source },
            |m: &mut Collector| { &mut m.collector_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &Collector| { &m.status },
            |m: &mut Collector| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collect_outputs",
            |m: &Collector| { &m.collect_outputs },
            |m: &mut Collector| { &mut m.collect_outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Collector>(
            "Collector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Collector {
    const NAME: &'static str = "Collector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                34 => {
                    self.pre_queue_workflow_id = is.read_string()?;
                },
                69 => {
                    self.pre_queue_random_sample = is.read_float()?;
                },
                42 => {
                    self.post_queue_workflow_id = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.collector_source)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                72 => {
                    self.collect_outputs = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.pre_queue_workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pre_queue_workflow_id);
        }
        if self.pre_queue_random_sample != 0. {
            my_size += 1 + 4;
        }
        if !self.post_queue_workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.post_queue_workflow_id);
        }
        if let Some(v) = self.collector_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.collect_outputs != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.pre_queue_workflow_id.is_empty() {
            os.write_string(4, &self.pre_queue_workflow_id)?;
        }
        if self.pre_queue_random_sample != 0. {
            os.write_float(8, self.pre_queue_random_sample)?;
        }
        if !self.post_queue_workflow_id.is_empty() {
            os.write_string(5, &self.post_queue_workflow_id)?;
        }
        if let Some(v) = self.collector_source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.collect_outputs != false {
            os.write_bool(9, self.collect_outputs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Collector {
        Collector::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.created_at.clear();
        self.pre_queue_workflow_id.clear();
        self.pre_queue_random_sample = 0.;
        self.post_queue_workflow_id.clear();
        self.collector_source.clear();
        self.status.clear();
        self.collect_outputs = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Collector {
        static instance: Collector = Collector {
            id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            pre_queue_workflow_id: ::std::string::String::new(),
            pre_queue_random_sample: 0.,
            post_queue_workflow_id: ::std::string::String::new(),
            collector_source: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            collect_outputs: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Collector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Collector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Collector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Configuration for the source to collect data from.
///  Only one of the fields can be present at a time.
// @@protoc_insertion_point(message:clarifai.api.CollectorSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CollectorSource {
    // message fields
    ///  Collect from the inputs passed in for PostModelOutputs predictions of a specific model.
    ///  This does not apply to models used within workflows, only PostModelOutputs calls.
    // @@protoc_insertion_point(field:clarifai.api.CollectorSource.api_post_model_outputs_collector_source)
    pub api_post_model_outputs_collector_source: ::protobuf::MessageField<APIPostModelOutputsCollectorSource>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CollectorSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectorSource {
    fn default() -> &'a CollectorSource {
        <CollectorSource as ::protobuf::Message>::default_instance()
    }
}

impl CollectorSource {
    pub fn new() -> CollectorSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, APIPostModelOutputsCollectorSource>(
            "api_post_model_outputs_collector_source",
            |m: &CollectorSource| { &m.api_post_model_outputs_collector_source },
            |m: &mut CollectorSource| { &mut m.api_post_model_outputs_collector_source },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectorSource>(
            "CollectorSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectorSource {
    const NAME: &'static str = "CollectorSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.api_post_model_outputs_collector_source)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.api_post_model_outputs_collector_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.api_post_model_outputs_collector_source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectorSource {
        CollectorSource::new()
    }

    fn clear(&mut self) {
        self.api_post_model_outputs_collector_source.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectorSource {
        static instance: CollectorSource = CollectorSource {
            api_post_model_outputs_collector_source: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectorSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectorSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectorSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectorSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is configuration for using the inputs send for model prediction in our API as
///  as the source for data.
// @@protoc_insertion_point(message:clarifai.api.APIPostModelOutputsCollectorSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct APIPostModelOutputsCollectorSource {
    // message fields
    ///  To define the model that we should collect from we need to specify the following 4 IDs:
    ///  The User ID of the model we want to collect from.
    ///  This is User B in the example.
    // @@protoc_insertion_point(field:clarifai.api.APIPostModelOutputsCollectorSource.model_user_id)
    pub model_user_id: ::std::string::String,
    ///  The App ID of the model we want to collect from.
    // @@protoc_insertion_point(field:clarifai.api.APIPostModelOutputsCollectorSource.model_app_id)
    pub model_app_id: ::std::string::String,
    ///  The Model ID of the model we want to collect from.
    // @@protoc_insertion_point(field:clarifai.api.APIPostModelOutputsCollectorSource.model_id)
    pub model_id: ::std::string::String,
    ///  The Version ID of the model we want to collect from.
    // @@protoc_insertion_point(field:clarifai.api.APIPostModelOutputsCollectorSource.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  This key is used to POST /inputs into your app by the collector. It can be an API key or a
    ///  PAT. This needs the permissions that are needed for POST /inputs for the app_id this
    ///  Collector is defined in.
    // @@protoc_insertion_point(field:clarifai.api.APIPostModelOutputsCollectorSource.post_inputs_key_id)
    pub post_inputs_key_id: ::std::string::String,
    ///  This is a private field that defaults to the app owner for public users.
    ///  If this is left blank then this collector will collect from ALL users calling the given model.
    // @@protoc_insertion_point(field:clarifai.api.APIPostModelOutputsCollectorSource.caller_user_id)
    pub caller_user_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.APIPostModelOutputsCollectorSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a APIPostModelOutputsCollectorSource {
    fn default() -> &'a APIPostModelOutputsCollectorSource {
        <APIPostModelOutputsCollectorSource as ::protobuf::Message>::default_instance()
    }
}

impl APIPostModelOutputsCollectorSource {
    pub fn new() -> APIPostModelOutputsCollectorSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_user_id",
            |m: &APIPostModelOutputsCollectorSource| { &m.model_user_id },
            |m: &mut APIPostModelOutputsCollectorSource| { &mut m.model_user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_app_id",
            |m: &APIPostModelOutputsCollectorSource| { &m.model_app_id },
            |m: &mut APIPostModelOutputsCollectorSource| { &mut m.model_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &APIPostModelOutputsCollectorSource| { &m.model_id },
            |m: &mut APIPostModelOutputsCollectorSource| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &APIPostModelOutputsCollectorSource| { &m.model_version_id },
            |m: &mut APIPostModelOutputsCollectorSource| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "post_inputs_key_id",
            |m: &APIPostModelOutputsCollectorSource| { &m.post_inputs_key_id },
            |m: &mut APIPostModelOutputsCollectorSource| { &mut m.post_inputs_key_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "caller_user_id",
            |m: &APIPostModelOutputsCollectorSource| { &m.caller_user_id },
            |m: &mut APIPostModelOutputsCollectorSource| { &mut m.caller_user_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APIPostModelOutputsCollectorSource>(
            "APIPostModelOutputsCollectorSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for APIPostModelOutputsCollectorSource {
    const NAME: &'static str = "APIPostModelOutputsCollectorSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.model_user_id = is.read_string()?;
                },
                18 => {
                    self.model_app_id = is.read_string()?;
                },
                26 => {
                    self.model_id = is.read_string()?;
                },
                34 => {
                    self.model_version_id = is.read_string()?;
                },
                42 => {
                    self.post_inputs_key_id = is.read_string()?;
                },
                50 => {
                    self.caller_user_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.model_user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.model_user_id);
        }
        if !self.model_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_app_id);
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.model_version_id);
        }
        if !self.post_inputs_key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.post_inputs_key_id);
        }
        if !self.caller_user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.caller_user_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.model_user_id.is_empty() {
            os.write_string(1, &self.model_user_id)?;
        }
        if !self.model_app_id.is_empty() {
            os.write_string(2, &self.model_app_id)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(3, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(4, &self.model_version_id)?;
        }
        if !self.post_inputs_key_id.is_empty() {
            os.write_string(5, &self.post_inputs_key_id)?;
        }
        if !self.caller_user_id.is_empty() {
            os.write_string(6, &self.caller_user_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> APIPostModelOutputsCollectorSource {
        APIPostModelOutputsCollectorSource::new()
    }

    fn clear(&mut self) {
        self.model_user_id.clear();
        self.model_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.post_inputs_key_id.clear();
        self.caller_user_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static APIPostModelOutputsCollectorSource {
        static instance: APIPostModelOutputsCollectorSource = APIPostModelOutputsCollectorSource {
            model_user_id: ::std::string::String::new(),
            model_app_id: ::std::string::String::new(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            post_inputs_key_id: ::std::string::String::new(),
            caller_user_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for APIPostModelOutputsCollectorSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("APIPostModelOutputsCollectorSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for APIPostModelOutputsCollectorSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIPostModelOutputsCollectorSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StatValue
// @@protoc_insertion_point(message:clarifai.api.StatValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatValue {
    // message fields
    ///  The time of the event. Defaults to now().
    // @@protoc_insertion_point(field:clarifai.api.StatValue.time)
    pub time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  A value for the metric you're recording.
    // @@protoc_insertion_point(field:clarifai.api.StatValue.value)
    pub value: f32,
    ///  List of tags to attach to this stat. Each should contain one colon so that the first part will
    ///  be used as a tag group while the second being the tag itself. For example: ["task_id:a",
    ///  "worker_id:1"]. These tag groups like "task_id" or "worker_id" are important for aggregating
    ///  values in the StatValueAggregateQuery.
    // @@protoc_insertion_point(field:clarifai.api.StatValue.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.StatValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatValue {
    fn default() -> &'a StatValue {
        <StatValue as ::protobuf::Message>::default_instance()
    }
}

impl StatValue {
    pub fn new() -> StatValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "time",
            |m: &StatValue| { &m.time },
            |m: &mut StatValue| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &StatValue| { &m.value },
            |m: &mut StatValue| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &StatValue| { &m.tags },
            |m: &mut StatValue| { &mut m.tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatValue>(
            "StatValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatValue {
    const NAME: &'static str = "StatValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                21 => {
                    self.value = is.read_float()?;
                },
                26 => {
                    self.tags.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.value != 0. {
            my_size += 1 + 4;
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.value != 0. {
            os.write_float(2, self.value)?;
        }
        for v in &self.tags {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatValue {
        StatValue::new()
    }

    fn clear(&mut self) {
        self.time.clear();
        self.value = 0.;
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatValue {
        static instance: StatValue = StatValue {
            time: ::protobuf::MessageField::none(),
            value: 0.,
            tags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StatValueAggregateResult
// @@protoc_insertion_point(message:clarifai.api.StatValueAggregateResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatValueAggregateResult {
    // message fields
    ///  The list of repeated aggregate values and their counts.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregateResult.stat_value_aggregates)
    pub stat_value_aggregates: ::std::vec::Vec<StatValueAggregate>,
    ///  The query that created these results.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregateResult.stat_value_aggregate_query)
    pub stat_value_aggregate_query: ::protobuf::MessageField<StatValueAggregateQuery>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.StatValueAggregateResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatValueAggregateResult {
    fn default() -> &'a StatValueAggregateResult {
        <StatValueAggregateResult as ::protobuf::Message>::default_instance()
    }
}

impl StatValueAggregateResult {
    pub fn new() -> StatValueAggregateResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_value_aggregates",
            |m: &StatValueAggregateResult| { &m.stat_value_aggregates },
            |m: &mut StatValueAggregateResult| { &mut m.stat_value_aggregates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatValueAggregateQuery>(
            "stat_value_aggregate_query",
            |m: &StatValueAggregateResult| { &m.stat_value_aggregate_query },
            |m: &mut StatValueAggregateResult| { &mut m.stat_value_aggregate_query },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatValueAggregateResult>(
            "StatValueAggregateResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatValueAggregateResult {
    const NAME: &'static str = "StatValueAggregateResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stat_value_aggregates.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stat_value_aggregate_query)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stat_value_aggregates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.stat_value_aggregate_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stat_value_aggregates {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.stat_value_aggregate_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatValueAggregateResult {
        StatValueAggregateResult::new()
    }

    fn clear(&mut self) {
        self.stat_value_aggregates.clear();
        self.stat_value_aggregate_query.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatValueAggregateResult {
        static instance: StatValueAggregateResult = StatValueAggregateResult {
            stat_value_aggregates: ::std::vec::Vec::new(),
            stat_value_aggregate_query: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatValueAggregateResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatValueAggregateResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatValueAggregateResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValueAggregateResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StatValueAggregate
// @@protoc_insertion_point(message:clarifai.api.StatValueAggregate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatValueAggregate {
    // message fields
    ///  The time of the aggregation. For example, if you aggregate over "HOUR" buckets then you can
    ///  expect each hour that has atleast one value (matching the rest of your query fields) will have
    ///  a StatValueAggregate with the time filled into that hour.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregate.time)
    pub time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The value aggregated according to the stat_value_agg_type
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregate.aggregate_value)
    pub aggregate_value: f32,
    ///  The count of the stat values that were used in this aggregation.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregate.count)
    pub count: u64,
    ///  The tags for this aggregated_value and count. This will be filled in if tag groups were used in
    ///  the query to group aggregations.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregate.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.StatValueAggregate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatValueAggregate {
    fn default() -> &'a StatValueAggregate {
        <StatValueAggregate as ::protobuf::Message>::default_instance()
    }
}

impl StatValueAggregate {
    pub fn new() -> StatValueAggregate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "time",
            |m: &StatValueAggregate| { &m.time },
            |m: &mut StatValueAggregate| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aggregate_value",
            |m: &StatValueAggregate| { &m.aggregate_value },
            |m: &mut StatValueAggregate| { &mut m.aggregate_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &StatValueAggregate| { &m.count },
            |m: &mut StatValueAggregate| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &StatValueAggregate| { &m.tags },
            |m: &mut StatValueAggregate| { &mut m.tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatValueAggregate>(
            "StatValueAggregate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatValueAggregate {
    const NAME: &'static str = "StatValueAggregate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                21 => {
                    self.aggregate_value = is.read_float()?;
                },
                24 => {
                    self.count = is.read_uint64()?;
                },
                34 => {
                    self.tags.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.aggregate_value != 0. {
            my_size += 1 + 4;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.count);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.aggregate_value != 0. {
            os.write_float(2, self.aggregate_value)?;
        }
        if self.count != 0 {
            os.write_uint64(3, self.count)?;
        }
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatValueAggregate {
        StatValueAggregate::new()
    }

    fn clear(&mut self) {
        self.time.clear();
        self.aggregate_value = 0.;
        self.count = 0;
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatValueAggregate {
        static instance: StatValueAggregate = StatValueAggregate {
            time: ::protobuf::MessageField::none(),
            aggregate_value: 0.,
            count: 0,
            tags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatValueAggregate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatValueAggregate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatValueAggregate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValueAggregate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StatValueAggregateQuery
// @@protoc_insertion_point(message:clarifai.api.StatValueAggregateQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatValueAggregateQuery {
    // message fields
    ///  These tags are used to filter down the values before they are aggregated. For example,
    ///  if you want to aggregate values for "task_id:a" you could specify that as a tag here.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregateQuery.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    ///  These are tag groups to aggregate over. So for example if you added stat values with tags
    ///  "task_id:a" and others with "task_id:b", then added ["task_id"] to the task group, it the
    ///  aggregation would return StatValueAggregate values for each task_id. If you provide more than
    ///  one tag_group the response will return all rolled up combinations of them. For example
    ///  ["task_id", "something"] where "something:1" and "something:2" were used as tags for some
    ///  values then you'd get StatValueAggregate values back for:
    ///  task_id | something
    ///  a       | 1
    ///  a       | 2
    ///  b       | 1
    ///  b       | 1
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregateQuery.tag_groups)
    pub tag_groups: ::std::vec::Vec<::std::string::String>,
    ///  Aggregation function to use over the values. Count(value) is also always returns.
    ///  Defaults to 'sum' if not provided.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregateQuery.stat_value_agg_type)
    pub stat_value_agg_type: ::protobuf::EnumOrUnknown<StatValueAggType>,
    ///  Aggregation bins for time where the values will be aggregated at this bin granualarity.
    ///  And the "time" field will be returned in StatValueAggregate object.
    ///  If not provided then bins are not used, and all time is aggregated over.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregateQuery.stat_time_agg_type)
    pub stat_time_agg_type: ::protobuf::EnumOrUnknown<StatTimeAggType>,
    ///  If provided the time range over which values will be >= this time. If not provided then
    ///  all values will be used back to start of time.
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregateQuery.start_time)
    pub start_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  If provided the time range over which values will be <= this time. If not provided then all
    ///  values will be used up until now().
    // @@protoc_insertion_point(field:clarifai.api.StatValueAggregateQuery.end_time)
    pub end_time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.StatValueAggregateQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatValueAggregateQuery {
    fn default() -> &'a StatValueAggregateQuery {
        <StatValueAggregateQuery as ::protobuf::Message>::default_instance()
    }
}

impl StatValueAggregateQuery {
    pub fn new() -> StatValueAggregateQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &StatValueAggregateQuery| { &m.tags },
            |m: &mut StatValueAggregateQuery| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tag_groups",
            |m: &StatValueAggregateQuery| { &m.tag_groups },
            |m: &mut StatValueAggregateQuery| { &mut m.tag_groups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stat_value_agg_type",
            |m: &StatValueAggregateQuery| { &m.stat_value_agg_type },
            |m: &mut StatValueAggregateQuery| { &mut m.stat_value_agg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stat_time_agg_type",
            |m: &StatValueAggregateQuery| { &m.stat_time_agg_type },
            |m: &mut StatValueAggregateQuery| { &mut m.stat_time_agg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "start_time",
            |m: &StatValueAggregateQuery| { &m.start_time },
            |m: &mut StatValueAggregateQuery| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "end_time",
            |m: &StatValueAggregateQuery| { &m.end_time },
            |m: &mut StatValueAggregateQuery| { &mut m.end_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatValueAggregateQuery>(
            "StatValueAggregateQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatValueAggregateQuery {
    const NAME: &'static str = "StatValueAggregateQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags.push(is.read_string()?);
                },
                18 => {
                    self.tag_groups.push(is.read_string()?);
                },
                24 => {
                    self.stat_value_agg_type = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.stat_time_agg_type = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.tag_groups {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.stat_value_agg_type != ::protobuf::EnumOrUnknown::new(StatValueAggType::SUM) {
            my_size += ::protobuf::rt::int32_size(3, self.stat_value_agg_type.value());
        }
        if self.stat_time_agg_type != ::protobuf::EnumOrUnknown::new(StatTimeAggType::NO_TIME_AGG) {
            my_size += ::protobuf::rt::int32_size(4, self.stat_time_agg_type.value());
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tags {
            os.write_string(1, &v)?;
        };
        for v in &self.tag_groups {
            os.write_string(2, &v)?;
        };
        if self.stat_value_agg_type != ::protobuf::EnumOrUnknown::new(StatValueAggType::SUM) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.stat_value_agg_type))?;
        }
        if self.stat_time_agg_type != ::protobuf::EnumOrUnknown::new(StatTimeAggType::NO_TIME_AGG) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.stat_time_agg_type))?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatValueAggregateQuery {
        StatValueAggregateQuery::new()
    }

    fn clear(&mut self) {
        self.tags.clear();
        self.tag_groups.clear();
        self.stat_value_agg_type = ::protobuf::EnumOrUnknown::new(StatValueAggType::SUM);
        self.stat_time_agg_type = ::protobuf::EnumOrUnknown::new(StatTimeAggType::NO_TIME_AGG);
        self.start_time.clear();
        self.end_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatValueAggregateQuery {
        static instance: StatValueAggregateQuery = StatValueAggregateQuery {
            tags: ::std::vec::Vec::new(),
            tag_groups: ::std::vec::Vec::new(),
            stat_value_agg_type: ::protobuf::EnumOrUnknown::from_i32(0),
            stat_time_agg_type: ::protobuf::EnumOrUnknown::from_i32(0),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatValueAggregateQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatValueAggregateQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatValueAggregateQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValueAggregateQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PCAProjectionComparator
// @@protoc_insertion_point(message:clarifai.api.PCAProjectionComparator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PCAProjectionComparator {
    // message fields
    ///  Within what distance do we consider two annotations duplicates
    // @@protoc_insertion_point(field:clarifai.api.PCAProjectionComparator.distance_threshold)
    pub distance_threshold: f32,
    ///  What cluster model version generated these
    // @@protoc_insertion_point(field:clarifai.api.PCAProjectionComparator.model_version_id)
    pub model_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PCAProjectionComparator.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PCAProjectionComparator {
    fn default() -> &'a PCAProjectionComparator {
        <PCAProjectionComparator as ::protobuf::Message>::default_instance()
    }
}

impl PCAProjectionComparator {
    pub fn new() -> PCAProjectionComparator {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "distance_threshold",
            |m: &PCAProjectionComparator| { &m.distance_threshold },
            |m: &mut PCAProjectionComparator| { &mut m.distance_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &PCAProjectionComparator| { &m.model_version_id },
            |m: &mut PCAProjectionComparator| { &mut m.model_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PCAProjectionComparator>(
            "PCAProjectionComparator",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PCAProjectionComparator {
    const NAME: &'static str = "PCAProjectionComparator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.distance_threshold = is.read_float()?;
                },
                18 => {
                    self.model_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.distance_threshold != 0. {
            my_size += 1 + 4;
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.distance_threshold != 0. {
            os.write_float(1, self.distance_threshold)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(2, &self.model_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PCAProjectionComparator {
        PCAProjectionComparator::new()
    }

    fn clear(&mut self) {
        self.distance_threshold = 0.;
        self.model_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PCAProjectionComparator {
        static instance: PCAProjectionComparator = PCAProjectionComparator {
            distance_threshold: 0.,
            model_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PCAProjectionComparator {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PCAProjectionComparator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PCAProjectionComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PCAProjectionComparator {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DuplicateAnnotationsResults
// @@protoc_insertion_point(message:clarifai.api.DuplicateAnnotationsResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DuplicateAnnotationsResults {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DuplicateAnnotationsResults.duplicate_cfid)
    pub duplicate_cfid: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DuplicateAnnotationsResults.unique_count)
    pub unique_count: i32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DuplicateAnnotationsResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DuplicateAnnotationsResults {
    fn default() -> &'a DuplicateAnnotationsResults {
        <DuplicateAnnotationsResults as ::protobuf::Message>::default_instance()
    }
}

impl DuplicateAnnotationsResults {
    pub fn new() -> DuplicateAnnotationsResults {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "duplicate_cfid",
            |m: &DuplicateAnnotationsResults| { &m.duplicate_cfid },
            |m: &mut DuplicateAnnotationsResults| { &mut m.duplicate_cfid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_count",
            |m: &DuplicateAnnotationsResults| { &m.unique_count },
            |m: &mut DuplicateAnnotationsResults| { &mut m.unique_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DuplicateAnnotationsResults>(
            "DuplicateAnnotationsResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DuplicateAnnotationsResults {
    const NAME: &'static str = "DuplicateAnnotationsResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.duplicate_cfid.push(is.read_string()?);
                },
                16 => {
                    self.unique_count = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.duplicate_cfid {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.unique_count != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.unique_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.duplicate_cfid {
            os.write_string(1, &v)?;
        };
        if self.unique_count != 0 {
            os.write_int32(2, self.unique_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DuplicateAnnotationsResults {
        DuplicateAnnotationsResults::new()
    }

    fn clear(&mut self) {
        self.duplicate_cfid.clear();
        self.unique_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DuplicateAnnotationsResults {
        static instance: DuplicateAnnotationsResults = DuplicateAnnotationsResults {
            duplicate_cfid: ::std::vec::Vec::new(),
            unique_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DuplicateAnnotationsResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DuplicateAnnotationsResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DuplicateAnnotationsResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DuplicateAnnotationsResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Visibility represents how visible the given resource is to other users.
///  When authenticating a request we can tell if a user is a collaborator or a teammate for the
///  the app that contains the resource and set their allowed visibility. We use that to restrict
///  what they are allowed to see:
///  If AllowedVisibility is PRIVATE then we allow PRIVATE (10), ORG (30), PUBLIC (50)
///  If AllowedVisibility is ORG then we allow ORG (30), PUBLIC (50)
///  If AllowedVisibility is PUBLIC then we allow PUBLIC (50) only.
// @@protoc_insertion_point(message:clarifai.api.Visibility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Visibility {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.Visibility.gettable)
    pub gettable: ::protobuf::EnumOrUnknown<visibility::Gettable>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Visibility.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Visibility {
    fn default() -> &'a Visibility {
        <Visibility as ::protobuf::Message>::default_instance()
    }
}

impl Visibility {
    pub fn new() -> Visibility {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gettable",
            |m: &Visibility| { &m.gettable },
            |m: &mut Visibility| { &mut m.gettable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Visibility>(
            "Visibility",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Visibility {
    const NAME: &'static str = "Visibility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gettable = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.gettable != ::protobuf::EnumOrUnknown::new(visibility::Gettable::UNKNOWN_VISIBILITY) {
            my_size += ::protobuf::rt::int32_size(1, self.gettable.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.gettable != ::protobuf::EnumOrUnknown::new(visibility::Gettable::UNKNOWN_VISIBILITY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.gettable))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Visibility {
        Visibility::new()
    }

    fn clear(&mut self) {
        self.gettable = ::protobuf::EnumOrUnknown::new(visibility::Gettable::UNKNOWN_VISIBILITY);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Visibility {
        static instance: Visibility = Visibility {
            gettable: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Visibility {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Visibility").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Visibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Visibility {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Visibility`
pub mod visibility {
    ///  Gettable defined the level of access for GET operations for this resource.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.Visibility.Gettable)
    pub enum Gettable {
        // @@protoc_insertion_point(enum_value:clarifai.api.Visibility.Gettable.UNKNOWN_VISIBILITY)
        UNKNOWN_VISIBILITY = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.Visibility.Gettable.PRIVATE)
        PRIVATE = 10,
        // @@protoc_insertion_point(enum_value:clarifai.api.Visibility.Gettable.ORG)
        ORG = 30,
        // @@protoc_insertion_point(enum_value:clarifai.api.Visibility.Gettable.PUBLIC)
        PUBLIC = 50,
    }

    impl ::protobuf::Enum for Gettable {
        const NAME: &'static str = "Gettable";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Gettable> {
            match value {
                0 => ::std::option::Option::Some(Gettable::UNKNOWN_VISIBILITY),
                10 => ::std::option::Option::Some(Gettable::PRIVATE),
                30 => ::std::option::Option::Some(Gettable::ORG),
                50 => ::std::option::Option::Some(Gettable::PUBLIC),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Gettable> {
            match str {
                "UNKNOWN_VISIBILITY" => ::std::option::Option::Some(Gettable::UNKNOWN_VISIBILITY),
                "PRIVATE" => ::std::option::Option::Some(Gettable::PRIVATE),
                "ORG" => ::std::option::Option::Some(Gettable::ORG),
                "PUBLIC" => ::std::option::Option::Some(Gettable::PUBLIC),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Gettable] = &[
            Gettable::UNKNOWN_VISIBILITY,
            Gettable::PRIVATE,
            Gettable::ORG,
            Gettable::PUBLIC,
        ];
    }

    impl ::protobuf::EnumFull for Gettable {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Visibility.Gettable").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Gettable::UNKNOWN_VISIBILITY => 0,
                Gettable::PRIVATE => 1,
                Gettable::ORG => 2,
                Gettable::PUBLIC => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Gettable {
        fn default() -> Self {
            Gettable::UNKNOWN_VISIBILITY
        }
    }

    impl Gettable {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Gettable>("Visibility.Gettable")
        }
    }
}

///  TrendingMetric
// @@protoc_insertion_point(message:clarifai.api.TrendingMetric)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrendingMetric {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.TrendingMetric.user_id)
    pub user_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.TrendingMetric.app_id)
    pub app_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.TrendingMetric.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.TrendingMetric.view_count)
    pub view_count: u64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TrendingMetric.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrendingMetric {
    fn default() -> &'a TrendingMetric {
        <TrendingMetric as ::protobuf::Message>::default_instance()
    }
}

impl TrendingMetric {
    pub fn new() -> TrendingMetric {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &TrendingMetric| { &m.user_id },
            |m: &mut TrendingMetric| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &TrendingMetric| { &m.app_id },
            |m: &mut TrendingMetric| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &TrendingMetric| { &m.object_id },
            |m: &mut TrendingMetric| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "view_count",
            |m: &TrendingMetric| { &m.view_count },
            |m: &mut TrendingMetric| { &mut m.view_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrendingMetric>(
            "TrendingMetric",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrendingMetric {
    const NAME: &'static str = "TrendingMetric";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.user_id = is.read_string()?;
                },
                18 => {
                    self.app_id = is.read_string()?;
                },
                26 => {
                    self.object_id = is.read_string()?;
                },
                32 => {
                    self.view_count = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object_id);
        }
        if self.view_count != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.view_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if !self.object_id.is_empty() {
            os.write_string(3, &self.object_id)?;
        }
        if self.view_count != 0 {
            os.write_uint64(4, self.view_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrendingMetric {
        TrendingMetric::new()
    }

    fn clear(&mut self) {
        self.user_id.clear();
        self.app_id.clear();
        self.object_id.clear();
        self.view_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrendingMetric {
        static instance: TrendingMetric = TrendingMetric {
            user_id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            object_id: ::std::string::String::new(),
            view_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrendingMetric {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrendingMetric").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrendingMetric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrendingMetric {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.FullTag)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FullTag {
    // message fields
    ///  Display name of the tag. Ex. "English"
    // @@protoc_insertion_point(field:clarifai.api.FullTag.name)
    pub name: ::std::string::String,
    ///  Id value for referencing. Ex. "en"
    // @@protoc_insertion_point(field:clarifai.api.FullTag.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.FullTag.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FullTag {
    fn default() -> &'a FullTag {
        <FullTag as ::protobuf::Message>::default_instance()
    }
}

impl FullTag {
    pub fn new() -> FullTag {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FullTag| { &m.name },
            |m: &mut FullTag| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FullTag| { &m.id },
            |m: &mut FullTag| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FullTag>(
            "FullTag",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FullTag {
    const NAME: &'static str = "FullTag";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FullTag {
        FullTag::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FullTag {
        static instance: FullTag = FullTag {
            name: ::std::string::String::new(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FullTag {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FullTag").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FullTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FullTag {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TimeSegment
// @@protoc_insertion_point(message:clarifai.api.TimeSegment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TimeSegment {
    // message fields
    ///  A unique id for the time segment.
    // @@protoc_insertion_point(field:clarifai.api.TimeSegment.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.TimeSegment.data)
    pub data: ::protobuf::MessageField<Data>,
    // @@protoc_insertion_point(field:clarifai.api.TimeSegment.time_info)
    pub time_info: ::protobuf::MessageField<TimeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TimeSegment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeSegment {
    fn default() -> &'a TimeSegment {
        <TimeSegment as ::protobuf::Message>::default_instance()
    }
}

impl TimeSegment {
    pub fn new() -> TimeSegment {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &TimeSegment| { &m.id },
            |m: &mut TimeSegment| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Data>(
            "data",
            |m: &TimeSegment| { &m.data },
            |m: &mut TimeSegment| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TimeInfo>(
            "time_info",
            |m: &TimeSegment| { &m.time_info },
            |m: &mut TimeSegment| { &mut m.time_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeSegment>(
            "TimeSegment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeSegment {
    const NAME: &'static str = "TimeSegment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.time_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeSegment {
        TimeSegment::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.data.clear();
        self.time_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeSegment {
        static instance: TimeSegment = TimeSegment {
            id: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            time_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeSegment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeSegment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeSegment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeSegment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  TimeInfo
// @@protoc_insertion_point(message:clarifai.api.TimeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TimeInfo {
    // message fields
    ///  Number of frames
    // @@protoc_insertion_point(field:clarifai.api.TimeInfo.num_frames)
    pub num_frames: u32,
    ///  Timestamp where track begins.
    // @@protoc_insertion_point(field:clarifai.api.TimeInfo.begin_time)
    pub begin_time: f32,
    ///  Timestamp where track ends.
    // @@protoc_insertion_point(field:clarifai.api.TimeInfo.end_time)
    pub end_time: f32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.TimeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeInfo {
    fn default() -> &'a TimeInfo {
        <TimeInfo as ::protobuf::Message>::default_instance()
    }
}

impl TimeInfo {
    pub fn new() -> TimeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_frames",
            |m: &TimeInfo| { &m.num_frames },
            |m: &mut TimeInfo| { &mut m.num_frames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "begin_time",
            |m: &TimeInfo| { &m.begin_time },
            |m: &mut TimeInfo| { &mut m.begin_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_time",
            |m: &TimeInfo| { &m.end_time },
            |m: &mut TimeInfo| { &mut m.end_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeInfo>(
            "TimeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeInfo {
    const NAME: &'static str = "TimeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_frames = is.read_uint32()?;
                },
                37 => {
                    self.begin_time = is.read_float()?;
                },
                45 => {
                    self.end_time = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.num_frames != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.num_frames);
        }
        if self.begin_time != 0. {
            my_size += 1 + 4;
        }
        if self.end_time != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.num_frames != 0 {
            os.write_uint32(1, self.num_frames)?;
        }
        if self.begin_time != 0. {
            os.write_float(4, self.begin_time)?;
        }
        if self.end_time != 0. {
            os.write_float(5, self.end_time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeInfo {
        TimeInfo::new()
    }

    fn clear(&mut self) {
        self.num_frames = 0;
        self.begin_time = 0.;
        self.end_time = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeInfo {
        static instance: TimeInfo = TimeInfo {
            num_frames: 0,
            begin_time: 0.,
            end_time: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DatasetStar
// @@protoc_insertion_point(message:clarifai.api.DatasetStar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetStar {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DatasetStar.dataset_id)
    pub dataset_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetStar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetStar {
    fn default() -> &'a DatasetStar {
        <DatasetStar as ::protobuf::Message>::default_instance()
    }
}

impl DatasetStar {
    pub fn new() -> DatasetStar {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DatasetStar| { &m.dataset_id },
            |m: &mut DatasetStar| { &mut m.dataset_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetStar>(
            "DatasetStar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetStar {
    const NAME: &'static str = "DatasetStar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dataset_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dataset_id.is_empty() {
            os.write_string(1, &self.dataset_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetStar {
        DatasetStar::new()
    }

    fn clear(&mut self) {
        self.dataset_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetStar {
        static instance: DatasetStar = DatasetStar {
            dataset_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DatasetStar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetStar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetStar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetStar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModuleStar
// @@protoc_insertion_point(message:clarifai.api.ModuleStar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModuleStar {
    // message fields
    ///  Module id of the star
    // @@protoc_insertion_point(field:clarifai.api.ModuleStar.module_id)
    pub module_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModuleStar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModuleStar {
    fn default() -> &'a ModuleStar {
        <ModuleStar as ::protobuf::Message>::default_instance()
    }
}

impl ModuleStar {
    pub fn new() -> ModuleStar {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &ModuleStar| { &m.module_id },
            |m: &mut ModuleStar| { &mut m.module_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModuleStar>(
            "ModuleStar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModuleStar {
    const NAME: &'static str = "ModuleStar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.module_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.module_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.module_id.is_empty() {
            os.write_string(1, &self.module_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModuleStar {
        ModuleStar::new()
    }

    fn clear(&mut self) {
        self.module_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModuleStar {
        static instance: ModuleStar = ModuleStar {
            module_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModuleStar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModuleStar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModuleStar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleStar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  An app module that a user created in our app module marketplace.
// @@protoc_insertion_point(message:clarifai.api.Module)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Module {
    // message fields
    ///  A unique ID for this app module.
    // @@protoc_insertion_point(field:clarifai.api.Module.id)
    pub id: ::std::string::String,
    ///  A short description for this app module to be used in grids of modules.
    // @@protoc_insertion_point(field:clarifai.api.Module.description)
    pub description: ::std::string::String,
    ///  When the app module was created.
    // @@protoc_insertion_point(field:clarifai.api.Module.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the app module was last modified.
    // @@protoc_insertion_point(field:clarifai.api.Module.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    ///  Defaults to PRIVATE if not provided.
    // @@protoc_insertion_point(field:clarifai.api.Module.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    ///  This is an optional arg.
    // @@protoc_insertion_point(field:clarifai.api.Module.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  The creator of the app module.
    // @@protoc_insertion_point(field:clarifai.api.Module.user_id)
    pub user_id: ::std::string::String,
    ///  The app_id this module was created in.
    // @@protoc_insertion_point(field:clarifai.api.Module.app_id)
    pub app_id: ::std::string::String,
    ///  A ModuleVersion which is used when listing modules to include the latest module version
    ///  in the response.
    // @@protoc_insertion_point(field:clarifai.api.Module.module_version)
    pub module_version: ::protobuf::MessageField<ModuleVersion>,
    ///  Is starred by the requesting user (only showed on get/list requests)
    ///  Please use PostModuleStars/DeleteModuleStars endpoints to star/unstar a module
    // @@protoc_insertion_point(field:clarifai.api.Module.is_starred)
    pub is_starred: bool,
    ///  How many users have starred the module (only showed on get/list requests)
    ///  Computed value, not editable
    // @@protoc_insertion_point(field:clarifai.api.Module.star_count)
    pub star_count: i32,
    ///  bookmark info. When set, this module is a bookmarked module of this app.
    ///  Info in this field will allow you to find/access original module.
    // @@protoc_insertion_point(field:clarifai.api.Module.bookmark_origin)
    pub bookmark_origin: ::protobuf::MessageField<BookmarkOrigin>,
    ///  Representative image for this module
    // @@protoc_insertion_point(field:clarifai.api.Module.image)
    pub image: ::protobuf::MessageField<Image>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Module.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Module| { &m.id },
            |m: &mut Module| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Module| { &m.description },
            |m: &mut Module| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Module| { &m.created_at },
            |m: &mut Module| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Module| { &m.modified_at },
            |m: &mut Module| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &Module| { &m.visibility },
            |m: &mut Module| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &Module| { &m.metadata },
            |m: &mut Module| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Module| { &m.user_id },
            |m: &mut Module| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &Module| { &m.app_id },
            |m: &mut Module| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ModuleVersion>(
            "module_version",
            |m: &Module| { &m.module_version },
            |m: &mut Module| { &mut m.module_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_starred",
            |m: &Module| { &m.is_starred },
            |m: &mut Module| { &mut m.is_starred },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "star_count",
            |m: &Module| { &m.star_count },
            |m: &mut Module| { &mut m.star_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BookmarkOrigin>(
            "bookmark_origin",
            |m: &Module| { &m.bookmark_origin },
            |m: &mut Module| { &mut m.bookmark_origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Image>(
            "image",
            |m: &Module| { &m.image },
            |m: &mut Module| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Module>(
            "Module",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Module {
    const NAME: &'static str = "Module";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    self.description = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                74 => {
                    self.user_id = is.read_string()?;
                },
                82 => {
                    self.app_id = is.read_string()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module_version)?;
                },
                96 => {
                    self.is_starred = is.read_bool()?;
                },
                104 => {
                    self.star_count = is.read_int32()?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bookmark_origin)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.app_id);
        }
        if let Some(v) = self.module_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.is_starred != false {
            my_size += 1 + 1;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.star_count);
        }
        if let Some(v) = self.bookmark_origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(9, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(10, &self.app_id)?;
        }
        if let Some(v) = self.module_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if self.is_starred != false {
            os.write_bool(12, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(13, self.star_count)?;
        }
        if let Some(v) = self.bookmark_origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Module {
        Module::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.visibility.clear();
        self.metadata.clear();
        self.user_id.clear();
        self.app_id.clear();
        self.module_version.clear();
        self.is_starred = false;
        self.star_count = 0;
        self.bookmark_origin.clear();
        self.image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Module {
        static instance: Module = Module {
            id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            visibility: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            module_version: ::protobuf::MessageField::none(),
            is_starred: false,
            star_count: 0,
            bookmark_origin: ::protobuf::MessageField::none(),
            image: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Module {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Module").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A specific version of an app module that is available for assigning to apps.
// @@protoc_insertion_point(message:clarifai.api.ModuleVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModuleVersion {
    // message fields
    ///  A name for this version like 1_0, 1_1_0, etc.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.id)
    pub id: ::std::string::String,
    ///  The module this version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.module_id)
    pub module_id: ::std::string::String,
    ///  The app_id this module version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.app_id)
    pub app_id: ::std::string::String,
    ///  The user_id this module version belongs to.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.user_id)
    pub user_id: ::std::string::String,
    ///  A short description for this version.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.description)
    pub description: ::std::string::String,
    ///  A markdown formatted string to detailed description of the app module.
    ///  This is within each version so that it can be change version to version.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.notes)
    pub notes: ::std::string::String,
    ///  When the app module version was created.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the app module version was last modified.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The code repo of the streamlit app.
    ///  If you are still developing your Module you should create a ModuleVersion
    ///  with an empty git_commit_url and then create an InstalledModuleVersion
    ///  with a pre-deployed deploy_url (such as localhost or streamlit cloud).
    ///  Once you are ready to create a production, create a new ModuleVersion with
    ///  the ready git url to a specific commit that you would like to be reviewed by the
    ///  Clarifai team for approval within our community. You cannot publish a ModuleVersion
    ///  is reviewed and approved. Please only provide the git_commit_url when you're
    ///  ready for a review. This url needs to include a specific commit, for example:
    ///  https://github.com/user/repo/commit/767ff9c08ba3429c8e7b8825da148555
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.git_commit_url)
    pub git_commit_url: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.module_nav)
    pub module_nav: ::protobuf::MessageField<module_version::ModuleNav>,
    ///  A boolean to mark if Clarifai has approved this app version.
    ///  This cannot be set in the request to True.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.approved)
    pub approved: bool,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible.
    ///  Defaults to PRIVATE if not provided.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    ///  This is an optional arg.
    // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModuleVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModuleVersion {
    fn default() -> &'a ModuleVersion {
        <ModuleVersion as ::protobuf::Message>::default_instance()
    }
}

impl ModuleVersion {
    pub fn new() -> ModuleVersion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ModuleVersion| { &m.id },
            |m: &mut ModuleVersion| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &ModuleVersion| { &m.module_id },
            |m: &mut ModuleVersion| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &ModuleVersion| { &m.app_id },
            |m: &mut ModuleVersion| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &ModuleVersion| { &m.user_id },
            |m: &mut ModuleVersion| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ModuleVersion| { &m.description },
            |m: &mut ModuleVersion| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "notes",
            |m: &ModuleVersion| { &m.notes },
            |m: &mut ModuleVersion| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &ModuleVersion| { &m.created_at },
            |m: &mut ModuleVersion| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &ModuleVersion| { &m.modified_at },
            |m: &mut ModuleVersion| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "git_commit_url",
            |m: &ModuleVersion| { &m.git_commit_url },
            |m: &mut ModuleVersion| { &mut m.git_commit_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, module_version::ModuleNav>(
            "module_nav",
            |m: &ModuleVersion| { &m.module_nav },
            |m: &mut ModuleVersion| { &mut m.module_nav },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "approved",
            |m: &ModuleVersion| { &m.approved },
            |m: &mut ModuleVersion| { &mut m.approved },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &ModuleVersion| { &m.visibility },
            |m: &mut ModuleVersion| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &ModuleVersion| { &m.metadata },
            |m: &mut ModuleVersion| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModuleVersion>(
            "ModuleVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModuleVersion {
    const NAME: &'static str = "ModuleVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.app_id = is.read_string()?;
                },
                34 => {
                    self.user_id = is.read_string()?;
                },
                50 => {
                    self.description = is.read_string()?;
                },
                58 => {
                    self.notes = is.read_string()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                82 => {
                    self.git_commit_url = is.read_string()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module_nav)?;
                },
                96 => {
                    self.approved = is.read_bool()?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.notes);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.git_commit_url.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.git_commit_url);
        }
        if let Some(v) = self.module_nav.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.approved != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(3, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(4, &self.user_id)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if !self.notes.is_empty() {
            os.write_string(7, &self.notes)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if !self.git_commit_url.is_empty() {
            os.write_string(10, &self.git_commit_url)?;
        }
        if let Some(v) = self.module_nav.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if self.approved != false {
            os.write_bool(12, self.approved)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModuleVersion {
        ModuleVersion::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.module_id.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.description.clear();
        self.notes.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.git_commit_url.clear();
        self.module_nav.clear();
        self.approved = false;
        self.visibility.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModuleVersion {
        static instance: ModuleVersion = ModuleVersion {
            id: ::std::string::String::new(),
            module_id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            notes: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            git_commit_url: ::std::string::String::new(),
            module_nav: ::protobuf::MessageField::none(),
            approved: false,
            visibility: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModuleVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModuleVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModuleVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ModuleVersion`
pub mod module_version {
    // @@protoc_insertion_point(message:clarifai.api.ModuleVersion.ModuleSubNav)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ModuleSubNav {
        // message fields
        ///  This is the display title for a navbar element to link to a specific page.
        ///  The name for this subnav element to show in the sidebar.
        // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.ModuleSubNav.title)
        pub title: ::std::string::String,
        ///  The query param name
        // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.ModuleSubNav.query_key)
        pub query_key: ::std::string::String,
        ///  The query param value
        // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.ModuleSubNav.query_value)
        pub query_value: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:clarifai.api.ModuleVersion.ModuleSubNav.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ModuleSubNav {
        fn default() -> &'a ModuleSubNav {
            <ModuleSubNav as ::protobuf::Message>::default_instance()
        }
    }

    impl ModuleSubNav {
        pub fn new() -> ModuleSubNav {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &ModuleSubNav| { &m.title },
                |m: &mut ModuleSubNav| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query_key",
                |m: &ModuleSubNav| { &m.query_key },
                |m: &mut ModuleSubNav| { &mut m.query_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "query_value",
                |m: &ModuleSubNav| { &m.query_value },
                |m: &mut ModuleSubNav| { &mut m.query_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModuleSubNav>(
                "ModuleVersion.ModuleSubNav",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ModuleSubNav {
        const NAME: &'static str = "ModuleSubNav";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.query_key = is.read_string()?;
                    },
                    26 => {
                        self.query_value = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.query_key.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.query_key);
            }
            if !self.query_value.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.query_value);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.query_key.is_empty() {
                os.write_string(2, &self.query_key)?;
            }
            if !self.query_value.is_empty() {
                os.write_string(3, &self.query_value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ModuleSubNav {
            ModuleSubNav::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.query_key.clear();
            self.query_value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ModuleSubNav {
            static instance: ModuleSubNav = ModuleSubNav {
                title: ::std::string::String::new(),
                query_key: ::std::string::String::new(),
                query_value: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ModuleSubNav {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ModuleVersion.ModuleSubNav").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ModuleSubNav {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ModuleSubNav {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:clarifai.api.ModuleVersion.ModuleNav)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ModuleNav {
        // message fields
        ///  This is the left side title for this module and for browser tab title of the module.
        ///  We have this in the version so that users can change those settings
        ///  when releasing a new version of their module.
        // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.ModuleNav.title)
        pub title: ::std::string::String,
        ///  A list of subnav elements to put under the module title.
        // @@protoc_insertion_point(field:clarifai.api.ModuleVersion.ModuleNav.module_sub_navs)
        pub module_sub_navs: ::std::vec::Vec<ModuleSubNav>,
        // special fields
        // @@protoc_insertion_point(special_field:clarifai.api.ModuleVersion.ModuleNav.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ModuleNav {
        fn default() -> &'a ModuleNav {
            <ModuleNav as ::protobuf::Message>::default_instance()
        }
    }

    impl ModuleNav {
        pub fn new() -> ModuleNav {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &ModuleNav| { &m.title },
                |m: &mut ModuleNav| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "module_sub_navs",
                |m: &ModuleNav| { &m.module_sub_navs },
                |m: &mut ModuleNav| { &mut m.module_sub_navs },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModuleNav>(
                "ModuleVersion.ModuleNav",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ModuleNav {
        const NAME: &'static str = "ModuleNav";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.module_sub_navs.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            for value in &self.module_sub_navs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            for v in &self.module_sub_navs {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ModuleNav {
            ModuleNav::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.module_sub_navs.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ModuleNav {
            static instance: ModuleNav = ModuleNav {
                title: ::std::string::String::new(),
                module_sub_navs: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ModuleNav {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ModuleVersion.ModuleNav").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ModuleNav {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ModuleNav {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:clarifai.api.InstalledModuleVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstalledModuleVersion {
    // message fields
    ///  A unique id for this install. This will be used in the browser url.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.id)
    pub id: ::std::string::String,
    ///  The installed module version provided here so that we users don't need to do an additional
    ///  fetch. When creating a new InstalledModuleVersion you should provide the:
    ///  module_version.user_id
    ///  module_version.app_id
    ///  module_version.module_id
    ///  module_version.id
    ///  in order to uniquely define which module version.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.module_version)
    pub module_version: ::protobuf::MessageField<ModuleVersion>,
    ///  The app_id the ModuleVersion is installed into (not necessary where the ModuleVersion was
    ///  created). This doesn't have to be provided in requests to install, but will be returned in
    ///  responses.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.app_id)
    pub app_id: ::std::string::String,
    ///  The user that the app belongs to where the ModuleVersion is installed into (not necessary where
    ///  the ModuleVersion was created). This doesn't have to be provided in requests to install, but
    ///  will be returned in responses.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.user_id)
    pub user_id: ::std::string::String,
    ///  When the install was created.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the install was last modified.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  The URL of where this app module version is deployed.
    ///  If you provide this deploy_url when creating the install then it will
    ///  be treated as a pre-deployed module. You can only use a pre-deployed module
    ///  in when installing to an app_id that you own as the creator of the module.
    ///  If you want to install someone elses module or to rely on Clarifai deploying
    ///  your module for you, leave deploy_url empty when creating the install.
    ///  If it is left empty, then deployment will occur when this module version is
    ///  installed into an app using the git_commit_url of the ModuleVersion.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.deploy_url)
    pub deploy_url: ::std::string::String,
    ///  The visibility field represents whether this message is privately/publicly visible.
    ///  To be visible to the public the App that contains it AND the User that contains the App must
    ///  also be publicly visible. For the InstalledModuleVersion this allows the app owner who
    ///  installed the module version to decide if they want other users of their app to have
    ///  the added functionality that the modules version provides to their app.
    ///  Defaults to PRIVATE if not provided.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.visibility)
    pub visibility: ::protobuf::MessageField<Visibility>,
    ///  The key ID to use for making requests to the API for this module.
    ///  This key is associated to this installed module version by PostInstalledModuleVersionsKey
    ///  request. The key is associated with the CALLER not the App Owner where this module is installed
    ///  nor the author of the module. This allows the module to act on behalf of the caller at all
    ///  times so we get proper permissions the caller has (such as if they are stranger, teammate or
    ///  collaborator). This key should be a personal access token to enable modules to work across apps
    ///  and have necessary abilities beyond what app-specific keys offer.
    // @@protoc_insertion_point(field:clarifai.api.InstalledModuleVersion.key_id)
    pub key_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InstalledModuleVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstalledModuleVersion {
    fn default() -> &'a InstalledModuleVersion {
        <InstalledModuleVersion as ::protobuf::Message>::default_instance()
    }
}

impl InstalledModuleVersion {
    pub fn new() -> InstalledModuleVersion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &InstalledModuleVersion| { &m.id },
            |m: &mut InstalledModuleVersion| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ModuleVersion>(
            "module_version",
            |m: &InstalledModuleVersion| { &m.module_version },
            |m: &mut InstalledModuleVersion| { &mut m.module_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &InstalledModuleVersion| { &m.app_id },
            |m: &mut InstalledModuleVersion| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &InstalledModuleVersion| { &m.user_id },
            |m: &mut InstalledModuleVersion| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &InstalledModuleVersion| { &m.created_at },
            |m: &mut InstalledModuleVersion| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &InstalledModuleVersion| { &m.modified_at },
            |m: &mut InstalledModuleVersion| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deploy_url",
            |m: &InstalledModuleVersion| { &m.deploy_url },
            |m: &mut InstalledModuleVersion| { &mut m.deploy_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Visibility>(
            "visibility",
            |m: &InstalledModuleVersion| { &m.visibility },
            |m: &mut InstalledModuleVersion| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &InstalledModuleVersion| { &m.key_id },
            |m: &mut InstalledModuleVersion| { &mut m.key_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstalledModuleVersion>(
            "InstalledModuleVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstalledModuleVersion {
    const NAME: &'static str = "InstalledModuleVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module_version)?;
                },
                26 => {
                    self.app_id = is.read_string()?;
                },
                34 => {
                    self.user_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                58 => {
                    self.deploy_url = is.read_string()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                74 => {
                    self.key_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.module_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.deploy_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.deploy_url);
        }
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.module_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(3, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(4, &self.user_id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.deploy_url.is_empty() {
            os.write_string(7, &self.deploy_url)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(9, &self.key_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstalledModuleVersion {
        InstalledModuleVersion::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.module_version.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.deploy_url.clear();
        self.visibility.clear();
        self.key_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstalledModuleVersion {
        static instance: InstalledModuleVersion = InstalledModuleVersion {
            id: ::std::string::String::new(),
            module_version: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            deploy_url: ::std::string::String::new(),
            visibility: ::protobuf::MessageField::none(),
            key_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstalledModuleVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstalledModuleVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstalledModuleVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstalledModuleVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.BulkOperation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BulkOperation {
    // message fields
    ///  id of the Bulk Operation task
    // @@protoc_insertion_point(field:clarifai.api.BulkOperation.id)
    pub id: ::std::string::String,
    ///  Operation to perform
    // @@protoc_insertion_point(field:clarifai.api.BulkOperation.operation)
    pub operation: ::protobuf::MessageField<Operation>,
    ///  Application ID that this Operation was created from
    // @@protoc_insertion_point(field:clarifai.api.BulkOperation.app_id)
    pub app_id: ::std::string::String,
    ///  Status (pending, in-progress, completed, failed) of the operation
    // @@protoc_insertion_point(field:clarifai.api.BulkOperation.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  Progress of an on-going Bulk Operation task
    // @@protoc_insertion_point(field:clarifai.api.BulkOperation.progress)
    pub progress: ::protobuf::MessageField<Progress>,
    ///  User id that created this operation
    // @@protoc_insertion_point(field:clarifai.api.BulkOperation.created_by)
    pub created_by: ::std::string::String,
    ///  When the operation was created. We follow the XXXX timestamp
    ///  format. We use https://www.ietf.org/rfc/rfc3339.txt format:
    ///  "2006-01-02T15:04:05.999999Z" so you can expect results like
    ///  the following from the API:
    ///  "2017-04-11T21:50:50.223962Z"
    // @@protoc_insertion_point(field:clarifai.api.BulkOperation.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Last time the status got updated
    // @@protoc_insertion_point(field:clarifai.api.BulkOperation.last_modified_at)
    pub last_modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // message oneof groups
    pub input_source: ::std::option::Option<bulk_operation::Input_source>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.BulkOperation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BulkOperation {
    fn default() -> &'a BulkOperation {
        <BulkOperation as ::protobuf::Message>::default_instance()
    }
}

impl BulkOperation {
    pub fn new() -> BulkOperation {
        ::std::default::Default::default()
    }

    // .clarifai.api.InputIDs input_ids = 2;

    pub fn input_ids(&self) -> &InputIDs {
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::InputIds(ref v)) => v,
            _ => <InputIDs as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_input_ids(&mut self) {
        self.input_source = ::std::option::Option::None;
    }

    pub fn has_input_ids(&self) -> bool {
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::InputIds(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_input_ids(&mut self, v: InputIDs) {
        self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::InputIds(v))
    }

    // Mutable pointer to the field.
    pub fn mut_input_ids(&mut self) -> &mut InputIDs {
        if let ::std::option::Option::Some(bulk_operation::Input_source::InputIds(_)) = self.input_source {
        } else {
            self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::InputIds(InputIDs::new()));
        }
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::InputIds(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_input_ids(&mut self) -> InputIDs {
        if self.has_input_ids() {
            match self.input_source.take() {
                ::std::option::Option::Some(bulk_operation::Input_source::InputIds(v)) => v,
                _ => panic!(),
            }
        } else {
            InputIDs::new()
        }
    }

    // .clarifai.api.Search search = 10;

    pub fn search(&self) -> &Search {
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::Search(ref v)) => v,
            _ => <Search as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_search(&mut self) {
        self.input_source = ::std::option::Option::None;
    }

    pub fn has_search(&self) -> bool {
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::Search(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: Search) {
        self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::Search(v))
    }

    // Mutable pointer to the field.
    pub fn mut_search(&mut self) -> &mut Search {
        if let ::std::option::Option::Some(bulk_operation::Input_source::Search(_)) = self.input_source {
        } else {
            self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::Search(Search::new()));
        }
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::Search(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_search(&mut self) -> Search {
        if self.has_search() {
            match self.input_source.take() {
                ::std::option::Option::Some(bulk_operation::Input_source::Search(v)) => v,
                _ => panic!(),
            }
        } else {
            Search::new()
        }
    }

    // .clarifai.api.Dataset dataset = 11;

    pub fn dataset(&self) -> &Dataset {
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::Dataset(ref v)) => v,
            _ => <Dataset as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dataset(&mut self) {
        self.input_source = ::std::option::Option::None;
    }

    pub fn has_dataset(&self) -> bool {
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::Dataset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dataset(&mut self, v: Dataset) {
        self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::Dataset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dataset(&mut self) -> &mut Dataset {
        if let ::std::option::Option::Some(bulk_operation::Input_source::Dataset(_)) = self.input_source {
        } else {
            self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::Dataset(Dataset::new()));
        }
        match self.input_source {
            ::std::option::Option::Some(bulk_operation::Input_source::Dataset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dataset(&mut self) -> Dataset {
        if self.has_dataset() {
            match self.input_source.take() {
                ::std::option::Option::Some(bulk_operation::Input_source::Dataset(v)) => v,
                _ => panic!(),
            }
        } else {
            Dataset::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &BulkOperation| { &m.id },
            |m: &mut BulkOperation| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InputIDs>(
            "input_ids",
            BulkOperation::has_input_ids,
            BulkOperation::input_ids,
            BulkOperation::mut_input_ids,
            BulkOperation::set_input_ids,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Search>(
            "search",
            BulkOperation::has_search,
            BulkOperation::search,
            BulkOperation::mut_search,
            BulkOperation::set_search,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Dataset>(
            "dataset",
            BulkOperation::has_dataset,
            BulkOperation::dataset,
            BulkOperation::mut_dataset,
            BulkOperation::set_dataset,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Operation>(
            "operation",
            |m: &BulkOperation| { &m.operation },
            |m: &mut BulkOperation| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &BulkOperation| { &m.app_id },
            |m: &mut BulkOperation| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &BulkOperation| { &m.status },
            |m: &mut BulkOperation| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Progress>(
            "progress",
            |m: &BulkOperation| { &m.progress },
            |m: &mut BulkOperation| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_by",
            |m: &BulkOperation| { &m.created_by },
            |m: &mut BulkOperation| { &mut m.created_by },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &BulkOperation| { &m.created_at },
            |m: &mut BulkOperation| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "last_modified_at",
            |m: &BulkOperation| { &m.last_modified_at },
            |m: &mut BulkOperation| { &mut m.last_modified_at },
        ));
        oneofs.push(bulk_operation::Input_source::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BulkOperation>(
            "BulkOperation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BulkOperation {
    const NAME: &'static str = "BulkOperation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::InputIds(is.read_message()?));
                },
                82 => {
                    self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::Search(is.read_message()?));
                },
                90 => {
                    self.input_source = ::std::option::Option::Some(bulk_operation::Input_source::Dataset(is.read_message()?));
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.operation)?;
                },
                34 => {
                    self.app_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.progress)?;
                },
                58 => {
                    self.created_by = is.read_string()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_modified_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_id);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.created_by.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.created_by);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.input_source {
            match v {
                &bulk_operation::Input_source::InputIds(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bulk_operation::Input_source::Search(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bulk_operation::Input_source::Dataset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.operation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(4, &self.app_id)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.progress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.created_by.is_empty() {
            os.write_string(7, &self.created_by)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.last_modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.input_source {
            match v {
                &bulk_operation::Input_source::InputIds(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &bulk_operation::Input_source::Search(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &bulk_operation::Input_source::Dataset(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BulkOperation {
        BulkOperation::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.input_source = ::std::option::Option::None;
        self.input_source = ::std::option::Option::None;
        self.input_source = ::std::option::Option::None;
        self.operation.clear();
        self.app_id.clear();
        self.status.clear();
        self.progress.clear();
        self.created_by.clear();
        self.created_at.clear();
        self.last_modified_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BulkOperation {
        static instance: BulkOperation = BulkOperation {
            id: ::std::string::String::new(),
            operation: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            status: ::protobuf::MessageField::none(),
            progress: ::protobuf::MessageField::none(),
            created_by: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            last_modified_at: ::protobuf::MessageField::none(),
            input_source: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BulkOperation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BulkOperation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BulkOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkOperation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BulkOperation`
pub mod bulk_operation {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.BulkOperation.input_source)
    pub enum Input_source {
        // @@protoc_insertion_point(oneof_field:clarifai.api.BulkOperation.input_ids)
        InputIds(super::InputIDs),
        // @@protoc_insertion_point(oneof_field:clarifai.api.BulkOperation.search)
        Search(super::Search),
        // @@protoc_insertion_point(oneof_field:clarifai.api.BulkOperation.dataset)
        Dataset(super::Dataset),
    }

    impl ::protobuf::Oneof for Input_source {
    }

    impl ::protobuf::OneofFull for Input_source {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BulkOperation as ::protobuf::MessageFull>::descriptor().oneof_by_name("input_source").unwrap()).clone()
        }
    }

    impl Input_source {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Input_source>("input_source")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.InputIDs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputIDs {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.InputIDs.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputIDs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputIDs {
    fn default() -> &'a InputIDs {
        <InputIDs as ::protobuf::Message>::default_instance()
    }
}

impl InputIDs {
    pub fn new() -> InputIDs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &InputIDs| { &m.input_ids },
            |m: &mut InputIDs| { &mut m.input_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputIDs>(
            "InputIDs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputIDs {
    const NAME: &'static str = "InputIDs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.input_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.input_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputIDs {
        InputIDs::new()
    }

    fn clear(&mut self) {
        self.input_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputIDs {
        static instance: InputIDs = InputIDs {
            input_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputIDs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputIDs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputIDs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputIDs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.Progress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Progress {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.Progress.processed)
    pub processed: u32,
    // @@protoc_insertion_point(field:clarifai.api.Progress.last_processed_id)
    pub last_processed_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Progress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Progress {
    fn default() -> &'a Progress {
        <Progress as ::protobuf::Message>::default_instance()
    }
}

impl Progress {
    pub fn new() -> Progress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "processed",
            |m: &Progress| { &m.processed },
            |m: &mut Progress| { &mut m.processed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_processed_id",
            |m: &Progress| { &m.last_processed_id },
            |m: &mut Progress| { &mut m.last_processed_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Progress>(
            "Progress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Progress {
    const NAME: &'static str = "Progress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.processed = is.read_uint32()?;
                },
                18 => {
                    self.last_processed_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.processed != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.processed);
        }
        if !self.last_processed_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.last_processed_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.processed != 0 {
            os.write_uint32(1, self.processed)?;
        }
        if !self.last_processed_id.is_empty() {
            os.write_string(2, &self.last_processed_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Progress {
        Progress::new()
    }

    fn clear(&mut self) {
        self.processed = 0;
        self.last_processed_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Progress {
        static instance: Progress = Progress {
            processed: 0,
            last_processed_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Progress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Progress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Progress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Progress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.Operation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Operation {
    // message oneof groups
    pub operation: ::std::option::Option<operation::Operation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Operation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Operation {
    fn default() -> &'a Operation {
        <Operation as ::protobuf::Message>::default_instance()
    }
}

impl Operation {
    pub fn new() -> Operation {
        ::std::default::Default::default()
    }

    // .clarifai.api.AddConcepts add_concepts = 1;

    pub fn add_concepts(&self) -> &AddConcepts {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddConcepts(ref v)) => v,
            _ => <AddConcepts as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_add_concepts(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_add_concepts(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddConcepts(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_concepts(&mut self, v: AddConcepts) {
        self.operation = ::std::option::Option::Some(operation::Operation::AddConcepts(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add_concepts(&mut self) -> &mut AddConcepts {
        if let ::std::option::Option::Some(operation::Operation::AddConcepts(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::AddConcepts(AddConcepts::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddConcepts(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_concepts(&mut self) -> AddConcepts {
        if self.has_add_concepts() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::AddConcepts(v)) => v,
                _ => panic!(),
            }
        } else {
            AddConcepts::new()
        }
    }

    // .clarifai.api.DeleteConcepts delete_concepts = 2;

    pub fn delete_concepts(&self) -> &DeleteConcepts {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteConcepts(ref v)) => v,
            _ => <DeleteConcepts as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_concepts(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_delete_concepts(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteConcepts(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_concepts(&mut self, v: DeleteConcepts) {
        self.operation = ::std::option::Option::Some(operation::Operation::DeleteConcepts(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_concepts(&mut self) -> &mut DeleteConcepts {
        if let ::std::option::Option::Some(operation::Operation::DeleteConcepts(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::DeleteConcepts(DeleteConcepts::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteConcepts(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_concepts(&mut self) -> DeleteConcepts {
        if self.has_delete_concepts() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::DeleteConcepts(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteConcepts::new()
        }
    }

    // .clarifai.api.AddMetadata add_metadata = 3;

    pub fn add_metadata(&self) -> &AddMetadata {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddMetadata(ref v)) => v,
            _ => <AddMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_add_metadata(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_add_metadata(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_metadata(&mut self, v: AddMetadata) {
        self.operation = ::std::option::Option::Some(operation::Operation::AddMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add_metadata(&mut self) -> &mut AddMetadata {
        if let ::std::option::Option::Some(operation::Operation::AddMetadata(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::AddMetadata(AddMetadata::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_metadata(&mut self) -> AddMetadata {
        if self.has_add_metadata() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::AddMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            AddMetadata::new()
        }
    }

    // .clarifai.api.DeleteMetadata delete_metadata = 4;

    pub fn delete_metadata(&self) -> &DeleteMetadata {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteMetadata(ref v)) => v,
            _ => <DeleteMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_metadata(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_delete_metadata(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_metadata(&mut self, v: DeleteMetadata) {
        self.operation = ::std::option::Option::Some(operation::Operation::DeleteMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_metadata(&mut self) -> &mut DeleteMetadata {
        if let ::std::option::Option::Some(operation::Operation::DeleteMetadata(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::DeleteMetadata(DeleteMetadata::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_metadata(&mut self) -> DeleteMetadata {
        if self.has_delete_metadata() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::DeleteMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteMetadata::new()
        }
    }

    // .clarifai.api.OverwriteGeo overwrite_geo = 5;

    pub fn overwrite_geo(&self) -> &OverwriteGeo {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::OverwriteGeo(ref v)) => v,
            _ => <OverwriteGeo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_overwrite_geo(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_overwrite_geo(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::OverwriteGeo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_overwrite_geo(&mut self, v: OverwriteGeo) {
        self.operation = ::std::option::Option::Some(operation::Operation::OverwriteGeo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_overwrite_geo(&mut self) -> &mut OverwriteGeo {
        if let ::std::option::Option::Some(operation::Operation::OverwriteGeo(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::OverwriteGeo(OverwriteGeo::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::OverwriteGeo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_overwrite_geo(&mut self) -> OverwriteGeo {
        if self.has_overwrite_geo() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::OverwriteGeo(v)) => v,
                _ => panic!(),
            }
        } else {
            OverwriteGeo::new()
        }
    }

    // .clarifai.api.DeleteGeo delete_geo = 6;

    pub fn delete_geo(&self) -> &DeleteGeo {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteGeo(ref v)) => v,
            _ => <DeleteGeo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_geo(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_delete_geo(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteGeo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_geo(&mut self, v: DeleteGeo) {
        self.operation = ::std::option::Option::Some(operation::Operation::DeleteGeo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_geo(&mut self) -> &mut DeleteGeo {
        if let ::std::option::Option::Some(operation::Operation::DeleteGeo(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::DeleteGeo(DeleteGeo::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteGeo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_geo(&mut self) -> DeleteGeo {
        if self.has_delete_geo() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::DeleteGeo(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteGeo::new()
        }
    }

    // .clarifai.api.DeleteFromDataset delete_from_dataset = 7;

    pub fn delete_from_dataset(&self) -> &DeleteFromDataset {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteFromDataset(ref v)) => v,
            _ => <DeleteFromDataset as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_from_dataset(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_delete_from_dataset(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteFromDataset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_dataset(&mut self, v: DeleteFromDataset) {
        self.operation = ::std::option::Option::Some(operation::Operation::DeleteFromDataset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_dataset(&mut self) -> &mut DeleteFromDataset {
        if let ::std::option::Option::Some(operation::Operation::DeleteFromDataset(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::DeleteFromDataset(DeleteFromDataset::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::DeleteFromDataset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_dataset(&mut self) -> DeleteFromDataset {
        if self.has_delete_from_dataset() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::DeleteFromDataset(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteFromDataset::new()
        }
    }

    // .clarifai.api.AddToDataset add_to_dataset = 8;

    pub fn add_to_dataset(&self) -> &AddToDataset {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddToDataset(ref v)) => v,
            _ => <AddToDataset as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_add_to_dataset(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_add_to_dataset(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddToDataset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_to_dataset(&mut self, v: AddToDataset) {
        self.operation = ::std::option::Option::Some(operation::Operation::AddToDataset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add_to_dataset(&mut self) -> &mut AddToDataset {
        if let ::std::option::Option::Some(operation::Operation::AddToDataset(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::AddToDataset(AddToDataset::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::AddToDataset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_to_dataset(&mut self) -> AddToDataset {
        if self.has_add_to_dataset() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::AddToDataset(v)) => v,
                _ => panic!(),
            }
        } else {
            AddToDataset::new()
        }
    }

    // .clarifai.api.SplitIntoDatasets split_into_datasets = 9;

    pub fn split_into_datasets(&self) -> &SplitIntoDatasets {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::SplitIntoDatasets(ref v)) => v,
            _ => <SplitIntoDatasets as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_split_into_datasets(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_split_into_datasets(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(operation::Operation::SplitIntoDatasets(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_split_into_datasets(&mut self, v: SplitIntoDatasets) {
        self.operation = ::std::option::Option::Some(operation::Operation::SplitIntoDatasets(v))
    }

    // Mutable pointer to the field.
    pub fn mut_split_into_datasets(&mut self) -> &mut SplitIntoDatasets {
        if let ::std::option::Option::Some(operation::Operation::SplitIntoDatasets(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(operation::Operation::SplitIntoDatasets(SplitIntoDatasets::new()));
        }
        match self.operation {
            ::std::option::Option::Some(operation::Operation::SplitIntoDatasets(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_split_into_datasets(&mut self) -> SplitIntoDatasets {
        if self.has_split_into_datasets() {
            match self.operation.take() {
                ::std::option::Option::Some(operation::Operation::SplitIntoDatasets(v)) => v,
                _ => panic!(),
            }
        } else {
            SplitIntoDatasets::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AddConcepts>(
            "add_concepts",
            Operation::has_add_concepts,
            Operation::add_concepts,
            Operation::mut_add_concepts,
            Operation::set_add_concepts,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteConcepts>(
            "delete_concepts",
            Operation::has_delete_concepts,
            Operation::delete_concepts,
            Operation::mut_delete_concepts,
            Operation::set_delete_concepts,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AddMetadata>(
            "add_metadata",
            Operation::has_add_metadata,
            Operation::add_metadata,
            Operation::mut_add_metadata,
            Operation::set_add_metadata,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteMetadata>(
            "delete_metadata",
            Operation::has_delete_metadata,
            Operation::delete_metadata,
            Operation::mut_delete_metadata,
            Operation::set_delete_metadata,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OverwriteGeo>(
            "overwrite_geo",
            Operation::has_overwrite_geo,
            Operation::overwrite_geo,
            Operation::mut_overwrite_geo,
            Operation::set_overwrite_geo,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteGeo>(
            "delete_geo",
            Operation::has_delete_geo,
            Operation::delete_geo,
            Operation::mut_delete_geo,
            Operation::set_delete_geo,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteFromDataset>(
            "delete_from_dataset",
            Operation::has_delete_from_dataset,
            Operation::delete_from_dataset,
            Operation::mut_delete_from_dataset,
            Operation::set_delete_from_dataset,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AddToDataset>(
            "add_to_dataset",
            Operation::has_add_to_dataset,
            Operation::add_to_dataset,
            Operation::mut_add_to_dataset,
            Operation::set_add_to_dataset,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SplitIntoDatasets>(
            "split_into_datasets",
            Operation::has_split_into_datasets,
            Operation::split_into_datasets,
            Operation::mut_split_into_datasets,
            Operation::set_split_into_datasets,
        ));
        oneofs.push(operation::Operation::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Operation>(
            "Operation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Operation {
    const NAME: &'static str = "Operation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::AddConcepts(is.read_message()?));
                },
                18 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::DeleteConcepts(is.read_message()?));
                },
                26 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::AddMetadata(is.read_message()?));
                },
                34 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::DeleteMetadata(is.read_message()?));
                },
                42 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::OverwriteGeo(is.read_message()?));
                },
                50 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::DeleteGeo(is.read_message()?));
                },
                58 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::DeleteFromDataset(is.read_message()?));
                },
                66 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::AddToDataset(is.read_message()?));
                },
                74 => {
                    self.operation = ::std::option::Option::Some(operation::Operation::SplitIntoDatasets(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.operation {
            match v {
                &operation::Operation::AddConcepts(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Operation::DeleteConcepts(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Operation::AddMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Operation::DeleteMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Operation::OverwriteGeo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Operation::DeleteGeo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Operation::DeleteFromDataset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Operation::AddToDataset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &operation::Operation::SplitIntoDatasets(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.operation {
            match v {
                &operation::Operation::AddConcepts(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &operation::Operation::DeleteConcepts(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &operation::Operation::AddMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &operation::Operation::DeleteMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &operation::Operation::OverwriteGeo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &operation::Operation::DeleteGeo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &operation::Operation::DeleteFromDataset(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &operation::Operation::AddToDataset(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &operation::Operation::SplitIntoDatasets(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Operation {
        Operation::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Operation {
        static instance: Operation = Operation {
            operation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Operation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Operation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Operation`
pub mod operation {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.Operation.operation)
    pub enum Operation {
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.add_concepts)
        AddConcepts(super::AddConcepts),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.delete_concepts)
        DeleteConcepts(super::DeleteConcepts),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.add_metadata)
        AddMetadata(super::AddMetadata),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.delete_metadata)
        DeleteMetadata(super::DeleteMetadata),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.overwrite_geo)
        OverwriteGeo(super::OverwriteGeo),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.delete_geo)
        DeleteGeo(super::DeleteGeo),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.delete_from_dataset)
        DeleteFromDataset(super::DeleteFromDataset),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.add_to_dataset)
        AddToDataset(super::AddToDataset),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Operation.split_into_datasets)
        SplitIntoDatasets(super::SplitIntoDatasets),
    }

    impl ::protobuf::Oneof for Operation {
    }

    impl ::protobuf::OneofFull for Operation {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Operation as ::protobuf::MessageFull>::descriptor().oneof_by_name("operation").unwrap()).clone()
        }
    }

    impl Operation {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Operation>("operation")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.AddConcepts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddConcepts {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.AddConcepts.concepts)
    pub concepts: ::std::vec::Vec<Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AddConcepts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddConcepts {
    fn default() -> &'a AddConcepts {
        <AddConcepts as ::protobuf::Message>::default_instance()
    }
}

impl AddConcepts {
    pub fn new() -> AddConcepts {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &AddConcepts| { &m.concepts },
            |m: &mut AddConcepts| { &mut m.concepts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddConcepts>(
            "AddConcepts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddConcepts {
    const NAME: &'static str = "AddConcepts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.concepts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddConcepts {
        AddConcepts::new()
    }

    fn clear(&mut self) {
        self.concepts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddConcepts {
        static instance: AddConcepts = AddConcepts {
            concepts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddConcepts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddConcepts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddConcepts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddConcepts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.DeleteConcepts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteConcepts {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteConcepts.concepts)
    pub concepts: ::std::vec::Vec<Concept>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteConcepts.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteConcepts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteConcepts {
    fn default() -> &'a DeleteConcepts {
        <DeleteConcepts as ::protobuf::Message>::default_instance()
    }
}

impl DeleteConcepts {
    pub fn new() -> DeleteConcepts {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &DeleteConcepts| { &m.concepts },
            |m: &mut DeleteConcepts| { &mut m.concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &DeleteConcepts| { &m.user_ids },
            |m: &mut DeleteConcepts| { &mut m.user_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteConcepts>(
            "DeleteConcepts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteConcepts {
    const NAME: &'static str = "DeleteConcepts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.concepts.push(is.read_message()?);
                },
                18 => {
                    self.user_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteConcepts {
        DeleteConcepts::new()
    }

    fn clear(&mut self) {
        self.concepts.clear();
        self.user_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteConcepts {
        static instance: DeleteConcepts = DeleteConcepts {
            concepts: ::std::vec::Vec::new(),
            user_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteConcepts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteConcepts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteConcepts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteConcepts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.AddMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddMetadata {
    // message fields
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.AddMetadata.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AddMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddMetadata {
    fn default() -> &'a AddMetadata {
        <AddMetadata as ::protobuf::Message>::default_instance()
    }
}

impl AddMetadata {
    pub fn new() -> AddMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &AddMetadata| { &m.metadata },
            |m: &mut AddMetadata| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddMetadata>(
            "AddMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddMetadata {
    const NAME: &'static str = "AddMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddMetadata {
        AddMetadata::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddMetadata {
        static instance: AddMetadata = AddMetadata {
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.DeleteMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteMetadata {
    // message fields
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    // @@protoc_insertion_point(field:clarifai.api.DeleteMetadata.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteMetadata {
    fn default() -> &'a DeleteMetadata {
        <DeleteMetadata as ::protobuf::Message>::default_instance()
    }
}

impl DeleteMetadata {
    pub fn new() -> DeleteMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &DeleteMetadata| { &m.metadata },
            |m: &mut DeleteMetadata| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteMetadata>(
            "DeleteMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteMetadata {
    const NAME: &'static str = "DeleteMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteMetadata {
        DeleteMetadata::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteMetadata {
        static instance: DeleteMetadata = DeleteMetadata {
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.OverwriteGeo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OverwriteGeo {
    // message fields
    ///  Geo info
    // @@protoc_insertion_point(field:clarifai.api.OverwriteGeo.geo)
    pub geo: ::protobuf::MessageField<Geo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.OverwriteGeo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OverwriteGeo {
    fn default() -> &'a OverwriteGeo {
        <OverwriteGeo as ::protobuf::Message>::default_instance()
    }
}

impl OverwriteGeo {
    pub fn new() -> OverwriteGeo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Geo>(
            "geo",
            |m: &OverwriteGeo| { &m.geo },
            |m: &mut OverwriteGeo| { &mut m.geo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OverwriteGeo>(
            "OverwriteGeo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OverwriteGeo {
    const NAME: &'static str = "OverwriteGeo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.geo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.geo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.geo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OverwriteGeo {
        OverwriteGeo::new()
    }

    fn clear(&mut self) {
        self.geo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OverwriteGeo {
        static instance: OverwriteGeo = OverwriteGeo {
            geo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OverwriteGeo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OverwriteGeo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OverwriteGeo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OverwriteGeo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.DeleteGeo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteGeo {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteGeo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteGeo {
    fn default() -> &'a DeleteGeo {
        <DeleteGeo as ::protobuf::Message>::default_instance()
    }
}

impl DeleteGeo {
    pub fn new() -> DeleteGeo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteGeo>(
            "DeleteGeo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteGeo {
    const NAME: &'static str = "DeleteGeo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteGeo {
        DeleteGeo::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteGeo {
        static instance: DeleteGeo = DeleteGeo {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteGeo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteGeo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteGeo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteGeo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.AddToDataset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddToDataset {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.AddToDataset.dataset_id)
    pub dataset_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AddToDataset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddToDataset {
    fn default() -> &'a AddToDataset {
        <AddToDataset as ::protobuf::Message>::default_instance()
    }
}

impl AddToDataset {
    pub fn new() -> AddToDataset {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &AddToDataset| { &m.dataset_id },
            |m: &mut AddToDataset| { &mut m.dataset_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddToDataset>(
            "AddToDataset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddToDataset {
    const NAME: &'static str = "AddToDataset";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dataset_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dataset_id.is_empty() {
            os.write_string(1, &self.dataset_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddToDataset {
        AddToDataset::new()
    }

    fn clear(&mut self) {
        self.dataset_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddToDataset {
        static instance: AddToDataset = AddToDataset {
            dataset_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddToDataset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddToDataset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddToDataset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddToDataset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.DeleteFromDataset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteFromDataset {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteFromDataset.dataset_id)
    pub dataset_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteFromDataset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteFromDataset {
    fn default() -> &'a DeleteFromDataset {
        <DeleteFromDataset as ::protobuf::Message>::default_instance()
    }
}

impl DeleteFromDataset {
    pub fn new() -> DeleteFromDataset {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DeleteFromDataset| { &m.dataset_id },
            |m: &mut DeleteFromDataset| { &mut m.dataset_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteFromDataset>(
            "DeleteFromDataset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteFromDataset {
    const NAME: &'static str = "DeleteFromDataset";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dataset_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dataset_id.is_empty() {
            os.write_string(1, &self.dataset_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteFromDataset {
        DeleteFromDataset::new()
    }

    fn clear(&mut self) {
        self.dataset_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteFromDataset {
        static instance: DeleteFromDataset = DeleteFromDataset {
            dataset_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteFromDataset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteFromDataset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteFromDataset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteFromDataset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SplitIntoDatasets)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SplitIntoDatasets {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SplitIntoDatasets.dataset_splits)
    pub dataset_splits: ::std::vec::Vec<DatasetSplit>,
    // @@protoc_insertion_point(field:clarifai.api.SplitIntoDatasets.method)
    pub method: ::protobuf::EnumOrUnknown<split_into_datasets::DatasetSplitMethod>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SplitIntoDatasets.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SplitIntoDatasets {
    fn default() -> &'a SplitIntoDatasets {
        <SplitIntoDatasets as ::protobuf::Message>::default_instance()
    }
}

impl SplitIntoDatasets {
    pub fn new() -> SplitIntoDatasets {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_splits",
            |m: &SplitIntoDatasets| { &m.dataset_splits },
            |m: &mut SplitIntoDatasets| { &mut m.dataset_splits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "method",
            |m: &SplitIntoDatasets| { &m.method },
            |m: &mut SplitIntoDatasets| { &mut m.method },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SplitIntoDatasets>(
            "SplitIntoDatasets",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SplitIntoDatasets {
    const NAME: &'static str = "SplitIntoDatasets";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dataset_splits.push(is.read_message()?);
                },
                16 => {
                    self.method = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dataset_splits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.method != ::protobuf::EnumOrUnknown::new(split_into_datasets::DatasetSplitMethod::NOT_SET) {
            my_size += ::protobuf::rt::int32_size(2, self.method.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dataset_splits {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.method != ::protobuf::EnumOrUnknown::new(split_into_datasets::DatasetSplitMethod::NOT_SET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.method))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SplitIntoDatasets {
        SplitIntoDatasets::new()
    }

    fn clear(&mut self) {
        self.dataset_splits.clear();
        self.method = ::protobuf::EnumOrUnknown::new(split_into_datasets::DatasetSplitMethod::NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SplitIntoDatasets {
        static instance: SplitIntoDatasets = SplitIntoDatasets {
            dataset_splits: ::std::vec::Vec::new(),
            method: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SplitIntoDatasets {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SplitIntoDatasets").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SplitIntoDatasets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitIntoDatasets {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SplitIntoDatasets`
pub mod split_into_datasets {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.SplitIntoDatasets.DatasetSplitMethod)
    pub enum DatasetSplitMethod {
        // @@protoc_insertion_point(enum_value:clarifai.api.SplitIntoDatasets.DatasetSplitMethod.NOT_SET)
        NOT_SET = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.SplitIntoDatasets.DatasetSplitMethod.RANDOM_PERCENTAGE_SPLIT)
        RANDOM_PERCENTAGE_SPLIT = 1,
    }

    impl ::protobuf::Enum for DatasetSplitMethod {
        const NAME: &'static str = "DatasetSplitMethod";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DatasetSplitMethod> {
            match value {
                0 => ::std::option::Option::Some(DatasetSplitMethod::NOT_SET),
                1 => ::std::option::Option::Some(DatasetSplitMethod::RANDOM_PERCENTAGE_SPLIT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<DatasetSplitMethod> {
            match str {
                "NOT_SET" => ::std::option::Option::Some(DatasetSplitMethod::NOT_SET),
                "RANDOM_PERCENTAGE_SPLIT" => ::std::option::Option::Some(DatasetSplitMethod::RANDOM_PERCENTAGE_SPLIT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DatasetSplitMethod] = &[
            DatasetSplitMethod::NOT_SET,
            DatasetSplitMethod::RANDOM_PERCENTAGE_SPLIT,
        ];
    }

    impl ::protobuf::EnumFull for DatasetSplitMethod {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SplitIntoDatasets.DatasetSplitMethod").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DatasetSplitMethod {
        fn default() -> Self {
            DatasetSplitMethod::NOT_SET
        }
    }

    impl DatasetSplitMethod {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DatasetSplitMethod>("SplitIntoDatasets.DatasetSplitMethod")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.DatasetSplit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DatasetSplit {
    // message fields
    ///  Expected to have ID
    // @@protoc_insertion_point(field:clarifai.api.DatasetSplit.dataset)
    pub dataset: ::protobuf::MessageField<Dataset>,
    // message oneof groups
    pub method_info: ::std::option::Option<dataset_split::Method_info>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DatasetSplit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DatasetSplit {
    fn default() -> &'a DatasetSplit {
        <DatasetSplit as ::protobuf::Message>::default_instance()
    }
}

impl DatasetSplit {
    pub fn new() -> DatasetSplit {
        ::std::default::Default::default()
    }

    // uint32 percentage = 2;

    pub fn percentage(&self) -> u32 {
        match self.method_info {
            ::std::option::Option::Some(dataset_split::Method_info::Percentage(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_percentage(&mut self) {
        self.method_info = ::std::option::Option::None;
    }

    pub fn has_percentage(&self) -> bool {
        match self.method_info {
            ::std::option::Option::Some(dataset_split::Method_info::Percentage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_percentage(&mut self, v: u32) {
        self.method_info = ::std::option::Option::Some(dataset_split::Method_info::Percentage(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Dataset>(
            "dataset",
            |m: &DatasetSplit| { &m.dataset },
            |m: &mut DatasetSplit| { &mut m.dataset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "percentage",
            DatasetSplit::has_percentage,
            DatasetSplit::percentage,
            DatasetSplit::set_percentage,
        ));
        oneofs.push(dataset_split::Method_info::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DatasetSplit>(
            "DatasetSplit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DatasetSplit {
    const NAME: &'static str = "DatasetSplit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset)?;
                },
                16 => {
                    self.method_info = ::std::option::Option::Some(dataset_split::Method_info::Percentage(is.read_uint32()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dataset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.method_info {
            match v {
                &dataset_split::Method_info::Percentage(v) => {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dataset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.method_info {
            match v {
                &dataset_split::Method_info::Percentage(v) => {
                    os.write_uint32(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DatasetSplit {
        DatasetSplit::new()
    }

    fn clear(&mut self) {
        self.dataset.clear();
        self.method_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DatasetSplit {
        static instance: DatasetSplit = DatasetSplit {
            dataset: ::protobuf::MessageField::none(),
            method_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DatasetSplit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DatasetSplit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DatasetSplit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetSplit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DatasetSplit`
pub mod dataset_split {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.DatasetSplit.method_info)
    pub enum Method_info {
        // @@protoc_insertion_point(oneof_field:clarifai.api.DatasetSplit.percentage)
        Percentage(u32),
    }

    impl ::protobuf::Oneof for Method_info {
    }

    impl ::protobuf::OneofFull for Method_info {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DatasetSplit as ::protobuf::MessageFull>::descriptor().oneof_by_name("method_info").unwrap()).clone()
        }
    }

    impl Method_info {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Method_info>("method_info")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.InputsAddJob)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputsAddJob {
    // message fields
    ///  id of the job
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.id)
    pub id: ::std::string::String,
    ///  If call back url is set, we will send a Post request to this endpoint with job status.
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.call_back_url)
    pub call_back_url: ::std::string::String,
    ///  Personal Access Token to the application to which inputs are added
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.app_pat)
    pub app_pat: ::std::string::String,
    ///  Progress of an on-going Input Ingestion task
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.progress)
    pub progress: ::protobuf::MessageField<InputsAddJobProgress>,
    ///  When the job was created.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Most recent time when the job was updated.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Sub-jobs that extract inputs from the cloud and/or archives
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.extraction_jobs)
    pub extraction_jobs: ::std::vec::Vec<InputsExtractionJob>,
    ///  Archive uploads
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.uploads)
    pub uploads: ::std::vec::Vec<Upload>,
    ///  Status of the job
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJob.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputsAddJob.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputsAddJob {
    fn default() -> &'a InputsAddJob {
        <InputsAddJob as ::protobuf::Message>::default_instance()
    }
}

impl InputsAddJob {
    pub fn new() -> InputsAddJob {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &InputsAddJob| { &m.id },
            |m: &mut InputsAddJob| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "call_back_url",
            |m: &InputsAddJob| { &m.call_back_url },
            |m: &mut InputsAddJob| { &mut m.call_back_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_pat",
            |m: &InputsAddJob| { &m.app_pat },
            |m: &mut InputsAddJob| { &mut m.app_pat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InputsAddJobProgress>(
            "progress",
            |m: &InputsAddJob| { &m.progress },
            |m: &mut InputsAddJob| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &InputsAddJob| { &m.created_at },
            |m: &mut InputsAddJob| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &InputsAddJob| { &m.modified_at },
            |m: &mut InputsAddJob| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extraction_jobs",
            |m: &InputsAddJob| { &m.extraction_jobs },
            |m: &mut InputsAddJob| { &mut m.extraction_jobs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uploads",
            |m: &InputsAddJob| { &m.uploads },
            |m: &mut InputsAddJob| { &mut m.uploads },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &InputsAddJob| { &m.status },
            |m: &mut InputsAddJob| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputsAddJob>(
            "InputsAddJob",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputsAddJob {
    const NAME: &'static str = "InputsAddJob";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    self.call_back_url = is.read_string()?;
                },
                34 => {
                    self.app_pat = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.progress)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                82 => {
                    self.extraction_jobs.push(is.read_message()?);
                },
                90 => {
                    self.uploads.push(is.read_message()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.call_back_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.call_back_url);
        }
        if !self.app_pat.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_pat);
        }
        if let Some(v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.extraction_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.call_back_url.is_empty() {
            os.write_string(3, &self.call_back_url)?;
        }
        if !self.app_pat.is_empty() {
            os.write_string(4, &self.app_pat)?;
        }
        if let Some(v) = self.progress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        for v in &self.extraction_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.uploads {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputsAddJob {
        InputsAddJob::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.call_back_url.clear();
        self.app_pat.clear();
        self.progress.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.extraction_jobs.clear();
        self.uploads.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputsAddJob {
        static instance: InputsAddJob = InputsAddJob {
            id: ::std::string::String::new(),
            call_back_url: ::std::string::String::new(),
            app_pat: ::std::string::String::new(),
            progress: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            extraction_jobs: ::std::vec::Vec::new(),
            uploads: ::std::vec::Vec::new(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputsAddJob {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputsAddJob").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputsAddJob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputsAddJob {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.InputsAddJobProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputsAddJobProgress {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJobProgress.pending_count)
    pub pending_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJobProgress.in_progress_count)
    pub in_progress_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJobProgress.success_count)
    pub success_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsAddJobProgress.failed_count)
    pub failed_count: u64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputsAddJobProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputsAddJobProgress {
    fn default() -> &'a InputsAddJobProgress {
        <InputsAddJobProgress as ::protobuf::Message>::default_instance()
    }
}

impl InputsAddJobProgress {
    pub fn new() -> InputsAddJobProgress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pending_count",
            |m: &InputsAddJobProgress| { &m.pending_count },
            |m: &mut InputsAddJobProgress| { &mut m.pending_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "in_progress_count",
            |m: &InputsAddJobProgress| { &m.in_progress_count },
            |m: &mut InputsAddJobProgress| { &mut m.in_progress_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success_count",
            |m: &InputsAddJobProgress| { &m.success_count },
            |m: &mut InputsAddJobProgress| { &mut m.success_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failed_count",
            |m: &InputsAddJobProgress| { &m.failed_count },
            |m: &mut InputsAddJobProgress| { &mut m.failed_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputsAddJobProgress>(
            "InputsAddJobProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputsAddJobProgress {
    const NAME: &'static str = "InputsAddJobProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pending_count = is.read_uint64()?;
                },
                16 => {
                    self.in_progress_count = is.read_uint64()?;
                },
                24 => {
                    self.success_count = is.read_uint64()?;
                },
                32 => {
                    self.failed_count = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pending_count != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pending_count);
        }
        if self.in_progress_count != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.in_progress_count);
        }
        if self.success_count != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.success_count);
        }
        if self.failed_count != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.failed_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pending_count != 0 {
            os.write_uint64(1, self.pending_count)?;
        }
        if self.in_progress_count != 0 {
            os.write_uint64(2, self.in_progress_count)?;
        }
        if self.success_count != 0 {
            os.write_uint64(3, self.success_count)?;
        }
        if self.failed_count != 0 {
            os.write_uint64(4, self.failed_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputsAddJobProgress {
        InputsAddJobProgress::new()
    }

    fn clear(&mut self) {
        self.pending_count = 0;
        self.in_progress_count = 0;
        self.success_count = 0;
        self.failed_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputsAddJobProgress {
        static instance: InputsAddJobProgress = InputsAddJobProgress {
            pending_count: 0,
            in_progress_count: 0,
            success_count: 0,
            failed_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputsAddJobProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputsAddJobProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputsAddJobProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputsAddJobProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.Upload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Upload {
    // message fields
    ///  ID of upload
    // @@protoc_insertion_point(field:clarifai.api.Upload.id)
    pub id: ::std::string::String,
    ///  When the upload was started.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.Upload.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Most recent time when the upload was updated.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.Upload.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the upload will expire and be deleted
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.Upload.expires_at)
    pub expires_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Status of the upload
    // @@protoc_insertion_point(field:clarifai.api.Upload.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  name of uploaded content (e.g. filename)
    // @@protoc_insertion_point(field:clarifai.api.Upload.content_name)
    pub content_name: ::std::string::String,
    ///  Total size of the upload content
    // @@protoc_insertion_point(field:clarifai.api.Upload.content_length)
    pub content_length: u64,
    ///  Url of uploaded content
    // @@protoc_insertion_point(field:clarifai.api.Upload.content_url)
    pub content_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Upload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Upload {
    fn default() -> &'a Upload {
        <Upload as ::protobuf::Message>::default_instance()
    }
}

impl Upload {
    pub fn new() -> Upload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Upload| { &m.id },
            |m: &mut Upload| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Upload| { &m.created_at },
            |m: &mut Upload| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Upload| { &m.modified_at },
            |m: &mut Upload| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "expires_at",
            |m: &Upload| { &m.expires_at },
            |m: &mut Upload| { &mut m.expires_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &Upload| { &m.status },
            |m: &mut Upload| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content_name",
            |m: &Upload| { &m.content_name },
            |m: &mut Upload| { &mut m.content_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content_length",
            |m: &Upload| { &m.content_length },
            |m: &mut Upload| { &mut m.content_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content_url",
            |m: &Upload| { &m.content_url },
            |m: &mut Upload| { &mut m.content_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Upload>(
            "Upload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Upload {
    const NAME: &'static str = "Upload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.expires_at)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                66 => {
                    self.content_name = is.read_string()?;
                },
                48 => {
                    self.content_length = is.read_uint64()?;
                },
                58 => {
                    self.content_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expires_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.content_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.content_name);
        }
        if self.content_length != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.content_length);
        }
        if !self.content_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.content_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.expires_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.content_name.is_empty() {
            os.write_string(8, &self.content_name)?;
        }
        if self.content_length != 0 {
            os.write_uint64(6, self.content_length)?;
        }
        if !self.content_url.is_empty() {
            os.write_string(7, &self.content_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Upload {
        Upload::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.expires_at.clear();
        self.status.clear();
        self.content_name.clear();
        self.content_length = 0;
        self.content_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Upload {
        static instance: Upload = Upload {
            id: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            expires_at: ::protobuf::MessageField::none(),
            status: ::protobuf::MessageField::none(),
            content_name: ::std::string::String::new(),
            content_length: 0,
            content_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Upload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Upload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Upload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Upload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.UploadContentPart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UploadContentPart {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.UploadContentPart.range_start)
    pub range_start: u64,
    // @@protoc_insertion_point(field:clarifai.api.UploadContentPart.part_number)
    pub part_number: i64,
    // @@protoc_insertion_point(field:clarifai.api.UploadContentPart.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.UploadContentPart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UploadContentPart {
    fn default() -> &'a UploadContentPart {
        <UploadContentPart as ::protobuf::Message>::default_instance()
    }
}

impl UploadContentPart {
    pub fn new() -> UploadContentPart {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "range_start",
            |m: &UploadContentPart| { &m.range_start },
            |m: &mut UploadContentPart| { &mut m.range_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "part_number",
            |m: &UploadContentPart| { &m.part_number },
            |m: &mut UploadContentPart| { &mut m.part_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &UploadContentPart| { &m.data },
            |m: &mut UploadContentPart| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadContentPart>(
            "UploadContentPart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UploadContentPart {
    const NAME: &'static str = "UploadContentPart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.range_start = is.read_uint64()?;
                },
                16 => {
                    self.part_number = is.read_int64()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.range_start != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.range_start);
        }
        if self.part_number != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.part_number);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.range_start != 0 {
            os.write_uint64(1, self.range_start)?;
        }
        if self.part_number != 0 {
            os.write_int64(2, self.part_number)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UploadContentPart {
        UploadContentPart::new()
    }

    fn clear(&mut self) {
        self.range_start = 0;
        self.part_number = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UploadContentPart {
        static instance: UploadContentPart = UploadContentPart {
            range_start: 0,
            part_number: 0,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UploadContentPart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UploadContentPart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UploadContentPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadContentPart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  We use this message to communicate with Custom Code Operator Backend. You can use this message
///  to test your custom operator code locally.
///  We expect the response to come in the format of the MultiOutputResponse protobuf message.
// @@protoc_insertion_point(message:clarifai.api.CustomCodeOperatorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CustomCodeOperatorRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CustomCodeOperatorRequest.inputs)
    pub inputs: ::std::vec::Vec<Input>,
    ///  support arbitrary metadata
    // @@protoc_insertion_point(field:clarifai.api.CustomCodeOperatorRequest.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CustomCodeOperatorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CustomCodeOperatorRequest {
    fn default() -> &'a CustomCodeOperatorRequest {
        <CustomCodeOperatorRequest as ::protobuf::Message>::default_instance()
    }
}

impl CustomCodeOperatorRequest {
    pub fn new() -> CustomCodeOperatorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &CustomCodeOperatorRequest| { &m.inputs },
            |m: &mut CustomCodeOperatorRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &CustomCodeOperatorRequest| { &m.metadata },
            |m: &mut CustomCodeOperatorRequest| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CustomCodeOperatorRequest>(
            "CustomCodeOperatorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CustomCodeOperatorRequest {
    const NAME: &'static str = "CustomCodeOperatorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.inputs.push(is.read_message()?);
                },
                8018 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1002, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CustomCodeOperatorRequest {
        CustomCodeOperatorRequest::new()
    }

    fn clear(&mut self) {
        self.inputs.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CustomCodeOperatorRequest {
        static instance: CustomCodeOperatorRequest = CustomCodeOperatorRequest {
            inputs: ::std::vec::Vec::new(),
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CustomCodeOperatorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CustomCodeOperatorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CustomCodeOperatorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CustomCodeOperatorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.InputsExtractionJob)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputsExtractionJob {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJob.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  ID of extraction job
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJob.id)
    pub id: ::std::string::String,
    ///  Url of archive or bucket
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJob.url)
    pub url: ::std::string::String,
    ///  Progress counts of the job
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJob.progress)
    pub progress: ::protobuf::MessageField<InputsExtractionJobProgress>,
    ///  When the extraction job was started.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJob.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Most recent time when the extraction job was updated.
    ///  The format is https://www.ietf.org/rfc/rfc3339.txt.
    ///  Example: "2006-01-02T15:04:05.999999Z".
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJob.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  How to handle input ID conflicts.
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJob.input_id_conflict_resolution)
    pub input_id_conflict_resolution: ::protobuf::EnumOrUnknown<InputIDConflictResolution>,
    ///  Fields set in the template are added to all generated inputs
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJob.input_template)
    pub input_template: ::protobuf::MessageField<Input>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputsExtractionJob.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputsExtractionJob {
    fn default() -> &'a InputsExtractionJob {
        <InputsExtractionJob as ::protobuf::Message>::default_instance()
    }
}

impl InputsExtractionJob {
    pub fn new() -> InputsExtractionJob {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &InputsExtractionJob| { &m.status },
            |m: &mut InputsExtractionJob| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &InputsExtractionJob| { &m.id },
            |m: &mut InputsExtractionJob| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &InputsExtractionJob| { &m.url },
            |m: &mut InputsExtractionJob| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InputsExtractionJobProgress>(
            "progress",
            |m: &InputsExtractionJob| { &m.progress },
            |m: &mut InputsExtractionJob| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &InputsExtractionJob| { &m.created_at },
            |m: &mut InputsExtractionJob| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &InputsExtractionJob| { &m.modified_at },
            |m: &mut InputsExtractionJob| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id_conflict_resolution",
            |m: &InputsExtractionJob| { &m.input_id_conflict_resolution },
            |m: &mut InputsExtractionJob| { &mut m.input_id_conflict_resolution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input_template",
            |m: &InputsExtractionJob| { &m.input_template },
            |m: &mut InputsExtractionJob| { &mut m.input_template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputsExtractionJob>(
            "InputsExtractionJob",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputsExtractionJob {
    const NAME: &'static str = "InputsExtractionJob";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    self.url = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.progress)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                56 => {
                    self.input_id_conflict_resolution = is.read_enum_or_unknown()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input_template)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        if let Some(v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(7, self.input_id_conflict_resolution.value());
        }
        if let Some(v) = self.input_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        if let Some(v) = self.progress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.input_id_conflict_resolution))?;
        }
        if let Some(v) = self.input_template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputsExtractionJob {
        InputsExtractionJob::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.id.clear();
        self.url.clear();
        self.progress.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.input_id_conflict_resolution = ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET);
        self.input_template.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputsExtractionJob {
        static instance: InputsExtractionJob = InputsExtractionJob {
            status: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            url: ::std::string::String::new(),
            progress: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            input_id_conflict_resolution: ::protobuf::EnumOrUnknown::from_i32(0),
            input_template: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputsExtractionJob {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputsExtractionJob").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputsExtractionJob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputsExtractionJob {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.InputsExtractionJobProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputsExtractionJobProgress {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJobProgress.audio_inputs_count)
    pub audio_inputs_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJobProgress.image_inputs_count)
    pub image_inputs_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJobProgress.video_inputs_count)
    pub video_inputs_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJobProgress.text_inputs_count)
    pub text_inputs_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJobProgress.pending_archives_count)
    pub pending_archives_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJobProgress.in_progress_archives_count)
    pub in_progress_archives_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJobProgress.completed_archives_count)
    pub completed_archives_count: u64,
    // @@protoc_insertion_point(field:clarifai.api.InputsExtractionJobProgress.failed_archives_count)
    pub failed_archives_count: u64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputsExtractionJobProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputsExtractionJobProgress {
    fn default() -> &'a InputsExtractionJobProgress {
        <InputsExtractionJobProgress as ::protobuf::Message>::default_instance()
    }
}

impl InputsExtractionJobProgress {
    pub fn new() -> InputsExtractionJobProgress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "audio_inputs_count",
            |m: &InputsExtractionJobProgress| { &m.audio_inputs_count },
            |m: &mut InputsExtractionJobProgress| { &mut m.audio_inputs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_inputs_count",
            |m: &InputsExtractionJobProgress| { &m.image_inputs_count },
            |m: &mut InputsExtractionJobProgress| { &mut m.image_inputs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "video_inputs_count",
            |m: &InputsExtractionJobProgress| { &m.video_inputs_count },
            |m: &mut InputsExtractionJobProgress| { &mut m.video_inputs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text_inputs_count",
            |m: &InputsExtractionJobProgress| { &m.text_inputs_count },
            |m: &mut InputsExtractionJobProgress| { &mut m.text_inputs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pending_archives_count",
            |m: &InputsExtractionJobProgress| { &m.pending_archives_count },
            |m: &mut InputsExtractionJobProgress| { &mut m.pending_archives_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "in_progress_archives_count",
            |m: &InputsExtractionJobProgress| { &m.in_progress_archives_count },
            |m: &mut InputsExtractionJobProgress| { &mut m.in_progress_archives_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "completed_archives_count",
            |m: &InputsExtractionJobProgress| { &m.completed_archives_count },
            |m: &mut InputsExtractionJobProgress| { &mut m.completed_archives_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "failed_archives_count",
            |m: &InputsExtractionJobProgress| { &m.failed_archives_count },
            |m: &mut InputsExtractionJobProgress| { &mut m.failed_archives_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputsExtractionJobProgress>(
            "InputsExtractionJobProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputsExtractionJobProgress {
    const NAME: &'static str = "InputsExtractionJobProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.audio_inputs_count = is.read_uint64()?;
                },
                24 => {
                    self.image_inputs_count = is.read_uint64()?;
                },
                32 => {
                    self.video_inputs_count = is.read_uint64()?;
                },
                40 => {
                    self.text_inputs_count = is.read_uint64()?;
                },
                48 => {
                    self.pending_archives_count = is.read_uint64()?;
                },
                56 => {
                    self.in_progress_archives_count = is.read_uint64()?;
                },
                64 => {
                    self.completed_archives_count = is.read_uint64()?;
                },
                72 => {
                    self.failed_archives_count = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.audio_inputs_count != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.audio_inputs_count);
        }
        if self.image_inputs_count != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.image_inputs_count);
        }
        if self.video_inputs_count != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.video_inputs_count);
        }
        if self.text_inputs_count != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.text_inputs_count);
        }
        if self.pending_archives_count != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.pending_archives_count);
        }
        if self.in_progress_archives_count != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.in_progress_archives_count);
        }
        if self.completed_archives_count != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.completed_archives_count);
        }
        if self.failed_archives_count != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.failed_archives_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.audio_inputs_count != 0 {
            os.write_uint64(2, self.audio_inputs_count)?;
        }
        if self.image_inputs_count != 0 {
            os.write_uint64(3, self.image_inputs_count)?;
        }
        if self.video_inputs_count != 0 {
            os.write_uint64(4, self.video_inputs_count)?;
        }
        if self.text_inputs_count != 0 {
            os.write_uint64(5, self.text_inputs_count)?;
        }
        if self.pending_archives_count != 0 {
            os.write_uint64(6, self.pending_archives_count)?;
        }
        if self.in_progress_archives_count != 0 {
            os.write_uint64(7, self.in_progress_archives_count)?;
        }
        if self.completed_archives_count != 0 {
            os.write_uint64(8, self.completed_archives_count)?;
        }
        if self.failed_archives_count != 0 {
            os.write_uint64(9, self.failed_archives_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputsExtractionJobProgress {
        InputsExtractionJobProgress::new()
    }

    fn clear(&mut self) {
        self.audio_inputs_count = 0;
        self.image_inputs_count = 0;
        self.video_inputs_count = 0;
        self.text_inputs_count = 0;
        self.pending_archives_count = 0;
        self.in_progress_archives_count = 0;
        self.completed_archives_count = 0;
        self.failed_archives_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputsExtractionJobProgress {
        static instance: InputsExtractionJobProgress = InputsExtractionJobProgress {
            audio_inputs_count: 0,
            image_inputs_count: 0,
            video_inputs_count: 0,
            text_inputs_count: 0,
            pending_archives_count: 0,
            in_progress_archives_count: 0,
            completed_archives_count: 0,
            failed_archives_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputsExtractionJobProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputsExtractionJobProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputsExtractionJobProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputsExtractionJobProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.InputsDataSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputsDataSource {
    // message fields
    ///  Collect statistics about created inputs in job with given ID.
    ///  On Post call:
    ///  * If job ID is empty, then job is automatically created with random ID.
    ///  * If job ID is non-empty, then a new job will be created with given ID.
    // @@protoc_insertion_point(field:clarifai.api.InputsDataSource.inputs_add_job_id)
    pub inputs_add_job_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.InputsDataSource.url)
    pub url: ::protobuf::MessageField<DataSourceURL>,
    ///  How to handle input ID conflicts.
    // @@protoc_insertion_point(field:clarifai.api.InputsDataSource.input_id_conflict_resolution)
    pub input_id_conflict_resolution: ::protobuf::EnumOrUnknown<InputIDConflictResolution>,
    ///  Fields set in the template will also be added to all generated inputs
    // @@protoc_insertion_point(field:clarifai.api.InputsDataSource.input_template)
    pub input_template: ::protobuf::MessageField<Input>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputsDataSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputsDataSource {
    fn default() -> &'a InputsDataSource {
        <InputsDataSource as ::protobuf::Message>::default_instance()
    }
}

impl InputsDataSource {
    pub fn new() -> InputsDataSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_add_job_id",
            |m: &InputsDataSource| { &m.inputs_add_job_id },
            |m: &mut InputsDataSource| { &mut m.inputs_add_job_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DataSourceURL>(
            "url",
            |m: &InputsDataSource| { &m.url },
            |m: &mut InputsDataSource| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id_conflict_resolution",
            |m: &InputsDataSource| { &m.input_id_conflict_resolution },
            |m: &mut InputsDataSource| { &mut m.input_id_conflict_resolution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input_template",
            |m: &InputsDataSource| { &m.input_template },
            |m: &mut InputsDataSource| { &mut m.input_template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputsDataSource>(
            "InputsDataSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputsDataSource {
    const NAME: &'static str = "InputsDataSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.inputs_add_job_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.url)?;
                },
                24 => {
                    self.input_id_conflict_resolution = is.read_enum_or_unknown()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input_template)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.inputs_add_job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.inputs_add_job_id);
        }
        if let Some(v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(3, self.input_id_conflict_resolution.value());
        }
        if let Some(v) = self.input_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.inputs_add_job_id.is_empty() {
            os.write_string(1, &self.inputs_add_job_id)?;
        }
        if let Some(v) = self.url.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.input_id_conflict_resolution))?;
        }
        if let Some(v) = self.input_template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputsDataSource {
        InputsDataSource::new()
    }

    fn clear(&mut self) {
        self.inputs_add_job_id.clear();
        self.url.clear();
        self.input_id_conflict_resolution = ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET);
        self.input_template.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputsDataSource {
        static instance: InputsDataSource = InputsDataSource {
            inputs_add_job_id: ::std::string::String::new(),
            url: ::protobuf::MessageField::none(),
            input_id_conflict_resolution: ::protobuf::EnumOrUnknown::from_i32(0),
            input_template: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputsDataSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputsDataSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputsDataSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputsDataSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.DataSourceURL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DataSourceURL {
    // message fields
    ///  Supported providers are AWS S3, Azure blob, GCP cloud storage.
    // @@protoc_insertion_point(field:clarifai.api.DataSourceURL.url)
    pub url: ::std::string::String,
    ///  Credentials that would allow access to the provided url
    // @@protoc_insertion_point(field:clarifai.api.DataSourceURL.credentials)
    pub credentials: ::protobuf::MessageField<DataSourceCredentials>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DataSourceURL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataSourceURL {
    fn default() -> &'a DataSourceURL {
        <DataSourceURL as ::protobuf::Message>::default_instance()
    }
}

impl DataSourceURL {
    pub fn new() -> DataSourceURL {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &DataSourceURL| { &m.url },
            |m: &mut DataSourceURL| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DataSourceCredentials>(
            "credentials",
            |m: &DataSourceURL| { &m.credentials },
            |m: &mut DataSourceURL| { &mut m.credentials },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataSourceURL>(
            "DataSourceURL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataSourceURL {
    const NAME: &'static str = "DataSourceURL";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.credentials)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if let Some(v) = self.credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if let Some(v) = self.credentials.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataSourceURL {
        DataSourceURL::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.credentials.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataSourceURL {
        static instance: DataSourceURL = DataSourceURL {
            url: ::std::string::String::new(),
            credentials: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataSourceURL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataSourceURL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataSourceURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataSourceURL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.DataSourceCredentials)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DataSourceCredentials {
    // message oneof groups
    pub credentials: ::std::option::Option<data_source_credentials::Credentials>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DataSourceCredentials.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataSourceCredentials {
    fn default() -> &'a DataSourceCredentials {
        <DataSourceCredentials as ::protobuf::Message>::default_instance()
    }
}

impl DataSourceCredentials {
    pub fn new() -> DataSourceCredentials {
        ::std::default::Default::default()
    }

    // .clarifai.api.AWSCreds s3_creds = 1;

    pub fn s3_creds(&self) -> &AWSCreds {
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::S3Creds(ref v)) => v,
            _ => <AWSCreds as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_s3_creds(&mut self) {
        self.credentials = ::std::option::Option::None;
    }

    pub fn has_s3_creds(&self) -> bool {
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::S3Creds(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_s3_creds(&mut self, v: AWSCreds) {
        self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::S3Creds(v))
    }

    // Mutable pointer to the field.
    pub fn mut_s3_creds(&mut self) -> &mut AWSCreds {
        if let ::std::option::Option::Some(data_source_credentials::Credentials::S3Creds(_)) = self.credentials {
        } else {
            self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::S3Creds(AWSCreds::new()));
        }
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::S3Creds(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_s3_creds(&mut self) -> AWSCreds {
        if self.has_s3_creds() {
            match self.credentials.take() {
                ::std::option::Option::Some(data_source_credentials::Credentials::S3Creds(v)) => v,
                _ => panic!(),
            }
        } else {
            AWSCreds::new()
        }
    }

    // bytes gcp_creds = 2;

    pub fn gcp_creds(&self) -> &[u8] {
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::GcpCreds(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_gcp_creds(&mut self) {
        self.credentials = ::std::option::Option::None;
    }

    pub fn has_gcp_creds(&self) -> bool {
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::GcpCreds(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcp_creds(&mut self, v: ::std::vec::Vec<u8>) {
        self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::GcpCreds(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcp_creds(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(data_source_credentials::Credentials::GcpCreds(_)) = self.credentials {
        } else {
            self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::GcpCreds(::std::vec::Vec::new()));
        }
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::GcpCreds(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcp_creds(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_gcp_creds() {
            match self.credentials.take() {
                ::std::option::Option::Some(data_source_credentials::Credentials::GcpCreds(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .clarifai.api.AzureBlobCreds azure_blob_creds = 4;

    pub fn azure_blob_creds(&self) -> &AzureBlobCreds {
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::AzureBlobCreds(ref v)) => v,
            _ => <AzureBlobCreds as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_azure_blob_creds(&mut self) {
        self.credentials = ::std::option::Option::None;
    }

    pub fn has_azure_blob_creds(&self) -> bool {
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::AzureBlobCreds(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_azure_blob_creds(&mut self, v: AzureBlobCreds) {
        self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::AzureBlobCreds(v))
    }

    // Mutable pointer to the field.
    pub fn mut_azure_blob_creds(&mut self) -> &mut AzureBlobCreds {
        if let ::std::option::Option::Some(data_source_credentials::Credentials::AzureBlobCreds(_)) = self.credentials {
        } else {
            self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::AzureBlobCreds(AzureBlobCreds::new()));
        }
        match self.credentials {
            ::std::option::Option::Some(data_source_credentials::Credentials::AzureBlobCreds(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_azure_blob_creds(&mut self) -> AzureBlobCreds {
        if self.has_azure_blob_creds() {
            match self.credentials.take() {
                ::std::option::Option::Some(data_source_credentials::Credentials::AzureBlobCreds(v)) => v,
                _ => panic!(),
            }
        } else {
            AzureBlobCreds::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AWSCreds>(
            "s3_creds",
            DataSourceCredentials::has_s3_creds,
            DataSourceCredentials::s3_creds,
            DataSourceCredentials::mut_s3_creds,
            DataSourceCredentials::set_s3_creds,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "gcp_creds",
            DataSourceCredentials::has_gcp_creds,
            DataSourceCredentials::gcp_creds,
            DataSourceCredentials::set_gcp_creds,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AzureBlobCreds>(
            "azure_blob_creds",
            DataSourceCredentials::has_azure_blob_creds,
            DataSourceCredentials::azure_blob_creds,
            DataSourceCredentials::mut_azure_blob_creds,
            DataSourceCredentials::set_azure_blob_creds,
        ));
        oneofs.push(data_source_credentials::Credentials::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataSourceCredentials>(
            "DataSourceCredentials",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataSourceCredentials {
    const NAME: &'static str = "DataSourceCredentials";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::S3Creds(is.read_message()?));
                },
                18 => {
                    self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::GcpCreds(is.read_bytes()?));
                },
                34 => {
                    self.credentials = ::std::option::Option::Some(data_source_credentials::Credentials::AzureBlobCreds(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.credentials {
            match v {
                &data_source_credentials::Credentials::S3Creds(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &data_source_credentials::Credentials::GcpCreds(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &data_source_credentials::Credentials::AzureBlobCreds(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.credentials {
            match v {
                &data_source_credentials::Credentials::S3Creds(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &data_source_credentials::Credentials::GcpCreds(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &data_source_credentials::Credentials::AzureBlobCreds(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataSourceCredentials {
        DataSourceCredentials::new()
    }

    fn clear(&mut self) {
        self.credentials = ::std::option::Option::None;
        self.credentials = ::std::option::Option::None;
        self.credentials = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataSourceCredentials {
        static instance: DataSourceCredentials = DataSourceCredentials {
            credentials: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataSourceCredentials {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataSourceCredentials").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataSourceCredentials {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataSourceCredentials {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DataSourceCredentials`
pub mod data_source_credentials {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.DataSourceCredentials.credentials)
    pub enum Credentials {
        // @@protoc_insertion_point(oneof_field:clarifai.api.DataSourceCredentials.s3_creds)
        S3Creds(super::AWSCreds),
        // @@protoc_insertion_point(oneof_field:clarifai.api.DataSourceCredentials.gcp_creds)
        GcpCreds(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:clarifai.api.DataSourceCredentials.azure_blob_creds)
        AzureBlobCreds(super::AzureBlobCreds),
    }

    impl ::protobuf::Oneof for Credentials {
    }

    impl ::protobuf::OneofFull for Credentials {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DataSourceCredentials as ::protobuf::MessageFull>::descriptor().oneof_by_name("credentials").unwrap()).clone()
        }
    }

    impl Credentials {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Credentials>("credentials")
        }
    }
}

///  AWS S3 storage credentials.
// @@protoc_insertion_point(message:clarifai.api.AWSCreds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AWSCreds {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.AWSCreds.region)
    pub region: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.AWSCreds.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.AWSCreds.secret)
    pub secret: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.AWSCreds.token)
    pub token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AWSCreds.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AWSCreds {
    fn default() -> &'a AWSCreds {
        <AWSCreds as ::protobuf::Message>::default_instance()
    }
}

impl AWSCreds {
    pub fn new() -> AWSCreds {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "region",
            |m: &AWSCreds| { &m.region },
            |m: &mut AWSCreds| { &mut m.region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AWSCreds| { &m.id },
            |m: &mut AWSCreds| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "secret",
            |m: &AWSCreds| { &m.secret },
            |m: &mut AWSCreds| { &mut m.secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &AWSCreds| { &m.token },
            |m: &mut AWSCreds| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AWSCreds>(
            "AWSCreds",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AWSCreds {
    const NAME: &'static str = "AWSCreds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.region = is.read_string()?;
                },
                26 => {
                    self.id = is.read_string()?;
                },
                34 => {
                    self.secret = is.read_string()?;
                },
                42 => {
                    self.token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.region.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.region);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        if !self.secret.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.secret);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.region.is_empty() {
            os.write_string(2, &self.region)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        if !self.secret.is_empty() {
            os.write_string(4, &self.secret)?;
        }
        if !self.token.is_empty() {
            os.write_string(5, &self.token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AWSCreds {
        AWSCreds::new()
    }

    fn clear(&mut self) {
        self.region.clear();
        self.id.clear();
        self.secret.clear();
        self.token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AWSCreds {
        static instance: AWSCreds = AWSCreds {
            region: ::std::string::String::new(),
            id: ::std::string::String::new(),
            secret: ::std::string::String::new(),
            token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AWSCreds {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AWSCreds").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AWSCreds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AWSCreds {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Azure Blob storage credentials.
// @@protoc_insertion_point(message:clarifai.api.AzureBlobCreds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AzureBlobCreds {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.AzureBlobCreds.account_name)
    pub account_name: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.AzureBlobCreds.account_key)
    pub account_key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AzureBlobCreds.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AzureBlobCreds {
    fn default() -> &'a AzureBlobCreds {
        <AzureBlobCreds as ::protobuf::Message>::default_instance()
    }
}

impl AzureBlobCreds {
    pub fn new() -> AzureBlobCreds {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account_name",
            |m: &AzureBlobCreds| { &m.account_name },
            |m: &mut AzureBlobCreds| { &mut m.account_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account_key",
            |m: &AzureBlobCreds| { &m.account_key },
            |m: &mut AzureBlobCreds| { &mut m.account_key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AzureBlobCreds>(
            "AzureBlobCreds",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AzureBlobCreds {
    const NAME: &'static str = "AzureBlobCreds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.account_name = is.read_string()?;
                },
                18 => {
                    self.account_key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.account_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_name);
        }
        if !self.account_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.account_name.is_empty() {
            os.write_string(1, &self.account_name)?;
        }
        if !self.account_key.is_empty() {
            os.write_string(2, &self.account_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AzureBlobCreds {
        AzureBlobCreds::new()
    }

    fn clear(&mut self) {
        self.account_name.clear();
        self.account_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AzureBlobCreds {
        static instance: AzureBlobCreds = AzureBlobCreds {
            account_name: ::std::string::String::new(),
            account_key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AzureBlobCreds {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AzureBlobCreds").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AzureBlobCreds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureBlobCreds {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.InputsUpload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputsUpload {
    // message fields
    ///  Collect statistics about created inputs in job with given ID.
    ///  * If job ID is empty, then job is automatically created with random ID.
    ///  * If job ID is non-empty, then a new job will be created with given ID.
    // @@protoc_insertion_point(field:clarifai.api.InputsUpload.inputs_add_job_id)
    pub inputs_add_job_id: ::std::string::String,
    ///  Personal Access Token to the application to which inputs are added
    // @@protoc_insertion_point(field:clarifai.api.InputsUpload.app_pat)
    pub app_pat: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.InputsUpload.upload)
    pub upload: ::protobuf::MessageField<Upload>,
    ///  How to handle input ID conflicts.
    // @@protoc_insertion_point(field:clarifai.api.InputsUpload.input_id_conflict_resolution)
    pub input_id_conflict_resolution: ::protobuf::EnumOrUnknown<InputIDConflictResolution>,
    ///  Fields set in the template will also be added to all generated inputs
    // @@protoc_insertion_point(field:clarifai.api.InputsUpload.input_template)
    pub input_template: ::protobuf::MessageField<Input>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.InputsUpload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputsUpload {
    fn default() -> &'a InputsUpload {
        <InputsUpload as ::protobuf::Message>::default_instance()
    }
}

impl InputsUpload {
    pub fn new() -> InputsUpload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_add_job_id",
            |m: &InputsUpload| { &m.inputs_add_job_id },
            |m: &mut InputsUpload| { &mut m.inputs_add_job_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_pat",
            |m: &InputsUpload| { &m.app_pat },
            |m: &mut InputsUpload| { &mut m.app_pat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Upload>(
            "upload",
            |m: &InputsUpload| { &m.upload },
            |m: &mut InputsUpload| { &mut m.upload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id_conflict_resolution",
            |m: &InputsUpload| { &m.input_id_conflict_resolution },
            |m: &mut InputsUpload| { &mut m.input_id_conflict_resolution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Input>(
            "input_template",
            |m: &InputsUpload| { &m.input_template },
            |m: &mut InputsUpload| { &mut m.input_template },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputsUpload>(
            "InputsUpload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputsUpload {
    const NAME: &'static str = "InputsUpload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.inputs_add_job_id = is.read_string()?;
                },
                18 => {
                    self.app_pat = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.upload)?;
                },
                32 => {
                    self.input_id_conflict_resolution = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input_template)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.inputs_add_job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.inputs_add_job_id);
        }
        if !self.app_pat.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_pat);
        }
        if let Some(v) = self.upload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(4, self.input_id_conflict_resolution.value());
        }
        if let Some(v) = self.input_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.inputs_add_job_id.is_empty() {
            os.write_string(1, &self.inputs_add_job_id)?;
        }
        if !self.app_pat.is_empty() {
            os.write_string(2, &self.app_pat)?;
        }
        if let Some(v) = self.upload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.input_id_conflict_resolution))?;
        }
        if let Some(v) = self.input_template.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputsUpload {
        InputsUpload::new()
    }

    fn clear(&mut self) {
        self.inputs_add_job_id.clear();
        self.app_pat.clear();
        self.upload.clear();
        self.input_id_conflict_resolution = ::protobuf::EnumOrUnknown::new(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET);
        self.input_template.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputsUpload {
        static instance: InputsUpload = InputsUpload {
            inputs_add_job_id: ::std::string::String::new(),
            app_pat: ::std::string::String::new(),
            upload: ::protobuf::MessageField::none(),
            input_id_conflict_resolution: ::protobuf::EnumOrUnknown::from_i32(0),
            input_template: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputsUpload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputsUpload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputsUpload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputsUpload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.BookmarkOrigin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BookmarkOrigin {
    // message fields
    ///  original resource id
    // @@protoc_insertion_point(field:clarifai.api.BookmarkOrigin.id)
    pub id: ::std::string::String,
    ///  original resource app id
    // @@protoc_insertion_point(field:clarifai.api.BookmarkOrigin.app_id)
    pub app_id: ::std::string::String,
    ///  original resource user id
    // @@protoc_insertion_point(field:clarifai.api.BookmarkOrigin.user_id)
    pub user_id: ::std::string::String,
    ///  resource type.
    // @@protoc_insertion_point(field:clarifai.api.BookmarkOrigin.resource_type)
    pub resource_type: ::protobuf::EnumOrUnknown<bookmark_origin::BookmarkType>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.BookmarkOrigin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BookmarkOrigin {
    fn default() -> &'a BookmarkOrigin {
        <BookmarkOrigin as ::protobuf::Message>::default_instance()
    }
}

impl BookmarkOrigin {
    pub fn new() -> BookmarkOrigin {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &BookmarkOrigin| { &m.id },
            |m: &mut BookmarkOrigin| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &BookmarkOrigin| { &m.app_id },
            |m: &mut BookmarkOrigin| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &BookmarkOrigin| { &m.user_id },
            |m: &mut BookmarkOrigin| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resource_type",
            |m: &BookmarkOrigin| { &m.resource_type },
            |m: &mut BookmarkOrigin| { &mut m.resource_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BookmarkOrigin>(
            "BookmarkOrigin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BookmarkOrigin {
    const NAME: &'static str = "BookmarkOrigin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.app_id = is.read_string()?;
                },
                26 => {
                    self.user_id = is.read_string()?;
                },
                32 => {
                    self.resource_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.user_id);
        }
        if self.resource_type != ::protobuf::EnumOrUnknown::new(bookmark_origin::BookmarkType::unknown) {
            my_size += ::protobuf::rt::int32_size(4, self.resource_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(3, &self.user_id)?;
        }
        if self.resource_type != ::protobuf::EnumOrUnknown::new(bookmark_origin::BookmarkType::unknown) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.resource_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BookmarkOrigin {
        BookmarkOrigin::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.resource_type = ::protobuf::EnumOrUnknown::new(bookmark_origin::BookmarkType::unknown);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BookmarkOrigin {
        static instance: BookmarkOrigin = BookmarkOrigin {
            id: ::std::string::String::new(),
            app_id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            resource_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BookmarkOrigin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BookmarkOrigin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BookmarkOrigin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookmarkOrigin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BookmarkOrigin`
pub mod bookmark_origin {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.BookmarkOrigin.BookmarkType)
    pub enum BookmarkType {
        // @@protoc_insertion_point(enum_value:clarifai.api.BookmarkOrigin.BookmarkType.unknown)
        unknown = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.BookmarkOrigin.BookmarkType.model)
        model = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.BookmarkOrigin.BookmarkType.workflow)
        workflow = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.BookmarkOrigin.BookmarkType.dataset)
        dataset = 3,
        // @@protoc_insertion_point(enum_value:clarifai.api.BookmarkOrigin.BookmarkType.module)
        module = 4,
    }

    impl ::protobuf::Enum for BookmarkType {
        const NAME: &'static str = "BookmarkType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BookmarkType> {
            match value {
                0 => ::std::option::Option::Some(BookmarkType::unknown),
                1 => ::std::option::Option::Some(BookmarkType::model),
                2 => ::std::option::Option::Some(BookmarkType::workflow),
                3 => ::std::option::Option::Some(BookmarkType::dataset),
                4 => ::std::option::Option::Some(BookmarkType::module),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<BookmarkType> {
            match str {
                "unknown" => ::std::option::Option::Some(BookmarkType::unknown),
                "model" => ::std::option::Option::Some(BookmarkType::model),
                "workflow" => ::std::option::Option::Some(BookmarkType::workflow),
                "dataset" => ::std::option::Option::Some(BookmarkType::dataset),
                "module" => ::std::option::Option::Some(BookmarkType::module),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BookmarkType] = &[
            BookmarkType::unknown,
            BookmarkType::model,
            BookmarkType::workflow,
            BookmarkType::dataset,
            BookmarkType::module,
        ];
    }

    impl ::protobuf::EnumFull for BookmarkType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BookmarkOrigin.BookmarkType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BookmarkType {
        fn default() -> Self {
            BookmarkType::unknown
        }
    }

    impl BookmarkType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BookmarkType>("BookmarkOrigin.BookmarkType")
        }
    }
}

///  A worker for compute within a nodepool of instances.
///  This asks the API for work
// @@protoc_insertion_point(message:clarifai.api.Runner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Runner {
    // message fields
    ///  A unique ID for this app module.
    ///  This is a UUID since runners can be automatically orchestrated.
    // @@protoc_insertion_point(field:clarifai.api.Runner.id)
    pub id: ::std::string::String,
    ///  A short description for this app module to be used in grids of modules.
    // @@protoc_insertion_point(field:clarifai.api.Runner.description)
    pub description: ::std::string::String,
    ///  When the app module was created.
    // @@protoc_insertion_point(field:clarifai.api.Runner.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  When the app module was last modified.
    // @@protoc_insertion_point(field:clarifai.api.Runner.modified_at)
    pub modified_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  To handle arbitrary json metadata you can use a struct field:
    ///  https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
    ///  This is an optional arg.
    // @@protoc_insertion_point(field:clarifai.api.Runner.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    ///  The owner of the runner. Runners belong to a user/org account.
    // @@protoc_insertion_point(field:clarifai.api.Runner.user_id)
    pub user_id: ::std::string::String,
    ///  Labels to match in order to find work.
    // @@protoc_insertion_point(field:clarifai.api.Runner.labels)
    pub labels: ::std::vec::Vec<::std::string::String>,
    ///  Runners are defined within nodepools so this field needs the id and user_id of the nodepool
    ///  to be provided when creating a Runner.
    ///  This nodepool must be accessible to you or an org you are part of.
    // @@protoc_insertion_point(field:clarifai.api.Runner.nodepool)
    pub nodepool: ::protobuf::MessageField<Nodepool>,
    /// //////////////////////////
    ///  Need resources on the runner so we can schedule this Runner into the Nodepool.
    ///  If this runner is being orchestrated for a model then the orchestrator will set this to the
    ///  model resource requirements. If a workflow then it'll compute those requirements and set
    ///  populate this resource field.
    ///  Having this on the underlying object like Model and Workflow allows us to represent the minimum
    ///  requirements on those object, which may be less than what the Runner allocates (as a safety
    ///  margin for the runner to for sure run the resource).
    // @@protoc_insertion_point(field:clarifai.api.Runner.compute_info)
    pub compute_info: ::protobuf::MessageField<ComputeInfo>,
    // message oneof groups
    pub object: ::std::option::Option<runner::Object>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Runner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Runner {
    fn default() -> &'a Runner {
        <Runner as ::protobuf::Message>::default_instance()
    }
}

impl Runner {
    pub fn new() -> Runner {
        ::std::default::Default::default()
    }

    // .clarifai.api.Model model = 9;

    pub fn model(&self) -> &Model {
        match self.object {
            ::std::option::Option::Some(runner::Object::Model(ref v)) => v,
            _ => <Model as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_model(&mut self) {
        self.object = ::std::option::Option::None;
    }

    pub fn has_model(&self) -> bool {
        match self.object {
            ::std::option::Option::Some(runner::Object::Model(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: Model) {
        self.object = ::std::option::Option::Some(runner::Object::Model(v))
    }

    // Mutable pointer to the field.
    pub fn mut_model(&mut self) -> &mut Model {
        if let ::std::option::Option::Some(runner::Object::Model(_)) = self.object {
        } else {
            self.object = ::std::option::Option::Some(runner::Object::Model(Model::new()));
        }
        match self.object {
            ::std::option::Option::Some(runner::Object::Model(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_model(&mut self) -> Model {
        if self.has_model() {
            match self.object.take() {
                ::std::option::Option::Some(runner::Object::Model(v)) => v,
                _ => panic!(),
            }
        } else {
            Model::new()
        }
    }

    // .clarifai.api.Workflow workflow = 10;

    pub fn workflow(&self) -> &Workflow {
        match self.object {
            ::std::option::Option::Some(runner::Object::Workflow(ref v)) => v,
            _ => <Workflow as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_workflow(&mut self) {
        self.object = ::std::option::Option::None;
    }

    pub fn has_workflow(&self) -> bool {
        match self.object {
            ::std::option::Option::Some(runner::Object::Workflow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_workflow(&mut self, v: Workflow) {
        self.object = ::std::option::Option::Some(runner::Object::Workflow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_workflow(&mut self) -> &mut Workflow {
        if let ::std::option::Option::Some(runner::Object::Workflow(_)) = self.object {
        } else {
            self.object = ::std::option::Option::Some(runner::Object::Workflow(Workflow::new()));
        }
        match self.object {
            ::std::option::Option::Some(runner::Object::Workflow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_workflow(&mut self) -> Workflow {
        if self.has_workflow() {
            match self.object.take() {
                ::std::option::Option::Some(runner::Object::Workflow(v)) => v,
                _ => panic!(),
            }
        } else {
            Workflow::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Runner| { &m.id },
            |m: &mut Runner| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Runner| { &m.description },
            |m: &mut Runner| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "created_at",
            |m: &Runner| { &m.created_at },
            |m: &mut Runner| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "modified_at",
            |m: &Runner| { &m.modified_at },
            |m: &mut Runner| { &mut m.modified_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &Runner| { &m.metadata },
            |m: &mut Runner| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Runner| { &m.user_id },
            |m: &mut Runner| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &Runner| { &m.labels },
            |m: &mut Runner| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Model>(
            "model",
            Runner::has_model,
            Runner::model,
            Runner::mut_model,
            Runner::set_model,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Workflow>(
            "workflow",
            Runner::has_workflow,
            Runner::workflow,
            Runner::mut_workflow,
            Runner::set_workflow,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Nodepool>(
            "nodepool",
            |m: &Runner| { &m.nodepool },
            |m: &mut Runner| { &mut m.nodepool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ComputeInfo>(
            "compute_info",
            |m: &Runner| { &m.compute_info },
            |m: &mut Runner| { &mut m.compute_info },
        ));
        oneofs.push(runner::Object::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Runner>(
            "Runner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Runner {
    const NAME: &'static str = "Runner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.modified_at)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                50 => {
                    self.user_id = is.read_string()?;
                },
                58 => {
                    self.labels.push(is.read_string()?);
                },
                74 => {
                    self.object = ::std::option::Option::Some(runner::Object::Model(is.read_message()?));
                },
                82 => {
                    self.object = ::std::option::Option::Some(runner::Object::Workflow(is.read_message()?));
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodepool)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.compute_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.user_id);
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.nodepool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.compute_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.object {
            match v {
                &runner::Object::Model(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &runner::Object::Workflow(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.modified_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(6, &self.user_id)?;
        }
        for v in &self.labels {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.nodepool.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.compute_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.object {
            match v {
                &runner::Object::Model(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &runner::Object::Workflow(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Runner {
        Runner::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.metadata.clear();
        self.user_id.clear();
        self.labels.clear();
        self.object = ::std::option::Option::None;
        self.object = ::std::option::Option::None;
        self.nodepool.clear();
        self.compute_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Runner {
        static instance: Runner = Runner {
            id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            created_at: ::protobuf::MessageField::none(),
            modified_at: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            user_id: ::std::string::String::new(),
            labels: ::std::vec::Vec::new(),
            nodepool: ::protobuf::MessageField::none(),
            compute_info: ::protobuf::MessageField::none(),
            object: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Runner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Runner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Runner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Runner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Runner`
pub mod runner {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.Runner.object)
    pub enum Object {
        // @@protoc_insertion_point(oneof_field:clarifai.api.Runner.model)
        Model(super::Model),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Runner.workflow)
        Workflow(super::Workflow),
    }

    impl ::protobuf::Oneof for Object {
    }

    impl ::protobuf::OneofFull for Object {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Runner as ::protobuf::MessageFull>::descriptor().oneof_by_name("object").unwrap()).clone()
        }
    }

    impl Object {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Object>("object")
        }
    }
}

///  A nodepool is a set of nodes dedicated for a given user's compute needs.
///  This compute will typically be consumed by runners and in the future other objects
///  like UI modules may be assigned to node pools.
// @@protoc_insertion_point(message:clarifai.api.Nodepool)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Nodepool {
    // message fields
    ///  The user defined ID of the nodepool.
    // @@protoc_insertion_point(field:clarifai.api.Nodepool.id)
    pub id: ::std::string::String,
    ///  The user/org that this nodepool belongs to.
    // @@protoc_insertion_point(field:clarifai.api.Nodepool.user_id)
    pub user_id: ::std::string::String,
    ///  Which cloud region this nodepool is within.
    // @@protoc_insertion_point(field:clarifai.api.Nodepool.cloud_region)
    pub cloud_region: ::protobuf::MessageField<CloudRegion>,
    // @@protoc_insertion_point(field:clarifai.api.Nodepool.capacity_types)
    pub capacity_types: ::std::vec::Vec<::protobuf::EnumOrUnknown<nodepool::CapacityType>>,
    /// ////////////////////////////////////
    ///  The instance types that will be available in this pool of nodes.
    ///  Clarifai offers multiple different choices that combine cpu cores, memory and accelerator.
    // @@protoc_insertion_point(field:clarifai.api.Nodepool.instance_types)
    pub instance_types: ::std::vec::Vec<::std::string::String>,
    ///  Minimum number of instances in this nodepool. This allows the nodeool to scale down to this
    ///  amount. A nodepool needs a minimum of 1 instance.
    // @@protoc_insertion_point(field:clarifai.api.Nodepool.min_instances)
    pub min_instances: u32,
    ///  An upper limit on the number of instances in this nodepool. This allows the nodepool to scale
    ///  up to this amount.
    // @@protoc_insertion_point(field:clarifai.api.Nodepool.max_instances)
    pub max_instances: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Nodepool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Nodepool {
    fn default() -> &'a Nodepool {
        <Nodepool as ::protobuf::Message>::default_instance()
    }
}

impl Nodepool {
    pub fn new() -> Nodepool {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Nodepool| { &m.id },
            |m: &mut Nodepool| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Nodepool| { &m.user_id },
            |m: &mut Nodepool| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CloudRegion>(
            "cloud_region",
            |m: &Nodepool| { &m.cloud_region },
            |m: &mut Nodepool| { &mut m.cloud_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "capacity_types",
            |m: &Nodepool| { &m.capacity_types },
            |m: &mut Nodepool| { &mut m.capacity_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "instance_types",
            |m: &Nodepool| { &m.instance_types },
            |m: &mut Nodepool| { &mut m.instance_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_instances",
            |m: &Nodepool| { &m.min_instances },
            |m: &mut Nodepool| { &mut m.min_instances },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_instances",
            |m: &Nodepool| { &m.max_instances },
            |m: &mut Nodepool| { &mut m.max_instances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Nodepool>(
            "Nodepool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Nodepool {
    const NAME: &'static str = "Nodepool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.user_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cloud_region)?;
                },
                32 => {
                    self.capacity_types.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.capacity_types)?
                },
                66 => {
                    self.instance_types.push(is.read_string()?);
                },
                72 => {
                    self.min_instances = is.read_uint32()?;
                },
                80 => {
                    self.max_instances = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_id);
        }
        if let Some(v) = self.cloud_region.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.capacity_types {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        for value in &self.instance_types {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.min_instances != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.min_instances);
        }
        if self.max_instances != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.max_instances);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(2, &self.user_id)?;
        }
        if let Some(v) = self.cloud_region.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.capacity_types {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.instance_types {
            os.write_string(8, &v)?;
        };
        if self.min_instances != 0 {
            os.write_uint32(9, self.min_instances)?;
        }
        if self.max_instances != 0 {
            os.write_uint32(10, self.max_instances)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Nodepool {
        Nodepool::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.user_id.clear();
        self.cloud_region.clear();
        self.capacity_types.clear();
        self.instance_types.clear();
        self.min_instances = 0;
        self.max_instances = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Nodepool {
        static instance: Nodepool = Nodepool {
            id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            cloud_region: ::protobuf::MessageField::none(),
            capacity_types: ::std::vec::Vec::new(),
            instance_types: ::std::vec::Vec::new(),
            min_instances: 0,
            max_instances: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Nodepool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Nodepool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Nodepool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Nodepool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Nodepool`
pub mod nodepool {
    ///  Type of nodes that are ok for instances in this pool.
    ///  If both spot and on-demand are provided then the runner will be able to run on either
    ///  with a preference for spot until they are not available.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.Nodepool.CapacityType)
    pub enum CapacityType {
        // @@protoc_insertion_point(enum_value:clarifai.api.Nodepool.CapacityType.UKNOWN_CAPACITY_TYPE)
        UKNOWN_CAPACITY_TYPE = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.Nodepool.CapacityType.ONDEMAND_TYPE)
        ONDEMAND_TYPE = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.Nodepool.CapacityType.SPOT_TYPE)
        SPOT_TYPE = 2,
    }

    impl ::protobuf::Enum for CapacityType {
        const NAME: &'static str = "CapacityType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CapacityType> {
            match value {
                0 => ::std::option::Option::Some(CapacityType::UKNOWN_CAPACITY_TYPE),
                1 => ::std::option::Option::Some(CapacityType::ONDEMAND_TYPE),
                2 => ::std::option::Option::Some(CapacityType::SPOT_TYPE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<CapacityType> {
            match str {
                "UKNOWN_CAPACITY_TYPE" => ::std::option::Option::Some(CapacityType::UKNOWN_CAPACITY_TYPE),
                "ONDEMAND_TYPE" => ::std::option::Option::Some(CapacityType::ONDEMAND_TYPE),
                "SPOT_TYPE" => ::std::option::Option::Some(CapacityType::SPOT_TYPE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CapacityType] = &[
            CapacityType::UKNOWN_CAPACITY_TYPE,
            CapacityType::ONDEMAND_TYPE,
            CapacityType::SPOT_TYPE,
        ];
    }

    impl ::protobuf::EnumFull for CapacityType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Nodepool.CapacityType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CapacityType {
        fn default() -> Self {
            CapacityType::UKNOWN_CAPACITY_TYPE
        }
    }

    impl CapacityType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CapacityType>("Nodepool.CapacityType")
        }
    }
}

///  We define a cloud region here to be used in Nodepools and by the cloud agent.
///  There will be one cloud agent per CloudRegion.
///  This allows us to define CloudRegions that are VPCs within one physical cloud and have that
///  managed by one cloud agent which can list all nodepools for that VPC to deploy them and
///  orchestrate work within them.
// @@protoc_insertion_point(message:clarifai.api.CloudRegion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CloudRegion {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CloudRegion.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.CloudRegion.cloud)
    pub cloud: ::protobuf::EnumOrUnknown<cloud_region::Cloud>,
    ///  The region. The naming here depends on the cloud choice above and will be validated
    ///  against which clouds+regions that Clarifai currently supports.
    // @@protoc_insertion_point(field:clarifai.api.CloudRegion.region)
    pub region: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CloudRegion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CloudRegion {
    fn default() -> &'a CloudRegion {
        <CloudRegion as ::protobuf::Message>::default_instance()
    }
}

impl CloudRegion {
    pub fn new() -> CloudRegion {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CloudRegion| { &m.id },
            |m: &mut CloudRegion| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cloud",
            |m: &CloudRegion| { &m.cloud },
            |m: &mut CloudRegion| { &mut m.cloud },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "region",
            |m: &CloudRegion| { &m.region },
            |m: &mut CloudRegion| { &mut m.region },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CloudRegion>(
            "CloudRegion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CloudRegion {
    const NAME: &'static str = "CloudRegion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                24 => {
                    self.cloud = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.region = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.cloud != ::protobuf::EnumOrUnknown::new(cloud_region::Cloud::UNKOWN_CLOUD) {
            my_size += ::protobuf::rt::int32_size(3, self.cloud.value());
        }
        if !self.region.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.region);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.cloud != ::protobuf::EnumOrUnknown::new(cloud_region::Cloud::UNKOWN_CLOUD) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.cloud))?;
        }
        if !self.region.is_empty() {
            os.write_string(4, &self.region)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CloudRegion {
        CloudRegion::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.cloud = ::protobuf::EnumOrUnknown::new(cloud_region::Cloud::UNKOWN_CLOUD);
        self.region.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CloudRegion {
        static instance: CloudRegion = CloudRegion {
            id: ::std::string::String::new(),
            cloud: ::protobuf::EnumOrUnknown::from_i32(0),
            region: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CloudRegion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CloudRegion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CloudRegion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloudRegion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CloudRegion`
pub mod cloud_region {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.CloudRegion.Cloud)
    pub enum Cloud {
        // @@protoc_insertion_point(enum_value:clarifai.api.CloudRegion.Cloud.UNKOWN_CLOUD)
        UNKOWN_CLOUD = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.CloudRegion.Cloud.SELF_HOSTED)
        SELF_HOSTED = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.CloudRegion.Cloud.AWS)
        AWS = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.CloudRegion.Cloud.GCP)
        GCP = 3,
        // @@protoc_insertion_point(enum_value:clarifai.api.CloudRegion.Cloud.AZURE)
        AZURE = 4,
        // @@protoc_insertion_point(enum_value:clarifai.api.CloudRegion.Cloud.LAMBDA)
        LAMBDA = 5,
    }

    impl ::protobuf::Enum for Cloud {
        const NAME: &'static str = "Cloud";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Cloud> {
            match value {
                0 => ::std::option::Option::Some(Cloud::UNKOWN_CLOUD),
                1 => ::std::option::Option::Some(Cloud::SELF_HOSTED),
                2 => ::std::option::Option::Some(Cloud::AWS),
                3 => ::std::option::Option::Some(Cloud::GCP),
                4 => ::std::option::Option::Some(Cloud::AZURE),
                5 => ::std::option::Option::Some(Cloud::LAMBDA),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Cloud> {
            match str {
                "UNKOWN_CLOUD" => ::std::option::Option::Some(Cloud::UNKOWN_CLOUD),
                "SELF_HOSTED" => ::std::option::Option::Some(Cloud::SELF_HOSTED),
                "AWS" => ::std::option::Option::Some(Cloud::AWS),
                "GCP" => ::std::option::Option::Some(Cloud::GCP),
                "AZURE" => ::std::option::Option::Some(Cloud::AZURE),
                "LAMBDA" => ::std::option::Option::Some(Cloud::LAMBDA),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Cloud] = &[
            Cloud::UNKOWN_CLOUD,
            Cloud::SELF_HOSTED,
            Cloud::AWS,
            Cloud::GCP,
            Cloud::AZURE,
            Cloud::LAMBDA,
        ];
    }

    impl ::protobuf::EnumFull for Cloud {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CloudRegion.Cloud").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Cloud {
        fn default() -> Self {
            Cloud::UNKOWN_CLOUD
        }
    }

    impl Cloud {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Cloud>("CloudRegion.Cloud")
        }
    }
}

///  These are the resource needs of a given API object such as a model.
///  This is what they require as a minimum to run and will be used upon scheduling
///  as the request and limit for the k8s pod. If we want to separate limits and requests in the
///  future we can allow setting a limits ComputeInfo and a requests ComputeInfo.
// @@protoc_insertion_point(message:clarifai.api.ComputeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComputeInfo {
    // message fields
    ///  Number of CPUs.
    // @@protoc_insertion_point(field:clarifai.api.ComputeInfo.num_cpus)
    pub num_cpus: u32,
    ///  Amount of CPU memory to use as a minimum.
    // @@protoc_insertion_point(field:clarifai.api.ComputeInfo.cpu_memory)
    pub cpu_memory: ::std::string::String,
    ///  Number of accelerators (typically GPUs, TPUs, etc. not CPUs) for this resource.
    // @@protoc_insertion_point(field:clarifai.api.ComputeInfo.num_accelerators)
    pub num_accelerators: u32,
    ///  Amount of accelerator/GPU memory to use as a minimum.
    ///  This is defined per accelerator.
    ///  This follows the format used by kubernetes like 1Ki, 2Mi, 3Gi, 4Ti.
    // @@protoc_insertion_point(field:clarifai.api.ComputeInfo.accelerator_memory)
    pub accelerator_memory: ::std::string::String,
    ///  Or should it be removed completely and use the nodepool accelerator type itself.
    ///  These are the supported accelerators that the model can run on.
    // @@protoc_insertion_point(field:clarifai.api.ComputeInfo.accelerator_type)
    pub accelerator_type: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ComputeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComputeInfo {
    fn default() -> &'a ComputeInfo {
        <ComputeInfo as ::protobuf::Message>::default_instance()
    }
}

impl ComputeInfo {
    pub fn new() -> ComputeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_cpus",
            |m: &ComputeInfo| { &m.num_cpus },
            |m: &mut ComputeInfo| { &mut m.num_cpus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cpu_memory",
            |m: &ComputeInfo| { &m.cpu_memory },
            |m: &mut ComputeInfo| { &mut m.cpu_memory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_accelerators",
            |m: &ComputeInfo| { &m.num_accelerators },
            |m: &mut ComputeInfo| { &mut m.num_accelerators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accelerator_memory",
            |m: &ComputeInfo| { &m.accelerator_memory },
            |m: &mut ComputeInfo| { &mut m.accelerator_memory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accelerator_type",
            |m: &ComputeInfo| { &m.accelerator_type },
            |m: &mut ComputeInfo| { &mut m.accelerator_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComputeInfo>(
            "ComputeInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComputeInfo {
    const NAME: &'static str = "ComputeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_cpus = is.read_uint32()?;
                },
                18 => {
                    self.cpu_memory = is.read_string()?;
                },
                24 => {
                    self.num_accelerators = is.read_uint32()?;
                },
                34 => {
                    self.accelerator_memory = is.read_string()?;
                },
                42 => {
                    self.accelerator_type.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.num_cpus != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.num_cpus);
        }
        if !self.cpu_memory.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cpu_memory);
        }
        if self.num_accelerators != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.num_accelerators);
        }
        if !self.accelerator_memory.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.accelerator_memory);
        }
        for value in &self.accelerator_type {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.num_cpus != 0 {
            os.write_uint32(1, self.num_cpus)?;
        }
        if !self.cpu_memory.is_empty() {
            os.write_string(2, &self.cpu_memory)?;
        }
        if self.num_accelerators != 0 {
            os.write_uint32(3, self.num_accelerators)?;
        }
        if !self.accelerator_memory.is_empty() {
            os.write_string(4, &self.accelerator_memory)?;
        }
        for v in &self.accelerator_type {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComputeInfo {
        ComputeInfo::new()
    }

    fn clear(&mut self) {
        self.num_cpus = 0;
        self.cpu_memory.clear();
        self.num_accelerators = 0;
        self.accelerator_memory.clear();
        self.accelerator_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComputeInfo {
        static instance: ComputeInfo = ComputeInfo {
            num_cpus: 0,
            cpu_memory: ::std::string::String::new(),
            num_accelerators: 0,
            accelerator_memory: ::std::string::String::new(),
            accelerator_type: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComputeInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComputeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComputeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputeInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  It might be better to do this as runner autoscaling so that resources
///  of a model are very simply what that model needs at minimum.
///  Note that resources for things like modes inside runners are not
///  related to how many replicas of those runners are needed to handle traffic.
// @@protoc_insertion_point(message:clarifai.api.AutoscaleConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AutoscaleConfig {
    // message fields
    ///  The minimum number of replicas for the runner to have.
    ///  Defaults to 0 which means autoscaling can scale down to zero.
    ///  If you want a replica always up then set to >= 1.
    // @@protoc_insertion_point(field:clarifai.api.AutoscaleConfig.min_replicas)
    pub min_replicas: u32,
    ///  The maximium number of replicas to scale up the runner to.
    // @@protoc_insertion_point(field:clarifai.api.AutoscaleConfig.max_replicas)
    pub max_replicas: u32,
    ///  The number of seconds of traffic history to consider when autoscaling.
    // @@protoc_insertion_point(field:clarifai.api.AutoscaleConfig.traffic_history_seconds)
    pub traffic_history_seconds: u32,
    ///  The time to wait before scaling down after the last request.
    // @@protoc_insertion_point(field:clarifai.api.AutoscaleConfig.scale_down_delay_seconds)
    pub scale_down_delay_seconds: u32,
    ///  The time to wait between scaling up replicas without burst traffic.
    // @@protoc_insertion_point(field:clarifai.api.AutoscaleConfig.scale_up_delay_seconds)
    pub scale_up_delay_seconds: u32,
    ///  Depending on your plan you may be able to enable packing of resources into a single node
    ///  for more compute and cost efficiency.
    // @@protoc_insertion_point(field:clarifai.api.AutoscaleConfig.enable_packing)
    pub enable_packing: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.AutoscaleConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AutoscaleConfig {
    fn default() -> &'a AutoscaleConfig {
        <AutoscaleConfig as ::protobuf::Message>::default_instance()
    }
}

impl AutoscaleConfig {
    pub fn new() -> AutoscaleConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_replicas",
            |m: &AutoscaleConfig| { &m.min_replicas },
            |m: &mut AutoscaleConfig| { &mut m.min_replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_replicas",
            |m: &AutoscaleConfig| { &m.max_replicas },
            |m: &mut AutoscaleConfig| { &mut m.max_replicas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "traffic_history_seconds",
            |m: &AutoscaleConfig| { &m.traffic_history_seconds },
            |m: &mut AutoscaleConfig| { &mut m.traffic_history_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scale_down_delay_seconds",
            |m: &AutoscaleConfig| { &m.scale_down_delay_seconds },
            |m: &mut AutoscaleConfig| { &mut m.scale_down_delay_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scale_up_delay_seconds",
            |m: &AutoscaleConfig| { &m.scale_up_delay_seconds },
            |m: &mut AutoscaleConfig| { &mut m.scale_up_delay_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enable_packing",
            |m: &AutoscaleConfig| { &m.enable_packing },
            |m: &mut AutoscaleConfig| { &mut m.enable_packing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutoscaleConfig>(
            "AutoscaleConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AutoscaleConfig {
    const NAME: &'static str = "AutoscaleConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.min_replicas = is.read_uint32()?;
                },
                16 => {
                    self.max_replicas = is.read_uint32()?;
                },
                24 => {
                    self.traffic_history_seconds = is.read_uint32()?;
                },
                32 => {
                    self.scale_down_delay_seconds = is.read_uint32()?;
                },
                40 => {
                    self.scale_up_delay_seconds = is.read_uint32()?;
                },
                48 => {
                    self.enable_packing = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.min_replicas != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.min_replicas);
        }
        if self.max_replicas != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.max_replicas);
        }
        if self.traffic_history_seconds != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.traffic_history_seconds);
        }
        if self.scale_down_delay_seconds != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.scale_down_delay_seconds);
        }
        if self.scale_up_delay_seconds != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.scale_up_delay_seconds);
        }
        if self.enable_packing != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.min_replicas != 0 {
            os.write_uint32(1, self.min_replicas)?;
        }
        if self.max_replicas != 0 {
            os.write_uint32(2, self.max_replicas)?;
        }
        if self.traffic_history_seconds != 0 {
            os.write_uint32(3, self.traffic_history_seconds)?;
        }
        if self.scale_down_delay_seconds != 0 {
            os.write_uint32(4, self.scale_down_delay_seconds)?;
        }
        if self.scale_up_delay_seconds != 0 {
            os.write_uint32(5, self.scale_up_delay_seconds)?;
        }
        if self.enable_packing != false {
            os.write_bool(6, self.enable_packing)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AutoscaleConfig {
        AutoscaleConfig::new()
    }

    fn clear(&mut self) {
        self.min_replicas = 0;
        self.max_replicas = 0;
        self.traffic_history_seconds = 0;
        self.scale_down_delay_seconds = 0;
        self.scale_up_delay_seconds = 0;
        self.enable_packing = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AutoscaleConfig {
        static instance: AutoscaleConfig = AutoscaleConfig {
            min_replicas: 0,
            max_replicas: 0,
            traffic_history_seconds: 0,
            scale_down_delay_seconds: 0,
            scale_up_delay_seconds: 0,
            enable_packing: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AutoscaleConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AutoscaleConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AutoscaleConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AutoscaleConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A deployment allows you to configure how runners for a particular type of resource will
///  scale up and down. These are unique per user_id, nodepool and model so for differnet nodepools
///  you can scale differently.
// @@protoc_insertion_point(message:clarifai.api.Deployment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Deployment {
    // message fields
    ///  An id for this configured deployment.
    // @@protoc_insertion_point(field:clarifai.api.Deployment.id)
    pub id: ::std::string::String,
    ///  The user who owns the deployment. These live in the user/org account.
    // @@protoc_insertion_point(field:clarifai.api.Deployment.user_id)
    pub user_id: ::std::string::String,
    ///  How to autoscale the object.
    // @@protoc_insertion_point(field:clarifai.api.Deployment.autoscale_config)
    pub autoscale_config: ::protobuf::MessageField<AutoscaleConfig>,
    ///  You can configure different autoscaling per nodepool(s).
    ///  These nodepools have to be also owned by the same user_id/org as this deployment.
    ///  If there is more than one nodepool we use the model's ComputeInfo to match
    ///  with what the nodepool provides to decide which one can handle it combined with the
    ///  NodepoolRank below. Note: even within a single nodepool if it is heterogeneous then
    ///  we need a way to rank scheduling choices when we don't know how to decide (like a model
    ///  supports
    // @@protoc_insertion_point(field:clarifai.api.Deployment.nodepools)
    pub nodepools: ::std::vec::Vec<Nodepool>,
    // @@protoc_insertion_point(field:clarifai.api.Deployment.scheduling_choice)
    pub scheduling_choice: ::protobuf::EnumOrUnknown<deployment::SchedulingChoice>,
    // message oneof groups
    pub object: ::std::option::Option<deployment::Object>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Deployment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Deployment {
    fn default() -> &'a Deployment {
        <Deployment as ::protobuf::Message>::default_instance()
    }
}

impl Deployment {
    pub fn new() -> Deployment {
        ::std::default::Default::default()
    }

    // .clarifai.api.Model model = 5;

    pub fn model(&self) -> &Model {
        match self.object {
            ::std::option::Option::Some(deployment::Object::Model(ref v)) => v,
            _ => <Model as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_model(&mut self) {
        self.object = ::std::option::Option::None;
    }

    pub fn has_model(&self) -> bool {
        match self.object {
            ::std::option::Option::Some(deployment::Object::Model(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: Model) {
        self.object = ::std::option::Option::Some(deployment::Object::Model(v))
    }

    // Mutable pointer to the field.
    pub fn mut_model(&mut self) -> &mut Model {
        if let ::std::option::Option::Some(deployment::Object::Model(_)) = self.object {
        } else {
            self.object = ::std::option::Option::Some(deployment::Object::Model(Model::new()));
        }
        match self.object {
            ::std::option::Option::Some(deployment::Object::Model(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_model(&mut self) -> Model {
        if self.has_model() {
            match self.object.take() {
                ::std::option::Option::Some(deployment::Object::Model(v)) => v,
                _ => panic!(),
            }
        } else {
            Model::new()
        }
    }

    // .clarifai.api.Workflow workflow = 6;

    pub fn workflow(&self) -> &Workflow {
        match self.object {
            ::std::option::Option::Some(deployment::Object::Workflow(ref v)) => v,
            _ => <Workflow as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_workflow(&mut self) {
        self.object = ::std::option::Option::None;
    }

    pub fn has_workflow(&self) -> bool {
        match self.object {
            ::std::option::Option::Some(deployment::Object::Workflow(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_workflow(&mut self, v: Workflow) {
        self.object = ::std::option::Option::Some(deployment::Object::Workflow(v))
    }

    // Mutable pointer to the field.
    pub fn mut_workflow(&mut self) -> &mut Workflow {
        if let ::std::option::Option::Some(deployment::Object::Workflow(_)) = self.object {
        } else {
            self.object = ::std::option::Option::Some(deployment::Object::Workflow(Workflow::new()));
        }
        match self.object {
            ::std::option::Option::Some(deployment::Object::Workflow(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_workflow(&mut self) -> Workflow {
        if self.has_workflow() {
            match self.object.take() {
                ::std::option::Option::Some(deployment::Object::Workflow(v)) => v,
                _ => panic!(),
            }
        } else {
            Workflow::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Deployment| { &m.id },
            |m: &mut Deployment| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &Deployment| { &m.user_id },
            |m: &mut Deployment| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AutoscaleConfig>(
            "autoscale_config",
            |m: &Deployment| { &m.autoscale_config },
            |m: &mut Deployment| { &mut m.autoscale_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodepools",
            |m: &Deployment| { &m.nodepools },
            |m: &mut Deployment| { &mut m.nodepools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Model>(
            "model",
            Deployment::has_model,
            Deployment::model,
            Deployment::mut_model,
            Deployment::set_model,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Workflow>(
            "workflow",
            Deployment::has_workflow,
            Deployment::workflow,
            Deployment::mut_workflow,
            Deployment::set_workflow,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scheduling_choice",
            |m: &Deployment| { &m.scheduling_choice },
            |m: &mut Deployment| { &mut m.scheduling_choice },
        ));
        oneofs.push(deployment::Object::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Deployment>(
            "Deployment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Deployment {
    const NAME: &'static str = "Deployment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.user_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.autoscale_config)?;
                },
                34 => {
                    self.nodepools.push(is.read_message()?);
                },
                42 => {
                    self.object = ::std::option::Option::Some(deployment::Object::Model(is.read_message()?));
                },
                50 => {
                    self.object = ::std::option::Option::Some(deployment::Object::Workflow(is.read_message()?));
                },
                56 => {
                    self.scheduling_choice = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_id);
        }
        if let Some(v) = self.autoscale_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.nodepools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.scheduling_choice != ::protobuf::EnumOrUnknown::new(deployment::SchedulingChoice::UNKNOWN_SCHEDULING_CHOICE) {
            my_size += ::protobuf::rt::int32_size(7, self.scheduling_choice.value());
        }
        if let ::std::option::Option::Some(ref v) = self.object {
            match v {
                &deployment::Object::Model(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &deployment::Object::Workflow(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(2, &self.user_id)?;
        }
        if let Some(v) = self.autoscale_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.nodepools {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.scheduling_choice != ::protobuf::EnumOrUnknown::new(deployment::SchedulingChoice::UNKNOWN_SCHEDULING_CHOICE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.scheduling_choice))?;
        }
        if let ::std::option::Option::Some(ref v) = self.object {
            match v {
                &deployment::Object::Model(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &deployment::Object::Workflow(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Deployment {
        Deployment::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.user_id.clear();
        self.autoscale_config.clear();
        self.nodepools.clear();
        self.object = ::std::option::Option::None;
        self.object = ::std::option::Option::None;
        self.scheduling_choice = ::protobuf::EnumOrUnknown::new(deployment::SchedulingChoice::UNKNOWN_SCHEDULING_CHOICE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Deployment {
        static instance: Deployment = Deployment {
            id: ::std::string::String::new(),
            user_id: ::std::string::String::new(),
            autoscale_config: ::protobuf::MessageField::none(),
            nodepools: ::std::vec::Vec::new(),
            scheduling_choice: ::protobuf::EnumOrUnknown::from_i32(0),
            object: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Deployment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Deployment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Deployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deployment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Deployment`
pub mod deployment {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.Deployment.object)
    pub enum Object {
        // @@protoc_insertion_point(oneof_field:clarifai.api.Deployment.model)
        Model(super::Model),
        // @@protoc_insertion_point(oneof_field:clarifai.api.Deployment.workflow)
        Workflow(super::Workflow),
    }

    impl ::protobuf::Oneof for Object {
    }

    impl ::protobuf::OneofFull for Object {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Deployment as ::protobuf::MessageFull>::descriptor().oneof_by_name("object").unwrap()).clone()
        }
    }

    impl Object {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Object>("object")
        }
    }
    ///  In some scenarios it may not be obvous how we should schedule a resource to underlying nodes
    ///  within the nodepool(s) above. The SchedulerChoice allows us to specify how to decide which
    ///  nodepool to use when there are multiple nodepools and how to decide which type of node
    ///  within a nodepool if there are multiple types.
    ///  If here are multiple nondepools then a decision on which to use comes into play
    ///  if it is not specified in the prediction request.
    ///  Even with a single nodepool a choice may come up such as when a resource that needs scheduling
    ///  has not specified the accelerator types it supports and the nodepool has multiple types.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:clarifai.api.Deployment.SchedulingChoice)
    pub enum SchedulingChoice {
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.UNKNOWN_SCHEDULING_CHOICE)
        UNKNOWN_SCHEDULING_CHOICE = 0,
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.FAIL)
        FAIL = 1,
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.RANDOM)
        RANDOM = 2,
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.PRICE)
        PRICE = 3,
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.PERFORMANCE)
        PERFORMANCE = 4,
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.NETWORK)
        NETWORK = 5,
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.UTILIZATION)
        UTILIZATION = 6,
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.PREFER_SPOT)
        PREFER_SPOT = 7,
        // @@protoc_insertion_point(enum_value:clarifai.api.Deployment.SchedulingChoice.PREFER_ONDEMAND)
        PREFER_ONDEMAND = 8,
    }

    impl ::protobuf::Enum for SchedulingChoice {
        const NAME: &'static str = "SchedulingChoice";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SchedulingChoice> {
            match value {
                0 => ::std::option::Option::Some(SchedulingChoice::UNKNOWN_SCHEDULING_CHOICE),
                1 => ::std::option::Option::Some(SchedulingChoice::FAIL),
                2 => ::std::option::Option::Some(SchedulingChoice::RANDOM),
                3 => ::std::option::Option::Some(SchedulingChoice::PRICE),
                4 => ::std::option::Option::Some(SchedulingChoice::PERFORMANCE),
                5 => ::std::option::Option::Some(SchedulingChoice::NETWORK),
                6 => ::std::option::Option::Some(SchedulingChoice::UTILIZATION),
                7 => ::std::option::Option::Some(SchedulingChoice::PREFER_SPOT),
                8 => ::std::option::Option::Some(SchedulingChoice::PREFER_ONDEMAND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SchedulingChoice> {
            match str {
                "UNKNOWN_SCHEDULING_CHOICE" => ::std::option::Option::Some(SchedulingChoice::UNKNOWN_SCHEDULING_CHOICE),
                "FAIL" => ::std::option::Option::Some(SchedulingChoice::FAIL),
                "RANDOM" => ::std::option::Option::Some(SchedulingChoice::RANDOM),
                "PRICE" => ::std::option::Option::Some(SchedulingChoice::PRICE),
                "PERFORMANCE" => ::std::option::Option::Some(SchedulingChoice::PERFORMANCE),
                "NETWORK" => ::std::option::Option::Some(SchedulingChoice::NETWORK),
                "UTILIZATION" => ::std::option::Option::Some(SchedulingChoice::UTILIZATION),
                "PREFER_SPOT" => ::std::option::Option::Some(SchedulingChoice::PREFER_SPOT),
                "PREFER_ONDEMAND" => ::std::option::Option::Some(SchedulingChoice::PREFER_ONDEMAND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SchedulingChoice] = &[
            SchedulingChoice::UNKNOWN_SCHEDULING_CHOICE,
            SchedulingChoice::FAIL,
            SchedulingChoice::RANDOM,
            SchedulingChoice::PRICE,
            SchedulingChoice::PERFORMANCE,
            SchedulingChoice::NETWORK,
            SchedulingChoice::UTILIZATION,
            SchedulingChoice::PREFER_SPOT,
            SchedulingChoice::PREFER_ONDEMAND,
        ];
    }

    impl ::protobuf::EnumFull for SchedulingChoice {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Deployment.SchedulingChoice").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SchedulingChoice {
        fn default() -> Self {
            SchedulingChoice::UNKNOWN_SCHEDULING_CHOICE
        }
    }

    impl SchedulingChoice {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SchedulingChoice>("Deployment.SchedulingChoice")
        }
    }
}

/// ////////////////////////////////////////
///  Don't need RunnerSelector if we're opening up endpoints for deployments.
/// ////////////////////////////////////////
///  The RunnerSelector is an optional field we can provide during runtime
///  of model/workflow predictions to specify which particular runner we want to process the work.
///  This can optionally be used to select a particular nodepool and then within that nodepool
///  a particular runner.
// @@protoc_insertion_point(message:clarifai.api.RunnerSelector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RunnerSelector {
    // message fields
    ///  A particular nodepool for the resource to be run within. This request the id and user_id of
    ///  the nodepool to be specified. Runners will be scaled according to a deployment for the given
    ///  resource to be run. There should not be more than one deployment in this nodepool for the
    ///  particular resource to run. If no deployments then default autoscaling will be used.
    // @@protoc_insertion_point(field:clarifai.api.RunnerSelector.nodepool)
    pub nodepool: ::protobuf::MessageField<Nodepool>,
    ///  Optionally a partcular runner within the nodepool.
    // @@protoc_insertion_point(field:clarifai.api.RunnerSelector.runner)
    pub runner: ::protobuf::MessageField<Runner>,
    ///  Optionally a partcular deployment within the nodepool.
    // @@protoc_insertion_point(field:clarifai.api.RunnerSelector.deployment)
    pub deployment: ::protobuf::MessageField<Deployment>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.RunnerSelector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunnerSelector {
    fn default() -> &'a RunnerSelector {
        <RunnerSelector as ::protobuf::Message>::default_instance()
    }
}

impl RunnerSelector {
    pub fn new() -> RunnerSelector {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Nodepool>(
            "nodepool",
            |m: &RunnerSelector| { &m.nodepool },
            |m: &mut RunnerSelector| { &mut m.nodepool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Runner>(
            "runner",
            |m: &RunnerSelector| { &m.runner },
            |m: &mut RunnerSelector| { &mut m.runner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Deployment>(
            "deployment",
            |m: &RunnerSelector| { &m.deployment },
            |m: &mut RunnerSelector| { &mut m.deployment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunnerSelector>(
            "RunnerSelector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunnerSelector {
    const NAME: &'static str = "RunnerSelector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nodepool)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.runner)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deployment)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.nodepool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.runner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deployment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.nodepool.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.runner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.deployment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunnerSelector {
        RunnerSelector::new()
    }

    fn clear(&mut self) {
        self.nodepool.clear();
        self.runner.clear();
        self.deployment.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunnerSelector {
        static instance: RunnerSelector = RunnerSelector {
            nodepool: ::protobuf::MessageField::none(),
            runner: ::protobuf::MessageField::none(),
            deployment: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunnerSelector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunnerSelector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunnerSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunnerSelector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Processing info tells the runner how to process a RunnerItem
// @@protoc_insertion_point(message:clarifai.api.ProcessingInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProcessingInfo {
    // message fields
    ///  The type of method witin the runner to call.
    // @@protoc_insertion_point(field:clarifai.api.ProcessingInfo.runner_method_type)
    pub runner_method_type: ::protobuf::EnumOrUnknown<RunnerMethodType>,
    ///  A status of the processing. We use this for signalling end of a request stream, a runner
    ///  item's processing should be cancelled, etc.
    // @@protoc_insertion_point(field:clarifai.api.ProcessingInfo.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ProcessingInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessingInfo {
    fn default() -> &'a ProcessingInfo {
        <ProcessingInfo as ::protobuf::Message>::default_instance()
    }
}

impl ProcessingInfo {
    pub fn new() -> ProcessingInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_method_type",
            |m: &ProcessingInfo| { &m.runner_method_type },
            |m: &mut ProcessingInfo| { &mut m.runner_method_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ProcessingInfo| { &m.status },
            |m: &mut ProcessingInfo| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessingInfo>(
            "ProcessingInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessingInfo {
    const NAME: &'static str = "ProcessingInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.runner_method_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.runner_method_type != ::protobuf::EnumOrUnknown::new(RunnerMethodType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.runner_method_type.value());
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.runner_method_type != ::protobuf::EnumOrUnknown::new(RunnerMethodType::UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.runner_method_type))?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessingInfo {
        ProcessingInfo::new()
    }

    fn clear(&mut self) {
        self.runner_method_type = ::protobuf::EnumOrUnknown::new(RunnerMethodType::UNKNOWN);
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessingInfo {
        static instance: ProcessingInfo = ProcessingInfo {
            runner_method_type: ::protobuf::EnumOrUnknown::from_i32(0),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProcessingInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessingInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessingInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.WorkflowModelUseCase)
pub enum WorkflowModelUseCase {
    // @@protoc_insertion_point(enum_value:clarifai.api.WorkflowModelUseCase.WORKFLOW_MODEL_USE_CASE_NOT_SET)
    WORKFLOW_MODEL_USE_CASE_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.WorkflowModelUseCase.CLASSIFICATION)
    CLASSIFICATION = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.WorkflowModelUseCase.DETECTION)
    DETECTION = 2,
}

impl ::protobuf::Enum for WorkflowModelUseCase {
    const NAME: &'static str = "WorkflowModelUseCase";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkflowModelUseCase> {
        match value {
            0 => ::std::option::Option::Some(WorkflowModelUseCase::WORKFLOW_MODEL_USE_CASE_NOT_SET),
            1 => ::std::option::Option::Some(WorkflowModelUseCase::CLASSIFICATION),
            2 => ::std::option::Option::Some(WorkflowModelUseCase::DETECTION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<WorkflowModelUseCase> {
        match str {
            "WORKFLOW_MODEL_USE_CASE_NOT_SET" => ::std::option::Option::Some(WorkflowModelUseCase::WORKFLOW_MODEL_USE_CASE_NOT_SET),
            "CLASSIFICATION" => ::std::option::Option::Some(WorkflowModelUseCase::CLASSIFICATION),
            "DETECTION" => ::std::option::Option::Some(WorkflowModelUseCase::DETECTION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [WorkflowModelUseCase] = &[
        WorkflowModelUseCase::WORKFLOW_MODEL_USE_CASE_NOT_SET,
        WorkflowModelUseCase::CLASSIFICATION,
        WorkflowModelUseCase::DETECTION,
    ];
}

impl ::protobuf::EnumFull for WorkflowModelUseCase {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("WorkflowModelUseCase").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for WorkflowModelUseCase {
    fn default() -> Self {
        WorkflowModelUseCase::WORKFLOW_MODEL_USE_CASE_NOT_SET
    }
}

impl WorkflowModelUseCase {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WorkflowModelUseCase>("WorkflowModelUseCase")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.DatasetVersionRequestOrigin)
pub enum DatasetVersionRequestOrigin {
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionRequestOrigin.DATASET_VERSION_REQUEST_ORIGIN_NOT_SET)
    DATASET_VERSION_REQUEST_ORIGIN_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionRequestOrigin.MANUAL)
    MANUAL = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionRequestOrigin.TRAINING)
    TRAINING = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionRequestOrigin.EVAL_GROUND_TRUTH)
    EVAL_GROUND_TRUTH = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionRequestOrigin.EVAL_PREDICTIONS)
    EVAL_PREDICTIONS = 4,
}

impl ::protobuf::Enum for DatasetVersionRequestOrigin {
    const NAME: &'static str = "DatasetVersionRequestOrigin";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatasetVersionRequestOrigin> {
        match value {
            0 => ::std::option::Option::Some(DatasetVersionRequestOrigin::DATASET_VERSION_REQUEST_ORIGIN_NOT_SET),
            1 => ::std::option::Option::Some(DatasetVersionRequestOrigin::MANUAL),
            2 => ::std::option::Option::Some(DatasetVersionRequestOrigin::TRAINING),
            3 => ::std::option::Option::Some(DatasetVersionRequestOrigin::EVAL_GROUND_TRUTH),
            4 => ::std::option::Option::Some(DatasetVersionRequestOrigin::EVAL_PREDICTIONS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DatasetVersionRequestOrigin> {
        match str {
            "DATASET_VERSION_REQUEST_ORIGIN_NOT_SET" => ::std::option::Option::Some(DatasetVersionRequestOrigin::DATASET_VERSION_REQUEST_ORIGIN_NOT_SET),
            "MANUAL" => ::std::option::Option::Some(DatasetVersionRequestOrigin::MANUAL),
            "TRAINING" => ::std::option::Option::Some(DatasetVersionRequestOrigin::TRAINING),
            "EVAL_GROUND_TRUTH" => ::std::option::Option::Some(DatasetVersionRequestOrigin::EVAL_GROUND_TRUTH),
            "EVAL_PREDICTIONS" => ::std::option::Option::Some(DatasetVersionRequestOrigin::EVAL_PREDICTIONS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DatasetVersionRequestOrigin] = &[
        DatasetVersionRequestOrigin::DATASET_VERSION_REQUEST_ORIGIN_NOT_SET,
        DatasetVersionRequestOrigin::MANUAL,
        DatasetVersionRequestOrigin::TRAINING,
        DatasetVersionRequestOrigin::EVAL_GROUND_TRUTH,
        DatasetVersionRequestOrigin::EVAL_PREDICTIONS,
    ];
}

impl ::protobuf::EnumFull for DatasetVersionRequestOrigin {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DatasetVersionRequestOrigin").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DatasetVersionRequestOrigin {
    fn default() -> Self {
        DatasetVersionRequestOrigin::DATASET_VERSION_REQUEST_ORIGIN_NOT_SET
    }
}

impl DatasetVersionRequestOrigin {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DatasetVersionRequestOrigin>("DatasetVersionRequestOrigin")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.DatasetVersionMetricsGroupType)
pub enum DatasetVersionMetricsGroupType {
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET)
    DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.INPUT_TYPE)
    INPUT_TYPE = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.CONCEPT_ID)
    CONCEPT_ID = 10,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.CONCEPTS_COUNT)
    CONCEPTS_COUNT = 11,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.BOUNDING_BOXES_COUNT)
    BOUNDING_BOXES_COUNT = 20,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.POLYGONS_COUNT)
    POLYGONS_COUNT = 21,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.POINTS_COUNT)
    POINTS_COUNT = 22,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.MASKS_COUNT)
    MASKS_COUNT = 23,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.PIXELS_COUNT)
    PIXELS_COUNT = 30,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionMetricsGroupType.ASPECT_RATIO)
    ASPECT_RATIO = 31,
}

impl ::protobuf::Enum for DatasetVersionMetricsGroupType {
    const NAME: &'static str = "DatasetVersionMetricsGroupType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatasetVersionMetricsGroupType> {
        match value {
            0 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET),
            2 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::INPUT_TYPE),
            10 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::CONCEPT_ID),
            11 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::CONCEPTS_COUNT),
            20 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::BOUNDING_BOXES_COUNT),
            21 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::POLYGONS_COUNT),
            22 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::POINTS_COUNT),
            23 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::MASKS_COUNT),
            30 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::PIXELS_COUNT),
            31 => ::std::option::Option::Some(DatasetVersionMetricsGroupType::ASPECT_RATIO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DatasetVersionMetricsGroupType> {
        match str {
            "DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET),
            "INPUT_TYPE" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::INPUT_TYPE),
            "CONCEPT_ID" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::CONCEPT_ID),
            "CONCEPTS_COUNT" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::CONCEPTS_COUNT),
            "BOUNDING_BOXES_COUNT" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::BOUNDING_BOXES_COUNT),
            "POLYGONS_COUNT" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::POLYGONS_COUNT),
            "POINTS_COUNT" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::POINTS_COUNT),
            "MASKS_COUNT" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::MASKS_COUNT),
            "PIXELS_COUNT" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::PIXELS_COUNT),
            "ASPECT_RATIO" => ::std::option::Option::Some(DatasetVersionMetricsGroupType::ASPECT_RATIO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DatasetVersionMetricsGroupType] = &[
        DatasetVersionMetricsGroupType::DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET,
        DatasetVersionMetricsGroupType::INPUT_TYPE,
        DatasetVersionMetricsGroupType::CONCEPT_ID,
        DatasetVersionMetricsGroupType::CONCEPTS_COUNT,
        DatasetVersionMetricsGroupType::BOUNDING_BOXES_COUNT,
        DatasetVersionMetricsGroupType::POLYGONS_COUNT,
        DatasetVersionMetricsGroupType::POINTS_COUNT,
        DatasetVersionMetricsGroupType::MASKS_COUNT,
        DatasetVersionMetricsGroupType::PIXELS_COUNT,
        DatasetVersionMetricsGroupType::ASPECT_RATIO,
    ];
}

impl ::protobuf::EnumFull for DatasetVersionMetricsGroupType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DatasetVersionMetricsGroupType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DatasetVersionMetricsGroupType::DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET => 0,
            DatasetVersionMetricsGroupType::INPUT_TYPE => 1,
            DatasetVersionMetricsGroupType::CONCEPT_ID => 2,
            DatasetVersionMetricsGroupType::CONCEPTS_COUNT => 3,
            DatasetVersionMetricsGroupType::BOUNDING_BOXES_COUNT => 4,
            DatasetVersionMetricsGroupType::POLYGONS_COUNT => 5,
            DatasetVersionMetricsGroupType::POINTS_COUNT => 6,
            DatasetVersionMetricsGroupType::MASKS_COUNT => 7,
            DatasetVersionMetricsGroupType::PIXELS_COUNT => 8,
            DatasetVersionMetricsGroupType::ASPECT_RATIO => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DatasetVersionMetricsGroupType {
    fn default() -> Self {
        DatasetVersionMetricsGroupType::DATASET_VERSION_METRICS_GROUP_TYPE_NOT_SET
    }
}

impl DatasetVersionMetricsGroupType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DatasetVersionMetricsGroupType>("DatasetVersionMetricsGroupType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.DatasetVersionExportFormat)
pub enum DatasetVersionExportFormat {
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionExportFormat.DATASET_VERSION_EXPORT_FORMAT_NOT_SET)
    DATASET_VERSION_EXPORT_FORMAT_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionExportFormat.CLARIFAI_DATA_PROTOBUF)
    CLARIFAI_DATA_PROTOBUF = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionExportFormat.CLARIFAI_DATA_JSON)
    CLARIFAI_DATA_JSON = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.DatasetVersionExportFormat.COCO)
    COCO = 2,
}

impl ::protobuf::Enum for DatasetVersionExportFormat {
    const NAME: &'static str = "DatasetVersionExportFormat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatasetVersionExportFormat> {
        match value {
            0 => ::std::option::Option::Some(DatasetVersionExportFormat::DATASET_VERSION_EXPORT_FORMAT_NOT_SET),
            1 => ::std::option::Option::Some(DatasetVersionExportFormat::CLARIFAI_DATA_PROTOBUF),
            3 => ::std::option::Option::Some(DatasetVersionExportFormat::CLARIFAI_DATA_JSON),
            2 => ::std::option::Option::Some(DatasetVersionExportFormat::COCO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DatasetVersionExportFormat> {
        match str {
            "DATASET_VERSION_EXPORT_FORMAT_NOT_SET" => ::std::option::Option::Some(DatasetVersionExportFormat::DATASET_VERSION_EXPORT_FORMAT_NOT_SET),
            "CLARIFAI_DATA_PROTOBUF" => ::std::option::Option::Some(DatasetVersionExportFormat::CLARIFAI_DATA_PROTOBUF),
            "CLARIFAI_DATA_JSON" => ::std::option::Option::Some(DatasetVersionExportFormat::CLARIFAI_DATA_JSON),
            "COCO" => ::std::option::Option::Some(DatasetVersionExportFormat::COCO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DatasetVersionExportFormat] = &[
        DatasetVersionExportFormat::DATASET_VERSION_EXPORT_FORMAT_NOT_SET,
        DatasetVersionExportFormat::CLARIFAI_DATA_PROTOBUF,
        DatasetVersionExportFormat::CLARIFAI_DATA_JSON,
        DatasetVersionExportFormat::COCO,
    ];
}

impl ::protobuf::EnumFull for DatasetVersionExportFormat {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DatasetVersionExportFormat").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DatasetVersionExportFormat::DATASET_VERSION_EXPORT_FORMAT_NOT_SET => 0,
            DatasetVersionExportFormat::CLARIFAI_DATA_PROTOBUF => 1,
            DatasetVersionExportFormat::CLARIFAI_DATA_JSON => 2,
            DatasetVersionExportFormat::COCO => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DatasetVersionExportFormat {
    fn default() -> Self {
        DatasetVersionExportFormat::DATASET_VERSION_EXPORT_FORMAT_NOT_SET
    }
}

impl DatasetVersionExportFormat {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DatasetVersionExportFormat>("DatasetVersionExportFormat")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.ExpirationAction)
pub enum ExpirationAction {
    // @@protoc_insertion_point(enum_value:clarifai.api.ExpirationAction.EXPIRATION_ACTION_NOT_SET)
    EXPIRATION_ACTION_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.ExpirationAction.DELAY)
    DELAY = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.ExpirationAction.EXPIRY)
    EXPIRY = 2,
}

impl ::protobuf::Enum for ExpirationAction {
    const NAME: &'static str = "ExpirationAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExpirationAction> {
        match value {
            0 => ::std::option::Option::Some(ExpirationAction::EXPIRATION_ACTION_NOT_SET),
            1 => ::std::option::Option::Some(ExpirationAction::DELAY),
            2 => ::std::option::Option::Some(ExpirationAction::EXPIRY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ExpirationAction> {
        match str {
            "EXPIRATION_ACTION_NOT_SET" => ::std::option::Option::Some(ExpirationAction::EXPIRATION_ACTION_NOT_SET),
            "DELAY" => ::std::option::Option::Some(ExpirationAction::DELAY),
            "EXPIRY" => ::std::option::Option::Some(ExpirationAction::EXPIRY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ExpirationAction] = &[
        ExpirationAction::EXPIRATION_ACTION_NOT_SET,
        ExpirationAction::DELAY,
        ExpirationAction::EXPIRY,
    ];
}

impl ::protobuf::EnumFull for ExpirationAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ExpirationAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ExpirationAction {
    fn default() -> Self {
        ExpirationAction::EXPIRATION_ACTION_NOT_SET
    }
}

impl ExpirationAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ExpirationAction>("ExpirationAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.LicenseScope)
pub enum LicenseScope {
    // @@protoc_insertion_point(enum_value:clarifai.api.LicenseScope.LICENSE_SCOPE_NOT_SET)
    LICENSE_SCOPE_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.LicenseScope.PREDICT)
    PREDICT = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.LicenseScope.TRAIN)
    TRAIN = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.LicenseScope.SEARCH)
    SEARCH = 3,
}

impl ::protobuf::Enum for LicenseScope {
    const NAME: &'static str = "LicenseScope";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LicenseScope> {
        match value {
            0 => ::std::option::Option::Some(LicenseScope::LICENSE_SCOPE_NOT_SET),
            1 => ::std::option::Option::Some(LicenseScope::PREDICT),
            2 => ::std::option::Option::Some(LicenseScope::TRAIN),
            3 => ::std::option::Option::Some(LicenseScope::SEARCH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LicenseScope> {
        match str {
            "LICENSE_SCOPE_NOT_SET" => ::std::option::Option::Some(LicenseScope::LICENSE_SCOPE_NOT_SET),
            "PREDICT" => ::std::option::Option::Some(LicenseScope::PREDICT),
            "TRAIN" => ::std::option::Option::Some(LicenseScope::TRAIN),
            "SEARCH" => ::std::option::Option::Some(LicenseScope::SEARCH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LicenseScope] = &[
        LicenseScope::LICENSE_SCOPE_NOT_SET,
        LicenseScope::PREDICT,
        LicenseScope::TRAIN,
        LicenseScope::SEARCH,
    ];
}

impl ::protobuf::EnumFull for LicenseScope {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LicenseScope").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LicenseScope {
    fn default() -> Self {
        LicenseScope::LICENSE_SCOPE_NOT_SET
    }
}

impl LicenseScope {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LicenseScope>("LicenseScope")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.DataType)
pub enum DataType {
    // @@protoc_insertion_point(enum_value:clarifai.api.DataType.UNDEFINED)
    UNDEFINED = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.DataType.STRING)
    STRING = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.DataType.UINT8)
    UINT8 = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.DataType.INT32)
    INT32 = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.DataType.INT64)
    INT64 = 4,
    // @@protoc_insertion_point(enum_value:clarifai.api.DataType.FP32)
    FP32 = 5,
}

impl ::protobuf::Enum for DataType {
    const NAME: &'static str = "DataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataType> {
        match value {
            0 => ::std::option::Option::Some(DataType::UNDEFINED),
            1 => ::std::option::Option::Some(DataType::STRING),
            2 => ::std::option::Option::Some(DataType::UINT8),
            3 => ::std::option::Option::Some(DataType::INT32),
            4 => ::std::option::Option::Some(DataType::INT64),
            5 => ::std::option::Option::Some(DataType::FP32),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DataType> {
        match str {
            "UNDEFINED" => ::std::option::Option::Some(DataType::UNDEFINED),
            "STRING" => ::std::option::Option::Some(DataType::STRING),
            "UINT8" => ::std::option::Option::Some(DataType::UINT8),
            "INT32" => ::std::option::Option::Some(DataType::INT32),
            "INT64" => ::std::option::Option::Some(DataType::INT64),
            "FP32" => ::std::option::Option::Some(DataType::FP32),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DataType] = &[
        DataType::UNDEFINED,
        DataType::STRING,
        DataType::UINT8,
        DataType::INT32,
        DataType::INT64,
        DataType::FP32,
    ];
}

impl ::protobuf::EnumFull for DataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DataType {
    fn default() -> Self {
        DataType::UNDEFINED
    }
}

impl DataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataType>("DataType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.ValueComparator)
pub enum ValueComparator {
    // @@protoc_insertion_point(enum_value:clarifai.api.ValueComparator.CONCEPT_THRESHOLD_NOT_SET)
    CONCEPT_THRESHOLD_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.ValueComparator.GREATER_THAN)
    GREATER_THAN = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.ValueComparator.GREATER_THAN_OR_EQUAL)
    GREATER_THAN_OR_EQUAL = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.ValueComparator.LESS_THAN)
    LESS_THAN = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.ValueComparator.LESS_THAN_OR_EQUAL)
    LESS_THAN_OR_EQUAL = 4,
    // @@protoc_insertion_point(enum_value:clarifai.api.ValueComparator.EQUAL)
    EQUAL = 5,
}

impl ::protobuf::Enum for ValueComparator {
    const NAME: &'static str = "ValueComparator";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValueComparator> {
        match value {
            0 => ::std::option::Option::Some(ValueComparator::CONCEPT_THRESHOLD_NOT_SET),
            1 => ::std::option::Option::Some(ValueComparator::GREATER_THAN),
            2 => ::std::option::Option::Some(ValueComparator::GREATER_THAN_OR_EQUAL),
            3 => ::std::option::Option::Some(ValueComparator::LESS_THAN),
            4 => ::std::option::Option::Some(ValueComparator::LESS_THAN_OR_EQUAL),
            5 => ::std::option::Option::Some(ValueComparator::EQUAL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ValueComparator> {
        match str {
            "CONCEPT_THRESHOLD_NOT_SET" => ::std::option::Option::Some(ValueComparator::CONCEPT_THRESHOLD_NOT_SET),
            "GREATER_THAN" => ::std::option::Option::Some(ValueComparator::GREATER_THAN),
            "GREATER_THAN_OR_EQUAL" => ::std::option::Option::Some(ValueComparator::GREATER_THAN_OR_EQUAL),
            "LESS_THAN" => ::std::option::Option::Some(ValueComparator::LESS_THAN),
            "LESS_THAN_OR_EQUAL" => ::std::option::Option::Some(ValueComparator::LESS_THAN_OR_EQUAL),
            "EQUAL" => ::std::option::Option::Some(ValueComparator::EQUAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ValueComparator] = &[
        ValueComparator::CONCEPT_THRESHOLD_NOT_SET,
        ValueComparator::GREATER_THAN,
        ValueComparator::GREATER_THAN_OR_EQUAL,
        ValueComparator::LESS_THAN,
        ValueComparator::LESS_THAN_OR_EQUAL,
        ValueComparator::EQUAL,
    ];
}

impl ::protobuf::EnumFull for ValueComparator {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ValueComparator").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ValueComparator {
    fn default() -> Self {
        ValueComparator::CONCEPT_THRESHOLD_NOT_SET
    }
}

impl ValueComparator {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValueComparator>("ValueComparator")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.EvaluationType)
pub enum EvaluationType {
    // @@protoc_insertion_point(enum_value:clarifai.api.EvaluationType.Undefined)
    Undefined = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.EvaluationType.Classification)
    Classification = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.EvaluationType.Detection)
    Detection = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.EvaluationType.Segmentation)
    Segmentation = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.EvaluationType.Clustering)
    Clustering = 4,
    // @@protoc_insertion_point(enum_value:clarifai.api.EvaluationType.Tracker)
    Tracker = 5,
    // @@protoc_insertion_point(enum_value:clarifai.api.EvaluationType.Generation)
    Generation = 6,
}

impl ::protobuf::Enum for EvaluationType {
    const NAME: &'static str = "EvaluationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EvaluationType> {
        match value {
            0 => ::std::option::Option::Some(EvaluationType::Undefined),
            1 => ::std::option::Option::Some(EvaluationType::Classification),
            2 => ::std::option::Option::Some(EvaluationType::Detection),
            3 => ::std::option::Option::Some(EvaluationType::Segmentation),
            4 => ::std::option::Option::Some(EvaluationType::Clustering),
            5 => ::std::option::Option::Some(EvaluationType::Tracker),
            6 => ::std::option::Option::Some(EvaluationType::Generation),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EvaluationType> {
        match str {
            "Undefined" => ::std::option::Option::Some(EvaluationType::Undefined),
            "Classification" => ::std::option::Option::Some(EvaluationType::Classification),
            "Detection" => ::std::option::Option::Some(EvaluationType::Detection),
            "Segmentation" => ::std::option::Option::Some(EvaluationType::Segmentation),
            "Clustering" => ::std::option::Option::Some(EvaluationType::Clustering),
            "Tracker" => ::std::option::Option::Some(EvaluationType::Tracker),
            "Generation" => ::std::option::Option::Some(EvaluationType::Generation),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EvaluationType] = &[
        EvaluationType::Undefined,
        EvaluationType::Classification,
        EvaluationType::Detection,
        EvaluationType::Segmentation,
        EvaluationType::Clustering,
        EvaluationType::Tracker,
        EvaluationType::Generation,
    ];
}

impl ::protobuf::EnumFull for EvaluationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EvaluationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EvaluationType {
    fn default() -> Self {
        EvaluationType::Undefined
    }
}

impl EvaluationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EvaluationType>("EvaluationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.APIEventType)
pub enum APIEventType {
    // @@protoc_insertion_point(enum_value:clarifai.api.APIEventType.API_EVENT_TYPE_NOT_SET)
    API_EVENT_TYPE_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.APIEventType.ON_PREM_PREDICT)
    ON_PREM_PREDICT = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.APIEventType.ON_PREM_TRAIN)
    ON_PREM_TRAIN = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.APIEventType.ON_PREM_SEARCH)
    ON_PREM_SEARCH = 3,
}

impl ::protobuf::Enum for APIEventType {
    const NAME: &'static str = "APIEventType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<APIEventType> {
        match value {
            0 => ::std::option::Option::Some(APIEventType::API_EVENT_TYPE_NOT_SET),
            1 => ::std::option::Option::Some(APIEventType::ON_PREM_PREDICT),
            2 => ::std::option::Option::Some(APIEventType::ON_PREM_TRAIN),
            3 => ::std::option::Option::Some(APIEventType::ON_PREM_SEARCH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<APIEventType> {
        match str {
            "API_EVENT_TYPE_NOT_SET" => ::std::option::Option::Some(APIEventType::API_EVENT_TYPE_NOT_SET),
            "ON_PREM_PREDICT" => ::std::option::Option::Some(APIEventType::ON_PREM_PREDICT),
            "ON_PREM_TRAIN" => ::std::option::Option::Some(APIEventType::ON_PREM_TRAIN),
            "ON_PREM_SEARCH" => ::std::option::Option::Some(APIEventType::ON_PREM_SEARCH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [APIEventType] = &[
        APIEventType::API_EVENT_TYPE_NOT_SET,
        APIEventType::ON_PREM_PREDICT,
        APIEventType::ON_PREM_TRAIN,
        APIEventType::ON_PREM_SEARCH,
    ];
}

impl ::protobuf::EnumFull for APIEventType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("APIEventType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for APIEventType {
    fn default() -> Self {
        APIEventType::API_EVENT_TYPE_NOT_SET
    }
}

impl APIEventType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<APIEventType>("APIEventType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.UsageIntervalType)
pub enum UsageIntervalType {
    // @@protoc_insertion_point(enum_value:clarifai.api.UsageIntervalType.undef)
    undef = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.UsageIntervalType.day)
    day = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.UsageIntervalType.month)
    month = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.UsageIntervalType.year)
    year = 3,
}

impl ::protobuf::Enum for UsageIntervalType {
    const NAME: &'static str = "UsageIntervalType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UsageIntervalType> {
        match value {
            0 => ::std::option::Option::Some(UsageIntervalType::undef),
            1 => ::std::option::Option::Some(UsageIntervalType::day),
            2 => ::std::option::Option::Some(UsageIntervalType::month),
            3 => ::std::option::Option::Some(UsageIntervalType::year),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<UsageIntervalType> {
        match str {
            "undef" => ::std::option::Option::Some(UsageIntervalType::undef),
            "day" => ::std::option::Option::Some(UsageIntervalType::day),
            "month" => ::std::option::Option::Some(UsageIntervalType::month),
            "year" => ::std::option::Option::Some(UsageIntervalType::year),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [UsageIntervalType] = &[
        UsageIntervalType::undef,
        UsageIntervalType::day,
        UsageIntervalType::month,
        UsageIntervalType::year,
    ];
}

impl ::protobuf::EnumFull for UsageIntervalType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("UsageIntervalType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for UsageIntervalType {
    fn default() -> Self {
        UsageIntervalType::undef
    }
}

impl UsageIntervalType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UsageIntervalType>("UsageIntervalType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.AnnotationDataType)
pub enum AnnotationDataType {
    // @@protoc_insertion_point(enum_value:clarifai.api.AnnotationDataType.ANNOTATION_DATA_TYPE_NOT_SET)
    ANNOTATION_DATA_TYPE_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.AnnotationDataType.TAG)
    TAG = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.AnnotationDataType.BOUNDING_BOX)
    BOUNDING_BOX = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.AnnotationDataType.POLYGON)
    POLYGON = 4,
    // @@protoc_insertion_point(enum_value:clarifai.api.AnnotationDataType.POINT)
    POINT = 8,
    // @@protoc_insertion_point(enum_value:clarifai.api.AnnotationDataType.SPAN)
    SPAN = 16,
    // @@protoc_insertion_point(enum_value:clarifai.api.AnnotationDataType.MASK)
    MASK = 32,
}

impl ::protobuf::Enum for AnnotationDataType {
    const NAME: &'static str = "AnnotationDataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AnnotationDataType> {
        match value {
            0 => ::std::option::Option::Some(AnnotationDataType::ANNOTATION_DATA_TYPE_NOT_SET),
            1 => ::std::option::Option::Some(AnnotationDataType::TAG),
            2 => ::std::option::Option::Some(AnnotationDataType::BOUNDING_BOX),
            4 => ::std::option::Option::Some(AnnotationDataType::POLYGON),
            8 => ::std::option::Option::Some(AnnotationDataType::POINT),
            16 => ::std::option::Option::Some(AnnotationDataType::SPAN),
            32 => ::std::option::Option::Some(AnnotationDataType::MASK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AnnotationDataType> {
        match str {
            "ANNOTATION_DATA_TYPE_NOT_SET" => ::std::option::Option::Some(AnnotationDataType::ANNOTATION_DATA_TYPE_NOT_SET),
            "TAG" => ::std::option::Option::Some(AnnotationDataType::TAG),
            "BOUNDING_BOX" => ::std::option::Option::Some(AnnotationDataType::BOUNDING_BOX),
            "POLYGON" => ::std::option::Option::Some(AnnotationDataType::POLYGON),
            "POINT" => ::std::option::Option::Some(AnnotationDataType::POINT),
            "SPAN" => ::std::option::Option::Some(AnnotationDataType::SPAN),
            "MASK" => ::std::option::Option::Some(AnnotationDataType::MASK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AnnotationDataType] = &[
        AnnotationDataType::ANNOTATION_DATA_TYPE_NOT_SET,
        AnnotationDataType::TAG,
        AnnotationDataType::BOUNDING_BOX,
        AnnotationDataType::POLYGON,
        AnnotationDataType::POINT,
        AnnotationDataType::SPAN,
        AnnotationDataType::MASK,
    ];
}

impl ::protobuf::EnumFull for AnnotationDataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AnnotationDataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            AnnotationDataType::ANNOTATION_DATA_TYPE_NOT_SET => 0,
            AnnotationDataType::TAG => 1,
            AnnotationDataType::BOUNDING_BOX => 2,
            AnnotationDataType::POLYGON => 3,
            AnnotationDataType::POINT => 4,
            AnnotationDataType::SPAN => 5,
            AnnotationDataType::MASK => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AnnotationDataType {
    fn default() -> Self {
        AnnotationDataType::ANNOTATION_DATA_TYPE_NOT_SET
    }
}

impl AnnotationDataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AnnotationDataType>("AnnotationDataType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.RoleType)
pub enum RoleType {
    // @@protoc_insertion_point(enum_value:clarifai.api.RoleType.TEAM)
    TEAM = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.RoleType.ORG)
    ORG = 1,
}

impl ::protobuf::Enum for RoleType {
    const NAME: &'static str = "RoleType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RoleType> {
        match value {
            0 => ::std::option::Option::Some(RoleType::TEAM),
            1 => ::std::option::Option::Some(RoleType::ORG),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RoleType> {
        match str {
            "TEAM" => ::std::option::Option::Some(RoleType::TEAM),
            "ORG" => ::std::option::Option::Some(RoleType::ORG),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RoleType] = &[
        RoleType::TEAM,
        RoleType::ORG,
    ];
}

impl ::protobuf::EnumFull for RoleType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RoleType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RoleType {
    fn default() -> Self {
        RoleType::TEAM
    }
}

impl RoleType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RoleType>("RoleType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.StatValueAggType)
pub enum StatValueAggType {
    // @@protoc_insertion_point(enum_value:clarifai.api.StatValueAggType.SUM)
    SUM = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.StatValueAggType.AVG)
    AVG = 1,
}

impl ::protobuf::Enum for StatValueAggType {
    const NAME: &'static str = "StatValueAggType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatValueAggType> {
        match value {
            0 => ::std::option::Option::Some(StatValueAggType::SUM),
            1 => ::std::option::Option::Some(StatValueAggType::AVG),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<StatValueAggType> {
        match str {
            "SUM" => ::std::option::Option::Some(StatValueAggType::SUM),
            "AVG" => ::std::option::Option::Some(StatValueAggType::AVG),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [StatValueAggType] = &[
        StatValueAggType::SUM,
        StatValueAggType::AVG,
    ];
}

impl ::protobuf::EnumFull for StatValueAggType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("StatValueAggType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for StatValueAggType {
    fn default() -> Self {
        StatValueAggType::SUM
    }
}

impl StatValueAggType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StatValueAggType>("StatValueAggType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.StatTimeAggType)
pub enum StatTimeAggType {
    // @@protoc_insertion_point(enum_value:clarifai.api.StatTimeAggType.NO_TIME_AGG)
    NO_TIME_AGG = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.StatTimeAggType.YEAR)
    YEAR = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.StatTimeAggType.MONTH)
    MONTH = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.StatTimeAggType.WEEK)
    WEEK = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.StatTimeAggType.DAY)
    DAY = 4,
    // @@protoc_insertion_point(enum_value:clarifai.api.StatTimeAggType.HOUR)
    HOUR = 5,
    // @@protoc_insertion_point(enum_value:clarifai.api.StatTimeAggType.MINUTE)
    MINUTE = 6,
}

impl ::protobuf::Enum for StatTimeAggType {
    const NAME: &'static str = "StatTimeAggType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatTimeAggType> {
        match value {
            0 => ::std::option::Option::Some(StatTimeAggType::NO_TIME_AGG),
            1 => ::std::option::Option::Some(StatTimeAggType::YEAR),
            2 => ::std::option::Option::Some(StatTimeAggType::MONTH),
            3 => ::std::option::Option::Some(StatTimeAggType::WEEK),
            4 => ::std::option::Option::Some(StatTimeAggType::DAY),
            5 => ::std::option::Option::Some(StatTimeAggType::HOUR),
            6 => ::std::option::Option::Some(StatTimeAggType::MINUTE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<StatTimeAggType> {
        match str {
            "NO_TIME_AGG" => ::std::option::Option::Some(StatTimeAggType::NO_TIME_AGG),
            "YEAR" => ::std::option::Option::Some(StatTimeAggType::YEAR),
            "MONTH" => ::std::option::Option::Some(StatTimeAggType::MONTH),
            "WEEK" => ::std::option::Option::Some(StatTimeAggType::WEEK),
            "DAY" => ::std::option::Option::Some(StatTimeAggType::DAY),
            "HOUR" => ::std::option::Option::Some(StatTimeAggType::HOUR),
            "MINUTE" => ::std::option::Option::Some(StatTimeAggType::MINUTE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [StatTimeAggType] = &[
        StatTimeAggType::NO_TIME_AGG,
        StatTimeAggType::YEAR,
        StatTimeAggType::MONTH,
        StatTimeAggType::WEEK,
        StatTimeAggType::DAY,
        StatTimeAggType::HOUR,
        StatTimeAggType::MINUTE,
    ];
}

impl ::protobuf::EnumFull for StatTimeAggType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("StatTimeAggType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for StatTimeAggType {
    fn default() -> Self {
        StatTimeAggType::NO_TIME_AGG
    }
}

impl StatTimeAggType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StatTimeAggType>("StatTimeAggType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.ValidationErrorType)
pub enum ValidationErrorType {
    // @@protoc_insertion_point(enum_value:clarifai.api.ValidationErrorType.VALIDATION_ERROR_TYPE_NOT_SET)
    VALIDATION_ERROR_TYPE_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.ValidationErrorType.RESTRICTED)
    RESTRICTED = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.ValidationErrorType.DATABASE)
    DATABASE = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.ValidationErrorType.FORMAT)
    FORMAT = 3,
}

impl ::protobuf::Enum for ValidationErrorType {
    const NAME: &'static str = "ValidationErrorType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValidationErrorType> {
        match value {
            0 => ::std::option::Option::Some(ValidationErrorType::VALIDATION_ERROR_TYPE_NOT_SET),
            1 => ::std::option::Option::Some(ValidationErrorType::RESTRICTED),
            2 => ::std::option::Option::Some(ValidationErrorType::DATABASE),
            3 => ::std::option::Option::Some(ValidationErrorType::FORMAT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ValidationErrorType> {
        match str {
            "VALIDATION_ERROR_TYPE_NOT_SET" => ::std::option::Option::Some(ValidationErrorType::VALIDATION_ERROR_TYPE_NOT_SET),
            "RESTRICTED" => ::std::option::Option::Some(ValidationErrorType::RESTRICTED),
            "DATABASE" => ::std::option::Option::Some(ValidationErrorType::DATABASE),
            "FORMAT" => ::std::option::Option::Some(ValidationErrorType::FORMAT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ValidationErrorType] = &[
        ValidationErrorType::VALIDATION_ERROR_TYPE_NOT_SET,
        ValidationErrorType::RESTRICTED,
        ValidationErrorType::DATABASE,
        ValidationErrorType::FORMAT,
    ];
}

impl ::protobuf::EnumFull for ValidationErrorType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ValidationErrorType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ValidationErrorType {
    fn default() -> Self {
        ValidationErrorType::VALIDATION_ERROR_TYPE_NOT_SET
    }
}

impl ValidationErrorType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValidationErrorType>("ValidationErrorType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.InputIDConflictResolution)
pub enum InputIDConflictResolution {
    // @@protoc_insertion_point(enum_value:clarifai.api.InputIDConflictResolution.INPUT_ID_CONFLICT_RESOLUTION_NOT_SET)
    INPUT_ID_CONFLICT_RESOLUTION_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.InputIDConflictResolution.SKIP)
    SKIP = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.InputIDConflictResolution.SUFFIX)
    SUFFIX = 2,
}

impl ::protobuf::Enum for InputIDConflictResolution {
    const NAME: &'static str = "InputIDConflictResolution";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InputIDConflictResolution> {
        match value {
            0 => ::std::option::Option::Some(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET),
            1 => ::std::option::Option::Some(InputIDConflictResolution::SKIP),
            2 => ::std::option::Option::Some(InputIDConflictResolution::SUFFIX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<InputIDConflictResolution> {
        match str {
            "INPUT_ID_CONFLICT_RESOLUTION_NOT_SET" => ::std::option::Option::Some(InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET),
            "SKIP" => ::std::option::Option::Some(InputIDConflictResolution::SKIP),
            "SUFFIX" => ::std::option::Option::Some(InputIDConflictResolution::SUFFIX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [InputIDConflictResolution] = &[
        InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET,
        InputIDConflictResolution::SKIP,
        InputIDConflictResolution::SUFFIX,
    ];
}

impl ::protobuf::EnumFull for InputIDConflictResolution {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("InputIDConflictResolution").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for InputIDConflictResolution {
    fn default() -> Self {
        InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET
    }
}

impl InputIDConflictResolution {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InputIDConflictResolution>("InputIDConflictResolution")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.RunnerMethodType)
pub enum RunnerMethodType {
    // @@protoc_insertion_point(enum_value:clarifai.api.RunnerMethodType.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.RunnerMethodType.UNARY_UNARY)
    UNARY_UNARY = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.RunnerMethodType.UNARY_STREAMING)
    UNARY_STREAMING = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.RunnerMethodType.STREAMING_UNARY)
    STREAMING_UNARY = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.RunnerMethodType.STREAMING_STREAMING)
    STREAMING_STREAMING = 4,
}

impl ::protobuf::Enum for RunnerMethodType {
    const NAME: &'static str = "RunnerMethodType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RunnerMethodType> {
        match value {
            0 => ::std::option::Option::Some(RunnerMethodType::UNKNOWN),
            1 => ::std::option::Option::Some(RunnerMethodType::UNARY_UNARY),
            2 => ::std::option::Option::Some(RunnerMethodType::UNARY_STREAMING),
            3 => ::std::option::Option::Some(RunnerMethodType::STREAMING_UNARY),
            4 => ::std::option::Option::Some(RunnerMethodType::STREAMING_STREAMING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RunnerMethodType> {
        match str {
            "UNKNOWN" => ::std::option::Option::Some(RunnerMethodType::UNKNOWN),
            "UNARY_UNARY" => ::std::option::Option::Some(RunnerMethodType::UNARY_UNARY),
            "UNARY_STREAMING" => ::std::option::Option::Some(RunnerMethodType::UNARY_STREAMING),
            "STREAMING_UNARY" => ::std::option::Option::Some(RunnerMethodType::STREAMING_UNARY),
            "STREAMING_STREAMING" => ::std::option::Option::Some(RunnerMethodType::STREAMING_STREAMING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RunnerMethodType] = &[
        RunnerMethodType::UNKNOWN,
        RunnerMethodType::UNARY_UNARY,
        RunnerMethodType::UNARY_STREAMING,
        RunnerMethodType::STREAMING_UNARY,
        RunnerMethodType::STREAMING_STREAMING,
    ];
}

impl ::protobuf::EnumFull for RunnerMethodType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RunnerMethodType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RunnerMethodType {
    fn default() -> Self {
        RunnerMethodType::UNKNOWN
    }
}

impl RunnerMethodType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RunnerMethodType>("RunnerMethodType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"proto/clarifai/api/resources.proto\x12\x0cclarifai.api\x1a&proto/cla\
    rifai/api/status/status.proto\x1a+proto/clarifai/api/status/status_code.\
    proto\x1a)proto/clarifai/api/utils/extensions.proto\x1a%proto/clarifai/a\
    pi/utils/matrix.proto\x1a(proto/clarifai/auth/util/extension.proto\x1a\
    \x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\
    \x1a\x1egoogle/protobuf/wrappers.proto\"\xb0\x05\n\nAnnotation\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\n\x08input_id\x18\x02\x20\x01(\
    \tR\x07inputId\x12&\n\x04data\x18\x03\x20\x01(\x0b2\x12.clarifai.api.Dat\
    aR\x04data\x12@\n\x0fannotation_info\x18\r\x20\x01(\x0b2\x17.google.prot\
    obuf.StructR\x0eannotationInfo\x12\x17\n\x07user_id\x18\x0f\x20\x01(\tR\
    \x06userId\x12(\n\x10model_version_id\x18\x10\x20\x01(\tR\x0emodelVersio\
    nId\x127\n\x16embed_model_version_id\x18\x0e\x20\x01(\tR\x13embedModelVe\
    rsionIdB\x02\x18\x01\x123\n\x06status\x18\x07\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x129\n\ncreated_at\x18\x08\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\t\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x12\x1c\n\x07t\
    rusted\x18\n\x20\x01(\x08R\x07trustedB\x02\x18\x01\x12\x1f\n\x0binput_le\
    vel\x18\x11\x20\x01(\x08R\ninputLevel\x12>\n\x0econsensus_info\x18\x12\
    \x20\x01(\x0b2\x17.google.protobuf.StructR\rconsensusInfo\x12\x17\n\x07t\
    ask_id\x18\x13\x20\x01(\tR\x06taskId\x12.\n\x13workflow_version_id\x18\
    \x14\x20\x01(\tR\x11workflowVersionIdJ\x04\x08\x04\x10\x05J\x04\x08\x05\
    \x10\x06J\x04\x08\x06\x10\x07J\x04\x08\x0b\x10\x0cJ\x04\x08\x0c\x10\r\"\
    \x9f\x01\n\x06Worker\x12(\n\x04user\x18\x01\x20\x01(\x0b2\x12.clarifai.a\
    pi.UserH\0R\x04user\x12+\n\x05model\x18\x02\x20\x01(\x0b2\x13.clarifai.a\
    pi.ModelH\0R\x05model\x124\n\x08workflow\x18\x03\x20\x01(\x0b2\x16.clari\
    fai.api.WorkflowH\0R\x08workflowB\x08\n\x06worker\"\xe3\x06\n\x03App\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01\
    (\tR\x04name\x12)\n\x10default_language\x18\x03\x20\x01(\tR\x0fdefaultLa\
    nguage\x12.\n\x13default_workflow_id\x18\x04\x20\x01(\tR\x11defaultWorkf\
    lowId\x12A\n\x10default_workflow\x18\x17\x20\x01(\x0b2\x16.clarifai.api.\
    WorkflowR\x0fdefaultWorkflow\x12\x17\n\x07user_id\x18\x05\x20\x01(\tR\
    \x06userId\x129\n\ncreated_at\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.\
    TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x11\x20\x01(\x0b2\x1a.go\
    ogle.protobuf.TimestampR\nmodifiedAt\x120\n\x14legal_consent_status\x18\
    \x07\x20\x01(\rR\x12legalConsentStatus\x123\n\x08metadata\x18\r\x20\x01(\
    \x0b2\x17.google.protobuf.StructR\x08metadata\x12\x20\n\x0bdescription\
    \x18\x0e\x20\x01(\tR\x0bdescription\x12\x1b\n\tsample_ms\x18\x0f\x20\x01\
    (\rR\x08sampleMs\x128\n\nvisibility\x18\x10\x20\x01(\x0b2\x18.clarifai.a\
    pi.VisibilityR\nvisibility\x12\x20\n\x0cdata_tier_id\x18\x12\x20\x01(\tR\
    \ndataTierId\x12\x1d\n\nis_starred\x18\x13\x20\x01(\x08R\tisStarred\x12\
    \x1d\n\nstar_count\x18\x14\x20\x01(\x05R\tstarCount\x12\x14\n\x05notes\
    \x18\x15\x20\x01(\tR\x05notes\x12)\n\x05image\x18\x16\x20\x01(\x0b2\x13.\
    clarifai.api.ImageR\x05image\x12;\n\x0bis_template\x18\x19\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\nisTemplate\x129\n\nextra_info\x18\x18\
    \x20\x01(\x0b2\x1a.clarifai.api.AppExtraInfoR\textraInfoJ\x04\x08\n\x10\
    \x0bJ\x04\x08\x0b\x10\x0cJ\x04\x08\x0c\x10\r\"}\n\x0cAppExtraInfo\x124\n\
    \x16search_revision_marker\x18\x01\x20\x01(\tR\x14searchRevisionMarker\
    \x127\n\x06counts\x18\x02\x20\x01(\x0b2\x1f.clarifai.api.AppResourceCoun\
    tsR\x06counts\"\x1e\n\x08AppQuery\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\"\x97\x01\n\x11AppResourceCounts\x12\x1a\n\x08datasets\x18\x01\
    \x20\x01(\x03R\x08datasets\x12\x16\n\x06models\x18\x02\x20\x01(\x03R\x06\
    models\x12\x1c\n\tworkflows\x18\x03\x20\x01(\x03R\tworkflows\x12\x18\n\
    \x07modules\x18\x04\x20\x01(\x03R\x07modules\x12\x16\n\x06inputs\x18\x05\
    \x20\x01(\x03R\x06inputs\"\xd4\x02\n\x0cCollaborator\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12#\n\x03app\x18\x02\x20\x01(\x0b2\x11.clarifai.\
    api.AppR\x03app\x12&\n\x04user\x18\x03\x20\x01(\x0b2\x12.clarifai.api.Us\
    erR\x04user\x12\x16\n\x06scopes\x18\x04\x20\x03(\tR\x06scopes\x12\x1c\n\
    \tendpoints\x18\x05\x20\x03(\tR\tendpoints\x129\n\ncreated_at\x18\x06\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodif\
    ied_at\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\
    \x129\n\ndeleted_at\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \tdeletedAt\"\xd6\x01\n\rCollaboration\x12#\n\x03app\x18\x01\x20\x01(\
    \x0b2\x11.clarifai.api.AppR\x03app\x12/\n\tapp_owner\x18\x02\x20\x01(\
    \x0b2\x12.clarifai.api.UserR\x08appOwner\x12\x16\n\x06scopes\x18\x03\x20\
    \x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\x04\x20\x03(\tR\tendpoints\
    \x129\n\ncreated_at\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \tcreatedAt\"\xca\x01\n\x05Audio\x12\x10\n\x03url\x18\x01\x20\x01(\tR\
    \x03url\x12\x16\n\x06base64\x18\x02\x20\x01(\x0cR\x06base64\x12.\n\x13al\
    low_duplicate_url\x18\x04\x20\x01(\x08R\x11allowDuplicateUrl\x12/\n\x06h\
    osted\x18\x05\x20\x01(\x0b2\x17.clarifai.api.HostedURLR\x06hosted\x126\n\
    \naudio_info\x18\x06\x20\x01(\x0b2\x17.clarifai.api.AudioInfoR\taudioInf\
    o\"\x95\x01\n\tAudioInfo\x12!\n\x0caudio_format\x18\x01\x20\x01(\tR\x0ba\
    udioFormat\x12\x1f\n\x0bsample_rate\x18\x02\x20\x01(\x05R\nsampleRate\
    \x12)\n\x10duration_seconds\x18\x03\x20\x01(\x02R\x0fdurationSeconds\x12\
    \x19\n\x08bit_rate\x18\x04\x20\x01(\x05R\x07bitRate\"\x94\x01\n\x05Track\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12&\n\x04data\x18\x02\x20\
    \x01(\x0b2\x12.clarifai.api.DataR\x04data\x123\n\ttime_info\x18\x04\x20\
    \x01(\x0b2\x16.clarifai.api.TimeInfoR\x08timeInfo\x12\x18\n\x07quality\
    \x18\x05\x20\x01(\x02R\x07qualityJ\x04\x08\x03\x10\x04\"\x8c\x01\n\x07Cl\
    uster\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05count\x18\
    \x02\x20\x01(\rR\x05count\x12\x14\n\x05score\x18\x03\x20\x01(\x02R\x05sc\
    ore\x12%\n\x04hits\x18\x04\x20\x03(\x0b2\x11.clarifai.api.HitR\x04hits\
    \x12\x1e\n\nprojection\x18\x05\x20\x03(\x02R\nprojection\"a\n\x05Color\
    \x12\x17\n\x07raw_hex\x18\x01\x20\x01(\tR\x06rawHex\x12#\n\x03w3c\x18\
    \x02\x20\x01(\x0b2\x11.clarifai.api.W3CR\x03w3c\x12\x1a\n\x05value\x18\
    \x03\x20\x01(\x02R\x05valueB\x04\x80\xb5\x18\x01\"+\n\x03W3C\x12\x10\n\
    \x03hex\x18\x01\x20\x01(\tR\x03hex\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\">\n\x0cUserAppIDSet\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\
    \x06userId\x12\x15\n\x06app_id\x18\x02\x20\x01(\tR\x05appId\"m\n\x0bPatc\
    hAction\x12\x0e\n\x02op\x18\x01\x20\x01(\tR\x02op\x12:\n\x19merge_confli\
    ct_resolution\x18\x02\x20\x01(\tR\x17mergeConflictResolution\x12\x12\n\
    \x04path\x18\x03\x20\x01(\tR\x04path\"\xcc\x03\n\x07Concept\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12!\n\x05value\x18\x03\x20\x01(\x02R\x05valueB\x0b\x80\xb5\x18\
    \x01\xd5\xb5\x18\0\0\x80?\x129\n\ncreated_at\x18\x04\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.TimestampR\tcreatedAt\x12\x1a\n\x08language\x18\x05\x20\
    \x01(\tR\x08language\x12\x15\n\x06app_id\x18\x06\x20\x01(\tR\x05appId\
    \x12\x1e\n\ndefinition\x18\x07\x20\x01(\tR\ndefinition\x12\x19\n\x08voca\
    b_id\x18\x08\x20\x01(\tR\x07vocabId\x128\n\nvisibility\x18\t\x20\x01(\
    \x0b2\x18.clarifai.api.VisibilityR\nvisibility\x12\x17\n\x07user_id\x18\
    \n\x20\x01(\tR\x06userId\x12?\n\rkeypoint_info\x18\x0b\x20\x01(\x0b2\x1a\
    .clarifai.api.KeypointInfoR\x0ckeypointInfo\x12=\n\nextra_info\x18\x0c\
    \x20\x01(\x0b2\x1e.clarifai.api.ConceptExtraInfoR\textraInfo\"m\n\x0cKey\
    pointInfo\x12%\n\x0ekeypoint_names\x18\x01\x20\x03(\tR\rkeypointNames\
    \x126\n\x08skeleton\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.KeypointEdgeR\
    \x08skeleton\".\n\x0cKeypointEdge\x12\x0e\n\x02k1\x18\x01\x20\x01(\rR\
    \x02k1\x12\x0e\n\x02k2\x18\x02\x20\x01(\rR\x02k2\"3\n\x10ConceptExtraInf\
    o\x12\x1f\n\x0bis_rankable\x18\x01\x20\x01(\x08R\nisRankable\"\xd4\x01\n\
    \x0cConceptCount\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04\
    name\x18\x02\x20\x01(\tR\x04name\x12L\n\x12concept_type_count\x18\x03\
    \x20\x01(\x0b2\x1e.clarifai.api.ConceptTypeCountR\x10conceptTypeCount\
    \x12R\n\x14detail_concept_count\x18\x04\x20\x01(\x0b2\x20.clarifai.api.D\
    etailConceptCountR\x12detailConceptCount\"V\n\x10ConceptTypeCount\x12\
    \x20\n\x08positive\x18\x01\x20\x01(\rR\x08positiveB\x04\x80\xb5\x18\x01\
    \x12\x20\n\x08negative\x18\x02\x20\x01(\rR\x08negativeB\x04\x80\xb5\x18\
    \x01\"\x89\x02\n\x12DetailConceptCount\x12<\n\tprocessed\x18\x01\x20\x01\
    (\x0b2\x1e.clarifai.api.ConceptTypeCountR\tprocessed\x12=\n\nto_process\
    \x18\x02\x20\x01(\x0b2\x1e.clarifai.api.ConceptTypeCountR\ttoProcess\x12\
    6\n\x06errors\x18\x03\x20\x01(\x0b2\x1e.clarifai.api.ConceptTypeCountR\
    \x06errors\x12>\n\nprocessing\x18\x04\x20\x01(\x0b2\x1e.clarifai.api.Con\
    ceptTypeCountR\nprocessing\"\xa0\x01\n\x0cConceptQuery\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08language\x18\x02\x20\x01(\tR\
    \x08language\x12\x1f\n\x0bworkflow_id\x18\x03\x20\x01(\tR\nworkflowId\
    \x12?\n\tuse_cases\x18\x04\x20\x03(\x0e2\".clarifai.api.WorkflowModelUse\
    CaseR\x08useCases\"\xa5\x02\n\x0fConceptRelation\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12>\n\x0fsubject_concept\x18\x02\x20\x01(\x0b2\x15.c\
    larifai.api.ConceptR\x0esubjectConcept\x12<\n\x0eobject_concept\x18\x03\
    \x20\x01(\x0b2\x15.clarifai.api.ConceptR\robjectConcept\x12\x1c\n\tpredi\
    cate\x18\x04\x20\x01(\tR\tpredicate\x12,\n\x12knowledge_graph_id\x18\x05\
    \x20\x01(\tR\x10knowledgeGraphId\x128\n\nvisibility\x18\x06\x20\x01(\x0b\
    2\x18.clarifai.api.VisibilityR\nvisibility\"\xb5\x01\n\x0eKnowledgeGraph\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescrip\
    tion\x12&\n\x0fexamples_app_id\x18\x04\x20\x01(\tR\rexamplesAppId\x125\n\
    \x17sampled_examples_app_id\x18\x05\x20\x01(\tR\x14sampledExamplesAppId\
    \"b\n\x11ConceptMappingJob\x12,\n\x12knowledge_graph_id\x18\x01\x20\x01(\
    \tR\x10knowledgeGraphId\x12\x1f\n\x0bconcept_ids\x18\x02\x20\x03(\tR\nco\
    nceptIds\"U\n\x0fConceptLanguage\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02\
    id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1e\n\ndefinition\
    \x18\x03\x20\x01(\tR\ndefinition\"\x83\x06\n\x04Data\x12)\n\x05image\x18\
    \x01\x20\x01(\x0b2\x13.clarifai.api.ImageR\x05image\x12)\n\x05video\x18\
    \x02\x20\x01(\x0b2\x13.clarifai.api.VideoR\x05video\x121\n\x08concepts\
    \x18\x03\x20\x03(\x0b2\x15.clarifai.api.ConceptR\x08concepts\x123\n\x08m\
    etadata\x18\x05\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\
    \x12#\n\x03geo\x18\x06\x20\x01(\x0b2\x11.clarifai.api.GeoR\x03geo\x12+\n\
    \x06colors\x18\x07\x20\x03(\x0b2\x13.clarifai.api.ColorR\x06colors\x121\
    \n\x08clusters\x18\x08\x20\x03(\x0b2\x15.clarifai.api.ClusterR\x08cluste\
    rs\x127\n\nembeddings\x18\t\x20\x03(\x0b2\x17.clarifai.api.EmbeddingR\ne\
    mbeddings\x12.\n\x07regions\x18\x0b\x20\x03(\x0b2\x14.clarifai.api.Regio\
    nR\x07regions\x12+\n\x06frames\x18\x0c\x20\x03(\x0b2\x13.clarifai.api.Fr\
    ameR\x06frames\x12&\n\x04text\x18\r\x20\x01(\x0b2\x12.clarifai.api.TextR\
    \x04text\x12)\n\x05audio\x18\x0e\x20\x01(\x0b2\x13.clarifai.api.AudioR\
    \x05audio\x12+\n\x06tracks\x18\x0f\x20\x03(\x0b2\x13.clarifai.api.TrackR\
    \x06tracks\x12>\n\rtime_segments\x18\x10\x20\x03(\x0b2\x19.clarifai.api.\
    TimeSegmentR\x0ctimeSegments\x12%\n\x04hits\x18\x11\x20\x03(\x0b2\x11.cl\
    arifai.api.HitR\x04hits\x12/\n\x08heatmaps\x18\x12\x20\x03(\x0b2\x13.cla\
    rifai.api.ImageR\x08heatmapsJ\x04\x08\x04\x10\x05J\x04\x08\n\x10\x0b\"\
    \xac\x01\n\x06Region\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x129\n\
    \x0bregion_info\x18\x02\x20\x01(\x0b2\x18.clarifai.api.RegionInfoR\nregi\
    onInfo\x12&\n\x04data\x18\x03\x20\x01(\x0b2\x12.clarifai.api.DataR\x04da\
    ta\x12\x14\n\x05value\x18\x04\x20\x01(\x02R\x05value\x12\x19\n\x08track_\
    id\x18\x05\x20\x01(\tR\x07trackId\"\xf1\x02\n\nRegionInfo\x12<\n\x0cboun\
    ding_box\x18\x01\x20\x01(\x0b2\x19.clarifai.api.BoundingBoxR\x0bbounding\
    Box\x12&\n\x04mask\x18\x04\x20\x01(\x0b2\x12.clarifai.api.MaskR\x04mask\
    \x12/\n\x07polygon\x18\x05\x20\x01(\x0b2\x15.clarifai.api.PolygonR\x07po\
    lygon\x12)\n\x05point\x18\x06\x20\x01(\x0b2\x13.clarifai.api.PointR\x05p\
    oint\x12&\n\x04span\x18\x07\x20\x01(\x0b2\x12.clarifai.api.SpanR\x04span\
    \x12)\n\x05token\x18\x08\x20\x01(\x0b2\x13.clarifai.api.TokenR\x05token\
    \x12B\n\x12keypoint_locations\x18\t\x20\x03(\x0b2\x13.clarifai.api.Point\
    R\x11keypointLocationsJ\x04\x08\x02\x10\x03J\x04\x08\x03\x10\x04\"\x95\
    \x01\n\x0bBoundingBox\x12\x1d\n\x07top_row\x18\x01\x20\x01(\x02R\x06topR\
    owB\x04\x80\xb5\x18\x01\x12\x1f\n\x08left_col\x18\x02\x20\x01(\x02R\x07l\
    eftColB\x04\x80\xb5\x18\x01\x12#\n\nbottom_row\x18\x03\x20\x01(\x02R\tbo\
    ttomRowB\x04\x80\xb5\x18\x01\x12!\n\tright_col\x18\x04\x20\x01(\x02R\x08\
    rightColB\x04\x80\xb5\x18\x01\"C\n\tFrameInfo\x12\x1c\n\x05index\x18\x01\
    \x20\x01(\rR\x05indexB\x06\x18\x01\x80\xb5\x18\x01\x12\x18\n\x04time\x18\
    \x02\x20\x01(\rR\x04timeB\x04\x80\xb5\x18\x01\"w\n\x05Frame\x126\n\nfram\
    e_info\x18\x01\x20\x01(\x0b2\x17.clarifai.api.FrameInfoR\tframeInfo\x12&\
    \n\x04data\x18\x02\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\x12\x0e\
    \n\x02id\x18\x03\x20\x01(\tR\x02id\"7\n\x04Mask\x12)\n\x05image\x18\x02\
    \x20\x01(\x0b2\x13.clarifai.api.ImageR\x05imageJ\x04\x08\x01\x10\x02\"6\
    \n\x07Polygon\x12+\n\x06points\x18\x01\x20\x03(\x0b2\x13.clarifai.api.Po\
    intR\x06points\"\xcf\x01\n\x05Point\x12\x16\n\x03row\x18\x01\x20\x01(\
    \x02R\x03rowB\x04\x80\xb5\x18\x01\x12\x16\n\x03col\x18\x02\x20\x01(\x02R\
    \x03colB\x04\x80\xb5\x18\x01\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\x01z\
    \x12>\n\nvisibility\x18\x04\x20\x01(\x0e2\x1e.clarifai.api.Point.Visibil\
    ityR\nvisibility\"H\n\nVisibility\x12\x0b\n\x07NOT_SET\x10\0\x12\x0b\n\
    \x07VISIBLE\x10\x01\x12\x0f\n\x0bNOT_VISIBLE\x10\x02\x12\x0f\n\x0bNOT_PR\
    ESENT\x10\x03\"g\n\x04Span\x12#\n\nchar_start\x18\x01\x20\x01(\rR\tcharS\
    tartB\x04\x80\xb5\x18\x01\x12\x1f\n\x08char_end\x18\x02\x20\x01(\rR\x07c\
    harEndB\x04\x80\xb5\x18\x01\x12\x19\n\x08raw_text\x18\x03\x20\x01(\tR\
    \x07rawText\"h\n\x05Token\x12#\n\nchar_start\x18\x01\x20\x01(\rR\tcharSt\
    artB\x04\x80\xb5\x18\x01\x12\x1f\n\x08char_end\x18\x02\x20\x01(\rR\x07ch\
    arEndB\x04\x80\xb5\x18\x01\x12\x19\n\x08raw_text\x18\x03\x20\x01(\tR\x07\
    rawText\"N\n\tEmbedding\x12\x1a\n\x06vector\x18\x01\x20\x03(\x02R\x06vec\
    torB\x02\x10\x01\x12%\n\x0enum_dimensions\x18\x02\x20\x01(\rR\rnumDimens\
    ions\"P\n\x08GeoPoint\x12\"\n\tlongitude\x18\x01\x20\x01(\x02R\tlongitud\
    eB\x04\x80\xb5\x18\x01\x12\x20\n\x08latitude\x18\x02\x20\x01(\x02R\x08la\
    titudeB\x04\x80\xb5\x18\x01\":\n\x08GeoLimit\x12\x12\n\x04type\x18\x01\
    \x20\x01(\tR\x04type\x12\x1a\n\x05value\x18\x02\x20\x01(\x02R\x05valueB\
    \x04\x80\xb5\x18\x01\"D\n\rGeoBoxedPoint\x123\n\tgeo_point\x18\x01\x20\
    \x01(\x0b2\x16.clarifai.api.GeoPointR\x08geoPoint\"\xa5\x01\n\x03Geo\x12\
    3\n\tgeo_point\x18\x01\x20\x01(\x0b2\x16.clarifai.api.GeoPointR\x08geoPo\
    int\x123\n\tgeo_limit\x18\x02\x20\x01(\x0b2\x16.clarifai.api.GeoLimitR\
    \x08geoLimit\x124\n\x07geo_box\x18\x03\x20\x03(\x0b2\x1b.clarifai.api.Ge\
    oBoxedPointR\x06geoBox\"\xd0\x01\n\x05Image\x12\x10\n\x03url\x18\x01\x20\
    \x01(\tR\x03url\x12\x16\n\x06base64\x18\x02\x20\x01(\x0cR\x06base64\x12.\
    \n\x13allow_duplicate_url\x18\x04\x20\x01(\x08R\x11allowDuplicateUrl\x12\
    /\n\x06hosted\x18\x05\x20\x01(\x0b2\x17.clarifai.api.HostedURLR\x06hoste\
    d\x126\n\nimage_info\x18\x06\x20\x01(\x0b2\x17.clarifai.api.ImageInfoR\t\
    imageInfoJ\x04\x08\x03\x10\x04\"p\n\tImageInfo\x12\x14\n\x05width\x18\
    \x01\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\
    \x06height\x12\x16\n\x06format\x18\x03\x20\x01(\tR\x06format\x12\x1d\n\n\
    color_mode\x18\x04\x20\x01(\tR\tcolorMode\"s\n\tHostedURL\x12\x16\n\x06p\
    refix\x18\x01\x20\x01(\tR\x06prefix\x12\x16\n\x06suffix\x18\x02\x20\x01(\
    \tR\x06suffix\x12\x14\n\x05sizes\x18\x03\x20\x03(\tR\x05sizes\x12\x20\n\
    \x0bcrossorigin\x18\x04\x20\x01(\tR\x0bcrossorigin\"\x93\x02\n\x05Input\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12&\n\x04data\x18\x02\x20\
    \x01(\x0b2\x12.clarifai.api.DataR\x04data\x129\n\ncreated_at\x18\x04\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_\
    at\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x123\
    \n\x06status\x18\x06\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x12\x1f\n\x0bdataset_ids\x18\x07\x20\x03(\tR\ndatasetIdsJ\x04\x08\
    \x03\x10\x04\"9\n\nInputBatch\x12+\n\x06inputs\x18\x01\x20\x03(\x0b2\x13\
    .clarifai.api.InputR\x06inputs\"\xb5\x02\n\nInputCount\x12\"\n\tprocesse\
    d\x18\x01\x20\x01(\rR\tprocessedB\x04\x80\xb5\x18\x01\x12#\n\nto_process\
    \x18\x02\x20\x01(\rR\ttoProcessB\x04\x80\xb5\x18\x01\x12\x1c\n\x06errors\
    \x18\x03\x20\x01(\rR\x06errorsB\x04\x80\xb5\x18\x01\x12$\n\nprocessing\
    \x18\x04\x20\x01(\rR\nprocessingB\x04\x80\xb5\x18\x01\x12\"\n\treindexed\
    \x18\x05\x20\x01(\rR\treindexedB\x04\x80\xb5\x18\x01\x12#\n\nto_reindex\
    \x18\x06\x20\x01(\rR\ttoReindexB\x04\x80\xb5\x18\x01\x12+\n\x0ereindex_e\
    rrors\x18\x07\x20\x01(\rR\rreindexErrorsB\x04\x80\xb5\x18\x01\x12$\n\nre\
    indexing\x18\x08\x20\x01(\rR\nreindexingB\x04\x80\xb5\x18\x01\"\x9c\x06\
    \n\x07Dataset\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x129\n\ncreated_\
    at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\
    \n\x0bmodified_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\n\
    modifiedAt\x12\x15\n\x06app_id\x18\x04\x20\x01(\tR\x05appId\x12\x17\n\
    \x07user_id\x18\x05\x20\x01(\tR\x06userId\x12\x20\n\x0bdescription\x18\
    \x07\x20\x01(\tR\x0bdescription\x123\n\x08metadata\x18\x08\x20\x01(\x0b2\
    \x17.google.protobuf.StructR\x08metadata\x128\n\nvisibility\x18\t\x20\
    \x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibility\x12Z\n\x19default_an\
    notation_filter\x18\x0c\x20\x01(\x0b2\x1e.clarifai.api.AnnotationFilterR\
    \x17defaultAnnotationFilter\x12b\n\x17default_processing_info\x18\x10\
    \x20\x01(\x0b2*.clarifai.api.DatasetVersionProcessingInfoR\x15defaultPro\
    cessingInfo\x12\x14\n\x05notes\x18\x0b\x20\x01(\tR\x05notes\x126\n\x07ve\
    rsion\x18\r\x20\x01(\x0b2\x1c.clarifai.api.DatasetVersionR\x07version\
    \x12\x1d\n\nis_starred\x18\x0e\x20\x01(\x08R\tisStarred\x12\x1d\n\nstar_\
    count\x18\x0f\x20\x01(\x05R\tstarCount\x12E\n\x0fbookmark_origin\x18\x11\
    \x20\x01(\x0b2\x1c.clarifai.api.BookmarkOriginR\x0ebookmarkOrigin\x12)\n\
    \x05image\x18\x12\x20\x01(\x0b2\x13.clarifai.api.ImageR\x05imageJ\x04\
    \x08\x06\x10\x07J\x04\x08\n\x10\x0b\"\x8a\x02\n\x10AnnotationFilter\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x129\n\ncreated_at\x18\x02\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_\
    at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x12\
    \x17\n\x07user_id\x18\x04\x20\x01(\tR\x06userId\x12\x15\n\x06app_id\x18\
    \x05\x20\x01(\tR\x05appId\x12,\n\x06search\x18\t\x20\x01(\x0b2\x14.clari\
    fai.api.SearchR\x06searchJ\x04\x08\x06\x10\x07J\x04\x08\x07\x10\x08J\x04\
    \x08\x08\x10\t\"t\n\x0cDatasetInput\x129\n\ncreated_at\x18\x01\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12)\n\x05input\x18\x02\
    \x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\"\xd3\x08\n\x0eDatasetVe\
    rsion\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x129\n\ncreated_at\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bm\
    odified_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifie\
    dAt\x12\x15\n\x06app_id\x18\x04\x20\x01(\tR\x05appId\x12\x17\n\x07user_i\
    d\x18\x05\x20\x01(\tR\x06userId\x12\x1d\n\ndataset_id\x18\x06\x20\x01(\t\
    R\tdatasetId\x12`\n\x18annotation_filter_config\x18\x0f\x20\x01(\x0b2$.c\
    larifai.api.AnnotationFilterConfigH\0R\x16annotationFilterConfig\x12T\n\
    \x14model_predict_config\x18\x12\x20\x01(\x0b2\x20.clarifai.api.ModelPre\
    dictConfigH\0R\x12modelPredictConfig\x123\n\x06status\x18\x08\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x20\n\x0bdescription\
    \x18\n\x20\x01(\tR\x0bdescription\x12S\n\x0fprocessing_info\x18\x13\x20\
    \x01(\x0b2*.clarifai.api.DatasetVersionProcessingInfoR\x0eprocessingInfo\
    \x12C\n\x07metrics\x18\x10\x20\x03(\x0b2).clarifai.api.DatasetVersion.Me\
    tricsEntryR\x07metrics\x12G\n\x0bexport_info\x18\x11\x20\x01(\x0b2&.clar\
    ifai.api.DatasetVersionExportInfoR\nexportInfo\x123\n\x08metadata\x18\
    \x0c\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\x128\n\nvisib\
    ility\x18\r\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibility\x125\
    \n\x17embed_model_version_ids\x18\x0e\x20\x03(\tR\x14embedModelVersionId\
    s\x12P\n\x0erequest_origin\x18\x14\x20\x01(\x0e2).clarifai.api.DatasetVe\
    rsionRequestOriginR\rrequestOrigin\x1a_\n\x0cMetricsEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x129\n\x05value\x18\x02\x20\x01(\x0b2#.cla\
    rifai.api.DatasetVersionMetricsR\x05value:\x028\x01B\r\n\x0bdata_configJ\
    \x04\x08\x07\x10\x08J\x04\x08\t\x10\nJ\x04\x08\x0b\x10\x0c\"\x95\x01\n\
    \x16AnnotationFilterConfig\x12K\n\x11annotation_filter\x18\x01\x20\x01(\
    \x0b2\x1e.clarifai.api.AnnotationFilterR\x10annotationFilter\x12.\n\x13i\
    gnore_empty_inputs\x18\x02\x20\x01(\x08R\x11ignoreEmptyInputs\"?\n\x12Mo\
    delPredictConfig\x12)\n\x05model\x18\x01\x20\x01(\x0b2\x13.clarifai.api.\
    ModelR\x05model\"\x92\x0b\n\x15DatasetVersionMetrics\x12?\n\x0cinputs_co\
    unt\x18\x01\x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\x0binputsCoun\
    t\x12R\n\x16unlabeled_inputs_count\x18\x06\x20\x01(\x0b2\x1c.google.prot\
    obuf.UInt64ValueR\x14unlabeledInputsCount\x12Y\n\x1ainputs_with_metadata\
    _count\x18\x08\x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\x17inputsW\
    ithMetadataCount\x12O\n\x15inputs_with_geo_count\x18\t\x20\x01(\x0b2\x1c\
    .google.protobuf.UInt64ValueR\x12inputsWithGeoCount\x12A\n\rregions_coun\
    t\x18\x14\x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\x0cregionsCount\
    \x12C\n\x16region_location_matrix\x18\x15\x20\x01(\x0b2\r.MatrixUint64R\
    \x14regionLocationMatrix\x12N\n\x14bounding_boxes_count\x18\x16\x20\x01(\
    \x0b2\x1c.google.protobuf.UInt64ValueR\x12boundingBoxesCount\x12C\n\x0ep\
    olygons_count\x18\x17\x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\rpo\
    lygonsCount\x12?\n\x0cpoints_count\x18\x18\x20\x01(\x0b2\x1c.google.prot\
    obuf.UInt64ValueR\x0bpointsCount\x12=\n\x0bmasks_count\x18\x19\x20\x01(\
    \x0b2\x1c.google.protobuf.UInt64ValueR\nmasksCount\x12L\n\x13region_inpu\
    ts_count\x18<\x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\x11regionIn\
    putsCount\x12L\n\x13region_frames_count\x18=\x20\x01(\x0b2\x1c.google.pr\
    otobuf.UInt64ValueR\x11regionFramesCount\x12?\n\x0cframes_count\x18\x1e\
    \x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\x0bframesCount\x12J\n\
    \x12frame_inputs_count\x18F\x20\x01(\x0b2\x1c.google.protobuf.UInt64Valu\
    eR\x10frameInputsCount\x12G\n\x10embeddings_count\x18(\x20\x01(\x0b2\x1c\
    .google.protobuf.UInt64ValueR\x0fembeddingsCount\x12W\n\x19positive_inpu\
    t_tags_count\x182\x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\x16posi\
    tiveInputTagsCount\x12Y\n\x1apositive_region_tags_count\x183\x20\x01(\
    \x0b2\x1c.google.protobuf.UInt64ValueR\x17positiveRegionTagsCount\x12W\n\
    \x19positive_frame_tags_count\x184\x20\x01(\x0b2\x1c.google.protobuf.UIn\
    t64ValueR\x16positiveFrameTagsCountJ\x04\x08\x02\x10\x03J\x04\x08\x03\
    \x10\x04J\x04\x08\x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x07\x10\x08\
    \"\xec\x01\n\x1aDatasetVersionMetricsGroup\x12\x1f\n\x0bparent_path\x18\
    \x01\x20\x01(\tR\nparentPath\x12@\n\x04type\x18\x02\x20\x01(\x0e2,.clari\
    fai.api.DatasetVersionMetricsGroupTypeR\x04type\x12,\n\x05value\x18\x03\
    \x20\x01(\x0b2\x16.google.protobuf.ValueR\x05value\x12=\n\x07metrics\x18\
    \x04\x20\x01(\x0b2#.clarifai.api.DatasetVersionMetricsR\x07metrics\"\xfe\
    \x01\n\x18DatasetVersionExportInfo\x12X\n\x16clarifai_data_protobuf\x18\
    \x01\x20\x01(\x0b2\".clarifai.api.DatasetVersionExportR\x14clarifaiDataP\
    rotobuf\x12P\n\x12clarifai_data_json\x18\x03\x20\x01(\x0b2\".clarifai.ap\
    i.DatasetVersionExportR\x10clarifaiDataJson\x126\n\x04coco\x18\x02\x20\
    \x01(\x0b2\".clarifai.api.DatasetVersionExportR\x04coco\"\xe2\x01\n\x14D\
    atasetVersionExport\x12@\n\x06format\x18\x01\x20\x01(\x0e2(.clarifai.api\
    .DatasetVersionExportFormatR\x06format\x123\n\x06status\x18\x02\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x10\n\x03url\x18\x03\
    \x20\x01(\tR\x03url\x12\x12\n\x04size\x18\x04\x20\x01(\x04R\x04size\x12-\
    \n\x12include_embeddings\x18\x05\x20\x01(\x08R\x11includeEmbeddings\"~\n\
    \x1cDatasetVersionProcessingInfo\x12^\n\x18frame_interpolation_info\x18\
    \x01\x20\x01(\x0b2$.clarifai.api.FrameInterpolationInfoR\x16frameInterpo\
    lationInfo\"5\n\x16FrameInterpolationInfo\x12\x1b\n\tsample_ms\x18\x01\
    \x20\x01(\rR\x08sampleMs\"\x87\x01\n\x19WorkflowResultsSimilarity\x124\n\
    \x0bprobe_input\x18\x01\x20\x01(\x0b2\x13.clarifai.api.InputR\nprobeInpu\
    t\x124\n\x0cpool_results\x18\x02\x20\x03(\x0b2\x11.clarifai.api.HitR\x0b\
    poolResults\"\xcc\x02\n\x03Key\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x12\n\x04type\x18\x08\x20\x01(\tR\x04type\x12\x20\n\x0bdescription\
    \x18\x02\x20\x01(\tR\x0bdescription\x12\x16\n\x06scopes\x18\x03\x20\x03(\
    \tR\x06scopes\x12\x1c\n\tendpoints\x18\x07\x20\x03(\tR\tendpoints\x12%\n\
    \x04apps\x18\x04\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\x129\n\ncre\
    ated_at\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\
    \x129\n\nexpires_at\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \texpiresAt\x12,\n\x12authorized_idp_ids\x18\t\x20\x03(\tR\x10authorized\
    IdpIds\"\xdd\t\n\x05Model\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x16\n\x04name\x18\x02\x20\x01(\tR\x04nameB\x02\x18\x01\x129\n\ncreated_\
    at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\
    \n\x0bmodified_at\x18\x13\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\n\
    modifiedAt\x12\x1b\n\x06app_id\x18\x04\x20\x01(\tR\x05appIdB\x04\x80\xb5\
    \x18\x01\x12=\n\x0boutput_info\x18\x05\x20\x01(\x0b2\x18.clarifai.api.Ou\
    tputInfoR\noutputInfoB\x02\x18\x01\x12?\n\rmodel_version\x18\x06\x20\x01\
    (\x0b2\x1a.clarifai.api.ModelVersionR\x0cmodelVersion\x12%\n\x0cdisplay_\
    name\x18\x07\x20\x01(\tR\x0bdisplayNameB\x02\x18\x01\x12\x17\n\x07user_i\
    d\x18\t\x20\x01(\tR\x06userId\x12B\n\x11default_eval_info\x18\x1e\x20\
    \x01(\x0b2\x16.clarifai.api.EvalInfoR\x0fdefaultEvalInfo\x12\"\n\rmodel_\
    type_id\x18\x0e\x20\x01(\tR\x0bmodelTypeId\x12\x12\n\x04task\x18\x1a\x20\
    \x01(\tR\x04task\x128\n\nvisibility\x18\x0f\x20\x01(\x0b2\x18.clarifai.a\
    pi.VisibilityR\nvisibility\x12\x20\n\x0bdescription\x18\x10\x20\x01(\tR\
    \x0bdescription\x123\n\x08metadata\x18\x11\x20\x01(\x0b2\x17.google.prot\
    obuf.StructR\x08metadata\x121\n\x07presets\x18\x1b\x20\x01(\x0b2\x17.goo\
    gle.protobuf.StructR\x07presets\x12\x14\n\x05notes\x18\x12\x20\x01(\tR\
    \x05notes\x12\x20\n\x08toolkits\x18\x14\x20\x03(\tR\x08toolkitsB\x04\x80\
    \xb5\x18\x01\x12!\n\tuse_cases\x18\x15\x20\x03(\tR\x08useCasesB\x04\x80\
    \xb5\x18\x01\x12\"\n\tlanguages\x18\x19\x20\x03(\tR\tlanguagesB\x04\x80\
    \xb5\x18\x01\x12B\n\x0elanguages_full\x18\x1f\x20\x03(\x0b2\x15.clarifai\
    .api.FullTagR\rlanguagesFullB\x04\x80\xb5\x18\x01\x12+\n\x0echeck_consen\
    ts\x18\x20\x20\x03(\tR\rcheckConsentsB\x04\x80\xb5\x18\x01\x12\x1d\n\nis\
    _starred\x18\x16\x20\x01(\x08R\tisStarred\x12\x1d\n\nstar_count\x18\x17\
    \x20\x01(\x05R\tstarCount\x12M\n\x14workflow_recommended\x18\x1d\x20\x01\
    (\x0b2\x1a.google.protobuf.BoolValueR\x13workflowRecommended\x12E\n\x0fb\
    ookmark_origin\x18!\x20\x01(\x0b2\x1c.clarifai.api.BookmarkOriginR\x0ebo\
    okmarkOrigin\x12)\n\x05image\x18\"\x20\x01(\x0b2\x13.clarifai.api.ImageR\
    \x05imageJ\x04\x08\x08\x10\tJ\x04\x08\n\x10\x0bJ\x04\x08\x0b\x10\x0cJ\
    \x04\x08\x0c\x10\rJ\x04\x08\r\x10\x0eJ\x04\x08\x18\x10\x19J\x04\x08\x1c\
    \x10\x1d\"\x96\x01\n\x0eModelReference\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \tR\x02id\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x10\n\
    \x03url\x18\x03\x20\x01(\tR\x03url\x12\x12\n\x04name\x18\x04\x20\x01(\tR\
    \x04name\x123\n\x08metadata\x18\x05\x20\x01(\x0b2\x17.google.protobuf.St\
    ructR\x08metadata\"\xcd\x01\n\x18ModelVersionInputExample\x12\x0e\n\x02i\
    d\x18\x01\x20\x01(\tR\x02id\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\
    \x07modelId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersi\
    onId\x12&\n\x04data\x18\x04\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\
    \x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\
    \x18\x06\x20\x01(\tR\x0bdescription\"\xc5\x02\n\nOutputInfo\x12&\n\x04da\
    ta\x18\x01\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\x12?\n\routput_c\
    onfig\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.OutputConfigR\x0coutputConf\
    ig\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x126\n\nfields_ma\
    p\x18\x06\x20\x01(\x0b2\x17.google.protobuf.StructR\tfieldsMap\x12/\n\
    \x06params\x18\x07\x20\x01(\x0b2\x17.google.protobuf.StructR\x06params\
    \x12?\n\x0cparams_specs\x18\x08\x20\x03(\x0b2\x1c.clarifai.api.ModelType\
    FieldR\x0bparamsSpecsJ\x04\x08\x04\x10\x05J\x04\x08\x05\x10\x06\"\xb3\
    \x01\n\tInputInfo\x126\n\nfields_map\x18\x01\x20\x01(\x0b2\x17.google.pr\
    otobuf.StructR\tfieldsMap\x12/\n\x06params\x18\x02\x20\x01(\x0b2\x17.goo\
    gle.protobuf.StructR\x06params\x12=\n\x10base_embed_model\x18\x03\x20\
    \x01(\x0b2\x13.clarifai.api.ModelR\x0ebaseEmbedModel\"\xae\x01\n\tTrainI\
    nfo\x12/\n\x06params\x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\
    \x06params\x12/\n\x07dataset\x18\x02\x20\x01(\x0b2\x15.clarifai.api.Data\
    setR\x07dataset\x12?\n\x11resume_from_model\x18\x03\x20\x01(\x0b2\x13.cl\
    arifai.api.ModelR\x0fresumeFromModel\";\n\x08EvalInfo\x12/\n\x06params\
    \x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\x06params\"=\n\nImpor\
    tInfo\x12/\n\x06params\x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\
    \x06params\"\xbc\x05\n\x0cOutputConfig\x12B\n\x1bconcepts_mutually_exclu\
    sive\x18\x01\x20\x01(\x08R\x19conceptsMutuallyExclusiveB\x02\x18\x01\x12\
    .\n\x11existing_model_id\x18\x03\x20\x01(\tR\x0fexistingModelIdB\x02\x18\
    \x01\x12\x1a\n\x08language\x18\x04\x20\x01(\tR\x08language\x12-\n\x10hyp\
    er_parameters\x18\x05\x20\x01(\tR\x0fhyperParametersB\x02\x18\x01\x12'\n\
    \x0cmax_concepts\x18\x06\x20\x01(\rR\x0bmaxConceptsB\x04\x80\xb5\x18\x01\
    \x12!\n\tmin_value\x18\x07\x20\x01(\x02R\x08minValueB\x04\x80\xb5\x18\
    \x01\x12>\n\x0fselect_concepts\x18\x08\x20\x03(\x0b2\x15.clarifai.api.Co\
    nceptR\x0eselectConcepts\x12)\n\x10training_timeout\x18\t\x20\x01(\rR\
    \x0ftrainingTimeout\x12\x1b\n\tsample_ms\x18\n\x20\x01(\rR\x08sampleMs\
    \x12:\n\x0chyper_params\x18\r\x20\x01(\x0b2\x17.google.protobuf.StructR\
    \x0bhyperParams\x127\n\x16embed_model_version_id\x18\x0e\x20\x01(\tR\x13\
    embedModelVersionIdB\x02\x18\x01\x12H\n!fail_on_missing_positive_example\
    s\x18\x0f\x20\x01(\x08R\x1dfailOnMissingPositiveExamples\x12B\n\x0emodel\
    _metadata\x18\x11\x20\x01(\x0b2\x17.google.protobuf.StructR\rmodelMetada\
    taB\x02\x18\x01J\x04\x08\x0b\x10\x0cJ\x04\x08\x0c\x10\rJ\x04\x08\x10\x10\
    \x11J\x04\x08\x12\x10\x13\"\x8f\x05\n\tModelType\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\
    \x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12!\n\x0cinput\
    _fields\x18\x05\x20\x03(\tR\x0binputFields\x12#\n\routput_fields\x18\x06\
    \x20\x03(\tR\x0coutputFields\x12\x1c\n\ttrainable\x18\x08\x20\x01(\x08R\
    \ttrainable\x12\x1c\n\tcreatable\x18\t\x20\x01(\x08R\tcreatable\x12#\n\r\
    internal_only\x18\n\x20\x01(\x08R\x0cinternalOnly\x12H\n\x11model_type_f\
    ields\x18\x0b\x20\x03(\x0b2\x1c.clarifai.api.ModelTypeFieldR\x0fmodelTyp\
    eFields\x12<\n\x1arequires_sequential_frames\x18\x0c\x20\x01(\x08R\x18re\
    quiresSequentialFrames\x12P\n\x15expected_input_layers\x18\x10\x20\x03(\
    \x0b2\x1c.clarifai.api.ModelLayerInfoR\x13expectedInputLayers\x12R\n\x16\
    expected_output_layers\x18\x11\x20\x03(\x0b2\x1c.clarifai.api.ModelLayer\
    InfoR\x14expectedOutputLayers\x12E\n\x0fevaluation_type\x18\x12\x20\x01(\
    \x0e2\x1c.clarifai.api.EvaluationTypeR\x0eevaluationTypeJ\x04\x08\x07\
    \x10\x08J\x04\x08\x04\x10\x05J\x04\x08\r\x10\x0eJ\x04\x08\x0e\x10\x0fJ\
    \x04\x08\x0f\x10\x10\"\xc4\x01\n\x0eModelLayerInfo\x12&\n\x0fdata_field_\
    name\x18\x01\x20\x01(\tR\rdataFieldName\x120\n\x06shapes\x18\x02\x20\x03\
    (\x0b2\x18.clarifai.api.LayerShapeR\x06shapes\x12\x20\n\x0bdescription\
    \x18\x03\x20\x01(\tR\x0bdescription\x126\n\x17requires_label_filename\
    \x18\x04\x20\x01(\x08R\x15requiresLabelFilename\"`\n\x12TritonCondaEnvIn\
    fo\x12$\n\x0econda_pack_url\x18\x01\x20\x01(\tR\x0ccondaPackUrl\x12$\n\
    \x0econda_yaml_url\x18\x02\x20\x01(\tR\x0ccondaYamlUrl\"\x92\x01\n\nLaye\
    rShape\x12\x12\n\x04dims\x18\x01\x20\x03(\x05R\x04dims\x12\x19\n\x08max_\
    dims\x18\x02\x20\x03(\x05R\x07maxDims\x123\n\tdata_type\x18\x03\x20\x01(\
    \x0e2\x16.clarifai.api.DataTypeR\x08dataType\x12\x20\n\x0bdescription\
    \x18\x04\x20\x01(\tR\x0bdescription\"\xb8\x07\n\x0eModelTypeField\x12\
    \x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12N\n\nfield_type\x18\x02\
    \x20\x01(\x0e2/.clarifai.api.ModelTypeField.ModelTypeFieldTypeR\tfieldTy\
    pe\x12;\n\rdefault_value\x18\x03\x20\x01(\x0b2\x16.google.protobuf.Value\
    R\x0cdefaultValue\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\x0bdescri\
    ption\x12\x20\n\x0bplaceholder\x18\x05\x20\x01(\tR\x0bplaceholder\x12X\n\
    \x17model_type_enum_options\x18\x06\x20\x03(\x0b2!.clarifai.api.ModelTyp\
    eEnumOptionR\x14modelTypeEnumOptions\x12#\n\rinternal_only\x18\x07\x20\
    \x01(\x08R\x0cinternalOnly\x12\x1a\n\x08required\x18\x08\x20\x01(\x08R\
    \x08required\x12S\n\x15model_type_range_info\x18\t\x20\x01(\x0b2\x20.cla\
    rifai.api.ModelTypeRangeInfoR\x12modelTypeRangeInfo\"\xd0\x03\n\x12Model\
    TypeFieldType\x12!\n\x1dINVALID_MODEL_TYPE_FIELD_TYPE\x10\0\x12\x0b\n\
    \x07BOOLEAN\x10\x01\x12\n\n\x06STRING\x10\x02\x12\n\n\x06NUMBER\x10\x03\
    \x12\x15\n\x11ARRAY_OF_CONCEPTS\x10\x04\x12$\n\x20ARRAY_OF_CONCEPTS_WITH\
    _THRESHOLD\x10\x05\x12\t\n\x05RANGE\x10\x07\x12\x08\n\x04ENUM\x10\x08\
    \x12\x11\n\rCOLLABORATORS\x10\t\x12\x08\n\x04JSON\x10\n\x12\x14\n\x10ARR\
    AY_OF_NUMBERS\x10\x0b\x12\x19\n\x15WORKFLOW_EMBED_MODELS\x10\x0c\x12\x14\
    \n\x10ARRAY_OF_STRINGS\x10\r\x12\x12\n\x0eRECURSIVE_ENUM\x10\x0e\x12\x0f\
    \n\x0bPYTHON_CODE\x10\x0f\x12\x0e\n\nDATASET_ID\x10\x10\x12\x16\n\x12DAT\
    ASET_VERSION_ID\x10\x11\x12\x1b\n\x17ARRAY_OF_MODEL_CONCEPTS\x10\x12\x12\
    \x0b\n\x07DATASET\x10\x13\x12\x13\n\x0fDATASET_VERSION\x10\x14\x12\x14\n\
    \x10ENCRYPTED_STRING\x10\x15\x12\x14\n\x10CHECKPOINT_MODEL\x10\x16\"\x04\
    \x08\x06\x10\x06\"L\n\x12ModelTypeRangeInfo\x12\x10\n\x03min\x18\x01\x20\
    \x01(\x02R\x03min\x12\x10\n\x03max\x18\x02\x20\x01(\x02R\x03max\x12\x12\
    \n\x04step\x18\x03\x20\x01(\x02R\x04step\"\x9a\x02\n\x13ModelTypeEnumOpt\
    ion\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12@\n\x07aliases\x18\x05\
    \x20\x03(\x0b2&.clarifai.api.ModelTypeEnumOptionAliasR\x07aliases\x12\
    \x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12H\n\x11model\
    _type_fields\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.ModelTypeFieldR\x0fm\
    odelTypeFields\x12#\n\rinternal_only\x18\x04\x20\x01(\x08R\x0cinternalOn\
    ly\x12\x20\n\x0brecommended\x18\x06\x20\x01(\x08R\x0brecommended\"Z\n\
    \x18ModelTypeEnumOptionAlias\x12\x15\n\x06id_int\x18\x01\x20\x01(\x03R\
    \x05idInt\x12'\n\x0fwildcard_string\x18\x02\x20\x01(\tR\x0ewildcardStrin\
    g\"J\n\nModelQuery\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\"\n\
    \rmodel_type_id\x18\x03\x20\x01(\tR\x0bmodelTypeIdJ\x04\x08\x02\x10\x03\
    \"\xed\x08\n\x0cModelVersion\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x129\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \tcreatedAt\x123\n\x06status\x18\x03\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\x120\n\x14active_concept_count\x18\x04\x20\x01(\rR\
    \x12activeConceptCount\x123\n\x07metrics\x18\x05\x20\x01(\x0b2\x19.clari\
    fai.api.EvalMetricsR\x07metrics\x12*\n\x11total_input_count\x18\x06\x20\
    \x01(\rR\x0ftotalInputCount\x12[\n\x17pretrained_model_config\x18\x07\
    \x20\x01(\x0b2#.clarifai.api.PretrainedModelConfigR\x15pretrainedModelCo\
    nfig\x12=\n\x0ccompleted_at\x18\n\x20\x01(\x0b2\x1a.google.protobuf.Time\
    stampR\x0bcompletedAt\x12\x20\n\x0bdescription\x18\x0b\x20\x01(\tR\x0bde\
    scription\x128\n\nvisibility\x18\x0c\x20\x01(\x0b2\x18.clarifai.api.Visi\
    bilityR\nvisibility\x12\x15\n\x06app_id\x18\r\x20\x01(\tR\x05appId\x12\
    \x17\n\x07user_id\x18\x0e\x20\x01(\tR\x06userId\x12;\n\x0bmodified_at\
    \x18\x0f\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x123\n\
    \x08metadata\x18\x10\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metada\
    ta\x12\x18\n\x07license\x18\x11\x20\x01(\tR\x07license\x129\n\x0boutput_\
    info\x18\x13\x20\x01(\x0b2\x18.clarifai.api.OutputInfoR\noutputInfo\x126\
    \n\ninput_info\x18\x14\x20\x01(\x0b2\x17.clarifai.api.InputInfoR\tinputI\
    nfo\x126\n\ntrain_info\x18\x15\x20\x01(\x0b2\x17.clarifai.api.TrainInfoR\
    \ttrainInfo\x129\n\x0bimport_info\x18\x16\x20\x01(\x0b2\x18.clarifai.api\
    .ImportInfoR\nimportInfo\x12\x1b\n\ttrain_log\x18\x17\x20\x01(\tR\x08tra\
    inLog\x12O\n\x16inference_compute_info\x18\x18\x20\x01(\x0b2\x19.clarifa\
    i.api.ComputeInfoR\x14inferenceComputeInfo\x126\n\nbuild_info\x18\x19\
    \x20\x01(\x0b2\x17.clarifai.api.BuildInfoR\tbuildInfoJ\x04\x08\t\x10\nJ\
    \x04\x08\x12\x10\x13\"\x91\x01\n\tBuildInfo\x12*\n\x11docker_image_name\
    \x18\x01\x20\x01(\tR\x0fdockerImageName\x12(\n\x10docker_image_tag\x18\
    \x02\x20\x01(\tR\x0edockerImageTag\x12.\n\x13docker_image_digest\x18\x03\
    \x20\x01(\tR\x11dockerImageDigest\"o\n\x12ModelVersionExport\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x12\n\x04size\x18\x03\
    \x20\x01(\x03R\x04size\"\xcf\x01\n\x15PretrainedModelConfig\x12A\n\x10in\
    put_fields_map\x18\x03\x20\x01(\x0b2\x17.google.protobuf.StructR\x0einpu\
    tFieldsMap\x12C\n\x11output_fields_map\x18\x04\x20\x01(\x0b2\x17.google.\
    protobuf.StructR\x0foutputFieldsMap\x12\"\n\rmodel_zip_url\x18\x06\x20\
    \x01(\tR\x0bmodelZipUrlJ\x04\x08\x02\x10\x03J\x04\x08\x05\x10\x06\"I\n\n\
    TrainStats\x12;\n\nloss_curve\x18\x01\x20\x03(\x0b2\x1c.clarifai.api.Los\
    sCurveEntryR\tlossCurve\"[\n\x0eLossCurveEntry\x12\x14\n\x05epoch\x18\
    \x01\x20\x01(\rR\x05epoch\x12\x1f\n\x0bglobal_step\x18\x02\x20\x01(\rR\n\
    globalStep\x12\x12\n\x04cost\x18\x03\x20\x01(\x02R\x04cost\"z\n\nLabelCo\
    unt\x12%\n\x0cconcept_name\x18\x01\x20\x01(\tR\x0bconceptNameB\x02\x18\
    \x01\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05count\x12/\n\x07concept\
    \x18\x03\x20\x01(\x0b2\x15.clarifai.api.ConceptR\x07concept\"a\n\x11Labe\
    lDistribution\x12L\n\x15positive_label_counts\x18\x01\x20\x03(\x0b2\x18.\
    clarifai.api.LabelCountR\x13positiveLabelCounts\"S\n\x17CooccurrenceMatr\
    ixEntry\x12\x10\n\x03row\x18\x01\x20\x01(\tR\x03row\x12\x10\n\x03col\x18\
    \x02\x20\x01(\tR\x03col\x12\x14\n\x05count\x18\x03\x20\x01(\rR\x05count\
    \"t\n\x12CooccurrenceMatrix\x12=\n\x06matrix\x18\x01\x20\x03(\x0b2%.clar\
    ifai.api.CooccurrenceMatrixEntryR\x06matrix\x12\x1f\n\x0bconcept_ids\x18\
    \x02\x20\x03(\tR\nconceptIds\"\xea\x01\n\x14ConfusionMatrixEntry\x12\x1c\
    \n\tpredicted\x18\x01\x20\x01(\tR\tpredicted\x12\x16\n\x06actual\x18\x02\
    \x20\x01(\tR\x06actual\x12\x1a\n\x05value\x18\x04\x20\x01(\x02R\x05value\
    B\x04\x80\xb5\x18\x01\x12B\n\x11predicted_concept\x18\x05\x20\x01(\x0b2\
    \x15.clarifai.api.ConceptR\x10predictedConcept\x12<\n\x0eactual_concept\
    \x18\x06\x20\x01(\x0b2\x15.clarifai.api.ConceptR\ractualConcept\"n\n\x0f\
    ConfusionMatrix\x12:\n\x06matrix\x18\x01\x20\x03(\x0b2\".clarifai.api.Co\
    nfusionMatrixEntryR\x06matrix\x12\x1f\n\x0bconcept_ids\x18\x02\x20\x03(\
    \tR\nconceptIds\"\xa5\x01\n\x03ROC\x12\x16\n\x03fpr\x18\x01\x20\x03(\x02\
    R\x03fprB\x04\x80\xb5\x18\x01\x12\x16\n\x03tpr\x18\x02\x20\x03(\x02R\x03\
    tprB\x04\x80\xb5\x18\x01\x12$\n\nthresholds\x18\x03\x20\x03(\x02R\nthres\
    holdsB\x04\x80\xb5\x18\x01\x12\"\n\rfpr_per_image\x18\x04\x20\x03(\x02R\
    \x0bfprPerImage\x12$\n\x0efpr_per_object\x18\x05\x20\x03(\x02R\x0cfprPer\
    Object\"~\n\x14PrecisionRecallCurve\x12\x1c\n\x06recall\x18\x01\x20\x03(\
    \x02R\x06recallB\x04\x80\xb5\x18\x01\x12\"\n\tprecision\x18\x02\x20\x03(\
    \x02R\tprecisionB\x04\x80\xb5\x18\x01\x12$\n\nthresholds\x18\x03\x20\x03\
    (\x02R\nthresholdsB\x04\x80\xb5\x18\x01\"\xe6\x03\n\rBinaryMetrics\x12\
    \x1d\n\x07num_pos\x18\x01\x20\x01(\rR\x06numPosB\x04\x80\xb5\x18\x01\x12\
    \x1d\n\x07num_neg\x18\x02\x20\x01(\rR\x06numNegB\x04\x80\xb5\x18\x01\x12\
    \x1d\n\x07num_tot\x18\x03\x20\x01(\rR\x06numTotB\x04\x80\xb5\x18\x01\x12\
    \x1d\n\x07roc_auc\x18\x04\x20\x01(\x02R\x06rocAucB\x04\x80\xb5\x18\x01\
    \x12\x14\n\x02f1\x18\x05\x20\x01(\x02R\x02f1B\x04\x80\xb5\x18\x01\x12/\n\
    \x07concept\x18\x06\x20\x01(\x0b2\x15.clarifai.api.ConceptR\x07concept\
    \x12.\n\troc_curve\x18\x07\x20\x01(\x0b2\x11.clarifai.api.ROCR\x08rocCur\
    ve\x12X\n\x16precision_recall_curve\x18\x08\x20\x01(\x0b2\".clarifai.api\
    .PrecisionRecallCurveR\x14precisionRecallCurve\x12#\n\ravg_precision\x18\
    \t\x20\x01(\x02R\x0cavgPrecision\x12\x1b\n\tarea_name\x18\n\x20\x01(\tR\
    \x08areaName\x12\x19\n\x08area_min\x18\x0b\x20\x01(\x01R\x07areaMin\x12\
    \x19\n\x08area_max\x18\x0c\x20\x01(\x01R\x07areaMax\x12\x10\n\x03iou\x18\
    \r\x20\x01(\x02R\x03iou\"\xdb\x01\n\x0eTrackerMetrics\x12\x19\n\x08mot_m\
    ota\x18\x01\x20\x01(\x02R\x07motMota\x12(\n\x10mot_num_switches\x18\x02\
    \x20\x01(\x05R\x0emotNumSwitches\x12\x1d\n\nmorse_frag\x18\x03\x20\x01(\
    \x02R\tmorseFrag\x12#\n\ravg_precision\x18\x04\x20\x01(\x02R\x0cavgPreci\
    sion\x12\x12\n\x04aiid\x18\x05\x20\x01(\tR\x04aiid\x12,\n\x12unique_swit\
    ch_rate\x18\x06\x20\x01(\x02R\x10uniqueSwitchRate\"\xb7\x03\n\x10EvalTes\
    tSetEntry\x12)\n\x05input\x18\x06\x20\x01(\x0b2\x13.clarifai.api.InputR\
    \x05input\x12D\n\x12predicted_concepts\x18\x03\x20\x03(\x0b2\x15.clarifa\
    i.api.ConceptR\x11predictedConcepts\x12I\n\x15ground_truth_concepts\x18\
    \x04\x20\x03(\x0b2\x15.clarifai.api.ConceptR\x13groundTruthConcepts\x12<\
    \n\nannotation\x18\x05\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\nannot\
    ationB\x02\x18\x01\x12K\n\x14predicted_annotation\x18\x07\x20\x01(\x0b2\
    \x18.clarifai.api.AnnotationR\x13predictedAnnotation\x12P\n\x17ground_tr\
    uth_annotation\x18\x08\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\x15gro\
    undTruthAnnotationJ\x04\x08\x01\x10\x02J\x04\x08\x02\x10\x03\"\xaf\x02\n\
    \x0eLOPQEvalResult\x12\x0c\n\x01k\x18\x01\x20\x01(\x05R\x01k\x127\n\x15r\
    ecall_vs_brute_force\x18\x02\x20\x01(\x02R\x12recallVsBruteForceB\x04\
    \x80\xb5\x18\x01\x12@\n\x1akendall_tau_vs_brute_force\x18\x03\x20\x01(\
    \x02R\x16kendallTauVsBruteForceB\x04\x80\xb5\x18\x01\x12A\n\x1amost_freq\
    uent_code_percent\x18\x04\x20\x01(\x02R\x17mostFrequentCodePercentB\x04\
    \x80\xb5\x18\x01\x12!\n\tlopq_ndcg\x18\x05\x20\x01(\x02R\x08lopqNdcgB\
    \x04\x80\xb5\x18\x01\x12.\n\x10brute_force_ndcg\x18\x06\x20\x01(\x02R\
    \x0ebruteForceNdcgB\x04\x80\xb5\x18\x01\"\xcb\x04\n\x0eMetricsSummary\
    \x12'\n\rtop1_accuracy\x18\x01\x20\x01(\x02R\x0ctop1AccuracyB\x02\x18\
    \x01\x12'\n\rtop5_accuracy\x18\x02\x20\x01(\x02R\x0ctop5AccuracyB\x02\
    \x18\x01\x12/\n\x11macro_avg_roc_auc\x18\x03\x20\x01(\x02R\x0emacroAvgRo\
    cAucB\x04\x80\xb5\x18\x01\x12/\n\x11macro_std_roc_auc\x18\x04\x20\x01(\
    \x02R\x0emacroStdRocAucB\x04\x80\xb5\x18\x01\x121\n\x12macro_avg_f1_scor\
    e\x18\x05\x20\x01(\x02R\x0fmacroAvgF1ScoreB\x04\x80\xb5\x18\x01\x121\n\
    \x12macro_std_f1_score\x18\x06\x20\x01(\x02R\x0fmacroStdF1ScoreB\x04\x80\
    \xb5\x18\x01\x124\n\x13macro_avg_precision\x18\x07\x20\x01(\x02R\x11macr\
    oAvgPrecisionB\x04\x80\xb5\x18\x01\x12.\n\x10macro_avg_recall\x18\x08\
    \x20\x01(\x02R\x0emacroAvgRecallB\x04\x80\xb5\x18\x01\x128\n\x19mean_avg\
    _precision_iou_50\x18\n\x20\x01(\x02R\x15meanAvgPrecisionIou50\x12>\n\
    \x1cmean_avg_precision_iou_range\x18\x0b\x20\x01(\x02R\x18meanAvgPrecisi\
    onIouRange\x12?\n\x0clopq_metrics\x18\t\x20\x03(\x0b2\x1c.clarifai.api.L\
    OPQEvalResultR\x0blopqMetrics\"\xa8\x08\n\x0bEvalMetrics\x123\n\x06statu\
    s\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    \x17\n\x07user_id\x18\x0f\x20\x01(\tR\x06userId\x12\x15\n\x06app_id\x18\
    \x10\x20\x01(\tR\x05appId\x12\x0e\n\x02id\x18\n\x20\x01(\tR\x02id\x12)\n\
    \x05model\x18\r\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05model\x12G\n\
    \x14ground_truth_dataset\x18\x0e\x20\x01(\x0b2\x15.clarifai.api.DatasetR\
    \x12groundTruthDataset\x12F\n\x13predictions_dataset\x18\x12\x20\x01(\
    \x0b2\x15.clarifai.api.DatasetR\x12predictionsDataset\x126\n\x07summary\
    \x18\x02\x20\x01(\x0b2\x1c.clarifai.api.MetricsSummaryR\x07summary\x12H\
    \n\x10confusion_matrix\x18\x03\x20\x01(\x0b2\x1d.clarifai.api.ConfusionM\
    atrixR\x0fconfusionMatrix\x12Q\n\x13cooccurrence_matrix\x18\x04\x20\x01(\
    \x0b2\x20.clarifai.api.CooccurrenceMatrixR\x12cooccurrenceMatrix\x12B\n\
    \x0clabel_counts\x18\x05\x20\x01(\x0b2\x1f.clarifai.api.LabelDistributio\
    nR\x0blabelCounts\x12B\n\x0ebinary_metrics\x18\x06\x20\x03(\x0b2\x1b.cla\
    rifai.api.BinaryMetricsR\rbinaryMetrics\x129\n\x08test_set\x18\x07\x20\
    \x03(\x0b2\x1e.clarifai.api.EvalTestSetEntryR\x07testSet\x12C\n\x0fmetri\
    cs_by_area\x18\x08\x20\x03(\x0b2\x1b.clarifai.api.BinaryMetricsR\rmetric\
    sByArea\x12E\n\x10metrics_by_class\x18\t\x20\x03(\x0b2\x1b.clarifai.api.\
    BinaryMetricsR\x0emetricsByClass\x12E\n\x0ftracker_metrics\x18\x0b\x20\
    \x03(\x0b2\x1c.clarifai.api.TrackerMetricsR\x0etrackerMetrics\x123\n\tev\
    al_info\x18\x0c\x20\x01(\x0b2\x16.clarifai.api.EvalInfoR\x08evalInfo\x12\
    H\n\x10extended_metrics\x18\x11\x20\x01(\x0b2\x1d.clarifai.api.ExtendedM\
    etricsR\x0fextendedMetrics\"M\n\x0fExtendedMetrics\x12:\n\x0cuser_metric\
    s\x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\x0buserMetrics\"\xa0\
    \x02\n\x0bFieldsValue\x12)\n\x10confusion_matrix\x18\x01\x20\x01(\x08R\
    \x0fconfusionMatrix\x12/\n\x13cooccurrence_matrix\x18\x02\x20\x01(\x08R\
    \x12cooccurrenceMatrix\x12!\n\x0clabel_counts\x18\x03\x20\x01(\x08R\x0bl\
    abelCounts\x12%\n\x0ebinary_metrics\x18\x04\x20\x01(\x08R\rbinaryMetrics\
    \x12\x19\n\x08test_set\x18\x05\x20\x01(\x08R\x07testSet\x12&\n\x0fmetric\
    s_by_area\x18\x06\x20\x01(\x08R\rmetricsByArea\x12(\n\x10metrics_by_clas\
    s\x18\x07\x20\x01(\x08R\x0emetricsByClass\"\x86\x02\n\x06Output\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\tR\x02id\x123\n\x06status\x18\x02\x20\x01(\x0b\
    2\x1b.clarifai.api.status.StatusR\x06status\x129\n\ncreated_at\x18\x03\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12)\n\x05model\
    \x18\x04\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05model\x12)\n\x05input\
    \x18\x05\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\x12&\n\x04data\
    \x18\x06\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\"L\n\tScopeDeps\
    \x12\x14\n\x05scope\x18\x01\x20\x01(\tR\x05scope\x12)\n\x10depending_sco\
    pes\x18\x02\x20\x03(\tR\x0fdependingScopes\"U\n\x0cEndpointDeps\x12\x1a\
    \n\x08endpoint\x18\x01\x20\x01(\tR\x08endpoint\x12)\n\x10depending_scope\
    s\x18\x02\x20\x03(\tR\x0fdependingScopes\"\xb6\x01\n\x03Hit\x12\x1a\n\
    \x05score\x18\x01\x20\x01(\x02R\x05scoreB\x04\x80\xb5\x18\x01\x12)\n\x05\
    input\x18\x02\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\x128\n\nann\
    otation\x18\x03\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\nannotation\
    \x12\x17\n\x07user_id\x18\x04\x20\x01(\tR\x06userId\x12\x15\n\x06app_id\
    \x18\x05\x20\x01(\tR\x05appId\"3\n\x08HitCount\x12'\n\x0festimated_total\
    \x18\x01\x20\x01(\x04R\x0eestimatedTotal\"\xb0\x01\n\x03And\x12)\n\x05in\
    put\x18\x01\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\x12,\n\x06out\
    put\x18\x02\x20\x01(\x0b2\x14.clarifai.api.OutputR\x06output\x12\x16\n\
    \x06negate\x18\x03\x20\x01(\x08R\x06negate\x128\n\nannotation\x18\x04\
    \x20\x01(\x0b2\x18.clarifai.api.AnnotationR\nannotation\"\xa8\x01\n\x05Q\
    uery\x12)\n\x04ands\x18\x01\x20\x03(\x0b2\x11.clarifai.api.AndR\x04andsB\
    \x02\x18\x01\x12\x1a\n\x08language\x18\x02\x20\x01(\tR\x08language\x12.\
    \n\x07filters\x18\x03\x20\x03(\x0b2\x14.clarifai.api.FilterR\x07filters\
    \x12(\n\x05ranks\x18\x04\x20\x03(\x0b2\x12.clarifai.api.RankR\x05ranks\"\
    \xcb\x04\n\x06Search\x12)\n\x05query\x18\x01\x20\x01(\x0b2\x13.clarifai.\
    api.QueryR\x05query\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12%\n\x0e\
    application_id\x18\x03\x20\x01(\tR\rapplicationId\x12\x12\n\x04name\x18\
    \x04\x20\x01(\tR\x04name\x12/\n\x05as_of\x18\x05\x20\x01(\x0b2\x1a.googl\
    e.protobuf.TimestampR\x04asOf\x12\x19\n\x08git_hash\x18\x06\x20\x01(\tR\
    \x07gitHash\x129\n\ncreated_at\x18\x07\x20\x01(\x0b2\x1a.google.protobuf\
    .TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x08\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.TimestampR\nmodifiedAt\x12\x1c\n\talgorithm\x18\t\x20\x01\
    (\tR\talgorithm\x12\x12\n\x04save\x18\n\x20\x01(\x08R\x04save\x12\x1b\n\
    \tmin_value\x18\x0b\x20\x01(\x02R\x08minValue\x128\n\nvisibility\x18\x0c\
    \x20\x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibility\x123\n\x06metric\
    \x18\r\x20\x01(\x0e2\x1b.clarifai.api.Search.MetricR\x06metric\"I\n\x06M\
    etric\x12\x12\n\x0eMETRIC_NOT_SET\x10\0\x12\x16\n\x12EUCLIDEAN_DISTANCE\
    \x10\x01\x12\x13\n\x0fCOSINE_DISTANCE\x10\x02\"\xd5\x01\n\x06Filter\x12\
    \x16\n\x06negate\x18\x03\x20\x01(\x08R\x06negate\x128\n\nannotation\x18\
    \x04\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\nannotation\x12)\n\x05in\
    put\x18\x05\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\x12N\n\x17las\
    t_updated_time_range\x18\x06\x20\x01(\x0b2\x17.clarifai.api.TimeRangeR\
    \x14lastUpdatedTimeRange\"}\n\tTimeRange\x129\n\nstart_time\x18\x01\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\tstartTime\x125\n\x08end_time\
    \x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07endTime\"X\n\
    \x04Rank\x12\x16\n\x06negate\x18\x03\x20\x01(\x08R\x06negate\x128\n\nann\
    otation\x18\x04\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\nannotation\"\
    \xd7\x02\n\x17AnnotationSearchMetrics\x127\n\x0cground_truth\x18\x01\x20\
    \x01(\x0b2\x14.clarifai.api.SearchR\x0bgroundTruth\x12:\n\x0esearch_to_e\
    val\x18\x02\x20\x01(\x0b2\x14.clarifai.api.SearchR\x0csearchToEval\x123\
    \n\x07metrics\x18\x03\x20\x01(\x0b2\x19.clarifai.api.EvalMetricsR\x07met\
    rics\x12&\n\x04data\x18\x04\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\
    \x120\n\x14active_concept_count\x18\x05\x20\x01(\rR\x12activeConceptCoun\
    t\x128\n\nvisibility\x18\x06\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\
    \nvisibility\"\xc0\x01\n\x04Text\x12\x10\n\x03raw\x18\x01\x20\x01(\tR\
    \x03raw\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12.\n\x13allow_dupl\
    icate_url\x18\x03\x20\x01(\x08R\x11allowDuplicateUrl\x12/\n\x06hosted\
    \x18\x04\x20\x01(\x0b2\x17.clarifai.api.HostedURLR\x06hosted\x123\n\ttex\
    t_info\x18\x05\x20\x01(\x0b2\x16.clarifai.api.TextInfoR\x08textInfo\"E\n\
    \x08TextInfo\x12\x1d\n\nchar_count\x18\x01\x20\x01(\x05R\tcharCount\x12\
    \x1a\n\x08encoding\x18\x02\x20\x01(\tR\x08encoding\"\xa7\x08\n\x04User\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12'\n\rprimary_email\x18\x02\
    \x20\x01(\tR\x0cprimaryEmailB\x02\x18\x01\x12\x1d\n\nfirst_name\x18\x03\
    \x20\x01(\tR\tfirstName\x12\x1b\n\tlast_name\x18\x04\x20\x01(\tR\x08last\
    Name\x12!\n\x0ccompany_name\x18\x05\x20\x01(\tR\x0bcompanyName\x12\x1b\n\
    \tjob_title\x18\x13\x20\x01(\tR\x08jobTitle\x12\x19\n\x08job_role\x18\
    \x14\x20\x01(\tR\x07jobRole\x12\x1c\n\tintention\x18\x18\x20\x01(\tR\tin\
    tention\x12\x1f\n\tbill_type\x18\x07\x20\x01(\tR\x08billTypeB\x02\x18\
    \x01\x129\n\ncreated_at\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampR\tcreatedAt\x12J\n\x11date_gdpr_consent\x18\x08\x20\x01(\x0b2\x1a.go\
    ogle.protobuf.TimestampR\x0fdateGdprConsentB\x02\x18\x01\x12H\n\x10date_\
    tos_consent\x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0edateTo\
    sConsentB\x02\x18\x01\x12T\n\x16date_marketing_consent\x18\n\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x14dateMarketingConsentB\x02\x18\
    \x01\x12H\n\x10date_pii_consent\x18\x17\x20\x01(\x0b2\x1a.google.protobu\
    f.TimestampR\x0edatePiiConsentB\x02\x18\x01\x127\n\x08metadata\x18\x0b\
    \x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadataB\x02\x18\x01\x12G\
    \n\x0femail_addresses\x18\x0c\x20\x03(\x0b2\x1a.clarifai.api.EmailAddres\
    sR\x0eemailAddressesB\x02\x18\x01\x129\n\x17two_factor_auth_enabled\x18\
    \x0f\x20\x01(\x08R\x14twoFactorAuthEnabledB\x02\x18\x01\x12#\n\x0bteams_\
    count\x18\x10\x20\x01(\rR\nteamsCountB\x02\x18\x01\x12\x1d\n\nis_starred\
    \x18\x15\x20\x01(\x08R\tisStarred\x12\x1d\n\nstar_count\x18\x16\x20\x01(\
    \x05R\tstarCount\x128\n\nvisibility\x18\x11\x20\x01(\x0b2\x18.clarifai.a\
    pi.VisibilityR\nvisibility\x129\n\x0buser_detail\x18\x12\x20\x01(\x0b2\
    \x18.clarifai.api.UserDetailR\nuserDetailJ\x04\x08\r\x10\x0eJ\x04\x08\
    \x0e\x10\x0f\"\xfc\x04\n\nUserDetail\x12#\n\rprimary_email\x18\x01\x20\
    \x01(\tR\x0cprimaryEmail\x12\x1b\n\tbill_type\x18\x02\x20\x01(\tR\x08bil\
    lType\x12F\n\x11date_gdpr_consent\x18\x03\x20\x01(\x0b2\x1a.google.proto\
    buf.TimestampR\x0fdateGdprConsent\x12D\n\x10date_tos_consent\x18\x04\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x0edateTosConsent\x12P\n\x16da\
    te_marketing_consent\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.Timestamp\
    R\x14dateMarketingConsent\x12D\n\x10date_pii_consent\x18\r\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x0edatePiiConsent\x123\n\x08metadata\x18\
    \x06\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\x12C\n\x0fema\
    il_addresses\x18\x07\x20\x03(\x0b2\x1a.clarifai.api.EmailAddressR\x0eema\
    ilAddresses\x125\n\x17two_factor_auth_enabled\x18\t\x20\x01(\x08R\x14two\
    FactorAuthEnabled\x12\x1f\n\x0bteams_count\x18\n\x20\x01(\rR\nteamsCount\
    \x12\x18\n\x07country\x18\x0b\x20\x01(\tR\x07country\x12\x14\n\x05state\
    \x18\x0c\x20\x01(\tR\x05stateJ\x04\x08\x08\x10\t\"l\n\x0cEmailAddress\
    \x12\x1a\n\x05email\x18\x01\x20\x01(\tR\x05emailB\x04\x80\xb5\x18\x01\
    \x12\x1e\n\x07primary\x18\x02\x20\x01(\x08R\x07primaryB\x04\x80\xb5\x18\
    \x01\x12\x20\n\x08verified\x18\x03\x20\x01(\x08R\x08verifiedB\x04\x80\
    \xb5\x18\x01\"(\n\x08Password\x12\x1c\n\tplaintext\x18\x01\x20\x01(\tR\t\
    plaintext\"\xf2\x04\n\x12PasswordViolations\x12%\n\x0eminimum_length\x18\
    \x01\x20\x01(\x08R\rminimumLength\x12%\n\x0emaximum_length\x18\x02\x20\
    \x01(\x08R\rmaximumLength\x12*\n\x11upper_case_needed\x18\x03\x20\x01(\
    \x08R\x0fupperCaseNeeded\x12*\n\x11lower_case_needed\x18\x04\x20\x01(\
    \x08R\x0flowerCaseNeeded\x12%\n\x0enumeric_needed\x18\x05\x20\x01(\x08R\
    \rnumericNeeded\x126\n\x17non_alphanumeric_needed\x18\x06\x20\x01(\x08R\
    \x15nonAlphanumericNeeded\x12%\n\x0epassword_reuse\x18\x07\x20\x01(\x08R\
    \rpasswordReuse\x12#\n\rexclude_names\x18\x08\x20\x01(\x08R\x0cexcludeNa\
    mes\x12#\n\rexclude_email\x18\t\x20\x01(\x08R\x0cexcludeEmail\x120\n\x14\
    no_confusing_letters\x18\n\x20\x01(\x08R\x12noConfusingLetters\x12.\n\
    \x13no_simple_passwords\x18\x0b\x20\x01(\x08R\x11noSimplePasswords\x12(\
    \n\x10no_common_vocabs\x18\x0c\x20\x01(\x08R\x0enoCommonVocabs\x12-\n\
    \x13no_overlap_with_old\x18\r\x20\x01(\x08R\x10noOverlapWithOld\x12+\n\
    \x11password_lifespan\x18\x0e\x20\x01(\x08R\x10passwordLifespan\"\xb7\
    \x02\n\x05Video\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x16\n\
    \x06base64\x18\x02\x20\x01(\x0cR\x06base64\x12.\n\x13allow_duplicate_url\
    \x18\x04\x20\x01(\x08R\x11allowDuplicateUrl\x12'\n\rthumbnail_url\x18\
    \x05\x20\x01(\tR\x0cthumbnailUrlB\x02\x18\x01\x12/\n\x06hosted\x18\x06\
    \x20\x01(\x0b2\x17.clarifai.api.HostedURLR\x06hosted\x12B\n\x10hosted_th\
    umbnail\x18\x08\x20\x01(\x0b2\x17.clarifai.api.HostedURLR\x0fhostedThumb\
    nail\x126\n\nvideo_info\x18\x07\x20\x01(\x0b2\x17.clarifai.api.VideoInfo\
    R\tvideoInfo\"\xd5\x01\n\tVideoInfo\x12\x14\n\x05width\x18\x01\x20\x01(\
    \x05R\x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\x12\
    \x10\n\x03fps\x18\x03\x20\x01(\x02R\x03fps\x12!\n\x0cvideo_format\x18\
    \x04\x20\x01(\tR\x0bvideoFormat\x12\x19\n\x08bit_rate\x18\x05\x20\x01(\
    \x05R\x07bitRate\x12\x1f\n\x0bframe_count\x18\x06\x20\x01(\x05R\nframeCo\
    unt\x12)\n\x10duration_seconds\x18\x07\x20\x01(\x02R\x0fdurationSeconds\
    \"\xd4\x05\n\x08Workflow\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x15\n\x06app_id\x18\x02\x20\x01(\tR\x05appId\x129\n\ncreated_at\x18\x03\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x120\n\x05nodes\
    \x18\x04\x20\x03(\x0b2\x1a.clarifai.api.WorkflowNodeR\x05nodes\x123\n\
    \x08metadata\x18\x05\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metada\
    ta\x128\n\nvisibility\x18\x06\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\
    \nvisibility\x12\x17\n\x07user_id\x18\x07\x20\x01(\tR\x06userId\x12;\n\
    \x0bmodified_at\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmo\
    difiedAt\x127\n\x07version\x18\t\x20\x01(\x0b2\x1d.clarifai.api.Workflow\
    VersionR\x07version\x12\x1d\n\nis_starred\x18\n\x20\x01(\x08R\tisStarred\
    \x12\x1d\n\nstar_count\x18\x0b\x20\x01(\x05R\tstarCount\x12\x20\n\x0bdes\
    cription\x18\x0c\x20\x01(\tR\x0bdescription\x12\x14\n\x05notes\x18\r\x20\
    \x01(\tR\x05notes\x12!\n\tuse_cases\x18\x0e\x20\x03(\tR\x08useCasesB\x04\
    \x80\xb5\x18\x01\x12+\n\x0echeck_consents\x18\x0f\x20\x03(\tR\rcheckCons\
    entsB\x04\x80\xb5\x18\x01\x12E\n\x0fbookmark_origin\x18\x10\x20\x01(\x0b\
    2\x1c.clarifai.api.BookmarkOriginR\x0ebookmarkOrigin\x12)\n\x05image\x18\
    \x11\x20\x01(\x0b2\x13.clarifai.api.ImageR\x05image\"\xc7\x03\n\x0fWorkf\
    lowVersion\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1f\n\x0bworkfl\
    ow_id\x18\x02\x20\x01(\tR\nworkflowId\x129\n\ncreated_at\x18\x03\x20\x01\
    (\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\
    \x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x128\n\
    \nvisibility\x18\x05\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibil\
    ity\x120\n\x05nodes\x18\x06\x20\x03(\x0b2\x1a.clarifai.api.WorkflowNodeR\
    \x05nodes\x123\n\x08metadata\x18\x07\x20\x01(\x0b2\x17.google.protobuf.S\
    tructR\x08metadata\x12\x15\n\x06app_id\x18\x08\x20\x01(\tR\x05appId\x12\
    \x17\n\x07user_id\x18\t\x20\x01(\tR\x06userId\x12\x20\n\x0bdescription\
    \x18\n\x20\x01(\tR\x0bdescription\x12\x18\n\x07license\x18\x0b\x20\x01(\
    \tR\x07license\"\xf8\x01\n\x0cWorkflowNode\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12)\n\x05model\x18\x02\x20\x01(\x0b2\x13.clarifai.api.Mo\
    delR\x05model\x128\n\x0bnode_inputs\x18\x03\x20\x03(\x0b2\x17.clarifai.a\
    pi.NodeInputR\nnodeInputs\x12'\n\x0fsuppress_output\x18\x04\x20\x01(\x08\
    R\x0esuppressOutput\x12J\n\x14output_info_override\x18\x05\x20\x01(\x0b2\
    \x18.clarifai.api.OutputInfoR\x12outputInfoOverride\"$\n\tNodeInput\x12\
    \x17\n\x07node_id\x18\x01\x20\x01(\tR\x06nodeId\"\xc3\x02\n\x0eWorkflowR\
    esult\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x123\n\x06status\x18\x02\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x129\n\ncreated\
    _at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12-\
    \n\x05model\x18\x04\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05modelB\x02\
    \x18\x01\x12)\n\x05input\x18\x05\x20\x01(\x0b2\x13.clarifai.api.InputR\
    \x05input\x12.\n\x07outputs\x18\x06\x20\x03(\x0b2\x14.clarifai.api.Outpu\
    tR\x07outputs\x12'\n\x0fsuppress_output\x18\x07\x20\x01(\x08R\x0esuppres\
    sOutput\"\x1f\n\rWorkflowState\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \"\xfe\x03\n\x0eAppDuplication\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12:\n\x0fdestination_app\x18\n\x20\x01(\x0b2\x11.clarifai.api.AppR\x0e\
    destinationApp\x12*\n\x0fexisting_app_id\x18\x08\x20\x01(\tR\rexistingAp\
    pIdB\x02\x18\x01\x12\x20\n\nnew_app_id\x18\x02\x20\x01(\tR\x08newAppIdB\
    \x02\x18\x01\x12$\n\x0cnew_app_name\x18\x03\x20\x01(\tR\nnewAppNameB\x02\
    \x18\x01\x123\n\x06status\x18\x04\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x129\n\ncreated_at\x18\x05\x20\x01(\x0b2\x1a.google.pr\
    otobuf.TimestampR\tcreatedAt\x12D\n\x10last_modified_at\x18\x06\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x0elastModifiedAt\x12;\n\x06filter\
    \x18\x07\x20\x01(\x0b2#.clarifai.api.AppDuplicationFiltersR\x06filter\
    \x129\n\x08progress\x18\t\x20\x03(\x0b2\x1d.clarifai.api.AppCopyProgress\
    R\x08progress\"C\n\x0fAppCopyProgress\x12\x14\n\x05field\x18\x01\x20\x01\
    (\tR\x05field\x12\x1a\n\x05value\x18\x02\x20\x01(\x05R\x05valueB\x04\x80\
    \xb5\x18\x01\"\x95\x02\n\x15AppDuplicationFilters\x12\x1f\n\x0bcopy_inpu\
    ts\x18\x01\x20\x01(\x08R\ncopyInputs\x12#\n\rcopy_concepts\x18\x02\x20\
    \x01(\x08R\x0ccopyConcepts\x12)\n\x10copy_annotations\x18\x03\x20\x01(\
    \x08R\x0fcopyAnnotations\x12\x1f\n\x0bcopy_models\x18\x04\x20\x01(\x08R\
    \ncopyModels\x12%\n\x0ecopy_workflows\x18\x05\x20\x01(\x08R\rcopyWorkflo\
    ws\x12C\n\x1ecopy_installed_module_versions\x18\x06\x20\x01(\x08R\x1bcop\
    yInstalledModuleVersions\"\xee\x03\n\nLabelOrder\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x123\n\
    \x06status\x18\x03\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12!\n\x0cauto_release\x18\x04\x20\x01(\x08R\x0bautoRelease\x12&\n\
    \x0fallow_empty_tag\x18\x05\x20\x01(\x08R\rallowEmptyTag\x12L\n\x14desir\
    ed_fulfill_time\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x12\
    desiredFulfillTime\x12N\n\x15estimate_fulfill_time\x18\x07\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x13estimateFulfillTime\x12&\n\x04task\
    \x18\x08\x20\x01(\x0b2\x12.clarifai.api.TaskR\x04task\x129\n\ncreated_at\
    \x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\
    \x0bmodified_at\x18\n\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodi\
    fiedAt\"\xca\x08\n\x04Task\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    9\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcr\
    eatedAt\x12;\n\x0bmodified_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.\
    TimestampR\nmodifiedAt\x12/\n\x04type\x18\x04\x20\x01(\x0e2\x1b.clarifai\
    .api.Task.TaskTypeR\x04type\x12\x20\n\x0bdescription\x18\x05\x20\x01(\tR\
    \x0bdescription\x120\n\x06worker\x18\x06\x20\x01(\x0b2\x18.clarifai.api.\
    TaskWorkerR\x06worker\x12#\n\x0bconcept_ids\x18\x07\x20\x03(\tR\nconcept\
    IdsB\x02\x18\x01\x12@\n\x0cinput_source\x18\x08\x20\x01(\x0b2\x1d.clarif\
    ai.api.TaskInputSourceR\x0binputSource\x12\x1b\n\tsample_ms\x18\t\x20\
    \x01(\rR\x08sampleMs\x12@\n\x0cai_assistant\x18\n\x20\x01(\x0b2\x1d.clar\
    ifai.api.TaskAIAssistantR\x0baiAssistant\x120\n\x06review\x18\x0b\x20\
    \x01(\x0b2\x18.clarifai.api.TaskReviewR\x06review\x123\n\x06status\x18\
    \x0c\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x12\n\
    \x04name\x18\r\x20\x01(\tR\x04name\x12J\n\x10ai_assist_params\x18\x0e\
    \x20\x01(\x0b2\x20.clarifai.api.AiAssistParametersR\x0eaiAssistParams\
    \x128\n\nvisibility\x18\x0f\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\n\
    visibility\x12\x15\n\x06app_id\x18\x10\x20\x01(\tR\x05appId\x12\x17\n\
    \x07user_id\x18\x11\x20\x01(\tR\x06userId\x12$\n\x0elabel_order_id\x18\
    \x12\x20\x01(\tR\x0clabelOrderId\x125\n\x08concepts\x18\x13\x20\x03(\x0b\
    2\x19.clarifai.api.TaskConceptR\x08concepts\x12>\n\x1bdelete_previous_an\
    notations\x18\x14\x20\x01(\x08R\x19deletePreviousAnnotations\x123\n\x07m\
    etrics\x18\x15\x20\x01(\x0b2\x19.clarifai.api.TaskMetricsR\x07metrics\"l\
    \n\x08TaskType\x12\x10\n\x0cTYPE_NOT_SET\x10\0\x12\x1b\n\x17CONCEPTS_CLA\
    SSIFICATION\x10\x01\x12\x1a\n\x16BOUNDING_BOX_DETECTION\x10\x02\x12\x15\
    \n\x11POLYGON_DETECTION\x10\x03\"\x90\x01\n\x12AiAssistParameters\x12#\n\
    \rmin_threshold\x18\x01\x20\x01(\x02R\x0cminThreshold\x12#\n\rmax_thresh\
    old\x18\x02\x20\x01(\x02R\x0cmaxThreshold\x120\n\x14concept_relation_ids\
    \x18\x03\x20\x03(\tR\x12conceptRelationIds\"\xb2\x03\n\nTaskWorker\x12G\
    \n\x08strategy\x18\x01\x20\x01(\x0e2+.clarifai.api.TaskWorker.TaskWorker\
    StrategyR\x08strategy\x12\x1d\n\x08user_ids\x18\x02\x20\x03(\tR\x07userI\
    dsB\x02\x18\x01\x12,\n\x05users\x18\x04\x20\x03(\x0b2\x12.clarifai.api.U\
    serR\x05usersB\x02\x18\x01\x12m\n\x19partitioned_strategy_info\x18\x03\
    \x20\x01(\x0b2/.clarifai.api.TaskWorkerPartitionedStrategyInfoH\0R\x17pa\
    rtitionedStrategyInfo\x12.\n\x07workers\x18\x07\x20\x03(\x0b2\x14.clarif\
    ai.api.WorkerR\x07workers\"R\n\x12TaskWorkerStrategy\x12\x1b\n\x17WORKER\
    _STRATEGY_NOT_SET\x10\0\x12\x0f\n\x0bPARTITIONED\x10\x02\x12\x08\n\x04FU\
    LL\x10\x03\"\x04\x08\x01\x10\x01B\x0f\n\rstrategy_infoJ\x04\x08\x05\x10\
    \x06J\x04\x08\x06\x10\x07\"\xc9\x02\n!TaskWorkerPartitionedStrategyInfo\
    \x12a\n\x04type\x18\x01\x20\x01(\x0e2M.clarifai.api.TaskWorkerPartitione\
    dStrategyInfo.TaskWorkerPartitionedStrategyR\x04type\x12*\n\x11workers_p\
    er_input\x18\x02\x20\x01(\x05R\x0fworkersPerInput\x121\n\x07weights\x18\
    \x03\x20\x01(\x0b2\x17.google.protobuf.StructR\x07weights\"b\n\x1dTaskWo\
    rkerPartitionedStrategy\x12'\n#PARTITIONED_WORKER_STRATEGY_NOT_SET\x10\0\
    \x12\n\n\x06EVENLY\x10\x01\x12\x0c\n\x08WEIGHTED\x10\x02\"\xcd\x01\n\x0f\
    TaskInputSource\x12E\n\x04type\x18\x01\x20\x01(\x0e21.clarifai.api.TaskI\
    nputSource.TaskInputSourceTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\
    \tR\x02id\"c\n\x13TaskInputSourceType\x12\x1d\n\x19INPUT_SOURCE_TYPE_NOT\
    _SET\x10\0\x12\x0e\n\nALL_INPUTS\x10\x01\x12\x10\n\x0cSAVED_SEARCH\x10\
    \x02\x12\x0b\n\x07DATASET\x10\x03\"\xd5\x03\n\nTaskReview\x12G\n\x08stra\
    tegy\x18\x01\x20\x01(\x0e2+.clarifai.api.TaskReview.TaskReviewStrategyR\
    \x08strategy\x12\x1d\n\x08user_ids\x18\x02\x20\x03(\tR\x07userIdsB\x02\
    \x18\x01\x12(\n\x05users\x18\x05\x20\x03(\x0b2\x12.clarifai.api.UserR\
    \x05users\x12^\n\x14manual_strategy_info\x18\x03\x20\x01(\x0b2*.clarifai\
    .api.TaskReviewManualStrategyInfoH\0R\x12manualStrategyInfo\x12g\n\x17co\
    nsensus_strategy_info\x18\x04\x20\x01(\x0b2-.clarifai.api.TaskReviewCons\
    ensusStrategyInfoH\0R\x15consensusStrategyInfo\"[\n\x12TaskReviewStrateg\
    y\x12\x20\n\x1cTASK_REVIEW_STRATEGY_NOT_SET\x10\0\x12\x08\n\x04NONE\x10\
    \x01\x12\n\n\x06MANUAL\x10\x02\x12\r\n\tCONSENSUS\x10\x03B\x0f\n\rstrate\
    gy_info\"K\n\x1cTaskReviewManualStrategyInfo\x12+\n\x11sample_percentage\
    \x18\x01\x20\x01(\x02R\x10samplePercentage\"V\n\x1fTaskReviewConsensusSt\
    rategyInfo\x12-\n\x12approval_threshold\x18\x02\x20\x01(\rR\x11approvalT\
    hresholdJ\x04\x08\x01\x10\x02\"2\n\x0fTaskAIAssistant\x12\x1f\n\x0bworkf\
    low_id\x18\x01\x20\x01(\tR\nworkflowId\"\xa6\x02\n\x0eTaskAssignment\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x129\n\ncreated_at\x18\x02\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_\
    at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x12,\
    \n\x06worker\x18\x04\x20\x01(\x0b2\x14.clarifai.api.WorkerR\x06worker\
    \x12)\n\x05input\x18\x05\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\
    \x123\n\x06status\x18\x06\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\"\xbf\x02\n\x16TaskStatusCountPerUser\x12\x1b\n\x07user_id\
    \x18\x01\x20\x01(\tR\x06userIdB\x02\x18\x01\x12\x1e\n\x07pending\x18\x02\
    \x20\x01(\rR\x07pendingB\x04\x80\xb5\x18\x01\x12-\n\x0fawaiting_review\
    \x18\x03\x20\x01(\rR\x0eawaitingReviewB\x04\x80\xb5\x18\x01\x12\x1e\n\
    \x07success\x18\x04\x20\x01(\rR\x07successB\x04\x80\xb5\x18\x01\x12)\n\r\
    review_denied\x18\x05\x20\x01(\rR\x0creviewDeniedB\x04\x80\xb5\x18\x01\
    \x12@\n\x19awaiting_consensus_review\x18\x06\x20\x01(\rR\x17awaitingCons\
    ensusReviewB\x04\x80\xb5\x18\x01\x12,\n\x06worker\x18\x07\x20\x01(\x0b2\
    \x14.clarifai.api.WorkerR\x06worker\"\x98\x01\n\x0eThresholdRange\x12,\n\
    \x12is_lower_inclusive\x18\x01\x20\x01(\x08R\x10isLowerInclusive\x12,\n\
    \x12is_upper_inclusive\x18\x02\x20\x01(\x08R\x10isUpperInclusive\x12\x14\
    \n\x05lower\x18\x03\x20\x01(\x02R\x05lower\x12\x14\n\x05upper\x18\x04\
    \x20\x01(\x02R\x05upper\"\xde\x01\n\x1fTaskConceptAutoAnnotationConfig\
    \x122\n\x15annotation_data_types\x18\x01\x20\x01(\rR\x13annotationDataTy\
    pes\x12E\n\x0fthreshold_range\x18\x02\x20\x01(\x0b2\x1c.clarifai.api.Thr\
    esholdRangeR\x0ethresholdRange\x12@\n\x0bstatus_code\x18\x03\x20\x01(\
    \x0e2\x1f.clarifai.api.status.StatusCodeR\nstatusCode\"\xa3\x01\n\x0bTas\
    kConcept\x12/\n\x07concept\x18\x01\x20\x01(\x0b2\x15.clarifai.api.Concep\
    tR\x07concept\x12c\n\x16auto_annotation_config\x18\x02\x20\x01(\x0b2-.cl\
    arifai.api.TaskConceptAutoAnnotationConfigR\x14autoAnnotationConfig\"F\n\
    \x0bTaskMetrics\x121\n\x04work\x18\x02\x20\x01(\x0b2\x1d.clarifai.api.Ta\
    skWorkMetricsR\x04workJ\x04\x08\x01\x10\x02\"\x81\x01\n\x0fTaskWorkMetri\
    cs\x124\n\x16inputs_count_estimated\x18\x01\x20\x01(\x04R\x14inputsCount\
    Estimated\x128\n\x18inputs_percent_estimated\x18\x02\x20\x01(\rR\x16inpu\
    tsPercentEstimated\"\xbf\x03\n\tCollector\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescripti\
    on\x129\n\ncreated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.Timestam\
    pR\tcreatedAt\x121\n\x15pre_queue_workflow_id\x18\x04\x20\x01(\tR\x12pre\
    QueueWorkflowId\x125\n\x17pre_queue_random_sample\x18\x08\x20\x01(\x02R\
    \x14preQueueRandomSample\x123\n\x16post_queue_workflow_id\x18\x05\x20\
    \x01(\tR\x13postQueueWorkflowId\x12H\n\x10collector_source\x18\x06\x20\
    \x01(\x0b2\x1d.clarifai.api.CollectorSourceR\x0fcollectorSource\x123\n\
    \x06status\x18\x07\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12'\n\x0fcollect_outputs\x18\t\x20\x01(\x08R\x0ecollectOutputs\"\x99\
    \x01\n\x0fCollectorSource\x12\x85\x01\n'api_post_model_outputs_collector\
    _source\x18\x02\x20\x01(\x0b20.clarifai.api.APIPostModelOutputsCollector\
    SourceR\"apiPostModelOutputsCollectorSource\"\x82\x02\n\"APIPostModelOut\
    putsCollectorSource\x12\"\n\rmodel_user_id\x18\x01\x20\x01(\tR\x0bmodelU\
    serId\x12\x20\n\x0cmodel_app_id\x18\x02\x20\x01(\tR\nmodelAppId\x12\x19\
    \n\x08model_id\x18\x03\x20\x01(\tR\x07modelId\x12(\n\x10model_version_id\
    \x18\x04\x20\x01(\tR\x0emodelVersionId\x12+\n\x12post_inputs_key_id\x18\
    \x05\x20\x01(\tR\x0fpostInputsKeyId\x12$\n\x0ecaller_user_id\x18\x06\x20\
    \x01(\tR\x0ccallerUserId\"e\n\tStatValue\x12.\n\x04time\x18\x01\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x04time\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x02R\x05value\x12\x12\n\x04tags\x18\x03\x20\x03(\tR\x04tags\"\
    \xd4\x01\n\x18StatValueAggregateResult\x12T\n\x15stat_value_aggregates\
    \x18\x01\x20\x03(\x0b2\x20.clarifai.api.StatValueAggregateR\x13statValue\
    Aggregates\x12b\n\x1astat_value_aggregate_query\x18\x02\x20\x01(\x0b2%.c\
    larifai.api.StatValueAggregateQueryR\x17statValueAggregateQuery\"\x97\
    \x01\n\x12StatValueAggregate\x12.\n\x04time\x18\x01\x20\x01(\x0b2\x1a.go\
    ogle.protobuf.TimestampR\x04time\x12'\n\x0faggregate_value\x18\x02\x20\
    \x01(\x02R\x0eaggregateValue\x12\x14\n\x05count\x18\x03\x20\x01(\x04R\
    \x05count\x12\x12\n\x04tags\x18\x04\x20\x03(\tR\x04tags\"\xd9\x02\n\x17S\
    tatValueAggregateQuery\x12\x12\n\x04tags\x18\x01\x20\x03(\tR\x04tags\x12\
    \x1d\n\ntag_groups\x18\x02\x20\x03(\tR\ttagGroups\x12M\n\x13stat_value_a\
    gg_type\x18\x03\x20\x01(\x0e2\x1e.clarifai.api.StatValueAggTypeR\x10stat\
    ValueAggType\x12J\n\x12stat_time_agg_type\x18\x04\x20\x01(\x0e2\x1d.clar\
    ifai.api.StatTimeAggTypeR\x0fstatTimeAggType\x129\n\nstart_time\x18\x05\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tstartTime\x125\n\x08end_t\
    ime\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07endTime\"r\n\
    \x17PCAProjectionComparator\x12-\n\x12distance_threshold\x18\x01\x20\x01\
    (\x02R\x11distanceThreshold\x12(\n\x10model_version_id\x18\x02\x20\x01(\
    \tR\x0emodelVersionId\"g\n\x1bDuplicateAnnotationsResults\x12%\n\x0edupl\
    icate_cfid\x18\x01\x20\x03(\tR\rduplicateCfid\x12!\n\x0cunique_count\x18\
    \x02\x20\x01(\x05R\x0buniqueCount\"\x91\x01\n\nVisibility\x12=\n\x08gett\
    able\x18\x01\x20\x01(\x0e2!.clarifai.api.Visibility.GettableR\x08gettabl\
    e\"D\n\x08Gettable\x12\x16\n\x12UNKNOWN_VISIBILITY\x10\0\x12\x0b\n\x07PR\
    IVATE\x10\n\x12\x07\n\x03ORG\x10\x1e\x12\n\n\x06PUBLIC\x102\"|\n\x0eTren\
    dingMetric\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\x06userId\x12\x15\n\
    \x06app_id\x18\x02\x20\x01(\tR\x05appId\x12\x1b\n\tobject_id\x18\x03\x20\
    \x01(\tR\x08objectId\x12\x1d\n\nview_count\x18\x04\x20\x01(\x04R\tviewCo\
    unt\"-\n\x07FullTag\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"z\n\x0bTimeSegment\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\tR\x02id\x12&\n\x04data\x18\x02\x20\x01(\x0b2\x12.cl\
    arifai.api.DataR\x04data\x123\n\ttime_info\x18\x03\x20\x01(\x0b2\x16.cla\
    rifai.api.TimeInfoR\x08timeInfo\"o\n\x08TimeInfo\x12\x1d\n\nnum_frames\
    \x18\x01\x20\x01(\rR\tnumFrames\x12\x1d\n\nbegin_time\x18\x04\x20\x01(\
    \x02R\tbeginTime\x12\x19\n\x08end_time\x18\x05\x20\x01(\x02R\x07endTimeJ\
    \x04\x08\x02\x10\x03J\x04\x08\x03\x10\x04\",\n\x0bDatasetStar\x12\x1d\n\
    \ndataset_id\x18\x01\x20\x01(\tR\tdatasetId\")\n\nModuleStar\x12\x1b\n\t\
    module_id\x18\x01\x20\x01(\tR\x08moduleId\"\xcb\x04\n\x06Module\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x20\n\x0bdescription\x18\x03\x20\
    \x01(\tR\x0bdescription\x129\n\ncreated_at\x18\x04\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x05\x20\x01\
    (\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x128\n\nvisibility\x18\
    \x07\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibility\x123\n\x08me\
    tadata\x18\x08\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\x12\
    \x17\n\x07user_id\x18\t\x20\x01(\tR\x06userId\x12\x15\n\x06app_id\x18\n\
    \x20\x01(\tR\x05appId\x12B\n\x0emodule_version\x18\x0b\x20\x01(\x0b2\x1b\
    .clarifai.api.ModuleVersionR\rmoduleVersion\x12\x1d\n\nis_starred\x18\
    \x0c\x20\x01(\x08R\tisStarred\x12\x1d\n\nstar_count\x18\r\x20\x01(\x05R\
    \tstarCount\x12E\n\x0fbookmark_origin\x18\x0e\x20\x01(\x0b2\x1c.clarifai\
    .api.BookmarkOriginR\x0ebookmarkOrigin\x12)\n\x05image\x18\x0f\x20\x01(\
    \x0b2\x13.clarifai.api.ImageR\x05imageJ\x04\x08\x02\x10\x03\"\xf2\x05\n\
    \rModuleVersion\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1b\n\tmod\
    ule_id\x18\x02\x20\x01(\tR\x08moduleId\x12\x15\n\x06app_id\x18\x03\x20\
    \x01(\tR\x05appId\x12\x17\n\x07user_id\x18\x04\x20\x01(\tR\x06userId\x12\
    \x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12\x14\n\x05no\
    tes\x18\x07\x20\x01(\tR\x05notes\x129\n\ncreated_at\x18\x08\x20\x01(\x0b\
    2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\t\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x12$\n\x0egit_\
    commit_url\x18\n\x20\x01(\tR\x0cgitCommitUrl\x12D\n\nmodule_nav\x18\x0b\
    \x20\x01(\x0b2%.clarifai.api.ModuleVersion.ModuleNavR\tmoduleNav\x12\x1a\
    \n\x08approved\x18\x0c\x20\x01(\x08R\x08approved\x128\n\nvisibility\x18\
    \r\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibility\x123\n\x08meta\
    data\x18\x0e\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\x1ab\
    \n\x0cModuleSubNav\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\
    \x1b\n\tquery_key\x18\x02\x20\x01(\tR\x08queryKey\x12\x1f\n\x0bquery_val\
    ue\x18\x03\x20\x01(\tR\nqueryValue\x1as\n\tModuleNav\x12\x14\n\x05title\
    \x18\x01\x20\x01(\tR\x05title\x12P\n\x0fmodule_sub_navs\x18\x02\x20\x03(\
    \x0b2(.clarifai.api.ModuleVersion.ModuleSubNavR\rmoduleSubNavsJ\x04\x08\
    \x05\x10\x06\"\x84\x03\n\x16InstalledModuleVersion\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12B\n\x0emodule_version\x18\x02\x20\x01(\x0b2\
    \x1b.clarifai.api.ModuleVersionR\rmoduleVersion\x12\x15\n\x06app_id\x18\
    \x03\x20\x01(\tR\x05appId\x12\x17\n\x07user_id\x18\x04\x20\x01(\tR\x06us\
    erId\x129\n\ncreated_at\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x06\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\nmodifiedAt\x12\x1d\n\ndeploy_url\x18\x07\x20\x01(\tR\
    \tdeployUrl\x128\n\nvisibility\x18\x08\x20\x01(\x0b2\x18.clarifai.api.Vi\
    sibilityR\nvisibility\x12\x15\n\x06key_id\x18\t\x20\x01(\tR\x05keyId\"\
    \xa0\x04\n\rBulkOperation\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x125\
    \n\tinput_ids\x18\x02\x20\x01(\x0b2\x16.clarifai.api.InputIDsH\0R\x08inp\
    utIds\x12.\n\x06search\x18\n\x20\x01(\x0b2\x14.clarifai.api.SearchH\0R\
    \x06search\x121\n\x07dataset\x18\x0b\x20\x01(\x0b2\x15.clarifai.api.Data\
    setH\0R\x07dataset\x125\n\toperation\x18\x03\x20\x01(\x0b2\x17.clarifai.\
    api.OperationR\toperation\x12\x15\n\x06app_id\x18\x04\x20\x01(\tR\x05app\
    Id\x123\n\x06status\x18\x05\x20\x01(\x0b2\x1b.clarifai.api.status.Status\
    R\x06status\x122\n\x08progress\x18\x06\x20\x01(\x0b2\x16.clarifai.api.Pr\
    ogressR\x08progress\x12\x1d\n\ncreated_by\x18\x07\x20\x01(\tR\tcreatedBy\
    \x129\n\ncreated_at\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \tcreatedAt\x12D\n\x10last_modified_at\x18\t\x20\x01(\x0b2\x1a.google.pr\
    otobuf.TimestampR\x0elastModifiedAtB\x0e\n\x0cinput_source\"'\n\x08Input\
    IDs\x12\x1b\n\tinput_ids\x18\x01\x20\x03(\tR\x08inputIds\"T\n\x08Progres\
    s\x12\x1c\n\tprocessed\x18\x01\x20\x01(\rR\tprocessed\x12*\n\x11last_pro\
    cessed_id\x18\x02\x20\x01(\tR\x0flastProcessedId\"\x91\x05\n\tOperation\
    \x12>\n\x0cadd_concepts\x18\x01\x20\x01(\x0b2\x19.clarifai.api.AddConcep\
    tsH\0R\x0baddConcepts\x12G\n\x0fdelete_concepts\x18\x02\x20\x01(\x0b2\
    \x1c.clarifai.api.DeleteConceptsH\0R\x0edeleteConcepts\x12>\n\x0cadd_met\
    adata\x18\x03\x20\x01(\x0b2\x19.clarifai.api.AddMetadataH\0R\x0baddMetad\
    ata\x12G\n\x0fdelete_metadata\x18\x04\x20\x01(\x0b2\x1c.clarifai.api.Del\
    eteMetadataH\0R\x0edeleteMetadata\x12A\n\roverwrite_geo\x18\x05\x20\x01(\
    \x0b2\x1a.clarifai.api.OverwriteGeoH\0R\x0coverwriteGeo\x128\n\ndelete_g\
    eo\x18\x06\x20\x01(\x0b2\x17.clarifai.api.DeleteGeoH\0R\tdeleteGeo\x12Q\
    \n\x13delete_from_dataset\x18\x07\x20\x01(\x0b2\x1f.clarifai.api.DeleteF\
    romDatasetH\0R\x11deleteFromDataset\x12B\n\x0eadd_to_dataset\x18\x08\x20\
    \x01(\x0b2\x1a.clarifai.api.AddToDatasetH\0R\x0caddToDataset\x12Q\n\x13s\
    plit_into_datasets\x18\t\x20\x01(\x0b2\x1f.clarifai.api.SplitIntoDataset\
    sH\0R\x11splitIntoDatasetsB\x0b\n\toperation\"@\n\x0bAddConcepts\x121\n\
    \x08concepts\x18\x01\x20\x03(\x0b2\x15.clarifai.api.ConceptR\x08concepts\
    \"^\n\x0eDeleteConcepts\x121\n\x08concepts\x18\x01\x20\x03(\x0b2\x15.cla\
    rifai.api.ConceptR\x08concepts\x12\x19\n\x08user_ids\x18\x02\x20\x03(\tR\
    \x07userIds\"B\n\x0bAddMetadata\x123\n\x08metadata\x18\x01\x20\x01(\x0b2\
    \x17.google.protobuf.StructR\x08metadata\"E\n\x0eDeleteMetadata\x123\n\
    \x08metadata\x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metada\
    ta\"3\n\x0cOverwriteGeo\x12#\n\x03geo\x18\x01\x20\x01(\x0b2\x11.clarifai\
    .api.GeoR\x03geo\"\x0b\n\tDeleteGeo\"-\n\x0cAddToDataset\x12\x1d\n\ndata\
    set_id\x18\x01\x20\x01(\tR\tdatasetId\"2\n\x11DeleteFromDataset\x12\x1d\
    \n\ndataset_id\x18\x01\x20\x01(\tR\tdatasetId\"\xe2\x01\n\x11SplitIntoDa\
    tasets\x12A\n\x0edataset_splits\x18\x01\x20\x03(\x0b2\x1a.clarifai.api.D\
    atasetSplitR\rdatasetSplits\x12J\n\x06method\x18\x02\x20\x01(\x0e22.clar\
    ifai.api.SplitIntoDatasets.DatasetSplitMethodR\x06method\">\n\x12Dataset\
    SplitMethod\x12\x0b\n\x07NOT_SET\x10\0\x12\x1b\n\x17RANDOM_PERCENTAGE_SP\
    LIT\x10\x01\"p\n\x0cDatasetSplit\x12/\n\x07dataset\x18\x01\x20\x01(\x0b2\
    \x15.clarifai.api.DatasetR\x07dataset\x12\x20\n\npercentage\x18\x02\x20\
    \x01(\rH\0R\npercentageB\r\n\x0bmethod_info\"\xd6\x03\n\x0cInputsAddJob\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\"\n\rcall_back_url\x18\
    \x03\x20\x01(\tR\x0bcallBackUrl\x12\x17\n\x07app_pat\x18\x04\x20\x01(\tR\
    \x06appPat\x12>\n\x08progress\x18\x07\x20\x01(\x0b2\".clarifai.api.Input\
    sAddJobProgressR\x08progress\x129\n\ncreated_at\x18\x08\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\t\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x12J\n\x0fextr\
    action_jobs\x18\n\x20\x03(\x0b2!.clarifai.api.InputsExtractionJobR\x0eex\
    tractionJobs\x12.\n\x07uploads\x18\x0b\x20\x03(\x0b2\x14.clarifai.api.Up\
    loadR\x07uploads\x123\n\x06status\x18\x0c\x20\x01(\x0b2\x1b.clarifai.api\
    .status.StatusR\x06statusJ\x04\x08\x02\x10\x03J\x04\x08\x05\x10\x06J\x04\
    \x08\x06\x10\x07\"\xaf\x01\n\x14InputsAddJobProgress\x12#\n\rpending_cou\
    nt\x18\x01\x20\x01(\x04R\x0cpendingCount\x12*\n\x11in_progress_count\x18\
    \x02\x20\x01(\x04R\x0finProgressCount\x12#\n\rsuccess_count\x18\x03\x20\
    \x01(\x04R\x0csuccessCount\x12!\n\x0cfailed_count\x18\x04\x20\x01(\x04R\
    \x0bfailedCount\"\xeb\x02\n\x06Upload\x12\x0e\n\x02id\x18\x01\x20\x01(\t\
    R\x02id\x129\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Tim\
    estampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x03\x20\x01(\x0b2\x1a.googl\
    e.protobuf.TimestampR\nmodifiedAt\x129\n\nexpires_at\x18\x04\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\texpiresAt\x123\n\x06status\x18\x05\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12!\n\x0cconte\
    nt_name\x18\x08\x20\x01(\tR\x0bcontentName\x12%\n\x0econtent_length\x18\
    \x06\x20\x01(\x04R\rcontentLength\x12\x1f\n\x0bcontent_url\x18\x07\x20\
    \x01(\tR\ncontentUrl\"i\n\x11UploadContentPart\x12\x1f\n\x0brange_start\
    \x18\x01\x20\x01(\x04R\nrangeStart\x12\x1f\n\x0bpart_number\x18\x02\x20\
    \x01(\x03R\npartNumber\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\
    ~\n\x19CustomCodeOperatorRequest\x12+\n\x06inputs\x18\x01\x20\x03(\x0b2\
    \x13.clarifai.api.InputR\x06inputs\x124\n\x08metadata\x18\xea\x07\x20\
    \x01(\x0b2\x17.google.protobuf.StructR\x08metadata\"\xd1\x03\n\x13Inputs\
    ExtractionJob\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12\x10\
    \n\x03url\x18\x03\x20\x01(\tR\x03url\x12E\n\x08progress\x18\x04\x20\x01(\
    \x0b2).clarifai.api.InputsExtractionJobProgressR\x08progress\x129\n\ncre\
    ated_at\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\
    \x12;\n\x0bmodified_at\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.Timesta\
    mpR\nmodifiedAt\x12h\n\x1cinput_id_conflict_resolution\x18\x07\x20\x01(\
    \x0e2'.clarifai.api.InputIDConflictResolutionR\x19inputIdConflictResolut\
    ion\x12:\n\x0einput_template\x18\x08\x20\x01(\x0b2\x13.clarifai.api.Inpu\
    tR\rinputTemplate\"\xba\x03\n\x1bInputsExtractionJobProgress\x12,\n\x12a\
    udio_inputs_count\x18\x02\x20\x01(\x04R\x10audioInputsCount\x12,\n\x12im\
    age_inputs_count\x18\x03\x20\x01(\x04R\x10imageInputsCount\x12,\n\x12vid\
    eo_inputs_count\x18\x04\x20\x01(\x04R\x10videoInputsCount\x12*\n\x11text\
    _inputs_count\x18\x05\x20\x01(\x04R\x0ftextInputsCount\x124\n\x16pending\
    _archives_count\x18\x06\x20\x01(\x04R\x14pendingArchivesCount\x12;\n\x1a\
    in_progress_archives_count\x18\x07\x20\x01(\x04R\x17inProgressArchivesCo\
    unt\x128\n\x18completed_archives_count\x18\x08\x20\x01(\x04R\x16complete\
    dArchivesCount\x122\n\x15failed_archives_count\x18\t\x20\x01(\x04R\x13fa\
    iledArchivesCountJ\x04\x08\x01\x10\x02\"\x92\x02\n\x10InputsDataSource\
    \x12)\n\x11inputs_add_job_id\x18\x01\x20\x01(\tR\x0einputsAddJobId\x12-\
    \n\x03url\x18\x02\x20\x01(\x0b2\x1b.clarifai.api.DataSourceURLR\x03url\
    \x12h\n\x1cinput_id_conflict_resolution\x18\x03\x20\x01(\x0e2'.clarifai.\
    api.InputIDConflictResolutionR\x19inputIdConflictResolution\x12:\n\x0ein\
    put_template\x18\x04\x20\x01(\x0b2\x13.clarifai.api.InputR\rinputTemplat\
    e\"h\n\rDataSourceURL\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12E\n\
    \x0bcredentials\x18\x02\x20\x01(\x0b2#.clarifai.api.DataSourceCredential\
    sR\x0bcredentials\"\xca\x01\n\x15DataSourceCredentials\x123\n\x08s3_cred\
    s\x18\x01\x20\x01(\x0b2\x16.clarifai.api.AWSCredsH\0R\x07s3Creds\x12\x1d\
    \n\tgcp_creds\x18\x02\x20\x01(\x0cH\0R\x08gcpCreds\x12H\n\x10azure_blob_\
    creds\x18\x04\x20\x01(\x0b2\x1c.clarifai.api.AzureBlobCredsH\0R\x0eazure\
    BlobCredsB\r\n\x0bcredentialsJ\x04\x08\x03\x10\x04\"f\n\x08AWSCreds\x12\
    \x16\n\x06region\x18\x02\x20\x01(\tR\x06region\x12\x0e\n\x02id\x18\x03\
    \x20\x01(\tR\x02id\x12\x16\n\x06secret\x18\x04\x20\x01(\tR\x06secret\x12\
    \x14\n\x05token\x18\x05\x20\x01(\tR\x05tokenJ\x04\x08\x01\x10\x02\"T\n\
    \x0eAzureBlobCreds\x12!\n\x0caccount_name\x18\x01\x20\x01(\tR\x0baccount\
    Name\x12\x1f\n\x0baccount_key\x18\x02\x20\x01(\tR\naccountKey\"\xa6\x02\
    \n\x0cInputsUpload\x12)\n\x11inputs_add_job_id\x18\x01\x20\x01(\tR\x0ein\
    putsAddJobId\x12\x17\n\x07app_pat\x18\x02\x20\x01(\tR\x06appPat\x12,\n\
    \x06upload\x18\x03\x20\x01(\x0b2\x14.clarifai.api.UploadR\x06upload\x12h\
    \n\x1cinput_id_conflict_resolution\x18\x04\x20\x01(\x0e2'.clarifai.api.I\
    nputIDConflictResolutionR\x19inputIdConflictResolution\x12:\n\x0einput_t\
    emplate\x18\x05\x20\x01(\x0b2\x13.clarifai.api.InputR\rinputTemplate\"\
    \xef\x01\n\x0eBookmarkOrigin\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x15\n\x06app_id\x18\x02\x20\x01(\tR\x05appId\x12\x17\n\x07user_id\
    \x18\x03\x20\x01(\tR\x06userId\x12N\n\rresource_type\x18\x04\x20\x01(\
    \x0e2).clarifai.api.BookmarkOrigin.BookmarkTypeR\x0cresourceType\"M\n\
    \x0cBookmarkType\x12\x0b\n\x07unknown\x10\0\x12\t\n\x05model\x10\x01\x12\
    \x0c\n\x08workflow\x10\x02\x12\x0b\n\x07dataset\x10\x03\x12\n\n\x06modul\
    e\x10\x04\"\xfb\x03\n\x06Runner\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02i\
    d\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x129\n\ncr\
    eated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\
    \x12;\n\x0bmodified_at\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.Timesta\
    mpR\nmodifiedAt\x123\n\x08metadata\x18\x05\x20\x01(\x0b2\x17.google.prot\
    obuf.StructR\x08metadata\x12\x17\n\x07user_id\x18\x06\x20\x01(\tR\x06use\
    rId\x12\x1a\n\x06labels\x18\x07\x20\x03(\tR\x06labelsB\x02\x18\x01\x12+\
    \n\x05model\x18\t\x20\x01(\x0b2\x13.clarifai.api.ModelH\0R\x05model\x124\
    \n\x08workflow\x18\n\x20\x01(\x0b2\x16.clarifai.api.WorkflowH\0R\x08work\
    flow\x122\n\x08nodepool\x18\x0c\x20\x01(\x0b2\x16.clarifai.api.NodepoolR\
    \x08nodepool\x12<\n\x0ccompute_info\x18\r\x20\x01(\x0b2\x19.clarifai.api\
    .ComputeInfoR\x0bcomputeInfoB\x08\n\x06object\"\xfa\x02\n\x08Nodepool\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x17\n\x07user_id\x18\x02\
    \x20\x01(\tR\x06userId\x12<\n\x0ccloud_region\x18\x03\x20\x01(\x0b2\x19.\
    clarifai.api.CloudRegionR\x0bcloudRegion\x12J\n\x0ecapacity_types\x18\
    \x04\x20\x03(\x0e2#.clarifai.api.Nodepool.CapacityTypeR\rcapacityTypes\
    \x12%\n\x0einstance_types\x18\x08\x20\x03(\tR\rinstanceTypes\x12#\n\rmin\
    _instances\x18\t\x20\x01(\rR\x0cminInstances\x12#\n\rmax_instances\x18\n\
    \x20\x01(\rR\x0cmaxInstances\"J\n\x0cCapacityType\x12\x18\n\x14UKNOWN_CA\
    PACITY_TYPE\x10\0\x12\x11\n\rONDEMAND_TYPE\x10\x01\x12\r\n\tSPOT_TYPE\
    \x10\x02\"\xc1\x01\n\x0bCloudRegion\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x125\n\x05cloud\x18\x03\x20\x01(\x0e2\x1f.clarifai.api.CloudRegio\
    n.CloudR\x05cloud\x12\x16\n\x06region\x18\x04\x20\x01(\tR\x06region\"S\n\
    \x05Cloud\x12\x10\n\x0cUNKOWN_CLOUD\x10\0\x12\x0f\n\x0bSELF_HOSTED\x10\
    \x01\x12\x07\n\x03AWS\x10\x02\x12\x07\n\x03GCP\x10\x03\x12\t\n\x05AZURE\
    \x10\x04\x12\n\n\x06LAMBDA\x10\x05\"\xcc\x01\n\x0bComputeInfo\x12\x19\n\
    \x08num_cpus\x18\x01\x20\x01(\rR\x07numCpus\x12\x1d\n\ncpu_memory\x18\
    \x02\x20\x01(\tR\tcpuMemory\x12)\n\x10num_accelerators\x18\x03\x20\x01(\
    \rR\x0fnumAccelerators\x12-\n\x12accelerator_memory\x18\x04\x20\x01(\tR\
    \x11acceleratorMemory\x12)\n\x10accelerator_type\x18\x05\x20\x03(\tR\x0f\
    acceleratorType\"\xa4\x02\n\x0fAutoscaleConfig\x12!\n\x0cmin_replicas\
    \x18\x01\x20\x01(\rR\x0bminReplicas\x12!\n\x0cmax_replicas\x18\x02\x20\
    \x01(\rR\x0bmaxReplicas\x126\n\x17traffic_history_seconds\x18\x03\x20\
    \x01(\rR\x15trafficHistorySeconds\x127\n\x18scale_down_delay_seconds\x18\
    \x04\x20\x01(\rR\x15scaleDownDelaySeconds\x123\n\x16scale_up_delay_secon\
    ds\x18\x05\x20\x01(\rR\x13scaleUpDelaySeconds\x12%\n\x0eenable_packing\
    \x18\x06\x20\x01(\x08R\renablePacking\"\xa4\x04\n\nDeployment\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12\x17\n\x07user_id\x18\x02\x20\x01(\t\
    R\x06userId\x12H\n\x10autoscale_config\x18\x03\x20\x01(\x0b2\x1d.clarifa\
    i.api.AutoscaleConfigR\x0fautoscaleConfig\x124\n\tnodepools\x18\x04\x20\
    \x03(\x0b2\x16.clarifai.api.NodepoolR\tnodepools\x12+\n\x05model\x18\x05\
    \x20\x01(\x0b2\x13.clarifai.api.ModelH\0R\x05model\x124\n\x08workflow\
    \x18\x06\x20\x01(\x0b2\x16.clarifai.api.WorkflowH\0R\x08workflow\x12V\n\
    \x11scheduling_choice\x18\x07\x20\x01(\x0e2).clarifai.api.Deployment.Sch\
    edulingChoiceR\x10schedulingChoice\"\xa7\x01\n\x10SchedulingChoice\x12\
    \x1d\n\x19UNKNOWN_SCHEDULING_CHOICE\x10\0\x12\x08\n\x04FAIL\x10\x01\x12\
    \n\n\x06RANDOM\x10\x02\x12\t\n\x05PRICE\x10\x03\x12\x0f\n\x0bPERFORMANCE\
    \x10\x04\x12\x0b\n\x07NETWORK\x10\x05\x12\x0f\n\x0bUTILIZATION\x10\x06\
    \x12\x0f\n\x0bPREFER_SPOT\x10\x07\x12\x13\n\x0fPREFER_ONDEMAND\x10\x08B\
    \x08\n\x06object\"\xac\x01\n\x0eRunnerSelector\x122\n\x08nodepool\x18\
    \x01\x20\x01(\x0b2\x16.clarifai.api.NodepoolR\x08nodepool\x12,\n\x06runn\
    er\x18\x02\x20\x01(\x0b2\x14.clarifai.api.RunnerR\x06runner\x128\n\ndepl\
    oyment\x18\x03\x20\x01(\x0b2\x18.clarifai.api.DeploymentR\ndeployment\"\
    \x93\x01\n\x0eProcessingInfo\x12L\n\x12runner_method_type\x18\x01\x20\
    \x01(\x0e2\x1e.clarifai.api.RunnerMethodTypeR\x10runnerMethodType\x123\n\
    \x06status\x18\x02\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us*^\n\x14WorkflowModelUseCase\x12#\n\x1fWORKFLOW_MODEL_USE_CASE_NOT_SET\
    \x10\0\x12\x12\n\x0eCLASSIFICATION\x10\x01\x12\r\n\tDETECTION\x10\x02*\
    \x90\x01\n\x1bDatasetVersionRequestOrigin\x12*\n&DATASET_VERSION_REQUEST\
    _ORIGIN_NOT_SET\x10\0\x12\n\n\x06MANUAL\x10\x01\x12\x0c\n\x08TRAINING\
    \x10\x02\x12\x15\n\x11EVAL_GROUND_TRUTH\x10\x03\x12\x14\n\x10EVAL_PREDIC\
    TIONS\x10\x04*\xf9\x01\n\x1eDatasetVersionMetricsGroupType\x12.\n*DATASE\
    T_VERSION_METRICS_GROUP_TYPE_NOT_SET\x10\0\x12\x0e\n\nINPUT_TYPE\x10\x02\
    \x12\x0e\n\nCONCEPT_ID\x10\n\x12\x12\n\x0eCONCEPTS_COUNT\x10\x0b\x12\x18\
    \n\x14BOUNDING_BOXES_COUNT\x10\x14\x12\x12\n\x0ePOLYGONS_COUNT\x10\x15\
    \x12\x10\n\x0cPOINTS_COUNT\x10\x16\x12\x0f\n\x0bMASKS_COUNT\x10\x17\x12\
    \x10\n\x0cPIXELS_COUNT\x10\x1e\x12\x10\n\x0cASPECT_RATIO\x10\x1f*\x85\
    \x01\n\x1aDatasetVersionExportFormat\x12)\n%DATASET_VERSION_EXPORT_FORMA\
    T_NOT_SET\x10\0\x12\x1a\n\x16CLARIFAI_DATA_PROTOBUF\x10\x01\x12\x16\n\
    \x12CLARIFAI_DATA_JSON\x10\x03\x12\x08\n\x04COCO\x10\x02*H\n\x10Expirati\
    onAction\x12\x1d\n\x19EXPIRATION_ACTION_NOT_SET\x10\0\x12\t\n\x05DELAY\
    \x10\x01\x12\n\n\x06EXPIRY\x10\x02*M\n\x0cLicenseScope\x12\x19\n\x15LICE\
    NSE_SCOPE_NOT_SET\x10\0\x12\x0b\n\x07PREDICT\x10\x01\x12\t\n\x05TRAIN\
    \x10\x02\x12\n\n\x06SEARCH\x10\x03*P\n\x08DataType\x12\r\n\tUNDEFINED\
    \x10\0\x12\n\n\x06STRING\x10\x01\x12\t\n\x05UINT8\x10\x02\x12\t\n\x05INT\
    32\x10\x03\x12\t\n\x05INT64\x10\x04\x12\x08\n\x04FP32\x10\x05*\x8f\x01\n\
    \x0fValueComparator\x12\x1d\n\x19CONCEPT_THRESHOLD_NOT_SET\x10\0\x12\x10\
    \n\x0cGREATER_THAN\x10\x01\x12\x19\n\x15GREATER_THAN_OR_EQUAL\x10\x02\
    \x12\r\n\tLESS_THAN\x10\x03\x12\x16\n\x12LESS_THAN_OR_EQUAL\x10\x04\x12\
    \t\n\x05EQUAL\x10\x05*\x81\x01\n\x0eEvaluationType\x12\r\n\tUndefined\
    \x10\0\x12\x12\n\x0eClassification\x10\x01\x12\r\n\tDetection\x10\x02\
    \x12\x10\n\x0cSegmentation\x10\x03\x12\x0e\n\nClustering\x10\x04\x12\x0b\
    \n\x07Tracker\x10\x05\x12\x0e\n\nGeneration\x10\x06*f\n\x0cAPIEventType\
    \x12\x1a\n\x16API_EVENT_TYPE_NOT_SET\x10\0\x12\x13\n\x0fON_PREM_PREDICT\
    \x10\x01\x12\x11\n\rON_PREM_TRAIN\x10\x02\x12\x12\n\x0eON_PREM_SEARCH\
    \x10\x03*<\n\x11UsageIntervalType\x12\t\n\x05undef\x10\0\x12\x07\n\x03da\
    y\x10\x01\x12\t\n\x05month\x10\x02\x12\x08\n\x04year\x10\x03*}\n\x12Anno\
    tationDataType\x12\x20\n\x1cANNOTATION_DATA_TYPE_NOT_SET\x10\0\x12\x07\n\
    \x03TAG\x10\x01\x12\x10\n\x0cBOUNDING_BOX\x10\x02\x12\x0b\n\x07POLYGON\
    \x10\x04\x12\t\n\x05POINT\x10\x08\x12\x08\n\x04SPAN\x10\x10\x12\x08\n\
    \x04MASK\x10\x20*\x1d\n\x08RoleType\x12\x08\n\x04TEAM\x10\0\x12\x07\n\
    \x03ORG\x10\x01*$\n\x10StatValueAggType\x12\x07\n\x03SUM\x10\0\x12\x07\n\
    \x03AVG\x10\x01*`\n\x0fStatTimeAggType\x12\x0f\n\x0bNO_TIME_AGG\x10\0\
    \x12\x08\n\x04YEAR\x10\x01\x12\t\n\x05MONTH\x10\x02\x12\x08\n\x04WEEK\
    \x10\x03\x12\x07\n\x03DAY\x10\x04\x12\x08\n\x04HOUR\x10\x05\x12\n\n\x06M\
    INUTE\x10\x06*b\n\x13ValidationErrorType\x12!\n\x1dVALIDATION_ERROR_TYPE\
    _NOT_SET\x10\0\x12\x0e\n\nRESTRICTED\x10\x01\x12\x0c\n\x08DATABASE\x10\
    \x02\x12\n\n\x06FORMAT\x10\x03*[\n\x19InputIDConflictResolution\x12(\n$I\
    NPUT_ID_CONFLICT_RESOLUTION_NOT_SET\x10\0\x12\x08\n\x04SKIP\x10\x01\x12\
    \n\n\x06SUFFIX\x10\x02*s\n\x10RunnerMethodType\x12\x0b\n\x07UNKNOWN\x10\
    \0\x12\x0f\n\x0bUNARY_UNARY\x10\x01\x12\x13\n\x0fUNARY_STREAMING\x10\x02\
    \x12\x13\n\x0fSTREAMING_UNARY\x10\x03\x12\x17\n\x13STREAMING_STREAMING\
    \x10\x04BY\n\x15com.clarifai.grpc.apiP\x01Z7github.com/Clarifai/clarifai\
    -go-grpc/proto/clarifai/api\xa2\x02\x04CAIPJ\xaf\xc4\x0c\n\x07\x12\x05\0\
    \0\xed#\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\x02\x03\0\x12\x03\x02\
    \00\n\t\n\x02\x03\x01\x12\x03\x03\05\n\t\n\x02\x03\x02\x12\x03\x04\03\n\
    \t\n\x02\x03\x03\x12\x03\x05\0/\n\t\n\x02\x03\x04\x12\x03\x06\02\n\t\n\
    \x02\x03\x05\x12\x03\x08\0&\n\t\n\x02\x03\x06\x12\x03\t\0)\n\t\n\x02\x03\
    \x07\x12\x03\n\0(\n\x08\n\x01\x02\x12\x03\x0c\0\x15\n\x08\n\x01\x08\x12\
    \x03\x0e\0N\n\t\n\x02\x08\x0b\x12\x03\x0e\0N\n\x08\n\x01\x08\x12\x03\x0f\
    \0\"\n\t\n\x02\x08\n\x12\x03\x0f\0\"\n\x08\n\x01\x08\x12\x03\x10\0.\n\t\
    \n\x02\x08\x01\x12\x03\x10\0.\n\x08\n\x01\x08\x12\x03\x11\0\"\n\t\n\x02\
    \x08$\x12\x03\x11\0\"\n2\n\x02\x04\0\x12\x04\x15\0H\x01\x1a&\x20Annotati\
    on\x20of\x20an\x20asset\x20with\x20metadata\n\n\n\n\x03\x04\0\x01\x12\
    \x03\x15\x08\x12\n\n\n\x03\x04\0\t\x12\x03\x16\x02\x1b\n\x0b\n\x04\x04\0\
    \t\0\x12\x03\x16\x0b\x0c\n\x0c\n\x05\x04\0\t\0\x01\x12\x03\x16\x0b\x0c\n\
    \x0c\n\x05\x04\0\t\0\x02\x12\x03\x16\x0b\x0c\n\x0b\n\x04\x04\0\t\x01\x12\
    \x03\x16\x0e\x0f\n\x0c\n\x05\x04\0\t\x01\x01\x12\x03\x16\x0e\x0f\n\x0c\n\
    \x05\x04\0\t\x01\x02\x12\x03\x16\x0e\x0f\n\x0b\n\x04\x04\0\t\x02\x12\x03\
    \x16\x11\x12\n\x0c\n\x05\x04\0\t\x02\x01\x12\x03\x16\x11\x12\n\x0c\n\x05\
    \x04\0\t\x02\x02\x12\x03\x16\x11\x12\n\x0b\n\x04\x04\0\t\x03\x12\x03\x16\
    \x14\x16\n\x0c\n\x05\x04\0\t\x03\x01\x12\x03\x16\x14\x16\n\x0c\n\x05\x04\
    \0\t\x03\x02\x12\x03\x16\x14\x16\n\x0b\n\x04\x04\0\t\x04\x12\x03\x16\x18\
    \x1a\n\x0c\n\x05\x04\0\t\x04\x01\x12\x03\x16\x18\x1a\n\x0c\n\x05\x04\0\t\
    \x04\x02\x12\x03\x16\x18\x1a\n(\n\x04\x04\0\x02\0\x12\x03\x19\x02\x10\
    \x1a\x1b\x20The\x20ID\x20for\x20the\x20annotation\n\n\x0c\n\x05\x04\0\
    \x02\0\x05\x12\x03\x19\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x19\t\
    \x0b\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x19\x0e\x0f\n9\n\x04\x04\0\x02\
    \x01\x12\x03\x1c\x02\x16\x1a,\x20ID\x20of\x20the\x20input\x20this\x20ann\
    otation\x20is\x20tied\x20to\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x1c\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x1c\t\x11\n\x0c\n\x05\x04\
    \0\x02\x01\x03\x12\x03\x1c\x14\x15\n8\n\x04\x04\0\x02\x02\x12\x03\x1f\
    \x02\x10\x1a+\x20The\x20data\x20passed\x20along\x20in\x20this\x20annotat\
    ion.\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x1f\x02\x06\n\x0c\n\x05\x04\
    \0\x02\x02\x01\x12\x03\x1f\x07\x0b\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\
    \x1f\x0e\x0f\nD\n\x04\x04\0\x02\x03\x12\x03\"\x02.\x1a7\x20task_id\x20is\
    \x20deprecated\x20in\x20annotation_info.\x20Use\x20task_id\n\n\x0c\n\x05\
    \x04\0\x02\x03\x06\x12\x03\"\x02\x18\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03\"\x19(\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\"+-\n;\n\x04\x04\0\x02\
    \x04\x12\x03%\x02\x16\x1a.\x20ID\x20of\x20the\x20user\x20this\x20annotat\
    ion\x20is\x20created\x20by\n\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03%\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03%\t\x10\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03%\x13\x15\nD\n\x04\x04\0\x02\x05\x12\x03'\x02\x1f\x1a7\
    \x20ID\x20of\x20the\x20model\x20version\x20this\x20annotation\x20is\x20c\
    reated\x20by\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03'\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x05\x01\x12\x03'\t\x19\n\x0c\n\x05\x04\0\x02\x05\x03\x12\
    \x03'\x1c\x1e\n\x1a\n\x04\x04\0\x02\x06\x12\x03*\x029\x1a\r\x20DEPRECATE\
    D.\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03*\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x06\x01\x12\x03*\t\x1f\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03*\"$\n\
    \x0c\n\x05\x04\0\x02\x06\x08\x12\x03*%8\n\r\n\x06\x04\0\x02\x06\x08\x03\
    \x12\x03*&7\n\x20\n\x04\x04\0\x02\x07\x12\x03-\x02(\x1a\x13\x20Annotatio\
    n\x20Status\n\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03-\x02\x1c\n\x0c\n\x05\
    \x04\0\x02\x07\x01\x12\x03-\x1d#\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03-&\
    '\n\x84\x02\n\x04\x04\0\x02\x08\x12\x034\x02+\x1a\xf6\x01\x20When\x20the\
    \x20annotation\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20time\
    stamp\n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\
    \x20format:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20\
    expect\x20results\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\
    \x20\"2017-04-11T21:50:50.223962Z\"\n\n\x0c\n\x05\x04\0\x02\x08\x06\x12\
    \x034\x02\x1b\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x034\x1c&\n\x0c\n\x05\
    \x04\0\x02\x08\x03\x12\x034)*\n0\n\x04\x04\0\x02\t\x12\x037\x02,\x1a#\
    \x20When\x20the\x20annotation\x20was\x20modified.\n\n\x0c\n\x05\x04\0\
    \x02\t\x06\x12\x037\x02\x1b\n\x0c\n\x05\x04\0\x02\t\x01\x12\x037\x1c'\n\
    \x0c\n\x05\x04\0\x02\t\x03\x12\x037*+\nL\n\x04\x04\0\x02\n\x12\x03;\x02(\
    \x1a?\x20Whether\x20or\x20not\x20this\x20annotation\x20is\x20trusted\n\
    \x20Will\x20be\x20deprecated\n\n\x0c\n\x05\x04\0\x02\n\x05\x12\x03;\x02\
    \x06\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03;\x07\x0e\n\x0c\n\x05\x04\0\x02\
    \n\x03\x12\x03;\x11\x13\n\x0c\n\x05\x04\0\x02\n\x08\x12\x03;\x14'\n\r\n\
    \x06\x04\0\x02\n\x08\x03\x12\x03;\x15&\n2\n\x04\x04\0\x02\x0b\x12\x03>\
    \x02\x18\x1a%\x20Is\x20this\x20the\x20input\x20level\x20annotation.\n\n\
    \x0c\n\x05\x04\0\x02\x0b\x05\x12\x03>\x02\x06\n\x0c\n\x05\x04\0\x02\x0b\
    \x01\x12\x03>\x07\x12\n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03>\x15\x17\n\
    \xa3\x01\n\x04\x04\0\x02\x0c\x12\x03C\x02-\x1a\x95\x01\x20Consensus\x20r\
    eview\x20related\x20information,\x20e.g.\n\x20*\x20annotation\x20group\n\
    \x20*\x20id\x20of\x20annotation\x20parent,\x20in\x20case\x20the\x20annot\
    ation\x20was\x20split\x20from\x20another\x20annotation\n\n\x0c\n\x05\x04\
    \0\x02\x0c\x06\x12\x03C\x02\x18\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03C\
    \x19'\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03C*,\n7\n\x04\x04\0\x02\r\x12\
    \x03E\x02\x16\x1a*\x20The\x20id\x20of\x20the\x20task\x20annotation\x20be\
    longs\x20to\n\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03E\x02\x08\n\x0c\n\x05\
    \x04\0\x02\r\x01\x12\x03E\t\x10\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03E\x13\
    \x15\nG\n\x04\x04\0\x02\x0e\x12\x03G\x02\"\x1a:\x20ID\x20of\x20the\x20wo\
    rkflow\x20version\x20this\x20annotation\x20is\x20created\x20by\n\n\x0c\n\
    \x05\x04\0\x02\x0e\x05\x12\x03G\x02\x08\n\x0c\n\x05\x04\0\x02\x0e\x01\
    \x12\x03G\t\x1c\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x03G\x1f!\n4\n\x02\x04\
    \x01\x12\x04K\0Y\x01\x1a(\x20Worker\x20is\x20the\x20author\x20of\x20an\
    \x20annotation.\n\n\n\n\x03\x04\x01\x01\x12\x03K\x08\x0e\n\x0c\n\x04\x04\
    \x01\x08\0\x12\x04L\x02X\x03\n\x0c\n\x05\x04\x01\x08\0\x01\x12\x03L\x08\
    \x0e\n\xb8\x01\n\x04\x04\x01\x02\0\x12\x03Q\x04\x12\x1a\xaa\x01\x20User\
    \x20is\x20the\x20human\x20that\x20created\x20the\x20annotation.\n\n\x20B\
    y\x20default\x20no\x20real\x20names\x20of\x20users\x20are\x20returned\
    \x20in\x20responses.\x20These\x20can\n\x20be\x20requested\x20with\x20the\
    \x20'names'\x20additional\x20field.\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\
    \x03Q\x04\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03Q\t\r\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03Q\x10\x11\n>\n\x04\x04\x01\x02\x01\x12\x03T\x04\
    \x14\x1a1\x20Model\x20is\x20the\x20model\x20that\x20created\x20the\x20an\
    notation.\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03T\x04\t\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03T\n\x0f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\
    \x03T\x12\x13\nD\n\x04\x04\x01\x02\x02\x12\x03W\x04\x1a\x1a7\x20Workflow\
    \x20is\x20the\x20workflow\x20that\x20created\x20the\x20annotation.\n\n\
    \x0c\n\x05\x04\x01\x02\x02\x06\x12\x03W\x04\x0c\n\x0c\n\x05\x04\x01\x02\
    \x02\x01\x12\x03W\r\x15\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03W\x18\x19\
    \n2\n\x02\x04\x02\x12\x05\\\0\x98\x01\x01\x1a%\x20Application\x20with\
    \x20tasks\x20and\x20datasets\n\n\n\n\x03\x04\x02\x01\x12\x03\\\x08\x0b\n\
    \n\n\x03\x04\x02\t\x12\x03]\x02\x16\n\x0b\n\x04\x04\x02\t\0\x12\x03]\x0b\
    \r\n\x0c\n\x05\x04\x02\t\0\x01\x12\x03]\x0b\r\n\x0c\n\x05\x04\x02\t\0\
    \x02\x12\x03]\x0b\r\n\x0b\n\x04\x04\x02\t\x01\x12\x03]\x0f\x11\n\x0c\n\
    \x05\x04\x02\t\x01\x01\x12\x03]\x0f\x11\n\x0c\n\x05\x04\x02\t\x01\x02\
    \x12\x03]\x0f\x11\n\x0b\n\x04\x04\x02\t\x02\x12\x03]\x13\x15\n\x0c\n\x05\
    \x04\x02\t\x02\x01\x12\x03]\x13\x15\n\x0c\n\x05\x04\x02\t\x02\x02\x12\
    \x03]\x13\x15\n\x0b\n\x04\x04\x02\x02\0\x12\x03^\x02\x10\n\x0c\n\x05\x04\
    \x02\x02\0\x05\x12\x03^\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03^\t\
    \x0b\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03^\x0e\x0f\n\x0b\n\x04\x04\x02\
    \x02\x01\x12\x03_\x02\x12\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03_\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03_\t\r\n\x0c\n\x05\x04\x02\
    \x02\x01\x03\x12\x03_\x10\x11\n\x0b\n\x04\x04\x02\x02\x02\x12\x03`\x02\
    \x1e\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03`\x02\x08\n\x0c\n\x05\x04\
    \x02\x02\x02\x01\x12\x03`\t\x19\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03`\
    \x1c\x1d\nJ\n\x04\x04\x02\x02\x03\x12\x03b\x02!\x1a=\x20Default\x20workf\
    low\x20id\x20deprecated\x20in\x20favor\x20of\x20default_workflow\n\n\x0c\
    \n\x05\x04\x02\x02\x03\x05\x12\x03b\x02\x08\n\x0c\n\x05\x04\x02\x02\x03\
    \x01\x12\x03b\t\x1c\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03b\x1f\x20\n\
    \x0b\n\x04\x04\x02\x02\x04\x12\x03c\x02!\n\x0c\n\x05\x04\x02\x02\x04\x06\
    \x12\x03c\x02\n\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03c\x0b\x1b\n\x0c\n\
    \x05\x04\x02\x02\x04\x03\x12\x03c\x1e\x20\n\x9d\x03\n\x04\x04\x02\x02\
    \x05\x12\x03g\x02\x15\x1a\x8f\x03\x20why\x20is\x20user_id\x20present\x20\
    here\x20when\x20this\x20message\x20type\x20is\x20used\x20in\x20PostApps\
    \x20but\x20completely\x20ignored\x20there?\x20PostApp\x20already\n\x20sp\
    ecifies\x20the\x20userid\x20in\x20path\x20but\x20doesn't\x20even\x20actu\
    ally\x20use\x20neither\x20of\x20userids,\x20it\x20instead\x20used\x20the\
    \x20id\x20from\x20auth\x20context.\n\x20This\x20creates\x20a\x20lot\x20o\
    f\x20ambiguity,\x20should\x20always\x20have\x20different\x20message\x20t\
    ypes\x20for\x20Post/Get\x20endpoints\x20so\x20that\x20the\x20minimum\x20\
    interface\x20for\x20each\x20op\x20can\x20be\x20described\n\n\x0c\n\x05\
    \x04\x02\x02\x05\x05\x12\x03g\x02\x08\n\x0c\n\x05\x04\x02\x02\x05\x01\
    \x12\x03g\t\x10\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03g\x13\x14\n\xfd\
    \x01\n\x04\x04\x02\x02\x06\x12\x03m\x02+\x1a\xef\x01\x20When\x20the\x20a\
    pp\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20timestamp\n\x20f\
    ormat.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\x20format:\n\
    \x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20expect\x20res\
    ults\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\x20\"2017-04\
    -11T21:50:50.223962Z\"\n\n\x0c\n\x05\x04\x02\x02\x06\x06\x12\x03m\x02\
    \x1b\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03m\x1c&\n\x0c\n\x05\x04\x02\
    \x02\x06\x03\x12\x03m)*\n-\n\x04\x04\x02\x02\x07\x12\x03o\x02-\x1a\x20\
    \x20When\x20the\x20app\x20was\x20last\x20modified\n\n\x0c\n\x05\x04\x02\
    \x02\x07\x06\x12\x03o\x02\x1b\n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03o\
    \x1c'\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03o*,\n@\n\x04\x04\x02\x02\
    \x08\x12\x03q\x02\"\x1a3\x20if\x20user\x20accept\x20legal\x20consent\x20\
    for\x20face\x20recognition\n\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\x03q\
    \x02\x08\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03q\t\x1d\n\x0c\n\x05\x04\
    \x02\x02\x08\x03\x12\x03q\x20!\n\x9e\x01\n\x04\x04\x02\x02\t\x12\x03u\
    \x02'\x1a\x90\x01\x20To\x20handle\x20arbitrary\x20json\x20metadata\x20yo\
    u\x20can\x20use\x20a\x20struct\x20field:\n\x20https://github.com/google/\
    protobuf/blob/master/src/google/protobuf/struct.proto\n\n\x0c\n\x05\x04\
    \x02\x02\t\x06\x12\x03u\x02\x18\n\x0c\n\x05\x04\x02\x02\t\x01\x12\x03u\
    \x19!\n\x0c\n\x05\x04\x02\x02\t\x03\x12\x03u$&\n/\n\x04\x04\x02\x02\n\
    \x12\x03x\x02\x1a\x1a\"\x20short\x20description\x20about\x20the\x20app.\
    \n\n\x0c\n\x05\x04\x02\x02\n\x05\x12\x03x\x02\x08\n\x0c\n\x05\x04\x02\
    \x02\n\x01\x12\x03x\t\x14\n\x0c\n\x05\x04\x02\x02\n\x03\x12\x03x\x17\x19\
    \n{\n\x04\x04\x02\x02\x0b\x12\x03{\x02\x18\x1an\x20Default\x20value\x20f\
    or\x20model\x20predictions\x20on\x20video:\x20Sample\x20delay\x20for\x20\
    video\x20predicting\x20(1\x20frame\x20per\x20N\x20milliseconds)\n\n\x0c\
    \n\x05\x04\x02\x02\x0b\x05\x12\x03{\x02\x08\n\x0c\n\x05\x04\x02\x02\x0b\
    \x01\x12\x03{\t\x12\n\x0c\n\x05\x04\x02\x02\x0b\x03\x12\x03{\x15\x17\n\
    \xdd\x01\n\x04\x04\x02\x02\x0c\x12\x04\x80\x01\x02\x1d\x1a\xce\x01\x20Th\
    e\x20visibility\x20field\x20represents\x20whether\x20this\x20message\x20\
    is\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20t\
    he\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20Us\
    er\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\
    \x20visible.\n\n\r\n\x05\x04\x02\x02\x0c\x06\x12\x04\x80\x01\x02\x0c\n\r\
    \n\x05\x04\x02\x02\x0c\x01\x12\x04\x80\x01\r\x17\n\r\n\x05\x04\x02\x02\
    \x0c\x03\x12\x04\x80\x01\x1a\x1c\n/\n\x04\x04\x02\x02\r\x12\x04\x83\x01\
    \x02\x1b\x1a!\x20data\x20tier\x20id\x20this\x20app\x20is\x20using.\n\n\r\
    \n\x05\x04\x02\x02\r\x05\x12\x04\x83\x01\x02\x08\n\r\n\x05\x04\x02\x02\r\
    \x01\x12\x04\x83\x01\t\x15\n\r\n\x05\x04\x02\x02\r\x03\x12\x04\x83\x01\
    \x18\x1a\n\x9d\x01\n\x04\x04\x02\x02\x0e\x12\x04\x87\x01\x02\x17\x1a\x8e\
    \x01\x20Is\x20starred\x20by\x20the\x20requesting\x20user\x20(only\x20sho\
    wed\x20on\x20get/list\x20requests)\n\x20Please\x20use\x20PostAppStars/De\
    leteAppStars\x20endpoints\x20to\x20star/unstar\x20an\x20app\n\n\r\n\x05\
    \x04\x02\x02\x0e\x05\x12\x04\x87\x01\x02\x06\n\r\n\x05\x04\x02\x02\x0e\
    \x01\x12\x04\x87\x01\x07\x11\n\r\n\x05\x04\x02\x02\x0e\x03\x12\x04\x87\
    \x01\x14\x16\nt\n\x04\x04\x02\x02\x0f\x12\x04\x8a\x01\x02\x18\x1af\x20Ho\
    w\x20many\x20users\x20have\x20starred\x20the\x20app\x20(only\x20showed\
    \x20on\x20get/list\x20requests)\n\x20Computed\x20value,\x20not\x20editab\
    le\n\n\r\n\x05\x04\x02\x02\x0f\x05\x12\x04\x8a\x01\x02\x07\n\r\n\x05\x04\
    \x02\x02\x0f\x01\x12\x04\x8a\x01\x08\x12\n\r\n\x05\x04\x02\x02\x0f\x03\
    \x12\x04\x8a\x01\x15\x17\nq\n\x04\x04\x02\x02\x10\x12\x04\x8e\x01\x02\
    \x14\x1ac\x20Notes\x20for\x20the\x20application\n\x20This\x20field\x20sh\
    ould\x20be\x20used\x20for\x20in-depth\x20notes\x20and\x20supports\x20up\
    \x20to\x2064Kbs.\n\n\r\n\x05\x04\x02\x02\x10\x05\x12\x04\x8e\x01\x02\x08\
    \n\r\n\x05\x04\x02\x02\x10\x01\x12\x04\x8e\x01\t\x0e\n\r\n\x05\x04\x02\
    \x02\x10\x03\x12\x04\x8e\x01\x11\x13\n1\n\x04\x04\x02\x02\x11\x12\x04\
    \x91\x01\x02\x13\x1a#\x20Representative\x20image\x20for\x20this\x20app\n\
    \n\r\n\x05\x04\x02\x02\x11\x06\x12\x04\x91\x01\x02\x07\n\r\n\x05\x04\x02\
    \x02\x11\x01\x12\x04\x91\x01\x08\r\n\r\n\x05\x04\x02\x02\x11\x03\x12\x04\
    \x91\x01\x10\x12\n\x86\x01\n\x04\x04\x02\x02\x12\x12\x04\x95\x01\x02-\
    \x1ax\x20An\x20app\x20marked\x20as\x20a\x20template\x20can\x20be\x20dupl\
    icated\x20by\x20any\x20user\x20that\x20can\x20see\x20it,\n\x20including\
    \x20all\x20visible\x20resources\x20within\x20it.\n\n\r\n\x05\x04\x02\x02\
    \x12\x06\x12\x04\x95\x01\x02\x1b\n\r\n\x05\x04\x02\x02\x12\x01\x12\x04\
    \x95\x01\x1c'\n\r\n\x05\x04\x02\x02\x12\x03\x12\x04\x95\x01*,\n\x0c\n\
    \x04\x04\x02\x02\x13\x12\x04\x97\x01\x02\x1f\n\r\n\x05\x04\x02\x02\x13\
    \x06\x12\x04\x97\x01\x02\x0e\n\r\n\x05\x04\x02\x02\x13\x01\x12\x04\x97\
    \x01\x0f\x19\n\r\n\x05\x04\x02\x02\x13\x03\x12\x04\x97\x01\x1c\x1e\n\x0c\
    \n\x02\x04\x03\x12\x06\x9a\x01\0\xa4\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\
    \x04\x9a\x01\x08\x14\n\x88\x03\n\x04\x04\x03\x02\0\x12\x04\xa2\x01\x02$\
    \x1a\xf9\x02\x20Revision\x20marker\x20for\x20this\x20application.\n\x20T\
    he\x20value\x20of\x20the\x20revision\x20changes\x20when\n\x20*\x20inputs\
    \x20are\x20added,\x20updated\x20or\x20deleted\n\x20*\x20annotations\x20a\
    re\x20added,\x20updated\x20or\x20deleted\n\x20*\x20inputs\x20are\x20adde\
    d\x20to\x20or\x20removed\x20from\x20datasets\n\x20For\x20example,\x20thi\
    s\x20value\x20can\x20be\x20used\x20to\x20detect\x20if\x20client\x20side\
    \x20caches\x20related\x20to\x20searching\x20should\x20be\x20invalidated.\
    \n\x20Field\x20not\x20filled\x20in\x20for\x20list\x20endpoints,\x20use\
    \x20GetApp\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xa2\x01\x02\x08\n\r\n\
    \x05\x04\x03\x02\0\x01\x12\x04\xa2\x01\t\x1f\n\r\n\x05\x04\x03\x02\0\x03\
    \x12\x04\xa2\x01\"#\n\x0c\n\x04\x04\x03\x02\x01\x12\x04\xa3\x01\x02\x1f\
    \n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\xa3\x01\x02\x13\n\r\n\x05\x04\x03\
    \x02\x01\x01\x12\x04\xa3\x01\x14\x1a\n\r\n\x05\x04\x03\x02\x01\x03\x12\
    \x04\xa3\x01\x1d\x1e\n\x19\n\x02\x04\x04\x12\x06\xa7\x01\0\xaa\x01\x01\
    \x1a\x0b\x20App\x20query\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xa7\x01\x08\
    \x10\nw\n\x04\x04\x04\x02\0\x12\x04\xa9\x01\x02\x12\x1ai\x20Query\x20by\
    \x20application\x20name.\x20This\x20supports\x20wildcard\x20queries\x20l\
    ike\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20an\x20example.\n\
    \n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x04\
    \x02\0\x01\x12\x04\xa9\x01\t\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xa9\
    \x01\x10\x11\n\x0c\n\x02\x04\x05\x12\x06\xac\x01\0\xb2\x01\x01\n\x0b\n\
    \x03\x04\x05\x01\x12\x04\xac\x01\x08\x19\n\x0c\n\x04\x04\x05\x02\0\x12\
    \x04\xad\x01\x02\x15\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xad\x01\x02\x07\
    \n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x05\
    \x02\0\x03\x12\x04\xad\x01\x13\x14\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\
    \xae\x01\x02\x13\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xae\x01\x02\x07\n\
    \r\n\x05\x04\x05\x02\x01\x01\x12\x04\xae\x01\x08\x0e\n\r\n\x05\x04\x05\
    \x02\x01\x03\x12\x04\xae\x01\x11\x12\n\x0c\n\x04\x04\x05\x02\x02\x12\x04\
    \xaf\x01\x02\x16\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xaf\x01\x02\x07\n\
    \r\n\x05\x04\x05\x02\x02\x01\x12\x04\xaf\x01\x08\x11\n\r\n\x05\x04\x05\
    \x02\x02\x03\x12\x04\xaf\x01\x14\x15\n\x0c\n\x04\x04\x05\x02\x03\x12\x04\
    \xb0\x01\x02\x14\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\xb0\x01\x02\x07\n\
    \r\n\x05\x04\x05\x02\x03\x01\x12\x04\xb0\x01\x08\x0f\n\r\n\x05\x04\x05\
    \x02\x03\x03\x12\x04\xb0\x01\x12\x13\n\x0c\n\x04\x04\x05\x02\x04\x12\x04\
    \xb1\x01\x02\x13\n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\xb1\x01\x02\x07\n\
    \r\n\x05\x04\x05\x02\x04\x01\x12\x04\xb1\x01\x08\x0e\n\r\n\x05\x04\x05\
    \x02\x04\x03\x12\x04\xb1\x01\x11\x12\nS\n\x02\x04\x06\x12\x06\xb5\x01\0\
    \xcd\x01\x01\x1aE\x20Collaborator\x20-\x20invited\x20user,\x20who\x20sha\
    res\x20an\x20access\x20to\x20an\x20application\n\n\x0b\n\x03\x04\x06\x01\
    \x12\x04\xb5\x01\x08\x14\n'\n\x04\x04\x06\x02\0\x12\x04\xb7\x01\x02\x10\
    \x1a\x19\x20id\x20of\x20this\x20collaborator\n\n\r\n\x05\x04\x06\x02\0\
    \x05\x12\x04\xb7\x01\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xb7\x01\
    \t\x0b\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xb7\x01\x0e\x0f\n\x8b\x01\n\
    \x04\x04\x06\x02\x01\x12\x04\xba\x01\x02\x1b\x1a}\x20the\x20app\x20this\
    \x20collaborator\x20has\x20access\x20to\n\x20FIXME(zeiler):\x20this\x20s\
    hould\x20be\x20in\x20the\x20user_app_id.app_id\x20already\x20from\x20the\
    \x20endpoint.\n\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\xba\x01\x02\x12\n\
    \r\n\x05\x04\x06\x02\x01\x01\x12\x04\xba\x01\x13\x16\n\r\n\x05\x04\x06\
    \x02\x01\x03\x12\x04\xba\x01\x19\x1a\n(\n\x04\x04\x06\x02\x02\x12\x04\
    \xbc\x01\x02\x1d\x1a\x1a\x20who\x20is\x20this\x20collaborator\n\n\r\n\
    \x05\x04\x06\x02\x02\x06\x12\x04\xbc\x01\x02\x13\n\r\n\x05\x04\x06\x02\
    \x02\x01\x12\x04\xbc\x01\x14\x18\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\
    \xbc\x01\x1b\x1c\n0\n\x04\x04\x06\x02\x03\x12\x04\xbe\x01\x02\x1d\x1a\"\
    \x20the\x20permission\x20this\x20collaborator\n\n\r\n\x05\x04\x06\x02\
    \x03\x04\x12\x04\xbe\x01\x02\n\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\xbe\
    \x01\x0b\x11\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xbe\x01\x12\x18\n\r\n\
    \x05\x04\x06\x02\x03\x03\x12\x04\xbe\x01\x1b\x1c\n\x0c\n\x04\x04\x06\x02\
    \x04\x12\x04\xbf\x01\x02\x20\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\xbf\
    \x01\x02\n\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xbf\x01\x0b\x11\n\r\n\
    \x05\x04\x06\x02\x04\x01\x12\x04\xbf\x01\x12\x1b\n\r\n\x05\x04\x06\x02\
    \x04\x03\x12\x04\xbf\x01\x1e\x1f\n\x82\x02\n\x04\x04\x06\x02\x05\x12\x04\
    \xc6\x01\x02+\x1a\xf3\x01\x20When\x20the\x20app\x20was\x20shared\x20with\
    .\x20We\x20follow\x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\
    \x20https://www.ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15\
    :04:05.999999Z\"\x20so\x20you\x20can\x20expect\x20results\x20like\n\x20t\
    he\x20following\x20from\x20the\x20API:\n\x20\"2017-04-11T21:50:50.223962\
    Z\"\n\n\r\n\x05\x04\x06\x02\x05\x06\x12\x04\xc6\x01\x02\x1b\n\r\n\x05\
    \x04\x06\x02\x05\x01\x12\x04\xc6\x01\x1c&\n\r\n\x05\x04\x06\x02\x05\x03\
    \x12\x04\xc6\x01)*\n2\n\x04\x04\x06\x02\x06\x12\x04\xc9\x01\x02,\x1a$\
    \x20When\x20the\x20collaborator\x20was\x20updated.\n\n\r\n\x05\x04\x06\
    \x02\x06\x06\x12\x04\xc9\x01\x02\x1b\n\r\n\x05\x04\x06\x02\x06\x01\x12\
    \x04\xc9\x01\x1c'\n\r\n\x05\x04\x06\x02\x06\x03\x12\x04\xc9\x01*+\n;\n\
    \x04\x04\x06\x02\x07\x12\x04\xcc\x01\x02+\x1a-\x20When\x20the\x20collabo\
    rator\x20was\x20removed\x20from\x20app.\n\n\r\n\x05\x04\x06\x02\x07\x06\
    \x12\x04\xcc\x01\x02\x1b\n\r\n\x05\x04\x06\x02\x07\x01\x12\x04\xcc\x01\
    \x1c&\n\r\n\x05\x04\x06\x02\x07\x03\x12\x04\xcc\x01)*\nH\n\x02\x04\x07\
    \x12\x06\xd0\x01\0\xdb\x01\x01\x1a:\x20collaboration\x20includes\x20an\
    \x20app\x20you're\x20invited\x20to\x20work\x20on.\n\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xd0\x01\x08\x15\n\x1f\n\x04\x04\x07\x02\0\x12\x04\xd2\x01\
    \x02\x0e\x1a\x11\x20the\x20application\n\n\r\n\x05\x04\x07\x02\0\x06\x12\
    \x04\xd2\x01\x02\x05\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xd2\x01\x06\t\n\
    \r\n\x05\x04\x07\x02\0\x03\x12\x04\xd2\x01\x0c\r\nd\n\x04\x04\x07\x02\
    \x01\x12\x04\xd4\x01\x02\x15\x1aV\x20the\x20app\x20owner's\x20info(inclu\
    ding\x20user_unique_id,\x20first_name,\x20last_name,\x20primary_email)\n\
    \n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xd4\x01\x02\x06\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xd4\x01\x07\x10\n\r\n\x05\x04\x07\x02\x01\x03\x12\
    \x04\xd4\x01\x13\x14\nP\n\x04\x04\x07\x02\x02\x12\x04\xd6\x01\x02\x1d\
    \x1aB\x20the\x20low-level\x20scope\x20users\x20are\x20shared\x20with\x20\
    for\x20this\x20collaboration\n\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xd6\
    \x01\x02\n\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\xd6\x01\x0b\x11\n\r\n\
    \x05\x04\x07\x02\x02\x01\x12\x04\xd6\x01\x12\x18\n\r\n\x05\x04\x07\x02\
    \x02\x03\x12\x04\xd6\x01\x1b\x1c\nV\n\x04\x04\x07\x02\x03\x12\x04\xd8\
    \x01\x02\x20\x1aH\x20the\x20endpoint-level\x20scopes\x20users\x20are\x20\
    shared\x20with\x20for\x20this\x20collaboration\n\n\r\n\x05\x04\x07\x02\
    \x03\x04\x12\x04\xd8\x01\x02\n\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\xd8\
    \x01\x0b\x11\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xd8\x01\x12\x1b\n\r\n\
    \x05\x04\x07\x02\x03\x03\x12\x04\xd8\x01\x1e\x1f\n1\n\x04\x04\x07\x02\
    \x04\x12\x04\xda\x01\x02+\x1a#\x20when\x20is\x20the\x20collaboration\x20\
    created\n\n\r\n\x05\x04\x07\x02\x04\x06\x12\x04\xda\x01\x02\x1b\n\r\n\
    \x05\x04\x07\x02\x04\x01\x12\x04\xda\x01\x1c&\n\r\n\x05\x04\x07\x02\x04\
    \x03\x12\x04\xda\x01)*\n\"\n\x02\x04\x08\x12\x06\xde\x01\0\xf0\x01\x01\
    \x1a\x14\x20Audio\x20asset\x20struct\n\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \xde\x01\x08\r\n\x86\x01\n\x04\x04\x08\x02\0\x12\x04\xe1\x01\x02\x11\x1a\
    x\x20This\x20is\x20a\x20URL\x20to\x20a\x20publicly\x20accessible\x20imag\
    e\x20file.\x20The\x20platform\x20will\x20download\x20this\x20file\x20ser\
    ver\n\x20side\x20and\x20then\x20process.\n\n\r\n\x05\x04\x08\x02\0\x05\
    \x12\x04\xe1\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xe1\x01\t\
    \x0c\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xe1\x01\x0f\x10\n\x90\x03\n\x04\
    \x04\x08\x02\x01\x12\x04\xe8\x01\x02\x13\x1a\x81\x03\x20The\x20base64\
    \x20field\x20is\x20using\x20image\x20file\x20bytes\x20directly\x20in\x20\
    the\x20request.\n\x20NOTE:\x20if\x20you're\x20sending\x20a\x20json\x20re\
    quest,\x20then\x20this\x20MUST\x20be\x20base64\x20encoded\x20before\x20s\
    ending\x20(hence\n\x20the\x20name\x20here).\n\x20When\x20using\x20our\
    \x20grpc\x20clients,\x20you\x20DO\x20NOT\x20need\x20to\x20base64\x20enco\
    de\n\x20it\x20yourself\x20since\x20the\x20clients\x20know\x20how\x20to\
    \x20do\x20this\x20for\x20you\x20automatically\x20and\x20will\x20avoid\
    \x20the\n\x20base64\x20encoding\x20if\x20they\x20send\x20a\x20binary\x20\
    request.\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xe8\x01\x02\x07\n\r\n\
    \x05\x04\x08\x02\x01\x01\x12\x04\xe8\x01\x08\x0e\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xe8\x01\x11\x12\nG\n\x04\x04\x08\x02\x02\x12\x04\xea\
    \x01\x02\x1f\x1a9\x20If\x20True\x20then\x20you\x20will\x20be\x20allowed\
    \x20to\x20have\x20multiple\x20urls.\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\
    \x04\xea\x01\x02\x06\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xea\x01\x07\
    \x1a\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xea\x01\x1d\x1e\n\x81\x01\n\
    \x04\x04\x08\x02\x03\x12\x04\xed\x01\x02\x17\x1as\x20The\x20hosted\x20fi\
    eld\x20lists\x20original\x20audio\x20hosted\x20in\x20Clarifai\x20storage\
    .\x20This\x20field\x20is\x20currently\x20used\n\x20only\x20in\x20respons\
    e.\n\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\xed\x01\x02\x0b\n\r\n\x05\x04\
    \x08\x02\x03\x01\x12\x04\xed\x01\x0c\x12\n\r\n\x05\x04\x08\x02\x03\x03\
    \x12\x04\xed\x01\x15\x16\n\x1a\n\x04\x04\x08\x02\x04\x12\x04\xef\x01\x02\
    \x1b\x1a\x0c\x20audio\x20info\n\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\
    \xef\x01\x02\x0b\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\xef\x01\x0c\x16\n\
    \r\n\x05\x04\x08\x02\x04\x03\x12\x04\xef\x01\x19\x1a\n\x0c\n\x02\x04\t\
    \x12\x06\xf2\x01\0\xfb\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xf2\x01\x08\
    \x11\n\x1c\n\x04\x04\t\x02\0\x12\x04\xf4\x01\x02\x1a\x1a\x0e\x20audio\
    \x20format\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xf4\x01\x02\x08\n\r\n\x05\
    \x04\t\x02\0\x01\x12\x04\xf4\x01\t\x15\n\r\n\x05\x04\t\x02\0\x03\x12\x04\
    \xf4\x01\x18\x19\n\x1b\n\x04\x04\t\x02\x01\x12\x04\xf6\x01\x02\x18\x1a\r\
    \x20sample\x20rate\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xf6\x01\x02\x07\
    \n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xf6\x01\x08\x13\n\r\n\x05\x04\t\x02\
    \x01\x03\x12\x04\xf6\x01\x16\x17\n/\n\x04\x04\t\x02\x02\x12\x04\xf8\x01\
    \x02\x1d\x1a!\x20audio\x20track\x20duration\x20in\x20seconds\n\n\r\n\x05\
    \x04\t\x02\x02\x05\x12\x04\xf8\x01\x02\x07\n\r\n\x05\x04\t\x02\x02\x01\
    \x12\x04\xf8\x01\x08\x18\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xf8\x01\x1b\
    \x1c\n$\n\x04\x04\t\x02\x03\x12\x04\xfa\x01\x02\x15\x1a\x16\x20audio\x20\
    track\x20bit\x20rate\n\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xfa\x01\x02\
    \x07\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\t\
    \x02\x03\x03\x12\x04\xfa\x01\x13\x14\nR\n\x02\x04\n\x12\x06\xfe\x01\0\
    \x8a\x02\x01\x1aD\x20Track\x20proto\x20encodes\x20information\x20of\x20a\
    \x20track\x20over\x20a\x20number\x20of\x20frames\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xfe\x01\x08\r\n\x0b\n\x03\x04\n\t\x12\x04\xff\x01\x02\r\n\x0c\n\
    \x04\x04\n\t\0\x12\x04\xff\x01\x0b\x0c\n\r\n\x05\x04\n\t\0\x01\x12\x04\
    \xff\x01\x0b\x0c\n\r\n\x05\x04\n\t\0\x02\x12\x04\xff\x01\x0b\x0c\n\x18\n\
    \x04\x04\n\x02\0\x12\x04\x81\x02\x02\x10\x1a\n\x20track\x20id\n\n\r\n\
    \x05\x04\n\x02\0\x05\x12\x04\x81\x02\x02\x08\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\x81\x02\t\x0b\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x81\x02\x0e\x0f\
    \n\x89\x01\n\x04\x04\n\x02\x01\x12\x04\x85\x02\x02\x10\x1a{\x20This\x20i\
    s\x20a\x20recursive\x20definition\x20which\x20can\x20contain\x20all\x20t\
    he\x20concepts,\n\x20embeddings,\x20etc.\x20that\x20are\x20computed\x20w\
    ithin\x20this\x20track.\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x85\x02\
    \x02\x06\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x85\x02\x07\x0b\n\r\n\x05\
    \x04\n\x02\x01\x03\x12\x04\x85\x02\x0e\x0f\n\x0c\n\x04\x04\n\x02\x02\x12\
    \x04\x87\x02\x02\x19\n\r\n\x05\x04\n\x02\x02\x06\x12\x04\x87\x02\x02\n\n\
    \r\n\x05\x04\n\x02\x02\x01\x12\x04\x87\x02\x0b\x14\n\r\n\x05\x04\n\x02\
    \x02\x03\x12\x04\x87\x02\x17\x18\n\x0c\n\x04\x04\n\x02\x03\x12\x04\x89\
    \x02\x02\x14\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\x89\x02\x02\x07\n\r\n\
    \x05\x04\n\x02\x03\x01\x12\x04\x89\x02\x08\x0f\n\r\n\x05\x04\n\x02\x03\
    \x03\x12\x04\x89\x02\x12\x13\n\x1c\n\x02\x04\x0b\x12\x06\x92\x02\0\xa0\
    \x02\x01\x1a\x0e\x20Cluster\x20data\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\
    \x92\x02\x08\x0f\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x93\x02\x02\x10\n\r\n\
    \x05\x04\x0b\x02\0\x05\x12\x04\x93\x02\x02\x08\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\x93\x02\t\x0b\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x93\x02\
    \x0e\x0f\nD\n\x04\x04\x0b\x02\x01\x12\x04\x96\x02\x02\x13\x1a6\x20Number\
    \x20of\x20annotations\x20tied\x20to\x20the\x20cluster\x20in\x20the\x20ap\
    p\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x96\x02\x02\x08\n\r\n\x05\x04\
    \x0b\x02\x01\x01\x12\x04\x96\x02\t\x0e\n\r\n\x05\x04\x0b\x02\x01\x03\x12\
    \x04\x96\x02\x11\x12\n\x9b\x01\n\x04\x04\x0b\x02\x02\x12\x04\x9a\x02\x02\
    \x12\x1a\x8c\x01\x20The\x20score\x20assigned\x20to\x20this\x20cluster.\n\
    \x20For\x20List\x20Clusters\x20endpoint,\x20this\x20represents\x20percen\
    tage\x20of\x20inputs\x20in\x20the\x20app\x20assigned\x20to\x20this\x20cl\
    uster.\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x9a\x02\x02\x07\n\r\n\x05\
    \x04\x0b\x02\x02\x01\x12\x04\x9a\x02\x08\r\n\r\n\x05\x04\x0b\x02\x02\x03\
    \x12\x04\x9a\x02\x10\x11\nJ\n\x04\x04\x0b\x02\x03\x12\x04\x9d\x02\x02\
    \x18\x1a<\x20Representative\x20hits\x20for\x20cluster\x20(for\x20now\x20\
    we\x20only\x20return\x201)\n\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\x9d\
    \x02\x02\n\n\r\n\x05\x04\x0b\x02\x03\x06\x12\x04\x9d\x02\x0b\x0e\n\r\n\
    \x05\x04\x0b\x02\x03\x01\x12\x04\x9d\x02\x0f\x13\n\r\n\x05\x04\x0b\x02\
    \x03\x03\x12\x04\x9d\x02\x16\x17\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\x9f\
    \x02\x02\x20\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\x9f\x02\x02\n\n\r\n\
    \x05\x04\x0b\x02\x04\x05\x12\x04\x9f\x02\x0b\x10\n\r\n\x05\x04\x0b\x02\
    \x04\x01\x12\x04\x9f\x02\x11\x1b\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\
    \x9f\x02\x1e\x1f\n\x1a\n\x02\x04\x0c\x12\x06\xa3\x02\0\xa7\x02\x01\x1a\
    \x0c\x20Color\x20data\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa3\x02\x08\r\n\
    \x0c\n\x04\x04\x0c\x02\0\x12\x04\xa4\x02\x02\x15\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xa4\x02\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa4\x02\
    \t\x10\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa4\x02\x13\x14\n\x0c\n\x04\
    \x04\x0c\x02\x01\x12\x04\xa5\x02\x02\x0e\n\r\n\x05\x04\x0c\x02\x01\x06\
    \x12\x04\xa5\x02\x02\x05\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xa5\x02\
    \x06\t\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xa5\x02\x0c\r\n\x0c\n\x04\
    \x04\x0c\x02\x02\x12\x04\xa6\x02\x02A\n\r\n\x05\x04\x0c\x02\x02\x05\x12\
    \x04\xa6\x02\x02\x07\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xa6\x02\x08\r\
    \n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xa6\x02\x10\x11\n\r\n\x05\x04\x0c\
    \x02\x02\x08\x12\x04\xa6\x02\x12@\n\x10\n\x08\x04\x0c\x02\x02\x08\xd0\
    \x86\x03\x12\x04\xa6\x02\x13?\n\x0c\n\x02\x04\r\x12\x06\xa9\x02\0\xac\
    \x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xa9\x02\x08\x0b\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\xaa\x02\x02\x11\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xaa\x02\
    \x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xaa\x02\t\x0c\n\r\n\x05\x04\r\
    \x02\0\x03\x12\x04\xaa\x02\x0f\x10\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xab\
    \x02\x02\x12\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xab\x02\x02\x08\n\r\n\
    \x05\x04\r\x02\x01\x01\x12\x04\xab\x02\t\r\n\r\n\x05\x04\r\x02\x01\x03\
    \x12\x04\xab\x02\x10\x11\nE\n\x02\x04\x0e\x12\x06\xaf\x02\0\xb3\x02\x01\
    \x1a7\x20Common\x20message\x20to\x20identify\x20the\x20app\x20in\x20a\
    \x20url\x20endpoint.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xaf\x02\x08\x14\n\
    ]\n\x04\x04\x0e\x02\0\x12\x04\xb1\x02\x02\x15\x1aO\x20Note\x20user_id\
    \x20'me'\x20is\x20reserved\x20-\x20it\x20is\x20the\x20alias\x20for\x20th\
    e\x20id\x20of\x20authorized\x20user\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\
    \x04\xb1\x02\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xb1\x02\t\x10\n\
    \r\n\x05\x04\x0e\x02\0\x03\x12\x04\xb1\x02\x13\x14\n\x0c\n\x04\x04\x0e\
    \x02\x01\x12\x04\xb2\x02\x02\x14\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\
    \xb2\x02\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xb2\x02\t\x0f\n\r\
    \n\x05\x04\x0e\x02\x01\x03\x12\x04\xb2\x02\x12\x13\n\x1b\n\x02\x04\x0f\
    \x12\x06\xb6\x02\0\x80\x03\x01\x1a\r\x20PatchAction\n\n\x0b\n\x03\x04\
    \x0f\x01\x12\x04\xb6\x02\x08\x13\n\x96\x01\n\x04\x04\x0f\x02\0\x12\x04\
    \xb9\x02\x02\x10\x1a\x87\x01\x20The\x20operation\x20to\x20perform\x20on\
    \x20the\x20patched\x20metadata\x20given\x20a\x20path\n\x20For\x20now\x20\
    only\x20operations\x20'overwrite',\x20'delete,\x20and\x20'merge'\x20is\
    \x20supported\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xb9\x02\x02\x08\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\xb9\x02\t\x0b\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xb9\x02\x0e\x0f\n\x97\t\n\x04\x04\x0f\x02\x01\x12\x04\xfb\
    \x02\x02'\x1a\x88\t\x20If\x20the\x20action\x20is\x20'merge'\x20and\x20th\
    ere\x20is\x20a\x20conflict,\x20how\x20to\x20resolve\x20it.\n\x20The\x20o\
    ptions\x20are\n\x20'overwrite_by_id',\x20'remove_by_id',\x20'merge_by_id\
    ','overwrite',\x20'append'\x20and\x20'do_nothing'\n\x20Note\x20that\x20f\
    or\x20conflict\x20resolutions\x20'*_by_id'\x20to\x20work\x20on\x20a\x20l\
    ist,\x20the\x20list\x20should\x20contain\n\x20objects\x20with\x20an\x20'\
    id'\x20field\x20which\x20will\x20be\x20used\x20to\x20uniquely\x20identif\
    y\x20each\x20field.\x20For\x20example\n\x20Patching\x20existing\x20json\
    \n\x20{\n\x20\x20\x20\"tag\":\x20[\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\
    \x20\x20\x20\x20\"id\":\x20\"1\",\n\x20\x20\x20\x20\x20\x20\x20\"data\":\
    \x201\n\x20\x20\x20\x20\x20},\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\
    \x20\x20\x20\"id\":\x20\"2\",\n\x20\x20\x20\x20\x20\x20\x20\"data\":\x20\
    2\n\x20\x20\x20\x20\x20}\n\x20\x20\x20]\n\x20}\n\x20with\x20op\x20'merge\
    '\x20and\x20merge_conflict_resolution\x20'overwrite_by_id'\n\x20{\n\x20\
    \x20\x20\"tag\":\x20[\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\
    \x20\"id\":\x20\"2\",\n\x20\x20\x20\x20\x20\x20\x20\"data\":\x203\n\x20\
    \x20\x20\x20\x20}\n\x20\x20\x20]\n\x20}\n\x20would\x20produce\n\x20{\n\
    \x20\x20\x20\"tag\":\x20[\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\
    \x20\x20\"id\":\x20\"1\",\n\x20\x20\x20\x20\x20\x20\x20\"data\":\x201\n\
    \x20\x20\x20\x20\x20},\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\
    \x20\"id\":\x20\"2\",\n\x20\x20\x20\x20\x20\x20\x20\"data\":\x203\n\x20\
    \x20\x20\x20\x20}\n\x20\x20\x20]\n\x20}\n\x20while\x20with\x20merge_conf\
    lict_resolution\x20'remove_by_id'\x20it\x20would\x20produce\n\x20{\n\x20\
    \x20\x20\"tag\":\x20[\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\
    \x20\"id\":\x20\"1\",\n\x20\x20\x20\x20\x20\x20\x20\"data\":\x201\n\x20\
    \x20\x20\x20\x20}\n\x20\x20\x20]\n\x20}\n\n\x20Option\x20'append'\x20wil\
    l\x20simply\x20create\x20a\x20list\x20on\x20conflicts.\x20For\x20example\
    \x20in\x20above\x20example\n\x20the\x20final\x20result\x20would\x20be\n\
    \x20{\n\x20\x20\x20\"tag\":\x20[\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\
    \x20\x20\x20\x20\"id\":\x20\"1\",\n\x20\x20\x20\x20\x20\x20\x20\"data\":\
    \x201\n\x20\x20\x20\x20\x20},\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\
    \x20\x20\x20\"id\":\x20\"2\",\n\x20\x20\x20\x20\x20\x20\x20\"data\":\x20\
    [2,\x203]\n\x20\x20\x20\x20\x20}\n\x20\x20\x20]\n\x20}\n\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\xfb\x02\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\
    \x12\x04\xfb\x02\t\"\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xfb\x02%&\n\
    \x85\x01\n\x04\x04\x0f\x02\x02\x12\x04\xff\x02\x02\x12\x1aw\x20Path\x20f\
    or\x20the\x20change.\x20For\x20example\x20'tag[1].data'\x20is\x20a\x20va\
    lid\x20path\x20in\x20above\x20example.\n\x20Default\x20path\x20is\x20roo\
    t\x20level\x20i.e.\x20''.\n\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xff\
    \x02\x02\x08\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xff\x02\t\r\n\r\n\x05\
    \x04\x0f\x02\x02\x03\x12\x04\xff\x02\x10\x11\n\x1e\n\x02\x04\x10\x12\x06\
    \x84\x03\0\xad\x03\x01\x1a\x10\x20Concept\x20or\x20tag\n\n\x0b\n\x03\x04\
    \x10\x01\x12\x04\x84\x03\x08\x0f\n(\n\x04\x04\x10\x02\0\x12\x04\x86\x03\
    \x02\x10\x1a\x1a\x20The\x20concept's\x20unique\x20id.\n\n\r\n\x05\x04\
    \x10\x02\0\x05\x12\x04\x86\x03\x02\x08\n\r\n\x05\x04\x10\x02\0\x01\x12\
    \x04\x86\x03\t\x0b\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x86\x03\x0e\x0f\n\
    >\n\x04\x04\x10\x02\x01\x12\x04\x88\x03\x02\x12\x1a0\x20The\x20name\x20o\
    f\x20the\x20concept\x20in\x20the\x20given\x20language.\n\n\r\n\x05\x04\
    \x10\x02\x01\x05\x12\x04\x88\x03\x02\x08\n\r\n\x05\x04\x10\x02\x01\x01\
    \x12\x04\x88\x03\t\r\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x88\x03\x10\
    \x11\n\xe6\x02\n\x04\x04\x10\x02\x02\x12\x04\x8d\x03\x02n\x1a\xd7\x02\
    \x20Used\x20to\x20indicate\x20presence\x20(1.0)\x20or\x20not\x20(0.0)\
    \x20of\x20this\x20concept\x20when\x20making\x20a\x20request.\n\x20This\
    \x20is\x20also\x20the\x20prediction\x20probability\x20when\x20returning\
    \x20predictions\x20from\x20our\x20API.\n\x20For\x20convenience\x20we\x20\
    use\x20the\x20default\x20of\x201.0\x20when\x20making\x20requests\x20so\
    \x20the\x20concept\x20you\x20provide\x20is\n\x20is\x20treated\x20as\x20a\
    \x20positive\x20(1.0)\x20and\x20not\x20a\x20negative\x20(which\x20would\
    \x20be\x20value\x20==\x200.0).\n\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\
    \x8d\x03\x02\x07\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\x8d\x03\x08\r\n\r\
    \n\x05\x04\x10\x02\x02\x03\x12\x04\x8d\x03\x10\x11\n\r\n\x05\x04\x10\x02\
    \x02\x08\x12\x04\x8d\x03\x12m\n\x10\n\x08\x04\x10\x02\x02\x08\xda\x86\
    \x03\x12\x04\x8d\x03\x13>\n\x10\n\x08\x04\x10\x02\x02\x08\xd0\x86\x03\
    \x12\x04\x8d\x03@l\n\xb3\x01\n\x04\x04\x10\x02\x03\x12\x04\x90\x03\x02+\
    \x1a\xa4\x01\x20When\x20the\x20concept\x20was\x20created.\x20The\x20form\
    at\x20is\x20https://www.ietf.org/rfc/rfc3339.txt\x20.\n\x20Example:\x20\
    \"2006-01-02T15:04:05.999999Z\".\x20This\x20field\x20is\x20used\x20only\
    \x20in\x20a\x20response.\n\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\x90\x03\
    \x02\x1b\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\x90\x03\x1c&\n\r\n\x05\
    \x04\x10\x02\x03\x03\x12\x04\x90\x03)*\n\xc8\x02\n\x04\x04\x10\x02\x04\
    \x12\x04\x96\x03\x02\x16\x1a\xb9\x02\x20The\x20language\x20in\x20which\
    \x20the\x20concept\x20name\x20is\x20in.\x20This\x20is\x20*ONLY*\x20used\
    \x20in\x20the\x20response\x20and\x20setting\n\x20it\x20in\x20a\x20reques\
    t\x20is\x20ignored\x20since\x20the\x20default\x20language\x20of\x20your\
    \x20app\x20is\x20used\x20when\x20creating\n\x20or\x20patching\x20a\x20Co\
    ncept.\x20To\x20set\x20other\x20languages\x20for\x20your\x20concept\x20u\
    se\x20the\x20ConceptLanguage\x20object\n\x20and\x20its\x20corresponding\
    \x20endpoints.\n\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\x96\x03\x02\x08\n\
    \r\n\x05\x04\x10\x02\x04\x01\x12\x04\x96\x03\t\x11\n\r\n\x05\x04\x10\x02\
    \x04\x03\x12\x04\x96\x03\x14\x15\nb\n\x04\x04\x10\x02\x05\x12\x04\x98\
    \x03\x02\x14\x1aT\x20The\x20application\x20id\x20that\x20this\x20concept\
    \x20is\x20within.\x20This\x20can\x20be\x20ignored\x20by\x20most\x20users\
    .\n\n\r\n\x05\x04\x10\x02\x05\x05\x12\x04\x98\x03\x02\x08\n\r\n\x05\x04\
    \x10\x02\x05\x01\x12\x04\x98\x03\t\x0f\n\r\n\x05\x04\x10\x02\x05\x03\x12\
    \x04\x98\x03\x12\x13\nc\n\x04\x04\x10\x02\x06\x12\x04\x9a\x03\x02\x18\
    \x1aU\x20The\x20definition\x20for\x20the\x20concept.\x20Similar\x20to\
    \x20name.\x20This\x20can\x20be\x20ignored\x20by\x20most\x20users.\n\n\r\
    \n\x05\x04\x10\x02\x06\x05\x12\x04\x9a\x03\x02\x08\n\r\n\x05\x04\x10\x02\
    \x06\x01\x12\x04\x9a\x03\t\x13\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\x9a\
    \x03\x16\x17\n\x9a\x02\n\x04\x04\x10\x02\x07\x12\x04\x9e\x03\x02\x16\x1a\
    \x8b\x02\x20The\x20vocabulary\x20that\x20this\x20concept\x20belongs\x20t\
    o.\x20This\x20is\x20useful\x20if\x20you\x20have\x20different\x20unique\
    \x20sets\n\x20of\x20concepts\x20that\x20you\x20can\x20separate\x20out\
    \x20based\x20on\x20this\x20field.\x20For\x20example\x20\"age_appearance\
    \"\x20vs\n\x20\"gender_appearance\"\x20in\x20a\x20list\x20of\x20concept\
    \x20returned\x20from\x20the\x20demographics\x20model.\n\n\r\n\x05\x04\
    \x10\x02\x07\x05\x12\x04\x9e\x03\x02\x08\n\r\n\x05\x04\x10\x02\x07\x01\
    \x12\x04\x9e\x03\t\x11\n\r\n\x05\x04\x10\x02\x07\x03\x12\x04\x9e\x03\x14\
    \x15\n\xdd\x01\n\x04\x04\x10\x02\x08\x12\x04\xa3\x03\x02\x1c\x1a\xce\x01\
    \x20The\x20visibility\x20field\x20represents\x20whether\x20this\x20messa\
    ge\x20is\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\x20t\
    o\x20the\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\
    \x20User\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20pu\
    blicly\x20visible.\n\n\r\n\x05\x04\x10\x02\x08\x06\x12\x04\xa3\x03\x02\
    \x0c\n\r\n\x05\x04\x10\x02\x08\x01\x12\x04\xa3\x03\r\x17\n\r\n\x05\x04\
    \x10\x02\x08\x03\x12\x04\xa3\x03\x1a\x1b\n0\n\x04\x04\x10\x02\t\x12\x04\
    \xa6\x03\x02\x16\x1a\"\x20The\x20user\x20the\x20concept\x20belongs\x20to\
    .\n\n\r\n\x05\x04\x10\x02\t\x05\x12\x04\xa6\x03\x02\x08\n\r\n\x05\x04\
    \x10\x02\t\x01\x12\x04\xa6\x03\t\x10\n\r\n\x05\x04\x10\x02\t\x03\x12\x04\
    \xa6\x03\x13\x15\n<\n\x04\x04\x10\x02\n\x12\x04\xa9\x03\x02\"\x1a.\x20In\
    formation\x20about\x20keypoints\x20for\x20this\x20concept\n\n\r\n\x05\
    \x04\x10\x02\n\x06\x12\x04\xa9\x03\x02\x0e\n\r\n\x05\x04\x10\x02\n\x01\
    \x12\x04\xa9\x03\x0f\x1c\n\r\n\x05\x04\x10\x02\n\x03\x12\x04\xa9\x03\x1f\
    !\n$\n\x04\x04\x10\x02\x0b\x12\x04\xac\x03\x02#\x1a\x16\x20Optional\x20e\
    xtra\x20info.\n\n\r\n\x05\x04\x10\x02\x0b\x06\x12\x04\xac\x03\x02\x12\n\
    \r\n\x05\x04\x10\x02\x0b\x01\x12\x04\xac\x03\x13\x1d\n\r\n\x05\x04\x10\
    \x02\x0b\x03\x12\x04\xac\x03\x20\"\n\x0c\n\x02\x04\x11\x12\x06\xaf\x03\0\
    \xb5\x03\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xaf\x03\x08\x14\n&\n\x04\
    \x04\x11\x02\0\x12\x04\xb1\x03\x02%\x1a\x18\x20Names\x20of\x20the\x20key\
    points\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xb1\x03\x02\n\n\r\n\x05\x04\
    \x11\x02\0\x05\x12\x04\xb1\x03\x0b\x11\n\r\n\x05\x04\x11\x02\0\x01\x12\
    \x04\xb1\x03\x12\x20\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb1\x03#$\nr\n\
    \x04\x04\x11\x02\x01\x12\x04\xb4\x03\x02%\x1ad\x20Defines\x20the\x20conn\
    ections\x20between\x20keypoint_names.\x20Each\x20value\x20represents\x20\
    the\x20index\x20in\x20keypoint_names.\n\n\r\n\x05\x04\x11\x02\x01\x04\
    \x12\x04\xb4\x03\x02\n\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xb4\x03\x0b\
    \x17\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xb4\x03\x18\x20\n\r\n\x05\x04\
    \x11\x02\x01\x03\x12\x04\xb4\x03#$\n\x0c\n\x02\x04\x12\x12\x06\xb7\x03\0\
    \xba\x03\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xb7\x03\x08\x14\n\x0c\n\x04\
    \x04\x12\x02\0\x12\x04\xb8\x03\x02\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\
    \x04\xb8\x03\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xb8\x03\t\x0b\n\
    \r\n\x05\x04\x12\x02\0\x03\x12\x04\xb8\x03\x0e\x0f\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xb9\x03\x02\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xb9\x03\x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xb9\x03\t\x0b\n\r\
    \n\x05\x04\x12\x02\x01\x03\x12\x04\xb9\x03\x0e\x0f\n\xa9\x01\n\x02\x04\
    \x13\x12\x06\xbe\x03\0\xc1\x03\x01\x1a\x9a\x01\x20ConceptExtraInfo\x20re\
    presents\x20extra\x20information\x20related\x20to\x20a\x20concept\x20tha\
    t\x20is\x20context-dependent.\n\x20It\x20is\x20only\x20set\x20when\x20re\
    quested\x20in\x20ConceptExtraInfoRequest.\n\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\xbe\x03\x08\x18\n`\n\x04\x04\x13\x02\0\x12\x04\xc0\x03\x02\x17\x1aR\
    \x20Whether\x20this\x20concept\x20is\x20rankable\x20based\x20on\x20Conce\
    ptExtraInfoRequest\x20configuration.\n\n\r\n\x05\x04\x13\x02\0\x05\x12\
    \x04\xc0\x03\x02\x06\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xc0\x03\x07\x12\
    \n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xc0\x03\x15\x16\n\x1c\n\x02\x04\x14\
    \x12\x06\xc4\x03\0\xcd\x03\x01\x1a\x0e\x20ConceptCount\n\n\x0b\n\x03\x04\
    \x14\x01\x12\x04\xc4\x03\x08\x14\n(\n\x04\x04\x14\x02\0\x12\x04\xc6\x03\
    \x02\x10\x1a\x1a\x20The\x20concept's\x20unique\x20id.\n\n\r\n\x05\x04\
    \x14\x02\0\x05\x12\x04\xc6\x03\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\
    \x04\xc6\x03\t\x0b\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xc6\x03\x0e\x0f\n\
    (\n\x04\x04\x14\x02\x01\x12\x04\xc8\x03\x02\x12\x1a\x1a\x20The\x20name\
    \x20of\x20the\x20concept.\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xc8\
    \x03\x02\x08\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xc8\x03\t\r\n\r\n\x05\
    \x04\x14\x02\x01\x03\x12\x04\xc8\x03\x10\x11\nu\n\x04\x04\x14\x02\x02\
    \x12\x04\xca\x03\x02*\x1ag\x20The\x20total\x20count\x20for\x20concepts\
    \x20labeled\x20for\x20all\x20asset\x20statues\x20(processing,\x20to_proc\
    ess,\x20processed,\x20error)\n\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\xca\
    \x03\x02\x12\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xca\x03\x13%\n\r\n\
    \x05\x04\x14\x02\x02\x03\x12\x04\xca\x03()\n<\n\x04\x04\x14\x02\x03\x12\
    \x04\xcc\x03\x02.\x1a.\x20The\x20detail\x20count\x20for\x20different\x20\
    assets\x20status\n\n\r\n\x05\x04\x14\x02\x03\x06\x12\x04\xcc\x03\x02\x14\
    \n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xcc\x03\x15)\n\r\n\x05\x04\x14\
    \x02\x03\x03\x12\x04\xcc\x03,-\n\x20\n\x02\x04\x15\x12\x06\xd0\x03\0\xd7\
    \x03\x01\x1a\x12\x20ConceptTypeCount\n\n\x0b\n\x03\x04\x15\x01\x12\x04\
    \xd0\x03\x08\x18\n\x7f\n\x04\x04\x15\x02\0\x12\x04\xd3\x03\x02E\x1aq\x20\
    The\x20number\x20of\x20inputs\x20that\x20have\x20a\x20concept\x20with\
    \x20a\x20value\x20of\x201.0\x20(indicating\x20presence\x20of\x20the\n\
    \x20concept\x20in\x20an\x20input).\n\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\
    \xd3\x03\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xd3\x03\t\x11\n\r\n\
    \x05\x04\x15\x02\0\x03\x12\x04\xd3\x03\x14\x15\n\r\n\x05\x04\x15\x02\0\
    \x08\x12\x04\xd3\x03\x16D\n\x10\n\x08\x04\x15\x02\0\x08\xd0\x86\x03\x12\
    \x04\xd3\x03\x17C\n~\n\x04\x04\x15\x02\x01\x12\x04\xd6\x03\x02E\x1ap\x20\
    The\x20number\x20of\x20inputs\x20that\x20have\x20a\x20concept\x20with\
    \x20a\x20value\x20of\x200.0\x20(indicating\x20absence\x20of\x20the\n\x20\
    concept\x20in\x20an\x20input).\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\
    \xd6\x03\x02\x08\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xd6\x03\t\x11\n\r\
    \n\x05\x04\x15\x02\x01\x03\x12\x04\xd6\x03\x14\x15\n\r\n\x05\x04\x15\x02\
    \x01\x08\x12\x04\xd6\x03\x16D\n\x10\n\x08\x04\x15\x02\x01\x08\xd0\x86\
    \x03\x12\x04\xd6\x03\x17C\n\"\n\x02\x04\x16\x12\x06\xda\x03\0\xe3\x03\
    \x01\x1a\x14\x20DetailConceptCount\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xda\
    \x03\x08\x1a\n6\n\x04\x04\x16\x02\0\x12\x04\xdc\x03\x02!\x1a(\x20The\x20\
    concept\x20count\x20for\x20processed\x20assets\n\n\r\n\x05\x04\x16\x02\0\
    \x06\x12\x04\xdc\x03\x02\x12\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xdc\x03\
    \x13\x1c\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xdc\x03\x1f\x20\n7\n\x04\
    \x04\x16\x02\x01\x12\x04\xde\x03\x02\"\x1a)\x20The\x20concept\x20count\
    \x20for\x20to\x20process\x20assets\n\n\r\n\x05\x04\x16\x02\x01\x06\x12\
    \x04\xde\x03\x02\x12\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xde\x03\x13\
    \x1d\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xde\x03\x20!\n>\n\x04\x04\x16\
    \x02\x02\x12\x04\xe0\x03\x02\x1e\x1a0\x20The\x20concept\x20count\x20for\
    \x20assets\x20with\x20status\x20error\n\n\r\n\x05\x04\x16\x02\x02\x06\
    \x12\x04\xe0\x03\x02\x12\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xe0\x03\
    \x13\x19\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xe0\x03\x1c\x1d\n7\n\x04\
    \x04\x16\x02\x03\x12\x04\xe2\x03\x02\"\x1a)\x20The\x20concept\x20count\
    \x20for\x20processing\x20assets\n\n\r\n\x05\x04\x16\x02\x03\x06\x12\x04\
    \xe2\x03\x02\x12\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xe2\x03\x13\x1d\n\
    \r\n\x05\x04\x16\x02\x03\x03\x12\x04\xe2\x03\x20!\n\x1c\n\x02\x04\x17\
    \x12\x06\xe6\x03\0\xf0\x03\x01\x1a\x0e\x20ConceptQuery\n\n\x0b\n\x03\x04\
    \x17\x01\x12\x04\xe6\x03\x08\x14\n2\n\x04\x04\x17\x02\0\x12\x04\xe8\x03\
    \x02\x12\x1a$\x20The\x20name\x20of\x20the\x20concept\x20to\x20search.\n\
    \n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xe8\x03\x02\x08\n\r\n\x05\x04\x17\
    \x02\0\x01\x12\x04\xe8\x03\t\r\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xe8\
    \x03\x10\x11\nR\n\x04\x04\x17\x02\x01\x12\x04\xea\x03\x02\x16\x1aD\x20Th\
    e\x20language\x20of\x20the\x20concept\x20name\x20in\x20a\x20search.\x20D\
    efaults\x20to\x20English.\n\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xea\
    \x03\x02\x08\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xea\x03\t\x11\n\r\n\
    \x05\x04\x17\x02\x01\x03\x12\x04\xea\x03\x14\x15\na\n\x04\x04\x17\x02\
    \x02\x12\x04\xec\x03\x02\x19\x1aS\x20The\x20id\x20of\x20workflow.\x20If\
    \x20no\x20id\x20is\x20provided,\x20then\x20application\x20base\x20workfl\
    ow\x20is\x20used.\n\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xec\x03\x02\
    \x08\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xec\x03\t\x14\n\r\n\x05\x04\
    \x17\x02\x02\x03\x12\x04\xec\x03\x17\x18\n\x88\x01\n\x04\x04\x17\x02\x03\
    \x12\x04\xef\x03\x02.\x1az\x20The\x20concepts\x20must\x20belong\x20to\
    \x20workflow\x20models\x20with\x20specified\x20use\x20cases.\n\x20Multip\
    le\x20values\x20are\x20joined\x20using\x20an\x20OR\x20condition.\n\n\r\n\
    \x05\x04\x17\x02\x03\x04\x12\x04\xef\x03\x02\n\n\r\n\x05\x04\x17\x02\x03\
    \x06\x12\x04\xef\x03\x0b\x1f\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xef\
    \x03\x20)\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xef\x03,-\n\x0c\n\x02\
    \x05\0\x12\x06\xf1\x03\0\xfb\x03\x01\n\x0b\n\x03\x05\0\x01\x12\x04\xf1\
    \x03\x05\x19\n\x0c\n\x04\x05\0\x02\0\x12\x04\xf2\x03\x02&\n\r\n\x05\x05\
    \0\x02\0\x01\x12\x04\xf2\x03\x02!\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xf2\
    \x03$%\ny\n\x04\x05\0\x02\x01\x12\x04\xf6\x03\x02\x15\x1ak\x20Classifier\
    \x20models\x20without\x20a\x20detector\x20parent\x20(recursive\x20check)\
    \x20in\x20a\x20workflow\n\x20are\x20used\x20for\x20classification.\n\n\r\
    \n\x05\x05\0\x02\x01\x01\x12\x04\xf6\x03\x02\x10\n\r\n\x05\x05\0\x02\x01\
    \x02\x12\x04\xf6\x03\x13\x14\n\x96\x01\n\x04\x05\0\x02\x02\x12\x04\xfa\
    \x03\x02\x10\x1a\x87\x01\x20Detector\x20models\x20in\x20a\x20workflow\
    \x20are\x20used\x20for\x20detection.\n\x20Classifier\x20models\x20that\
    \x20run\x20after\x20a\x20detector\x20model\x20are\x20also\x20used\x20for\
    \x20detection.\n\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xfa\x03\x02\x0b\n\r\
    \n\x05\x05\0\x02\x02\x02\x12\x04\xfa\x03\x0e\x0f\ni\n\x02\x04\x18\x12\
    \x06\xff\x03\0\xb1\x04\x01\x1a[\x20This\x20represents\x20a\x20relation\
    \x20(i.e.\x20edge)\x20between\x20the\x20subject\x20concept\x20and\x20the\
    \x20object\x20concept\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xff\x03\x08\x17\
    \n*\n\x04\x04\x18\x02\0\x12\x04\x81\x04\x02\x10\x1a\x1c\x20ID\x20of\x20t\
    he\x20concept\x20relation\n\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\x81\x04\
    \x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x81\x04\t\x0b\n\r\n\x05\x04\
    \x18\x02\0\x03\x12\x04\x81\x04\x0e\x0f\nI\n\x04\x04\x18\x02\x01\x12\x04\
    \x84\x04\x02\x1e\x1a;\x20The\x20subject\x20concept\x20(i.e.\x20source)\
    \x20of\x20the\x20concept\x20relation\n\n\r\n\x05\x04\x18\x02\x01\x06\x12\
    \x04\x84\x04\x02\t\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\x84\x04\n\x19\n\
    \r\n\x05\x04\x18\x02\x01\x03\x12\x04\x84\x04\x1c\x1d\nN\n\x04\x04\x18\
    \x02\x02\x12\x04\x87\x04\x02\x1d\x1a@\x20The\x20subject\x20concept\x20(i\
    .e.\x20destination)\x20of\x20the\x20concept\x20relation\n\n\r\n\x05\x04\
    \x18\x02\x02\x06\x12\x04\x87\x04\x02\t\n\r\n\x05\x04\x18\x02\x02\x01\x12\
    \x04\x87\x04\n\x18\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\x87\x04\x1b\x1c\
    \n\x9b\t\n\x04\x04\x18\x02\x03\x12\x04\xa7\x04\x02\x17\x1a\x8c\t\x20The\
    \x20predicate\x20(i.e.\x20edge)\x20linking\x20the\x20subject\x20and\x20t\
    he\x20object\n\x20Both\x20subject_concept\x20and\x20object_concept\x20ar\
    e\x20concepts.\n\x20The\x20predicate\x20is\x20the\x20type\x20of\x20relat\
    ionship.\n\x20That\x20predicate\x20acts\x20on\x20the\x20subject.\n\n\x20\
    There\x20are\x20three\x20current\x20types\x20of\x20predicates:\n\x201)\
    \x20\"hyponym\"\n\x202)\x20\"hypernym\"\n\x203)\x20\"synonym\"\n\n\x201)\
    \x20For\x20example,\x20'hyponym'\x20is\x20a\x20type\x20of\x20predicate\
    \x20which\x20represents\x20'is_a_kind_of'\x20relation\x20so\n\x20the\x20\
    following\x20relationship:\n\x20'honey'\x20(subject),\x20'hyponym'\x20(p\
    redicate),\x20'food'\x20(object)\n\x20Can\x20more\x20easily\x20be\x20rea\
    d\x20as:\n\x20'honey'\x20'is\x20a\x20kind\x20of'\x20'food'\n\n\n\x202)\
    \x20The\x20'hypernym'\x20relation\x20is\x20the\x20opposite\x20of\x20'hyp\
    onym'\x20and\x20when\x20you\x20add\x20one\x20of\x20the\n\x20relationship\
    s\x20the\x20opposite\x20will\x20automatically\x20appear\x20for\x20you\
    \x20in\x20queries.\n\n\x20The\x20'hypernym'\x20can\x20be\x20read\x20as\
    \x20'is\x20a\x20parent\x20of'\x20so:\n\x20'food'\x20(subject),\x20'hyper\
    nym'\x20(predicate),\x20'honey'\x20(object)\n\x20Can\x20more\x20easily\
    \x20be\x20read\x20as:\n\x20'food'\x20is\x20a\x20parent\x20of\x20'honey'\
    \n\n\x203)\x20The\x20'synonym'\x20relation\x20defines\x20two\x20concepts\
    \x20that\x20essential\x20mean\x20the\x20same\x20thing.\x20This\n\x20is\
    \x20more\x20like\x20a\x20\"is\"\x20relationship.\x20So\x20for\x20example\
    \x20a\x20'synonym'\x20relationship\x20could\x20be:\n\x20\"puppy\"\x20is\
    \x20\"pup\"\n\x20The\x20reverse\x20is\x20also\x20true\x20once\x20the\x20\
    former\x20is\x20added\x20so:\n\x20\"pup\"\x20is\x20\"puppy\"\n\x20will\
    \x20appear\x20in\x20queries\x20as\x20well.\n\n\r\n\x05\x04\x18\x02\x03\
    \x05\x12\x04\xa7\x04\x02\x08\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xa7\
    \x04\t\x12\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xa7\x04\x15\x16\n\xad\
    \x01\n\x04\x04\x18\x02\x04\x12\x04\xab\x04\x02\x20\x1a\x9e\x01\x20The\
    \x20knowledge\x20graph\x20id\x20that\x20this\x20edge\x20belongs\x20to.\
    \x20If\x20using\x20the\x20app's\x20global\x20knowledge\x20graph\n\x20and\
    \x20not\x20a\x20specific\x20one\x20then\x20this\x20should\x20be\x20the\
    \x20empty\x20string\x20\"\".\n\n\r\n\x05\x04\x18\x02\x04\x05\x12\x04\xab\
    \x04\x02\x08\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\xab\x04\t\x1b\n\r\n\
    \x05\x04\x18\x02\x04\x03\x12\x04\xab\x04\x1e\x1f\n\xdd\x01\n\x04\x04\x18\
    \x02\x05\x12\x04\xb0\x04\x02\x1c\x1a\xce\x01\x20The\x20visibility\x20fie\
    ld\x20represents\x20whether\x20this\x20message\x20is\x20privately/public\
    ly\x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20public\x20the\
    \x20App\x20that\x20contains\x20it\x20AND\x20the\x20User\x20that\x20conta\
    ins\x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20visible.\n\n\r\
    \n\x05\x04\x18\x02\x05\x06\x12\x04\xb0\x04\x02\x0c\n\r\n\x05\x04\x18\x02\
    \x05\x01\x12\x04\xb0\x04\r\x17\n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\xb0\
    \x04\x1a\x1b\n\\\n\x02\x04\x19\x12\x06\xb4\x04\0\xbf\x04\x01\x1aN\x20A\
    \x20Knowledge\x20Graph\x20is\x20a\x20logical\x20subsets\x20of\x20edges\
    \x20in\x20the\x20overall\x20Concept\x20Graph\n\n\x0b\n\x03\x04\x19\x01\
    \x12\x04\xb4\x04\x08\x16\n)\n\x04\x04\x19\x02\0\x12\x04\xb6\x04\x02\x10\
    \x1a\x1b\x20ID\x20of\x20the\x20knowledge\x20graph\n\n\r\n\x05\x04\x19\
    \x02\0\x05\x12\x04\xb6\x04\x02\x08\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\
    \xb6\x04\t\x0b\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xb6\x04\x0e\x0f\n+\n\
    \x04\x04\x19\x02\x01\x12\x04\xb8\x04\x02\x12\x1a\x1d\x20Name\x20of\x20th\
    e\x20knowledge\x20graph\n\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xb8\x04\
    \x02\x08\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xb8\x04\t\r\n\r\n\x05\x04\
    \x19\x02\x01\x03\x12\x04\xb8\x04\x10\x11\nA\n\x04\x04\x19\x02\x02\x12\
    \x04\xba\x04\x02\x19\x1a3\x20Human\x20readable\x20description\x20of\x20t\
    he\x20knowledge\x20graph\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xba\x04\
    \x02\x08\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xba\x04\t\x14\n\r\n\x05\
    \x04\x19\x02\x02\x03\x12\x04\xba\x04\x17\x18\ng\n\x04\x04\x19\x02\x03\
    \x12\x04\xbc\x04\x02\x1d\x1aY\x20The\x20app\x20that\x20contains\x20the\
    \x20images\x20that\x20correspond\x20to\x20the\x20concepts\x20in\x20the\
    \x20knowledge\x20graph\n\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xbc\x04\
    \x02\x08\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xbc\x04\t\x18\n\r\n\x05\
    \x04\x19\x02\x03\x03\x12\x04\xbc\x04\x1b\x1c\n\x81\x01\n\x04\x04\x19\x02\
    \x04\x12\x04\xbe\x04\x02%\x1as\x20The\x20app\x20that\x20contains\x20the\
    \x20sample\x20images\x20that\x20we\x20want\x20to\x20show\x20the\x20custo\
    mer\x20for\x20the\x20concepts\x20in\x20the\x20knowledge\x20graph\n\n\r\n\
    \x05\x04\x19\x02\x04\x05\x12\x04\xbe\x04\x02\x08\n\r\n\x05\x04\x19\x02\
    \x04\x01\x12\x04\xbe\x04\t\x20\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\xbe\
    \x04#$\n!\n\x02\x04\x1a\x12\x06\xc3\x04\0\xc8\x04\x01\x1a\x13\x20Concept\
    MappingJob\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xc3\x04\x08\x19\nU\n\x04\
    \x04\x1a\x02\0\x12\x04\xc5\x04\x02\x20\x1aG\x20The\x20id\x20of\x20the\
    \x20knowledge\x20graph\x20being\x20used\x20for\x20this\x20concept\x20map\
    ping\x20job\n\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xc5\x04\x02\x08\n\r\n\
    \x05\x04\x1a\x02\0\x01\x12\x04\xc5\x04\t\x1b\n\r\n\x05\x04\x1a\x02\0\x03\
    \x12\x04\xc5\x04\x1e\x1f\n4\n\x04\x04\x1a\x02\x01\x12\x04\xc7\x04\x02\"\
    \x1a&\x20The\x20ids\x20of\x20the\x20concepts\x20being\x20mapped\n\n\r\n\
    \x05\x04\x1a\x02\x01\x04\x12\x04\xc7\x04\x02\n\n\r\n\x05\x04\x1a\x02\x01\
    \x05\x12\x04\xc7\x04\x0b\x11\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xc7\
    \x04\x12\x1d\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xc7\x04\x20!\n\xc7\
    \x02\n\x02\x04\x1b\x12\x06\xce\x04\0\xd5\x04\x01\x1a\xb8\x02\x20This\x20\
    represents\x20a\x20link\x20to\x20an\x20outside\x20source\x20for\x20the\
    \x20given\x20concept.\n\x20The\x20values\x20from\x20here\x20are\x20stick\
    ed\x20into\x20Concept\x20message\x20into\x20the\x20name\x20and\x20defini\
    tion\x20fields\x20when\n\x20returning\x20from\x20the\x20API\x20in\x20you\
    r\x20default\x20language.\x20The\x20\"id\"\x20field\x20here\x20becomes\
    \x20the\x20\"language\"\n\x20field\x20of\x20the\x20Concept\x20message\
    \x20which\x20is\x20a\x20little\x20weird.\n\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\xce\x04\x08\x17\nH\n\x04\x04\x1b\x02\0\x12\x04\xd0\x04\x02\x10\x1a:\
    \x20This\x20is\x20the\x20language\x20code\x20for\x20the\x20language\x20s\
    uch\x20as\x20\"en\".\n\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xd0\x04\x02\
    \x08\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xd0\x04\t\x0b\n\r\n\x05\x04\x1b\
    \x02\0\x03\x12\x04\xd0\x04\x0e\x0f\n/\n\x04\x04\x1b\x02\x01\x12\x04\xd2\
    \x04\x02\x12\x1a!\x20The\x20type\x20of\x20the\x20outside\x20source.\n\n\
    \r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xd2\x04\x02\x08\n\r\n\x05\x04\x1b\
    \x02\x01\x01\x12\x04\xd2\x04\t\r\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\
    \xd2\x04\x10\x11\n8\n\x04\x04\x1b\x02\x02\x12\x04\xd4\x04\x02\x18\x1a*\
    \x20The\x20ID\x20that\x20is\x20referenced\x20in\x20the\x20source.\n\n\r\
    \n\x05\x04\x1b\x02\x02\x05\x12\x04\xd4\x04\x02\x08\n\r\n\x05\x04\x1b\x02\
    \x02\x01\x12\x04\xd4\x04\t\x13\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xd4\
    \x04\x16\x17\n\x14\n\x02\x04\x1c\x12\x06\xd9\x04\0\xfe\x04\x01\x1a\x06\
    \x20Data\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xd9\x04\x08\x0c\n\x0b\n\x03\
    \x04\x1c\t\x12\x04\xda\x04\x02\x11\n\x0c\n\x04\x04\x1c\t\0\x12\x04\xda\
    \x04\x0b\x0c\n\r\n\x05\x04\x1c\t\0\x01\x12\x04\xda\x04\x0b\x0c\n\r\n\x05\
    \x04\x1c\t\0\x02\x12\x04\xda\x04\x0b\x0c\n\x0c\n\x04\x04\x1c\t\x01\x12\
    \x04\xda\x04\x0e\x10\n\r\n\x05\x04\x1c\t\x01\x01\x12\x04\xda\x04\x0e\x10\
    \n\r\n\x05\x04\x1c\t\x01\x02\x12\x04\xda\x04\x0e\x10\n(\n\x04\x04\x1c\
    \x02\0\x12\x04\xdc\x04\x02\x12\x1a\x1a\x20Input\x20and\x20output\x20imag\
    es.\n\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xdc\x04\x02\x07\n\r\n\x05\x04\
    \x1c\x02\0\x01\x12\x04\xdc\x04\x08\r\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\
    \xdc\x04\x10\x11\n(\n\x04\x04\x1c\x02\x01\x12\x04\xde\x04\x02\x12\x1a\
    \x1a\x20Input\x20and\x20output\x20videos.\n\n\r\n\x05\x04\x1c\x02\x01\
    \x06\x12\x04\xde\x04\x02\x07\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xde\
    \x04\x08\r\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xde\x04\x10\x11\n#\n\
    \x04\x04\x1c\x02\x02\x12\x04\xe0\x04\x02\x20\x1a\x15\x20A\x20list\x20of\
    \x20concepts.\n\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xe0\x04\x02\n\n\r\
    \n\x05\x04\x1c\x02\x02\x06\x12\x04\xe0\x04\x0b\x12\n\r\n\x05\x04\x1c\x02\
    \x02\x01\x12\x04\xe0\x04\x13\x1b\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\
    \xe0\x04\x1e\x1f\n\x9f\x01\n\x04\x04\x1c\x02\x03\x12\x04\xe4\x04\x02&\
    \x1a\x90\x01\x20To\x20handle\x20arbitrary\x20json\x20metadata\x20you\x20\
    can\x20use\x20a\x20struct\x20field:\n\x20https://github.com/google/proto\
    buf/blob/master/src/google/protobuf/struct.proto\n\n\r\n\x05\x04\x1c\x02\
    \x03\x06\x12\x04\xe4\x04\x02\x18\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\
    \xe4\x04\x19!\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xe4\x04$%\n&\n\x04\
    \x04\x1c\x02\x04\x12\x04\xe6\x04\x02\x0e\x1a\x18\x20Geography\x20informa\
    tion.\n\n\r\n\x05\x04\x1c\x02\x04\x06\x12\x04\xe6\x04\x02\x05\n\r\n\x05\
    \x04\x1c\x02\x04\x01\x12\x04\xe6\x04\x06\t\n\r\n\x05\x04\x1c\x02\x04\x03\
    \x12\x04\xe6\x04\x0c\r\n4\n\x04\x04\x1c\x02\x05\x12\x04\xe9\x04\x02\x1c\
    \x1a&\x20The\x20dominant\x20colors\x20within\x20an\x20image.\n\n\r\n\x05\
    \x04\x1c\x02\x05\x04\x12\x04\xe9\x04\x02\n\n\r\n\x05\x04\x1c\x02\x05\x06\
    \x12\x04\xe9\x04\x0b\x10\n\r\n\x05\x04\x1c\x02\x05\x01\x12\x04\xe9\x04\
    \x11\x17\n\r\n\x05\x04\x1c\x02\x05\x03\x12\x04\xe9\x04\x1a\x1b\n0\n\x04\
    \x04\x1c\x02\x06\x12\x04\xeb\x04\x02\x20\x1a\"\x20Clustering\x20centroid\
    s\x20for\x20inputs.\n\n\r\n\x05\x04\x1c\x02\x06\x04\x12\x04\xeb\x04\x02\
    \n\n\r\n\x05\x04\x1c\x02\x06\x06\x12\x04\xeb\x04\x0b\x12\n\r\n\x05\x04\
    \x1c\x02\x06\x01\x12\x04\xeb\x04\x13\x1b\n\r\n\x05\x04\x1c\x02\x06\x03\
    \x12\x04\xeb\x04\x1e\x1f\n:\n\x04\x04\x1c\x02\x07\x12\x04\xed\x04\x02$\
    \x1a,\x20Embedding\x20vectors\x20representing\x20each\x20input.\n\n\r\n\
    \x05\x04\x1c\x02\x07\x04\x12\x04\xed\x04\x02\n\n\r\n\x05\x04\x1c\x02\x07\
    \x06\x12\x04\xed\x04\x0b\x14\n\r\n\x05\x04\x1c\x02\x07\x01\x12\x04\xed\
    \x04\x15\x1f\n\r\n\x05\x04\x1c\x02\x07\x03\x12\x04\xed\x04\"#\nA\n\x04\
    \x04\x1c\x02\x08\x12\x04\xef\x04\x02\x1f\x1a3\x20For\x20recursing\x20int\
    o\x20localized\x20regions\x20of\x20an\x20input.\n\n\r\n\x05\x04\x1c\x02\
    \x08\x04\x12\x04\xef\x04\x02\n\n\r\n\x05\x04\x1c\x02\x08\x06\x12\x04\xef\
    \x04\x0b\x11\n\r\n\x05\x04\x1c\x02\x08\x01\x12\x04\xef\x04\x12\x19\n\r\n\
    \x05\x04\x1c\x02\x08\x03\x12\x04\xef\x04\x1c\x1e\n0\n\x04\x04\x1c\x02\t\
    \x12\x04\xf1\x04\x02\x1d\x1a\"\x20For\x20temporal\x20content\x20like\x20\
    video.\n\n\r\n\x05\x04\x1c\x02\t\x04\x12\x04\xf1\x04\x02\n\n\r\n\x05\x04\
    \x1c\x02\t\x06\x12\x04\xf1\x04\x0b\x10\n\r\n\x05\x04\x1c\x02\t\x01\x12\
    \x04\xf1\x04\x11\x17\n\r\n\x05\x04\x1c\x02\t\x03\x12\x04\xf1\x04\x1a\x1c\
    \n1\n\x04\x04\x1c\x02\n\x12\x04\xf3\x04\x02\x11\x1a#\x20Input,\x20output\
    \x20or\x20annotation\x20text.\n\n\r\n\x05\x04\x1c\x02\n\x06\x12\x04\xf3\
    \x04\x02\x06\n\r\n\x05\x04\x1c\x02\n\x01\x12\x04\xf3\x04\x07\x0b\n\r\n\
    \x05\x04\x1c\x02\n\x03\x12\x04\xf3\x04\x0e\x10\n'\n\x04\x04\x1c\x02\x0b\
    \x12\x04\xf5\x04\x02\x13\x1a\x19\x20Input\x20and\x20output\x20audio.\n\n\
    \r\n\x05\x04\x1c\x02\x0b\x06\x12\x04\xf5\x04\x02\x07\n\r\n\x05\x04\x1c\
    \x02\x0b\x01\x12\x04\xf5\x04\x08\r\n\r\n\x05\x04\x1c\x02\x0b\x03\x12\x04\
    \xf5\x04\x10\x12\n\"\n\x04\x04\x1c\x02\x0c\x12\x04\xf7\x04\x02\x1d\x1a\
    \x14\x20Track\x20information.\n\n\r\n\x05\x04\x1c\x02\x0c\x04\x12\x04\
    \xf7\x04\x02\n\n\r\n\x05\x04\x1c\x02\x0c\x06\x12\x04\xf7\x04\x0b\x10\n\r\
    \n\x05\x04\x1c\x02\x0c\x01\x12\x04\xf7\x04\x11\x17\n\r\n\x05\x04\x1c\x02\
    \x0c\x03\x12\x04\xf7\x04\x1a\x1c\n*\n\x04\x04\x1c\x02\r\x12\x04\xf9\x04\
    \x02*\x1a\x1c\x20Time\x20segments\x20information.\n\n\r\n\x05\x04\x1c\
    \x02\r\x04\x12\x04\xf9\x04\x02\n\n\r\n\x05\x04\x1c\x02\r\x06\x12\x04\xf9\
    \x04\x0b\x16\n\r\n\x05\x04\x1c\x02\r\x01\x12\x04\xf9\x04\x17$\n\r\n\x05\
    \x04\x1c\x02\r\x03\x12\x04\xf9\x04')\nO\n\x04\x04\x1c\x02\x0e\x12\x04\
    \xfb\x04\x02\x19\x1aA\x20Holds\x20score,\x20rank,\x20and\x20user,\x20app\
    ,\x20input\x20IDs\x20and\x20search\x20hit\x20data\n\n\r\n\x05\x04\x1c\
    \x02\x0e\x04\x12\x04\xfb\x04\x02\n\n\r\n\x05\x04\x1c\x02\x0e\x06\x12\x04\
    \xfb\x04\x0b\x0e\n\r\n\x05\x04\x1c\x02\x0e\x01\x12\x04\xfb\x04\x0f\x13\n\
    \r\n\x05\x04\x1c\x02\x0e\x03\x12\x04\xfb\x04\x16\x18\n#\n\x04\x04\x1c\
    \x02\x0f\x12\x04\xfd\x04\x02\x1f\x1a\x15\x20Heatmap\x20as\x202d\x20image\
    \n\n\r\n\x05\x04\x1c\x02\x0f\x04\x12\x04\xfd\x04\x02\n\n\r\n\x05\x04\x1c\
    \x02\x0f\x06\x12\x04\xfd\x04\x0b\x10\n\r\n\x05\x04\x1c\x02\x0f\x01\x12\
    \x04\xfd\x04\x11\x19\n\r\n\x05\x04\x1c\x02\x0f\x03\x12\x04\xfd\x04\x1c\
    \x1e\n)\n\x02\x04\x1d\x12\x06\x81\x05\0\x8d\x05\x01\x1a\x1b\x20A\x20regi\
    on\x20within\x20the\x20data.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\x81\x05\
    \x08\x0e\n+\n\x04\x04\x1d\x02\0\x12\x04\x83\x05\x02\x10\x1a\x1d\x20A\x20\
    unique\x20id\x20for\x20the\x20region.\n\n\r\n\x05\x04\x1d\x02\0\x05\x12\
    \x04\x83\x05\x02\x08\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x83\x05\t\x0b\n\
    \r\n\x05\x04\x1d\x02\0\x03\x12\x04\x83\x05\x0e\x0f\n=\n\x04\x04\x1d\x02\
    \x01\x12\x04\x85\x05\x02\x1d\x1a/\x20The\x20details\x20about\x20the\x20l\
    ocation\x20of\x20the\x20region.\n\n\r\n\x05\x04\x1d\x02\x01\x06\x12\x04\
    \x85\x05\x02\x0c\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\x85\x05\r\x18\n\r\
    \n\x05\x04\x1d\x02\x01\x03\x12\x04\x85\x05\x1b\x1c\n\xbd\x01\n\x04\x04\
    \x1d\x02\x02\x12\x04\x88\x05\x02\x10\x1a\xae\x01\x20A\x20recursive\x20de\
    finition\x20of\x20the\x20data\x20within\x20the\x20Region.\x20For\x20exam\
    ple,\x20this\x20will\x20contain\n\x20data.concepts\x20if\x20the\x20regio\
    n\x20also\x20has\x20annotations\x20or\x20predictions\x20of\x20concepts\
    \x20within\x20it.\n\n\r\n\x05\x04\x1d\x02\x02\x06\x12\x04\x88\x05\x02\
    \x06\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\x88\x05\x07\x0b\n\r\n\x05\x04\
    \x1d\x02\x02\x03\x12\x04\x88\x05\x0e\x0f\nC\n\x04\x04\x1d\x02\x03\x12\
    \x04\x8a\x05\x02\x12\x1a5\x20This\x20is\x20the\x20confidence\x20score\
    \x20of\x20the\x20overall\x20Region.\n\n\r\n\x05\x04\x1d\x02\x03\x05\x12\
    \x04\x8a\x05\x02\x07\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\x8a\x05\x08\r\
    \n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\x8a\x05\x10\x11\nc\n\x04\x04\x1d\
    \x02\x04\x12\x04\x8c\x05\x02\x16\x1aU\x20For\x20tracking\x20algorithsm\
    \x20and\x20annotations\x20we\x20tie\x20regions\x20together\x20with\x20th\
    is\x20track\x20id.\n\n\r\n\x05\x04\x1d\x02\x04\x05\x12\x04\x8c\x05\x02\
    \x08\n\r\n\x05\x04\x1d\x02\x04\x01\x12\x04\x8c\x05\t\x11\n\r\n\x05\x04\
    \x1d\x02\x04\x03\x12\x04\x8c\x05\x14\x15\n>\n\x02\x04\x1e\x12\x06\x90\
    \x05\0\xa2\x05\x01\x1a0\x20The\x20information\x20of\x20the\x20location\
    \x20of\x20the\x20Region.\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\x90\x05\x08\
    \x12\n\x0b\n\x03\x04\x1e\t\x12\x04\x91\x05\x02\x10\n\x0c\n\x04\x04\x1e\t\
    \0\x12\x04\x91\x05\x0b\x0c\n\r\n\x05\x04\x1e\t\0\x01\x12\x04\x91\x05\x0b\
    \x0c\n\r\n\x05\x04\x1e\t\0\x02\x12\x04\x91\x05\x0b\x0c\n\x0c\n\x04\x04\
    \x1e\t\x01\x12\x04\x91\x05\x0e\x0f\n\r\n\x05\x04\x1e\t\x01\x01\x12\x04\
    \x91\x05\x0e\x0f\n\r\n\x05\x04\x1e\t\x01\x02\x12\x04\x91\x05\x0e\x0f\nA\
    \n\x04\x04\x1e\x02\0\x12\x04\x94\x05\x02\x1f\x1a3\x20Details\x20of\x20th\
    e\x20region's\x20rectangular\x20bounding\x20box.\n\n\r\n\x05\x04\x1e\x02\
    \0\x06\x12\x04\x94\x05\x02\r\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x94\x05\
    \x0e\x1a\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x94\x05\x1d\x1e\n:\n\x04\
    \x04\x1e\x02\x01\x12\x04\x96\x05\x02\x10\x1a,\x20Details\x20of\x20the\
    \x20region's\x20segmentation\x20mask.\n\n\r\n\x05\x04\x1e\x02\x01\x06\
    \x12\x04\x96\x05\x02\x06\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\x96\x05\
    \x07\x0b\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\x96\x05\x0e\x0f\n$\n\x04\
    \x04\x1e\x02\x02\x12\x04\x98\x05\x02\x16\x1a\x16\x20A\x20polygon\x20of\
    \x20points.\n\n\r\n\x05\x04\x1e\x02\x02\x06\x12\x04\x98\x05\x02\t\n\r\n\
    \x05\x04\x1e\x02\x02\x01\x12\x04\x98\x05\n\x11\n\r\n\x05\x04\x1e\x02\x02\
    \x03\x12\x04\x98\x05\x14\x15\n*\n\x04\x04\x1e\x02\x03\x12\x04\x9a\x05\
    \x02\x12\x1a\x1c\x20A\x20landmark\x20point\x20location.\n\n\r\n\x05\x04\
    \x1e\x02\x03\x06\x12\x04\x9a\x05\x02\x07\n\r\n\x05\x04\x1e\x02\x03\x01\
    \x12\x04\x9a\x05\x08\r\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\x9a\x05\x10\
    \x11\n+\n\x04\x04\x1e\x02\x04\x12\x04\x9c\x05\x02\x10\x1a\x1d\x20Span\
    \x20char\x20sequence\x20for\x20NLP.\n\n\r\n\x05\x04\x1e\x02\x04\x06\x12\
    \x04\x9c\x05\x02\x06\n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\x9c\x05\x07\
    \x0b\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\x9c\x05\x0e\x0f\n,\n\x04\x04\
    \x1e\x02\x05\x12\x04\x9e\x05\x02\x12\x1a\x1e\x20Token\x20char\x20sequenc\
    e\x20for\x20NLP.\n\n\r\n\x05\x04\x1e\x02\x05\x06\x12\x04\x9e\x05\x02\x07\
    \n\r\n\x05\x04\x1e\x02\x05\x01\x12\x04\x9e\x05\x08\r\n\r\n\x05\x04\x1e\
    \x02\x05\x03\x12\x04\x9e\x05\x10\x11\n\xf7\x01\n\x04\x04\x1e\x02\x06\x12\
    \x04\xa1\x05\x02(\x1a\xe8\x01\x20The\x20locations\x20of\x20detected\x20k\
    eypoints,\x20which\x20are\x20to\x20be\x20used\x20in\x20conjunction\x20wi\
    th\x20the\x20detected\x20concept's\x20skeleton\x20to\x20connect\x20the\
    \x20keypoint\x20locations.\n\x20These\x20will\x20be\x20in\x20the\x20same\
    \x20order\x20as\x20the\x20respective\x20keypoint_names\x20inside\x20the\
    \x20concept.\n\n\r\n\x05\x04\x1e\x02\x06\x04\x12\x04\xa1\x05\x02\n\n\r\n\
    \x05\x04\x1e\x02\x06\x06\x12\x04\xa1\x05\x0b\x10\n\r\n\x05\x04\x1e\x02\
    \x06\x01\x12\x04\xa1\x05\x11#\n\r\n\x05\x04\x1e\x02\x06\x03\x12\x04\xa1\
    \x05&'\n6\n\x02\x04\x1f\x12\x06\xa5\x05\0\xae\x05\x01\x1a(\x20Rectangula\
    r\x20bounding\x20box\x20for\x20a\x20region.\n\n\x0b\n\x03\x04\x1f\x01\
    \x12\x04\xa5\x05\x08\x13\nf\n\x04\x04\x1f\x02\0\x12\x04\xa7\x05\x02C\x1a\
    X\x20The\x20top\x20left\x20of\x20the\x20bounding\x20box\x20normalized\
    \x20to\x20the\x20data\x20dimension\x20to\x20be\x20within\x20[0-1.0]\n\n\
    \r\n\x05\x04\x1f\x02\0\x05\x12\x04\xa7\x05\x02\x07\n\r\n\x05\x04\x1f\x02\
    \0\x01\x12\x04\xa7\x05\x08\x0f\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xa7\
    \x05\x12\x13\n\r\n\x05\x04\x1f\x02\0\x08\x12\x04\xa7\x05\x14B\n\x10\n\
    \x08\x04\x1f\x02\0\x08\xd0\x86\x03\x12\x04\xa7\x05\x15A\ni\n\x04\x04\x1f\
    \x02\x01\x12\x04\xa9\x05\x02D\x1a[\x20The\x20left\x20column\x20of\x20the\
    \x20bounding\x20box\x20normalized\x20to\x20the\x20data\x20dimension\x20t\
    o\x20be\x20within\x20[0-1.0]\n\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xa9\
    \x05\x02\x07\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xa9\x05\x08\x10\n\r\n\
    \x05\x04\x1f\x02\x01\x03\x12\x04\xa9\x05\x13\x14\n\r\n\x05\x04\x1f\x02\
    \x01\x08\x12\x04\xa9\x05\x15C\n\x10\n\x08\x04\x1f\x02\x01\x08\xd0\x86\
    \x03\x12\x04\xa9\x05\x16B\nh\n\x04\x04\x1f\x02\x02\x12\x04\xab\x05\x02F\
    \x1aZ\x20The\x20bottom\x20row\x20of\x20the\x20bounding\x20box\x20normali\
    zed\x20to\x20the\x20data\x20dimension\x20to\x20be\x20within\x20[0-1.0]\n\
    \n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xab\x05\x02\x07\n\r\n\x05\x04\x1f\
    \x02\x02\x01\x12\x04\xab\x05\x08\x12\n\r\n\x05\x04\x1f\x02\x02\x03\x12\
    \x04\xab\x05\x15\x16\n\r\n\x05\x04\x1f\x02\x02\x08\x12\x04\xab\x05\x17E\
    \n\x10\n\x08\x04\x1f\x02\x02\x08\xd0\x86\x03\x12\x04\xab\x05\x18D\ng\n\
    \x04\x04\x1f\x02\x03\x12\x04\xad\x05\x02E\x1aY\x20The\x20right\x20col\
    \x20of\x20the\x20bounding\x20box\x20normalized\x20to\x20the\x20data\x20d\
    imension\x20to\x20be\x20within\x20[0-1.0]\n\n\r\n\x05\x04\x1f\x02\x03\
    \x05\x12\x04\xad\x05\x02\x07\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\xad\
    \x05\x08\x11\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\xad\x05\x14\x15\n\r\n\
    \x05\x04\x1f\x02\x03\x08\x12\x04\xad\x05\x16D\n\x10\n\x08\x04\x1f\x02\
    \x03\x08\xd0\x86\x03\x12\x04\xad\x05\x17C\n=\n\x02\x04\x20\x12\x06\xb1\
    \x05\0\xba\x05\x01\x1a/\x20The\x20information\x20of\x20the\x20location\
    \x20of\x20the\x20Frame.\n\n\x0b\n\x03\x04\x20\x01\x12\x04\xb1\x05\x08\
    \x11\n\x89\x02\n\x04\x04\x20\x02\0\x12\x04\xb6\x05\x02U\x1a\xfa\x01\x20D\
    eprecated.\x20Use\x20Time\x20instead.\n\x20The\x20index\x20of\x20the\x20\
    frame,\x20informational\x20and\x20optional.\n\x20Depends\x20on\x20the\
    \x20sampling\x20rate\x20used\x20during\x20processing\n\x20May\x20be\x200\
    \x20for\x20interpolated\x20frames\x20that\x20are\x20generated\x20for\x20\
    brief\x20time\x20(training)\x20or\x20if\x20new\x20frame\x20is\x20manuall\
    y\x20added\n\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xb6\x05\x02\x08\n\r\n\
    \x05\x04\x20\x02\0\x01\x12\x04\xb6\x05\t\x0e\n\r\n\x05\x04\x20\x02\0\x03\
    \x12\x04\xb6\x05\x11\x12\n\r\n\x05\x04\x20\x02\0\x08\x12\x04\xb6\x05\x13\
    T\n\x10\n\x08\x04\x20\x02\0\x08\xd0\x86\x03\x12\x04\xb6\x05\x14@\n\x0e\n\
    \x06\x04\x20\x02\0\x08\x03\x12\x04\xb6\x05BS\nu\n\x04\x04\x20\x02\x01\
    \x12\x04\xb9\x05\x02A\x1ag\x20time\x20in\x20the\x20video\x20in\x20millis\
    econds.\x20This\x20is\x20independent\x20of\x20the\x20sampling\x20rates\
    \x20used\x20during\n\x20processing.\n\n\r\n\x05\x04\x20\x02\x01\x05\x12\
    \x04\xb9\x05\x02\x08\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xb9\x05\t\r\n\
    \r\n\x05\x04\x20\x02\x01\x03\x12\x04\xb9\x05\x10\x11\n\r\n\x05\x04\x20\
    \x02\x01\x08\x12\x04\xb9\x05\x12@\n\x10\n\x08\x04\x20\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xb9\x05\x13?\n<\n\x02\x04!\x12\x06\xbd\x05\0\xc7\x05\
    \x01\x1a.\x20A\x20Frame\x20of\x20time-series\x20Data\x20such\x20as\x20a\
    \x20Video.\n\n\x0b\n\x03\x04!\x01\x12\x04\xbd\x05\x08\r\n@\n\x04\x04!\
    \x02\0\x12\x04\xbf\x05\x02\x1b\x1a2\x20Information\x20aboue\x20frame\x20\
    such\x20as\x20number\x20and\x20time.\n\n\r\n\x05\x04!\x02\0\x06\x12\x04\
    \xbf\x05\x02\x0b\n\r\n\x05\x04!\x02\0\x01\x12\x04\xbf\x05\x0c\x16\n\r\n\
    \x05\x04!\x02\0\x03\x12\x04\xbf\x05\x19\x1a\n\xd5\x02\n\x04\x04!\x02\x01\
    \x12\x04\xc4\x05\x02\x10\x1a\xc6\x02\x20A\x20recursive\x20definition\x20\
    of\x20the\x20data\x20within\x20the\x20Frame.\x20For\x20example,\x20this\
    \x20will\x20contain\n\x20data.concepts\x20if\x20the\x20Frame\x20also\x20\
    has\x20annotations\x20or\x20predictions\x20of\x20concepts\x20within\x20i\
    t.\n\x20This\x20can\x20also\x20have\x20data.regions\x20for\x20annotation\
    \x20or\x20predictions\x20of\x20detection\x20regions,\x20which\x20can\n\
    \x20then\x20recursively\x20have\x20their\x20data\x20field\x20filled\x20i\
    n\x20as\x20well.\n\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xc4\x05\x02\x06\n\
    \r\n\x05\x04!\x02\x01\x01\x12\x04\xc4\x05\x07\x0b\n\r\n\x05\x04!\x02\x01\
    \x03\x12\x04\xc4\x05\x0e\x0f\n$\n\x04\x04!\x02\x02\x12\x04\xc6\x05\x02\
    \x10\x1a\x16\x20An\x20ID\x20for\x20the\x20frame.\n\n\r\n\x05\x04!\x02\
    \x02\x05\x12\x04\xc6\x05\x02\x08\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xc6\
    \x05\t\x0b\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xc6\x05\x0e\x0f\n\"\n\x02\
    \x04\"\x12\x06\xca\x05\0\xcf\x05\x01\x1a\x14\x20Segmentation\x20mask.\n\
    \n\x0b\n\x03\x04\"\x01\x12\x04\xca\x05\x08\x0c\n\x0b\n\x03\x04\"\t\x12\
    \x04\xcb\x05\x02\r\n\x0c\n\x04\x04\"\t\0\x12\x04\xcb\x05\x0b\x0c\n\r\n\
    \x05\x04\"\t\0\x01\x12\x04\xcb\x05\x0b\x0c\n\r\n\x05\x04\"\t\0\x02\x12\
    \x04\xcb\x05\x0b\x0c\n=\n\x04\x04\"\x02\0\x12\x04\xce\x05\x02\x12\x1a/\
    \x20The\x20image\x20of\x20the\x20mask\x20in\x20a\x20non-raster\x20format\
    .\n\n\r\n\x05\x04\"\x02\0\x06\x12\x04\xce\x05\x02\x07\n\r\n\x05\x04\"\
    \x02\0\x01\x12\x04\xce\x05\x08\r\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xce\
    \x05\x10\x11\n\x17\n\x02\x04#\x12\x06\xd2\x05\0\xd5\x05\x01\x1a\t\x20Pol\
    ygon\n\n\x0b\n\x03\x04#\x01\x12\x04\xd2\x05\x08\x0f\nH\n\x04\x04#\x02\0\
    \x12\x04\xd4\x05\x02\x1c\x1a:\x20A\x20list\x20of\x20points\x20connected\
    \x20together\x20to\x20form\x20the\x20polygon.\n\n\r\n\x05\x04#\x02\0\x04\
    \x12\x04\xd4\x05\x02\n\n\r\n\x05\x04#\x02\0\x06\x12\x04\xd4\x05\x0b\x10\
    \n\r\n\x05\x04#\x02\0\x01\x12\x04\xd4\x05\x11\x17\n\r\n\x05\x04#\x02\0\
    \x03\x12\x04\xd4\x05\x1a\x1b\n\x15\n\x02\x04$\x12\x06\xd8\x05\0\xe9\x05\
    \x01\x1a\x07\x20Point\n\n\x0b\n\x03\x04$\x01\x12\x04\xd8\x05\x08\r\n\x7f\
    \n\x04\x04$\x02\0\x12\x04\xdb\x05\x02?\x1aq\x20The\x20row\x20location\
    \x20of\x20the\x20point.\x20This\x20has\x20a\x20[0.0-1.0]\x20range\x20wit\
    h\x200.0\x20being\x20top\x20row\x20and\x201.0\n\x20being\x20the\x20botto\
    m\x20row.\n\n\r\n\x05\x04$\x02\0\x05\x12\x04\xdb\x05\x02\x07\n\r\n\x05\
    \x04$\x02\0\x01\x12\x04\xdb\x05\x08\x0b\n\r\n\x05\x04$\x02\0\x03\x12\x04\
    \xdb\x05\x0e\x0f\n\r\n\x05\x04$\x02\0\x08\x12\x04\xdb\x05\x10>\n\x10\n\
    \x08\x04$\x02\0\x08\xd0\x86\x03\x12\x04\xdb\x05\x11=\n\x82\x01\n\x04\x04\
    $\x02\x01\x12\x04\xde\x05\x02?\x1at\x20The\x20column\x20location\x20of\
    \x20the\x20point.\x20This\x20has\x20a\x20[0.0-1.0]\x20range\x20with\x200\
    .0\x20being\x20left\x20col\x20and\x201.0\n\x20being\x20the\x20right\x20c\
    ol.\n\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xde\x05\x02\x07\n\r\n\x05\x04$\
    \x02\x01\x01\x12\x04\xde\x05\x08\x0b\n\r\n\x05\x04$\x02\x01\x03\x12\x04\
    \xde\x05\x0e\x0f\n\r\n\x05\x04$\x02\x01\x08\x12\x04\xde\x05\x10>\n\x10\n\
    \x08\x04$\x02\x01\x08\xd0\x86\x03\x12\x04\xde\x05\x11=\n2\n\x04\x04$\x02\
    \x02\x12\x04\xe0\x05\x02\x0e\x1a$\x20Depth\x20if\x20applicable\x20for\
    \x20the\x20point.\n\n\r\n\x05\x04$\x02\x02\x05\x12\x04\xe0\x05\x02\x07\n\
    \r\n\x05\x04$\x02\x02\x01\x12\x04\xe0\x05\x08\t\n\r\n\x05\x04$\x02\x02\
    \x03\x12\x04\xe0\x05\x0c\r\n;\n\x04\x04$\x04\0\x12\x06\xe2\x05\x02\xe7\
    \x05\x03\x1a+\x20Whether\x20this\x20point\x20is\x20visible\x20or\x20occl\
    uded\n\n\r\n\x05\x04$\x04\0\x01\x12\x04\xe2\x05\x07\x11\n4\n\x06\x04$\
    \x04\0\x02\0\x12\x04\xe3\x05\x04\x10\"$\x20Visibility\x20of\x20the\x20po\
    int\x20is\x20not\x20set\n\n\x0f\n\x07\x04$\x04\0\x02\0\x01\x12\x04\xe3\
    \x05\x04\x0b\n\x0f\n\x07\x04$\x04\0\x02\0\x02\x12\x04\xe3\x05\x0e\x0f\n\
    \"\n\x06\x04$\x04\0\x02\x01\x12\x04\xe4\x05\x04\x10\"\x12\x20Point\x20is\
    \x20visible\n\n\x0f\n\x07\x04$\x04\0\x02\x01\x01\x12\x04\xe4\x05\x04\x0b\
    \n\x0f\n\x07\x04$\x04\0\x02\x01\x02\x12\x04\xe4\x05\x0e\x0f\n#\n\x06\x04\
    $\x04\0\x02\x02\x12\x04\xe5\x05\x04\x14\"\x13\x20Point\x20is\x20occluded\
    \n\n\x0f\n\x07\x04$\x04\0\x02\x02\x01\x12\x04\xe5\x05\x04\x0f\n\x0f\n\
    \x07\x04$\x04\0\x02\x02\x02\x12\x04\xe5\x05\x12\x13\n+\n\x06\x04$\x04\0\
    \x02\x03\x12\x04\xe6\x05\x04\x14\"\x1b\x20Point\x20is\x20not\x20in\x20th\
    e\x20image\n\n\x0f\n\x07\x04$\x04\0\x02\x03\x01\x12\x04\xe6\x05\x04\x0f\
    \n\x0f\n\x07\x04$\x04\0\x02\x03\x02\x12\x04\xe6\x05\x12\x13\n\x0c\n\x04\
    \x04$\x02\x03\x12\x04\xe8\x05\x02\x1c\n\r\n\x05\x04$\x02\x03\x06\x12\x04\
    \xe8\x05\x02\x0c\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xe8\x05\r\x17\n\r\n\
    \x05\x04$\x02\x03\x03\x12\x04\xe8\x05\x1a\x1b\n\x0c\n\x02\x04%\x12\x06\
    \xeb\x05\0\xef\x05\x01\n\x0b\n\x03\x04%\x01\x12\x04\xeb\x05\x08\x0c\n\
    \x0c\n\x04\x04%\x02\0\x12\x04\xec\x05\x02G\n\r\n\x05\x04%\x02\0\x05\x12\
    \x04\xec\x05\x02\x08\n\r\n\x05\x04%\x02\0\x01\x12\x04\xec\x05\t\x13\n\r\
    \n\x05\x04%\x02\0\x03\x12\x04\xec\x05\x16\x17\n\r\n\x05\x04%\x02\0\x08\
    \x12\x04\xec\x05\x18F\n\x10\n\x08\x04%\x02\0\x08\xd0\x86\x03\x12\x04\xec\
    \x05\x19E\n\x0c\n\x04\x04%\x02\x01\x12\x04\xed\x05\x02E\n\r\n\x05\x04%\
    \x02\x01\x05\x12\x04\xed\x05\x02\x08\n\r\n\x05\x04%\x02\x01\x01\x12\x04\
    \xed\x05\t\x11\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xed\x05\x14\x15\n\r\n\
    \x05\x04%\x02\x01\x08\x12\x04\xed\x05\x16D\n\x10\n\x08\x04%\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xed\x05\x17C\n\x0c\n\x04\x04%\x02\x02\x12\x04\xee\
    \x05\x02\x16\n\r\n\x05\x04%\x02\x02\x05\x12\x04\xee\x05\x02\x08\n\r\n\
    \x05\x04%\x02\x02\x01\x12\x04\xee\x05\t\x11\n\r\n\x05\x04%\x02\x02\x03\
    \x12\x04\xee\x05\x14\x15\n\x0c\n\x02\x04&\x12\x06\xf1\x05\0\xf5\x05\x01\
    \n\x0b\n\x03\x04&\x01\x12\x04\xf1\x05\x08\r\n\x0c\n\x04\x04&\x02\0\x12\
    \x04\xf2\x05\x02G\n\r\n\x05\x04&\x02\0\x05\x12\x04\xf2\x05\x02\x08\n\r\n\
    \x05\x04&\x02\0\x01\x12\x04\xf2\x05\t\x13\n\r\n\x05\x04&\x02\0\x03\x12\
    \x04\xf2\x05\x16\x17\n\r\n\x05\x04&\x02\0\x08\x12\x04\xf2\x05\x18F\n\x10\
    \n\x08\x04&\x02\0\x08\xd0\x86\x03\x12\x04\xf2\x05\x19E\n\x0c\n\x04\x04&\
    \x02\x01\x12\x04\xf3\x05\x02E\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xf3\x05\
    \x02\x08\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xf3\x05\t\x11\n\r\n\x05\x04&\
    \x02\x01\x03\x12\x04\xf3\x05\x14\x15\n\r\n\x05\x04&\x02\x01\x08\x12\x04\
    \xf3\x05\x16D\n\x10\n\x08\x04&\x02\x01\x08\xd0\x86\x03\x12\x04\xf3\x05\
    \x17C\n\x0c\n\x04\x04&\x02\x02\x12\x04\xf4\x05\x02\x16\n\r\n\x05\x04&\
    \x02\x02\x05\x12\x04\xf4\x05\x02\x08\n\r\n\x05\x04&\x02\x02\x01\x12\x04\
    \xf4\x05\t\x11\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xf4\x05\x14\x15\n\x19\
    \n\x02\x04'\x12\x06\xf8\x05\0\xfb\x05\x01\x1a\x0b\x20Embedding\n\n\x0b\n\
    \x03\x04'\x01\x12\x04\xf8\x05\x08\x11\n\x0c\n\x04\x04'\x02\0\x12\x04\xf9\
    \x05\x02,\n\r\n\x05\x04'\x02\0\x04\x12\x04\xf9\x05\x02\n\n\r\n\x05\x04'\
    \x02\0\x05\x12\x04\xf9\x05\x0b\x10\n\r\n\x05\x04'\x02\0\x01\x12\x04\xf9\
    \x05\x11\x17\n\r\n\x05\x04'\x02\0\x03\x12\x04\xf9\x05\x1a\x1b\n\r\n\x05\
    \x04'\x02\0\x08\x12\x04\xf9\x05\x1c+\n\x0e\n\x06\x04'\x02\0\x08\x02\x12\
    \x04\xf9\x05\x1d*\n\x0c\n\x04\x04'\x02\x01\x12\x04\xfa\x05\x02\x1c\n\r\n\
    \x05\x04'\x02\x01\x05\x12\x04\xfa\x05\x02\x08\n\r\n\x05\x04'\x02\x01\x01\
    \x12\x04\xfa\x05\t\x17\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xfa\x05\x1a\
    \x1b\n\x18\n\x02\x04(\x12\x06\xfe\x05\0\x81\x06\x01\x1a\n\x20GeoPoint\n\
    \n\x0b\n\x03\x04(\x01\x12\x04\xfe\x05\x08\x10\n\x0c\n\x04\x04(\x02\0\x12\
    \x04\xff\x05\x02E\n\r\n\x05\x04(\x02\0\x05\x12\x04\xff\x05\x02\x07\n\r\n\
    \x05\x04(\x02\0\x01\x12\x04\xff\x05\x08\x11\n\r\n\x05\x04(\x02\0\x03\x12\
    \x04\xff\x05\x14\x15\n\r\n\x05\x04(\x02\0\x08\x12\x04\xff\x05\x16D\n\x10\
    \n\x08\x04(\x02\0\x08\xd0\x86\x03\x12\x04\xff\x05\x17C\n\x0c\n\x04\x04(\
    \x02\x01\x12\x04\x80\x06\x02D\n\r\n\x05\x04(\x02\x01\x05\x12\x04\x80\x06\
    \x02\x07\n\r\n\x05\x04(\x02\x01\x01\x12\x04\x80\x06\x08\x10\n\r\n\x05\
    \x04(\x02\x01\x03\x12\x04\x80\x06\x13\x14\n\r\n\x05\x04(\x02\x01\x08\x12\
    \x04\x80\x06\x15C\n\x10\n\x08\x04(\x02\x01\x08\xd0\x86\x03\x12\x04\x80\
    \x06\x16B\n\x18\n\x02\x04)\x12\x06\x84\x06\0\x87\x06\x01\x1a\n\x20GeoLim\
    it\n\n\x0b\n\x03\x04)\x01\x12\x04\x84\x06\x08\x10\n\x0c\n\x04\x04)\x02\0\
    \x12\x04\x85\x06\x02\x12\n\r\n\x05\x04)\x02\0\x05\x12\x04\x85\x06\x02\
    \x08\n\r\n\x05\x04)\x02\0\x01\x12\x04\x85\x06\t\r\n\r\n\x05\x04)\x02\0\
    \x03\x12\x04\x85\x06\x10\x11\n\x0c\n\x04\x04)\x02\x01\x12\x04\x86\x06\
    \x02A\n\r\n\x05\x04)\x02\x01\x05\x12\x04\x86\x06\x02\x07\n\r\n\x05\x04)\
    \x02\x01\x01\x12\x04\x86\x06\x08\r\n\r\n\x05\x04)\x02\x01\x03\x12\x04\
    \x86\x06\x10\x11\n\r\n\x05\x04)\x02\x01\x08\x12\x04\x86\x06\x12@\n\x10\n\
    \x08\x04)\x02\x01\x08\xd0\x86\x03\x12\x04\x86\x06\x13?\n\x1b\n\x02\x04*\
    \x12\x04\x8a\x06\01\x1a\x0f\x20GeoBoxedPoint\n\n\x0b\n\x03\x04*\x01\x12\
    \x04\x8a\x06\x08\x15\n\x0c\n\x04\x04*\x02\0\x12\x04\x8a\x06\x18/\n\r\n\
    \x05\x04*\x02\0\x06\x12\x04\x8a\x06\x18\x20\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\x8a\x06!*\n\r\n\x05\x04*\x02\0\x03\x12\x04\x8a\x06-.\n\x13\n\x02\
    \x04+\x12\x06\x8d\x06\0\x92\x06\x01\x1a\x05\x20Geo\n\n\x0b\n\x03\x04+\
    \x01\x12\x04\x8d\x06\x08\x0b\n\x0c\n\x04\x04+\x02\0\x12\x04\x8e\x06\x02\
    \x19\n\r\n\x05\x04+\x02\0\x06\x12\x04\x8e\x06\x02\n\n\r\n\x05\x04+\x02\0\
    \x01\x12\x04\x8e\x06\x0b\x14\n\r\n\x05\x04+\x02\0\x03\x12\x04\x8e\x06\
    \x17\x18\n\x0c\n\x04\x04+\x02\x01\x12\x04\x8f\x06\x02\x19\n\r\n\x05\x04+\
    \x02\x01\x06\x12\x04\x8f\x06\x02\n\n\r\n\x05\x04+\x02\x01\x01\x12\x04\
    \x8f\x06\x0b\x14\n\r\n\x05\x04+\x02\x01\x03\x12\x04\x8f\x06\x17\x18\nF\n\
    \x04\x04+\x02\x02\x12\x04\x91\x06\x02%\x1a8\x20NOTE:\x20inconsistency:\
    \x20should\x20have\x20been\x20geo_boxed_points\n\n\r\n\x05\x04+\x02\x02\
    \x04\x12\x04\x91\x06\x02\n\n\r\n\x05\x04+\x02\x02\x06\x12\x04\x91\x06\
    \x0b\x18\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x91\x06\x19\x20\n\r\n\x05\
    \x04+\x02\x02\x03\x12\x04\x91\x06#$\n\x15\n\x02\x04,\x12\x06\x95\x06\0\
    \xa8\x06\x01\x1a\x07\x20Image\n\n\x0b\n\x03\x04,\x01\x12\x04\x95\x06\x08\
    \r\n\x0b\n\x03\x04,\t\x12\x04\x96\x06\x02\r\n\x0c\n\x04\x04,\t\0\x12\x04\
    \x96\x06\x0b\x0c\n\r\n\x05\x04,\t\0\x01\x12\x04\x96\x06\x0b\x0c\n\r\n\
    \x05\x04,\t\0\x02\x12\x04\x96\x06\x0b\x0c\n\x86\x01\n\x04\x04,\x02\0\x12\
    \x04\x9a\x06\x02\x11\x1ax\x20This\x20is\x20a\x20URL\x20to\x20a\x20public\
    ly\x20accessible\x20image\x20file.\x20The\x20platform\x20will\x20downloa\
    d\x20this\x20file\x20server\n\x20side\x20and\x20then\x20process.\n\n\r\n\
    \x05\x04,\x02\0\x05\x12\x04\x9a\x06\x02\x08\n\r\n\x05\x04,\x02\0\x01\x12\
    \x04\x9a\x06\t\x0c\n\r\n\x05\x04,\x02\0\x03\x12\x04\x9a\x06\x0f\x10\n\
    \x90\x03\n\x04\x04,\x02\x01\x12\x04\xa1\x06\x02\x13\x1a\x81\x03\x20The\
    \x20base64\x20field\x20is\x20using\x20image\x20file\x20bytes\x20directly\
    \x20in\x20the\x20request.\n\x20NOTE:\x20if\x20you're\x20sending\x20a\x20\
    json\x20request,\x20then\x20this\x20MUST\x20be\x20base64\x20encoded\x20b\
    efore\x20sending\x20(hence\n\x20the\x20name\x20here).\n\x20When\x20using\
    \x20our\x20grpc\x20clients,\x20you\x20DO\x20NOT\x20need\x20to\x20base64\
    \x20encode\n\x20it\x20yourself\x20since\x20the\x20clients\x20know\x20how\
    \x20to\x20do\x20this\x20for\x20you\x20automatically\x20and\x20will\x20av\
    oid\x20the\n\x20base64\x20encoding\x20if\x20they\x20send\x20a\x20binary\
    \x20request.\n\n\r\n\x05\x04,\x02\x01\x05\x12\x04\xa1\x06\x02\x07\n\r\n\
    \x05\x04,\x02\x01\x01\x12\x04\xa1\x06\x08\x0e\n\r\n\x05\x04,\x02\x01\x03\
    \x12\x04\xa1\x06\x11\x12\n\x0c\n\x04\x04,\x02\x02\x12\x04\xa3\x06\x02\
    \x1f\n\r\n\x05\x04,\x02\x02\x05\x12\x04\xa3\x06\x02\x06\n\r\n\x05\x04,\
    \x02\x02\x01\x12\x04\xa3\x06\x07\x1a\n\r\n\x05\x04,\x02\x02\x03\x12\x04\
    \xa3\x06\x1d\x1e\n\\\n\x04\x04,\x02\x03\x12\x04\xa5\x06\x02\x17\x1aN\x20\
    The\x20hosted\x20field\x20lists\x20images\x20in\x20different\x20sizes\
    \x20hosted\x20in\x20Clarifai\x20storage.\n\n\r\n\x05\x04,\x02\x03\x06\
    \x12\x04\xa5\x06\x02\x0b\n\r\n\x05\x04,\x02\x03\x01\x12\x04\xa5\x06\x0c\
    \x12\n\r\n\x05\x04,\x02\x03\x03\x12\x04\xa5\x06\x15\x16\n\x1a\n\x04\x04,\
    \x02\x04\x12\x04\xa7\x06\x02\x1b\x1a\x0c\x20image\x20info\n\n\r\n\x05\
    \x04,\x02\x04\x06\x12\x04\xa7\x06\x02\x0b\n\r\n\x05\x04,\x02\x04\x01\x12\
    \x04\xa7\x06\x0c\x16\n\r\n\x05\x04,\x02\x04\x03\x12\x04\xa7\x06\x19\x1a\
    \n\x0c\n\x02\x04-\x12\x06\xaa\x06\0\xb3\x06\x01\n\x0b\n\x03\x04-\x01\x12\
    \x04\xaa\x06\x08\x11\n\x15\n\x04\x04-\x02\0\x12\x04\xac\x06\x02\x12\x1a\
    \x07\x20width\n\n\r\n\x05\x04-\x02\0\x05\x12\x04\xac\x06\x02\x07\n\r\n\
    \x05\x04-\x02\0\x01\x12\x04\xac\x06\x08\r\n\r\n\x05\x04-\x02\0\x03\x12\
    \x04\xac\x06\x10\x11\n\x16\n\x04\x04-\x02\x01\x12\x04\xae\x06\x02\x13\
    \x1a\x08\x20height\n\n\r\n\x05\x04-\x02\x01\x05\x12\x04\xae\x06\x02\x07\
    \n\r\n\x05\x04-\x02\x01\x01\x12\x04\xae\x06\x08\x0e\n\r\n\x05\x04-\x02\
    \x01\x03\x12\x04\xae\x06\x11\x12\n\x1c\n\x04\x04-\x02\x02\x12\x04\xb0\
    \x06\x02\x14\x1a\x0e\x20image\x20format\n\n\r\n\x05\x04-\x02\x02\x05\x12\
    \x04\xb0\x06\x02\x08\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xb0\x06\t\x0f\n\
    \r\n\x05\x04-\x02\x02\x03\x12\x04\xb0\x06\x12\x13\n\x20\n\x04\x04-\x02\
    \x03\x12\x04\xb2\x06\x02\x18\x1a\x12\x20image\x20color\x20mode\n\n\r\n\
    \x05\x04-\x02\x03\x05\x12\x04\xb2\x06\x02\x08\n\r\n\x05\x04-\x02\x03\x01\
    \x12\x04\xb2\x06\t\x13\n\r\n\x05\x04-\x02\x03\x03\x12\x04\xb2\x06\x16\
    \x17\n\x19\n\x02\x04.\x12\x06\xb6\x06\0\xc1\x06\x01\x1a\x0b\x20HostedURL\
    \n\n\x0b\n\x03\x04.\x01\x12\x04\xb6\x06\x08\x11\n8\n\x04\x04.\x02\0\x12\
    \x04\xb8\x06\x02\x14\x1a*\x20Prefix\x20of\x20the\x20URL\x20of\x20every\
    \x20hosted\x20image.\n\n\r\n\x05\x04.\x02\0\x05\x12\x04\xb8\x06\x02\x08\
    \n\r\n\x05\x04.\x02\0\x01\x12\x04\xb8\x06\t\x0f\n\r\n\x05\x04.\x02\0\x03\
    \x12\x04\xb8\x06\x12\x13\n=\n\x04\x04.\x02\x01\x12\x04\xba\x06\x02\x14\
    \x1a/\x20Suffix\x20of\x20an\x20image\x20stored\x20in\x20different\x20siz\
    es.\n\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xba\x06\x02\x08\n\r\n\x05\x04.\
    \x02\x01\x01\x12\x04\xba\x06\t\x0f\n\r\n\x05\x04.\x02\x01\x03\x12\x04\
    \xba\x06\x12\x13\n\xc7\x01\n\x04\x04.\x02\x02\x12\x04\xbd\x06\x02\x1c\
    \x1a\xb8\x01\x20The\x20sizes\x20field\x20lists\x20which\x20images\x20of\
    \x20the\x20different\x20sizes\x20are\x20hosted\x20in\x20our\x20storage.\
    \x20The\x20URL\n\x20of\x20each\x20hosted\x20image\x20can\x20be\x20obtain\
    ed\x20by\x20joining\x20the\x20prefix,\x20one\x20of\x20the\x20sizes\x20an\
    d\x20suffix.\n\n\r\n\x05\x04.\x02\x02\x04\x12\x04\xbd\x06\x02\n\n\r\n\
    \x05\x04.\x02\x02\x05\x12\x04\xbd\x06\x0b\x11\n\r\n\x05\x04.\x02\x02\x01\
    \x12\x04\xbd\x06\x12\x17\n\r\n\x05\x04.\x02\x02\x03\x12\x04\xbd\x06\x1a\
    \x1b\n}\n\x04\x04.\x02\x03\x12\x04\xc0\x06\x02\x19\x1ao\x20The\x20crosso\
    rigin\x20property\x20of\x20html\x20media\x20tag\n\x20For\x20Secure\x20Da\
    ta\x20Hosting\x20this\x20needs\x20to\x20be\x20set\x20to\x20'use-credenti\
    als'\n\n\r\n\x05\x04.\x02\x03\x05\x12\x04\xc0\x06\x02\x08\n\r\n\x05\x04.\
    \x02\x03\x01\x12\x04\xc0\x06\t\x14\n\r\n\x05\x04.\x02\x03\x03\x12\x04\
    \xc0\x06\x17\x18\n\x15\n\x02\x04/\x12\x06\xc4\x06\0\xe1\x06\x01\x1a\x07\
    \x20Input\n\n\x0b\n\x03\x04/\x01\x12\x04\xc4\x06\x08\r\n\x0b\n\x03\x04/\
    \t\x12\x04\xc5\x06\x02\r\n\x0c\n\x04\x04/\t\0\x12\x04\xc5\x06\x0b\x0c\n\
    \r\n\x05\x04/\t\0\x01\x12\x04\xc5\x06\x0b\x0c\n\r\n\x05\x04/\t\0\x02\x12\
    \x04\xc5\x06\x0b\x0c\n$\n\x04\x04/\x02\0\x12\x04\xc8\x06\x02\x10\x1a\x16\
    \x20The\x20ID\x20for\x20the\x20input\n\n\r\n\x05\x04/\x02\0\x05\x12\x04\
    \xc8\x06\x02\x08\n\r\n\x05\x04/\x02\0\x01\x12\x04\xc8\x06\t\x0b\n\r\n\
    \x05\x04/\x02\0\x03\x12\x04\xc8\x06\x0e\x0f\n4\n\x04\x04/\x02\x01\x12\
    \x04\xcb\x06\x02\x10\x1a&\x20The\x20data\x20passed\x20along\x20in\x20thi\
    s\x20input.\n\n\r\n\x05\x04/\x02\x01\x06\x12\x04\xcb\x06\x02\x06\n\r\n\
    \x05\x04/\x02\x01\x01\x12\x04\xcb\x06\x07\x0b\n\r\n\x05\x04/\x02\x01\x03\
    \x12\x04\xcb\x06\x0e\x0f\n\x80\x02\n\x04\x04/\x02\x02\x12\x04\xd2\x06\
    \x02+\x1a\xf1\x01\x20When\x20the\x20input\x20was\x20created.\x20We\x20fo\
    llow\x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\x20https://ww\
    w.ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15:04:05.999999Z\
    \"\x20so\x20you\x20can\x20expect\x20results\x20like\n\x20the\x20followin\
    g\x20from\x20the\x20API:\n\x20\"2017-04-11T21:50:50.223962Z\"\n\n\r\n\
    \x05\x04/\x02\x02\x06\x12\x04\xd2\x06\x02\x1b\n\r\n\x05\x04/\x02\x02\x01\
    \x12\x04\xd2\x06\x1c&\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xd2\x06)*\n,\n\
    \x04\x04/\x02\x03\x12\x04\xd5\x06\x02,\x1a\x1e\x20When\x20the\x20input\
    \x20was\x20modified.\n\n\r\n\x05\x04/\x02\x03\x06\x12\x04\xd5\x06\x02\
    \x1b\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xd5\x06\x1c'\n\r\n\x05\x04/\x02\
    \x03\x03\x12\x04\xd5\x06*+\n[\n\x04\x04/\x02\x04\x12\x04\xd9\x06\x02(\
    \x1aM\x20This\x20is\x20the\x20status\x20at\x20a\x20per\x20Input\x20level\
    \x20which\x20allows\x20for\n\x20partial\x20failures.\n\n\r\n\x05\x04/\
    \x02\x04\x06\x12\x04\xd9\x06\x02\x1c\n\r\n\x05\x04/\x02\x04\x01\x12\x04\
    \xd9\x06\x1d#\n\r\n\x05\x04/\x02\x04\x03\x12\x04\xd9\x06&'\n\x85\x03\n\
    \x04\x04/\x02\x05\x12\x04\xe0\x06\x02\"\x1a\xf6\x02\x20List\x20of\x20dat\
    aset\x20IDs\x20that\x20this\x20input\x20is\x20part\x20of\n\x20Currently,\
    \x20this\x20field\x20is\x20ONLY\x20used\x20to\n\x20*\x20search\x20inputs\
    \x20part\x20of\x20dataset(s),\x20e.g.\x20in\x20`PostSearches`,\x20`PostI\
    nputsSearches`\x20and\x20`PostAnnotationsSearches`\x20endpoints,\x20and\
    \n\x20*\x20to\x20add\x20inputs\x20to\x20dataset(s)\x20in\x20`PostInputs`\
    \x20endpoint.\n\x20Note\x20that\x20this\x20field\x20is\x20ignored\x20for\
    \x20other\x20endpoints,\x20e.g.\x20`GetInput`,\x20`ListInputs`\x20and\
    \x20`PatchInputs`.\n\n\r\n\x05\x04/\x02\x05\x04\x12\x04\xe0\x06\x02\n\n\
    \r\n\x05\x04/\x02\x05\x05\x12\x04\xe0\x06\x0b\x11\n\r\n\x05\x04/\x02\x05\
    \x01\x12\x04\xe0\x06\x12\x1d\n\r\n\x05\x04/\x02\x05\x03\x12\x04\xe0\x06\
    \x20!\n\x80\x01\n\x02\x040\x12\x04\xe5\x06\01\x1at\x20InputBatch\x20is\
    \x20a\x20batch\x20of\x20Input\x20resources.\x20Large\x20amounts\x20of\
    \x20inputs\x20are\x20usually\n\x20divided\x20into\x20multiple\x20InputBa\
    tches.\n\n\x0b\n\x03\x040\x01\x12\x04\xe5\x06\x08\x12\n\x0c\n\x04\x040\
    \x02\0\x12\x04\xe5\x06\x15/\n\r\n\x05\x040\x02\0\x04\x12\x04\xe5\x06\x15\
    \x1d\n\r\n\x05\x040\x02\0\x06\x12\x04\xe5\x06\x1e#\n\r\n\x05\x040\x02\0\
    \x01\x12\x04\xe5\x06$*\n\r\n\x05\x040\x02\0\x03\x12\x04\xe5\x06-.\nT\n\
    \x02\x041\x12\x06\xe8\x06\0\xf1\x06\x01\x1aF\x20NOTE:\x20inconsistency:\
    \x20this\x20is\x20weird\x20mix\x20of\x20plural\x20and\x20singular\x20wor\
    ds.\n\n\x0b\n\x03\x041\x01\x12\x04\xe8\x06\x08\x12\n\x0c\n\x04\x041\x02\
    \0\x12\x04\xe9\x06\x02F\n\r\n\x05\x041\x02\0\x05\x12\x04\xe9\x06\x02\x08\
    \n\r\n\x05\x041\x02\0\x01\x12\x04\xe9\x06\t\x12\n\r\n\x05\x041\x02\0\x03\
    \x12\x04\xe9\x06\x15\x16\n\r\n\x05\x041\x02\0\x08\x12\x04\xe9\x06\x17E\n\
    \x10\n\x08\x041\x02\0\x08\xd0\x86\x03\x12\x04\xe9\x06\x18D\n\x0c\n\x04\
    \x041\x02\x01\x12\x04\xea\x06\x02G\n\r\n\x05\x041\x02\x01\x05\x12\x04\
    \xea\x06\x02\x08\n\r\n\x05\x041\x02\x01\x01\x12\x04\xea\x06\t\x13\n\r\n\
    \x05\x041\x02\x01\x03\x12\x04\xea\x06\x16\x17\n\r\n\x05\x041\x02\x01\x08\
    \x12\x04\xea\x06\x18F\n\x10\n\x08\x041\x02\x01\x08\xd0\x86\x03\x12\x04\
    \xea\x06\x19E\n\x0c\n\x04\x041\x02\x02\x12\x04\xeb\x06\x02C\n\r\n\x05\
    \x041\x02\x02\x05\x12\x04\xeb\x06\x02\x08\n\r\n\x05\x041\x02\x02\x01\x12\
    \x04\xeb\x06\t\x0f\n\r\n\x05\x041\x02\x02\x03\x12\x04\xeb\x06\x12\x13\n\
    \r\n\x05\x041\x02\x02\x08\x12\x04\xeb\x06\x14B\n\x10\n\x08\x041\x02\x02\
    \x08\xd0\x86\x03\x12\x04\xeb\x06\x15A\n\x0c\n\x04\x041\x02\x03\x12\x04\
    \xec\x06\x02G\n\r\n\x05\x041\x02\x03\x05\x12\x04\xec\x06\x02\x08\n\r\n\
    \x05\x041\x02\x03\x01\x12\x04\xec\x06\t\x13\n\r\n\x05\x041\x02\x03\x03\
    \x12\x04\xec\x06\x16\x17\n\r\n\x05\x041\x02\x03\x08\x12\x04\xec\x06\x18F\
    \n\x10\n\x08\x041\x02\x03\x08\xd0\x86\x03\x12\x04\xec\x06\x19E\n\x0c\n\
    \x04\x041\x02\x04\x12\x04\xed\x06\x02F\n\r\n\x05\x041\x02\x04\x05\x12\
    \x04\xed\x06\x02\x08\n\r\n\x05\x041\x02\x04\x01\x12\x04\xed\x06\t\x12\n\
    \r\n\x05\x041\x02\x04\x03\x12\x04\xed\x06\x15\x16\n\r\n\x05\x041\x02\x04\
    \x08\x12\x04\xed\x06\x17E\n\x10\n\x08\x041\x02\x04\x08\xd0\x86\x03\x12\
    \x04\xed\x06\x18D\n\x0c\n\x04\x041\x02\x05\x12\x04\xee\x06\x02G\n\r\n\
    \x05\x041\x02\x05\x05\x12\x04\xee\x06\x02\x08\n\r\n\x05\x041\x02\x05\x01\
    \x12\x04\xee\x06\t\x13\n\r\n\x05\x041\x02\x05\x03\x12\x04\xee\x06\x16\
    \x17\n\r\n\x05\x041\x02\x05\x08\x12\x04\xee\x06\x18F\n\x10\n\x08\x041\
    \x02\x05\x08\xd0\x86\x03\x12\x04\xee\x06\x19E\n\x0c\n\x04\x041\x02\x06\
    \x12\x04\xef\x06\x02K\n\r\n\x05\x041\x02\x06\x05\x12\x04\xef\x06\x02\x08\
    \n\r\n\x05\x041\x02\x06\x01\x12\x04\xef\x06\t\x17\n\r\n\x05\x041\x02\x06\
    \x03\x12\x04\xef\x06\x1a\x1b\n\r\n\x05\x041\x02\x06\x08\x12\x04\xef\x06\
    \x1cJ\n\x10\n\x08\x041\x02\x06\x08\xd0\x86\x03\x12\x04\xef\x06\x1dI\n\
    \x0c\n\x04\x041\x02\x07\x12\x04\xf0\x06\x02G\n\r\n\x05\x041\x02\x07\x05\
    \x12\x04\xf0\x06\x02\x08\n\r\n\x05\x041\x02\x07\x01\x12\x04\xf0\x06\t\
    \x13\n\r\n\x05\x041\x02\x07\x03\x12\x04\xf0\x06\x16\x17\n\r\n\x05\x041\
    \x02\x07\x08\x12\x04\xf0\x06\x18F\n\x10\n\x08\x041\x02\x07\x08\xd0\x86\
    \x03\x12\x04\xf0\x06\x19E\n\x17\n\x02\x042\x12\x06\xf4\x06\0\xae\x07\x01\
    \x1a\t\x20Dataset\n\n\x0b\n\x03\x042\x01\x12\x04\xf4\x06\x08\x0f\n\x0b\n\
    \x03\x042\t\x12\x04\xf5\x06\x02\x11\n\x0c\n\x04\x042\t\0\x12\x04\xf5\x06\
    \x0b\x0c\n\r\n\x05\x042\t\0\x01\x12\x04\xf5\x06\x0b\x0c\n\r\n\x05\x042\t\
    \0\x02\x12\x04\xf5\x06\x0b\x0c\n\x0c\n\x04\x042\t\x01\x12\x04\xf5\x06\
    \x0e\x10\n\r\n\x05\x042\t\x01\x01\x12\x04\xf5\x06\x0e\x10\n\r\n\x05\x042\
    \t\x01\x02\x12\x04\xf5\x06\x0e\x10\n&\n\x04\x042\x02\0\x12\x04\xf8\x06\
    \x02\x10\x1a\x18\x20The\x20ID\x20for\x20the\x20dataset\n\n\r\n\x05\x042\
    \x02\0\x05\x12\x04\xf8\x06\x02\x08\n\r\n\x05\x042\x02\0\x01\x12\x04\xf8\
    \x06\t\x0b\n\r\n\x05\x042\x02\0\x03\x12\x04\xf8\x06\x0e\x0f\n\x8b\x01\n\
    \x04\x042\x02\x01\x12\x04\xfd\x06\x02+\x1a}\x20When\x20the\x20dataset\
    \x20was\x20created.\n\x20The\x20format\x20is\x20https://www.ietf.org/rfc\
    /rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\r\n\
    \x05\x042\x02\x01\x06\x12\x04\xfd\x06\x02\x1b\n\r\n\x05\x042\x02\x01\x01\
    \x12\x04\xfd\x06\x1c&\n\r\n\x05\x042\x02\x01\x03\x12\x04\xfd\x06)*\n\x8c\
    \x01\n\x04\x042\x02\x02\x12\x04\x82\x07\x02,\x1a~\x20When\x20the\x20data\
    set\x20was\x20modified.\n\x20The\x20format\x20is\x20https://www.ietf.org\
    /rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\
    \r\n\x05\x042\x02\x02\x06\x12\x04\x82\x07\x02\x1b\n\r\n\x05\x042\x02\x02\
    \x01\x12\x04\x82\x07\x1c'\n\r\n\x05\x042\x02\x02\x03\x12\x04\x82\x07*+\n\
    /\n\x04\x042\x02\x03\x12\x04\x85\x07\x02\x14\x1a!\x20The\x20app\x20the\
    \x20dataset\x20belongs\x20to.\n\n\r\n\x05\x042\x02\x03\x05\x12\x04\x85\
    \x07\x02\x08\n\r\n\x05\x042\x02\x03\x01\x12\x04\x85\x07\t\x0f\n\r\n\x05\
    \x042\x02\x03\x03\x12\x04\x85\x07\x12\x13\n0\n\x04\x042\x02\x04\x12\x04\
    \x88\x07\x02\x15\x1a\"\x20The\x20user\x20the\x20dataset\x20belongs\x20to\
    .\n\n\r\n\x05\x042\x02\x04\x05\x12\x04\x88\x07\x02\x08\n\r\n\x05\x042\
    \x02\x04\x01\x12\x04\x88\x07\t\x10\n\r\n\x05\x042\x02\x04\x03\x12\x04\
    \x88\x07\x13\x14\n*\n\x04\x042\x02\x05\x12\x04\x8b\x07\x02\x19\x1a\x1c\
    \x20Description\x20of\x20the\x20dataset\n\n\r\n\x05\x042\x02\x05\x05\x12\
    \x04\x8b\x07\x02\x08\n\r\n\x05\x042\x02\x05\x01\x12\x04\x8b\x07\t\x14\n\
    \r\n\x05\x042\x02\x05\x03\x12\x04\x8b\x07\x17\x18\n\x9f\x01\n\x04\x042\
    \x02\x06\x12\x04\x8f\x07\x02&\x1a\x90\x01\x20To\x20handle\x20arbitrary\
    \x20json\x20metadata\x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20\
    https://github.com/google/protobuf/blob/master/src/google/protobuf/struc\
    t.proto\n\n\r\n\x05\x042\x02\x06\x06\x12\x04\x8f\x07\x02\x18\n\r\n\x05\
    \x042\x02\x06\x01\x12\x04\x8f\x07\x19!\n\r\n\x05\x042\x02\x06\x03\x12\
    \x04\x8f\x07$%\n\xdd\x01\n\x04\x042\x02\x07\x12\x04\x94\x07\x02\x1c\x1a\
    \xce\x01\x20The\x20visibility\x20field\x20represents\x20whether\x20this\
    \x20message\x20is\x20privately/publicly\x20visible.\n\x20To\x20be\x20vis\
    ible\x20to\x20the\x20public\x20the\x20App\x20that\x20contains\x20it\x20A\
    ND\x20the\x20User\x20that\x20contains\x20the\x20App\x20must\n\x20also\
    \x20be\x20publicly\x20visible.\n\n\r\n\x05\x042\x02\x07\x06\x12\x04\x94\
    \x07\x02\x0c\n\r\n\x05\x042\x02\x07\x01\x12\x04\x94\x07\r\x17\n\r\n\x05\
    \x042\x02\x07\x03\x12\x04\x94\x07\x1a\x1b\n@\n\x04\x042\x02\x08\x12\x04\
    \x97\x07\x022\x1a2\x20Default\x20annotation\x20filter\x20used\x20for\x20\
    this\x20dataset.\n\n\r\n\x05\x042\x02\x08\x06\x12\x04\x97\x07\x02\x12\n\
    \r\n\x05\x042\x02\x08\x01\x12\x04\x97\x07\x13,\n\r\n\x05\x042\x02\x08\
    \x03\x12\x04\x97\x07/1\n>\n\x04\x042\x02\t\x12\x04\x9a\x07\x02<\x1a0\x20\
    Default\x20processing\x20info\x20used\x20for\x20this\x20dataset.\n\n\r\n\
    \x05\x042\x02\t\x06\x12\x04\x9a\x07\x02\x1e\n\r\n\x05\x042\x02\t\x01\x12\
    \x04\x9a\x07\x1f6\n\r\n\x05\x042\x02\t\x03\x12\x04\x9a\x079;\nm\n\x04\
    \x042\x02\n\x12\x04\x9e\x07\x02\x14\x1a_\x20Notes\x20for\x20the\x20datas\
    et\n\x20This\x20field\x20should\x20be\x20used\x20for\x20in-depth\x20note\
    s\x20and\x20supports\x20up\x20to\x2064Kbs.\n\n\r\n\x05\x042\x02\n\x05\
    \x12\x04\x9e\x07\x02\x08\n\r\n\x05\x042\x02\n\x01\x12\x04\x9e\x07\t\x0e\
    \n\r\n\x05\x042\x02\n\x03\x12\x04\x9e\x07\x11\x13\n\x81\x01\n\x04\x042\
    \x02\x0b\x12\x04\xa2\x07\x02\x1e\x1as\x20Dataset\x20version\x20associate\
    d\x20with\x20this\x20dataset.\x20This\x20is\x20used\x20in\x20listing\x20\
    Datasets\n\x20and\x20including\x20the\x20latest\x20version.\n\n\r\n\x05\
    \x042\x02\x0b\x06\x12\x04\xa2\x07\x02\x10\n\r\n\x05\x042\x02\x0b\x01\x12\
    \x04\xa2\x07\x11\x18\n\r\n\x05\x042\x02\x0b\x03\x12\x04\xa2\x07\x1b\x1d\
    \nF\n\x04\x042\x02\x0c\x12\x04\xa5\x07\x02\x17\x1a8\x20Whether\x20the\
    \x20dataset\x20is\x20starred\x20by\x20the\x20requesting\x20user.\n\n\r\n\
    \x05\x042\x02\x0c\x05\x12\x04\xa5\x07\x02\x06\n\r\n\x05\x042\x02\x0c\x01\
    \x12\x04\xa5\x07\x07\x11\n\r\n\x05\x042\x02\x0c\x03\x12\x04\xa5\x07\x14\
    \x16\n:\n\x04\x042\x02\r\x12\x04\xa7\x07\x02\x18\x1a,\x20Number\x20of\
    \x20users\x20that\x20starred\x20this\x20dataset.\n\n\r\n\x05\x042\x02\r\
    \x05\x12\x04\xa7\x07\x02\x07\n\r\n\x05\x042\x02\r\x01\x12\x04\xa7\x07\
    \x08\x12\n\r\n\x05\x042\x02\r\x03\x12\x04\xa7\x07\x15\x17\n\x9f\x01\n\
    \x04\x042\x02\x0e\x12\x04\xab\x07\x02&\x1a\x90\x01\x20bookmark\x20info.\
    \x20When\x20set,\x20this\x20dataset\x20is\x20a\x20bookmarked\x20dataset\
    \x20of\x20this\x20app.\n\x20Info\x20in\x20this\x20field\x20will\x20allow\
    \x20you\x20to\x20find/access\x20original\x20dataset.\n\n\r\n\x05\x042\
    \x02\x0e\x06\x12\x04\xab\x07\x02\x10\n\r\n\x05\x042\x02\x0e\x01\x12\x04\
    \xab\x07\x11\x20\n\r\n\x05\x042\x02\x0e\x03\x12\x04\xab\x07#%\n5\n\x04\
    \x042\x02\x0f\x12\x04\xad\x07\x02\x13\x1a'\x20Representative\x20image\
    \x20for\x20this\x20dataset\n\n\r\n\x05\x042\x02\x0f\x06\x12\x04\xad\x07\
    \x02\x07\n\r\n\x05\x042\x02\x0f\x01\x12\x04\xad\x07\x08\r\n\r\n\x05\x042\
    \x02\x0f\x03\x12\x04\xad\x07\x10\x12\n\xc6\x01\n\x02\x043\x12\x06\xb3\
    \x07\0\xcb\x07\x01\x1a\xb7\x01\x20AnnotationFilter\x20is\x20used\x20to\
    \x20create\x20a\x20new\x20dataset\x20version.\n\x20For\x20now,\x20the\
    \x20filter\x20is\x20simply\x20a\x20wrapper\x20over\x20a\x20Search.\n\x20\
    In\x20the\x20future,\x20we\x20may\x20add\x20extra\x20fields\x20to\x20cus\
    tomize\x20the\x20filtering.\n\n\x0b\n\x03\x043\x01\x12\x04\xb3\x07\x08\
    \x18\n\x0b\n\x03\x043\t\x12\x04\xb4\x07\x02\x13\n\x0c\n\x04\x043\t\0\x12\
    \x04\xb4\x07\x0b\x0c\n\r\n\x05\x043\t\0\x01\x12\x04\xb4\x07\x0b\x0c\n\r\
    \n\x05\x043\t\0\x02\x12\x04\xb4\x07\x0b\x0c\n\x0c\n\x04\x043\t\x01\x12\
    \x04\xb4\x07\x0e\x0f\n\r\n\x05\x043\t\x01\x01\x12\x04\xb4\x07\x0e\x0f\n\
    \r\n\x05\x043\t\x01\x02\x12\x04\xb4\x07\x0e\x0f\n\x0c\n\x04\x043\t\x02\
    \x12\x04\xb4\x07\x11\x12\n\r\n\x05\x043\t\x02\x01\x12\x04\xb4\x07\x11\
    \x12\n\r\n\x05\x043\t\x02\x02\x12\x04\xb4\x07\x11\x12\n0\n\x04\x043\x02\
    \0\x12\x04\xb7\x07\x02\x10\x1a\"\x20The\x20ID\x20for\x20the\x20annotatio\
    n\x20filter\n\n\r\n\x05\x043\x02\0\x05\x12\x04\xb7\x07\x02\x08\n\r\n\x05\
    \x043\x02\0\x01\x12\x04\xb7\x07\t\x0b\n\r\n\x05\x043\x02\0\x03\x12\x04\
    \xb7\x07\x0e\x0f\n\x96\x01\n\x04\x043\x02\x01\x12\x04\xbc\x07\x02+\x1a\
    \x87\x01\x20When\x20the\x20annotation\x20filter\x20was\x20created.\n\x20\
    The\x20format\x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Exampl\
    e:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\r\n\x05\x043\x02\x01\x06\x12\
    \x04\xbc\x07\x02\x1b\n\r\n\x05\x043\x02\x01\x01\x12\x04\xbc\x07\x1c&\n\r\
    \n\x05\x043\x02\x01\x03\x12\x04\xbc\x07)*\n\x97\x01\n\x04\x043\x02\x02\
    \x12\x04\xc1\x07\x02,\x1a\x88\x01\x20When\x20the\x20annotation\x20filter\
    \x20was\x20modified.\n\x20The\x20format\x20is\x20https://www.ietf.org/rf\
    c/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\r\n\
    \x05\x043\x02\x02\x06\x12\x04\xc1\x07\x02\x1b\n\r\n\x05\x043\x02\x02\x01\
    \x12\x04\xc1\x07\x1c'\n\r\n\x05\x043\x02\x02\x03\x12\x04\xc1\x07*+\n:\n\
    \x04\x043\x02\x03\x12\x04\xc4\x07\x02\x15\x1a,\x20The\x20user\x20the\x20\
    annotation\x20filter\x20belongs\x20to.\n\n\r\n\x05\x043\x02\x03\x05\x12\
    \x04\xc4\x07\x02\x08\n\r\n\x05\x043\x02\x03\x01\x12\x04\xc4\x07\t\x10\n\
    \r\n\x05\x043\x02\x03\x03\x12\x04\xc4\x07\x13\x14\n9\n\x04\x043\x02\x04\
    \x12\x04\xc7\x07\x02\x14\x1a+\x20The\x20app\x20the\x20annotation\x20filt\
    er\x20belongs\x20to.\n\n\r\n\x05\x043\x02\x04\x05\x12\x04\xc7\x07\x02\
    \x08\n\r\n\x05\x043\x02\x04\x01\x12\x04\xc7\x07\t\x0f\n\r\n\x05\x043\x02\
    \x04\x03\x12\x04\xc7\x07\x12\x13\n1\n\x04\x043\x02\x05\x12\x04\xca\x07\
    \x02\x14\x1a#\x20The\x20search\x20that\x20this\x20filter\x20uses.\n\n\r\
    \n\x05\x043\x02\x05\x06\x12\x04\xca\x07\x02\x08\n\r\n\x05\x043\x02\x05\
    \x01\x12\x04\xca\x07\t\x0f\n\r\n\x05\x043\x02\x05\x03\x12\x04\xca\x07\
    \x12\x13\n\x1c\n\x02\x044\x12\x06\xce\x07\0\xd6\x07\x01\x1a\x0e\x20Datas\
    etInput\n\n\x0b\n\x03\x044\x01\x12\x04\xce\x07\x08\x14\n\x97\x01\n\x04\
    \x044\x02\0\x12\x04\xd2\x07\x02+\x1a\x88\x01\x20When\x20the\x20input\x20\
    was\x20added\x20to\x20the\x20dataset.\n\x20The\x20format\x20is\x20https:\
    //www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.9\
    99999Z\".\n\n\r\n\x05\x044\x02\0\x06\x12\x04\xd2\x07\x02\x1b\n\r\n\x05\
    \x044\x02\0\x01\x12\x04\xd2\x07\x1c&\n\r\n\x05\x044\x02\0\x03\x12\x04\
    \xd2\x07)*\n\x1f\n\x04\x044\x02\x01\x12\x04\xd5\x07\x02\x12\x1a\x11\x20T\
    he\x20input\x20data.\n\n\r\n\x05\x044\x02\x01\x06\x12\x04\xd5\x07\x02\
    \x07\n\r\n\x05\x044\x02\x01\x01\x12\x04\xd5\x07\x08\r\n\r\n\x05\x044\x02\
    \x01\x03\x12\x04\xd5\x07\x10\x11\n\x0c\n\x02\x05\x01\x12\x06\xd7\x07\0\
    \xdd\x07\x03\n\x0b\n\x03\x05\x01\x01\x12\x04\xd7\x07\x05\x20\n\x0c\n\x04\
    \x05\x01\x02\0\x12\x04\xd8\x07\x04/\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\
    \xd8\x07\x04*\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xd8\x07-.\n\x0c\n\x04\
    \x05\x01\x02\x01\x12\x04\xd9\x07\x04\x0f\n\r\n\x05\x05\x01\x02\x01\x01\
    \x12\x04\xd9\x07\x04\n\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xd9\x07\r\
    \x0e\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\xda\x07\x04\x11\n\r\n\x05\x05\
    \x01\x02\x02\x01\x12\x04\xda\x07\x04\x0c\n\r\n\x05\x05\x01\x02\x02\x02\
    \x12\x04\xda\x07\x0f\x10\n\x0c\n\x04\x05\x01\x02\x03\x12\x04\xdb\x07\x04\
    \x1a\n\r\n\x05\x05\x01\x02\x03\x01\x12\x04\xdb\x07\x04\x15\n\r\n\x05\x05\
    \x01\x02\x03\x02\x12\x04\xdb\x07\x18\x19\n\x0c\n\x04\x05\x01\x02\x04\x12\
    \x04\xdc\x07\x04\x19\n\r\n\x05\x05\x01\x02\x04\x01\x12\x04\xdc\x07\x04\
    \x14\n\r\n\x05\x05\x01\x02\x04\x02\x12\x04\xdc\x07\x17\x18\n\x1e\n\x02\
    \x045\x12\x06\xe1\x07\0\xa2\x08\x01\x1a\x10\x20DatasetVersion\n\n\x0b\n\
    \x03\x045\x01\x12\x04\xe1\x07\x08\x16\n\x0b\n\x03\x045\t\x12\x04\xe2\x07\
    \x02\x14\n\x0c\n\x04\x045\t\0\x12\x04\xe2\x07\x0b\x0c\n\r\n\x05\x045\t\0\
    \x01\x12\x04\xe2\x07\x0b\x0c\n\r\n\x05\x045\t\0\x02\x12\x04\xe2\x07\x0b\
    \x0c\n\x0c\n\x04\x045\t\x01\x12\x04\xe2\x07\x0e\x0f\n\r\n\x05\x045\t\x01\
    \x01\x12\x04\xe2\x07\x0e\x0f\n\r\n\x05\x045\t\x01\x02\x12\x04\xe2\x07\
    \x0e\x0f\n\x0c\n\x04\x045\t\x02\x12\x04\xe2\x07\x11\x13\n\r\n\x05\x045\t\
    \x02\x01\x12\x04\xe2\x07\x11\x13\n\r\n\x05\x045\t\x02\x02\x12\x04\xe2\
    \x07\x11\x13\n.\n\x04\x045\x02\0\x12\x04\xe5\x07\x02\x10\x1a\x20\x20The\
    \x20ID\x20for\x20the\x20dataset\x20version\n\n\r\n\x05\x045\x02\0\x05\
    \x12\x04\xe5\x07\x02\x08\n\r\n\x05\x045\x02\0\x01\x12\x04\xe5\x07\t\x0b\
    \n\r\n\x05\x045\x02\0\x03\x12\x04\xe5\x07\x0e\x0f\n\x94\x01\n\x04\x045\
    \x02\x01\x12\x04\xea\x07\x02+\x1a\x85\x01\x20When\x20the\x20dataset\x20v\
    ersion\x20was\x20created.\n\x20The\x20format\x20is\x20https://www.ietf.o\
    rg/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\
    \n\r\n\x05\x045\x02\x01\x06\x12\x04\xea\x07\x02\x1b\n\r\n\x05\x045\x02\
    \x01\x01\x12\x04\xea\x07\x1c&\n\r\n\x05\x045\x02\x01\x03\x12\x04\xea\x07\
    )*\n\x95\x01\n\x04\x045\x02\x02\x12\x04\xef\x07\x02,\x1a\x86\x01\x20When\
    \x20the\x20dataset\x20version\x20was\x20modified.\n\x20The\x20format\x20\
    is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-0\
    2T15:04:05.999999Z\".\n\n\r\n\x05\x045\x02\x02\x06\x12\x04\xef\x07\x02\
    \x1b\n\r\n\x05\x045\x02\x02\x01\x12\x04\xef\x07\x1c'\n\r\n\x05\x045\x02\
    \x02\x03\x12\x04\xef\x07*+\n7\n\x04\x045\x02\x03\x12\x04\xf2\x07\x02\x14\
    \x1a)\x20The\x20app\x20the\x20dataset\x20version\x20belongs\x20to.\n\n\r\
    \n\x05\x045\x02\x03\x05\x12\x04\xf2\x07\x02\x08\n\r\n\x05\x045\x02\x03\
    \x01\x12\x04\xf2\x07\t\x0f\n\r\n\x05\x045\x02\x03\x03\x12\x04\xf2\x07\
    \x12\x13\n8\n\x04\x045\x02\x04\x12\x04\xf5\x07\x02\x15\x1a*\x20The\x20us\
    er\x20the\x20dataset\x20version\x20belongs\x20to.\n\n\r\n\x05\x045\x02\
    \x04\x05\x12\x04\xf5\x07\x02\x08\n\r\n\x05\x045\x02\x04\x01\x12\x04\xf5\
    \x07\t\x10\n\r\n\x05\x045\x02\x04\x03\x12\x04\xf5\x07\x13\x14\n;\n\x04\
    \x045\x02\x05\x12\x04\xf8\x07\x02\x18\x1a-\x20The\x20dataset\x20the\x20d\
    ataset\x20version\x20belongs\x20to.\n\n\r\n\x05\x045\x02\x05\x05\x12\x04\
    \xf8\x07\x02\x08\n\r\n\x05\x045\x02\x05\x01\x12\x04\xf8\x07\t\x13\n\r\n\
    \x05\x045\x02\x05\x03\x12\x04\xf8\x07\x16\x17\nK\n\x04\x045\x08\0\x12\
    \x06\xfb\x07\x02\x80\x08\x03\x1a;\x20Data\x20config\x20reveals\x20how\
    \x20the\x20dataset\x20version\x20is\x20generated.\n\n\r\n\x05\x045\x08\0\
    \x01\x12\x04\xfb\x07\x08\x13\nZ\n\x04\x045\x02\x06\x12\x04\xfd\x07\x049\
    \x1aL\x20The\x20dataset\x20version\x20will\x20be\x20generated\x20based\
    \x20on\x20a\x20single\x20annotation\x20filter.\n\n\r\n\x05\x045\x02\x06\
    \x06\x12\x04\xfd\x07\x04\x1a\n\r\n\x05\x045\x02\x06\x01\x12\x04\xfd\x07\
    \x1b3\n\r\n\x05\x045\x02\x06\x03\x12\x04\xfd\x0768\nX\n\x04\x045\x02\x07\
    \x12\x04\xff\x07\x041\x1aJ\x20The\x20dataset\x20version\x20will\x20be\
    \x20generated\x20based\x20on\x20model\x20version\x20inferences.\n\n\r\n\
    \x05\x045\x02\x07\x06\x12\x04\xff\x07\x04\x16\n\r\n\x05\x045\x02\x07\x01\
    \x12\x04\xff\x07\x17+\n\r\n\x05\x045\x02\x07\x03\x12\x04\xff\x07.0\n0\n\
    \x04\x045\x02\x08\x12\x04\x83\x08\x02(\x1a\"\x20Status\x20for\x20this\
    \x20dataset\x20version.\n\n\r\n\x05\x045\x02\x08\x06\x12\x04\x83\x08\x02\
    \x1c\n\r\n\x05\x045\x02\x08\x01\x12\x04\x83\x08\x1d#\n\r\n\x05\x045\x02\
    \x08\x03\x12\x04\x83\x08&'\n2\n\x04\x045\x02\t\x12\x04\x86\x08\x02\x1a\
    \x1a$\x20Description\x20of\x20the\x20dataset\x20version\n\n\r\n\x05\x045\
    \x02\t\x05\x12\x04\x86\x08\x02\x08\n\r\n\x05\x045\x02\t\x01\x12\x04\x86\
    \x08\t\x14\n\r\n\x05\x045\x02\t\x03\x12\x04\x86\x08\x17\x19\n\xf0\x01\n\
    \x04\x045\x02\n\x12\x04\x8b\x08\x024\x1a\xe1\x01\x20Dataset\x20version\
    \x20processing.\x20If\x20this\x20is\x20not\x20set\x20when\x20the\x20data\
    set\x20version\x20is\n\x20created,\x20then\x20the\x20dataset\x20default_\
    processing_info\x20is\x20copied\x20instead.\x20Later\n\x20updates\x20to\
    \x20default_processing_info\x20will\x20not\x20apply\x20to\x20existing\
    \x20versions.\n\n\r\n\x05\x045\x02\n\x06\x12\x04\x8b\x08\x02\x1e\n\r\n\
    \x05\x045\x02\n\x01\x12\x04\x8b\x08\x1f.\n\r\n\x05\x045\x02\n\x03\x12\
    \x04\x8b\x0813\n'\n\x04\x045\x02\x0b\x12\x04\x8e\x08\x022\x1a\x19\x20Dat\
    aset\x20version\x20metrics\n\n\r\n\x05\x045\x02\x0b\x06\x12\x04\x8e\x08\
    \x02$\n\r\n\x05\x045\x02\x0b\x01\x12\x04\x8e\x08%,\n\r\n\x05\x045\x02\
    \x0b\x03\x12\x04\x8e\x08/1\n'\n\x04\x045\x02\x0c\x12\x04\x91\x08\x02,\
    \x1a\x19\x20Dataset\x20version\x20exports\n\n\r\n\x05\x045\x02\x0c\x06\
    \x12\x04\x91\x08\x02\x1a\n\r\n\x05\x045\x02\x0c\x01\x12\x04\x91\x08\x1b&\
    \n\r\n\x05\x045\x02\x0c\x03\x12\x04\x91\x08)+\n\x9f\x01\n\x04\x045\x02\r\
    \x12\x04\x95\x08\x02'\x1a\x90\x01\x20To\x20handle\x20arbitrary\x20json\
    \x20metadata\x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20https://\
    github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto\
    \n\n\r\n\x05\x045\x02\r\x06\x12\x04\x95\x08\x02\x18\n\r\n\x05\x045\x02\r\
    \x01\x12\x04\x95\x08\x19!\n\r\n\x05\x045\x02\r\x03\x12\x04\x95\x08$&\n\
    \xdd\x01\n\x04\x045\x02\x0e\x12\x04\x9a\x08\x02\x1d\x1a\xce\x01\x20The\
    \x20visibility\x20field\x20represents\x20whether\x20this\x20message\x20i\
    s\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20th\
    e\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20Use\
    r\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\
    \x20visible.\n\n\r\n\x05\x045\x02\x0e\x06\x12\x04\x9a\x08\x02\x0c\n\r\n\
    \x05\x045\x02\x0e\x01\x12\x04\x9a\x08\r\x17\n\r\n\x05\x045\x02\x0e\x03\
    \x12\x04\x9a\x08\x1a\x1c\nd\n\x04\x045\x02\x0f\x12\x04\x9d\x08\x02/\x1aV\
    \x20The\x20embedding\x20models\x20to\x20return\x20embeddings\x20for.\x20\
    If\x20empty,\x20no\x20embeddings\x20are\x20returned.\n\n\r\n\x05\x045\
    \x02\x0f\x04\x12\x04\x9d\x08\x02\n\n\r\n\x05\x045\x02\x0f\x05\x12\x04\
    \x9d\x08\x0b\x11\n\r\n\x05\x045\x02\x0f\x01\x12\x04\x9d\x08\x12)\n\r\n\
    \x05\x045\x02\x0f\x03\x12\x04\x9d\x08,.\nS\n\x04\x045\x02\x10\x12\x04\
    \xa1\x08\x022\x1aE\x20Read\x20Only.\x20Cannot\x20be\x20Set\n\x20Origin\
    \x20of\x20request\x20for\x20new\x20dataset\x20version\n\n\r\n\x05\x045\
    \x02\x10\x06\x12\x04\xa1\x08\x02\x1d\n\r\n\x05\x045\x02\x10\x01\x12\x04\
    \xa1\x08\x1e,\n\r\n\x05\x045\x02\x10\x03\x12\x04\xa1\x08/1\n\x0c\n\x02\
    \x046\x12\x06\xa4\x08\0\xac\x08\x01\n\x0b\n\x03\x046\x01\x12\x04\xa4\x08\
    \x08\x1e\n3\n\x04\x046\x02\0\x12\x04\xa6\x08\x02)\x1a%\x20The\x20annotat\
    ion\x20filter\x20that\x20is\x20used.\n\n\r\n\x05\x046\x02\0\x06\x12\x04\
    \xa6\x08\x02\x12\n\r\n\x05\x046\x02\0\x01\x12\x04\xa6\x08\x13$\n\r\n\x05\
    \x046\x02\0\x03\x12\x04\xa6\x08'(\n\xee\x01\n\x04\x046\x02\x01\x12\x04\
    \xab\x08\x02\x1f\x1a\xdf\x01\x20If\x20true,\x20empty\x20inputs\x20are\
    \x20not\x20included\x20in\x20the\x20dataset\x20version.\n\x20If\x20false\
    ,\x20empty\x20inputs\x20are\x20included\x20in\x20the\x20dataset\x20versi\
    on.\n\x20We\x20define\x20an\x20empty\x20input\x20as\x20an\x20input\x20wi\
    thout\x20any\x20annotations\x20after\x20annotation\x20filter\x20is\x20ap\
    plied.\n\n\r\n\x05\x046\x02\x01\x05\x12\x04\xab\x08\x02\x06\n\r\n\x05\
    \x046\x02\x01\x01\x12\x04\xab\x08\x07\x1a\n\r\n\x05\x046\x02\x01\x03\x12\
    \x04\xab\x08\x1d\x1e\n\x0c\n\x02\x047\x12\x06\xae\x08\0\xb1\x08\x01\n\
    \x0b\n\x03\x047\x01\x12\x04\xae\x08\x08\x1a\nf\n\x04\x047\x02\0\x12\x04\
    \xb0\x08\x02\x12\x1aX\x20Assumed\x20to\x20be\x20owned\x20by\x20the\x20ca\
    lling\x20users\x20app\x20unless\x20user_id\x20and\x20app_id\x20are\x20fi\
    lled\x20out.\n\n\r\n\x05\x047\x02\0\x06\x12\x04\xb0\x08\x02\x07\n\r\n\
    \x05\x047\x02\0\x01\x12\x04\xb0\x08\x08\r\n\r\n\x05\x047\x02\0\x03\x12\
    \x04\xb0\x08\x10\x11\n\x0c\n\x02\x048\x12\x06\xb3\x08\0\xe7\x08\x01\n\
    \x0b\n\x03\x048\x01\x12\x04\xb3\x08\x08\x1d\n\x0b\n\x03\x048\t\x12\x04\
    \xb4\x08\x02\x19\n\x0c\n\x04\x048\t\0\x12\x04\xb4\x08\x0b\x0c\n\r\n\x05\
    \x048\t\0\x01\x12\x04\xb4\x08\x0b\x0c\n\r\n\x05\x048\t\0\x02\x12\x04\xb4\
    \x08\x0b\x0c\n\x0c\n\x04\x048\t\x01\x12\x04\xb4\x08\x0e\x0f\n\r\n\x05\
    \x048\t\x01\x01\x12\x04\xb4\x08\x0e\x0f\n\r\n\x05\x048\t\x01\x02\x12\x04\
    \xb4\x08\x0e\x0f\n\x0c\n\x04\x048\t\x02\x12\x04\xb4\x08\x11\x12\n\r\n\
    \x05\x048\t\x02\x01\x12\x04\xb4\x08\x11\x12\n\r\n\x05\x048\t\x02\x02\x12\
    \x04\xb4\x08\x11\x12\n\x0c\n\x04\x048\t\x03\x12\x04\xb4\x08\x14\x15\n\r\
    \n\x05\x048\t\x03\x01\x12\x04\xb4\x08\x14\x15\n\r\n\x05\x048\t\x03\x02\
    \x12\x04\xb4\x08\x14\x15\n\x0c\n\x04\x048\t\x04\x12\x04\xb4\x08\x17\x18\
    \n\r\n\x05\x048\t\x04\x01\x12\x04\xb4\x08\x17\x18\n\r\n\x05\x048\t\x04\
    \x02\x12\x04\xb4\x08\x17\x18\n\x20\n\x04\x048\x02\0\x12\x04\xb7\x08\x02/\
    \x1a\x12\x20Number\x20of\x20inputs\n\n\r\n\x05\x048\x02\0\x06\x12\x04\
    \xb7\x08\x02\x1d\n\r\n\x05\x048\x02\0\x01\x12\x04\xb7\x08\x1e*\n\r\n\x05\
    \x048\x02\0\x03\x12\x04\xb7\x08-.\n\x91\x01\n\x04\x048\x02\x01\x12\x04\
    \xba\x08\x029\x1a\x82\x01\x20Number\x20of\x20unlabeled\x20inputs\n\x20An\
    \x20input\x20is\x20considered\x20unlabeled\x20if\x20it\x20there\x20are\
    \x20no\x20annotations\x20with\x20positive\x20labels\x20for\x20that\x20in\
    put.\n\n\r\n\x05\x048\x02\x01\x06\x12\x04\xba\x08\x02\x1d\n\r\n\x05\x048\
    \x02\x01\x01\x12\x04\xba\x08\x1e4\n\r\n\x05\x048\x02\x01\x03\x12\x04\xba\
    \x0878\n3\n\x04\x048\x02\x02\x12\x04\xbc\x08\x02=\x1a%\x20Number\x20of\
    \x20inputs\x20that\x20have\x20metadata\n\n\r\n\x05\x048\x02\x02\x06\x12\
    \x04\xbc\x08\x02\x1d\n\r\n\x05\x048\x02\x02\x01\x12\x04\xbc\x08\x1e8\n\r\
    \n\x05\x048\x02\x02\x03\x12\x04\xbc\x08;<\n:\n\x04\x048\x02\x03\x12\x04\
    \xbe\x08\x028\x1a,\x20Number\x20of\x20inputs\x20that\x20have\x20geo\x20i\
    nformation\n\n\r\n\x05\x048\x02\x03\x06\x12\x04\xbe\x08\x02\x1d\n\r\n\
    \x05\x048\x02\x03\x01\x12\x04\xbe\x08\x1e3\n\r\n\x05\x048\x02\x03\x03\
    \x12\x04\xbe\x0867\n!\n\x04\x048\x02\x04\x12\x04\xc1\x08\x021\x1a\x13\
    \x20Number\x20of\x20regions\n\n\r\n\x05\x048\x02\x04\x06\x12\x04\xc1\x08\
    \x02\x1d\n\r\n\x05\x048\x02\x04\x01\x12\x04\xc1\x08\x1e+\n\r\n\x05\x048\
    \x02\x04\x03\x12\x04\xc1\x08.0\n\xc1\x04\n\x04\x048\x02\x05\x12\x04\xc8\
    \x08\x02+\x1a\xb2\x04\x20The\x20matrix\x20shows\x20where\x20the\x20regio\
    ns\x20are\x20located.\n\x20Example:\x20If\x20the\x20matrix\x20has\x202x2\
    \x20dimensions,\x20then\n\x20*\x20region_location_matrix[0][0]\x20=\x20t\
    he\x20number\x20of\x20regions\x20that\x20appear\x20in\x20the\x20top\x20l\
    eft\x20corner,\x20i.e.\x20[0,0]..(0.5,0.5)\n\x20*\x20region_location_mat\
    rix[0][1]\x20=\x20the\x20number\x20of\x20regions\x20that\x20appear\x20in\
    \x20the\x20top\x20right\x20corner,\x20i.e.\x20[0,0.5]..[0.5,1]\n\x20*\
    \x20region_location_matrix[1][0]\x20=\x20the\x20number\x20of\x20regions\
    \x20that\x20appear\x20in\x20the\x20bottom\x20left\x20corner,\x20i.e.\x20\
    [0.5,0]..[1,0.5)\n\x20*\x20region_location_matrix[1][1]\x20=\x20the\x20n\
    umber\x20of\x20regions\x20that\x20appear\x20in\x20the\x20bottom\x20right\
    \x20corner,\x20i.e.\x20[0.5,0.5]..[1,1]\n\n\r\n\x05\x048\x02\x05\x06\x12\
    \x04\xc8\x08\x02\x0e\n\r\n\x05\x048\x02\x05\x01\x12\x04\xc8\x08\x0f%\n\r\
    \n\x05\x048\x02\x05\x03\x12\x04\xc8\x08(*\n(\n\x04\x048\x02\x06\x12\x04\
    \xca\x08\x028\x1a\x1a\x20Number\x20of\x20bounding\x20boxes\n\n\r\n\x05\
    \x048\x02\x06\x06\x12\x04\xca\x08\x02\x1d\n\r\n\x05\x048\x02\x06\x01\x12\
    \x04\xca\x08\x1e2\n\r\n\x05\x048\x02\x06\x03\x12\x04\xca\x0857\n\"\n\x04\
    \x048\x02\x07\x12\x04\xcc\x08\x022\x1a\x14\x20Number\x20of\x20polygons\n\
    \n\r\n\x05\x048\x02\x07\x06\x12\x04\xcc\x08\x02\x1d\n\r\n\x05\x048\x02\
    \x07\x01\x12\x04\xcc\x08\x1e,\n\r\n\x05\x048\x02\x07\x03\x12\x04\xcc\x08\
    /1\n\x20\n\x04\x048\x02\x08\x12\x04\xce\x08\x020\x1a\x12\x20Number\x20of\
    \x20points\n\n\r\n\x05\x048\x02\x08\x06\x12\x04\xce\x08\x02\x1d\n\r\n\
    \x05\x048\x02\x08\x01\x12\x04\xce\x08\x1e*\n\r\n\x05\x048\x02\x08\x03\
    \x12\x04\xce\x08-/\n\x1f\n\x04\x048\x02\t\x12\x04\xd0\x08\x02/\x1a\x11\
    \x20Number\x20of\x20masks\n\n\r\n\x05\x048\x02\t\x06\x12\x04\xd0\x08\x02\
    \x1d\n\r\n\x05\x048\x02\t\x01\x12\x04\xd0\x08\x1e)\n\r\n\x05\x048\x02\t\
    \x03\x12\x04\xd0\x08,.\n\xee\x01\n\x04\x048\x02\n\x12\x04\xd4\x08\x027\
    \x1a\xdf\x01\x20Number\x20of\x20inputs\x20that\x20have\x20regions\x20att\
    ached\n\x20Note\x20that\x20this\x20is\x20not\x20a\x20recursive\x20count:\
    \x20if\x20an\x20input\x20contains\x20frames\x20that\x20contains\x20regio\
    ns,\x20then\x20the\x20region_frames_count\x20is\x20increased,\x20but\x20\
    region_inputs_count\x20is\x20not\x20increased.\n\n\r\n\x05\x048\x02\n\
    \x06\x12\x04\xd4\x08\x02\x1d\n\r\n\x05\x048\x02\n\x01\x12\x04\xd4\x08\
    \x1e1\n\r\n\x05\x048\x02\n\x03\x12\x04\xd4\x0846\n;\n\x04\x048\x02\x0b\
    \x12\x04\xd6\x08\x027\x1a-\x20Number\x20of\x20frames\x20that\x20have\x20\
    regions\x20attached\n\n\r\n\x05\x048\x02\x0b\x06\x12\x04\xd6\x08\x02\x1d\
    \n\r\n\x05\x048\x02\x0b\x01\x12\x04\xd6\x08\x1e1\n\r\n\x05\x048\x02\x0b\
    \x03\x12\x04\xd6\x0846\n\x20\n\x04\x048\x02\x0c\x12\x04\xd9\x08\x020\x1a\
    \x12\x20Number\x20of\x20frames\n\n\r\n\x05\x048\x02\x0c\x06\x12\x04\xd9\
    \x08\x02\x1d\n\r\n\x05\x048\x02\x0c\x01\x12\x04\xd9\x08\x1e*\n\r\n\x05\
    \x048\x02\x0c\x03\x12\x04\xd9\x08-/\n:\n\x04\x048\x02\r\x12\x04\xdc\x08\
    \x026\x1a,\x20Number\x20of\x20inputs\x20that\x20have\x20frames\x20attach\
    ed\n\n\r\n\x05\x048\x02\r\x06\x12\x04\xdc\x08\x02\x1d\n\r\n\x05\x048\x02\
    \r\x01\x12\x04\xdc\x08\x1e0\n\r\n\x05\x048\x02\r\x03\x12\x04\xdc\x0835\n\
    $\n\x04\x048\x02\x0e\x12\x04\xdf\x08\x024\x1a\x16\x20Number\x20of\x20emb\
    eddings\n\n\r\n\x05\x048\x02\x0e\x06\x12\x04\xdf\x08\x02\x1d\n\r\n\x05\
    \x048\x02\x0e\x01\x12\x04\xdf\x08\x1e.\n\r\n\x05\x048\x02\x0e\x03\x12\
    \x04\xdf\x0813\n<\n\x04\x048\x02\x0f\x12\x04\xe2\x08\x02=\x1a.\x20Number\
    \x20of\x20positive\x20tags\x20added\x20at\x20input-level\n\n\r\n\x05\x04\
    8\x02\x0f\x06\x12\x04\xe2\x08\x02\x1d\n\r\n\x05\x048\x02\x0f\x01\x12\x04\
    \xe2\x08\x1e7\n\r\n\x05\x048\x02\x0f\x03\x12\x04\xe2\x08:<\n=\n\x04\x048\
    \x02\x10\x12\x04\xe4\x08\x02>\x1a/\x20Number\x20of\x20positive\x20tags\
    \x20added\x20at\x20region-level\n\n\r\n\x05\x048\x02\x10\x06\x12\x04\xe4\
    \x08\x02\x1d\n\r\n\x05\x048\x02\x10\x01\x12\x04\xe4\x08\x1e8\n\r\n\x05\
    \x048\x02\x10\x03\x12\x04\xe4\x08;=\n<\n\x04\x048\x02\x11\x12\x04\xe6\
    \x08\x02=\x1a.\x20Number\x20of\x20positive\x20tags\x20added\x20at\x20fra\
    me-level\n\n\r\n\x05\x048\x02\x11\x06\x12\x04\xe6\x08\x02\x1d\n\r\n\x05\
    \x048\x02\x11\x01\x12\x04\xe6\x08\x1e7\n\r\n\x05\x048\x02\x11\x03\x12\
    \x04\xe6\x08:<\n\x0c\n\x02\x049\x12\x06\xe9\x08\0\xee\x08\x01\n\x0b\n\
    \x03\x049\x01\x12\x04\xe9\x08\x08\"\n\x0c\n\x04\x049\x02\0\x12\x04\xea\
    \x08\x02\x19\n\r\n\x05\x049\x02\0\x05\x12\x04\xea\x08\x02\x08\n\r\n\x05\
    \x049\x02\0\x01\x12\x04\xea\x08\t\x14\n\r\n\x05\x049\x02\0\x03\x12\x04\
    \xea\x08\x17\x18\n\x0c\n\x04\x049\x02\x01\x12\x04\xeb\x08\x02*\n\r\n\x05\
    \x049\x02\x01\x06\x12\x04\xeb\x08\x02\x20\n\r\n\x05\x049\x02\x01\x01\x12\
    \x04\xeb\x08!%\n\r\n\x05\x049\x02\x01\x03\x12\x04\xeb\x08()\n\x0c\n\x04\
    \x049\x02\x02\x12\x04\xec\x08\x02\"\n\r\n\x05\x049\x02\x02\x06\x12\x04\
    \xec\x08\x02\x17\n\r\n\x05\x049\x02\x02\x01\x12\x04\xec\x08\x18\x1d\n\r\
    \n\x05\x049\x02\x02\x03\x12\x04\xec\x08\x20!\n\x0c\n\x04\x049\x02\x03\
    \x12\x04\xed\x08\x02$\n\r\n\x05\x049\x02\x03\x06\x12\x04\xed\x08\x02\x17\
    \n\r\n\x05\x049\x02\x03\x01\x12\x04\xed\x08\x18\x1f\n\r\n\x05\x049\x02\
    \x03\x03\x12\x04\xed\x08\"#\n\x0c\n\x02\x05\x02\x12\x06\xef\x08\0\x8f\t\
    \x01\n\x0b\n\x03\x05\x02\x01\x12\x04\xef\x08\x05#\n\x0c\n\x04\x05\x02\
    \x02\0\x12\x04\xf0\x08\x021\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\xf0\x08\
    \x02,\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\xf0\x08/0\nZ\n\x04\x05\x02\x02\
    \x01\x12\x04\xf4\x08\x02\x11\x1aL\x20Group\x20data\x20examples\x20by\x20\
    input\x20type.\n\x20Examples:\x20images,\x20videos,\x20text,\x20audio.\n\
    \n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xf4\x08\x02\x0c\n\r\n\x05\x05\x02\
    \x02\x01\x02\x12\x04\xf4\x08\x0f\x10\no\n\x04\x05\x02\x02\x02\x12\x04\
    \xf7\x08\x02\x12\x1aa\x20Group\x20data\x20examples\x20by\x20concept\x20I\
    D.\n\x20Examples:\x20inputs\x20with\x20cat\x20concept,\x20inputs\x20with\
    \x20dog\x20concept.\n\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xf7\x08\x02\
    \x0c\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\xf7\x08\x0f\x11\ns\n\x04\x05\
    \x02\x02\x03\x12\x04\xfa\x08\x02\x16\x1ae\x20Group\x20data\x20examples\
    \x20by\x20concepts\x20count.\n\x20Examples:\x20inputs\x20with\x2020\x20c\
    oncepts,\x20inputs\x20with\x2021\x20concepts.\n\n\r\n\x05\x05\x02\x02\
    \x03\x01\x12\x04\xfa\x08\x02\x10\n\r\n\x05\x05\x02\x02\x03\x02\x12\x04\
    \xfa\x08\x13\x15\n\x85\x01\n\x04\x05\x02\x02\x04\x12\x04\xfd\x08\x02\x1c\
    \x1aw\x20Group\x20data\x20examples\x20by\x20bounding\x20boxes\x20count.\
    \n\x20Examples:\x20inputs\x20with\x2020\x20bounding\x20boxes,\x20inputs\
    \x20with\x2021\x20bounding\x20boxes.\n\n\r\n\x05\x05\x02\x02\x04\x01\x12\
    \x04\xfd\x08\x02\x16\n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\xfd\x08\x19\
    \x1b\ns\n\x04\x05\x02\x02\x05\x12\x04\x80\t\x02\x16\x1ae\x20Group\x20dat\
    a\x20examples\x20by\x20polygons\x20count.\n\x20Examples:\x20inputs\x20wi\
    th\x2020\x20polygons,\x20inputs\x20with\x2021\x20polygons.\n\n\r\n\x05\
    \x05\x02\x02\x05\x01\x12\x04\x80\t\x02\x10\n\r\n\x05\x05\x02\x02\x05\x02\
    \x12\x04\x80\t\x13\x15\nm\n\x04\x05\x02\x02\x06\x12\x04\x83\t\x02\x14\
    \x1a_\x20Group\x20data\x20examples\x20by\x20points\x20count.\n\x20Exampl\
    es:\x20inputs\x20with\x2020\x20points,\x20inputs\x20with\x2021\x20points\
    .\n\n\r\n\x05\x05\x02\x02\x06\x01\x12\x04\x83\t\x02\x0e\n\r\n\x05\x05\
    \x02\x02\x06\x02\x12\x04\x83\t\x11\x13\nj\n\x04\x05\x02\x02\x07\x12\x04\
    \x86\t\x02\x13\x1a\\\x20Group\x20data\x20examples\x20by\x20masks\x20coun\
    t.\n\x20Examples:\x20inputs\x20with\x2020\x20masks,\x20inputs\x20with\
    \x2021\x20masks.\n\n\r\n\x05\x05\x02\x02\x07\x01\x12\x04\x86\t\x02\r\n\r\
    \n\x05\x05\x02\x02\x07\x02\x12\x04\x86\t\x10\x12\n\xd4\x01\n\x04\x05\x02\
    \x02\x08\x12\x04\x8a\t\x02\x14\x1a\xc5\x01\x20Group\x20data\x20examples\
    \x20by\x20pixels\x20count.\n\x20In\x20order\x20to\x20reduce\x20the\x20nu\
    mber\x20of\x20groups,\x20we\x20use\x20bins.\n\x20Examples\x20for\x20bin\
    \x20size\x20=\x20400:\x20inputs\x20with\x20[200000,\x20200400)\x20pixels\
    ,\x20inputs\x20with\x20[200400,\x20200800)\x20pixels.\n\n\r\n\x05\x05\
    \x02\x02\x08\x01\x12\x04\x8a\t\x02\x0e\n\r\n\x05\x05\x02\x02\x08\x02\x12\
    \x04\x8a\t\x11\x13\n\xd4\x01\n\x04\x05\x02\x02\t\x12\x04\x8e\t\x02\x14\
    \x1a\xc5\x01\x20Group\x20data\x20examples\x20by\x20aspect\x20ratio.\n\
    \x20In\x20order\x20to\x20reduce\x20the\x20number\x20of\x20groups,\x20we\
    \x20use\x20bins.\n\x20Examples\x20for\x20bin\x20size\x20=\x200.1:\x20inp\
    uts\x20with\x20[0.5,\x200.6)\x20aspect\x20ratio,\x20inputs\x20with\x20[0\
    .6,\x200.7)\x20aspect\x20ratio.\n\n\r\n\x05\x05\x02\x02\t\x01\x12\x04\
    \x8e\t\x02\x0e\n\r\n\x05\x05\x02\x02\t\x02\x12\x04\x8e\t\x11\x13\n\x8b\
    \x02\n\x02\x04:\x12\x06\x96\t\0\x9f\t\x01\x1a\xfc\x01\x20DatasetVersionE\
    xportInfo\x20contains\x20information\x20about\x20all\x20exports\x20of\
    \x20a\x20dataset\x20version.\n\n\x20If\x20the\x20dataset\x20version\x20h\
    as\x20not\x20been\x20exported\x20in\x20a\x20format,\x20then\x20the\x20Da\
    tasetVersionExport\n\x20field\x20for\x20that\x20format\x20is\x20empty\
    \x20instead\x20of\x20having\x20a\x20\"not\x20exported\"\x20status.\n\n\
    \x0b\n\x03\x04:\x01\x12\x04\x96\t\x08\x20\na\n\x04\x04:\x02\0\x12\x04\
    \x98\t\x022\x1aS\x20clarifai_data_protobuf\x20is\x20a\x20CLARIFAI_DATA_P\
    ROTOBUF\x20export\x20of\x20the\x20dataset\x20version.\n\n\r\n\x05\x04:\
    \x02\0\x06\x12\x04\x98\t\x02\x16\n\r\n\x05\x04:\x02\0\x01\x12\x04\x98\t\
    \x17-\n\r\n\x05\x04:\x02\0\x03\x12\x04\x98\t01\nY\n\x04\x04:\x02\x01\x12\
    \x04\x9b\t\x02.\x1aK\x20clarifai_data_json\x20is\x20a\x20CLARIFAI_DATA_J\
    SON\x20export\x20of\x20the\x20dataset\x20version.\n\n\r\n\x05\x04:\x02\
    \x01\x06\x12\x04\x9b\t\x02\x16\n\r\n\x05\x04:\x02\x01\x01\x12\x04\x9b\t\
    \x17)\n\r\n\x05\x04:\x02\x01\x03\x12\x04\x9b\t,-\n=\n\x04\x04:\x02\x02\
    \x12\x04\x9e\t\x02\x20\x1a/\x20coco\x20is\x20a\x20COCO\x20export\x20of\
    \x20the\x20dataset\x20version.\n\n\r\n\x05\x04:\x02\x02\x06\x12\x04\x9e\
    \t\x02\x16\n\r\n\x05\x04:\x02\x02\x01\x12\x04\x9e\t\x17\x1b\n\r\n\x05\
    \x04:\x02\x02\x03\x12\x04\x9e\t\x1e\x1f\n[\n\x02\x04;\x12\x06\xa2\t\0\
    \xb1\t\x01\x1aM\x20DatasetVersionExport\x20contains\x20metadata\x20for\
    \x20a\x20single\x20dataset\x20version\x20export.\n\n\x0b\n\x03\x04;\x01\
    \x12\x04\xa2\t\x08\x1c\nC\n\x04\x04;\x02\0\x12\x04\xa4\t\x02(\x1a5\x20fo\
    rmat\x20is\x20the\x20format\x20of\x20the\x20dataset\x20version\x20export\
    .\n\n\r\n\x05\x04;\x02\0\x06\x12\x04\xa4\t\x02\x1c\n\r\n\x05\x04;\x02\0\
    \x01\x12\x04\xa4\t\x1d#\n\r\n\x05\x04;\x02\0\x03\x12\x04\xa4\t&'\nK\n\
    \x04\x04;\x02\x01\x12\x04\xa7\t\x02(\x1a=\x20status\x20is\x20the\x20curr\
    ent\x20status\x20of\x20the\x20dataset\x20version\x20export.\n\n\r\n\x05\
    \x04;\x02\x01\x06\x12\x04\xa7\t\x02\x1c\n\r\n\x05\x04;\x02\x01\x01\x12\
    \x04\xa7\t\x1d#\n\r\n\x05\x04;\x02\x01\x03\x12\x04\xa7\t&'\nW\n\x04\x04;\
    \x02\x02\x12\x04\xaa\t\x02\x11\x1aI\x20url\x20is\x20the\x20URL\x20from\
    \x20where\x20the\x20dataset\x20version\x20export\x20can\x20be\x20downloa\
    ded.\n\n\r\n\x05\x04;\x02\x02\x05\x12\x04\xaa\t\x02\x08\n\r\n\x05\x04;\
    \x02\x02\x01\x12\x04\xaa\t\t\x0c\n\r\n\x05\x04;\x02\x02\x03\x12\x04\xaa\
    \t\x0f\x10\nR\n\x04\x04;\x02\x03\x12\x04\xad\t\x02\x12\x1aD\x20size\x20i\
    s\x20the\x20size\x20of\x20the\x20dataset\x20version\x20export\x20in\x20n\
    umber\x20of\x20bytes.\n\n\r\n\x05\x04;\x02\x03\x05\x12\x04\xad\t\x02\x08\
    \n\r\n\x05\x04;\x02\x03\x01\x12\x04\xad\t\t\r\n\r\n\x05\x04;\x02\x03\x03\
    \x12\x04\xad\t\x10\x11\nC\n\x04\x04;\x02\x04\x12\x04\xb0\t\x02\x1e\x1a5\
    \x20whether\x20to\x20include\x20embeddings\x20in\x20the\x20export\x20or\
    \x20not.\n\n\r\n\x05\x04;\x02\x04\x05\x12\x04\xb0\t\x02\x06\n\r\n\x05\
    \x04;\x02\x04\x01\x12\x04\xb0\t\x07\x19\n\r\n\x05\x04;\x02\x04\x03\x12\
    \x04\xb0\t\x1c\x1d\n\x0c\n\x02\x05\x03\x12\x06\xb2\t\0\xc5\t\x01\n\x0b\n\
    \x03\x05\x03\x01\x12\x04\xb2\t\x05\x1f\n\x0c\n\x04\x05\x03\x02\0\x12\x04\
    \xb3\t\x02,\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\xb3\t\x02'\n\r\n\x05\x05\
    \x03\x02\0\x02\x12\x04\xb3\t*+\n\xf0\x01\n\x04\x05\x03\x02\x01\x12\x04\
    \xb9\t\x02\x1d\x1a\xe1\x01\x20CLARIFAI_DATA_PROTOBUF\x20is\x20the\x20pro\
    prietary\x20Clarifai\x20API\x20Data\x20format.\x20It\n\x20is\x20a\x20ZIP\
    -archive\x20containing\x20batches\x20of\x20serialized\x20InputBatch\x20p\
    rotobuf\x20messages.\n\n\x20Note\x20that\x20only\x20the\x20\"id\"\x20and\
    \x20\"data\"\x20fields\x20of\x20exported\x20inputs\x20are\x20set.\n\n\r\
    \n\x05\x05\x03\x02\x01\x01\x12\x04\xb9\t\x02\x18\n\r\n\x05\x05\x03\x02\
    \x01\x02\x12\x04\xb9\t\x1b\x1c\n\xf0\x01\n\x04\x05\x03\x02\x02\x12\x04\
    \xbf\t\x02\x19\x1a\xe1\x01\x20CLARIFAI_DATA_JSON\x20is\x20the\x20proprie\
    tary\x20Clarifai\x20API\x20Data\x20format\x20in\x20JSON.\x20It\n\x20is\
    \x20a\x20ZIP-archive\x20containing\x20batches\x20of\x20serialized\x20Inp\
    utBatch\x20JSON\x20messages.\n\n\x20Note\x20that\x20only\x20the\x20\"id\
    \"\x20and\x20\"data\"\x20fields\x20of\x20exported\x20inputs\x20are\x20se\
    t.\n\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\xbf\t\x02\x14\n\r\n\x05\x05\
    \x03\x02\x02\x02\x12\x04\xbf\t\x17\x18\n\xc7\x01\n\x04\x05\x03\x02\x03\
    \x12\x04\xc4\t\x02\x0b\x1a\xb8\x01\x20COCO\x20is\x20the\x20data\x20forma\
    t\x20used\x20by\x20Common\x20Objects\x20in\x20Context.\x20It\x20is\x20a\
    \n\x20ZIP-archive\x20containing\x20JSON\x20files\x20with\x20the\x20datas\
    et\x20version\x20annotations.\n\x20See\x20https://cocodataset.org/#forma\
    t-data.\n\n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\xc4\t\x02\x06\n\r\n\x05\
    \x05\x03\x02\x03\x02\x12\x04\xc4\t\t\n\nq\n\x02\x04<\x12\x06\xca\t\0\xd2\
    \t\x01\x1ac\x20DatasetVersionProcessingInfo\x20contains\x20information\
    \x20about\x20processing\x20applied\n\x20to\x20a\x20dataset\x20version.\n\
    \n\x0b\n\x03\x04<\x01\x12\x04\xca\t\x08$\n\xed\x02\n\x04\x04<\x02\0\x12\
    \x04\xd1\t\x026\x1a\xde\x02\x20If\x20frame_interpolation_info\x20is\x20s\
    et,\x20then\x20these\x20settings\x20are\x20used\x20to\n\x20interpolate\
    \x20new\x20frame\x20annotation\x20from\x20other\x20video\x20annotations.\
    \n\n\x20If\x20frame_interpolation_info\x20is\x20set\x20in\x20the\x20data\
    set\x20default_processing_info,\n\x20then\x20it\x20can\x20be\x20disabled\
    \x20for\x20a\x20single\x20dataset\x20version\x20by\x20setting\n\x20proce\
    ssing_info\x20but\x20not\x20setting\x20processing_info.frame_interpolati\
    on_info.\n\n\r\n\x05\x04<\x02\0\x06\x12\x04\xd1\t\x02\x18\n\r\n\x05\x04<\
    \x02\0\x01\x12\x04\xd1\t\x191\n\r\n\x05\x04<\x02\0\x03\x12\x04\xd1\t45\n\
    \xd6\x01\n\x02\x04=\x12\x06\xd7\t\0\xdd\t\x01\x1a\xc7\x01\x20FrameInterp\
    olationInfo\x20contains\x20information\x20about\x20frame\x20annotations\
    \n\x20interpolated\x20from\x20other\x20video\x20annotations,\x20such\x20\
    as\x20image\x20object-detection\n\x20regions\x20generated\x20from\x20vid\
    eo\x20object-tracking\x20regions.\n\n\x0b\n\x03\x04=\x01\x12\x04\xd7\t\
    \x08\x1e\n\x8f\x02\n\x04\x04=\x02\0\x12\x04\xdc\t\x02\x17\x1a\x80\x02\
    \x20sample_ms\x20is\x20the\x20sampling\x20rate\x20at\x20which\x20frame\
    \x20annotations\x20are\x20interpolated.\n\x20If\x20sample_ms\x20is\x20ze\
    ro,\x20then\x20the\x20dataset\x20default_processing_info\x20value\x20is\
    \x20used.\n\x20If\x20the\x20dataset\x20default\x20is\x20zero\x20or\x20no\
    t\x20set,\x20then\x20the\x20input\x20frame\x20prediction\n\x20sampling\
    \x20rate\x20is\x20used.\n\n\r\n\x05\x04=\x02\0\x05\x12\x04\xdc\t\x02\x08\
    \n\r\n\x05\x04=\x02\0\x01\x12\x04\xdc\t\t\x12\n\r\n\x05\x04=\x02\0\x03\
    \x12\x04\xdc\t\x15\x16\n)\n\x02\x04>\x12\x06\xe0\t\0\xe4\t\x01\x1a\x1b\
    \x20WorkflowResultsSimilarity\n\n\x0b\n\x03\x04>\x01\x12\x04\xe0\t\x08!\
    \nQ\n\x04\x04>\x02\0\x12\x04\xe2\t\x02\x18\x1aC\x20The\x20input\x20with\
    \x20the\x20specific\x20data\x20compare\x20against\x20all\x20pool\x20resu\
    lts\n\n\r\n\x05\x04>\x02\0\x06\x12\x04\xe2\t\x02\x07\n\r\n\x05\x04>\x02\
    \0\x01\x12\x04\xe2\t\x08\x13\n\r\n\x05\x04>\x02\0\x03\x12\x04\xe2\t\x16\
    \x17\n\x0c\n\x04\x04>\x02\x01\x12\x04\xe3\t\x02\x20\n\r\n\x05\x04>\x02\
    \x01\x04\x12\x04\xe3\t\x02\n\n\r\n\x05\x04>\x02\x01\x06\x12\x04\xe3\t\
    \x0b\x0e\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xe3\t\x0f\x1b\n\r\n\x05\x04>\
    \x02\x01\x03\x12\x04\xe3\t\x1e\x1f\n\x13\n\x02\x04?\x12\x06\xe7\t\0\x82\
    \n\x01\x1a\x05\x20Key\n\n\x0b\n\x03\x04?\x01\x12\x04\xe7\t\x08\x0b\nA\n\
    \x04\x04?\x02\0\x12\x04\xe9\t\x02\x10\x1a3\x20The\x20id\x20of\x20this\
    \x20key,\x20it\x20is\x20used\x20for\x20authorization.\n\n\r\n\x05\x04?\
    \x02\0\x05\x12\x04\xe9\t\x02\x08\n\r\n\x05\x04?\x02\0\x01\x12\x04\xe9\t\
    \t\x0b\n\r\n\x05\x04?\x02\0\x03\x12\x04\xe9\t\x0e\x0f\ni\n\x04\x04?\x02\
    \x01\x12\x04\xeb\t\x02\x12\x1a[\x20The\x20type\x20of\x20key,\x20it\x20ca\
    n\x20be\x20api_key\x20or\x20personal_access_token,\x20the\x20default\x20\
    value\x20is\x20api_key\n\n\r\n\x05\x04?\x02\x01\x05\x12\x04\xeb\t\x02\
    \x08\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xeb\t\t\r\n\r\n\x05\x04?\x02\x01\
    \x03\x12\x04\xeb\t\x10\x11\n\x1f\n\x04\x04?\x02\x02\x12\x04\xed\t\x02\
    \x19\x1a\x11\x20The\x20description\n\n\r\n\x05\x04?\x02\x02\x05\x12\x04\
    \xed\t\x02\x08\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xed\t\t\x14\n\r\n\x05\
    \x04?\x02\x02\x03\x12\x04\xed\t\x17\x18\n1\n\x04\x04?\x02\x03\x12\x04\
    \xef\t\x02\x1d\x1a#\x20The\x20low-level\x20scopes\x20this\x20key\x20has\
    \n\n\r\n\x05\x04?\x02\x03\x04\x12\x04\xef\t\x02\n\n\r\n\x05\x04?\x02\x03\
    \x05\x12\x04\xef\t\x0b\x11\n\r\n\x05\x04?\x02\x03\x01\x12\x04\xef\t\x12\
    \x18\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xef\t\x1b\x1c\n6\n\x04\x04?\x02\
    \x04\x12\x04\xf1\t\x02\x20\x1a(\x20The\x20endpoint-level\x20scopes\x20th\
    is\x20key\x20has\n\n\r\n\x05\x04?\x02\x04\x04\x12\x04\xf1\t\x02\n\n\r\n\
    \x05\x04?\x02\x04\x05\x12\x04\xf1\t\x0b\x11\n\r\n\x05\x04?\x02\x04\x01\
    \x12\x04\xf1\t\x12\x1b\n\r\n\x05\x04?\x02\x04\x03\x12\x04\xf1\t\x1e\x1f\
    \n\x9f\x01\n\x04\x04?\x02\x05\x12\x04\xf4\t\x02\x18\x1a\x90\x01\x20The\
    \x20apps\x20that\x20this\x20key\x20give\x20you\x20access\x20to,\x20it\
    \x20is\x20empty\x20if\x20this\x20key\x20is\x20personal_access_token\n\
    \x20API\x20key\x20can\x20only\x20give\x20you\x20access\x20to\x20a\x20sin\
    gle\x20app.\n\n\r\n\x05\x04?\x02\x05\x04\x12\x04\xf4\t\x02\n\n\r\n\x05\
    \x04?\x02\x05\x06\x12\x04\xf4\t\x0b\x0e\n\r\n\x05\x04?\x02\x05\x01\x12\
    \x04\xf4\t\x0f\x13\n\r\n\x05\x04?\x02\x05\x03\x12\x04\xf4\t\x16\x17\n\
    \xfe\x01\n\x04\x04?\x02\x06\x12\x04\xfb\t\x02+\x1a\xef\x01\x20When\x20th\
    e\x20key\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20timestamp\
    \n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\x20fo\
    rmat:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20expect\
    \x20results\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\x20\"\
    2017-04-11T21:50:50.223962Z\"\n\n\r\n\x05\x04?\x02\x06\x06\x12\x04\xfb\t\
    \x02\x1b\n\r\n\x05\x04?\x02\x06\x01\x12\x04\xfb\t\x1c&\n\r\n\x05\x04?\
    \x02\x06\x03\x12\x04\xfb\t)*\nP\n\x04\x04?\x02\x07\x12\x04\xfe\t\x02+\
    \x1aB\x20When\x20does\x20the\x20key\x20expires,\x20the\x20key\x20won't\
    \x20expire\x20if\x20this\x20is\x20empty\n\n\r\n\x05\x04?\x02\x07\x06\x12\
    \x04\xfe\t\x02\x1b\n\r\n\x05\x04?\x02\x07\x01\x12\x04\xfe\t\x1c&\n\r\n\
    \x05\x04?\x02\x07\x03\x12\x04\xfe\t)*\nD\n\x04\x04?\x02\x08\x12\x04\x81\
    \n\x02)\x1a6\x20list\x20of\x20idp\x20ids\x20at\x20which\x20key\x20is\x20\
    currently\x20authorized\n\n\r\n\x05\x04?\x02\x08\x04\x12\x04\x81\n\x02\n\
    \n\r\n\x05\x04?\x02\x08\x05\x12\x04\x81\n\x0b\x11\n\r\n\x05\x04?\x02\x08\
    \x01\x12\x04\x81\n\x12$\n\r\n\x05\x04?\x02\x08\x03\x12\x04\x81\n'(\n\x0c\
    \n\x02\x05\x04\x12\x06\x85\n\0\x8a\n\x01\n\x0b\n\x03\x05\x04\x01\x12\x04\
    \x85\n\x05\x15\n\x0c\n\x04\x05\x04\x02\0\x12\x04\x86\n\x02\x20\n\r\n\x05\
    \x05\x04\x02\0\x01\x12\x04\x86\n\x02\x1b\n\r\n\x05\x05\x04\x02\0\x02\x12\
    \x04\x86\n\x1e\x1f\n?\n\x04\x05\x04\x02\x01\x12\x04\x88\n\x02\x0c\"1\x20\
    Progressively\x20delay\x20the\x20execution\x20of\x20operations\n\n\r\n\
    \x05\x05\x04\x02\x01\x01\x12\x04\x88\n\x02\x07\n\r\n\x05\x05\x04\x02\x01\
    \x02\x12\x04\x88\n\n\x0b\n!\n\x04\x05\x04\x02\x02\x12\x04\x89\n\x02\r\"\
    \x13\x20Cease\x20functioning\n\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\x89\
    \n\x02\x08\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\x89\n\x0b\x0c\n\x0c\n\
    \x02\x05\x05\x12\x06\x8c\n\0\x92\n\x01\n\x0b\n\x03\x05\x05\x01\x12\x04\
    \x8c\n\x05\x11\n\x0c\n\x04\x05\x05\x02\0\x12\x04\x8d\n\x02\x1c\n\r\n\x05\
    \x05\x05\x02\0\x01\x12\x04\x8d\n\x02\x17\n\r\n\x05\x05\x05\x02\0\x02\x12\
    \x04\x8d\n\x1a\x1b\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\x8f\n\x02\x0e\n\r\
    \n\x05\x05\x05\x02\x01\x01\x12\x04\x8f\n\x02\t\n\r\n\x05\x05\x05\x02\x01\
    \x02\x12\x04\x8f\n\x0c\r\n\x0c\n\x04\x05\x05\x02\x02\x12\x04\x90\n\x02\
    \x0c\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\x90\n\x02\x07\n\r\n\x05\x05\
    \x05\x02\x02\x02\x12\x04\x90\n\n\x0b\n\x0c\n\x04\x05\x05\x02\x03\x12\x04\
    \x91\n\x02\r\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\x91\n\x02\x08\n\r\n\
    \x05\x05\x05\x02\x03\x02\x12\x04\x91\n\x0b\x0c\n\xdb\x06\n\x02\x04@\x12\
    \x06\xa0\n\0\xef\n\x01\x1a\xcc\x06\x20This\x20is\x20the\x20Model\x20obje\
    ct\x20which\x20represents\x20a\x20created\x20model\x20in\x20the\x20platf\
    orm.\n\x20Each\x20model\x20has\x20a\x20particular\x20type\x20denoted\x20\
    by\x20the\x20model_type_id.\n\x20When\x20creating\x20a\x20Model\x20with\
    \x20PostModels\x20the\x20following\x20happens:\n\x20\x20-\x20if\x20the\
    \x20ModelType\x20is\x20trainable,\x20then\x20a\x20new\x20ModelVersion\
    \x20is\x20created\x20that\x20is\n\x20\x20\x20\x20-\x20UNTRAINED\x20statu\
    s\x20by\x20default\n\x20\x20\x20\x20-\x20TRAINED\x20status\x20if\x20a\
    \x20ModelVersion\x20was\x20included\x20with\x20PretrainedModelConfig\x20\
    in\x20PostModels\n\x20\x20-\x20if\x20the\x20ModelType\x20is\x20not\x20tr\
    ainable,\x20then\x20a\x20new\x20ModelVersion\x20is\x20created\x20with\
    \x20TRAINED\x20status.\n\x20To\x20modify\x20config\x20settings\x20like\
    \x20OutputInfo\x20for\x20the\x20Model\x20you\x20an\x20use\x20PatchModels\
    .\x20This\x20will\n\x20also\x20create\x20a\x20new\x20ModelVersion,\x20po\
    tentially\x20UNTRAINED\x20following\x20the\x20same\x20rules\x20as\x20abo\
    ve.\n\x20The\x20fields\x20that\x20are\x20patchable\x20include\x20Model.n\
    ame,\x20Model.display_name\x20and\x20Model.output_info\n\x20(except\x20t\
    he\x20Model.output_info.type\x20and\x20Model.output_info.type_ext).\n\n\
    \x0b\n\x03\x04@\x01\x12\x04\xa0\n\x08\r\n\x0b\n\x03\x04@\t\x12\x04\xa1\n\
    \x02%\n\x0c\n\x04\x04@\t\0\x12\x04\xa1\n\x0b\x0c\n\r\n\x05\x04@\t\0\x01\
    \x12\x04\xa1\n\x0b\x0c\n\r\n\x05\x04@\t\0\x02\x12\x04\xa1\n\x0b\x0c\n\
    \x0c\n\x04\x04@\t\x01\x12\x04\xa1\n\x0e\x10\n\r\n\x05\x04@\t\x01\x01\x12\
    \x04\xa1\n\x0e\x10\n\r\n\x05\x04@\t\x01\x02\x12\x04\xa1\n\x0e\x10\n\x0c\
    \n\x04\x04@\t\x02\x12\x04\xa1\n\x12\x14\n\r\n\x05\x04@\t\x02\x01\x12\x04\
    \xa1\n\x12\x14\n\r\n\x05\x04@\t\x02\x02\x12\x04\xa1\n\x12\x14\n\x0c\n\
    \x04\x04@\t\x03\x12\x04\xa1\n\x16\x18\n\r\n\x05\x04@\t\x03\x01\x12\x04\
    \xa1\n\x16\x18\n\r\n\x05\x04@\t\x03\x02\x12\x04\xa1\n\x16\x18\n\x0c\n\
    \x04\x04@\t\x04\x12\x04\xa1\n\x1a\x1c\n\r\n\x05\x04@\t\x04\x01\x12\x04\
    \xa1\n\x1a\x1c\n\r\n\x05\x04@\t\x04\x02\x12\x04\xa1\n\x1a\x1c\n\x0c\n\
    \x04\x04@\t\x05\x12\x04\xa1\n\x1e\x20\n\r\n\x05\x04@\t\x05\x01\x12\x04\
    \xa1\n\x1e\x20\n\r\n\x05\x04@\t\x05\x02\x12\x04\xa1\n\x1e\x20\n\x0c\n\
    \x04\x04@\t\x06\x12\x04\xa1\n\"$\n\r\n\x05\x04@\t\x06\x01\x12\x04\xa1\n\
    \"$\n\r\n\x05\x04@\t\x06\x02\x12\x04\xa1\n\"$\nX\n\x04\x04@\x02\0\x12\
    \x04\xa4\n\x02\x10\x1aJ\x20The\x20model's\x20ID.\x20Must\x20be\x20unique\
    \x20within\x20a\x20particular\x20app\x20and\x20URL-friendly.\n\n\r\n\x05\
    \x04@\x02\0\x05\x12\x04\xa4\n\x02\x08\n\r\n\x05\x04@\x02\0\x01\x12\x04\
    \xa4\n\t\x0b\n\r\n\x05\x04@\x02\0\x03\x12\x04\xa4\n\x0e\x0f\nF\n\x04\x04\
    @\x02\x01\x12\x04\xa6\n\x02&\x1a8\x20DEPRECATED:\x20Please\x20use\x20the\
    \x20model\x20id\x20to\x20name\x20the\x20model.\n\n\r\n\x05\x04@\x02\x01\
    \x05\x12\x04\xa6\n\x02\x08\n\r\n\x05\x04@\x02\x01\x01\x12\x04\xa6\n\t\r\
    \n\r\n\x05\x04@\x02\x01\x03\x12\x04\xa6\n\x10\x11\n\r\n\x05\x04@\x02\x01\
    \x08\x12\x04\xa6\n\x12%\n\x0e\n\x06\x04@\x02\x01\x08\x03\x12\x04\xa6\n\
    \x13$\n\x82\x02\n\x04\x04@\x02\x02\x12\x04\xac\n\x02+\x1a\xf3\x01\x20Whe\
    n\x20the\x20model\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20t\
    imestamp\n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.t\
    xt\x20format:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\
    \x20expect\x20results\x20like\n\x20\x20the\x20following\x20from\x20the\
    \x20API:\n\x20\x20\"2017-04-11T21:50:50.223962Z\"\n\n\r\n\x05\x04@\x02\
    \x02\x06\x12\x04\xac\n\x02\x1b\n\r\n\x05\x04@\x02\x02\x01\x12\x04\xac\n\
    \x1c&\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xac\n)*\nA\n\x04\x04@\x02\x03\
    \x12\x04\xae\n\x02-\x1a3\x20When\x20was\x20the\x20most\x20recent\x20mode\
    l\x20version\x20created\x20at\n\n\r\n\x05\x04@\x02\x03\x06\x12\x04\xae\n\
    \x02\x1b\n\r\n\x05\x04@\x02\x03\x01\x12\x04\xae\n\x1c'\n\r\n\x05\x04@\
    \x02\x03\x03\x12\x04\xae\n*,\n-\n\x04\x04@\x02\x04\x12\x04\xb0\n\x02C\
    \x1a\x1f\x20The\x20app\x20the\x20model\x20belongs\x20to.\n\n\r\n\x05\x04\
    @\x02\x04\x05\x12\x04\xb0\n\x02\x08\n\r\n\x05\x04@\x02\x04\x01\x12\x04\
    \xb0\n\t\x0f\n\r\n\x05\x04@\x02\x04\x03\x12\x04\xb0\n\x12\x13\n\r\n\x05\
    \x04@\x02\x04\x08\x12\x04\xb0\n\x14B\n\x10\n\x08\x04@\x02\x04\x08\xd0\
    \x86\x03\x12\x04\xb0\n\x15A\nl\n\x04\x04@\x02\x05\x12\x04\xb3\n\x021\x1a\
    ^\x20Info\x20about\x20the\x20model's\x20output\x20and\x20configuration.\
    \n\x20DEPRECATED:\x20Will\x20be\x20moved\x20to\x20model\x20version\n\n\r\
    \n\x05\x04@\x02\x05\x06\x12\x04\xb3\n\x02\x0c\n\r\n\x05\x04@\x02\x05\x01\
    \x12\x04\xb3\n\r\x18\n\r\n\x05\x04@\x02\x05\x03\x12\x04\xb3\n\x1b\x1c\n\
    \r\n\x05\x04@\x02\x05\x08\x12\x04\xb3\n\x1d0\n\x0e\n\x06\x04@\x02\x05\
    \x08\x03\x12\x04\xb3\n\x1e/\n\xc2\x01\n\x04\x04@\x02\x06\x12\x04\xb6\n\
    \x02!\x1a\xb3\x01\x20A\x20particular\x20version\x20of\x20the\x20model,\
    \x20e.g.,\x20to\x20specify\x20the\x20version\x20when\x20creating\x20a\
    \x20workflow\x20or\n\x20when\x20listing\x20Models\x20to\x20include\x20th\
    e\x20latest\x20ModelVersion\x20of\x20the\x20model\x20in\x20the\x20respon\
    se.\n\n\r\n\x05\x04@\x02\x06\x06\x12\x04\xb6\n\x02\x0e\n\r\n\x05\x04@\
    \x02\x06\x01\x12\x04\xb6\n\x0f\x1c\n\r\n\x05\x04@\x02\x06\x03\x12\x04\
    \xb6\n\x1f\x20\nF\n\x04\x04@\x02\x07\x12\x04\xb8\n\x02.\x1a8\x20DEPRECAT\
    ED:\x20Please\x20use\x20the\x20model\x20id\x20to\x20name\x20the\x20model\
    .\n\n\r\n\x05\x04@\x02\x07\x05\x12\x04\xb8\n\x02\x08\n\r\n\x05\x04@\x02\
    \x07\x01\x12\x04\xb8\n\t\x15\n\r\n\x05\x04@\x02\x07\x03\x12\x04\xb8\n\
    \x18\x19\n\r\n\x05\x04@\x02\x07\x08\x12\x04\xb8\n\x1a-\n\x0e\n\x06\x04@\
    \x02\x07\x08\x03\x12\x04\xb8\n\x1b,\n6\n\x04\x04@\x02\x08\x12\x04\xba\n\
    \x02\x15\x1a(\x20The\x20user\x20id\x20that\x20the\x20model\x20belongs\
    \x20to.\n\n\r\n\x05\x04@\x02\x08\x05\x12\x04\xba\n\x02\x08\n\r\n\x05\x04\
    @\x02\x08\x01\x12\x04\xba\n\t\x10\n\r\n\x05\x04@\x02\x08\x03\x12\x04\xba\
    \n\x13\x14\nP\n\x04\x04@\x02\t\x12\x04\xbd\n\x02\"\x1aB\x20The\x20defaul\
    t\x20evaluation\x20info.\x20Can\x20be\x20overwritten\x20by\x20eval\x20re\
    quest.\n\n\r\n\x05\x04@\x02\t\x06\x12\x04\xbd\n\x02\n\n\r\n\x05\x04@\x02\
    \t\x01\x12\x04\xbd\n\x0b\x1c\n\r\n\x05\x04@\x02\t\x03\x12\x04\xbd\n\x1f!\
    \n\xa5\x01\n\x04\x04@\x02\n\x12\x04\xc0\n\x02\x1c\x1a\x96\x01\x20The\x20\
    ModelType.Id\x20that\x20is\x20used\x20for\x20this\x20model.\x20This\x20i\
    s\x20used\x20for\x20all\x20versions\x20and\x20you\x20cannot\n\x20change\
    \x20model_type_id\x20between\x20versions\x20of\x20the\x20same\x20model.\
    \n\n\r\n\x05\x04@\x02\n\x05\x12\x04\xc0\n\x02\x08\n\r\n\x05\x04@\x02\n\
    \x01\x12\x04\xc0\n\t\x16\n\r\n\x05\x04@\x02\n\x03\x12\x04\xc0\n\x19\x1b\
    \n4\n\x04\x04@\x02\x0b\x12\x04\xc2\n\x02\x13\x1a&\x20The\x20task\x20the\
    \x20model\x20was\x20trained\x20to\x20do\n\n\r\n\x05\x04@\x02\x0b\x05\x12\
    \x04\xc2\n\x02\x08\n\r\n\x05\x04@\x02\x0b\x01\x12\x04\xc2\n\t\r\n\r\n\
    \x05\x04@\x02\x0b\x03\x12\x04\xc2\n\x10\x12\n\xdd\x01\n\x04\x04@\x02\x0c\
    \x12\x04\xc7\n\x02\x1d\x1a\xce\x01\x20The\x20visibility\x20field\x20repr\
    esents\x20whether\x20this\x20message\x20is\x20privately/publicly\x20visi\
    ble.\n\x20To\x20be\x20visible\x20to\x20the\x20public\x20the\x20App\x20th\
    at\x20contains\x20it\x20AND\x20the\x20User\x20that\x20contains\x20the\
    \x20App\x20must\n\x20also\x20be\x20publicly\x20visible.\n\n\r\n\x05\x04@\
    \x02\x0c\x06\x12\x04\xc7\n\x02\x0c\n\r\n\x05\x04@\x02\x0c\x01\x12\x04\
    \xc7\n\r\x17\n\r\n\x05\x04@\x02\x0c\x03\x12\x04\xc7\n\x1a\x1c\n2\n\x04\
    \x04@\x02\r\x12\x04\xca\n\x02\x1a\x1a$\x20Short\x20description\x20about\
    \x20this\x20model\n\n\r\n\x05\x04@\x02\r\x05\x12\x04\xca\n\x02\x08\n\r\n\
    \x05\x04@\x02\r\x01\x12\x04\xca\n\t\x14\n\r\n\x05\x04@\x02\r\x03\x12\x04\
    \xca\n\x17\x19\n\x9f\x01\n\x04\x04@\x02\x0e\x12\x04\xce\n\x02'\x1a\x90\
    \x01\x20To\x20handle\x20arbitrary\x20json\x20metadata\x20you\x20can\x20u\
    se\x20a\x20struct\x20field:\n\x20https://github.com/google/protobuf/blob\
    /master/src/google/protobuf/struct.proto\n\n\r\n\x05\x04@\x02\x0e\x06\
    \x12\x04\xce\n\x02\x18\n\r\n\x05\x04@\x02\x0e\x01\x12\x04\xce\n\x19!\n\r\
    \n\x05\x04@\x02\x0e\x03\x12\x04\xce\n$&\n\x0c\n\x04\x04@\x02\x0f\x12\x04\
    \xcf\n\x02&\n\r\n\x05\x04@\x02\x0f\x06\x12\x04\xcf\n\x02\x18\n\r\n\x05\
    \x04@\x02\x0f\x01\x12\x04\xcf\n\x19\x20\n\r\n\x05\x04@\x02\x0f\x03\x12\
    \x04\xcf\n#%\nk\n\x04\x04@\x02\x10\x12\x04\xd3\n\x02\x14\x1a]\x20Notes\
    \x20for\x20the\x20model\n\x20This\x20field\x20should\x20be\x20used\x20fo\
    r\x20in-depth\x20notes\x20and\x20supports\x20up\x20to\x2064Kbs.\n\n\r\n\
    \x05\x04@\x02\x10\x05\x12\x04\xd3\n\x02\x08\n\r\n\x05\x04@\x02\x10\x01\
    \x12\x04\xd3\n\t\x0e\n\r\n\x05\x04@\x02\x10\x03\x12\x04\xd3\n\x11\x13\n+\
    \n\x04\x04@\x02\x11\x12\x04\xd6\n\x02O\x1a\x1d\x20Tags\x20from\x20toolki\
    ts\x20category\n\n\r\n\x05\x04@\x02\x11\x04\x12\x04\xd6\n\x02\n\n\r\n\
    \x05\x04@\x02\x11\x05\x12\x04\xd6\n\x0b\x11\n\r\n\x05\x04@\x02\x11\x01\
    \x12\x04\xd6\n\x12\x1a\n\r\n\x05\x04@\x02\x11\x03\x12\x04\xd6\n\x1d\x1f\
    \n\r\n\x05\x04@\x02\x11\x08\x12\x04\xd6\n\x20N\n\x10\n\x08\x04@\x02\x11\
    \x08\xd0\x86\x03\x12\x04\xd6\n!M\n,\n\x04\x04@\x02\x12\x12\x04\xd8\n\x02\
    P\x1a\x1e\x20Tags\x20from\x20use_cases\x20category\n\n\r\n\x05\x04@\x02\
    \x12\x04\x12\x04\xd8\n\x02\n\n\r\n\x05\x04@\x02\x12\x05\x12\x04\xd8\n\
    \x0b\x11\n\r\n\x05\x04@\x02\x12\x01\x12\x04\xd8\n\x12\x1b\n\r\n\x05\x04@\
    \x02\x12\x03\x12\x04\xd8\n\x1e\x20\n\r\n\x05\x04@\x02\x12\x08\x12\x04\
    \xd8\n!O\n\x10\n\x08\x04@\x02\x12\x08\xd0\x86\x03\x12\x04\xd8\n\"N\n-\n\
    \x04\x04@\x02\x13\x12\x04\xda\n\x02P\x1a\x1f\x20Tags\x20from\x20language\
    s\x20category.\n\n\r\n\x05\x04@\x02\x13\x04\x12\x04\xda\n\x02\n\n\r\n\
    \x05\x04@\x02\x13\x05\x12\x04\xda\n\x0b\x11\n\r\n\x05\x04@\x02\x13\x01\
    \x12\x04\xda\n\x12\x1b\n\r\n\x05\x04@\x02\x13\x03\x12\x04\xda\n\x1e\x20\
    \n\r\n\x05\x04@\x02\x13\x08\x12\x04\xda\n!O\n\x10\n\x08\x04@\x02\x13\x08\
    \xd0\x86\x03\x12\x04\xda\n\"N\nP\n\x04\x04@\x02\x14\x12\x04\xdc\n\x02V\
    \x1aB\x20Tags\x20from\x20languages\x20category\x20with\x20names,\x20only\
    \x20used\x20in\x20responses.\n\n\r\n\x05\x04@\x02\x14\x04\x12\x04\xdc\n\
    \x02\n\n\r\n\x05\x04@\x02\x14\x06\x12\x04\xdc\n\x0b\x12\n\r\n\x05\x04@\
    \x02\x14\x01\x12\x04\xdc\n\x13!\n\r\n\x05\x04@\x02\x14\x03\x12\x04\xdc\n\
    $&\n\r\n\x05\x04@\x02\x14\x08\x12\x04\xdc\n'U\n\x10\n\x08\x04@\x02\x14\
    \x08\xd0\x86\x03\x12\x04\xdc\n(T\n\x0c\n\x04\x04@\x02\x15\x12\x04\xde\n\
    \x02U\n\r\n\x05\x04@\x02\x15\x04\x12\x04\xde\n\x02\n\n\r\n\x05\x04@\x02\
    \x15\x05\x12\x04\xde\n\x0b\x11\n\r\n\x05\x04@\x02\x15\x01\x12\x04\xde\n\
    \x12\x20\n\r\n\x05\x04@\x02\x15\x03\x12\x04\xde\n#%\n\r\n\x05\x04@\x02\
    \x15\x08\x12\x04\xde\n&T\n\x10\n\x08\x04@\x02\x15\x08\xd0\x86\x03\x12\
    \x04\xde\n'S\n\xa2\x01\n\x04\x04@\x02\x16\x12\x04\xe2\n\x02\x17\x1a\x93\
    \x01\x20Is\x20starred\x20by\x20the\x20requesting\x20user\x20(only\x20sho\
    wed\x20on\x20get/list\x20requests)\n\x20Please\x20use\x20PostModelStars/\
    DeleteModelStars\x20endpoints\x20to\x20star/unstar\x20a\x20model\n\n\r\n\
    \x05\x04@\x02\x16\x05\x12\x04\xe2\n\x02\x06\n\r\n\x05\x04@\x02\x16\x01\
    \x12\x04\xe2\n\x07\x11\n\r\n\x05\x04@\x02\x16\x03\x12\x04\xe2\n\x14\x16\
    \nv\n\x04\x04@\x02\x17\x12\x04\xe5\n\x02\x18\x1ah\x20How\x20many\x20user\
    s\x20have\x20starred\x20the\x20model\x20(only\x20showed\x20on\x20get/lis\
    t\x20requests)\n\x20Computed\x20value,\x20not\x20editable\n\n\r\n\x05\
    \x04@\x02\x17\x05\x12\x04\xe5\n\x02\x07\n\r\n\x05\x04@\x02\x17\x01\x12\
    \x04\xe5\n\x08\x12\n\r\n\x05\x04@\x02\x17\x03\x12\x04\xe5\n\x15\x17\nR\n\
    \x04\x04@\x02\x18\x12\x04\xe8\n\x026\x1aD\x20Whether\x20it's\x20recommen\
    ded\x20that\x20this\x20model\x20is\x20used\x20within\x20a\x20workflow\n\
    \n\r\n\x05\x04@\x02\x18\x06\x12\x04\xe8\n\x02\x1b\n\r\n\x05\x04@\x02\x18\
    \x01\x12\x04\xe8\n\x1c0\n\r\n\x05\x04@\x02\x18\x03\x12\x04\xe8\n35\n\x99\
    \x01\n\x04\x04@\x02\x19\x12\x04\xec\n\x02&\x1a\x8a\x01\x20bookmark\x20in\
    fo.\x20When\x20set,\x20this\x20model\x20is\x20a\x20bookmarked\x20model\
    \x20of\x20this\x20app.\n\x20Info\x20in\x20this\x20field\x20will\x20allow\
    \x20you\x20to\x20find/access\x20original\x20model.\n\n\r\n\x05\x04@\x02\
    \x19\x06\x12\x04\xec\n\x02\x10\n\r\n\x05\x04@\x02\x19\x01\x12\x04\xec\n\
    \x11\x20\n\r\n\x05\x04@\x02\x19\x03\x12\x04\xec\n#%\n3\n\x04\x04@\x02\
    \x1a\x12\x04\xee\n\x02\x13\x1a%\x20Representative\x20image\x20for\x20thi\
    s\x20model\n\n\r\n\x05\x04@\x02\x1a\x06\x12\x04\xee\n\x02\x07\n\r\n\x05\
    \x04@\x02\x1a\x01\x12\x04\xee\n\x08\r\n\r\n\x05\x04@\x02\x1a\x03\x12\x04\
    \xee\n\x10\x12\nc\n\x02\x04A\x12\x06\xf2\n\0\x82\x0b\x01\x1aU\x20A\x20li\
    nk\x20to\x20a\x20html/markdown/text\x20file\x20that\x20stores\x20referen\
    ce\x20material\x20tied\x20to\x20a\x20model.\n\n\x0b\n\x03\x04A\x01\x12\
    \x04\xf2\n\x08\x16\n#\n\x04\x04A\x02\0\x12\x04\xf4\n\x02\x10\x1a\x15\x20\
    Id\x20of\x20the\x20reference\n\n\r\n\x05\x04A\x02\0\x05\x12\x04\xf4\n\
    \x02\x08\n\r\n\x05\x04A\x02\0\x01\x12\x04\xf4\n\t\x0b\n\r\n\x05\x04A\x02\
    \0\x03\x12\x04\xf4\n\x0e\x0f\nD\n\x04\x04A\x02\x01\x12\x04\xf7\n\x02\x16\
    \x1a6\x20The\x20id\x20of\x20the\x20model\x20this\x20Model\x20reference\
    \x20is\x20tied\x20to.\n\n\r\n\x05\x04A\x02\x01\x05\x12\x04\xf7\n\x02\x08\
    \n\r\n\x05\x04A\x02\x01\x01\x12\x04\xf7\n\t\x11\n\r\n\x05\x04A\x02\x01\
    \x03\x12\x04\xf7\n\x14\x15\n#\n\x04\x04A\x02\x02\x12\x04\xfa\n\x02\x11\
    \x1a\x15\x20address\x20of\x20resource\n\n\r\n\x05\x04A\x02\x02\x05\x12\
    \x04\xfa\n\x02\x08\n\r\n\x05\x04A\x02\x02\x01\x12\x04\xfa\n\t\x0c\n\r\n\
    \x05\x04A\x02\x02\x03\x12\x04\xfa\n\x0f\x10\n\x1c\n\x04\x04A\x02\x03\x12\
    \x04\xfd\n\x02\x12\x1a\x0e\x20name\x20of\x20link\n\n\r\n\x05\x04A\x02\
    \x03\x05\x12\x04\xfd\n\x02\x08\n\r\n\x05\x04A\x02\x03\x01\x12\x04\xfd\n\
    \t\r\n\r\n\x05\x04A\x02\x03\x03\x12\x04\xfd\n\x10\x11\n\x83\x01\n\x04\
    \x04A\x02\x04\x12\x04\x81\x0b\x02&\x1au\x20To\x20handle\x20arbitrary\x20\
    json\x20metadata:\n\x20https://github.com/google/protobuf/blob/master/sr\
    c/google/protobuf/struct.proto\n\n\r\n\x05\x04A\x02\x04\x06\x12\x04\x81\
    \x0b\x02\x18\n\r\n\x05\x04A\x02\x04\x01\x12\x04\x81\x0b\x19!\n\r\n\x05\
    \x04A\x02\x04\x03\x12\x04\x81\x0b$%\n(\n\x02\x04B\x12\x06\x85\x0b\0\x92\
    \x0b\x01\x1a\x1a\x20ModelVersionInputExample\n\n\x0b\n\x03\x04B\x01\x12\
    \x04\x85\x0b\x08\x20\n\x1e\n\x04\x04B\x02\0\x12\x04\x87\x0b\x02\x10\x1a\
    \x10\x20user\x20unique\x20id\n\n\r\n\x05\x04B\x02\0\x05\x12\x04\x87\x0b\
    \x02\x08\n\r\n\x05\x04B\x02\0\x01\x12\x04\x87\x0b\t\x0b\n\r\n\x05\x04B\
    \x02\0\x03\x12\x04\x87\x0b\x0e\x0f\n$\n\x04\x04B\x02\x01\x12\x04\x89\x0b\
    \x02\x16\x1a\x16\x20external\x20id\x20of\x20model\n\n\r\n\x05\x04B\x02\
    \x01\x05\x12\x04\x89\x0b\x02\x08\n\r\n\x05\x04B\x02\x01\x01\x12\x04\x89\
    \x0b\t\x11\n\r\n\x05\x04B\x02\x01\x03\x12\x04\x89\x0b\x14\x15\n,\n\x04\
    \x04B\x02\x02\x12\x04\x8b\x0b\x02\x1e\x1a\x1e\x20external\x20id\x20of\
    \x20model\x20version\n\n\r\n\x05\x04B\x02\x02\x05\x12\x04\x8b\x0b\x02\
    \x08\n\r\n\x05\x04B\x02\x02\x01\x12\x04\x8b\x0b\t\x19\n\r\n\x05\x04B\x02\
    \x02\x03\x12\x04\x8b\x0b\x1c\x1d\n8\n\x04\x04B\x02\x03\x12\x04\x8d\x0b\
    \x02\x10\x1a*\x20data\x20to\x20store\x20as\x20example\x20input\x20for\
    \x20model\n\n\r\n\x05\x04B\x02\x03\x06\x12\x04\x8d\x0b\x02\x06\n\r\n\x05\
    \x04B\x02\x03\x01\x12\x04\x8d\x0b\x07\x0b\n\r\n\x05\x04B\x02\x03\x03\x12\
    \x04\x8d\x0b\x0e\x0f\n(\n\x04\x04B\x02\x04\x12\x04\x8f\x0b\x02\x12\x1a\
    \x1a\x20name\x20of\x20link\x20for\x20display\n\n\r\n\x05\x04B\x02\x04\
    \x05\x12\x04\x8f\x0b\x02\x08\n\r\n\x05\x04B\x02\x04\x01\x12\x04\x8f\x0b\
    \t\r\n\r\n\x05\x04B\x02\x04\x03\x12\x04\x8f\x0b\x10\x11\n,\n\x04\x04B\
    \x02\x05\x12\x04\x91\x0b\x02\x19\x1a\x1e\x20description\x20of\x20link\
    \x20contents\n\n\r\n\x05\x04B\x02\x05\x05\x12\x04\x91\x0b\x02\x08\n\r\n\
    \x05\x04B\x02\x05\x01\x12\x04\x91\x0b\t\x14\n\r\n\x05\x04B\x02\x05\x03\
    \x12\x04\x91\x0b\x17\x18\n\xb4\x05\n\x02\x04C\x12\x06\x9c\x0b\0\xae\x0b\
    \x01\x1a\xa5\x05\x20OutputInfo\x20defines\x20some\x20of\x20the\x20settin\
    gs\x20for\x20each\x20model\x20version\x20that\x20PatchModels\x20can\x20e\
    ffect.\x20These\n\x20parameters\x20control\x20some\x20of\x20the\x20train\
    ing\x20or\x20inference\x20operations\x20that\x20this\x20model\x20can\x20\
    do.\n\x20As\x20the\x20number\x20of\x20parameters\x20continued\x20to\x20g\
    row\x20when\x20we\x20launched\x20more\x20ModelTypes\x20we\x20decided\x20\
    to\x20move\n\x20to\x20using\x20the\x20OutputInfo.params\x20field\x20whic\
    h\x20is\x20a\x20Struct\x20(or\x20JSON\x20object\x20if\x20you're\x20using\
    \n\x20our\x20JSON\x20REST\x20APIs).\x20This\x20allows\x20each\x20ModelTy\
    pe\x20to\x20define\x20the\x20set\x20of\x20fields,\x20their\x20default\
    \x20values\n\x20and\x20description\x20of\x20each\x20field\x20so\x20that\
    \x20we\x20can\x20display\x20those\x20in\x20Portal\x20and\x20make\x20the\
    \x20creation\x20of\n\x20Model's\x20very\x20extensible.\x20The\x20OutputC\
    onfig\x20object\x20will\x20eventually\x20go\x20away\x20in\x20favor\x20of\
    \n\x20infer_params\x20struct.\n\n\x0b\n\x03\x04C\x01\x12\x04\x9c\x0b\x08\
    \x12\n\x0b\n\x03\x04C\t\x12\x04\x9d\x0b\x02\x10\n\x0c\n\x04\x04C\t\0\x12\
    \x04\x9d\x0b\x0b\x0c\n\r\n\x05\x04C\t\0\x01\x12\x04\x9d\x0b\x0b\x0c\n\r\
    \n\x05\x04C\t\0\x02\x12\x04\x9d\x0b\x0b\x0c\n\x0c\n\x04\x04C\t\x01\x12\
    \x04\x9d\x0b\x0e\x0f\n\r\n\x05\x04C\t\x01\x01\x12\x04\x9d\x0b\x0e\x0f\n\
    \r\n\x05\x04C\t\x01\x02\x12\x04\x9d\x0b\x0e\x0f\nL\n\x04\x04C\x02\0\x12\
    \x04\x9f\x0b\x02\x10\x1a>\x20List\x20of\x20concepts\x20or\x20other\x20ou\
    tput\x20related\x20data\x20for\x20the\x20model.\n\n\r\n\x05\x04C\x02\0\
    \x06\x12\x04\x9f\x0b\x02\x06\n\r\n\x05\x04C\x02\0\x01\x12\x04\x9f\x0b\
    \x07\x0b\n\r\n\x05\x04C\x02\0\x03\x12\x04\x9f\x0b\x0e\x0f\nw\n\x04\x04C\
    \x02\x01\x12\x04\xa2\x0b\x02!\x1ai\x20Model\x20configuration...going\x20\
    away\x20in\x20favor\x20of\x20infer_params\x20and\x20train_params\x20over\
    \x20time.\n\x20TO\x20BE\x20DEPRECATED\n\n\r\n\x05\x04C\x02\x01\x06\x12\
    \x04\xa2\x0b\x02\x0e\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xa2\x0b\x0f\x1c\
    \n\r\n\x05\x04C\x02\x01\x03\x12\x04\xa2\x0b\x1f\x20\nT\n\x04\x04C\x02\
    \x02\x12\x04\xa4\x0b\x02\x15\x1aF\x20For\x20returning\x20where\x20to\x20\
    look\x20for\x20the\x20Output\x20info\x20if\x20not\x20returning\x20it.\n\
    \n\r\n\x05\x04C\x02\x02\x05\x12\x04\xa4\x0b\x02\x08\n\r\n\x05\x04C\x02\
    \x02\x01\x12\x04\xa4\x0b\t\x10\n\r\n\x05\x04C\x02\x02\x03\x12\x04\xa4\
    \x0b\x13\x14\n\xca\x01\n\x04\x04C\x02\x03\x12\x04\xa7\x0b\x02(\x1a\xbb\
    \x01\x20Map\x20from\x20the\x20api.Data\x20field\x20names\x20to\x20the\
    \x20underlying\x20model\x20graph's\x20outputs.\x20When\x20using\x20a\n\
    \x20PretrainedModelConfig\x20the\x20values\x20in\x20this\x20map\x20need\
    \x20to\x20match\x20the\x20Triton\x20config.pbtxt\x20output\x20names.\n\n\
    \r\n\x05\x04C\x02\x03\x06\x12\x04\xa7\x0b\x02\x18\n\r\n\x05\x04C\x02\x03\
    \x01\x12\x04\xa7\x0b\x19#\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xa7\x0b&'\n\
    \x84\x02\n\x04\x04C\x02\x04\x12\x04\xac\x0b\x02$\x1a\xf5\x01\x20For\x20p\
    redicting\x20with\x20the\x20various\x20ModelType's\x20we\x20accept\x20a\
    \x20Struct\x20(JSON\x20object)\x20worth\x20of\x20args\n\x20that\x20the\
    \x20ModelTypeField\x20defines.\x20During\x20inference,\x20the\x20setting\
    s\x20contained\x20within\x20are\x20sent\n\x20to\x20the\x20model\x20predi\
    ctor\x20to\x20alter\x20predictions\x20from\x20this\x20Model.\n\n\r\n\x05\
    \x04C\x02\x04\x06\x12\x04\xac\x0b\x02\x18\n\r\n\x05\x04C\x02\x04\x01\x12\
    \x04\xac\x0b\x19\x1f\n\r\n\x05\x04C\x02\x04\x03\x12\x04\xac\x0b\"#\n\x0c\
    \n\x04\x04C\x02\x05\x12\x04\xad\x0b\x02+\n\r\n\x05\x04C\x02\x05\x04\x12\
    \x04\xad\x0b\x02\n\n\r\n\x05\x04C\x02\x05\x06\x12\x04\xad\x0b\x0b\x19\n\
    \r\n\x05\x04C\x02\x05\x01\x12\x04\xad\x0b\x1a&\n\r\n\x05\x04C\x02\x05\
    \x03\x12\x04\xad\x0b)*\n\x19\n\x02\x04D\x12\x06\xb1\x0b\0\xbc\x0b\x01\
    \x1a\x0b\x20InputInfo\n\n\x0b\n\x03\x04D\x01\x12\x04\xb1\x0b\x08\x11\n\
    \xc8\x01\n\x04\x04D\x02\0\x12\x04\xb4\x0b\x02(\x1a\xb9\x01\x20Map\x20fro\
    m\x20the\x20api.Data\x20field\x20names\x20to\x20the\x20underlying\x20mod\
    el\x20graph's\x20inputs.\x20When\x20using\x20a\n\x20PretrainedModelConfi\
    g\x20the\x20values\x20in\x20this\x20map\x20need\x20to\x20match\x20the\
    \x20Triton\x20config.pbtxt\x20input\x20names.\n\n\r\n\x05\x04D\x02\0\x06\
    \x12\x04\xb4\x0b\x02\x18\n\r\n\x05\x04D\x02\0\x01\x12\x04\xb4\x0b\x19#\n\
    \r\n\x05\x04D\x02\0\x03\x12\x04\xb4\x0b&'\n\x92\x02\n\x04\x04D\x02\x01\
    \x12\x04\xb9\x0b\x02$\x1a\x83\x02\x20To\x20control\x20the\x20inputs\x20t\
    o\x20the\x20given\x20model\x20we\x20allow\x20a\x20list\x20of\x20paramete\
    rs\n\x20defined\x20for\x20each\x20ModelType\x20as\x20a\x20Struct\x20(JSO\
    N\x20object)\x20here.\x20During\x20training\x20or\x20inference,\x20the\n\
    \x20settings\x20contained\x20within\x20are\x20sent\x20to\x20the\x20train\
    ing\x20processor\x20to\x20alter\x20the\x20training\x20process.\n\n\r\n\
    \x05\x04D\x02\x01\x06\x12\x04\xb9\x0b\x02\x18\n\r\n\x05\x04D\x02\x01\x01\
    \x12\x04\xb9\x0b\x19\x1f\n\r\n\x05\x04D\x02\x01\x03\x12\x04\xb9\x0b\"#\n\
    R\n\x04\x04D\x02\x02\x12\x04\xbb\x0b\x02\x1d\x1aD\x20For\x20base\x20mode\
    l\x20to\x20get\x20embeddings\x20from\x20for\x20transfer\x20learned\x20mo\
    dels.\n\n\r\n\x05\x04D\x02\x02\x06\x12\x04\xbb\x0b\x02\x07\n\r\n\x05\x04\
    D\x02\x02\x01\x12\x04\xbb\x0b\x08\x18\n\r\n\x05\x04D\x02\x02\x03\x12\x04\
    \xbb\x0b\x1b\x1c\n\x0c\n\x02\x04E\x12\x06\xbe\x0b\0\xc7\x0b\x01\n\x0b\n\
    \x03\x04E\x01\x12\x04\xbe\x0b\x08\x11\n\x9b\x02\n\x04\x04E\x02\0\x12\x04\
    \xc2\x0b\x02$\x1a\x8c\x02\x20To\x20control\x20the\x20training\x20process\
    \x20when\x20PostModelVersions\x20is\x20used\x20we\x20allow\x20a\x20list\
    \x20of\x20parameters\n\x20defined\x20for\x20each\x20ModelType\x20as\x20a\
    \x20Struct\x20(JSON\x20object)\x20here.\x20During\x20training,\x20the\
    \x20settings\n\x20contained\x20within\x20are\x20sent\x20to\x20the\x20tra\
    ining\x20processor\x20to\x20alter\x20the\x20training\x20process.\n\n\r\n\
    \x05\x04E\x02\0\x06\x12\x04\xc2\x0b\x02\x18\n\r\n\x05\x04E\x02\0\x01\x12\
    \x04\xc2\x0b\x19\x1f\n\r\n\x05\x04E\x02\0\x03\x12\x04\xc2\x0b\"#\n\\\n\
    \x04\x04E\x02\x01\x12\x04\xc4\x0b\x02\x16\x1aN\x20The\x20dataset\x20and\
    \x20dataset\x20version\x20this\x20model\x20version\x20was\x20or\x20will\
    \x20be\x20trained\x20on\n\n\r\n\x05\x04E\x02\x01\x06\x12\x04\xc4\x0b\x02\
    \t\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xc4\x0b\n\x11\n\r\n\x05\x04E\x02\
    \x01\x03\x12\x04\xc4\x0b\x14\x15\n2\n\x04\x04E\x02\x02\x12\x04\xc6\x0b\
    \x02\x1e\x1a$\x20The\x20model\x20to\x20resume\x20training\x20from.\n\n\r\
    \n\x05\x04E\x02\x02\x06\x12\x04\xc6\x0b\x02\x07\n\r\n\x05\x04E\x02\x02\
    \x01\x12\x04\xc6\x0b\x08\x19\n\r\n\x05\x04E\x02\x02\x03\x12\x04\xc6\x0b\
    \x1c\x1d\n\x0c\n\x02\x04F\x12\x06\xc9\x0b\0\xcd\x0b\x01\n\x0b\n\x03\x04F\
    \x01\x12\x04\xc9\x0b\x08\x10\nO\n\x04\x04F\x02\0\x12\x04\xcc\x0b\x02$\
    \x1aA\x20To\x20control\x20the\x20evaluation\x20process.\n\x20Allow\x20a\
    \x20list\x20of\x20parameters.\n\n\r\n\x05\x04F\x02\0\x06\x12\x04\xcc\x0b\
    \x02\x18\n\r\n\x05\x04F\x02\0\x01\x12\x04\xcc\x0b\x19\x1f\n\r\n\x05\x04F\
    \x02\0\x03\x12\x04\xcc\x0b\"#\n\x0c\n\x02\x04G\x12\x06\xcf\x0b\0\xd2\x0b\
    \x01\n\x0b\n\x03\x04G\x01\x12\x04\xcf\x0b\x08\x12\nJ\n\x04\x04G\x02\0\
    \x12\x04\xd1\x0b\x02$\x1a<\x20Used\x20to\x20configure\x20model\x20import\
    s\x20from\x20third-party\x20toolkits.\n\n\r\n\x05\x04G\x02\0\x06\x12\x04\
    \xd1\x0b\x02\x18\n\r\n\x05\x04G\x02\0\x01\x12\x04\xd1\x0b\x19\x1f\n\r\n\
    \x05\x04G\x02\0\x03\x12\x04\xd1\x0b\"#\n\xa1\x02\n\x02\x04H\x12\x06\xd7\
    \x0b\0\x81\x0c\x01\x1a\x92\x02\x20OutputConfig\x20is\x20a\x20collection\
    \x20of\x20parameters\x20controlling\x20either\x20inference\x20or\x20trai\
    ning\x20settings\x20for\n\x20the\x20given\x20Model.\x20This\x20message\
    \x20will\x20be\x20deprecated\x20over\x20time\x20in\x20favor\x20or\x20inf\
    er_params\x20and\n\x20train_params\x20in\x20OutputInfo\x20which\x20are\
    \x20cleaner\x20and\x20more\x20extensible\x20for\x20many\x20ModelTypes.\n\
    \n\x0b\n\x03\x04H\x01\x12\x04\xd7\x0b\x08\x14\n\x0b\n\x03\x04H\t\x12\x04\
    \xd8\x0b\x02\x1a\n\x0c\n\x04\x04H\t\0\x12\x04\xd8\x0b\x0b\r\n\r\n\x05\
    \x04H\t\0\x01\x12\x04\xd8\x0b\x0b\r\n\r\n\x05\x04H\t\0\x02\x12\x04\xd8\
    \x0b\x0b\r\n\x0c\n\x04\x04H\t\x01\x12\x04\xd8\x0b\x0f\x11\n\r\n\x05\x04H\
    \t\x01\x01\x12\x04\xd8\x0b\x0f\x11\n\r\n\x05\x04H\t\x01\x02\x12\x04\xd8\
    \x0b\x0f\x11\n\x0c\n\x04\x04H\t\x02\x12\x04\xd8\x0b\x13\x15\n\r\n\x05\
    \x04H\t\x02\x01\x12\x04\xd8\x0b\x13\x15\n\r\n\x05\x04H\t\x02\x02\x12\x04\
    \xd8\x0b\x13\x15\n\x0c\n\x04\x04H\t\x03\x12\x04\xd8\x0b\x17\x19\n\r\n\
    \x05\x04H\t\x03\x01\x12\x04\xd8\x0b\x17\x19\n\r\n\x05\x04H\t\x03\x02\x12\
    \x04\xd8\x0b\x17\x19\na\n\x04\x04H\x02\0\x12\x04\xdb\x0b\x02;\x1aS\x20Fo\
    r\x20custom\x20concept\x20model\x20training:\x20whether\x20the\x20concep\
    t\x20predictions\x20must\x20sum\x20to\x201.\n\n\r\n\x05\x04H\x02\0\x05\
    \x12\x04\xdb\x0b\x02\x06\n\r\n\x05\x04H\x02\0\x01\x12\x04\xdb\x0b\x07\"\
    \n\r\n\x05\x04H\x02\0\x03\x12\x04\xdb\x0b%&\n\r\n\x05\x04H\x02\0\x08\x12\
    \x04\xdb\x0b':\n\x0e\n\x06\x04H\x02\0\x08\x03\x12\x04\xdb\x0b(9\n}\n\x04\
    \x04H\x02\x01\x12\x04\xde\x0b\x023\x1ao\x20DEPRECATED:\x20For\x20custom\
    \x20models,\x20this\x20is\x20the\x20base\x20model\x20to\x20use\x20for\
    \x20image\x20embeddings.\n\x20Default\x20is\x20general\x20model.\n\n\r\n\
    \x05\x04H\x02\x01\x05\x12\x04\xde\x0b\x02\x08\n\r\n\x05\x04H\x02\x01\x01\
    \x12\x04\xde\x0b\t\x1a\n\r\n\x05\x04H\x02\x01\x03\x12\x04\xde\x0b\x1d\
    \x1e\n\r\n\x05\x04H\x02\x01\x08\x12\x04\xde\x0b\x1f2\n\x0e\n\x06\x04H\
    \x02\x01\x08\x03\x12\x04\xde\x0b\x201\nl\n\x04\x04H\x02\x02\x12\x04\xe0\
    \x0b\x02\x16\x1a^\x20For\x20concept\x20model\x20predictions:\x20Override\
    s\x20the\x20default_language\x20for\x20the\x20app\x20in\x20a\x20predict\
    \x20call.\n\n\r\n\x05\x04H\x02\x02\x05\x12\x04\xe0\x0b\x02\x08\n\r\n\x05\
    \x04H\x02\x02\x01\x12\x04\xe0\x0b\t\x11\n\r\n\x05\x04H\x02\x02\x03\x12\
    \x04\xe0\x0b\x14\x15\nf\n\x04\x04H\x02\x03\x12\x04\xe3\x0b\x022\x1aX\x20\
    DEPRECATED:\x20Hyper-parameters\x20for\x20custom\x20training.\n\x20Use\
    \x20new\x20hyper_params\x20field\x20instead.\n\n\r\n\x05\x04H\x02\x03\
    \x05\x12\x04\xe3\x0b\x02\x08\n\r\n\x05\x04H\x02\x03\x01\x12\x04\xe3\x0b\
    \t\x19\n\r\n\x05\x04H\x02\x03\x03\x12\x04\xe3\x0b\x1c\x1d\n\r\n\x05\x04H\
    \x02\x03\x08\x12\x04\xe3\x0b\x1e1\n\x0e\n\x06\x04H\x02\x03\x08\x03\x12\
    \x04\xe3\x0b\x1f0\n\xe2\x01\n\x04\x04H\x02\x04\x12\x04\xe7\x0b\x02I\x1a\
    \xd3\x01\x20For\x20concept\x20model\x20predictions:\x20\x20Maximum\x20nu\
    mber\x20of\x20concepts\x20in\x20result.\x20Defaults\x20to\x200\x20which\
    \x20under\n\x20the\x20hood\x20will\x20return\x20default\x20of\x2020.\x20\
    We\x20do\x20a\x20server\x20side\x20default\x20in\x20order\x20to\x20contr\
    ol\x20this\n\x20feature\x20in\x20the\x20future.\n\n\r\n\x05\x04H\x02\x04\
    \x05\x12\x04\xe7\x0b\x02\x08\n\r\n\x05\x04H\x02\x04\x01\x12\x04\xe7\x0b\
    \t\x15\n\r\n\x05\x04H\x02\x04\x03\x12\x04\xe7\x0b\x18\x19\n\r\n\x05\x04H\
    \x02\x04\x08\x12\x04\xe7\x0b\x1aH\n\x10\n\x08\x04H\x02\x04\x08\xd0\x86\
    \x03\x12\x04\xe7\x0b\x1bG\n\xcd\x01\n\x04\x04H\x02\x05\x12\x04\xeb\x0b\
    \x02E\x1a\xbe\x01\x20For\x20concept\x20model\x20predictions:\x20Minimum\
    \x20value\x20of\x20concept's\x20probability\x20score\x20in\x20result.\n\
    \x20Defaults\x20to\x200.0\x20which\x20means\x20we\x20won't\x20do\x20any\
    \x20thresholding\x20as\x20all\x20probabilities\x20will\n\x20likely\x20be\
    \x20>\x200.0.\n\n\r\n\x05\x04H\x02\x05\x05\x12\x04\xeb\x0b\x02\x07\n\r\n\
    \x05\x04H\x02\x05\x01\x12\x04\xeb\x0b\x08\x11\n\r\n\x05\x04H\x02\x05\x03\
    \x12\x04\xeb\x0b\x14\x15\n\r\n\x05\x04H\x02\x05\x08\x12\x04\xeb\x0b\x16D\
    \n\x10\n\x08\x04H\x02\x05\x08\xd0\x86\x03\x12\x04\xeb\x0b\x17C\nY\n\x04\
    \x04H\x02\x06\x12\x04\xed\x0b\x02'\x1aK\x20For\x20concept\x20model\x20pr\
    edictions:\x20Select\x20concepts\x20in\x20result\x20by\x20name\x20or\x20\
    by\x20id\n\n\r\n\x05\x04H\x02\x06\x04\x12\x04\xed\x0b\x02\n\n\r\n\x05\
    \x04H\x02\x06\x06\x12\x04\xed\x0b\x0b\x12\n\r\n\x05\x04H\x02\x06\x01\x12\
    \x04\xed\x0b\x13\"\n\r\n\x05\x04H\x02\x06\x03\x12\x04\xed\x0b%&\n]\n\x04\
    \x04H\x02\x07\x12\x04\xef\x0b\x02\x1e\x1aO\x20For\x20custom\x20concept\
    \x20model\x20training:\x20Training\x20timeout\x20of\x20the\x20model\x20(\
    in\x20seconds)\n\n\r\n\x05\x04H\x02\x07\x05\x12\x04\xef\x0b\x02\x08\n\r\
    \n\x05\x04H\x02\x07\x01\x12\x04\xef\x0b\t\x19\n\r\n\x05\x04H\x02\x07\x03\
    \x12\x04\xef\x0b\x1c\x1d\nn\n\x04\x04H\x02\x08\x12\x04\xf1\x0b\x02\x18\
    \x1a`\x20For\x20model\x20predictions\x20on\x20video:\x20Sample\x20delay\
    \x20for\x20video\x20predicting\x20(1\x20frame\x20per\x20N\x20millisecond\
    s)\n\n\r\n\x05\x04H\x02\x08\x05\x12\x04\xf1\x0b\x02\x08\n\r\n\x05\x04H\
    \x02\x08\x01\x12\x04\xf1\x0b\t\x12\n\r\n\x05\x04H\x02\x08\x03\x12\x04\
    \xf1\x0b\x15\x17\nN\n\x04\x04H\x02\t\x12\x04\xf3\x0b\x02+\x1a@\x20For\
    \x20custom\x20model\x20training:\x20Hyperparameters\x20for\x20custom\x20\
    training\n\n\r\n\x05\x04H\x02\t\x06\x12\x04\xf3\x0b\x02\x18\n\r\n\x05\
    \x04H\x02\t\x01\x12\x04\xf3\x0b\x19%\n\r\n\x05\x04H\x02\t\x03\x12\x04\
    \xf3\x0b(*\n\xd0\x01\n\x04\x04H\x02\n\x12\x04\xf6\x0b\x029\x1a\x95\x01\
    \x20For\x20custom\x20model\x20training:\x20this\x20is\x20the\x20base\x20\
    model\x20version\x20to\x20use\x20for\x20image\x20embeddings.\n\x20This\
    \x20has\x20to\x20be\x20one\x20of\x20the\x20embed\x20models\x20in\x20the\
    \x20app\x20workflow.\n\"*\x20Use\x20input_info.base_embed_model\x20inste\
    ad.\n\n\r\n\x05\x04H\x02\n\x05\x12\x04\xf6\x0b\x02\x08\n\r\n\x05\x04H\
    \x02\n\x01\x12\x04\xf6\x0b\t\x1f\n\r\n\x05\x04H\x02\n\x03\x12\x04\xf6\
    \x0b\"$\n\r\n\x05\x04H\x02\n\x08\x12\x04\xf6\x0b%8\n\x0e\n\x06\x04H\x02\
    \n\x08\x03\x12\x04\xf6\x0b&7\n\x96\x01\n\x04\x04H\x02\x0b\x12\x04\xf9\
    \x0b\x02.\x1a\x87\x01\x20For\x20custom\x20model\x20training:\x20Use\x20t\
    his\x20flag\x20to\x20fail\x20on\x20missing\x20positive\x20examples\n\x20\
    By\x20default\x20we\x20fill\x20in\x20the\x20missing\x20with\x20random\
    \x20examples\n\n\r\n\x05\x04H\x02\x0b\x05\x12\x04\xf9\x0b\x02\x06\n\r\n\
    \x05\x04H\x02\x0b\x01\x12\x04\xf9\x0b\x07(\n\r\n\x05\x04H\x02\x0b\x03\
    \x12\x04\xf9\x0b+-\n\xf0\x03\n\x04\x04H\x02\x0c\x12\x04\x80\x0c\x02A\x1a\
    \xe1\x03\x20For\x20custom\x20model\x20training:\x20This\x20is\x20any\x20\
    additional\x20metadata\x20as\x20a\x20JSON\x20object\x20that\x20we\x20wan\
    t\n\x20want\x20to\x20persist\x20in\x20the\x20model's\x20output\x20config\
    .\x20This\x20is\x20a\x20useful\x20quick\x20way\x20to\x20set\x20fields\
    \x20for\n\x20introducing\x20fields\x20for\x20new\x20model\x20types\x20so\
    \x20we\x20don't\x20have\x20to\x20add\x20a\x20new\x20proto\x20field\x20an\
    d\x20DB\x20field\n\x20each\x20time.\x20Please\x20refer\x20to\x20the\x20d\
    ocumentation\x20or\x20model\x20implementation\x20internally\x20for\x20mo\
    re\n\x20details\x20on\x20what\x20fields\x20are\x20supported\x20for\x20wh\
    ich\x20models.\n\x20TODO(zeiler):\x20remove\x20this\x20field\x20after\
    \x20Portal\x20is\x20updated.\n\n\r\n\x05\x04H\x02\x0c\x06\x12\x04\x80\
    \x0c\x02\x18\n\r\n\x05\x04H\x02\x0c\x01\x12\x04\x80\x0c\x19'\n\r\n\x05\
    \x04H\x02\x0c\x03\x12\x04\x80\x0c*,\n\r\n\x05\x04H\x02\x0c\x08\x12\x04\
    \x80\x0c-@\n\x0e\n\x06\x04H\x02\x0c\x08\x03\x12\x04\x80\x0c.?\n\xbf\x01\
    \n\x02\x04I\x12\x06\x85\x0c\0\xb3\x0c\x01\x1a\xb0\x01\x20ModelType\x20is\
    \x20a\x20definition\x20of\x20a\x20set\x20of\x20models\x20that\x20general\
    ly\x20have\x20the\x20same\x20input\x20and\x20output\x20fields.\n\x20This\
    \x20is\x20used\x20to\x20understand\x20more\x20about\x20the\x20possible\
    \x20models\x20in\x20our\x20platform.\n\n\x0b\n\x03\x04I\x01\x12\x04\x85\
    \x0c\x08\x11\n\x0b\n\x03\x04I\t\x12\x04\x86\x0c\x02\x1c\n\x0c\n\x04\x04I\
    \t\0\x12\x04\x86\x0c\x0b\x0c\n\r\n\x05\x04I\t\0\x01\x12\x04\x86\x0c\x0b\
    \x0c\n\r\n\x05\x04I\t\0\x02\x12\x04\x86\x0c\x0b\x0c\n\x0c\n\x04\x04I\t\
    \x01\x12\x04\x86\x0c\x0e\x0f\n\r\n\x05\x04I\t\x01\x01\x12\x04\x86\x0c\
    \x0e\x0f\n\r\n\x05\x04I\t\x01\x02\x12\x04\x86\x0c\x0e\x0f\n\x0c\n\x04\
    \x04I\t\x02\x12\x04\x86\x0c\x11\x13\n\r\n\x05\x04I\t\x02\x01\x12\x04\x86\
    \x0c\x11\x13\n\r\n\x05\x04I\t\x02\x02\x12\x04\x86\x0c\x11\x13\n\x0c\n\
    \x04\x04I\t\x03\x12\x04\x86\x0c\x15\x17\n\r\n\x05\x04I\t\x03\x01\x12\x04\
    \x86\x0c\x15\x17\n\r\n\x05\x04I\t\x03\x02\x12\x04\x86\x0c\x15\x17\n\x0c\
    \n\x04\x04I\t\x04\x12\x04\x86\x0c\x19\x1b\n\r\n\x05\x04I\t\x04\x01\x12\
    \x04\x86\x0c\x19\x1b\n\r\n\x05\x04I\t\x04\x02\x12\x04\x86\x0c\x19\x1b\n8\
    \n\x04\x04I\x02\0\x12\x04\x89\x0c\x02\x10\x1a*\x20A\x20unique\x20identif\
    ier\x20for\x20this\x20model\x20type.\n\n\r\n\x05\x04I\x02\0\x05\x12\x04\
    \x89\x0c\x02\x08\n\r\n\x05\x04I\x02\0\x01\x12\x04\x89\x0c\t\x0b\n\r\n\
    \x05\x04I\x02\0\x03\x12\x04\x89\x0c\x0e\x0f\n/\n\x04\x04I\x02\x01\x12\
    \x04\x8b\x0c\x02\x13\x1a!\x20A\x20display\x20title\x20for\x20this\x20mod\
    el.\n\n\r\n\x05\x04I\x02\x01\x05\x12\x04\x8b\x0c\x02\x08\n\r\n\x05\x04I\
    \x02\x01\x01\x12\x04\x8b\x0c\t\x0e\n\r\n\x05\x04I\x02\x01\x03\x12\x04\
    \x8b\x0c\x11\x12\n/\n\x04\x04I\x02\x02\x12\x04\x8d\x0c\x02\x19\x1a!\x20D\
    escription\x20of\x20this\x20model\x20type.\n\n\r\n\x05\x04I\x02\x02\x05\
    \x12\x04\x8d\x0c\x02\x08\n\r\n\x05\x04I\x02\x02\x01\x12\x04\x8d\x0c\t\
    \x14\n\r\n\x05\x04I\x02\x02\x03\x12\x04\x8d\x0c\x17\x18\n\xfb\x05\n\x04\
    \x04I\x02\x03\x12\x04\x98\x0c\x02#\x1a\x80\x01\x20The\x20list\x20of\x20i\
    nput\x20fields\x20that\x20this\x20model\x20expects\x20as\x20inputs.\n\
    \x20Used\x20to\x20validate\x20that\x20request\x20input\x20data\x20has\
    \x20the\x20expected\x20fields.\n2\xe9\x04\x20For\x20both\x20input_fields\
    \x20and\x20output_fields\x20below,\x20the\x20following\x20hold\x20true:\
    \n\x20-\x20They\x20are\x20both\x20lists\x20of\x20strings\x20that\x20name\
    \x20the\x20fields\x20from\x20the\x20Data\x20proto\n\x20-\x20Individual\
    \x20entries\x20in\x20the\x20list\x20can\x20be\x20comma-separated\x20list\
    s.\x20Each\x20element\x20of\x20it\x20is\x20expected\x20to\x20be\x20prese\
    nt\x20in\x20an\x20incoming\x20data\x20example.\n\x20-\x20There\x20is\x20\
    not\x20currently\x20a\x20notion\x20of\x20fields\x20that\x20can\x20be\x20\
    \"OR\x20separated\".\x20\"OR\x20separated\"\x20meaning\x20any\x20combina\
    tion\x20of\x20the\x20fields\x20can\x20be\x20present.\n\x20-\x20Multiple\
    \x20entries\x20in\x20the\x20list\x20imply\x20that\x20inputs\x20come\x20f\
    rom\x20different\x20input\x20sources.\n\x20-\x20Both\x20are\x20used\x20t\
    o\x20validate\x20which\x20models\x20can\x20be\x20chained\x20before\x20an\
    d\x20after\x20each\x20other\x20inside\x20a\x20workflow.\n\n\r\n\x05\x04I\
    \x02\x03\x04\x12\x04\x98\x0c\x02\n\n\r\n\x05\x04I\x02\x03\x05\x12\x04\
    \x98\x0c\x0b\x11\n\r\n\x05\x04I\x02\x03\x01\x12\x04\x98\x0c\x12\x1e\n\r\
    \n\x05\x04I\x02\x03\x03\x12\x04\x98\x0c!\"\nB\n\x04\x04I\x02\x04\x12\x04\
    \x9a\x0c\x02$\x1a4\x20The\x20list\x20of\x20output\x20fields\x20that\x20t\
    his\x20model\x20accepts.\n\n\r\n\x05\x04I\x02\x04\x04\x12\x04\x9a\x0c\
    \x02\n\n\r\n\x05\x04I\x02\x04\x05\x12\x04\x9a\x0c\x0b\x11\n\r\n\x05\x04I\
    \x02\x04\x01\x12\x04\x9a\x0c\x12\x1f\n\r\n\x05\x04I\x02\x04\x03\x12\x04\
    \x9a\x0c\"#\n8\n\x04\x04I\x02\x05\x12\x04\x9d\x0c\x02\x15\x1a*\x20Is\x20\
    this\x20model\x20trainable\x20in\x20our\x20platform.\n\n\r\n\x05\x04I\
    \x02\x05\x05\x12\x04\x9d\x0c\x02\x06\n\r\n\x05\x04I\x02\x05\x01\x12\x04\
    \x9d\x0c\x07\x10\n\r\n\x05\x04I\x02\x05\x03\x12\x04\x9d\x0c\x13\x14\nz\n\
    \x04\x04I\x02\x06\x12\x04\xa0\x0c\x02\x15\x1al\x20Is\x20this\x20model\
    \x20creatable.\x20We\x20have\x20some\x20pre-trained\x20model\x20types\
    \x20that\x20users\x20cannot\x20create\x20yet\x20in\n\x20model\x20mode.\n\
    \n\r\n\x05\x04I\x02\x06\x05\x12\x04\xa0\x0c\x02\x06\n\r\n\x05\x04I\x02\
    \x06\x01\x12\x04\xa0\x0c\x07\x10\n\r\n\x05\x04I\x02\x06\x03\x12\x04\xa0\
    \x0c\x13\x14\nH\n\x04\x04I\x02\x07\x12\x04\xa2\x0c\x02\x1a\x1a:\x20Is\
    \x20this\x20model\x20type\x20only\x20for\x20internal\x20users\x20at\x20t\
    his\x20time.\n\n\r\n\x05\x04I\x02\x07\x05\x12\x04\xa2\x0c\x02\x06\n\r\n\
    \x05\x04I\x02\x07\x01\x12\x04\xa2\x0c\x07\x14\n\r\n\x05\x04I\x02\x07\x03\
    \x12\x04\xa2\x0c\x17\x19\n[\n\x04\x04I\x02\x08\x12\x04\xa5\x0c\x021\x1aM\
    \x20The\x20remaining\x20fields\x20are\x20definitions\x20of\x20the\x20con\
    figurable\x20fields\x20that\x20exist.\n\n\r\n\x05\x04I\x02\x08\x04\x12\
    \x04\xa5\x0c\x02\n\n\r\n\x05\x04I\x02\x08\x06\x12\x04\xa5\x0c\x0b\x19\n\
    \r\n\x05\x04I\x02\x08\x01\x12\x04\xa5\x0c\x1a+\n\r\n\x05\x04I\x02\x08\
    \x03\x12\x04\xa5\x0c.0\n\xc0\x01\n\x04\x04I\x02\t\x12\x04\xa9\x0c\x02'\
    \x1a\xb1\x01\x20For\x20sequence\x20models\x20we\x20need\x20to\x20know\
    \x20when\x20processing\x20that\x20they\x20require\x20temporal\x20time\
    \x20frames\n\x20in\x20sequential\x20order.\x20This\x20will\x20be\x20true\
    \x20for\x20model\x20types\x20like\x20trackers\x20as\x20an\x20example.\n\
    \n\r\n\x05\x04I\x02\t\x05\x12\x04\xa9\x0c\x02\x06\n\r\n\x05\x04I\x02\t\
    \x01\x12\x04\xa9\x0c\x07!\n\r\n\x05\x04I\x02\t\x03\x12\x04\xa9\x0c$&\n;\
    \n\x04\x04I\x02\n\x12\x04\xac\x0c\x025\x1a-\x20Expected\x20input\x20laye\
    rs\x20of\x20an\x20uploaded\x20model.\n\n\r\n\x05\x04I\x02\n\x04\x12\x04\
    \xac\x0c\x02\n\n\r\n\x05\x04I\x02\n\x06\x12\x04\xac\x0c\x0b\x19\n\r\n\
    \x05\x04I\x02\n\x01\x12\x04\xac\x0c\x1a/\n\r\n\x05\x04I\x02\n\x03\x12\
    \x04\xac\x0c24\n;\n\x04\x04I\x02\x0b\x12\x04\xaf\x0c\x026\x1a-\x20Expect\
    ed\x20output\x20layers\x20of\x20an\x20uploaded\x20model\n\n\r\n\x05\x04I\
    \x02\x0b\x04\x12\x04\xaf\x0c\x02\n\n\r\n\x05\x04I\x02\x0b\x06\x12\x04\
    \xaf\x0c\x0b\x19\n\r\n\x05\x04I\x02\x0b\x01\x12\x04\xaf\x0c\x1a0\n\r\n\
    \x05\x04I\x02\x0b\x03\x12\x04\xaf\x0c35\nI\n\x04\x04I\x02\x0c\x12\x04\
    \xb2\x0c\x02&\x1a;\x20What\x20type\x20of\x20evaluation\x20is\x20supporte\
    d\x20for\x20this\x20model\x20type.\n\n\r\n\x05\x04I\x02\x0c\x06\x12\x04\
    \xb2\x0c\x02\x10\n\r\n\x05\x04I\x02\x0c\x01\x12\x04\xb2\x0c\x11\x20\n\r\
    \n\x05\x04I\x02\x0c\x03\x12\x04\xb2\x0c#%\n\x0c\n\x02\x04J\x12\x06\xb5\
    \x0c\0\xbe\x0c\x01\n\x0b\n\x03\x04J\x01\x12\x04\xb5\x0c\x08\x16\nA\n\x04\
    \x04J\x02\0\x12\x04\xb7\x0c\x02\x1d\x1a3\x20The\x20api.Data\x20field\x20\
    this\x20layer\x20will\x20be\x20parsed\x20into\n\n\r\n\x05\x04J\x02\0\x05\
    \x12\x04\xb7\x0c\x02\x08\n\r\n\x05\x04J\x02\0\x01\x12\x04\xb7\x0c\t\x18\
    \n\r\n\x05\x04J\x02\0\x03\x12\x04\xb7\x0c\x1b\x1c\n]\n\x04\x04J\x02\x01\
    \x12\x04\xb9\x0c\x02!\x1aO\x20Description\x20of\x20the\x20expected\x20sh\
    ape.\x20Can\x20support\x20multiple\x20support\x20layer\x20shapes.\n\n\r\
    \n\x05\x04J\x02\x01\x04\x12\x04\xb9\x0c\x02\n\n\r\n\x05\x04J\x02\x01\x06\
    \x12\x04\xb9\x0c\x0b\x15\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xb9\x0c\x16\
    \x1c\n\r\n\x05\x04J\x02\x01\x03\x12\x04\xb9\x0c\x1f\x20\n;\n\x04\x04J\
    \x02\x02\x12\x04\xbb\x0c\x02\x19\x1a-\x20Brief\x20description\x20about\
    \x20the\x20layer\x20if\x20needed\n\n\r\n\x05\x04J\x02\x02\x05\x12\x04\
    \xbb\x0c\x02\x08\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xbb\x0c\t\x14\n\r\n\
    \x05\x04J\x02\x02\x03\x12\x04\xbb\x0c\x17\x18\nV\n\x04\x04J\x02\x03\x12\
    \x04\xbd\x0c\x02#\x1aH\x20Whether\x20this\x20layer\x20should\x20have\x20\
    a\x20label_filename\x20specified\x20and\x20provided\n\n\r\n\x05\x04J\x02\
    \x03\x05\x12\x04\xbd\x0c\x02\x06\n\r\n\x05\x04J\x02\x03\x01\x12\x04\xbd\
    \x0c\x07\x1e\n\r\n\x05\x04J\x02\x03\x03\x12\x04\xbd\x0c!\"\n\x0c\n\x02\
    \x04K\x12\x06\xc0\x0c\0\xc3\x0c\x01\n\x0b\n\x03\x04K\x01\x12\x04\xc0\x0c\
    \x08\x1a\n\x0c\n\x04\x04K\x02\0\x12\x04\xc1\x0c\x02\x1c\n\r\n\x05\x04K\
    \x02\0\x05\x12\x04\xc1\x0c\x02\x08\n\r\n\x05\x04K\x02\0\x01\x12\x04\xc1\
    \x0c\t\x17\n\r\n\x05\x04K\x02\0\x03\x12\x04\xc1\x0c\x1a\x1b\n\x0c\n\x04\
    \x04K\x02\x01\x12\x04\xc2\x0c\x02\x1c\n\r\n\x05\x04K\x02\x01\x05\x12\x04\
    \xc2\x0c\x02\x08\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xc2\x0c\t\x17\n\r\n\
    \x05\x04K\x02\x01\x03\x12\x04\xc2\x0c\x1a\x1b\n\x0c\n\x02\x05\x06\x12\
    \x06\xc4\x0c\0\xcb\x0c\x01\n\x0b\n\x03\x05\x06\x01\x12\x04\xc4\x0c\x05\r\
    \n1\n\x04\x05\x06\x02\0\x12\x04\xc5\x0c\x02\x10\"#\x20Default\x20value,\
    \x20should\x20not\x20be\x20used\n\n\r\n\x05\x05\x06\x02\0\x01\x12\x04\
    \xc5\x0c\x02\x0b\n\r\n\x05\x05\x06\x02\0\x02\x12\x04\xc5\x0c\x0e\x0f\n\
    \x0c\n\x04\x05\x06\x02\x01\x12\x04\xc6\x0c\x02\r\n\r\n\x05\x05\x06\x02\
    \x01\x01\x12\x04\xc6\x0c\x02\x08\n\r\n\x05\x05\x06\x02\x01\x02\x12\x04\
    \xc6\x0c\x0b\x0c\n\x0c\n\x04\x05\x06\x02\x02\x12\x04\xc7\x0c\x02\x0c\n\r\
    \n\x05\x05\x06\x02\x02\x01\x12\x04\xc7\x0c\x02\x07\n\r\n\x05\x05\x06\x02\
    \x02\x02\x12\x04\xc7\x0c\n\x0b\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\xc8\
    \x0c\x02\x0c\n\r\n\x05\x05\x06\x02\x03\x01\x12\x04\xc8\x0c\x02\x07\n\r\n\
    \x05\x05\x06\x02\x03\x02\x12\x04\xc8\x0c\n\x0b\n\x0c\n\x04\x05\x06\x02\
    \x04\x12\x04\xc9\x0c\x02\x0c\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\xc9\
    \x0c\x02\x07\n\r\n\x05\x05\x06\x02\x04\x02\x12\x04\xc9\x0c\n\x0b\n\x0c\n\
    \x04\x05\x06\x02\x05\x12\x04\xca\x0c\x02\x0b\n\r\n\x05\x05\x06\x02\x05\
    \x01\x12\x04\xca\x0c\x02\x06\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xca\
    \x0c\t\n\n\x0c\n\x02\x04L\x12\x06\xce\x0c\0\xd8\x0c\x01\n\x0b\n\x03\x04L\
    \x01\x12\x04\xce\x0c\x08\x12\n\xbc\x01\n\x04\x04L\x02\0\x12\x04\xd1\x0c\
    \x02\x1a\x1a\xad\x01\x20Supported\x20dimensions\n\x20Example:\x20[-1,4]\
    \x20is\x20a\x202-dimensional\x20array\x20with\x20the\x20first\x20dimensi\
    on\x20of\x20variablesize,\x20but\x20second\x20dimension\x20with\x20a\x20\
    static\x20size:\x20[[1,2,3,4],[4,5,6,7],...]\n\n\r\n\x05\x04L\x02\0\x04\
    \x12\x04\xd1\x0c\x02\n\n\r\n\x05\x04L\x02\0\x05\x12\x04\xd1\x0c\x0b\x10\
    \n\r\n\x05\x04L\x02\0\x01\x12\x04\xd1\x0c\x11\x15\n\r\n\x05\x04L\x02\0\
    \x03\x12\x04\xd1\x0c\x18\x19\nV\n\x04\x04L\x02\x01\x12\x04\xd3\x0c\x02\
    \x1e\x1aH\x20Max\x20dimension\x20size,\x20applicable\x20to\x20layers\x20\
    that\x20can\x20have\x20flexible\x20sizes.\n\n\r\n\x05\x04L\x02\x01\x04\
    \x12\x04\xd3\x0c\x02\n\n\r\n\x05\x04L\x02\x01\x05\x12\x04\xd3\x0c\x0b\
    \x10\n\r\n\x05\x04L\x02\x01\x01\x12\x04\xd3\x0c\x11\x19\n\r\n\x05\x04L\
    \x02\x01\x03\x12\x04\xd3\x0c\x1c\x1d\n$\n\x04\x04L\x02\x02\x12\x04\xd5\
    \x0c\x02\x19\x1a\x16\x20The\x20triton\x20data\x20type\n\n\r\n\x05\x04L\
    \x02\x02\x06\x12\x04\xd5\x0c\x02\n\n\r\n\x05\x04L\x02\x02\x01\x12\x04\
    \xd5\x0c\x0b\x14\n\r\n\x05\x04L\x02\x02\x03\x12\x04\xd5\x0c\x17\x18\n0\n\
    \x04\x04L\x02\x03\x12\x04\xd7\x0c\x02\x19\x1a\"\x20Description\x20about\
    \x20the\x20dimensions\n\n\r\n\x05\x04L\x02\x03\x05\x12\x04\xd7\x0c\x02\
    \x08\n\r\n\x05\x04L\x02\x03\x01\x12\x04\xd7\x0c\t\x14\n\r\n\x05\x04L\x02\
    \x03\x03\x12\x04\xd7\x0c\x17\x18\nK\n\x02\x04M\x12\x06\xdb\x0c\0\xa8\r\
    \x01\x1a=\x20ModelTypeField\x20stores\x20a\x20field\x20value\x20of\x20a\
    \x20configurable\x20type.\n\n\x0b\n\x03\x04M\x01\x12\x04\xdb\x0c\x08\x16\
    \n\xd7\x03\n\x04\x04M\x02\0\x12\x04\xe4\x0c\x02\x12\x1a\xc8\x03\x20The\
    \x20path\x20where\x20the\x20value\x20of\x20the\x20field\x20will\x20be\
    \x20stored\x20in\x20the\x20model\x20version\x20object.\n\x20Example:\n\
    \x20\"output_info.data\"\x20would\x20be\x20the\x20Data\x20message\x20in\
    \x20the\x20OutputInfo\x20message.\n\x20\"output_info.output_config.langu\
    age\"\x20is\x20in\x20the\x20OutputConfig\x20message\x20within\x20OutputI\
    nfo\n\x20\"input_info.params\"\x20is\x20in\x20the\x20params\x20struct\
    \x20within\x20InputInfo.\n\x20\"output_info.params\"\x20is\x20in\x20the\
    \x20params\x20struct\x20within\x20OutputInfo.\n\x20\"train_info.params\"\
    \x20is\x20in\x20the\x20params\x20struct\x20within\x20TrainInfo.\n\x20and\
    \x20so\x20on.\n\n\r\n\x05\x04M\x02\0\x05\x12\x04\xe4\x0c\x02\x08\n\r\n\
    \x05\x04M\x02\0\x01\x12\x04\xe4\x0c\t\r\n\r\n\x05\x04M\x02\0\x03\x12\x04\
    \xe4\x0c\x10\x11\nI\n\x04\x04M\x04\0\x12\x06\xe6\x0c\x02\x94\r\x03\x1a9\
    \x20These\x20are\x20various\x20types\x20of\x20fields\x20that\x20we\x20ha\
    ve\x20UIs\x20for.\n\n\r\n\x05\x04M\x04\0\x01\x12\x04\xe6\x0c\x07\x19\n\r\
    \n\x05\x04M\x04\0\x04\x12\x04\xe7\x0c\x04\x0f\n\x0e\n\x06\x04M\x04\0\x04\
    \0\x12\x04\xe7\x0c\r\x0e\n\x0f\n\x07\x04M\x04\0\x04\0\x01\x12\x04\xe7\
    \x0c\r\x0e\n\x0f\n\x07\x04M\x04\0\x04\0\x02\x12\x04\xe7\x0c\r\x0e\n\x0e\
    \n\x06\x04M\x04\0\x02\0\x12\x04\xe9\x0c\x04&\n\x0f\n\x07\x04M\x04\0\x02\
    \0\x01\x12\x04\xe9\x0c\x04!\n\x0f\n\x07\x04M\x04\0\x02\0\x02\x12\x04\xe9\
    \x0c$%\n\x0e\n\x06\x04M\x04\0\x02\x01\x12\x04\xeb\x0c\x04\x10\n\x0f\n\
    \x07\x04M\x04\0\x02\x01\x01\x12\x04\xeb\x0c\x04\x0b\n\x0f\n\x07\x04M\x04\
    \0\x02\x01\x02\x12\x04\xeb\x0c\x0e\x0f\n\x0e\n\x06\x04M\x04\0\x02\x02\
    \x12\x04\xec\x0c\x04\x0f\n\x0f\n\x07\x04M\x04\0\x02\x02\x01\x12\x04\xec\
    \x0c\x04\n\n\x0f\n\x07\x04M\x04\0\x02\x02\x02\x12\x04\xec\x0c\r\x0e\n\
    \x0e\n\x06\x04M\x04\0\x02\x03\x12\x04\xed\x0c\x04\x0f\n\x0f\n\x07\x04M\
    \x04\0\x02\x03\x01\x12\x04\xed\x0c\x04\n\n\x0f\n\x07\x04M\x04\0\x02\x03\
    \x02\x12\x04\xed\x0c\r\x0e\nd\n\x06\x04M\x04\0\x02\x04\x12\x04\xef\x0c\
    \x04\x1a\x1aT\x20For\x20auto-completing\x20to\x20concepts\x20in\x20the\
    \x20app.\x20This\x20goes\x20into\x20an\x20data.concepts\x20field.\n\n\
    \x0f\n\x07\x04M\x04\0\x02\x04\x01\x12\x04\xef\x0c\x04\x15\n\x0f\n\x07\
    \x04M\x04\0\x02\x04\x02\x12\x04\xef\x0c\x18\x19\nd\n\x06\x04M\x04\0\x02\
    \x05\x12\x04\xf1\x0c\x04)\x1aT\x20For\x20auto-completing\x20to\x20concep\
    ts\x20in\x20the\x20app.\x20This\x20goes\x20into\x20an\x20data.concepts\
    \x20field.\n\n\x0f\n\x07\x04M\x04\0\x02\x05\x01\x12\x04\xf1\x0c\x04$\n\
    \x0f\n\x07\x04M\x04\0\x02\x05\x02\x12\x04\xf1\x0c'(\n,\n\x06\x04M\x04\0\
    \x02\x06\x12\x04\xf3\x0c\x04\x0e\x1a\x1c\x20A\x20range\x20for\x20a\x20fl\
    oat\x20value.\n\n\x0f\n\x07\x04M\x04\0\x02\x06\x01\x12\x04\xf3\x0c\x04\t\
    \n\x0f\n\x07\x04M\x04\0\x02\x06\x02\x12\x04\xf3\x0c\x0c\r\n\xa1\x01\n\
    \x06\x04M\x04\0\x02\x07\x12\x04\xf6\x0c\x04\r\x1a\x90\x01\x20If\x20ENUM\
    \x20is\x20used\x20then\x20the\x20\"enum_options\"\x20field\x20should\x20\
    also\x20be\x20filled\x20in\x20with\x20the\x20respective\x20ID\x20and\x20\
    description\n\x20for\x20the\x20different\x20ENUM\x20options.\n\n\x0f\n\
    \x07\x04M\x04\0\x02\x07\x01\x12\x04\xf6\x0c\x04\x08\n\x0f\n\x07\x04M\x04\
    \0\x02\x07\x02\x12\x04\xf6\x0c\x0b\x0c\nl\n\x06\x04M\x04\0\x02\x08\x12\
    \x04\xf8\x0c\x04\x16\x1a\\\x20For\x20listing\x20collaborators\x20of\x20t\
    he\x20app.\x20The\x20field\x20is\x20a\x20string\x20of\x20the\x20collabor\
    ator's\x20user_id.\n\n\x0f\n\x07\x04M\x04\0\x02\x08\x01\x12\x04\xf8\x0c\
    \x04\x11\n\x0f\n\x07\x04M\x04\0\x02\x08\x02\x12\x04\xf8\x0c\x14\x15\n4\n\
    \x06\x04M\x04\0\x02\t\x12\x04\xfa\x0c\x04\x0e\x1a$\x20For\x20arbitrary\
    \x20json\x20object:\x20\"{...}\"\n\n\x0f\n\x07\x04M\x04\0\x02\t\x01\x12\
    \x04\xfa\x0c\x04\x08\n\x0f\n\x07\x04M\x04\0\x02\t\x02\x12\x04\xfa\x0c\
    \x0b\r\n)\n\x06\x04M\x04\0\x02\n\x12\x04\xfc\x0c\x04\x1a\x1a\x19\x20Such\
    \x20as\x20[1.0,\x202.0,\x203.5]\n\n\x0f\n\x07\x04M\x04\0\x02\n\x01\x12\
    \x04\xfc\x0c\x04\x14\n\x0f\n\x07\x04M\x04\0\x02\n\x02\x12\x04\xfc\x0c\
    \x17\x19\nT\n\x06\x04M\x04\0\x02\x0b\x12\x04\xfe\x0c\x04\x1f\x1aD\x20For\
    \x20selecting\x20the\x20embed_model_version_id\x20for\x20context\x20base\
    d\x20models.\n\n\x0f\n\x07\x04M\x04\0\x02\x0b\x01\x12\x04\xfe\x0c\x04\
    \x19\n\x0f\n\x07\x04M\x04\0\x02\x0b\x02\x12\x04\xfe\x0c\x1c\x1e\n2\n\x06\
    \x04M\x04\0\x02\x0c\x12\x04\x80\r\x04\x1a\x1a\"\x20Such\x20as\x20['a',\
    \x20'b',\x20'cantaloupe']\n\n\x0f\n\x07\x04M\x04\0\x02\x0c\x01\x12\x04\
    \x80\r\x04\x14\n\x0f\n\x07\x04M\x04\0\x02\x0c\x02\x12\x04\x80\r\x17\x19\
    \n\xe8\x01\n\x06\x04M\x04\0\x02\r\x12\x04\x83\r\x04\x18\x1a\xd7\x01\x20I\
    f\x20RECURSIVE_ENUM\x20is\x20used\x20then\x20the\x20\"enum_options\"\x20\
    field\x20should\x20also\x20be\x20filled\x20in\x20with\x20the\x20respecti\
    ve\x20ID\x20and\n\x20description\x20for\x20the\x20different\x20RECURSIVE\
    _ENUM\x20options,\x20as\x20well\x20as\x20model_type_fields\x20for\x20eac\
    h\x20enum\x20choice.\n\n\x0f\n\x07\x04M\x04\0\x02\r\x01\x12\x04\x83\r\
    \x04\x12\n\x0f\n\x07\x04M\x04\0\x02\r\x02\x12\x04\x83\r\x15\x17\nw\n\x06\
    \x04M\x04\0\x02\x0e\x12\x04\x85\r\x04\x15\x1ag\x20For\x20blocks\x20of\
    \x20code\x20that\x20need\x20to\x20be\x20specified\x20by\x20the\x20user\
    \x20for\x20setup\x20or\x20execution\x20during\x20workflow\x20runs.\n\n\
    \x0f\n\x07\x04M\x04\0\x02\x0e\x01\x12\x04\x85\r\x04\x0f\n\x0f\n\x07\x04M\
    \x04\0\x02\x0e\x02\x12\x04\x85\r\x12\x14\nX\n\x06\x04M\x04\0\x02\x0f\x12\
    \x04\x87\r\x04\x14\x1aH\x20For\x20selecting\x20a\x20dataset\x20id\x20in\
    \x20model\x20parameters.\x20String\x20in\x20API\x20request.\n\n\x0f\n\
    \x07\x04M\x04\0\x02\x0f\x01\x12\x04\x87\r\x04\x0e\n\x0f\n\x07\x04M\x04\0\
    \x02\x0f\x02\x12\x04\x87\r\x11\x13\n=\n\x06\x04M\x04\0\x02\x10\x12\x04\
    \x89\r\x04\x1c\x1a-\x20For\x20selecting\x20a\x20dataset\x20version\x20id\
    .\x20String.\n\n\x0f\n\x07\x04M\x04\0\x02\x10\x01\x12\x04\x89\r\x04\x16\
    \n\x0f\n\x07\x04M\x04\0\x02\x10\x02\x12\x04\x89\r\x19\x1b\n?\n\x06\x04M\
    \x04\0\x02\x11\x12\x04\x8b\r\x04!\x1a/\x20For\x20auto-completing\x20to\
    \x20concepts\x20in\x20the\x20model.\n\n\x0f\n\x07\x04M\x04\0\x02\x11\x01\
    \x12\x04\x8b\r\x04\x1b\n\x0f\n\x07\x04M\x04\0\x02\x11\x02\x12\x04\x8b\r\
    \x1e\x20\n)\n\x06\x04M\x04\0\x02\x12\x12\x04\x8d\r\x04\x11\x1a\x19\x20Fo\
    r\x20selecting\x20a\x20dataset\n\n\x0f\n\x07\x04M\x04\0\x02\x12\x01\x12\
    \x04\x8d\r\x04\x0b\n\x0f\n\x07\x04M\x04\0\x02\x12\x02\x12\x04\x8d\r\x0e\
    \x10\n1\n\x06\x04M\x04\0\x02\x13\x12\x04\x8f\r\x04\x19\x1a!\x20For\x20se\
    lecting\x20a\x20dataset\x20version\n\n\x0f\n\x07\x04M\x04\0\x02\x13\x01\
    \x12\x04\x8f\r\x04\x13\n\x0f\n\x07\x04M\x04\0\x02\x13\x02\x12\x04\x8f\r\
    \x16\x18\nS\n\x06\x04M\x04\0\x02\x14\x12\x04\x91\r\x04\x1a\x1aC\x20To\
    \x20pass\x20a\x20string\x20downstream,\x20that\x20is\x20encrypted\x20in\
    \x20the\x20DB\x20and\x20API.\n\n\x0f\n\x07\x04M\x04\0\x02\x14\x01\x12\
    \x04\x91\r\x04\x14\n\x0f\n\x07\x04M\x04\0\x02\x14\x02\x12\x04\x91\r\x17\
    \x19\n_\n\x06\x04M\x04\0\x02\x15\x12\x04\x93\r\x04\x1a\x1aO\x20For\x20se\
    lecting\x20a\x20model\x20version\x20of\x20the\x20same\x20model\x20type\
    \x20to\x20resume\x20training\x20from.\n\n\x0f\n\x07\x04M\x04\0\x02\x15\
    \x01\x12\x04\x93\r\x04\x14\n\x0f\n\x07\x04M\x04\0\x02\x15\x02\x12\x04\
    \x93\r\x17\x19\n)\n\x04\x04M\x02\x01\x12\x04\x96\r\x02$\x1a\x1b\x20The\
    \x20field\x20for\x20this\x20field.\n\n\r\n\x05\x04M\x02\x01\x06\x12\x04\
    \x96\r\x02\x14\n\r\n\x05\x04M\x02\x01\x01\x12\x04\x96\r\x15\x1f\n\r\n\
    \x05\x04M\x02\x01\x03\x12\x04\x96\r\"#\n\xa5\x01\n\x04\x04M\x02\x02\x12\
    \x04\x99\r\x02*\x1a\x96\x01\x20A\x20default\x20value.\x20We\x20use\x20th\
    e\x20Value\x20field\x20because\x20we\x20want\x20to\x20have\x20structured\
    \x20data\x20(just\x20like\n\x20google.protobuf.Struct\x20but\x20this\x20\
    is\x20just\x20a\x20single\x20value).\n\n\r\n\x05\x04M\x02\x02\x06\x12\
    \x04\x99\r\x02\x17\n\r\n\x05\x04M\x02\x02\x01\x12\x04\x99\r\x18%\n\r\n\
    \x05\x04M\x02\x02\x03\x12\x04\x99\r()\n+\n\x04\x04M\x02\x03\x12\x04\x9b\
    \r\x02\x19\x1a\x1d\x20Description\x20for\x20this\x20field.\n\n\r\n\x05\
    \x04M\x02\x03\x05\x12\x04\x9b\r\x02\x08\n\r\n\x05\x04M\x02\x03\x01\x12\
    \x04\x9b\r\t\x14\n\r\n\x05\x04M\x02\x03\x03\x12\x04\x9b\r\x17\x18\n4\n\
    \x04\x04M\x02\x04\x12\x04\x9d\r\x02\x19\x1a&\x20Placeholder\x20text\x20f\
    or\x20the\x20UI\x20element.\n\n\r\n\x05\x04M\x02\x04\x05\x12\x04\x9d\r\
    \x02\x08\n\r\n\x05\x04M\x02\x04\x01\x12\x04\x9d\r\t\x14\n\r\n\x05\x04M\
    \x02\x04\x03\x12\x04\x9d\r\x17\x18\nh\n\x04\x04M\x02\x05\x12\x04\x9f\r\
    \x02;\x1aZ\x20List\x20of\x20options\x20of\x20the\x20ENUM\x20type\x20and\
    \x20potentially\x20additional\x20fields\x20they\x20bring\x20with\x20them\
    .\n\n\r\n\x05\x04M\x02\x05\x04\x12\x04\x9f\r\x02\n\n\r\n\x05\x04M\x02\
    \x05\x06\x12\x04\x9f\r\x0b\x1e\n\r\n\x05\x04M\x02\x05\x01\x12\x04\x9f\r\
    \x1f6\n\r\n\x05\x04M\x02\x05\x03\x12\x04\x9f\r9:\nD\n\x04\x04M\x02\x06\
    \x12\x04\xa1\r\x02\x19\x1a6\x20If\x20this\x20field\x20should\x20appear\
    \x20for\x20internal\x20users\x20only.\n\n\r\n\x05\x04M\x02\x06\x05\x12\
    \x04\xa1\r\x02\x06\n\r\n\x05\x04M\x02\x06\x01\x12\x04\xa1\r\x07\x14\n\r\
    \n\x05\x04M\x02\x06\x03\x12\x04\xa1\r\x17\x18\n\xf3\x01\n\x04\x04M\x02\
    \x07\x12\x04\xa5\r\x02\x14\x1a\xe4\x01\x20If\x20this\x20field\x20is\x20a\
    \x20required\x20field.\x20If\x20True\x20then\x20during\x20validation\x20\
    you\x20won't\x20be\x20able\x20to\x20create\n\x20a\x20model\x20of\x20this\
    \x20type\x20with\x20providing\x20a\x20value\x20for\x20this\x20field.\x20\
    When\x20False,\x20the\x20ModelType's\n\x20default_value\x20will\x20be\
    \x20used\x20for\x20this\x20field.\n\n\r\n\x05\x04M\x02\x07\x05\x12\x04\
    \xa5\r\x02\x06\n\r\n\x05\x04M\x02\x07\x01\x12\x04\xa5\r\x07\x0f\n\r\n\
    \x05\x04M\x02\x07\x03\x12\x04\xa5\r\x12\x13\nC\n\x04\x04M\x02\x08\x12\
    \x04\xa7\r\x02/\x1a5\x20If\x20the\x20field_type\x20is\x20RANGE,\x20this\
    \x20must\x20be\x20filled\x20in.\n\n\r\n\x05\x04M\x02\x08\x06\x12\x04\xa7\
    \r\x02\x14\n\r\n\x05\x04M\x02\x08\x01\x12\x04\xa7\r\x15*\n\r\n\x05\x04M\
    \x02\x08\x03\x12\x04\xa7\r-.\n\"\n\x02\x04N\x12\x06\xab\r\0\xb3\r\x01\
    \x1a\x14\x20ModelTypeRangeInfo\n\n\x0b\n\x03\x04N\x01\x12\x04\xab\r\x08\
    \x1a\n2\n\x04\x04N\x02\0\x12\x04\xad\r\x02\x10\x1a$\x20The\x20start\x20o\
    f\x20the\x20range\x20as\x20a\x20float.\n\n\r\n\x05\x04N\x02\0\x05\x12\
    \x04\xad\r\x02\x07\n\r\n\x05\x04N\x02\0\x01\x12\x04\xad\r\x08\x0b\n\r\n\
    \x05\x04N\x02\0\x03\x12\x04\xad\r\x0e\x0f\n0\n\x04\x04N\x02\x01\x12\x04\
    \xaf\r\x02\x10\x1a\"\x20The\x20end\x20of\x20the\x20range\x20as\x20a\x20f\
    loat.\n\n\r\n\x05\x04N\x02\x01\x05\x12\x04\xaf\r\x02\x07\n\r\n\x05\x04N\
    \x02\x01\x01\x12\x04\xaf\r\x08\x0b\n\r\n\x05\x04N\x02\x01\x03\x12\x04\
    \xaf\r\x0e\x0f\n\xb5\x01\n\x04\x04N\x02\x02\x12\x04\xb2\r\x02\x11\x1a\
    \xa6\x01\x20An\x20optional\x20step\x20size\x20for\x20the\x20range.\x20If\
    \x20provided\x20then\x20only\x20values\x20at\x20that\x20step\x20size\x20\
    will\x20be\n\x20rounded\x20to.\x20For\x20example\x20if\x20step\x20is\x20\
    0.02\x20then\x200.0245\x20will\x20round\x20to\x200.02.\n\n\r\n\x05\x04N\
    \x02\x02\x05\x12\x04\xb2\r\x02\x07\n\r\n\x05\x04N\x02\x02\x01\x12\x04\
    \xb2\r\x08\x0c\n\r\n\x05\x04N\x02\x02\x03\x12\x04\xb2\r\x0f\x10\n#\n\x02\
    \x04O\x12\x06\xb6\r\0\xcd\r\x01\x1a\x15\x20ModelTypeEnumOption\n\n\x0b\n\
    \x03\x04O\x01\x12\x04\xb6\r\x08\x1b\n4\n\x04\x04O\x02\0\x12\x04\xb8\r\
    \x02\x10\x1a&\x20The\x20unique\x20value\x20of\x20the\x20enum\x20option.\
    \n\n\r\n\x05\x04O\x02\0\x05\x12\x04\xb8\r\x02\x08\n\r\n\x05\x04O\x02\0\
    \x01\x12\x04\xb8\r\t\x0b\n\r\n\x05\x04O\x02\0\x03\x12\x04\xb8\r\x0e\x0f\
    \n\x8d\x02\n\x04\x04O\x02\x01\x12\x04\xbf\r\x020\x1a\xfe\x01\x20List\x20\
    of\x20other\x20ID\x20values\x20that\x20are\x20equivalent\x20with\x20this\
    \x20ID.\n\x20This\x20allows\x20the\x20user\x20to\x20choose\x20this\x20op\
    tion\x20by\x20multiple\x20IDs.\n\x20Example:\x20if\x20enum\x20is\x20\"Ph\
    one\x20Number\x20Prefix\",\x20you\x20could\x20add\x20an\x20option\x20tha\
    t\x20is\x20selectable\x20by\x20two\x20values:\n\x201.\x20ID:\x20\"Estoni\
    a\"\n\x202.\x20Alias:\x2037\n\n\r\n\x05\x04O\x02\x01\x04\x12\x04\xbf\r\
    \x02\n\n\r\n\x05\x04O\x02\x01\x06\x12\x04\xbf\r\x0b#\n\r\n\x05\x04O\x02\
    \x01\x01\x12\x04\xbf\r$+\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xbf\r./\n:\n\
    \x04\x04O\x02\x02\x12\x04\xc2\r\x02\x19\x1a,\x20Optional\x20description\
    \x20for\x20this\x20enum\x20option.\n\n\r\n\x05\x04O\x02\x02\x05\x12\x04\
    \xc2\r\x02\x08\n\r\n\x05\x04O\x02\x02\x01\x12\x04\xc2\r\t\x14\n\r\n\x05\
    \x04O\x02\x02\x03\x12\x04\xc2\r\x17\x18\n\x9b\x01\n\x04\x04O\x02\x03\x12\
    \x04\xc5\r\x020\x1a\x8c\x01\x20These\x20are\x20additional\x20fields\x20t\
    hat\x20are\x20specific\x20to\x20this\x20enum\x20choice.\x20This\x20allow\
    s\n\x20us\x20to\x20use\x20enums\x20to\x20control\x20configuration\x20set\
    tings\x20as\x20well.\n\n\r\n\x05\x04O\x02\x03\x04\x12\x04\xc5\r\x02\n\n\
    \r\n\x05\x04O\x02\x03\x06\x12\x04\xc5\r\x0b\x19\n\r\n\x05\x04O\x02\x03\
    \x01\x12\x04\xc5\r\x1a+\n\r\n\x05\x04O\x02\x03\x03\x12\x04\xc5\r./\n<\n\
    \x04\x04O\x02\x04\x12\x04\xc8\r\x02\x19\x1a.\x20If\x20this\x20enum\x20op\
    tion\x20should\x20be\x20internal\x20only.\n\n\r\n\x05\x04O\x02\x04\x05\
    \x12\x04\xc8\r\x02\x06\n\r\n\x05\x04O\x02\x04\x01\x12\x04\xc8\r\x07\x14\
    \n\r\n\x05\x04O\x02\x04\x03\x12\x04\xc8\r\x17\x18\n\x9c\x01\n\x04\x04O\
    \x02\x05\x12\x04\xcc\r\x02\x17\x1a\x8d\x01\x20Whether\x20this\x20is\x20t\
    he\x20recommended\x20enum\x20option.\x20Set\x20to\x20`true`\x20when\x20t\
    here\n\x20are\x20multiple\x20options,\x20and\x20one\x20is\x20shown\x20to\
    \x20be\x20better\x20than\x20the\x20others.\n\n\r\n\x05\x04O\x02\x05\x05\
    \x12\x04\xcc\r\x02\x06\n\r\n\x05\x04O\x02\x05\x01\x12\x04\xcc\r\x07\x12\
    \n\r\n\x05\x04O\x02\x05\x03\x12\x04\xcc\r\x15\x16\n\x0c\n\x02\x04P\x12\
    \x06\xcf\r\0\xd4\r\x01\n\x0b\n\x03\x04P\x01\x12\x04\xcf\r\x08\x20\n%\n\
    \x04\x04P\x02\0\x12\x04\xd1\r\x02\x13\x1a\x17\x20Integer\x20alias\x20for\
    \x20id.\n\n\r\n\x05\x04P\x02\0\x05\x12\x04\xd1\r\x02\x07\n\r\n\x05\x04P\
    \x02\0\x01\x12\x04\xd1\r\x08\x0e\n\r\n\x05\x04P\x02\0\x03\x12\x04\xd1\r\
    \x11\x12\nP\n\x04\x04P\x02\x01\x12\x04\xd3\r\x02\x1d\x1aB\x20String\x20t\
    hat\x20can\x20contain\x20wild\x20cards\x20and\x20the\x20regex\x20needs\
    \x20to\x20match.\n\n\r\n\x05\x04P\x02\x01\x05\x12\x04\xd3\r\x02\x08\n\r\
    \n\x05\x04P\x02\x01\x01\x12\x04\xd3\r\t\x18\n\r\n\x05\x04P\x02\x01\x03\
    \x12\x04\xd3\r\x1b\x1c\n\x1a\n\x02\x04Q\x12\x06\xd7\r\0\xde\r\x01\x1a\
    \x0c\x20ModelQuery\n\n\x0b\n\x03\x04Q\x01\x12\x04\xd7\r\x08\x12\n\x0b\n\
    \x03\x04Q\t\x12\x04\xd8\r\x02\r\n\x0c\n\x04\x04Q\t\0\x12\x04\xd8\r\x0b\
    \x0c\n\r\n\x05\x04Q\t\0\x01\x12\x04\xd8\r\x0b\x0c\n\r\n\x05\x04Q\t\0\x02\
    \x12\x04\xd8\r\x0b\x0c\nq\n\x04\x04Q\x02\0\x12\x04\xda\r\x02\x12\x1ac\
    \x20The\x20name\x20ofthe\x20field.\x20This\x20supports\x20wilcard\x20que\
    ries\x20like\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20an\x20ex\
    ample.\n\n\r\n\x05\x04Q\x02\0\x05\x12\x04\xda\r\x02\x08\n\r\n\x05\x04Q\
    \x02\0\x01\x12\x04\xda\r\t\r\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xda\r\x10\
    \x11\nz\n\x04\x04Q\x02\x01\x12\x04\xdd\r\x02\x1b\x1al\x20Filter\x20model\
    s\x20by\x20the\x20specific\x20model_type_id.\x20See\x20ListModelTypes\
    \x20for\x20the\x20list\x20of\x20ModelType.Id's\n\x20supported.\n\n\r\n\
    \x05\x04Q\x02\x01\x05\x12\x04\xdd\r\x02\x08\n\r\n\x05\x04Q\x02\x01\x01\
    \x12\x04\xdd\r\t\x16\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xdd\r\x19\x1a\n\
    \x0c\n\x02\x05\x07\x12\x06\xdf\r\0\xec\r\x01\n\x0b\n\x03\x05\x07\x01\x12\
    \x04\xdf\r\x05\x14\n\x0c\n\x04\x05\x07\x02\0\x12\x04\xe0\r\x02\x20\n\r\n\
    \x05\x05\x07\x02\0\x01\x12\x04\xe0\r\x02\x1b\n\r\n\x05\x05\x07\x02\0\x02\
    \x12\x04\xe0\r\x1e\x1f\n\x1d\n\x04\x05\x07\x02\x01\x12\x04\xe3\r\x02\x13\
    \x1a\x0f\x20input\x20>\x20value\n\n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\
    \xe3\r\x02\x0e\n\r\n\x05\x05\x07\x02\x01\x02\x12\x04\xe3\r\x11\x12\n\x1e\
    \n\x04\x05\x07\x02\x02\x12\x04\xe5\r\x02\x1c\x1a\x10\x20input\x20>=\x20v\
    alue\n\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xe5\r\x02\x17\n\r\n\x05\x05\
    \x07\x02\x02\x02\x12\x04\xe5\r\x1a\x1b\n\x1d\n\x04\x05\x07\x02\x03\x12\
    \x04\xe7\r\x02\x10\x1a\x0f\x20input\x20<\x20value\n\n\r\n\x05\x05\x07\
    \x02\x03\x01\x12\x04\xe7\r\x02\x0b\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\
    \xe7\r\x0e\x0f\n\x1e\n\x04\x05\x07\x02\x04\x12\x04\xe9\r\x02\x19\x1a\x10\
    \x20input\x20<=\x20value\n\n\r\n\x05\x05\x07\x02\x04\x01\x12\x04\xe9\r\
    \x02\x14\n\r\n\x05\x05\x07\x02\x04\x02\x12\x04\xe9\r\x17\x18\n\x1e\n\x04\
    \x05\x07\x02\x05\x12\x04\xeb\r\x02\x0c\x1a\x10\x20input\x20==\x20value\n\
    \n\r\n\x05\x05\x07\x02\x05\x01\x12\x04\xeb\r\x02\x07\n\r\n\x05\x05\x07\
    \x02\x05\x02\x12\x04\xeb\r\n\x0b\n\x0c\n\x02\x05\x08\x12\x06\xee\r\0\xf6\
    \r\x01\n\x0b\n\x03\x05\x08\x01\x12\x04\xee\r\x05\x13\n\x0c\n\x04\x05\x08\
    \x02\0\x12\x04\xef\r\x02\x10\n\r\n\x05\x05\x08\x02\0\x01\x12\x04\xef\r\
    \x02\x0b\n\r\n\x05\x05\x08\x02\0\x02\x12\x04\xef\r\x0e\x0f\n\x17\n\x04\
    \x05\x08\x02\x01\x12\x04\xf0\r\x02\x15\"\t\x20default\n\n\r\n\x05\x05\
    \x08\x02\x01\x01\x12\x04\xf0\r\x02\x10\n\r\n\x05\x05\x08\x02\x01\x02\x12\
    \x04\xf0\r\x13\x14\n\x0c\n\x04\x05\x08\x02\x02\x12\x04\xf1\r\x02\x10\n\r\
    \n\x05\x05\x08\x02\x02\x01\x12\x04\xf1\r\x02\x0b\n\r\n\x05\x05\x08\x02\
    \x02\x02\x12\x04\xf1\r\x0e\x0f\n\x0c\n\x04\x05\x08\x02\x03\x12\x04\xf2\r\
    \x02\x13\n\r\n\x05\x05\x08\x02\x03\x01\x12\x04\xf2\r\x02\x0e\n\r\n\x05\
    \x05\x08\x02\x03\x02\x12\x04\xf2\r\x11\x12\n\x0c\n\x04\x05\x08\x02\x04\
    \x12\x04\xf3\r\x02\x11\n\r\n\x05\x05\x08\x02\x04\x01\x12\x04\xf3\r\x02\
    \x0c\n\r\n\x05\x05\x08\x02\x04\x02\x12\x04\xf3\r\x0f\x10\n\x0c\n\x04\x05\
    \x08\x02\x05\x12\x04\xf4\r\x02\x0e\n\r\n\x05\x05\x08\x02\x05\x01\x12\x04\
    \xf4\r\x02\t\n\r\n\x05\x05\x08\x02\x05\x02\x12\x04\xf4\r\x0c\r\n\x0c\n\
    \x04\x05\x08\x02\x06\x12\x04\xf5\r\x02\x11\n\r\n\x05\x05\x08\x02\x06\x01\
    \x12\x04\xf5\r\x02\x0c\n\r\n\x05\x05\x08\x02\x06\x02\x12\x04\xf5\r\x0f\
    \x10\n\x1c\n\x02\x04R\x12\x06\xfa\r\0\xba\x0e\x01\x1a\x0e\x20ModelVersio\
    n\n\n\x0b\n\x03\x04R\x01\x12\x04\xfa\r\x08\x14\n\x0b\n\x03\x04R\t\x12\
    \x04\xfb\r\x02\x11\n\x0c\n\x04\x04R\t\0\x12\x04\xfb\r\x0b\x0c\n\r\n\x05\
    \x04R\t\0\x01\x12\x04\xfb\r\x0b\x0c\n\r\n\x05\x04R\t\0\x02\x12\x04\xfb\r\
    \x0b\x0c\n\x0c\n\x04\x04R\t\x01\x12\x04\xfb\r\x0e\x10\n\r\n\x05\x04R\t\
    \x01\x01\x12\x04\xfb\r\x0e\x10\n\r\n\x05\x04R\t\x01\x02\x12\x04\xfb\r\
    \x0e\x10\n\x0c\n\x04\x04R\x02\0\x12\x04\xfd\r\x02\x10\n\r\n\x05\x04R\x02\
    \0\x05\x12\x04\xfd\r\x02\x08\n\r\n\x05\x04R\x02\0\x01\x12\x04\xfd\r\t\
    \x0b\n\r\n\x05\x04R\x02\0\x03\x12\x04\xfd\r\x0e\x0f\n-\n\x04\x04R\x02\
    \x01\x12\x04\xff\r\x02+\x1a\x1f\x20When\x20the\x20version\x20was\x20crea\
    ted.\n\n\r\n\x05\x04R\x02\x01\x06\x12\x04\xff\r\x02\x1b\n\r\n\x05\x04R\
    \x02\x01\x01\x12\x04\xff\r\x1c&\n\r\n\x05\x04R\x02\x01\x03\x12\x04\xff\r\
    )*\n\\\n\x04\x04R\x02\x02\x12\x04\x81\x0e\x02(\x1aN\x20The\x20status\x20\
    of\x20the\x20version\x20(whether\x20it's\x20untrained,\x20training,\x20t\
    rained,\x20etc.).\n\n\r\n\x05\x04R\x02\x02\x06\x12\x04\x81\x0e\x02\x1c\n\
    \r\n\x05\x04R\x02\x02\x01\x12\x04\x81\x0e\x1d#\n\r\n\x05\x04R\x02\x02\
    \x03\x12\x04\x81\x0e&'\n\x0c\n\x04\x04R\x02\x03\x12\x04\x83\x0e\x02\"\n\
    \r\n\x05\x04R\x02\x03\x05\x12\x04\x83\x0e\x02\x08\n\r\n\x05\x04R\x02\x03\
    \x01\x12\x04\x83\x0e\t\x1d\n\r\n\x05\x04R\x02\x03\x03\x12\x04\x83\x0e\
    \x20!\n\x0c\n\x04\x04R\x02\x04\x12\x04\x85\x0e\x02\x1a\n\r\n\x05\x04R\
    \x02\x04\x06\x12\x04\x85\x0e\x02\r\n\r\n\x05\x04R\x02\x04\x01\x12\x04\
    \x85\x0e\x0e\x15\n\r\n\x05\x04R\x02\x04\x03\x12\x04\x85\x0e\x18\x19\n5\n\
    \x04\x04R\x02\x05\x12\x04\x88\x0e\x02\x1f\x1a'\x20number\x20of\x20inputs\
    \x20in\x20the\x20model\x20version\n\n\r\n\x05\x04R\x02\x05\x05\x12\x04\
    \x88\x0e\x02\x08\n\r\n\x05\x04R\x02\x05\x01\x12\x04\x88\x0e\t\x1a\n\r\n\
    \x05\x04R\x02\x05\x03\x12\x04\x88\x0e\x1d\x1e\n\x0c\n\x04\x04R\x02\x06\
    \x12\x04\x8a\x0e\x024\n\r\n\x05\x04R\x02\x06\x06\x12\x04\x8a\x0e\x02\x17\
    \n\r\n\x05\x04R\x02\x06\x01\x12\x04\x8a\x0e\x18/\n\r\n\x05\x04R\x02\x06\
    \x03\x12\x04\x8a\x0e23\nX\n\x04\x04R\x02\x07\x12\x04\x8f\x0e\x02.\x1a.\
    \x20When\x20training\x20of\x20this\x20version\x20was\x20completed.\n2\
    \x1a\x20Detailed\x20training\x20stats.\n\n\r\n\x05\x04R\x02\x07\x06\x12\
    \x04\x8f\x0e\x02\x1b\n\r\n\x05\x04R\x02\x07\x01\x12\x04\x8f\x0e\x1c(\n\r\
    \n\x05\x04R\x02\x07\x03\x12\x04\x8f\x0e+-\n.\n\x04\x04R\x02\x08\x12\x04\
    \x92\x0e\x02\x1a\x1a\x20\x20Description\x20about\x20this\x20version\n\n\
    \r\n\x05\x04R\x02\x08\x05\x12\x04\x92\x0e\x02\x08\n\r\n\x05\x04R\x02\x08\
    \x01\x12\x04\x92\x0e\t\x14\n\r\n\x05\x04R\x02\x08\x03\x12\x04\x92\x0e\
    \x17\x19\n\xdd\x01\n\x04\x04R\x02\t\x12\x04\x97\x0e\x02\x1d\x1a\xce\x01\
    \x20The\x20visibility\x20field\x20represents\x20whether\x20this\x20messa\
    ge\x20is\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\x20t\
    o\x20the\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\
    \x20User\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20pu\
    blicly\x20visible.\n\n\r\n\x05\x04R\x02\t\x06\x12\x04\x97\x0e\x02\x0c\n\
    \r\n\x05\x04R\x02\t\x01\x12\x04\x97\x0e\r\x17\n\r\n\x05\x04R\x02\t\x03\
    \x12\x04\x97\x0e\x1a\x1c\n5\n\x04\x04R\x02\n\x12\x04\x9a\x0e\x02\x15\x1a\
    '\x20The\x20app\x20the\x20model\x20version\x20belongs\x20to.\n\n\r\n\x05\
    \x04R\x02\n\x05\x12\x04\x9a\x0e\x02\x08\n\r\n\x05\x04R\x02\n\x01\x12\x04\
    \x9a\x0e\t\x0f\n\r\n\x05\x04R\x02\n\x03\x12\x04\x9a\x0e\x12\x14\n6\n\x04\
    \x04R\x02\x0b\x12\x04\x9c\x0e\x02\x16\x1a(\x20The\x20user\x20the\x20mode\
    l\x20version\x20belongs\x20to.\n\n\r\n\x05\x04R\x02\x0b\x05\x12\x04\x9c\
    \x0e\x02\x08\n\r\n\x05\x04R\x02\x0b\x01\x12\x04\x9c\x0e\t\x10\n\r\n\x05\
    \x04R\x02\x0b\x03\x12\x04\x9c\x0e\x13\x15\n9\n\x04\x04R\x02\x0c\x12\x04\
    \x9f\x0e\x02-\x1a+\x20When\x20this\x20model\x20version\x20was\x20last\
    \x20modified\n\n\r\n\x05\x04R\x02\x0c\x06\x12\x04\x9f\x0e\x02\x1b\n\r\n\
    \x05\x04R\x02\x0c\x01\x12\x04\x9f\x0e\x1c'\n\r\n\x05\x04R\x02\x0c\x03\
    \x12\x04\x9f\x0e*,\n\x9f\x01\n\x04\x04R\x02\r\x12\x04\xa3\x0e\x02'\x1a\
    \x90\x01\x20To\x20handle\x20arbitrary\x20json\x20metadata\x20you\x20can\
    \x20use\x20a\x20struct\x20field:\n\x20https://github.com/google/protobuf\
    /blob/master/src/google/protobuf/struct.proto\n\n\r\n\x05\x04R\x02\r\x06\
    \x12\x04\xa3\x0e\x02\x18\n\r\n\x05\x04R\x02\r\x01\x12\x04\xa3\x0e\x19!\n\
    \r\n\x05\x04R\x02\r\x03\x12\x04\xa3\x0e$&\n\x0c\n\x04\x04R\x02\x0e\x12\
    \x04\xa5\x0e\x02\x16\n\r\n\x05\x04R\x02\x0e\x05\x12\x04\xa5\x0e\x02\x08\
    \n\r\n\x05\x04R\x02\x0e\x01\x12\x04\xa5\x0e\t\x10\n\r\n\x05\x04R\x02\x0e\
    \x03\x12\x04\xa5\x0e\x13\x15\n\x81\x02\n\x04\x04R\x02\x0f\x12\x04\xaa\
    \x0e\x02\x1e\x1a\xf2\x01\x20Info\x20about\x20the\x20model's\x20output.\
    \x20Besides\x20`output_info.data`,\x20these\x20fields\x20should\n\x20be\
    \x20reserved\x20for\x20parameters\x20that\x20affect\x20the\x20models\x20\
    outputs\x20when\x20inferencing.\n\x20`output_info.data`\x20is\x20used\
    \x20to\x20specify\x20the\x20training\x20concepts\x20for\x20this\x20model\
    \x20version.\n\n\r\n\x05\x04R\x02\x0f\x06\x12\x04\xaa\x0e\x02\x0c\n\r\n\
    \x05\x04R\x02\x0f\x01\x12\x04\xaa\x0e\r\x18\n\r\n\x05\x04R\x02\x0f\x03\
    \x12\x04\xaa\x0e\x1b\x1d\n\x86\x02\n\x04\x04R\x02\x10\x12\x04\xad\x0e\
    \x02\x1c\x1a\xf7\x01\x20Info\x20about\x20preprocessing\x20the\x20models\
    \x20inputs,\x20before\x20they\x20are\x20sent\x20to\x20this\x20model\x20f\
    or\x20training\x20or\x20inferencing.\n\x20E.g.:\x20`input_info.base_embe\
    d_model`\x20lets\x20us\x20know\x20inputs\x20should\x20be\x20ran\x20throu\
    gh\x20a\x20base\x20model\x20before\x20being\x20sent\x20to\x20an\x20embed\
    ding-classifier.\n\n\r\n\x05\x04R\x02\x10\x06\x12\x04\xad\x0e\x02\x0b\n\
    \r\n\x05\x04R\x02\x10\x01\x12\x04\xad\x0e\x0c\x16\n\r\n\x05\x04R\x02\x10\
    \x03\x12\x04\xad\x0e\x19\x1b\nM\n\x04\x04R\x02\x11\x12\x04\xaf\x0e\x02\
    \x1c\x1a?\x20Configuration\x20for\x20the\x20training\x20process\x20of\
    \x20this\x20model\x20version.\n\n\r\n\x05\x04R\x02\x11\x06\x12\x04\xaf\
    \x0e\x02\x0b\n\r\n\x05\x04R\x02\x11\x01\x12\x04\xaf\x0e\x0c\x16\n\r\n\
    \x05\x04R\x02\x11\x03\x12\x04\xaf\x0e\x19\x1b\nL\n\x04\x04R\x02\x12\x12\
    \x04\xb1\x0e\x02\x1e\x1a>\x20Configuration\x20used\x20to\x20import\x20mo\
    del\x20from\x20third-party\x20toolkits\n\n\r\n\x05\x04R\x02\x12\x06\x12\
    \x04\xb1\x0e\x02\x0c\n\r\n\x05\x04R\x02\x12\x01\x12\x04\xb1\x0e\r\x18\n\
    \r\n\x05\x04R\x02\x12\x03\x12\x04\xb1\x0e\x1b\x1d\n7\n\x04\x04R\x02\x13\
    \x12\x04\xb3\x0e\x02\x18\x1a)\x20Contains\x20the\x20training\x20logs\x20\
    if\x20available\n\n\r\n\x05\x04R\x02\x13\x05\x12\x04\xb3\x0e\x02\x08\n\r\
    \n\x05\x04R\x02\x13\x01\x12\x04\xb3\x0e\t\x12\n\r\n\x05\x04R\x02\x13\x03\
    \x12\x04\xb3\x0e\x15\x17\nS\n\x04\x04R\x02\x14\x12\x04\xb6\x0e\x02*\x1aE\
    \x20The\x20minimum\x20required\x20compute\x20resource\x20for\x20this\x20\
    model\x20for\x20inference.\n\n\r\n\x05\x04R\x02\x14\x06\x12\x04\xb6\x0e\
    \x02\r\n\r\n\x05\x04R\x02\x14\x01\x12\x04\xb6\x0e\x0e$\n\r\n\x05\x04R\
    \x02\x14\x03\x12\x04\xb6\x0e')\n7\n\x04\x04R\x02\x15\x12\x04\xb9\x0e\x02\
    \x1c\x1a)\x20Build\x20information\x20for\x20the\x20model\x20version\n\n\
    \r\n\x05\x04R\x02\x15\x06\x12\x04\xb9\x0e\x02\x0b\n\r\n\x05\x04R\x02\x15\
    \x01\x12\x04\xb9\x0e\x0c\x16\n\r\n\x05\x04R\x02\x15\x03\x12\x04\xb9\x0e\
    \x19\x1b\n\x0c\n\x02\x04S\x12\x06\xbc\x0e\0\xc3\x0e\x01\n\x0b\n\x03\x04S\
    \x01\x12\x04\xbc\x0e\x08\x11\n!\n\x04\x04S\x02\0\x12\x04\xbe\x0e\x02\x1f\
    \x1a\x13\x20Docker\x20image\x20name\n\n\r\n\x05\x04S\x02\0\x05\x12\x04\
    \xbe\x0e\x02\x08\n\r\n\x05\x04S\x02\0\x01\x12\x04\xbe\x0e\t\x1a\n\r\n\
    \x05\x04S\x02\0\x03\x12\x04\xbe\x0e\x1d\x1e\n\x20\n\x04\x04S\x02\x01\x12\
    \x04\xc0\x0e\x02\x1e\x1a\x12\x20Docker\x20image\x20tag\n\n\r\n\x05\x04S\
    \x02\x01\x05\x12\x04\xc0\x0e\x02\x08\n\r\n\x05\x04S\x02\x01\x01\x12\x04\
    \xc0\x0e\t\x19\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xc0\x0e\x1c\x1d\n#\n\
    \x04\x04S\x02\x02\x12\x04\xc2\x0e\x02!\x1a\x15\x20Docker\x20image\x20dig\
    est\n\n\r\n\x05\x04S\x02\x02\x05\x12\x04\xc2\x0e\x02\x08\n\r\n\x05\x04S\
    \x02\x02\x01\x12\x04\xc2\x0e\t\x1c\n\r\n\x05\x04S\x02\x02\x03\x12\x04\
    \xc2\x0e\x1f\x20\nW\n\x02\x04T\x12\x06\xc6\x0e\0\xcd\x0e\x01\x1aI\x20Mod\
    elVersionExport\x20contains\x20metadata\x20for\x20a\x20single\x20Model\
    \x20version\x20export.\n\n\x0b\n\x03\x04T\x01\x12\x04\xc6\x0e\x08\x1a\nK\
    \n\x04\x04T\x02\0\x12\x04\xc8\x0e\x02(\x1a=\x20status\x20is\x20the\x20cu\
    rrent\x20status\x20of\x20the\x20dataset\x20version\x20export.\n\n\r\n\
    \x05\x04T\x02\0\x06\x12\x04\xc8\x0e\x02\x1c\n\r\n\x05\x04T\x02\0\x01\x12\
    \x04\xc8\x0e\x1d#\n\r\n\x05\x04T\x02\0\x03\x12\x04\xc8\x0e&'\nU\n\x04\
    \x04T\x02\x01\x12\x04\xca\x0e\x02\x11\x1aG\x20url\x20is\x20the\x20URL\
    \x20from\x20where\x20the\x20model\x20version\x20export\x20can\x20be\x20d\
    ownloaded.\n\n\r\n\x05\x04T\x02\x01\x05\x12\x04\xca\x0e\x02\x08\n\r\n\
    \x05\x04T\x02\x01\x01\x12\x04\xca\x0e\t\x0c\n\r\n\x05\x04T\x02\x01\x03\
    \x12\x04\xca\x0e\x0f\x10\n\"\n\x04\x04T\x02\x02\x12\x04\xcc\x0e\x02\x11\
    \x1a\x14\x20size\x20of\x20model\x20file\n\n\r\n\x05\x04T\x02\x02\x05\x12\
    \x04\xcc\x0e\x02\x07\n\r\n\x05\x04T\x02\x02\x01\x12\x04\xcc\x0e\x08\x0c\
    \n\r\n\x05\x04T\x02\x02\x03\x12\x04\xcc\x0e\x0f\x10\n%\n\x02\x04U\x12\
    \x06\xd0\x0e\0\xdc\x0e\x01\x1a\x17\x20PretrainedModelConfig\n\n\x0b\n\
    \x03\x04U\x01\x12\x04\xd0\x0e\x08\x1d\n\x0b\n\x03\x04U\t\x12\x04\xd1\x0e\
    \x02\x10\n\x0c\n\x04\x04U\t\0\x12\x04\xd1\x0e\x0b\x0c\n\r\n\x05\x04U\t\0\
    \x01\x12\x04\xd1\x0e\x0b\x0c\n\r\n\x05\x04U\t\0\x02\x12\x04\xd1\x0e\x0b\
    \x0c\n\x0c\n\x04\x04U\t\x01\x12\x04\xd1\x0e\x0e\x0f\n\r\n\x05\x04U\t\x01\
    \x01\x12\x04\xd1\x0e\x0e\x0f\n\r\n\x05\x04U\t\x01\x02\x12\x04\xd1\x0e\
    \x0e\x0f\n\x85\x01\n\x04\x04U\x02\0\x12\x04\xd4\x0e\x02.\x1aw\x20This\
    \x20is\x20the\x20internal\x20id\x20of\x20the\x20pretrained\x20model.\n\
    \x20Map\x20from\x20the\x20api.Data\x20field\x20names\x20to\x20the\x20Tri\
    ton\x20config.pbtxt\x20input.\n\n\r\n\x05\x04U\x02\0\x06\x12\x04\xd4\x0e\
    \x02\x18\n\r\n\x05\x04U\x02\0\x01\x12\x04\xd4\x0e\x19)\n\r\n\x05\x04U\
    \x02\0\x03\x12\x04\xd4\x0e,-\nT\n\x04\x04U\x02\x01\x12\x04\xd6\x0e\x02/\
    \x1aF\x20Map\x20from\x20the\x20api.Data\x20field\x20names\x20to\x20the\
    \x20Triton\x20config.pbtxt\x20output.\n\n\r\n\x05\x04U\x02\x01\x06\x12\
    \x04\xd6\x0e\x02\x18\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xd6\x0e\x19*\n\r\
    \n\x05\x04U\x02\x01\x03\x12\x04\xd6\x0e-.\n\x9d\x02\n\x04\x04U\x02\x02\
    \x12\x04\xda\x0e\x02\x1b\x1a\xcf\x01\x20Url\x20to\x20a\x20zipped\x20up\
    \x20model\x20in\x20triton\x20format\x20with\x20the\x20following\x20files\
    \x20and\x20folders\x20at\x20the\x20root:\n\x20\x20config.pbtxt\n\x20\x20\
    version\x201\x20folder\x20that\x20contains\x20model\x20files\x20(onnx\
    \x20graph,\x20torch\x20script,\x20python\x20BE\x20model,\x20and\x20etc.)\
    \n\"=\x20Whether\x20to\x20overwrite\x20the\x20model\x20for\x20the\x20exi\
    sting\x20internal\x20id\n\n\r\n\x05\x04U\x02\x02\x05\x12\x04\xda\x0e\x02\
    \x08\n\r\n\x05\x04U\x02\x02\x01\x12\x04\xda\x0e\t\x16\n\r\n\x05\x04U\x02\
    \x02\x03\x12\x04\xda\x0e\x19\x1a\n\x18\n\x02\x04V\x12\x04\xdf\x0e\0>\x1a\
    \x0c\x20TrainStats\n\n\x0b\n\x03\x04V\x01\x12\x04\xdf\x0e\x08\x12\n\x0c\
    \n\x04\x04V\x02\0\x12\x04\xdf\x0e\x15<\n\r\n\x05\x04V\x02\0\x04\x12\x04\
    \xdf\x0e\x15\x1d\n\r\n\x05\x04V\x02\0\x06\x12\x04\xdf\x0e\x1e,\n\r\n\x05\
    \x04V\x02\0\x01\x12\x04\xdf\x0e-7\n\r\n\x05\x04V\x02\0\x03\x12\x04\xdf\
    \x0e:;\n\x1e\n\x02\x04W\x12\x06\xe2\x0e\0\xea\x0e\x01\x1a\x10\x20LossCur\
    veEntry\n\n\x0b\n\x03\x04W\x01\x12\x04\xe2\x0e\x08\x16\n\x1d\n\x04\x04W\
    \x02\0\x12\x04\xe4\x0e\x02\x13\x1a\x0f\x20current\x20epoch\n\n\r\n\x05\
    \x04W\x02\0\x05\x12\x04\xe4\x0e\x02\x08\n\r\n\x05\x04W\x02\0\x01\x12\x04\
    \xe4\x0e\t\x0e\n\r\n\x05\x04W\x02\0\x03\x12\x04\xe4\x0e\x11\x12\n#\n\x04\
    \x04W\x02\x01\x12\x04\xe6\x0e\x02\x19\x1a\x15\x20current\x20global\x20st\
    ep\n\n\r\n\x05\x04W\x02\x01\x05\x12\x04\xe6\x0e\x02\x08\n\r\n\x05\x04W\
    \x02\x01\x01\x12\x04\xe6\x0e\t\x14\n\r\n\x05\x04W\x02\x01\x03\x12\x04\
    \xe6\x0e\x17\x18\nP\n\x04\x04W\x02\x02\x12\x04\xe9\x0e\x02\x11\x1aB\x20c\
    urrent\x20cost\n\x20FIXME(rigel):\x20this\x20should\x20be\x20loss\x20ins\
    tead\x20of\x20cost.\n\n\r\n\x05\x04W\x02\x02\x05\x12\x04\xe9\x0e\x02\x07\
    \n\r\n\x05\x04W\x02\x02\x01\x12\x04\xe9\x0e\x08\x0c\n\r\n\x05\x04W\x02\
    \x02\x03\x12\x04\xe9\x0e\x0f\x10\n\x1a\n\x02\x04X\x12\x06\xed\x0e\0\xf1\
    \x0e\x01\x1a\x0c\x20LabelCount\n\n\x0b\n\x03\x04X\x01\x12\x04\xed\x0e\
    \x08\x12\n\x0c\n\x04\x04X\x02\0\x12\x04\xee\x0e\x02.\n\r\n\x05\x04X\x02\
    \0\x05\x12\x04\xee\x0e\x02\x08\n\r\n\x05\x04X\x02\0\x01\x12\x04\xee\x0e\
    \t\x15\n\r\n\x05\x04X\x02\0\x03\x12\x04\xee\x0e\x18\x19\n\r\n\x05\x04X\
    \x02\0\x08\x12\x04\xee\x0e\x1a-\n\x0e\n\x06\x04X\x02\0\x08\x03\x12\x04\
    \xee\x0e\x1b,\n\x0c\n\x04\x04X\x02\x01\x12\x04\xef\x0e\x02\x13\n\r\n\x05\
    \x04X\x02\x01\x05\x12\x04\xef\x0e\x02\x08\n\r\n\x05\x04X\x02\x01\x01\x12\
    \x04\xef\x0e\t\x0e\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xef\x0e\x11\x12\n\
    \x0c\n\x04\x04X\x02\x02\x12\x04\xf0\x0e\x02\x16\n\r\n\x05\x04X\x02\x02\
    \x06\x12\x04\xf0\x0e\x02\t\n\r\n\x05\x04X\x02\x02\x01\x12\x04\xf0\x0e\n\
    \x11\n\r\n\x05\x04X\x02\x02\x03\x12\x04\xf0\x0e\x14\x15\n\x1f\n\x02\x04Y\
    \x12\x04\xf4\x0e\0L\x1a\x13\x20LabelDistribution\n\n\x0b\n\x03\x04Y\x01\
    \x12\x04\xf4\x0e\x08\x19\n\x0c\n\x04\x04Y\x02\0\x12\x04\xf4\x0e\x1cJ\n\r\
    \n\x05\x04Y\x02\0\x04\x12\x04\xf4\x0e\x1c$\n\r\n\x05\x04Y\x02\0\x06\x12\
    \x04\xf4\x0e%/\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xf4\x0e0E\n\r\n\x05\x04Y\
    \x02\0\x03\x12\x04\xf4\x0eHI\nV\n\x02\x04Z\x12\x06\xf7\x0e\0\xfd\x0e\x01\
    \x1aH\x20NOTE:\x20this\x20is\x20inefficient,\x20should\x20just\x20have\
    \x20the\x20order\x20of\x20the\x20rows/cols\n\n\x0b\n\x03\x04Z\x01\x12\
    \x04\xf7\x0e\x08\x1f\n&\n\x04\x04Z\x02\0\x12\x04\xf9\x0e\x02\x11\x1a\x18\
    \x20concept_id\x20for\x20the\x20row\n\n\r\n\x05\x04Z\x02\0\x05\x12\x04\
    \xf9\x0e\x02\x08\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xf9\x0e\t\x0c\n\r\n\
    \x05\x04Z\x02\0\x03\x12\x04\xf9\x0e\x0f\x10\n&\n\x04\x04Z\x02\x01\x12\
    \x04\xfb\x0e\x02\x11\x1a\x18\x20concept_id\x20for\x20the\x20col\n\n\r\n\
    \x05\x04Z\x02\x01\x05\x12\x04\xfb\x0e\x02\x08\n\r\n\x05\x04Z\x02\x01\x01\
    \x12\x04\xfb\x0e\t\x0c\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\xfb\x0e\x0f\
    \x10\n\x0c\n\x04\x04Z\x02\x02\x12\x04\xfc\x0e\x02\x13\n\r\n\x05\x04Z\x02\
    \x02\x05\x12\x04\xfc\x0e\x02\x08\n\r\n\x05\x04Z\x02\x02\x01\x12\x04\xfc\
    \x0e\t\x0e\n\r\n\x05\x04Z\x02\x02\x03\x12\x04\xfc\x0e\x11\x12\n\"\n\x02\
    \x04[\x12\x06\x80\x0f\0\x84\x0f\x01\x1a\x14\x20CooccurrenceMatrix\n\n\
    \x0b\n\x03\x04[\x01\x12\x04\x80\x0f\x08\x1a\n\x0c\n\x04\x04[\x02\0\x12\
    \x04\x81\x0f\x02.\n\r\n\x05\x04[\x02\0\x04\x12\x04\x81\x0f\x02\n\n\r\n\
    \x05\x04[\x02\0\x06\x12\x04\x81\x0f\x0b\"\n\r\n\x05\x04[\x02\0\x01\x12\
    \x04\x81\x0f#)\n\r\n\x05\x04[\x02\0\x03\x12\x04\x81\x0f,-\ne\n\x04\x04[\
    \x02\x01\x12\x04\x83\x0f\x02\"\x1aW\x20These\x20concept_ids\x20are\x20or\
    dered\x20by\x20the\x20strength\x20of\x20the\x20diagonal\x20in\x20the\x20\
    ConfusionMatrix.\n\n\r\n\x05\x04[\x02\x01\x04\x12\x04\x83\x0f\x02\n\n\r\
    \n\x05\x04[\x02\x01\x05\x12\x04\x83\x0f\x0b\x11\n\r\n\x05\x04[\x02\x01\
    \x01\x12\x04\x83\x0f\x12\x1d\n\r\n\x05\x04[\x02\x01\x03\x12\x04\x83\x0f\
    \x20!\n$\n\x02\x04\\\x12\x06\x87\x0f\0\x8d\x0f\x01\x1a\x16\x20ConfusionM\
    atrixEntry\n\n\x0b\n\x03\x04\\\x01\x12\x04\x87\x0f\x08\x1c\n\x0c\n\x04\
    \x04\\\x02\0\x12\x04\x88\x0f\x02\x17\n\r\n\x05\x04\\\x02\0\x05\x12\x04\
    \x88\x0f\x02\x08\n\r\n\x05\x04\\\x02\0\x01\x12\x04\x88\x0f\t\x12\n\r\n\
    \x05\x04\\\x02\0\x03\x12\x04\x88\x0f\x15\x16\n\x0c\n\x04\x04\\\x02\x01\
    \x12\x04\x89\x0f\x02\x14\n\r\n\x05\x04\\\x02\x01\x05\x12\x04\x89\x0f\x02\
    \x08\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\x89\x0f\t\x0f\n\r\n\x05\x04\\\
    \x02\x01\x03\x12\x04\x89\x0f\x12\x13\n\x0c\n\x04\x04\\\x02\x02\x12\x04\
    \x8a\x0f\x02A\n\r\n\x05\x04\\\x02\x02\x05\x12\x04\x8a\x0f\x02\x07\n\r\n\
    \x05\x04\\\x02\x02\x01\x12\x04\x8a\x0f\x08\r\n\r\n\x05\x04\\\x02\x02\x03\
    \x12\x04\x8a\x0f\x10\x11\n\r\n\x05\x04\\\x02\x02\x08\x12\x04\x8a\x0f\x12\
    @\n\x10\n\x08\x04\\\x02\x02\x08\xd0\x86\x03\x12\x04\x8a\x0f\x13?\n\x0c\n\
    \x04\x04\\\x02\x03\x12\x04\x8b\x0f\x02\x20\n\r\n\x05\x04\\\x02\x03\x06\
    \x12\x04\x8b\x0f\x02\t\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\x8b\x0f\n\x1b\
    \n\r\n\x05\x04\\\x02\x03\x03\x12\x04\x8b\x0f\x1e\x1f\n\x0c\n\x04\x04\\\
    \x02\x04\x12\x04\x8c\x0f\x02\x1d\n\r\n\x05\x04\\\x02\x04\x06\x12\x04\x8c\
    \x0f\x02\t\n\r\n\x05\x04\\\x02\x04\x01\x12\x04\x8c\x0f\n\x18\n\r\n\x05\
    \x04\\\x02\x04\x03\x12\x04\x8c\x0f\x1b\x1c\n\x1f\n\x02\x04]\x12\x06\x90\
    \x0f\0\x94\x0f\x01\x1a\x11\x20ConfusionMatrix\n\n\x0b\n\x03\x04]\x01\x12\
    \x04\x90\x0f\x08\x17\n\x0c\n\x04\x04]\x02\0\x12\x04\x91\x0f\x02+\n\r\n\
    \x05\x04]\x02\0\x04\x12\x04\x91\x0f\x02\n\n\r\n\x05\x04]\x02\0\x06\x12\
    \x04\x91\x0f\x0b\x1f\n\r\n\x05\x04]\x02\0\x01\x12\x04\x91\x0f\x20&\n\r\n\
    \x05\x04]\x02\0\x03\x12\x04\x91\x0f)*\ne\n\x04\x04]\x02\x01\x12\x04\x93\
    \x0f\x02\"\x1aW\x20These\x20concept_ids\x20are\x20ordered\x20by\x20the\
    \x20strength\x20of\x20the\x20diagonal\x20in\x20the\x20ConfusionMatrix.\n\
    \n\r\n\x05\x04]\x02\x01\x04\x12\x04\x93\x0f\x02\n\n\r\n\x05\x04]\x02\x01\
    \x05\x12\x04\x93\x0f\x0b\x11\n\r\n\x05\x04]\x02\x01\x01\x12\x04\x93\x0f\
    \x12\x1d\n\r\n\x05\x04]\x02\x01\x03\x12\x04\x93\x0f\x20!\n\x13\n\x02\x04\
    ^\x12\x06\x97\x0f\0\x9d\x0f\x01\x1a\x05\x20ROC\n\n\x0b\n\x03\x04^\x01\
    \x12\x04\x97\x0f\x08\x0b\n\x0c\n\x04\x04^\x02\0\x12\x04\x98\x0f\x02H\n\r\
    \n\x05\x04^\x02\0\x04\x12\x04\x98\x0f\x02\n\n\r\n\x05\x04^\x02\0\x05\x12\
    \x04\x98\x0f\x0b\x10\n\r\n\x05\x04^\x02\0\x01\x12\x04\x98\x0f\x11\x14\n\
    \r\n\x05\x04^\x02\0\x03\x12\x04\x98\x0f\x17\x18\n\r\n\x05\x04^\x02\0\x08\
    \x12\x04\x98\x0f\x19G\n\x10\n\x08\x04^\x02\0\x08\xd0\x86\x03\x12\x04\x98\
    \x0f\x1aF\n\x0c\n\x04\x04^\x02\x01\x12\x04\x99\x0f\x02H\n\r\n\x05\x04^\
    \x02\x01\x04\x12\x04\x99\x0f\x02\n\n\r\n\x05\x04^\x02\x01\x05\x12\x04\
    \x99\x0f\x0b\x10\n\r\n\x05\x04^\x02\x01\x01\x12\x04\x99\x0f\x11\x14\n\r\
    \n\x05\x04^\x02\x01\x03\x12\x04\x99\x0f\x17\x18\n\r\n\x05\x04^\x02\x01\
    \x08\x12\x04\x99\x0f\x19G\n\x10\n\x08\x04^\x02\x01\x08\xd0\x86\x03\x12\
    \x04\x99\x0f\x1aF\n\x0c\n\x04\x04^\x02\x02\x12\x04\x9a\x0f\x02O\n\r\n\
    \x05\x04^\x02\x02\x04\x12\x04\x9a\x0f\x02\n\n\r\n\x05\x04^\x02\x02\x05\
    \x12\x04\x9a\x0f\x0b\x10\n\r\n\x05\x04^\x02\x02\x01\x12\x04\x9a\x0f\x11\
    \x1b\n\r\n\x05\x04^\x02\x02\x03\x12\x04\x9a\x0f\x1e\x1f\n\r\n\x05\x04^\
    \x02\x02\x08\x12\x04\x9a\x0f\x20N\n\x10\n\x08\x04^\x02\x02\x08\xd0\x86\
    \x03\x12\x04\x9a\x0f!M\n\x0c\n\x04\x04^\x02\x03\x12\x04\x9b\x0f\x02#\n\r\
    \n\x05\x04^\x02\x03\x04\x12\x04\x9b\x0f\x02\n\n\r\n\x05\x04^\x02\x03\x05\
    \x12\x04\x9b\x0f\x0b\x10\n\r\n\x05\x04^\x02\x03\x01\x12\x04\x9b\x0f\x11\
    \x1e\n\r\n\x05\x04^\x02\x03\x03\x12\x04\x9b\x0f!\"\n\x0c\n\x04\x04^\x02\
    \x04\x12\x04\x9c\x0f\x02$\n\r\n\x05\x04^\x02\x04\x04\x12\x04\x9c\x0f\x02\
    \n\n\r\n\x05\x04^\x02\x04\x05\x12\x04\x9c\x0f\x0b\x10\n\r\n\x05\x04^\x02\
    \x04\x01\x12\x04\x9c\x0f\x11\x1f\n\r\n\x05\x04^\x02\x04\x03\x12\x04\x9c\
    \x0f\"#\n$\n\x02\x04_\x12\x06\xa0\x0f\0\xa4\x0f\x01\x1a\x16\x20Precision\
    RecallCurve\n\n\x0b\n\x03\x04_\x01\x12\x04\xa0\x0f\x08\x1c\n\x0c\n\x04\
    \x04_\x02\0\x12\x04\xa1\x0f\x02K\n\r\n\x05\x04_\x02\0\x04\x12\x04\xa1\
    \x0f\x02\n\n\r\n\x05\x04_\x02\0\x05\x12\x04\xa1\x0f\x0b\x10\n\r\n\x05\
    \x04_\x02\0\x01\x12\x04\xa1\x0f\x11\x17\n\r\n\x05\x04_\x02\0\x03\x12\x04\
    \xa1\x0f\x1a\x1b\n\r\n\x05\x04_\x02\0\x08\x12\x04\xa1\x0f\x1cJ\n\x10\n\
    \x08\x04_\x02\0\x08\xd0\x86\x03\x12\x04\xa1\x0f\x1dI\n\x0c\n\x04\x04_\
    \x02\x01\x12\x04\xa2\x0f\x02N\n\r\n\x05\x04_\x02\x01\x04\x12\x04\xa2\x0f\
    \x02\n\n\r\n\x05\x04_\x02\x01\x05\x12\x04\xa2\x0f\x0b\x10\n\r\n\x05\x04_\
    \x02\x01\x01\x12\x04\xa2\x0f\x11\x1a\n\r\n\x05\x04_\x02\x01\x03\x12\x04\
    \xa2\x0f\x1d\x1e\n\r\n\x05\x04_\x02\x01\x08\x12\x04\xa2\x0f\x1fM\n\x10\n\
    \x08\x04_\x02\x01\x08\xd0\x86\x03\x12\x04\xa2\x0f\x20L\n\x0c\n\x04\x04_\
    \x02\x02\x12\x04\xa3\x0f\x02O\n\r\n\x05\x04_\x02\x02\x04\x12\x04\xa3\x0f\
    \x02\n\n\r\n\x05\x04_\x02\x02\x05\x12\x04\xa3\x0f\x0b\x10\n\r\n\x05\x04_\
    \x02\x02\x01\x12\x04\xa3\x0f\x11\x1b\n\r\n\x05\x04_\x02\x02\x03\x12\x04\
    \xa3\x0f\x1e\x1f\n\r\n\x05\x04_\x02\x02\x08\x12\x04\xa3\x0f\x20N\n\x10\n\
    \x08\x04_\x02\x02\x08\xd0\x86\x03\x12\x04\xa3\x0f!M\n\x1d\n\x02\x04`\x12\
    \x06\xa7\x0f\0\xb5\x0f\x01\x1a\x0f\x20BinaryMetrics\n\n\x0b\n\x03\x04`\
    \x01\x12\x04\xa7\x0f\x08\x15\n\x0c\n\x04\x04`\x02\0\x12\x04\xa8\x0f\x02D\
    \n\r\n\x05\x04`\x02\0\x05\x12\x04\xa8\x0f\x02\x08\n\r\n\x05\x04`\x02\0\
    \x01\x12\x04\xa8\x0f\t\x10\n\r\n\x05\x04`\x02\0\x03\x12\x04\xa8\x0f\x13\
    \x14\n\r\n\x05\x04`\x02\0\x08\x12\x04\xa8\x0f\x15C\n\x10\n\x08\x04`\x02\
    \0\x08\xd0\x86\x03\x12\x04\xa8\x0f\x16B\n\x0c\n\x04\x04`\x02\x01\x12\x04\
    \xa9\x0f\x02D\n\r\n\x05\x04`\x02\x01\x05\x12\x04\xa9\x0f\x02\x08\n\r\n\
    \x05\x04`\x02\x01\x01\x12\x04\xa9\x0f\t\x10\n\r\n\x05\x04`\x02\x01\x03\
    \x12\x04\xa9\x0f\x13\x14\n\r\n\x05\x04`\x02\x01\x08\x12\x04\xa9\x0f\x15C\
    \n\x10\n\x08\x04`\x02\x01\x08\xd0\x86\x03\x12\x04\xa9\x0f\x16B\n\x0c\n\
    \x04\x04`\x02\x02\x12\x04\xaa\x0f\x02D\n\r\n\x05\x04`\x02\x02\x05\x12\
    \x04\xaa\x0f\x02\x08\n\r\n\x05\x04`\x02\x02\x01\x12\x04\xaa\x0f\t\x10\n\
    \r\n\x05\x04`\x02\x02\x03\x12\x04\xaa\x0f\x13\x14\n\r\n\x05\x04`\x02\x02\
    \x08\x12\x04\xaa\x0f\x15C\n\x10\n\x08\x04`\x02\x02\x08\xd0\x86\x03\x12\
    \x04\xaa\x0f\x16B\n\x0c\n\x04\x04`\x02\x03\x12\x04\xab\x0f\x02C\n\r\n\
    \x05\x04`\x02\x03\x05\x12\x04\xab\x0f\x02\x07\n\r\n\x05\x04`\x02\x03\x01\
    \x12\x04\xab\x0f\x08\x0f\n\r\n\x05\x04`\x02\x03\x03\x12\x04\xab\x0f\x12\
    \x13\n\r\n\x05\x04`\x02\x03\x08\x12\x04\xab\x0f\x14B\n\x10\n\x08\x04`\
    \x02\x03\x08\xd0\x86\x03\x12\x04\xab\x0f\x15A\n\x0c\n\x04\x04`\x02\x04\
    \x12\x04\xac\x0f\x02>\n\r\n\x05\x04`\x02\x04\x05\x12\x04\xac\x0f\x02\x07\
    \n\r\n\x05\x04`\x02\x04\x01\x12\x04\xac\x0f\x08\n\n\r\n\x05\x04`\x02\x04\
    \x03\x12\x04\xac\x0f\r\x0e\n\r\n\x05\x04`\x02\x04\x08\x12\x04\xac\x0f\
    \x0f=\n\x10\n\x08\x04`\x02\x04\x08\xd0\x86\x03\x12\x04\xac\x0f\x10<\n\
    \x0c\n\x04\x04`\x02\x05\x12\x04\xad\x0f\x02\x16\n\r\n\x05\x04`\x02\x05\
    \x06\x12\x04\xad\x0f\x02\t\n\r\n\x05\x04`\x02\x05\x01\x12\x04\xad\x0f\n\
    \x11\n\r\n\x05\x04`\x02\x05\x03\x12\x04\xad\x0f\x14\x15\n\x0c\n\x04\x04`\
    \x02\x06\x12\x04\xae\x0f\x02\x14\n\r\n\x05\x04`\x02\x06\x06\x12\x04\xae\
    \x0f\x02\x05\n\r\n\x05\x04`\x02\x06\x01\x12\x04\xae\x0f\x06\x0f\n\r\n\
    \x05\x04`\x02\x06\x03\x12\x04\xae\x0f\x12\x13\n\x0c\n\x04\x04`\x02\x07\
    \x12\x04\xaf\x0f\x022\n\r\n\x05\x04`\x02\x07\x06\x12\x04\xaf\x0f\x02\x16\
    \n\r\n\x05\x04`\x02\x07\x01\x12\x04\xaf\x0f\x17-\n\r\n\x05\x04`\x02\x07\
    \x03\x12\x04\xaf\x0f01\n\x0c\n\x04\x04`\x02\x08\x12\x04\xb0\x0f\x02\x1a\
    \n\r\n\x05\x04`\x02\x08\x05\x12\x04\xb0\x0f\x02\x07\n\r\n\x05\x04`\x02\
    \x08\x01\x12\x04\xb0\x0f\x08\x15\n\r\n\x05\x04`\x02\x08\x03\x12\x04\xb0\
    \x0f\x18\x19\n\x0c\n\x04\x04`\x02\t\x12\x04\xb1\x0f\x02\x18\n\r\n\x05\
    \x04`\x02\t\x05\x12\x04\xb1\x0f\x02\x08\n\r\n\x05\x04`\x02\t\x01\x12\x04\
    \xb1\x0f\t\x12\n\r\n\x05\x04`\x02\t\x03\x12\x04\xb1\x0f\x15\x17\n\x0c\n\
    \x04\x04`\x02\n\x12\x04\xb2\x0f\x02\x17\n\r\n\x05\x04`\x02\n\x05\x12\x04\
    \xb2\x0f\x02\x08\n\r\n\x05\x04`\x02\n\x01\x12\x04\xb2\x0f\t\x11\n\r\n\
    \x05\x04`\x02\n\x03\x12\x04\xb2\x0f\x14\x16\n\x0c\n\x04\x04`\x02\x0b\x12\
    \x04\xb3\x0f\x02\x17\n\r\n\x05\x04`\x02\x0b\x05\x12\x04\xb3\x0f\x02\x08\
    \n\r\n\x05\x04`\x02\x0b\x01\x12\x04\xb3\x0f\t\x11\n\r\n\x05\x04`\x02\x0b\
    \x03\x12\x04\xb3\x0f\x14\x16\n\x0c\n\x04\x04`\x02\x0c\x12\x04\xb4\x0f\
    \x02\x11\n\r\n\x05\x04`\x02\x0c\x05\x12\x04\xb4\x0f\x02\x07\n\r\n\x05\
    \x04`\x02\x0c\x01\x12\x04\xb4\x0f\x08\x0b\n\r\n\x05\x04`\x02\x0c\x03\x12\
    \x04\xb4\x0f\x0e\x10\n\x1e\n\x02\x04a\x12\x06\xb8\x0f\0\xc5\x0f\x01\x1a\
    \x10\x20TrackerMetrics\n\n\x0b\n\x03\x04a\x01\x12\x04\xb8\x0f\x08\x16\n1\
    \n\x04\x04a\x02\0\x12\x04\xba\x0f\x02\x15\x1a#\x20Multiple\x20object\x20\
    tracking\x20accuracy\n\n\r\n\x05\x04a\x02\0\x05\x12\x04\xba\x0f\x02\x07\
    \n\r\n\x05\x04a\x02\0\x01\x12\x04\xba\x0f\x08\x10\n\r\n\x05\x04a\x02\0\
    \x03\x12\x04\xba\x0f\x13\x14\n1\n\x04\x04a\x02\x01\x12\x04\xbc\x0f\x02\
    \x1d\x1a#\x20Number\x20of\x20switches\x20between\x20tracks\n\n\r\n\x05\
    \x04a\x02\x01\x05\x12\x04\xbc\x0f\x02\x07\n\r\n\x05\x04a\x02\x01\x01\x12\
    \x04\xbc\x0f\x08\x18\n\r\n\x05\x04a\x02\x01\x03\x12\x04\xbc\x0f\x1b\x1c\
    \ne\n\x04\x04a\x02\x02\x12\x04\xbe\x0f\x02\x17\x1aW\x20MORSE\x20fragment\
    ation\x20rate\x20(a.k.a\x20unique\x20switch\x20rate,\x20only\x20calculat\
    ed\x20in\x20public\x20sector)\n\n\r\n\x05\x04a\x02\x02\x05\x12\x04\xbe\
    \x0f\x02\x07\n\r\n\x05\x04a\x02\x02\x01\x12\x04\xbe\x0f\x08\x12\n\r\n\
    \x05\x04a\x02\x02\x03\x12\x04\xbe\x0f\x15\x16\nF\n\x04\x04a\x02\x03\x12\
    \x04\xc0\x0f\x02\x1a\x1a8\x20Average\x20precision\x20calculated\x20from\
    \x20all\x20processed\x20frames\n\n\r\n\x05\x04a\x02\x03\x05\x12\x04\xc0\
    \x0f\x02\x07\n\r\n\x05\x04a\x02\x03\x01\x12\x04\xc0\x0f\x08\x15\n\r\n\
    \x05\x04a\x02\x03\x03\x12\x04\xc0\x0f\x18\x19\n>\n\x04\x04a\x02\x04\x12\
    \x04\xc2\x0f\x02\x12\x1a0\x20The\x20concept\x20that\x20we\x20are\x20eval\
    uating\x20the\x20tracker\n\n\r\n\x05\x04a\x02\x04\x05\x12\x04\xc2\x0f\
    \x02\x08\n\r\n\x05\x04a\x02\x04\x01\x12\x04\xc2\x0f\t\r\n\r\n\x05\x04a\
    \x02\x04\x03\x12\x04\xc2\x0f\x10\x11\nK\n\x04\x04a\x02\x05\x12\x04\xc4\
    \x0f\x02\x1f\x1a=\x20Same\x20as\x20morse_frag\x20but\x20calculated\x20us\
    ing\x20MOT\x20mapping/metrics\n\n\r\n\x05\x04a\x02\x05\x05\x12\x04\xc4\
    \x0f\x02\x07\n\r\n\x05\x04a\x02\x05\x01\x12\x04\xc4\x0f\x08\x1a\n\r\n\
    \x05\x04a\x02\x05\x03\x12\x04\xc4\x0f\x1d\x1e\n\x20\n\x02\x04b\x12\x06\
    \xc8\x0f\0\xd7\x0f\x01\x1a\x12\x20EvalTestSetEntry\n\n\x0b\n\x03\x04b\
    \x01\x12\x04\xc8\x0f\x08\x18\n\x0b\n\x03\x04b\t\x12\x04\xc9\x0f\x02\x10\
    \n\x0c\n\x04\x04b\t\0\x12\x04\xc9\x0f\x0b\x0c\n\r\n\x05\x04b\t\0\x01\x12\
    \x04\xc9\x0f\x0b\x0c\n\r\n\x05\x04b\t\0\x02\x12\x04\xc9\x0f\x0b\x0c\n\
    \x0c\n\x04\x04b\t\x01\x12\x04\xc9\x0f\x0e\x0f\n\r\n\x05\x04b\t\x01\x01\
    \x12\x04\xc9\x0f\x0e\x0f\n\r\n\x05\x04b\t\x01\x02\x12\x04\xc9\x0f\x0e\
    \x0f\n%\n\x04\x04b\x02\0\x12\x04\xca\x0f\x02\x12\"\x17\x20the\x20input\
    \x20information\n\n\r\n\x05\x04b\x02\0\x06\x12\x04\xca\x0f\x02\x07\n\r\n\
    \x05\x04b\x02\0\x01\x12\x04\xca\x0f\x08\r\n\r\n\x05\x04b\x02\0\x03\x12\
    \x04\xca\x0f\x10\x11\n\x0c\n\x04\x04b\x02\x01\x12\x04\xcc\x0f\x02*\n\r\n\
    \x05\x04b\x02\x01\x04\x12\x04\xcc\x0f\x02\n\n\r\n\x05\x04b\x02\x01\x06\
    \x12\x04\xcc\x0f\x0b\x12\n\r\n\x05\x04b\x02\x01\x01\x12\x04\xcc\x0f\x13%\
    \n\r\n\x05\x04b\x02\x01\x03\x12\x04\xcc\x0f()\nK\n\x04\x04b\x02\x02\x12\
    \x04\xce\x0f\x02-\x1a=\x20All\x20the\x20ground\x20truth\x20concepts\x20w\
    ill\x20be\x20show\x20on\x20the\x20top\x20level\n\n\r\n\x05\x04b\x02\x02\
    \x04\x12\x04\xce\x0f\x02\n\n\r\n\x05\x04b\x02\x02\x06\x12\x04\xce\x0f\
    \x0b\x12\n\r\n\x05\x04b\x02\x02\x01\x12\x04\xce\x0f\x13(\n\r\n\x05\x04b\
    \x02\x02\x03\x12\x04\xce\x0f+,\n\xbe\x01\n\x04\x04b\x02\x03\x12\x04\xd2\
    \x0f\x020\x1a\xaf\x01\x20Only\x20region-based/frame-based\x20app\x20cont\
    ains\x20this\x20annotation\n\x20Each\x20annotation\x20only\x20contains\
    \x20one\x20region\n\x20And\x20the\x20concepts\x20is\x20in\x20ground_trut\
    h_concepts\x20instead\x20of\x20this\x20annotation\n\n\r\n\x05\x04b\x02\
    \x03\x06\x12\x04\xd2\x0f\x02\x0c\n\r\n\x05\x04b\x02\x03\x01\x12\x04\xd2\
    \x0f\r\x17\n\r\n\x05\x04b\x02\x03\x03\x12\x04\xd2\x0f\x1a\x1b\n\r\n\x05\
    \x04b\x02\x03\x08\x12\x04\xd2\x0f\x1c/\n\x0e\n\x06\x04b\x02\x03\x08\x03\
    \x12\x04\xd2\x0f\x1d.\n\\\n\x04\x04b\x02\x04\x12\x04\xd5\x0f\x02&\x1aN\
    \x20For\x20region\x20based\x20models,\x20region\x20and\x20associated\x20\
    concepts\x20are\x20stored\x20together.\n\n\r\n\x05\x04b\x02\x04\x06\x12\
    \x04\xd5\x0f\x02\x0c\n\r\n\x05\x04b\x02\x04\x01\x12\x04\xd5\x0f\r!\n\r\n\
    \x05\x04b\x02\x04\x03\x12\x04\xd5\x0f$%\n\x0c\n\x04\x04b\x02\x05\x12\x04\
    \xd6\x0f\x02)\n\r\n\x05\x04b\x02\x05\x06\x12\x04\xd6\x0f\x02\x0c\n\r\n\
    \x05\x04b\x02\x05\x01\x12\x04\xd6\x0f\r$\n\r\n\x05\x04b\x02\x05\x03\x12\
    \x04\xd6\x0f'(\n\x1e\n\x02\x04c\x12\x06\xda\x0f\0\xfc\x0f\x01\x1a\x10\
    \x20LOPQEvalResult\n\n\x0b\n\x03\x04c\x01\x12\x04\xda\x0f\x08\x16\n:\n\
    \x04\x04c\x02\0\x12\x04\xdc\x0f\x02\x0e\x1a,\x20Rank\x20k\x20for\x20whic\
    h\x20all\x20metrics\x20are\x20reported.\n\n\r\n\x05\x04c\x02\0\x05\x12\
    \x04\xdc\x0f\x02\x07\n\r\n\x05\x04c\x02\0\x01\x12\x04\xdc\x0f\x08\t\n\r\
    \n\x05\x04c\x02\0\x03\x12\x04\xdc\x0f\x0c\r\nO\n\x04\x04c\x02\x01\x12\
    \x04\xdf\x0f\x02Q\x1aA\x20Recall\x20@\x20k\x20assuming\x20the\x20brute\
    \x20force\x20search\x20is\x20the\x20ground\x20truth.\n\n\r\n\x05\x04c\
    \x02\x01\x05\x12\x04\xdf\x0f\x02\x07\n\r\n\x05\x04c\x02\x01\x01\x12\x04\
    \xdf\x0f\x08\x1d\n\r\n\x05\x04c\x02\x01\x03\x12\x04\xdf\x0f\x20!\n\r\n\
    \x05\x04c\x02\x01\x08\x12\x04\xdf\x0f\"P\n\x10\n\x08\x04c\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xdf\x0f#O\nb\n\x04\x04c\x02\x02\x12\x04\xe1\x0f\x02\
    V\x1aT\x20Kendall's\x20tau\x20correlation\x20@\x20k\x20assuming\x20the\
    \x20brute\x20force\x20search\x20is\x20the\x20ground\x20truth.\n\n\r\n\
    \x05\x04c\x02\x02\x05\x12\x04\xe1\x0f\x02\x07\n\r\n\x05\x04c\x02\x02\x01\
    \x12\x04\xe1\x0f\x08\"\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xe1\x0f%&\n\r\
    \n\x05\x04c\x02\x02\x08\x12\x04\xe1\x0f'U\n\x10\n\x08\x04c\x02\x02\x08\
    \xd0\x86\x03\x12\x04\xe1\x0f(T\n`\n\x04\x04c\x02\x03\x12\x04\xe3\x0f\x02\
    V\x1aR\x20The\x20percentage\x20of\x20the\x20most\x20frequent\x20code\x20\
    in\x20the\x20indexed\x20part\x20of\x20evaluation\x20data.\n\n\r\n\x05\
    \x04c\x02\x03\x05\x12\x04\xe3\x0f\x02\x07\n\r\n\x05\x04c\x02\x03\x01\x12\
    \x04\xe3\x0f\x08\"\n\r\n\x05\x04c\x02\x03\x03\x12\x04\xe3\x0f%&\n\r\n\
    \x05\x04c\x02\x03\x08\x12\x04\xe3\x0f'U\n\x10\n\x08\x04c\x02\x03\x08\xd0\
    \x86\x03\x12\x04\xe3\x0f(T\n\xa5\x0b\n\x04\x04c\x02\x04\x12\x04\xf8\x0f\
    \x02E\x1a\x96\x0b\x20Normalized\x20Discounted\x20Cumulative\x20Gain\x20(\
    NDCG)\x20@\x20k\x20with\x20a\x20ground\x20truth\x20inferred\x20from\x20a\
    nnotations\n\x20and/or\x20prediction\x20for\x20this\x20evaluation\x20LOP\
    Q\x20model.\n\x20NDCG\x20uses\x20individual\x20relevance\x20scores\x20of\
    \x20each\x20returned\x20image\x20to\x20evaluate\x20the\x20usefulness,\
    \x20or\n\x20gain,\x20of\x20a\x20document\x20based\x20on\x20its\x20positi\
    on\x20in\x20the\x20result\x20list.\x20The\x20premise\x20of\x20DCG\x20is\
    \x20that\n\x20highly\x20relevant\x20documents\x20appearing\x20lower\x20i\
    n\x20a\x20search\x20result\x20list\x20should\x20be\x20penalized\x20as\
    \x20the\n\x20graded\x20relevance\x20value\x20is\x20reduced\x20logarithmi\
    cally\x20proportional\x20to\x20the\x20position\x20of\x20the\x20result.\n\
    \x20See:\x20https://en.wikipedia.org/wiki/Information_retrieval#Discount\
    ed_cumulative_gain\n\n\x20To\x20compute\x20the\x20relevance\x20score\x20\
    between\x20two\x20images\x20we\x20consider\x20two\x20cases:\n\x201)\x20O\
    nly\x20one\x20label\x20for\x20each\x20image\n\x20An\x20image\x20is\x20re\
    levant\x20to\x20an\x20image\x20query\x20iff\x20they\x20are\x20labeled\
    \x20the\x20same\x20(score\x201),\x20and\n\x20not\x20relevant\x20otherwis\
    e\x20(score\x200)\n\x202)\x20Multiple\x20labels\x20for\x20each\x20image\
    \n\x20Here\x20an\x20image\x20relevancy\x20with\x20respect\x20to\x20a\x20\
    single\x20image\x20query\x20is\x20measured\x20by\x20f-beta\x20score\n\
    \x20assuming\x20the\x20query\x20image\x20list\x20of\x20labels\x20as\x20g\
    round\x20truth\x20and\x20comparing\x20them\x20with\x20that\x20of\n\x20th\
    e\x20search\x20result.\x20These\x20labels\x20can\x20come\x20from\x20imag\
    e\x20annotations\x20or\x20if\x20substitute_annotation_misses\n\x20is\x20\
    set,\x20predictions\x20of\x20base\x20classifier\x20where\x20any\x20predi\
    ction\x20with\x20prob\x20<\x20prob_threshold\x20are\n\x20discarded.\x20T\
    o\x20quantify\x20the\x20relevancy\x20score\x20of\x20a\x20single\x20searc\
    h\x20result\x20we\x20opt\x20to\x20compute\x20precision\n\x20and\x20recal\
    l\x20@\x20k\x20for\x20simplicity,\x20and\x20combine\x20them\x20with\x20f\
    -beta\x20score\x20to\x20obtain\x20a\x20single\x20number.\n\n\r\n\x05\x04\
    c\x02\x04\x05\x12\x04\xf8\x0f\x02\x07\n\r\n\x05\x04c\x02\x04\x01\x12\x04\
    \xf8\x0f\x08\x11\n\r\n\x05\x04c\x02\x04\x03\x12\x04\xf8\x0f\x14\x15\n\r\
    \n\x05\x04c\x02\x04\x08\x12\x04\xf8\x0f\x16D\n\x10\n\x08\x04c\x02\x04\
    \x08\xd0\x86\x03\x12\x04\xf8\x0f\x17C\nw\n\x04\x04c\x02\x05\x12\x04\xfb\
    \x0f\x02L\x1ai\x20Brute\x20force\x20NDCG\x20which\x20gives\x20a\x20basel\
    ine\x20to\x20compare\x20to\x20and\x20is\x20a\x20measure\x20of\x20how\x20\
    good\n\x20the\x20embeddings\x20are.\n\n\r\n\x05\x04c\x02\x05\x05\x12\x04\
    \xfb\x0f\x02\x07\n\r\n\x05\x04c\x02\x05\x01\x12\x04\xfb\x0f\x08\x18\n\r\
    \n\x05\x04c\x02\x05\x03\x12\x04\xfb\x0f\x1b\x1c\n\r\n\x05\x04c\x02\x05\
    \x08\x12\x04\xfb\x0f\x1dK\n\x10\n\x08\x04c\x02\x05\x08\xd0\x86\x03\x12\
    \x04\xfb\x0f\x1eJ\n\x1e\n\x02\x04d\x12\x06\xff\x0f\0\x8c\x10\x01\x1a\x10\
    \x20MetricsSummary\n\n\x0b\n\x03\x04d\x01\x12\x04\xff\x0f\x08\x16\n\x0c\
    \n\x04\x04d\x02\0\x12\x04\x80\x10\x02.\n\r\n\x05\x04d\x02\0\x05\x12\x04\
    \x80\x10\x02\x07\n\r\n\x05\x04d\x02\0\x01\x12\x04\x80\x10\x08\x15\n\r\n\
    \x05\x04d\x02\0\x03\x12\x04\x80\x10\x18\x19\n\r\n\x05\x04d\x02\0\x08\x12\
    \x04\x80\x10\x1a-\n\x0e\n\x06\x04d\x02\0\x08\x03\x12\x04\x80\x10\x1b,\n\
    \x0c\n\x04\x04d\x02\x01\x12\x04\x81\x10\x02.\n\r\n\x05\x04d\x02\x01\x05\
    \x12\x04\x81\x10\x02\x07\n\r\n\x05\x04d\x02\x01\x01\x12\x04\x81\x10\x08\
    \x15\n\r\n\x05\x04d\x02\x01\x03\x12\x04\x81\x10\x18\x19\n\r\n\x05\x04d\
    \x02\x01\x08\x12\x04\x81\x10\x1a-\n\x0e\n\x06\x04d\x02\x01\x08\x03\x12\
    \x04\x81\x10\x1b,\n\x0c\n\x04\x04d\x02\x02\x12\x04\x82\x10\x02M\n\r\n\
    \x05\x04d\x02\x02\x05\x12\x04\x82\x10\x02\x07\n\r\n\x05\x04d\x02\x02\x01\
    \x12\x04\x82\x10\x08\x19\n\r\n\x05\x04d\x02\x02\x03\x12\x04\x82\x10\x1c\
    \x1d\n\r\n\x05\x04d\x02\x02\x08\x12\x04\x82\x10\x1eL\n\x10\n\x08\x04d\
    \x02\x02\x08\xd0\x86\x03\x12\x04\x82\x10\x1fK\n\x0c\n\x04\x04d\x02\x03\
    \x12\x04\x83\x10\x02M\n\r\n\x05\x04d\x02\x03\x05\x12\x04\x83\x10\x02\x07\
    \n\r\n\x05\x04d\x02\x03\x01\x12\x04\x83\x10\x08\x19\n\r\n\x05\x04d\x02\
    \x03\x03\x12\x04\x83\x10\x1c\x1d\n\r\n\x05\x04d\x02\x03\x08\x12\x04\x83\
    \x10\x1eL\n\x10\n\x08\x04d\x02\x03\x08\xd0\x86\x03\x12\x04\x83\x10\x1fK\
    \n\x0c\n\x04\x04d\x02\x04\x12\x04\x84\x10\x02N\n\r\n\x05\x04d\x02\x04\
    \x05\x12\x04\x84\x10\x02\x07\n\r\n\x05\x04d\x02\x04\x01\x12\x04\x84\x10\
    \x08\x1a\n\r\n\x05\x04d\x02\x04\x03\x12\x04\x84\x10\x1d\x1e\n\r\n\x05\
    \x04d\x02\x04\x08\x12\x04\x84\x10\x1fM\n\x10\n\x08\x04d\x02\x04\x08\xd0\
    \x86\x03\x12\x04\x84\x10\x20L\n\x0c\n\x04\x04d\x02\x05\x12\x04\x85\x10\
    \x02N\n\r\n\x05\x04d\x02\x05\x05\x12\x04\x85\x10\x02\x07\n\r\n\x05\x04d\
    \x02\x05\x01\x12\x04\x85\x10\x08\x1a\n\r\n\x05\x04d\x02\x05\x03\x12\x04\
    \x85\x10\x1d\x1e\n\r\n\x05\x04d\x02\x05\x08\x12\x04\x85\x10\x1fM\n\x10\n\
    \x08\x04d\x02\x05\x08\xd0\x86\x03\x12\x04\x85\x10\x20L\n\x0c\n\x04\x04d\
    \x02\x06\x12\x04\x86\x10\x02O\n\r\n\x05\x04d\x02\x06\x05\x12\x04\x86\x10\
    \x02\x07\n\r\n\x05\x04d\x02\x06\x01\x12\x04\x86\x10\x08\x1b\n\r\n\x05\
    \x04d\x02\x06\x03\x12\x04\x86\x10\x1e\x1f\n\r\n\x05\x04d\x02\x06\x08\x12\
    \x04\x86\x10\x20N\n\x10\n\x08\x04d\x02\x06\x08\xd0\x86\x03\x12\x04\x86\
    \x10!M\n\x0c\n\x04\x04d\x02\x07\x12\x04\x87\x10\x02L\n\r\n\x05\x04d\x02\
    \x07\x05\x12\x04\x87\x10\x02\x07\n\r\n\x05\x04d\x02\x07\x01\x12\x04\x87\
    \x10\x08\x18\n\r\n\x05\x04d\x02\x07\x03\x12\x04\x87\x10\x1b\x1c\n\r\n\
    \x05\x04d\x02\x07\x08\x12\x04\x87\x10\x1dK\n\x10\n\x08\x04d\x02\x07\x08\
    \xd0\x86\x03\x12\x04\x87\x10\x1eJ\n\x0c\n\x04\x04d\x02\x08\x12\x04\x88\
    \x10\x02'\n\r\n\x05\x04d\x02\x08\x05\x12\x04\x88\x10\x02\x07\n\r\n\x05\
    \x04d\x02\x08\x01\x12\x04\x88\x10\x08!\n\r\n\x05\x04d\x02\x08\x03\x12\
    \x04\x88\x10$&\n\x0c\n\x04\x04d\x02\t\x12\x04\x89\x10\x02*\n\r\n\x05\x04\
    d\x02\t\x05\x12\x04\x89\x10\x02\x07\n\r\n\x05\x04d\x02\t\x01\x12\x04\x89\
    \x10\x08$\n\r\n\x05\x04d\x02\t\x03\x12\x04\x89\x10')\n\x0c\n\x04\x04d\
    \x02\n\x12\x04\x8b\x10\x02+\n\r\n\x05\x04d\x02\n\x04\x12\x04\x8b\x10\x02\
    \n\n\r\n\x05\x04d\x02\n\x06\x12\x04\x8b\x10\x0b\x19\n\r\n\x05\x04d\x02\n\
    \x01\x12\x04\x8b\x10\x1a&\n\r\n\x05\x04d\x02\n\x03\x12\x04\x8b\x10)*\n\
    \x1b\n\x02\x04e\x12\x06\x8f\x10\0\xac\x10\x01\x1a\r\x20EvalMetrics\n\n\
    \x0b\n\x03\x04e\x01\x12\x04\x8f\x10\x08\x13\n\x0c\n\x04\x04e\x02\0\x12\
    \x04\x90\x10\x02(\n\r\n\x05\x04e\x02\0\x06\x12\x04\x90\x10\x02\x1c\n\r\n\
    \x05\x04e\x02\0\x01\x12\x04\x90\x10\x1d#\n\r\n\x05\x04e\x02\0\x03\x12\
    \x04\x90\x10&'\n1\n\x04\x04e\x02\x01\x12\x04\x92\x10\x02\x16\x1a#\x20use\
    r\x20id\x20that\x20owns\x20this\x20evaluation\n\n\r\n\x05\x04e\x02\x01\
    \x05\x12\x04\x92\x10\x02\x08\n\r\n\x05\x04e\x02\x01\x01\x12\x04\x92\x10\
    \t\x10\n\r\n\x05\x04e\x02\x01\x03\x12\x04\x92\x10\x13\x15\n0\n\x04\x04e\
    \x02\x02\x12\x04\x94\x10\x02\x15\x1a\"\x20app\x20id\x20that\x20owns\x20t\
    his\x20evaluation\n\n\r\n\x05\x04e\x02\x02\x05\x12\x04\x94\x10\x02\x08\n\
    \r\n\x05\x04e\x02\x02\x01\x12\x04\x94\x10\t\x0f\n\r\n\x05\x04e\x02\x02\
    \x03\x12\x04\x94\x10\x12\x14\n%\n\x04\x04e\x02\x03\x12\x04\x96\x10\x02\
    \x11\x1a\x17\x20Id\x20of\x20this\x20evaluation\n\n\r\n\x05\x04e\x02\x03\
    \x05\x12\x04\x96\x10\x02\x08\n\r\n\x05\x04e\x02\x03\x01\x12\x04\x96\x10\
    \t\x0b\n\r\n\x05\x04e\x02\x03\x03\x12\x04\x96\x10\x0e\x10\n!\n\x04\x04e\
    \x02\x04\x12\x04\x98\x10\x02\x13\x1a\x13\x20Model\x20to\x20evaluate\n\n\
    \r\n\x05\x04e\x02\x04\x06\x12\x04\x98\x10\x02\x07\n\r\n\x05\x04e\x02\x04\
    \x01\x12\x04\x98\x10\x08\r\n\r\n\x05\x04e\x02\x04\x03\x12\x04\x98\x10\
    \x10\x12\n(\n\x04\x04e\x02\x05\x12\x04\x9a\x10\x02$\x1a\x1a\x20The\x20gr\
    ound\x20truth\x20dataset\n\n\r\n\x05\x04e\x02\x05\x06\x12\x04\x9a\x10\
    \x02\t\n\r\n\x05\x04e\x02\x05\x01\x12\x04\x9a\x10\n\x1e\n\r\n\x05\x04e\
    \x02\x05\x03\x12\x04\x9a\x10!#\n,\n\x04\x04e\x02\x06\x12\x04\x9c\x10\x02\
    #\x1a\x1e\x20The\x20dataset\x20with\x20predictions\n\n\r\n\x05\x04e\x02\
    \x06\x06\x12\x04\x9c\x10\x02\t\n\r\n\x05\x04e\x02\x06\x01\x12\x04\x9c\
    \x10\n\x1d\n\r\n\x05\x04e\x02\x06\x03\x12\x04\x9c\x10\x20\"\n\x0c\n\x04\
    \x04e\x02\x07\x12\x04\x9e\x10\x02\x1d\n\r\n\x05\x04e\x02\x07\x06\x12\x04\
    \x9e\x10\x02\x10\n\r\n\x05\x04e\x02\x07\x01\x12\x04\x9e\x10\x11\x18\n\r\
    \n\x05\x04e\x02\x07\x03\x12\x04\x9e\x10\x1b\x1c\n\x0c\n\x04\x04e\x02\x08\
    \x12\x04\x9f\x10\x02'\n\r\n\x05\x04e\x02\x08\x06\x12\x04\x9f\x10\x02\x11\
    \n\r\n\x05\x04e\x02\x08\x01\x12\x04\x9f\x10\x12\"\n\r\n\x05\x04e\x02\x08\
    \x03\x12\x04\x9f\x10%&\n\x0c\n\x04\x04e\x02\t\x12\x04\xa0\x10\x02-\n\r\n\
    \x05\x04e\x02\t\x06\x12\x04\xa0\x10\x02\x14\n\r\n\x05\x04e\x02\t\x01\x12\
    \x04\xa0\x10\x15(\n\r\n\x05\x04e\x02\t\x03\x12\x04\xa0\x10+,\n\x0c\n\x04\
    \x04e\x02\n\x12\x04\xa1\x10\x02%\n\r\n\x05\x04e\x02\n\x06\x12\x04\xa1\
    \x10\x02\x13\n\r\n\x05\x04e\x02\n\x01\x12\x04\xa1\x10\x14\x20\n\r\n\x05\
    \x04e\x02\n\x03\x12\x04\xa1\x10#$\n\x0c\n\x04\x04e\x02\x0b\x12\x04\xa2\
    \x10\x02,\n\r\n\x05\x04e\x02\x0b\x04\x12\x04\xa2\x10\x02\n\n\r\n\x05\x04\
    e\x02\x0b\x06\x12\x04\xa2\x10\x0b\x18\n\r\n\x05\x04e\x02\x0b\x01\x12\x04\
    \xa2\x10\x19'\n\r\n\x05\x04e\x02\x0b\x03\x12\x04\xa2\x10*+\n\x0c\n\x04\
    \x04e\x02\x0c\x12\x04\xa3\x10\x02)\n\r\n\x05\x04e\x02\x0c\x04\x12\x04\
    \xa3\x10\x02\n\n\r\n\x05\x04e\x02\x0c\x06\x12\x04\xa3\x10\x0b\x1b\n\r\n\
    \x05\x04e\x02\x0c\x01\x12\x04\xa3\x10\x1c$\n\r\n\x05\x04e\x02\x0c\x03\
    \x12\x04\xa3\x10'(\n\x0c\n\x04\x04e\x02\r\x12\x04\xa4\x10\x02-\n\r\n\x05\
    \x04e\x02\r\x04\x12\x04\xa4\x10\x02\n\n\r\n\x05\x04e\x02\r\x06\x12\x04\
    \xa4\x10\x0b\x18\n\r\n\x05\x04e\x02\r\x01\x12\x04\xa4\x10\x19(\n\r\n\x05\
    \x04e\x02\r\x03\x12\x04\xa4\x10+,\n\x0c\n\x04\x04e\x02\x0e\x12\x04\xa5\
    \x10\x02.\n\r\n\x05\x04e\x02\x0e\x04\x12\x04\xa5\x10\x02\n\n\r\n\x05\x04\
    e\x02\x0e\x06\x12\x04\xa5\x10\x0b\x18\n\r\n\x05\x04e\x02\x0e\x01\x12\x04\
    \xa5\x10\x19)\n\r\n\x05\x04e\x02\x0e\x03\x12\x04\xa5\x10,-\n\x0c\n\x04\
    \x04e\x02\x0f\x12\x04\xa6\x10\x02/\n\r\n\x05\x04e\x02\x0f\x04\x12\x04\
    \xa6\x10\x02\n\n\r\n\x05\x04e\x02\x0f\x06\x12\x04\xa6\x10\x0b\x19\n\r\n\
    \x05\x04e\x02\x0f\x01\x12\x04\xa6\x10\x1a)\n\r\n\x05\x04e\x02\x0f\x03\
    \x12\x04\xa6\x10,.\n}\n\x04\x04e\x02\x10\x12\x04\xaa\x10\x02\x1a\x1ao\
    \x20Evaluation\x20parameters\x20to\x20pass.\x20Expected\x20to\x20match\
    \x20what\n\x20is\x20defined\x20in\x20the\x20model\x20type\x20for\x20the\
    \x20respective\x20model.\n\n\r\n\x05\x04e\x02\x10\x06\x12\x04\xaa\x10\
    \x02\n\n\r\n\x05\x04e\x02\x10\x01\x12\x04\xaa\x10\x0b\x14\n\r\n\x05\x04e\
    \x02\x10\x03\x12\x04\xaa\x10\x17\x19\n\x0c\n\x04\x04e\x02\x11\x12\x04\
    \xab\x10\x02(\n\r\n\x05\x04e\x02\x11\x06\x12\x04\xab\x10\x02\x11\n\r\n\
    \x05\x04e\x02\x11\x01\x12\x04\xab\x10\x12\"\n\r\n\x05\x04e\x02\x11\x03\
    \x12\x04\xab\x10%'\n\x0c\n\x02\x04f\x12\x06\xae\x10\0\xb0\x10\x01\n\x0b\
    \n\x03\x04f\x01\x12\x04\xae\x10\x08\x17\n\x0c\n\x04\x04f\x02\0\x12\x04\
    \xaf\x10\x02*\n\r\n\x05\x04f\x02\0\x06\x12\x04\xaf\x10\x02\x18\n\r\n\x05\
    \x04f\x02\0\x01\x12\x04\xaf\x10\x19%\n\r\n\x05\x04f\x02\0\x03\x12\x04\
    \xaf\x10()\n\x1b\n\x02\x04g\x12\x06\xb3\x10\0\xbb\x10\x01\x1a\r\x20Field\
    sValue\n\n\x0b\n\x03\x04g\x01\x12\x04\xb3\x10\x08\x13\n\x0c\n\x04\x04g\
    \x02\0\x12\x04\xb4\x10\x02\x1c\n\r\n\x05\x04g\x02\0\x05\x12\x04\xb4\x10\
    \x02\x06\n\r\n\x05\x04g\x02\0\x01\x12\x04\xb4\x10\x07\x17\n\r\n\x05\x04g\
    \x02\0\x03\x12\x04\xb4\x10\x1a\x1b\n\x0c\n\x04\x04g\x02\x01\x12\x04\xb5\
    \x10\x02\x1f\n\r\n\x05\x04g\x02\x01\x05\x12\x04\xb5\x10\x02\x06\n\r\n\
    \x05\x04g\x02\x01\x01\x12\x04\xb5\x10\x07\x1a\n\r\n\x05\x04g\x02\x01\x03\
    \x12\x04\xb5\x10\x1d\x1e\n\x0c\n\x04\x04g\x02\x02\x12\x04\xb6\x10\x02\
    \x18\n\r\n\x05\x04g\x02\x02\x05\x12\x04\xb6\x10\x02\x06\n\r\n\x05\x04g\
    \x02\x02\x01\x12\x04\xb6\x10\x07\x13\n\r\n\x05\x04g\x02\x02\x03\x12\x04\
    \xb6\x10\x16\x17\n\x0c\n\x04\x04g\x02\x03\x12\x04\xb7\x10\x02\x1a\n\r\n\
    \x05\x04g\x02\x03\x05\x12\x04\xb7\x10\x02\x06\n\r\n\x05\x04g\x02\x03\x01\
    \x12\x04\xb7\x10\x07\x15\n\r\n\x05\x04g\x02\x03\x03\x12\x04\xb7\x10\x18\
    \x19\n\x0c\n\x04\x04g\x02\x04\x12\x04\xb8\x10\x02\x14\n\r\n\x05\x04g\x02\
    \x04\x05\x12\x04\xb8\x10\x02\x06\n\r\n\x05\x04g\x02\x04\x01\x12\x04\xb8\
    \x10\x07\x0f\n\r\n\x05\x04g\x02\x04\x03\x12\x04\xb8\x10\x12\x13\n\x0c\n\
    \x04\x04g\x02\x05\x12\x04\xb9\x10\x02\x1b\n\r\n\x05\x04g\x02\x05\x05\x12\
    \x04\xb9\x10\x02\x06\n\r\n\x05\x04g\x02\x05\x01\x12\x04\xb9\x10\x07\x16\
    \n\r\n\x05\x04g\x02\x05\x03\x12\x04\xb9\x10\x19\x1a\n\x0c\n\x04\x04g\x02\
    \x06\x12\x04\xba\x10\x02\x1c\n\r\n\x05\x04g\x02\x06\x05\x12\x04\xba\x10\
    \x02\x06\n\r\n\x05\x04g\x02\x06\x01\x12\x04\xba\x10\x07\x17\n\r\n\x05\
    \x04g\x02\x06\x03\x12\x04\xba\x10\x1a\x1b\n\x16\n\x02\x04h\x12\x06\xbe\
    \x10\0\xd2\x10\x01\x1a\x08\x20Output\n\n\x0b\n\x03\x04h\x01\x12\x04\xbe\
    \x10\x08\x0e\n.\n\x04\x04h\x02\0\x12\x04\xc0\x10\x02\x10\x1a\x20\x20One\
    \x20of\x20these\x20outputs\x20per\x20Input\n\n\r\n\x05\x04h\x02\0\x05\
    \x12\x04\xc0\x10\x02\x08\n\r\n\x05\x04h\x02\0\x01\x12\x04\xc0\x10\t\x0b\
    \n\r\n\x05\x04h\x02\0\x03\x12\x04\xc0\x10\x0e\x0f\n\x0c\n\x04\x04h\x02\
    \x01\x12\x04\xc1\x10\x02(\n\r\n\x05\x04h\x02\x01\x06\x12\x04\xc1\x10\x02\
    \x1c\n\r\n\x05\x04h\x02\x01\x01\x12\x04\xc1\x10\x1d#\n\r\n\x05\x04h\x02\
    \x01\x03\x12\x04\xc1\x10&'\n\x81\x02\n\x04\x04h\x02\x02\x12\x04\xc8\x10\
    \x02+\x1a\xf2\x01\x20When\x20the\x20object\x20was\x20created.\x20We\x20f\
    ollow\x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\x20https://w\
    ww.ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15:04:05.999999\
    Z\"\x20so\x20you\x20can\x20expect\x20results\x20like\n\x20the\x20followi\
    ng\x20from\x20the\x20API:\n\x20\"2017-04-11T21:50:50.223962Z\"\n\n\r\n\
    \x05\x04h\x02\x02\x06\x12\x04\xc8\x10\x02\x1b\n\r\n\x05\x04h\x02\x02\x01\
    \x12\x04\xc8\x10\x1c&\n\r\n\x05\x04h\x02\x02\x03\x12\x04\xc8\x10)*\n3\n\
    \x04\x04h\x02\x03\x12\x04\xcb\x10\x02\x12\x1a%\x20The\x20model\x20that\
    \x20created\x20this\x20Output.\n\n\r\n\x05\x04h\x02\x03\x06\x12\x04\xcb\
    \x10\x02\x07\n\r\n\x05\x04h\x02\x03\x01\x12\x04\xcb\x10\x08\r\n\r\n\x05\
    \x04h\x02\x03\x03\x12\x04\xcb\x10\x10\x11\n\xbb\x01\n\x04\x04h\x02\x04\
    \x12\x04\xce\x10\x02\x12\x1a\xac\x01\x20The\x20input\x20that\x20was\x20p\
    assed\x20to\x20the\x20model\x20to\x20create\x20this\x20Output.\x20For\
    \x20example\x20if\x20we\x20have\x20an\x20image\n\x20model\x20then\x20it\
    \x20will\x20take\x20as\x20input\x20here\x20an\x20Input\x20object\x20with\
    \x20Image\x20filled\x20in.\n\n\r\n\x05\x04h\x02\x04\x06\x12\x04\xce\x10\
    \x02\x07\n\r\n\x05\x04h\x02\x04\x01\x12\x04\xce\x10\x08\r\n\r\n\x05\x04h\
    \x02\x04\x03\x12\x04\xce\x10\x10\x11\n\x86\x01\n\x04\x04h\x02\x05\x12\
    \x04\xd1\x10\x02\x10\x1ax\x20The\x20output\x20data\x20for\x20this\x20Out\
    put.\x20For\x20example\x20if\x20we\x20have\x20a\x20concept\x20model\x20t\
    hen\x20the\x20predicted\n\x20concepts\x20will\x20appear\x20here.\n\n\r\n\
    \x05\x04h\x02\x05\x06\x12\x04\xd1\x10\x02\x06\n\r\n\x05\x04h\x02\x05\x01\
    \x12\x04\xd1\x10\x07\x0b\n\r\n\x05\x04h\x02\x05\x03\x12\x04\xd1\x10\x0e\
    \x0f\n\x19\n\x02\x04i\x12\x06\xd5\x10\0\xda\x10\x01\x1a\x0b\x20ScopeDeps\
    \n\n\x0b\n\x03\x04i\x01\x12\x04\xd5\x10\x08\x11\n\x19\n\x04\x04i\x02\0\
    \x12\x04\xd7\x10\x02\x13\x1a\x0b\x20The\x20scope\n\n\r\n\x05\x04i\x02\0\
    \x05\x12\x04\xd7\x10\x02\x08\n\r\n\x05\x04i\x02\0\x01\x12\x04\xd7\x10\t\
    \x0e\n\r\n\x05\x04i\x02\0\x03\x12\x04\xd7\x10\x11\x12\n/\n\x04\x04i\x02\
    \x01\x12\x04\xd9\x10\x02'\x1a!\x20Other\x20scopes\x20that\x20are\x20requ\
    ired.\n\n\r\n\x05\x04i\x02\x01\x04\x12\x04\xd9\x10\x02\n\n\r\n\x05\x04i\
    \x02\x01\x05\x12\x04\xd9\x10\x0b\x11\n\r\n\x05\x04i\x02\x01\x01\x12\x04\
    \xd9\x10\x12\"\n\r\n\x05\x04i\x02\x01\x03\x12\x04\xd9\x10%&\n\x1c\n\x02\
    \x04j\x12\x06\xdd\x10\0\xe2\x10\x01\x1a\x0e\x20EndpointDeps\n\n\x0b\n\
    \x03\x04j\x01\x12\x04\xdd\x10\x08\x14\n/\n\x04\x04j\x02\0\x12\x04\xdf\
    \x10\x02\x16\x1a!\x20The\x20fully\x20qualified\x20endpoint\x20to\n\n\r\n\
    \x05\x04j\x02\0\x05\x12\x04\xdf\x10\x02\x08\n\r\n\x05\x04j\x02\0\x01\x12\
    \x04\xdf\x10\t\x11\n\r\n\x05\x04j\x02\0\x03\x12\x04\xdf\x10\x14\x15\n/\n\
    \x04\x04j\x02\x01\x12\x04\xe1\x10\x02'\x1a!\x20Other\x20scopes\x20that\
    \x20are\x20required.\n\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xe1\x10\x02\n\
    \n\r\n\x05\x04j\x02\x01\x05\x12\x04\xe1\x10\x0b\x11\n\r\n\x05\x04j\x02\
    \x01\x01\x12\x04\xe1\x10\x12\"\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xe1\
    \x10%&\n\x13\n\x02\x04k\x12\x06\xe5\x10\0\xfe\x10\x01\x1a\x05\x20Hit\n\n\
    \x0b\n\x03\x04k\x01\x12\x04\xe5\x10\x08\x0b\n\xcf\x05\n\x04\x04k\x02\0\
    \x12\x04\xef\x10\x02A\x1a\xc0\x05\x20This\x20is\x20the\x20score\x20for\
    \x20the\x20ranked\x20Hit\x20results\x20of\x20the\x20search\x20query.\x20\
    This\x20score\x20is\x20a\x20number\n\x20between\x200.0\x20and\x201.0\x20\
    as\x20it\x20represents\x20a\x20confidence\x20in\x20the\x20search\x20Hit.\
    \x20For\x20example,\x20if\x20you\x20search\n\x20for\x20\"car\"\x20and\
    \x20get\x20a\x20close\x20matching\x20Hit,\x20the\x20score\x20should\x20b\
    e\x20close\x20to\x201.0.\x20If\x20you\x20get\x20a\x20score\n\x20of\x20cl\
    ose\x20to\x200.0\x20that\x20means\x20it's\x20very\x20disimilar\x20to\x20\
    your\x20query,\x20in\x20this\x20case\x20NOT\x20a\x20\"car\".\x20There\n\
    \x20is\x20a\x20special\x20intermediate\x20score\x20of\x200.5\x20that\x20\
    means\x20that\x20the\x20Hit\x20is\x20not\x20really\x20correlated\x20with\
    \n\x20your\x20search\x20query\x20(ie.\x20not\x20similar\x20or\x20dissiml\
    ar\x20to\x20the\x20query)\x20which\x20is\x20a\x20common\x20occurrence\n\
    \x20when\x20using\x20negate\x20queries.\n\x20Note:\x20some\x20queries\
    \x20that\x20are\x20just\x20filtering\x20down\x20your\x20app\x20of\x20inp\
    uts\x20may\x20just\x20return\x20a\x20score\x20of\n\x201.0\x20for\x20all\
    \x20Hits.\n\n\r\n\x05\x04k\x02\0\x05\x12\x04\xef\x10\x02\x07\n\r\n\x05\
    \x04k\x02\0\x01\x12\x04\xef\x10\x08\r\n\r\n\x05\x04k\x02\0\x03\x12\x04\
    \xef\x10\x10\x11\n\r\n\x05\x04k\x02\0\x08\x12\x04\xef\x10\x12@\n\x10\n\
    \x08\x04k\x02\0\x08\xd0\x86\x03\x12\x04\xef\x10\x13?\n\x96\x02\n\x04\x04\
    k\x02\x01\x12\x04\xf3\x10\x02\x12\x1a\x87\x02\x20This\x20is\x20the\x20ma\
    tched\x20input\x20returned\x20from\x20the\x20search\x20query.\x20This\
    \x20will\x20contain\x20information\x20about\n\x20the\x20Input\x20such\
    \x20as\x20the\x20url,\x20created_at\x20time\x20and\x20trusted\x20annotat\
    ion\x20information\x20(for\x20backwards\n\x20compatibility\x20with\x20ap\
    ps\x20that\x20existed\x20before\x20Annotations\x20were\x20introduced.\n\
    \n\r\n\x05\x04k\x02\x01\x06\x12\x04\xf3\x10\x02\x07\n\r\n\x05\x04k\x02\
    \x01\x01\x12\x04\xf3\x10\x08\r\n\r\n\x05\x04k\x02\x01\x03\x12\x04\xf3\
    \x10\x10\x11\n\xc1\x03\n\x04\x04k\x02\x02\x12\x04\xf9\x10\x02\x1c\x1a\
    \xb2\x03\x20We\x20also\x20provide\x20back\x20the\x20specific\x20matched\
    \x20annotation\x20for\x20the\x20above\x20input.\x20We\x20do\x20this\x20i\
    n\x20order\n\x20to\x20support\x20more\x20complex\x20Annotation\x20querie\
    s\x20in\x20the\x20And\x20message\x20below.\x20For\x20example\x20if\x20we\
    \x20match\n\x20the\x20search\x20results\x20to\x20a\x20region\x20in\x20yo\
    ur\x20input,\x20or\x20a\x20frame\x20in\x20a\x20video\x20input,\x20this\
    \x20annotation\n\x20field\x20will\x20be\x20that\x20matched\x20annotation\
    \x20info\x20and\x20the\x20input\x20will\x20be\x20the\x20image/video\x20t\
    hat\x20the\x20user\n\x20originally\x20added\x20which\x20contains\x20thos\
    e\x20regions\x20/\x20frames.\n\n\r\n\x05\x04k\x02\x02\x06\x12\x04\xf9\
    \x10\x02\x0c\n\r\n\x05\x04k\x02\x02\x01\x12\x04\xf9\x10\r\x17\n\r\n\x05\
    \x04k\x02\x02\x03\x12\x04\xf9\x10\x1a\x1b\nX\n\x04\x04k\x02\x03\x12\x04\
    \xfb\x10\x02\x15\x1aJ\x20The\x20customer-facing\x20id\x20of\x20the\x20us\
    er\x20who\x20owns\x20the\x20app\x20the\x20asset\x20came\x20from.\n\n\r\n\
    \x05\x04k\x02\x03\x05\x12\x04\xfb\x10\x02\x08\n\r\n\x05\x04k\x02\x03\x01\
    \x12\x04\xfb\x10\t\x10\n\r\n\x05\x04k\x02\x03\x03\x12\x04\xfb\x10\x13\
    \x14\n8\n\x04\x04k\x02\x04\x12\x04\xfd\x10\x02\x14\x1a*\x20The\x20cfid\
    \x20of\x20the\x20app\x20the\x20asset\x20came\x20from.\n\n\r\n\x05\x04k\
    \x02\x04\x05\x12\x04\xfd\x10\x02\x08\n\r\n\x05\x04k\x02\x04\x01\x12\x04\
    \xfd\x10\t\x0f\n\r\n\x05\x04k\x02\x04\x03\x12\x04\xfd\x10\x12\x13\n\x0c\
    \n\x02\x04l\x12\x06\x80\x11\0\x83\x11\x01\n\x0b\n\x03\x04l\x01\x12\x04\
    \x80\x11\x08\x10\nc\n\x04\x04l\x02\0\x12\x04\x82\x11\x02\x1d\x1aU\x20The\
    \x20estimated\x20total\x20number\x20of\x20hits\x20for\x20the\x20search\
    \x20query,\x20not\x20just\x20the\x20current\x20page.\n\n\r\n\x05\x04l\
    \x02\0\x05\x12\x04\x82\x11\x02\x08\n\r\n\x05\x04l\x02\0\x01\x12\x04\x82\
    \x11\t\x18\n\r\n\x05\x04l\x02\0\x03\x12\x04\x82\x11\x1b\x1c\n\xd5\x03\n\
    \x02\x04m\x12\x06\x8a\x11\0\xe2\x11\x01\x1a\xc6\x03\x20This\x20is\x20the\
    \x20common\x20building\x20block\x20of\x20a\x20query\x20which\x20is\x20a\
    \x20sequence\x20of\x20And\x20messages\x20ANDed\x20together.\n\x20Note\
    \x20that\x20some\x20fields\x20are\x20used\x20too\x20RANK\x20results\x20(\
    affect\x20the\x20scores)\x20and\x20some\x20are\x20used\x20to\x20FILTER\n\
    \x20results\x20(unordered\x20subset\x20of\x20your\x20app's\x20contents).\
    \x20In\x20general,\x20FILTER\x20operations\x20are\x20more\n\x20efficient\
    \x20queries\x20at\x20scale\x20and\x20when\x20combined\x20with\x20RANK\
    \x20operations\x20can\x20speed\x20up\x20search\x20performance\n\x20as\
    \x20you\x20effectively\x20operate\x20on\x20a\x20smaller\x20sub-set\x20of\
    \x20your\x20entire\x20app.\n\n\x0b\n\x03\x04m\x01\x12\x04\x8a\x11\x08\
    \x0b\n\xb8\x08\n\x04\x04m\x02\0\x12\x04\xa1\x11\x02\x12\x1a\xa9\x08\x20F\
    ILTER\x20by\x20input.data...\x20information.\n\x20This\x20can\x20include\
    \x20human\x20provided\x20concepts,\x20geo\x20location\x20info,\x20metada\
    ta,\x20etc.\n\x20This\x20is\x20effectively\x20searching\x20over\x20only\
    \x20the\x20trusted\x20annotation\x20attached\x20to\x20an\x20input\x20in\
    \x20your\n\x20app.\x20To\x20search\x20by\x20more\x20specific\x20annotati\
    on\x20fields\x20use\x20the\x20Annotation\x20object\x20here.\n\x20#######\
    ###\x20Supported\x20fields\x20##########\n\x20\x20-\x20data.concepts[].i\
    d\n\x20\x20-\x20data.concepts[].name\n\x20\x20-\x20data.concepts[].value\
    \n\x20\x20-\x20data.geo.geo_box[].geo_point.latitude\n\x20\x20-\x20data.\
    geo.geo_box[].geo_point.longitude\n\x20\x20-\x20data.geo.geo_limit.type\
    \n\x20\x20-\x20data.geo.geo_limit.value\n\x20\x20-\x20data.geo.geo_point\
    .latitude\n\x20\x20-\x20data.geo.geo_point.longitude\n\x20\x20-\x20data.\
    image.url\n\x20\x20-\x20data.metadata\x20-\x20allow\x20search\x20with\
    \x20empty\x20metadata\n\x20\x20\x20\x20note\x20that\x20searching\x20by\
    \x20empty\x20metadata\x20will\x20actually\x20not\x20influence\x20the\x20\
    search\x20results.\n\x20\x20\x20\x20however,\x20in\x20order\x20to\x20be\
    \x20user-friendly,\x20we\x20are\x20still\x20supporting\x20searching\x20b\
    y\x20empty\x20metadata.\n\x20\x20-\x20data.metadata.fields\x20-\x20filte\
    r\x20by\x20metadata.\x20metadata\x20key&value\x20fields\x20are\x20OR-ed.\
    \n\x20\x20-\x20dataset_ids[]\x20-\x20filter\x20by\x20dataset\x20IDs\n\
    \x20\x20-\x20id\x20-\x20filter\x20by\x20input\x20ID\n\x20\x20-\x20status\
    .code\x20-\x20filter\x20by\x20input\x20status\n\n\r\n\x05\x04m\x02\0\x06\
    \x12\x04\xa1\x11\x02\x07\n\r\n\x05\x04m\x02\0\x01\x12\x04\xa1\x11\x08\r\
    \n\r\n\x05\x04m\x02\0\x03\x12\x04\xa1\x11\x10\x11\n\x86\n\n\x04\x04m\x02\
    \x01\x12\x04\xb7\x11\x02\x14\x1a\xf7\t\x20RANK\x20based\x20predicted\x20\
    outputs\x20from\x20models\x20such\x20as\x20custom\x20trained\x20models,\
    \x20pre-trained\x20models,\n\x20etc.\x20This\x20is\x20also\x20where\x20y\
    ou\x20enter\x20the\x20image\x20url\x20for\x20a\x20visual\x20search\x20be\
    cause\x20what\x20we're\x20asking\n\x20the\x20system\x20to\x20do\x20is\
    \x20find\x20output\x20embedding\x20most\x20visually\x20similar\x20to\x20\
    the\x20provided\x20input\x20(that\n\x20input\x20being\x20in\x20And.outpu\
    t.input.data.image.url\x20for\x20example).\x20This\x20will\x20return\x20\
    the\x20Hits\n\x20sorted\x20by\x20visual\x20similarity\x20(1.0\x20being\
    \x20very\x20similar\x20or\x20exact\x20match\x20and\x200.0\x20being\x20ve\
    ry\n\x20dissimlar).\x20For\x20a\x20search\x20by\x20Output\x20concept,\
    \x20this\x20means\x20we're\x20asking\x20the\x20system\x20to\x20rank\n\
    \x20the\x20Hits\x20by\x20confidence\x20of\x20our\x20model's\x20predicted\
    \x20Outputs.\x20So\x20for\x20example\x20if\x20the\x20model\n\x20predicts\
    \x20an\x20image\x20is\x200.95\x20likely\x20there\x20is\x20a\x20\"dog\"\
    \x20present,\x20that\x20should\x20related\x20directly\n\x20to\x20the\x20\
    score\x20returned\x20if\x20you\x20search\x20for\x20Output\x20concept\x20\
    \"dog\"\x20in\x20your\x20query.\x20This\x20provides\n\x20a\x20natural\
    \x20ranking\x20to\x20search\x20results\x20based\x20on\x20confidence\x20o\
    f\x20predictions\x20from\x20the\x20models\x20and\n\x20is\x20used\x20when\
    \x20ANDing\x20multiple\x20of\x20these\x20types\x20of\x20RANK\x20by\x20Ou\
    tput\x20queries\x20together\x20as\x20well.\n\n\x20##########\x20Supporte\
    d\x20fields\x20##########\n\x20\x20-\x20data.clusters[].id\n\x20\x20-\
    \x20data.concepts[].id\n\x20\x20-\x20data.concepts[].name\n\x20\x20-\x20\
    data.concepts[].value\n\x20\x20-\x20input.data.image\x20-\x20empty\x20im\
    age\x20is\x20required\x20when\x20searching\x20by\x20input\x20ID\n\x20\
    \x20-\x20input.data.image.base64[]\n\x20\x20-\x20input.data.image.url\n\
    \x20\x20-\x20input.id\n\n\r\n\x05\x04m\x02\x01\x06\x12\x04\xb7\x11\x02\
    \x08\n\r\n\x05\x04m\x02\x01\x01\x12\x04\xb7\x11\t\x0f\n\r\n\x05\x04m\x02\
    \x01\x03\x12\x04\xb7\x11\x12\x13\n\x98\x01\n\x04\x04m\x02\x02\x12\x04\
    \xba\x11\x02\x12\x1a\x89\x01\x20If\x20True\x20then\x20this\x20will\x20fl\
    ip\x20the\x20meaning\x20of\x20this\x20part\x20of\x20the\n\x20query.\x20T\
    his\x20allow\x20for\x20queries\x20such\x20as\x20dog\x20AND\x20!\x20metad\
    ata=={\"blah\":\"value\"}\n\n\r\n\x05\x04m\x02\x02\x05\x12\x04\xba\x11\
    \x02\x06\n\r\n\x05\x04m\x02\x02\x01\x12\x04\xba\x11\x07\r\n\r\n\x05\x04m\
    \x02\x02\x03\x12\x04\xba\x11\x10\x11\n\xe1\r\n\x04\x04m\x02\x03\x12\x04\
    \xe1\x11\x02\x1c\x1a\xd2\r\x20FILTER\x20by\x20annotation\x20information.\
    \x20This\x20is\x20more\x20flexible\x20than\x20just\x20filtering\x20by\n\
    \x20Input\x20information\x20because\x20in\x20the\x20general\x20case\x20e\
    ach\x20input\x20can\x20have\x20several\x20annotations.\n\x20Some\x20exam\
    ple\x20use\x20cases\x20for\x20filtering\x20by\x20annotations:\n\x201)\
    \x20find\x20all\x20the\x20inputs\x20annotated\x20\"dog\"\x20by\x20worker\
    _id\x20=\x20\"XYZ\"\n\x202)\x20find\x20all\x20the\x20annotations\x20asso\
    ciated\x20with\x20embed_model_version_id\x20=\x20\"123\"\n\x203)\x20find\
    \x20all\x20the\x20annotations\x20that\x20are\x20trusted,\x20etc.\n\n\x20\
    Since\x20all\x20the\x20annotations\x20under\x20the\x20hood\x20are\x20joi\
    ned\x20to\x20the\x20embedding\x20model's\x20annotation\n\x20using\x20wor\
    ker_id's\x20of\x20other\x20models\x20like\x20cluster\x20models\x20or\x20\
    concept\x20models\x20should\x20be\n\x20combinable\x20with\x20queries\x20\
    like\x20visual\x20search\x20(a\x20query\x20with\x20Output\x20filled\x20i\
    n).\n\n\x20##########\x20Supported\x20fields\x20##########\n\x20\x20-\
    \x20annotation_info\x20-\x20allows\x20searching\x20by\x20empty\x20annota\
    tion\x20info\n\x20\x20\x20\x20note\x20that\x20searching\x20by\x20empty\
    \x20annotation\x20info\x20will\x20actually\x20not\x20influence\x20the\
    \x20search\x20results.\n\x20\x20\x20\x20however,\x20in\x20order\x20to\
    \x20be\x20user-friendly,\x20we\x20are\x20still\x20supporting\x20searchin\
    g\x20by\x20empty\x20annotation\x20info.\n\x20\x20-\x20annotation_info.fi\
    elds\x20-\x20filter\x20by\x20annotation\x20info\n\x20\x20-\x20data.conce\
    pts[].id\n\x20\x20-\x20data.concepts[].name\n\x20\x20-\x20data.concepts[\
    ].value\n\x20\x20-\x20data.geo.geo_box[].geo_point.latitude\n\x20\x20-\
    \x20data.geo.geo_box[].geo_point.longitude\n\x20\x20-\x20data.geo.geo_li\
    mit.type\n\x20\x20-\x20data.geo.geo_limit.value\n\x20\x20-\x20data.geo.g\
    eo_point.latitude\n\x20\x20-\x20data.geo.geo_point.longitude\n\x20\x20-\
    \x20data.image.url\n\x20\x20-\x20data.metadata\x20-\x20allow\x20search\
    \x20with\x20empty\x20metadata\n\x20\x20\x20\x20note\x20that\x20searching\
    \x20by\x20empty\x20metadata\x20will\x20actually\x20not\x20influence\x20t\
    he\x20search\x20results.\n\x20\x20\x20\x20however,\x20in\x20order\x20to\
    \x20be\x20user-friendly,\x20we\x20are\x20still\x20supporting\x20searchin\
    g\x20by\x20empty\x20metadata.\n\x20\x20-\x20data.metadata.fields\x20-\
    \x20filter\x20by\x20metadata.\x20metadata\x20key&value\x20fields\x20are\
    \x20OR-ed.\n\x20\x20-\x20input_id\n\x20\x20-\x20input_level\n\x20\x20-\
    \x20model_version_id\n\x20\x20-\x20status.code\n\x20\x20-\x20task_id\n\
    \x20\x20-\x20trusted\n\x20\x20-\x20user_id\n\n\r\n\x05\x04m\x02\x03\x06\
    \x12\x04\xe1\x11\x02\x0c\n\r\n\x05\x04m\x02\x03\x01\x12\x04\xe1\x11\r\
    \x17\n\r\n\x05\x04m\x02\x03\x03\x12\x04\xe1\x11\x1a\x1b\nl\n\x02\x04n\
    \x12\x06\xe5\x11\0\xf9\x11\x01\x1a^\x20This\x20is\x20the\x20search\x20qu\
    ery\x20used\x20in\x20/searches,\x20model\x20training\x20requests,\x20bul\
    k\x20data\x20exports,\x20etc.\n\n\x0b\n\x03\x04n\x01\x12\x04\xe5\x11\x08\
    \r\n\xb6\x02\n\x04\x04n\x02\0\x12\x04\xeb\x11\x02,\x1a\xa7\x02\x20The\
    \x20query\x20syntax\x20is\x20simply\x20a\x20list\x20of\x20And\x20operati\
    osn\x20that\x20will\x20be\x20ANDed\x20together\x20to\x20fetch\n\x20resul\
    ts\x20which\x20are\x20returned\x20to\x20the\x20user\x20as\x20Hit\x20mess\
    ages.\n\n\x20Deprecated:\x20Only\x20used\x20by\x20the\x20deprecated\x20P\
    ostSearches\x20endpoint.\x20Use\x20filters\n\x20and\x20ranks\x20instead\
    \x20with\x20PostInputsSearches\x20or\x20PostAnnotationsSearches.\n\n\r\n\
    \x05\x04n\x02\0\x04\x12\x04\xeb\x11\x02\n\n\r\n\x05\x04n\x02\0\x06\x12\
    \x04\xeb\x11\x0b\x0e\n\r\n\x05\x04n\x02\0\x01\x12\x04\xeb\x11\x0f\x13\n\
    \r\n\x05\x04n\x02\0\x03\x12\x04\xeb\x11\x16\x17\n\r\n\x05\x04n\x02\0\x08\
    \x12\x04\xeb\x11\x18+\n\x0e\n\x06\x04n\x02\0\x08\x03\x12\x04\xeb\x11\x19\
    *\n\xfa\x01\n\x04\x04n\x02\x01\x12\x04\xf0\x11\x02\x16\x1a\xeb\x01\x20Th\
    is\x20allows\x20the\x20query\x20to\x20override\x20any\x20default\x20lang\
    uage\x20the\x20app\x20was\x20setup\x20in\x20when\x20doing\x20Concept\n\
    \x20based\x20searches.\x20This\x20currently\x20only\x20affects\x20public\
    \x20Models\x20Output\x20searches\x20when\x20those\x20public\n\x20Models\
    \x20have\x20translations\x20for\x20their\x20Concepts.\n\n\r\n\x05\x04n\
    \x02\x01\x05\x12\x04\xf0\x11\x02\x08\n\r\n\x05\x04n\x02\x01\x01\x12\x04\
    \xf0\x11\t\x11\n\r\n\x05\x04n\x02\x01\x03\x12\x04\xf0\x11\x14\x15\n]\n\
    \x04\x04n\x02\x02\x12\x04\xf4\x11\x02\x1e\x1aO\x20filters\x20in\x20this\
    \x20query\n\x20e.q.\x20only\x20fetch\x20annotations\x20that\x20have\x20c\
    ertain\x20metadata\n\n\r\n\x05\x04n\x02\x02\x04\x12\x04\xf4\x11\x02\n\n\
    \r\n\x05\x04n\x02\x02\x06\x12\x04\xf4\x11\x0b\x11\n\r\n\x05\x04n\x02\x02\
    \x01\x12\x04\xf4\x11\x12\x19\n\r\n\x05\x04n\x02\x02\x03\x12\x04\xf4\x11\
    \x1c\x1d\nC\n\x04\x04n\x02\x03\x12\x04\xf8\x11\x02\x1a\x1a5\x20rankings\
    \x20in\x20this\x20query\n\x20e.g.\x20visual\x20search\x20by\x20a\x20url\
    \n\n\r\n\x05\x04n\x02\x03\x04\x12\x04\xf8\x11\x02\n\n\r\n\x05\x04n\x02\
    \x03\x06\x12\x04\xf8\x11\x0b\x0f\n\r\n\x05\x04n\x02\x03\x01\x12\x04\xf8\
    \x11\x10\x15\n\r\n\x05\x04n\x02\x03\x03\x12\x04\xf8\x11\x18\x19\nE\n\x02\
    \x04o\x12\x06\xfc\x11\0\xb4\x12\x01\x1a7\x20This\x20is\x20the\x20new\x20\
    Search\x20object\x20used\x20in\x20saved\x20searches.\n\n\x0b\n\x03\x04o\
    \x01\x12\x04\xfc\x11\x08\x0e\n\x1d\n\x04\x04o\x02\0\x12\x04\xfe\x11\x02\
    \x12\x1a\x0f\x20Search\x20query.\n\n\r\n\x05\x04o\x02\0\x06\x12\x04\xfe\
    \x11\x02\x07\n\r\n\x05\x04o\x02\0\x01\x12\x04\xfe\x11\x08\r\n\r\n\x05\
    \x04o\x02\0\x03\x12\x04\xfe\x11\x10\x11\n\x90\x01\n\x04\x04o\x02\x01\x12\
    \x04\x82\x12\x02\x10\x1a\x81\x01\x20Customer\x20facing,\x20external\x20I\
    D\x20for\x20search\x20to\x20be\x20saved.\x20Provided\x20by\x20the\x20use\
    r,\x20e.g.\x20\"saved-search-1.\n\x20It\x20is\x20unique\x20per\x20applic\
    ation.\n\n\r\n\x05\x04o\x02\x01\x05\x12\x04\x82\x12\x02\x08\n\r\n\x05\
    \x04o\x02\x01\x01\x12\x04\x82\x12\t\x0b\n\r\n\x05\x04o\x02\x01\x03\x12\
    \x04\x82\x12\x0e\x0f\n8\n\x04\x04o\x02\x02\x12\x04\x85\x12\x02\x1c\x1a*\
    \x20Application\x20that\x20owns\x20this\x20saved\x20search.\n\n\r\n\x05\
    \x04o\x02\x02\x05\x12\x04\x85\x12\x02\x08\n\r\n\x05\x04o\x02\x02\x01\x12\
    \x04\x85\x12\t\x17\n\r\n\x05\x04o\x02\x02\x03\x12\x04\x85\x12\x1a\x1b\n@\
    \n\x04\x04o\x02\x03\x12\x04\x88\x12\x02\x12\x1a2\x20Human\x20readable\
    \x20display\x20name\x20of\x20the\x20saved\x20search.\n\n\r\n\x05\x04o\
    \x02\x03\x05\x12\x04\x88\x12\x02\x08\n\r\n\x05\x04o\x02\x03\x01\x12\x04\
    \x88\x12\t\r\n\r\n\x05\x04o\x02\x03\x03\x12\x04\x88\x12\x10\x11\n\x87\
    \x01\n\x04\x04o\x02\x04\x12\x04\x8c\x12\x02&\x1ay\x20\"As\x20of\"\x20tim\
    estamp,\x20indicating\x20a\x20time\x20in\x20the\x20past\x20as\x20of\x20w\
    hich\x20we\x20want\x20to\n\x20retrieve\x20the\x20annotations\x20satisfyi\
    ng\x20the\x20query.\n\n\r\n\x05\x04o\x02\x04\x06\x12\x04\x8c\x12\x02\x1b\
    \n\r\n\x05\x04o\x02\x04\x01\x12\x04\x8c\x12\x1c!\n\r\n\x05\x04o\x02\x04\
    \x03\x12\x04\x8c\x12$%\n9\n\x04\x04o\x02\x05\x12\x04\x8f\x12\x02\x16\x1a\
    +\x20Git\x20hash\x20of\x20the\x20code\x20that\x20ran\x20the\x20filter.\n\
    \n\r\n\x05\x04o\x02\x05\x05\x12\x04\x8f\x12\x02\x08\n\r\n\x05\x04o\x02\
    \x05\x01\x12\x04\x8f\x12\t\x11\n\r\n\x05\x04o\x02\x05\x03\x12\x04\x8f\
    \x12\x14\x15\n2\n\x04\x04o\x02\x06\x12\x04\x92\x12\x02+\x1a$\x20When\x20\
    the\x20saved\x20search\x20was\x20created.\n\n\r\n\x05\x04o\x02\x06\x06\
    \x12\x04\x92\x12\x02\x1b\n\r\n\x05\x04o\x02\x06\x01\x12\x04\x92\x12\x1c&\
    \n\r\n\x05\x04o\x02\x06\x03\x12\x04\x92\x12)*\n2\n\x04\x04o\x02\x07\x12\
    \x04\x95\x12\x02,\x1a$\x20When\x20the\x20saved\x20search\x20was\x20updat\
    ed.\n\n\r\n\x05\x04o\x02\x07\x06\x12\x04\x95\x12\x02\x1b\n\r\n\x05\x04o\
    \x02\x07\x01\x12\x04\x95\x12\x1c'\n\r\n\x05\x04o\x02\x07\x03\x12\x04\x95\
    \x12*+\n\xd8\x02\n\x04\x04o\x02\x08\x12\x04\x9c\x12\x02\x17\x1a\xc9\x02\
    \x20The\x20search\x20algorithm\x20to\x20be\x20used.\n\x20Options\x20are\
    \x20are\x20'nearest_neighbor',\x20'brute_force',\x20and\x20'avg_concept_\
    brute_force'\n\x20The\x20last\x20two\x20perform\x20a\x20brute\x20force\
    \x20search\x20visual\x20search\x20instead\x20of\x20a\x20more\x20scalable\
    \x20distributed\n\x20nearest\x20neighbor\x20search\x20and\x20should\x20b\
    e\x20used\x20by\x20advanced\x20users\x20only.\n\x20If\x20not\x20specifie\
    d\x20we\x20default\x20to\x20nearest\x20neighbor\n\n\r\n\x05\x04o\x02\x08\
    \x05\x12\x04\x9c\x12\x02\x08\n\r\n\x05\x04o\x02\x08\x01\x12\x04\x9c\x12\
    \t\x12\n\r\n\x05\x04o\x02\x08\x03\x12\x04\x9c\x12\x15\x16\nm\n\x04\x04o\
    \x02\t\x12\x04\xa0\x12\x02\x11\x1a_\x20If\x20true,\x20save\x20this\x20se\
    arch,\x20and\x20exit\x20without\x20executing\x20the\x20search.\n\x20If\
    \x20false\x20execute\x20the\x20query\n\n\r\n\x05\x04o\x02\t\x05\x12\x04\
    \xa0\x12\x02\x06\n\r\n\x05\x04o\x02\t\x01\x12\x04\xa0\x12\x07\x0b\n\r\n\
    \x05\x04o\x02\t\x03\x12\x04\xa0\x12\x0e\x10\n\xad\x01\n\x04\x04o\x02\n\
    \x12\x04\xa5\x12\x02\x17\x1a\x9e\x01\x20Minimum\x20value\x20of\x20confid\
    ence\x20threshold\x20score\x20in\x20result.\n\x20Defaults\x20to\x200.0\
    \x20which\x20means\x20we\x20won't\x20do\x20any\x20thresholding\x20as\x20\
    all\x20probabilities\x20will\n\x20likely\x20be\x20>\x200.0.\n\n\r\n\x05\
    \x04o\x02\n\x05\x12\x04\xa5\x12\x02\x07\n\r\n\x05\x04o\x02\n\x01\x12\x04\
    \xa5\x12\x08\x11\n\r\n\x05\x04o\x02\n\x03\x12\x04\xa5\x12\x14\x16\n\xdd\
    \x01\n\x04\x04o\x02\x0b\x12\x04\xaa\x12\x02\x1d\x1a\xce\x01\x20The\x20vi\
    sibility\x20field\x20represents\x20whether\x20this\x20message\x20is\x20p\
    rivately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20p\
    ublic\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20User\x20t\
    hat\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20vis\
    ible.\n\n\r\n\x05\x04o\x02\x0b\x06\x12\x04\xaa\x12\x02\x0c\n\r\n\x05\x04\
    o\x02\x0b\x01\x12\x04\xaa\x12\r\x17\n\r\n\x05\x04o\x02\x0b\x03\x12\x04\
    \xaa\x12\x1a\x1c\n\xa5\x01\n\x04\x04o\x04\0\x12\x06\xae\x12\x02\xb2\x12\
    \x03\x1a\x94\x01\x20Metric\x20used\x20for\x20search.\x20Can\x20be\x20EUC\
    LIDEAN_DISTANCE\x20(default)\x20or\x20COSINE_DISTANCE.\n\x20Currently\
    \x20only\x20brute\x20force\x20search\x20supports\x20non-eudlicean\x20met\
    rics.\n\n\r\n\x05\x04o\x04\0\x01\x12\x04\xae\x12\x07\r\n\x0e\n\x06\x04o\
    \x04\0\x02\0\x12\x04\xaf\x12\x04\x17\n\x0f\n\x07\x04o\x04\0\x02\0\x01\
    \x12\x04\xaf\x12\x04\x12\n\x0f\n\x07\x04o\x04\0\x02\0\x02\x12\x04\xaf\
    \x12\x15\x16\n\x0e\n\x06\x04o\x04\0\x02\x01\x12\x04\xb0\x12\x04\x1b\n\
    \x0f\n\x07\x04o\x04\0\x02\x01\x01\x12\x04\xb0\x12\x04\x16\n\x0f\n\x07\
    \x04o\x04\0\x02\x01\x02\x12\x04\xb0\x12\x19\x1a\n\x0e\n\x06\x04o\x04\0\
    \x02\x02\x12\x04\xb1\x12\x04\x18\n\x0f\n\x07\x04o\x04\0\x02\x02\x01\x12\
    \x04\xb1\x12\x04\x13\n\x0f\n\x07\x04o\x04\0\x02\x02\x02\x12\x04\xb1\x12\
    \x16\x17\n\x0c\n\x04\x04o\x02\x0c\x12\x04\xb3\x12\x02\x15\n\r\n\x05\x04o\
    \x02\x0c\x06\x12\x04\xb3\x12\x02\x08\n\r\n\x05\x04o\x02\x0c\x01\x12\x04\
    \xb3\x12\t\x0f\n\r\n\x05\x04o\x02\x0c\x03\x12\x04\xb3\x12\x12\x14\n\x16\
    \n\x02\x04p\x12\x06\xb7\x12\0\xa4\x13\x01\x1a\x08\x20Filter\n\n\x0b\n\
    \x03\x04p\x01\x12\x04\xb7\x12\x08\x0e\n\x98\x01\n\x04\x04p\x02\0\x12\x04\
    \xba\x12\x02\x12\x1a\x89\x01\x20If\x20True\x20then\x20this\x20will\x20fl\
    ip\x20the\x20meaning\x20of\x20this\x20part\x20of\x20the\n\x20query.\x20T\
    his\x20allow\x20for\x20queries\x20such\x20as\x20dog\x20AND\x20!\x20metad\
    ata=={\"blah\":\"value\"}\n\n\r\n\x05\x04p\x02\0\x05\x12\x04\xba\x12\x02\
    \x06\n\r\n\x05\x04p\x02\0\x01\x12\x04\xba\x12\x07\r\n\r\n\x05\x04p\x02\0\
    \x03\x12\x04\xba\x12\x10\x11\n\x922\n\x04\x04p\x02\x01\x12\x04\x90\x13\
    \x02\x1c\x1a\x832\x20FILTER\x20by\x20annotation\x20information.\n\x20###\
    #######\x20Supported\x20fields\x20##########\n\x20\x20#\x20Filter\x20by\
    \x20ID\x20fields\n\x20\x20-\x20id\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20example:\x20`{\"id\":\
    \x20\"xyz\"}`\n\x20\x20-\x20input_id\n\x20\x20-\x20model_version_id\n\
    \x20\x20-\x20task_id\n\x20\x20-\x20user_id\n\x20\x20-\x20workflow_versio\
    n_id\n\n\x20\x20#\x20Filter\x20by\x20other\x20top-level\x20fields\n\x20\
    \x20-\x20annotation_info\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20allows\x20searc\
    hing\x20by\x20empty\x20annotation-info,\x20i.e.\x20`{\"data\":\x20\"anno\
    tation_info\":\x20{}}`;\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20note\
    \x20that\x20searching\x20by\x20empty\x20annotation-info\x20will\x20actua\
    lly\x20not\x20influence\x20the\x20search\x20results.\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20however,\x20in\x20order\x20to\x20be\x20user-frie\
    ndly,\x20we\x20still\x20support\x20searching\x20by\x20empty\x20annotatio\
    n-info.\n\x20\x20-\x20annotation_info.fields\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20by\x20annotat\
    ion\x20info\n\x20\x20-\x20input_level\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20-\x20filter\x20only\x20input-level\x20annotations\n\x20\x20-\
    \x20status.code\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\
    \x20by\x20annotation\x20status\x20code\n\x20\x20-\x20trusted\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20only\x20t\
    rusted\x20annotations\n\n\x20\x20#\x20Filter\x20by\x20space-time\x20info\
    \x20fields,\x20i.e.\x20region,\x20frames\x20and\x20time-segments\n\x20\
    \x20-\x20data\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20-\x20filter\x20only\x20annotations\x20without\x20space-t\
    ime\x20info,\x20e.g.\x20classifications\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20-\x20in\x20order\x20to\x20enable\x20this,\x20you\x20need\x20to\x20se\
    t\x20the\x20field\x20to\x20an\x20empty\x20object,\x20i.e.\x20`{\"data\":\
    \x20{}}`\n\x20\x20-\x20data.frames[].frame_info\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20only\x20frame\x20\
    annotations\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20in\x20order\x20to\
    \x20enable\x20this,\x20you\x20need\x20to\x20set\x20the\x20field\x20to\
    \x20an\x20empty\x20object,\x20i.e.\x20`{\"data\":\x20{\"frames\":\x20[{\
    \"frame_info\":\x20{}}]}}`\n\x20\x20-\x20data.regions[].region_info.boun\
    ding_box\x20-\x20filter\x20only\x20bounding\x20box\x20annotations\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20-\x20in\x20order\x20to\x20enable\x20this,\
    \x20you\x20need\x20to\x20set\x20the\x20field\x20to\x20an\x20empty\x20obj\
    ect,\x20i.e.\x20`{\"data\":\x20{\"regions\":\x20[{\"region_info\":\x20{\
    \"bounding_box\":{}}}]}}`\n\x20\x20-\x20data.regions[].region_info.mask\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20only\x20mask\x20annot\
    ations\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20in\x20order\x20to\x20enable\
    \x20this,\x20you\x20need\x20to\x20set\x20the\x20field\x20to\x20an\x20emp\
    ty\x20object,\x20i.e.\x20`{\"data\":\x20{\"regions\":\x20[{\"region_info\
    \":\x20{\"mask\":{}}}]}}`\n\x20\x20-\x20data.regions[].region_info.point\
    \x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20only\x20point\x20annotati\
    ons\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20in\x20order\x20to\x20enable\
    \x20this,\x20you\x20need\x20to\x20set\x20the\x20field\x20to\x20an\x20emp\
    ty\x20object,\x20i.e.\x20`{\"data\":\x20{\"regions\":\x20[{\"region_info\
    \":\x20{\"point\":{}}}]}}`\n\x20\x20-\x20data.regions[].region_info.poly\
    gon\x20\x20\x20\x20\x20\x20-\x20filter\x20only\x20polygon\x20annotations\
    \n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20in\x20order\x20to\x20enable\x20\
    this,\x20you\x20need\x20to\x20set\x20the\x20field\x20to\x20an\x20empty\
    \x20object,\x20i.e.\x20`{\"data\":\x20{\"regions\":\x20[{\"region_info\"\
    :\x20{\"polygon\":{}}}]}}`\n\x20\x20-\x20data.regions[].region_info.span\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20only\x20span\x20annot\
    ations\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20in\x20order\x20to\x20enable\
    \x20this,\x20you\x20need\x20to\x20set\x20the\x20field\x20to\x20an\x20emp\
    ty\x20object,\x20i.e.\x20`{\"data\":\x20{\"regions\":\x20[{\"region_info\
    \":\x20{\"span\":{}}}]}}`\n\x20\x20-\x20data.time_segments[].time_info\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20only\x20time-segm\
    ent\x20annotations\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20in\x20order\x20\
    to\x20enable\x20this,\x20you\x20need\x20to\x20set\x20the\x20field\x20to\
    \x20an\x20empty\x20object,\x20i.e.\x20`{\"data\":\x20{\"time_segments\":\
    \x20[{\"time_info\":\x20{}}]}}`\n\n\x20\x20#\x20Filter\x20by\x20other\
    \x20data\x20fields\n\x20\x20-\x20data.clusters[].id\n\x20\x20-\x20data.c\
    oncepts[].id\n\x20\x20-\x20data.concepts[].name\n\x20\x20-\x20data.conce\
    pts[].value\n\x20\x20-\x20data.geo.geo_box[].geo_point.latitude\n\x20\
    \x20-\x20data.geo.geo_box[].geo_point.longitude\n\x20\x20-\x20data.geo.g\
    eo_limit.type\n\x20\x20-\x20data.geo.geo_limit.value\n\x20\x20-\x20data.\
    geo.geo_point.latitude\n\x20\x20-\x20data.geo.geo_point.longitude\n\x20\
    \x20-\x20data.metadata\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20allow\
    \x20search\x20with\x20empty\x20metadata,\x20i.e.\x20`{\"data\":\x20\"met\
    adata\":\x20{}}`;\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20note\x20that\
    \x20searching\x20by\x20empty\x20metadata\x20will\x20actually\x20not\x20i\
    nfluence\x20the\x20search\x20results;\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20however,\x20in\x20order\x20to\x20be\x20user-friendly,\x20we\x20s\
    till\x20support\x20searching\x20by\x20empty\x20metadata.\n\x20\x20-\x20d\
    ata.metadata.fields\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20-\x20filter\x20by\x20metadata\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20-\x20Important\x20to\x20note:\x20metadata\x20key&val\
    ue\x20fields\x20are\x20OR-ed.\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20exa\
    mple\x20with\x201\x20metadata\x20key:\x20searching\x20by\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`{\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\
    \x20\"data\":\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20`\x20\x20\x20\x20\"metadata\":\x20{\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20\
    \x20\x20\x20\x20\"fields\":\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20\x20\x20\x20\x20\x20\x20\"f\
    oo\":\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20`\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\"string_value\":\
    \x20\"bar\"\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20`\x20\x20\x20\x20\x20\x20\x20\x20},\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20\x20\
    \x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20`\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20}\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`}\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20will\x20result\x20in\
    \x20a\x20search\x20condition\x20like\x20`metadata\x20includes\x20{\"foo\
    \":\x20\"bar}`;\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20example\x20with\
    \x202\x20metadata\x20keys:\x20searching\x20by\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`{\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20\"data\":\
    \x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20`\x20\x20\x20\x20\"metadata\":\x20{\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20\x20\x20\x20\
    \x20\"fields\":\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20`\x20\x20\x20\x20\x20\x20\x20\x20\"foo1\":\x20{\
    \n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20`\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\"string_value\":\x20\"bar2\
    \"\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20`\x20\x20\x20\x20\x20\x20\x20\x20},\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20\x20\x20\x20\x20\
    \x20\x20\"foo2\":\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20`\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\"strin\
    g_value\":\x20\"bar2\"\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20`\x20\x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20\
    \x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20`\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`\x20\x20}\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20`}\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20will\x20result\
    \x20in\x20a\x20search\x20condition\x20like\x20`(metadata\x20includes\x20\
    {\"foo1\":\x20\"bar1\"})\x20OR\x20(metadata\x20includes\x20{\"foo2\":\
    \x20\"bar2\"})`.\n\x20\x20-\x20data.text\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20-\x20filter\x20only\x20text\x20annotations\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20-\x20in\x20order\x20to\x20enable\x20this,\x20you\
    \x20need\x20to\x20set\x20the\x20field\x20to\x20an\x20empty\x20object,\
    \x20i.e.\x20`{\"data\":\x20{\"text\":\x20{}}}`\n\n\r\n\x05\x04p\x02\x01\
    \x06\x12\x04\x90\x13\x02\x0c\n\r\n\x05\x04p\x02\x01\x01\x12\x04\x90\x13\
    \r\x17\n\r\n\x05\x04p\x02\x01\x03\x12\x04\x90\x13\x1a\x1b\n\xd4\x08\n\
    \x04\x04p\x02\x02\x12\x04\xa0\x13\x02\x12\x1a\xc5\x08\x20FILTER\x20by\
    \x20input\x20information.\n\x20##########\x20Supported\x20fields\x20####\
    ######\n\x20\x20-\x20data.audio\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20-\x20filter\x20only\x20audio\x20inputs\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20-\x20in\x20order\x20to\x20enable\x20this,\x20you\x20need\x20to\
    \x20set\x20the\x20field\x20to\x20an\x20empty\x20object,\x20i.e.\x20`{\"a\
    udio\":\x20{}}`\n\x20\x20-\x20data.image\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20-\x20filter\x20only\x20image\x20inputs\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20-\x20enable\x20using\x20`{\"image\":\x20{}}`\n\x20\x20-\
    \x20data.text\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\
    \x20filter\x20only\x20text\x20inputs\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    -\x20enable\x20using\x20`{\"text\":\x20{}}`\n\x20\x20-\x20data.video\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20only\x20video\
    \x20inputs\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20enable\x20using\x20`{\"\
    video\":\x20{}}`\n\x20\x20-\x20dataset_ids[]\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20-\x20filter\x20by\x20dataset\x20IDs\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20-\x20example:\x20`{\"dataset_ids\":\x20[\"d1\",\x20\"d2\"]}`\x20\
    will\x20filter\x20for\x20inputs\x20in\x20d1\x20OR\x20d2\n\x20\x20-\x20st\
    atus.code\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20filter\x20b\
    y\x20input\x20status\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20example:\
    \x20`{\"status\":\x20{\"code\":\x2030000}}`\x20to\x20filter\x20only\x20f\
    or\x20SUCCESS\x20inputs\n\n\r\n\x05\x04p\x02\x02\x06\x12\x04\xa0\x13\x02\
    \x07\n\r\n\x05\x04p\x02\x02\x01\x12\x04\xa0\x13\x08\r\n\r\n\x05\x04p\x02\
    \x02\x03\x12\x04\xa0\x13\x10\x11\n=\n\x04\x04p\x02\x03\x12\x04\xa3\x13\
    \x02(\x1a/\x20Filter\x20by\x20annotation\x20last\x20updated\x20time\x20r\
    ange.\n\n\r\n\x05\x04p\x02\x03\x06\x12\x04\xa3\x13\x02\x0b\n\r\n\x05\x04\
    p\x02\x03\x01\x12\x04\xa3\x13\x0c#\n\r\n\x05\x04p\x02\x03\x03\x12\x04\
    \xa3\x13&'\n\x19\n\x02\x04q\x12\x06\xa7\x13\0\xaa\x13\x01\x1a\x0b\x20Tim\
    eRange\n\n\x0b\n\x03\x04q\x01\x12\x04\xa7\x13\x08\x11\n=\n\x04\x04q\x02\
    \0\x12\x04\xa8\x13\x02+\"/\x20Begin\x20of\x20the\x20time\x20range,\x20op\
    tional,\x20inclusive.\n\n\r\n\x05\x04q\x02\0\x06\x12\x04\xa8\x13\x02\x1b\
    \n\r\n\x05\x04q\x02\0\x01\x12\x04\xa8\x13\x1c&\n\r\n\x05\x04q\x02\0\x03\
    \x12\x04\xa8\x13)*\n;\n\x04\x04q\x02\x01\x12\x04\xa9\x13\x02)\"-\x20End\
    \x20of\x20the\x20time\x20range,\x20optional,\x20inclusive.\n\n\r\n\x05\
    \x04q\x02\x01\x06\x12\x04\xa9\x13\x02\x1b\n\r\n\x05\x04q\x02\x01\x01\x12\
    \x04\xa9\x13\x1c$\n\r\n\x05\x04q\x02\x01\x03\x12\x04\xa9\x13'(\n\x14\n\
    \x02\x04r\x12\x06\xad\x13\0\xbf\x13\x01\x1a\x06\x20Rank\n\n\x0b\n\x03\
    \x04r\x01\x12\x04\xad\x13\x08\x0c\nw\n\x04\x04r\x02\0\x12\x04\xb0\x13\
    \x02\x12\x1ai\x20If\x20True\x20then\x20this\x20will\x20flip\x20the\x20me\
    aning\x20of\x20this\x20part\x20of\x20the\n\x20query.\x20This\x20allow\
    \x20for\x20queries\x20such\x20as\x20!dog\n\n\r\n\x05\x04r\x02\0\x05\x12\
    \x04\xb0\x13\x02\x06\n\r\n\x05\x04r\x02\0\x01\x12\x04\xb0\x13\x07\r\n\r\
    \n\x05\x04r\x02\0\x03\x12\x04\xb0\x13\x10\x11\n\xc5\x02\n\x04\x04r\x02\
    \x01\x12\x04\xbe\x13\x02\x1c\x1a\xb6\x02\x20RANK\x20by\x20annotation\x20\
    information.\n\x20##########\x20Supported\x20fields\x20##########\n\x20\
    \x20-\x20data.concepts[].id\n\x20\x20-\x20data.concepts[].name\n\x20\x20\
    -\x20data.concepts[].value\n\x20\x20-\x20data.embeddings[].num_dimension\
    s\n\x20\x20-\x20data.embeddings[].vector[]\n\x20\x20-\x20data.image.base\
    64[]\n\x20\x20-\x20data.image.url\n\x20\x20-\x20data.text.raw\n\x20\x20-\
    \x20input_id\n\x20\x20-\x20model_version_id\n\n\r\n\x05\x04r\x02\x01\x06\
    \x12\x04\xbe\x13\x02\x0c\n\r\n\x05\x04r\x02\x01\x01\x12\x04\xbe\x13\r\
    \x17\n\r\n\x05\x04r\x02\x01\x03\x12\x04\xbe\x13\x1a\x1b\n'\n\x02\x04s\
    \x12\x06\xc2\x13\0\xd6\x13\x01\x1a\x19\x20AnnotationSearchMetrics\n\n\
    \x0b\n\x03\x04s\x01\x12\x04\xc2\x13\x08\x1f\n:\n\x04\x04s\x02\0\x12\x04\
    \xc4\x13\x02'\x1a,\x20The\x20ground\x20truth\x20we\x20are\x20evaluating\
    \x20against\n\n\r\n\x05\x04s\x02\0\x06\x12\x04\xc4\x13\x02\x15\n\r\n\x05\
    \x04s\x02\0\x01\x12\x04\xc4\x13\x16\"\n\r\n\x05\x04s\x02\0\x03\x12\x04\
    \xc4\x13%&\n)\n\x04\x04s\x02\x01\x12\x04\xc7\x13\x02)\x1a\x1b\x20The\x20\
    set\x20we\x20are\x20evaluating\n\n\r\n\x05\x04s\x02\x01\x06\x12\x04\xc7\
    \x13\x02\x15\n\r\n\x05\x04s\x02\x01\x01\x12\x04\xc7\x13\x16$\n\r\n\x05\
    \x04s\x02\x01\x03\x12\x04\xc7\x13'(\n!\n\x04\x04s\x02\x02\x12\x04\xca\
    \x13\x02\x1a\x1a\x13\x20The\x20metric\x20result\n\n\r\n\x05\x04s\x02\x02\
    \x06\x12\x04\xca\x13\x02\r\n\r\n\x05\x04s\x02\x02\x01\x12\x04\xca\x13\
    \x0e\x15\n\r\n\x05\x04s\x02\x02\x03\x12\x04\xca\x13\x18\x19\nM\n\x04\x04\
    s\x02\x03\x12\x04\xcd\x13\x02\x10\x1a?\x20data\x20is\x20filled\x20out\
    \x20with\x20the\x20concepts\x20used\x20for\x20this\x20evaluation\n\n\r\n\
    \x05\x04s\x02\x03\x06\x12\x04\xcd\x13\x02\x06\n\r\n\x05\x04s\x02\x03\x01\
    \x12\x04\xcd\x13\x07\x0b\n\r\n\x05\x04s\x02\x03\x03\x12\x04\xcd\x13\x0e\
    \x0f\nR\n\x04\x04s\x02\x04\x12\x04\xd0\x13\x02\"\x1aD\x20active_concept_\
    count\x20is\x20the\x20number\x20of\x20concepts\x20for\x20this\x20evaluat\
    ion\n\n\r\n\x05\x04s\x02\x04\x05\x12\x04\xd0\x13\x02\x08\n\r\n\x05\x04s\
    \x02\x04\x01\x12\x04\xd0\x13\t\x1d\n\r\n\x05\x04s\x02\x04\x03\x12\x04\
    \xd0\x13\x20!\n\xdd\x01\n\x04\x04s\x02\x05\x12\x04\xd5\x13\x02\x1c\x1a\
    \xce\x01\x20The\x20visibility\x20field\x20represents\x20whether\x20this\
    \x20message\x20is\x20privately/publicly\x20visible.\n\x20To\x20be\x20vis\
    ible\x20to\x20the\x20public\x20the\x20App\x20that\x20contains\x20it\x20A\
    ND\x20the\x20User\x20that\x20contains\x20the\x20App\x20must\n\x20also\
    \x20be\x20publicly\x20visible.\n\n\r\n\x05\x04s\x02\x05\x06\x12\x04\xd5\
    \x13\x02\x0c\n\r\n\x05\x04s\x02\x05\x01\x12\x04\xd5\x13\r\x17\n\r\n\x05\
    \x04s\x02\x05\x03\x12\x04\xd5\x13\x1a\x1b\n\x14\n\x02\x04t\x12\x06\xdc\
    \x13\0\xe7\x13\x01\x1a\x06\x20Text\n\n\x0b\n\x03\x04t\x01\x12\x04\xdc\
    \x13\x08\x0c\n*\n\x04\x04t\x02\0\x12\x04\xde\x13\x02\x11\x1a\x1c\x20This\
    \x20is\x20a\x20raw\x20text\x20string.\n\n\r\n\x05\x04t\x02\0\x05\x12\x04\
    \xde\x13\x02\x08\n\r\n\x05\x04t\x02\0\x01\x12\x04\xde\x13\t\x0c\n\r\n\
    \x05\x04t\x02\0\x03\x12\x04\xde\x13\x0f\x10\n\"\n\x04\x04t\x02\x01\x12\
    \x04\xe0\x13\x02\x11\x1a\x14\x20Url\x20to\x20a\x20text\x20file\n\n\r\n\
    \x05\x04t\x02\x01\x05\x12\x04\xe0\x13\x02\x08\n\r\n\x05\x04t\x02\x01\x01\
    \x12\x04\xe0\x13\t\x0c\n\r\n\x05\x04t\x02\x01\x03\x12\x04\xe0\x13\x0f\
    \x10\n\x0c\n\x04\x04t\x02\x02\x12\x04\xe1\x13\x02\x1f\n\r\n\x05\x04t\x02\
    \x02\x05\x12\x04\xe1\x13\x02\x06\n\r\n\x05\x04t\x02\x02\x01\x12\x04\xe1\
    \x13\x07\x1a\n\r\n\x05\x04t\x02\x02\x03\x12\x04\xe1\x13\x1d\x1e\n\x80\
    \x01\n\x04\x04t\x02\x03\x12\x04\xe4\x13\x02\x17\x1ar\x20The\x20hosted\
    \x20field\x20lists\x20original\x20text\x20hosted\x20in\x20Clarifai\x20st\
    orage.\x20This\x20field\x20is\x20currently\x20used\n\x20only\x20in\x20re\
    sponse.\n\n\r\n\x05\x04t\x02\x03\x06\x12\x04\xe4\x13\x02\x0b\n\r\n\x05\
    \x04t\x02\x03\x01\x12\x04\xe4\x13\x0c\x12\n\r\n\x05\x04t\x02\x03\x03\x12\
    \x04\xe4\x13\x15\x16\n\x19\n\x04\x04t\x02\x04\x12\x04\xe6\x13\x02\x19\
    \x1a\x0b\x20text\x20info\n\n\r\n\x05\x04t\x02\x04\x06\x12\x04\xe6\x13\
    \x02\n\n\r\n\x05\x04t\x02\x04\x01\x12\x04\xe6\x13\x0b\x14\n\r\n\x05\x04t\
    \x02\x04\x03\x12\x04\xe6\x13\x17\x18\n\x0c\n\x02\x04u\x12\x06\xe9\x13\0\
    \xee\x13\x01\n\x0b\n\x03\x04u\x01\x12\x04\xe9\x13\x08\x10\n+\n\x04\x04u\
    \x02\0\x12\x04\xeb\x13\x02\x17\x1a\x1d\x20count\x20of\x20characters\x20i\
    n\x20text\n\n\r\n\x05\x04u\x02\0\x05\x12\x04\xeb\x13\x02\x07\n\r\n\x05\
    \x04u\x02\0\x01\x12\x04\xeb\x13\x08\x12\n\r\n\x05\x04u\x02\0\x03\x12\x04\
    \xeb\x13\x15\x16\n\x1d\n\x04\x04u\x02\x01\x12\x04\xed\x13\x02\x16\x1a\
    \x0f\x20text\x20encoding\n\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xed\x13\
    \x02\x08\n\r\n\x05\x04u\x02\x01\x01\x12\x04\xed\x13\t\x11\n\r\n\x05\x04u\
    \x02\x01\x03\x12\x04\xed\x13\x14\x15\n\x0c\n\x02\x05\t\x12\x06\xf5\x13\0\
    \xfe\x13\x01\n\x0b\n\x03\x05\t\x01\x12\x04\xf5\x13\x05\x11\n\x0c\n\x04\
    \x05\t\x02\0\x12\x04\xf6\x13\x02\x1d\n\r\n\x05\x05\t\x02\0\x01\x12\x04\
    \xf6\x13\x02\x18\n\r\n\x05\x05\t\x02\0\x02\x12\x04\xf6\x13\x1b\x1c\n#\n\
    \x04\x05\t\x02\x01\x12\x04\xf9\x13\x02\x16\x1a\x15\x20On\x20Prem\x20even\
    t\x20types\n\n\r\n\x05\x05\t\x02\x01\x01\x12\x04\xf9\x13\x02\x11\n\r\n\
    \x05\x05\t\x02\x01\x02\x12\x04\xf9\x13\x14\x15\n\x0c\n\x04\x05\t\x02\x02\
    \x12\x04\xfa\x13\x02\x14\n\r\n\x05\x05\t\x02\x02\x01\x12\x04\xfa\x13\x02\
    \x0f\n\r\n\x05\x05\t\x02\x02\x02\x12\x04\xfa\x13\x12\x13\n\x0c\n\x04\x05\
    \t\x02\x03\x12\x04\xfb\x13\x02\x15\n\r\n\x05\x05\t\x02\x03\x01\x12\x04\
    \xfb\x13\x02\x10\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\xfb\x13\x13\x14\n\
    \x0c\n\x02\x05\n\x12\x06\x80\x14\0\x86\x14\x01\n\x0b\n\x03\x05\n\x01\x12\
    \x04\x80\x14\x05\x16\nb\n\x04\x05\n\x02\0\x12\x04\x82\x14\x02\x0c\x1aT\
    \x20undef\x20UsageIntervalType\x20is\x20so\x20that\x20the\x20interval\
    \x20field\x20can\x20be\x20forced\x20to\x20be\x20included\n\n\r\n\x05\x05\
    \n\x02\0\x01\x12\x04\x82\x14\x02\x07\n\r\n\x05\x05\n\x02\0\x02\x12\x04\
    \x82\x14\n\x0b\n\x0c\n\x04\x05\n\x02\x01\x12\x04\x83\x14\x02\n\n\r\n\x05\
    \x05\n\x02\x01\x01\x12\x04\x83\x14\x02\x05\n\r\n\x05\x05\n\x02\x01\x02\
    \x12\x04\x83\x14\x08\t\n\x0c\n\x04\x05\n\x02\x02\x12\x04\x84\x14\x02\x0c\
    \n\r\n\x05\x05\n\x02\x02\x01\x12\x04\x84\x14\x02\x07\n\r\n\x05\x05\n\x02\
    \x02\x02\x12\x04\x84\x14\n\x0b\n\x0c\n\x04\x05\n\x02\x03\x12\x04\x85\x14\
    \x02\x0b\n\r\n\x05\x05\n\x02\x03\x01\x12\x04\x85\x14\x02\x06\n\r\n\x05\
    \x05\n\x02\x03\x02\x12\x04\x85\x14\t\n\n\x14\n\x02\x04v\x12\x06\x8a\x14\
    \0\xbc\x14\x01\x1a\x06\x20User\n\n\x0b\n\x03\x04v\x01\x12\x04\x8a\x14\
    \x08\x0c\n\x0b\n\x03\x04v\t\x12\x04\x8b\x14\x02\x12\n\x0c\n\x04\x04v\t\0\
    \x12\x04\x8b\x14\x0b\r\n\r\n\x05\x04v\t\0\x01\x12\x04\x8b\x14\x0b\r\n\r\
    \n\x05\x04v\t\0\x02\x12\x04\x8b\x14\x0b\r\n\x0c\n\x04\x04v\t\x01\x12\x04\
    \x8b\x14\x0f\x11\n\r\n\x05\x04v\t\x01\x01\x12\x04\x8b\x14\x0f\x11\n\r\n\
    \x05\x04v\t\x01\x02\x12\x04\x8b\x14\x0f\x11\n\x0c\n\x04\x04v\x02\0\x12\
    \x04\x8d\x14\x02\x10\n\r\n\x05\x04v\x02\0\x05\x12\x04\x8d\x14\x02\x08\n\
    \r\n\x05\x04v\x02\0\x01\x12\x04\x8d\x14\t\x0b\n\r\n\x05\x04v\x02\0\x03\
    \x12\x04\x8d\x14\x0e\x0f\n\x0c\n\x04\x04v\x02\x01\x12\x04\x8f\x14\x02/\n\
    \r\n\x05\x04v\x02\x01\x05\x12\x04\x8f\x14\x02\x08\n\r\n\x05\x04v\x02\x01\
    \x01\x12\x04\x8f\x14\t\x16\n\r\n\x05\x04v\x02\x01\x03\x12\x04\x8f\x14\
    \x19\x1a\n\r\n\x05\x04v\x02\x01\x08\x12\x04\x8f\x14\x1b.\n\x0e\n\x06\x04\
    v\x02\x01\x08\x03\x12\x04\x8f\x14\x1c-\n\x0c\n\x04\x04v\x02\x02\x12\x04\
    \x90\x14\x02\x18\n\r\n\x05\x04v\x02\x02\x05\x12\x04\x90\x14\x02\x08\n\r\
    \n\x05\x04v\x02\x02\x01\x12\x04\x90\x14\t\x13\n\r\n\x05\x04v\x02\x02\x03\
    \x12\x04\x90\x14\x16\x17\n\x0c\n\x04\x04v\x02\x03\x12\x04\x91\x14\x02\
    \x17\n\r\n\x05\x04v\x02\x03\x05\x12\x04\x91\x14\x02\x08\n\r\n\x05\x04v\
    \x02\x03\x01\x12\x04\x91\x14\t\x12\n\r\n\x05\x04v\x02\x03\x03\x12\x04\
    \x91\x14\x15\x16\n\x0c\n\x04\x04v\x02\x04\x12\x04\x92\x14\x02\x1a\n\r\n\
    \x05\x04v\x02\x04\x05\x12\x04\x92\x14\x02\x08\n\r\n\x05\x04v\x02\x04\x01\
    \x12\x04\x92\x14\t\x15\n\r\n\x05\x04v\x02\x04\x03\x12\x04\x92\x14\x18\
    \x19\n\x0c\n\x04\x04v\x02\x05\x12\x04\x93\x14\x02\x18\n\r\n\x05\x04v\x02\
    \x05\x05\x12\x04\x93\x14\x02\x08\n\r\n\x05\x04v\x02\x05\x01\x12\x04\x93\
    \x14\t\x12\n\r\n\x05\x04v\x02\x05\x03\x12\x04\x93\x14\x15\x17\n\x0c\n\
    \x04\x04v\x02\x06\x12\x04\x94\x14\x02\x17\n\r\n\x05\x04v\x02\x06\x05\x12\
    \x04\x94\x14\x02\x08\n\r\n\x05\x04v\x02\x06\x01\x12\x04\x94\x14\t\x11\n\
    \r\n\x05\x04v\x02\x06\x03\x12\x04\x94\x14\x14\x16\nG\n\x04\x04v\x02\x07\
    \x12\x04\x96\x14\x02\x18\x1a9\x20This\x20specifies\x20user\x20intent\x20\
    when\x20registering\x20on\x20clarifai\n\n\r\n\x05\x04v\x02\x07\x05\x12\
    \x04\x96\x14\x02\x08\n\r\n\x05\x04v\x02\x07\x01\x12\x04\x96\x14\t\x12\n\
    \r\n\x05\x04v\x02\x07\x03\x12\x04\x96\x14\x15\x17\n\x0c\n\x04\x04v\x02\
    \x08\x12\x04\x97\x14\x02+\n\r\n\x05\x04v\x02\x08\x05\x12\x04\x97\x14\x02\
    \x08\n\r\n\x05\x04v\x02\x08\x01\x12\x04\x97\x14\t\x12\n\r\n\x05\x04v\x02\
    \x08\x03\x12\x04\x97\x14\x15\x16\n\r\n\x05\x04v\x02\x08\x08\x12\x04\x97\
    \x14\x17*\n\x0e\n\x06\x04v\x02\x08\x08\x03\x12\x04\x97\x14\x18)\n\xff\
    \x01\n\x04\x04v\x02\t\x12\x04\x9e\x14\x02+\x1a\xf0\x01\x20When\x20the\
    \x20user\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20timestamp\
    \n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\x20fo\
    rmat:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20expect\
    \x20results\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\x20\"\
    2017-04-11T21:50:50.223962Z\"\n\n\r\n\x05\x04v\x02\t\x06\x12\x04\x9e\x14\
    \x02\x1b\n\r\n\x05\x04v\x02\t\x01\x12\x04\x9e\x14\x1c&\n\r\n\x05\x04v\
    \x02\t\x03\x12\x04\x9e\x14)*\n\x0c\n\x04\x04v\x02\n\x12\x04\x9f\x14\x02F\
    \n\r\n\x05\x04v\x02\n\x06\x12\x04\x9f\x14\x02\x1b\n\r\n\x05\x04v\x02\n\
    \x01\x12\x04\x9f\x14\x1c-\n\r\n\x05\x04v\x02\n\x03\x12\x04\x9f\x1401\n\r\
    \n\x05\x04v\x02\n\x08\x12\x04\x9f\x142E\n\x0e\n\x06\x04v\x02\n\x08\x03\
    \x12\x04\x9f\x143D\n\x0c\n\x04\x04v\x02\x0b\x12\x04\xa0\x14\x02E\n\r\n\
    \x05\x04v\x02\x0b\x06\x12\x04\xa0\x14\x02\x1b\n\r\n\x05\x04v\x02\x0b\x01\
    \x12\x04\xa0\x14\x1c,\n\r\n\x05\x04v\x02\x0b\x03\x12\x04\xa0\x14/0\n\r\n\
    \x05\x04v\x02\x0b\x08\x12\x04\xa0\x141D\n\x0e\n\x06\x04v\x02\x0b\x08\x03\
    \x12\x04\xa0\x142C\n\x0c\n\x04\x04v\x02\x0c\x12\x04\xa1\x14\x02L\n\r\n\
    \x05\x04v\x02\x0c\x06\x12\x04\xa1\x14\x02\x1b\n\r\n\x05\x04v\x02\x0c\x01\
    \x12\x04\xa1\x14\x1c2\n\r\n\x05\x04v\x02\x0c\x03\x12\x04\xa1\x1457\n\r\n\
    \x05\x04v\x02\x0c\x08\x12\x04\xa1\x148K\n\x0e\n\x06\x04v\x02\x0c\x08\x03\
    \x12\x04\xa1\x149J\n\x0c\n\x04\x04v\x02\r\x12\x04\xa2\x14\x02F\n\r\n\x05\
    \x04v\x02\r\x06\x12\x04\xa2\x14\x02\x1b\n\r\n\x05\x04v\x02\r\x01\x12\x04\
    \xa2\x14\x1c,\n\r\n\x05\x04v\x02\r\x03\x12\x04\xa2\x14/1\n\r\n\x05\x04v\
    \x02\r\x08\x12\x04\xa2\x142E\n\x0e\n\x06\x04v\x02\r\x08\x03\x12\x04\xa2\
    \x143D\n\x9f\x01\n\x04\x04v\x02\x0e\x12\x04\xa6\x14\x02;\x1a\x90\x01\x20\
    To\x20handle\x20arbitrary\x20json\x20metadata\x20you\x20can\x20use\x20a\
    \x20struct\x20field:\n\x20https://github.com/google/protobuf/blob/master\
    /src/google/protobuf/struct.proto\n\n\r\n\x05\x04v\x02\x0e\x06\x12\x04\
    \xa6\x14\x02\x18\n\r\n\x05\x04v\x02\x0e\x01\x12\x04\xa6\x14\x19!\n\r\n\
    \x05\x04v\x02\x0e\x03\x12\x04\xa6\x14$&\n\r\n\x05\x04v\x02\x0e\x08\x12\
    \x04\xa6\x14':\n\x0e\n\x06\x04v\x02\x0e\x08\x03\x12\x04\xa6\x14(9\n\x0c\
    \n\x04\x04v\x02\x0f\x12\x04\xa7\x14\x02A\n\r\n\x05\x04v\x02\x0f\x04\x12\
    \x04\xa7\x14\x02\n\n\r\n\x05\x04v\x02\x0f\x06\x12\x04\xa7\x14\x0b\x17\n\
    \r\n\x05\x04v\x02\x0f\x01\x12\x04\xa7\x14\x18'\n\r\n\x05\x04v\x02\x0f\
    \x03\x12\x04\xa7\x14*,\n\r\n\x05\x04v\x02\x0f\x08\x12\x04\xa7\x14-@\n\
    \x0e\n\x06\x04v\x02\x0f\x08\x03\x12\x04\xa7\x14.?\n\x0c\n\x04\x04v\x02\
    \x10\x12\x04\xa9\x14\x028\n\r\n\x05\x04v\x02\x10\x05\x12\x04\xa9\x14\x02\
    \x06\n\r\n\x05\x04v\x02\x10\x01\x12\x04\xa9\x14\x07\x1e\n\r\n\x05\x04v\
    \x02\x10\x03\x12\x04\xa9\x14!#\n\r\n\x05\x04v\x02\x10\x08\x12\x04\xa9\
    \x14$7\n\x0e\n\x06\x04v\x02\x10\x08\x03\x12\x04\xa9\x14%6\n\x0c\n\x04\
    \x04v\x02\x11\x12\x04\xaa\x14\x02.\n\r\n\x05\x04v\x02\x11\x05\x12\x04\
    \xaa\x14\x02\x08\n\r\n\x05\x04v\x02\x11\x01\x12\x04\xaa\x14\t\x14\n\r\n\
    \x05\x04v\x02\x11\x03\x12\x04\xaa\x14\x17\x19\n\r\n\x05\x04v\x02\x11\x08\
    \x12\x04\xaa\x14\x1a-\n\x0e\n\x06\x04v\x02\x11\x08\x03\x12\x04\xaa\x14\
    \x1b,\n\xa0\x01\n\x04\x04v\x02\x12\x12\x04\xae\x14\x02\x17\x1a\x91\x01\
    \x20Is\x20starred\x20by\x20the\x20requesting\x20user\x20(only\x20showed\
    \x20on\x20get/list\x20requests)\n\x20Please\x20use\x20PostUserStars/Dele\
    teUserStars\x20endpoints\x20to\x20star/unstar\x20an\x20user\n\n\r\n\x05\
    \x04v\x02\x12\x05\x12\x04\xae\x14\x02\x06\n\r\n\x05\x04v\x02\x12\x01\x12\
    \x04\xae\x14\x07\x11\n\r\n\x05\x04v\x02\x12\x03\x12\x04\xae\x14\x14\x16\
    \nu\n\x04\x04v\x02\x13\x12\x04\xb1\x14\x02\x18\x1ag\x20How\x20many\x20us\
    ers\x20have\x20starred\x20the\x20user\x20(only\x20showed\x20on\x20get/li\
    st\x20requests)\n\x20Computed\x20value,\x20not\x20editable\n\n\r\n\x05\
    \x04v\x02\x13\x05\x12\x04\xb1\x14\x02\x07\n\r\n\x05\x04v\x02\x13\x01\x12\
    \x04\xb1\x14\x08\x12\n\r\n\x05\x04v\x02\x13\x03\x12\x04\xb1\x14\x15\x17\
    \n\xdd\x01\n\x04\x04v\x02\x14\x12\x04\xb6\x14\x02\x1d\x1a\xce\x01\x20The\
    \x20visibility\x20field\x20represents\x20whether\x20this\x20message\x20i\
    s\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20th\
    e\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20Use\
    r\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\
    \x20visible.\n\n\r\n\x05\x04v\x02\x14\x06\x12\x04\xb6\x14\x02\x0c\n\r\n\
    \x05\x04v\x02\x14\x01\x12\x04\xb6\x14\r\x17\n\r\n\x05\x04v\x02\x14\x03\
    \x12\x04\xb6\x14\x1a\x1c\n\xce\x01\n\x04\x04v\x02\x15\x12\x04\xbb\x14\
    \x02\x1e\x1a\xbf\x01\x20This\x20is\x20all\x20the\x20personal\x20informat\
    ion\x20of\x20a\x20user.\x20GetUser/ListUsers\x20will\x20not\x20return\
    \x20this\n\x20information\x20unless\x20the\x20caller\x20has\x20the\x20Us\
    erAccounts_Get\x20scope\x20on\x20their\x20key\x20or\x20is\x20the\x20user\
    \n\x20themselves.\n\n\r\n\x05\x04v\x02\x15\x06\x12\x04\xbb\x14\x02\x0c\n\
    \r\n\x05\x04v\x02\x15\x01\x12\x04\xbb\x14\r\x18\n\r\n\x05\x04v\x02\x15\
    \x03\x12\x04\xbb\x14\x1b\x1d\n\xd6\x01\n\x02\x04w\x12\x06\xc0\x14\0\xd2\
    \x14\x01\x1a\xc7\x01\x20This\x20message\x20holds\x20the\x20confidential\
    \x20information\x20from\x20the\x20User\x20object\x20that\x20we\x20don't\
    \x20want\x20to\x20expose\n\x20to\x20other\x20users.\x20It\x20will\x20be\
    \x20accessible\x20only\x20from\x20/users/{user_id}/account\x20and\x20wit\
    h\x20the\x20User\x20scopes.\n\n\x0b\n\x03\x04w\x01\x12\x04\xc0\x14\x08\
    \x12\n\x0b\n\x03\x04w\t\x12\x04\xc1\x14\x02\r\n\x0c\n\x04\x04w\t\0\x12\
    \x04\xc1\x14\x0b\x0c\n\r\n\x05\x04w\t\0\x01\x12\x04\xc1\x14\x0b\x0c\n\r\
    \n\x05\x04w\t\0\x02\x12\x04\xc1\x14\x0b\x0c\n\x0c\n\x04\x04w\x02\0\x12\
    \x04\xc3\x14\x02\x1b\n\r\n\x05\x04w\x02\0\x05\x12\x04\xc3\x14\x02\x08\n\
    \r\n\x05\x04w\x02\0\x01\x12\x04\xc3\x14\t\x16\n\r\n\x05\x04w\x02\0\x03\
    \x12\x04\xc3\x14\x19\x1a\n\x0c\n\x04\x04w\x02\x01\x12\x04\xc4\x14\x02\
    \x17\n\r\n\x05\x04w\x02\x01\x05\x12\x04\xc4\x14\x02\x08\n\r\n\x05\x04w\
    \x02\x01\x01\x12\x04\xc4\x14\t\x12\n\r\n\x05\x04w\x02\x01\x03\x12\x04\
    \xc4\x14\x15\x16\n\x0c\n\x04\x04w\x02\x02\x12\x04\xc5\x14\x022\n\r\n\x05\
    \x04w\x02\x02\x06\x12\x04\xc5\x14\x02\x1b\n\r\n\x05\x04w\x02\x02\x01\x12\
    \x04\xc5\x14\x1c-\n\r\n\x05\x04w\x02\x02\x03\x12\x04\xc5\x1401\n\x0c\n\
    \x04\x04w\x02\x03\x12\x04\xc6\x14\x021\n\r\n\x05\x04w\x02\x03\x06\x12\
    \x04\xc6\x14\x02\x1b\n\r\n\x05\x04w\x02\x03\x01\x12\x04\xc6\x14\x1c,\n\r\
    \n\x05\x04w\x02\x03\x03\x12\x04\xc6\x14/0\n\x0c\n\x04\x04w\x02\x04\x12\
    \x04\xc7\x14\x027\n\r\n\x05\x04w\x02\x04\x06\x12\x04\xc7\x14\x02\x1b\n\r\
    \n\x05\x04w\x02\x04\x01\x12\x04\xc7\x14\x1c2\n\r\n\x05\x04w\x02\x04\x03\
    \x12\x04\xc7\x1456\n\x0c\n\x04\x04w\x02\x05\x12\x04\xc8\x14\x022\n\r\n\
    \x05\x04w\x02\x05\x06\x12\x04\xc8\x14\x02\x1b\n\r\n\x05\x04w\x02\x05\x01\
    \x12\x04\xc8\x14\x1c,\n\r\n\x05\x04w\x02\x05\x03\x12\x04\xc8\x14/1\n\x9f\
    \x01\n\x04\x04w\x02\x06\x12\x04\xcc\x14\x02&\x1a\x90\x01\x20To\x20handle\
    \x20arbitrary\x20json\x20metadata\x20you\x20can\x20use\x20a\x20struct\
    \x20field:\n\x20https://github.com/google/protobuf/blob/master/src/googl\
    e/protobuf/struct.proto\n\n\r\n\x05\x04w\x02\x06\x06\x12\x04\xcc\x14\x02\
    \x18\n\r\n\x05\x04w\x02\x06\x01\x12\x04\xcc\x14\x19!\n\r\n\x05\x04w\x02\
    \x06\x03\x12\x04\xcc\x14$%\n\x0c\n\x04\x04w\x02\x07\x12\x04\xcd\x14\x02,\
    \n\r\n\x05\x04w\x02\x07\x04\x12\x04\xcd\x14\x02\n\n\r\n\x05\x04w\x02\x07\
    \x06\x12\x04\xcd\x14\x0b\x17\n\r\n\x05\x04w\x02\x07\x01\x12\x04\xcd\x14\
    \x18'\n\r\n\x05\x04w\x02\x07\x03\x12\x04\xcd\x14*+\n\x0c\n\x04\x04w\x02\
    \x08\x12\x04\xce\x14\x02#\n\r\n\x05\x04w\x02\x08\x05\x12\x04\xce\x14\x02\
    \x06\n\r\n\x05\x04w\x02\x08\x01\x12\x04\xce\x14\x07\x1e\n\r\n\x05\x04w\
    \x02\x08\x03\x12\x04\xce\x14!\"\n\x0c\n\x04\x04w\x02\t\x12\x04\xcf\x14\
    \x02\x1a\n\r\n\x05\x04w\x02\t\x05\x12\x04\xcf\x14\x02\x08\n\r\n\x05\x04w\
    \x02\t\x01\x12\x04\xcf\x14\t\x14\n\r\n\x05\x04w\x02\t\x03\x12\x04\xcf\
    \x14\x17\x19\n\x0c\n\x04\x04w\x02\n\x12\x04\xd0\x14\x02\x16\n\r\n\x05\
    \x04w\x02\n\x05\x12\x04\xd0\x14\x02\x08\n\r\n\x05\x04w\x02\n\x01\x12\x04\
    \xd0\x14\t\x10\n\r\n\x05\x04w\x02\n\x03\x12\x04\xd0\x14\x13\x15\n\x0c\n\
    \x04\x04w\x02\x0b\x12\x04\xd1\x14\x02\x14\n\r\n\x05\x04w\x02\x0b\x05\x12\
    \x04\xd1\x14\x02\x08\n\r\n\x05\x04w\x02\x0b\x01\x12\x04\xd1\x14\t\x0e\n\
    \r\n\x05\x04w\x02\x0b\x03\x12\x04\xd1\x14\x11\x13\n\x1c\n\x02\x04x\x12\
    \x06\xd5\x14\0\xd9\x14\x01\x1a\x0e\x20EmailAddress\n\n\x0b\n\x03\x04x\
    \x01\x12\x04\xd5\x14\x08\x14\n\x0c\n\x04\x04x\x02\0\x12\x04\xd6\x14\x02B\
    \n\r\n\x05\x04x\x02\0\x05\x12\x04\xd6\x14\x02\x08\n\r\n\x05\x04x\x02\0\
    \x01\x12\x04\xd6\x14\t\x0e\n\r\n\x05\x04x\x02\0\x03\x12\x04\xd6\x14\x11\
    \x12\n\r\n\x05\x04x\x02\0\x08\x12\x04\xd6\x14\x13A\n\x10\n\x08\x04x\x02\
    \0\x08\xd0\x86\x03\x12\x04\xd6\x14\x14@\n\x0c\n\x04\x04x\x02\x01\x12\x04\
    \xd7\x14\x02B\n\r\n\x05\x04x\x02\x01\x05\x12\x04\xd7\x14\x02\x06\n\r\n\
    \x05\x04x\x02\x01\x01\x12\x04\xd7\x14\x07\x0e\n\r\n\x05\x04x\x02\x01\x03\
    \x12\x04\xd7\x14\x11\x12\n\r\n\x05\x04x\x02\x01\x08\x12\x04\xd7\x14\x13A\
    \n\x10\n\x08\x04x\x02\x01\x08\xd0\x86\x03\x12\x04\xd7\x14\x14@\n\x0c\n\
    \x04\x04x\x02\x02\x12\x04\xd8\x14\x02C\n\r\n\x05\x04x\x02\x02\x05\x12\
    \x04\xd8\x14\x02\x06\n\r\n\x05\x04x\x02\x02\x01\x12\x04\xd8\x14\x07\x0f\
    \n\r\n\x05\x04x\x02\x02\x03\x12\x04\xd8\x14\x12\x13\n\r\n\x05\x04x\x02\
    \x02\x08\x12\x04\xd8\x14\x14B\n\x10\n\x08\x04x\x02\x02\x08\xd0\x86\x03\
    \x12\x04\xd8\x14\x15A\n\x18\n\x02\x04y\x12\x06\xde\x14\0\xe1\x14\x01\x1a\
    \n\x20Password\n\n\x0b\n\x03\x04y\x01\x12\x04\xde\x14\x08\x10\n+\n\x04\
    \x04y\x02\0\x12\x04\xe0\x14\x02\x17\x1a\x1d\x20unencrypted\x20password\
    \x20string\n\n\r\n\x05\x04y\x02\0\x05\x12\x04\xe0\x14\x02\x08\n\r\n\x05\
    \x04y\x02\0\x01\x12\x04\xe0\x14\t\x12\n\r\n\x05\x04y\x02\0\x03\x12\x04\
    \xe0\x14\x15\x16\n\"\n\x02\x04z\x12\x06\xe5\x14\0\x82\x15\x01\x1a\x14\
    \x20PasswordViolations\n\n\x0b\n\x03\x04z\x01\x12\x04\xe5\x14\x08\x1a\nK\
    \n\x04\x04z\x02\0\x12\x04\xe7\x14\x02\x1a\x1a=\x20when\x20new\x20passwor\
    d\x20length\x20is\x20shorter\x20than\x20minimum\x20length\x20set\n\n\r\n\
    \x05\x04z\x02\0\x05\x12\x04\xe7\x14\x02\x06\n\r\n\x05\x04z\x02\0\x01\x12\
    \x04\xe7\x14\x07\x15\n\r\n\x05\x04z\x02\0\x03\x12\x04\xe7\x14\x18\x19\nJ\
    \n\x04\x04z\x02\x01\x12\x04\xe9\x14\x02\x1a\x1a<\x20when\x20new\x20passw\
    ord\x20length\x20is\x20longer\x20than\x20maximum\x20length\x20set\n\n\r\
    \n\x05\x04z\x02\x01\x05\x12\x04\xe9\x14\x02\x06\n\r\n\x05\x04z\x02\x01\
    \x01\x12\x04\xe9\x14\x07\x15\n\r\n\x05\x04z\x02\x01\x03\x12\x04\xe9\x14\
    \x18\x19\nc\n\x04\x04z\x02\x02\x12\x04\xeb\x14\x02\x1d\x1aU\x20there\x20\
    is\x20no\x20upper\x20case\x20letter\x20in\x20the\x20new\x20password\x20w\
    hen\x20there\x20should\x20be\x20at\x20least\x20one\n\n\r\n\x05\x04z\x02\
    \x02\x05\x12\x04\xeb\x14\x02\x06\n\r\n\x05\x04z\x02\x02\x01\x12\x04\xeb\
    \x14\x07\x18\n\r\n\x05\x04z\x02\x02\x03\x12\x04\xeb\x14\x1b\x1c\nc\n\x04\
    \x04z\x02\x03\x12\x04\xed\x14\x02\x1d\x1aU\x20there\x20is\x20no\x20lower\
    \x20case\x20letter\x20in\x20the\x20new\x20password\x20when\x20there\x20s\
    hould\x20be\x20at\x20least\x20one\n\n\r\n\x05\x04z\x02\x03\x05\x12\x04\
    \xed\x14\x02\x06\n\r\n\x05\x04z\x02\x03\x01\x12\x04\xed\x14\x07\x18\n\r\
    \n\x05\x04z\x02\x03\x03\x12\x04\xed\x14\x1b\x1c\nZ\n\x04\x04z\x02\x04\
    \x12\x04\xef\x14\x02\x1a\x1aL\x20there\x20is\x20no\x20numerics\x20in\x20\
    the\x20new\x20password\x20when\x20there\x20should\x20be\x20at\x20least\
    \x20one\n\n\r\n\x05\x04z\x02\x04\x05\x12\x04\xef\x14\x02\x06\n\r\n\x05\
    \x04z\x02\x04\x01\x12\x04\xef\x14\x07\x15\n\r\n\x05\x04z\x02\x04\x03\x12\
    \x04\xef\x14\x18\x19\nc\n\x04\x04z\x02\x05\x12\x04\xf1\x14\x02#\x1aU\x20\
    there\x20is\x20no\x20special\x20character\x20in\x20the\x20new\x20passwor\
    d\x20when\x20there\x20should\x20be\x20at\x20least\x20one\n\n\r\n\x05\x04\
    z\x02\x05\x05\x12\x04\xf1\x14\x02\x06\n\r\n\x05\x04z\x02\x05\x01\x12\x04\
    \xf1\x14\x07\x1e\n\r\n\x05\x04z\x02\x05\x03\x12\x04\xf1\x14!\"\n\x84\x01\
    \n\x04\x04z\x02\x06\x12\x04\xf3\x14\x02\x1a\x1av\x20when\x20one\x20of\
    \x20the\x20N\x20most\x20recent\x20old\x20password\x20is\x20reused,\x20N\
    \x20is\x20specified\x20by\x20password_reuse_epoch\x20in\x20db.password_p\
    olicies\n\n\r\n\x05\x04z\x02\x06\x05\x12\x04\xf3\x14\x02\x06\n\r\n\x05\
    \x04z\x02\x06\x01\x12\x04\xf3\x14\x07\x15\n\r\n\x05\x04z\x02\x06\x03\x12\
    \x04\xf3\x14\x18\x19\nY\n\x04\x04z\x02\x07\x12\x04\xf5\x14\x02\x19\x1aK\
    \x20when\x20either\x20user's\x20first,\x20middle\x20or\x20last\x20name\
    \x20is\x20used\x20in\x20the\x20new\x20password\n\n\r\n\x05\x04z\x02\x07\
    \x05\x12\x04\xf5\x14\x02\x06\n\r\n\x05\x04z\x02\x07\x01\x12\x04\xf5\x14\
    \x07\x14\n\r\n\x05\x04z\x02\x07\x03\x12\x04\xf5\x14\x17\x18\n\x7f\n\x04\
    \x04z\x02\x08\x12\x04\xf7\x14\x02\x19\x1aq\x20when\x20first\x20part\x20o\
    f\x20user's\x20email\x20(exact\x20string\x20or\x20after\x20removing\x20s\
    pecial\x20characters)\x20is\x20used\x20in\x20the\x20new\x20password\n\n\
    \r\n\x05\x04z\x02\x08\x05\x12\x04\xf7\x14\x02\x06\n\r\n\x05\x04z\x02\x08\
    \x01\x12\x04\xf7\x14\x07\x14\n\r\n\x05\x04z\x02\x08\x03\x12\x04\xf7\x14\
    \x17\x18\nx\n\x04\x04z\x02\t\x12\x04\xf9\x14\x02!\x1aj\x20when\x20there\
    \x20are\x20confusing\x20letters\x20in\x20the\x20new\x20password,\x20such\
    \x20as\x20o\x20(first\x20character\x20of\x20'omega')\x20vs\x200\x20(zero\
    )\n\n\r\n\x05\x04z\x02\t\x05\x12\x04\xf9\x14\x02\x06\n\r\n\x05\x04z\x02\
    \t\x01\x12\x04\xf9\x14\x07\x1b\n\r\n\x05\x04z\x02\t\x03\x12\x04\xf9\x14\
    \x1e\x20\nZ\n\x04\x04z\x02\n\x12\x04\xfb\x14\x02\x20\x1aL\x20when\x20the\
    re\x20are\x20simple\x20password\x20patterns\x20used,\x20such\x20as\x2012\
    345678\x20or\x20aaaaaaa1\n\n\r\n\x05\x04z\x02\n\x05\x12\x04\xfb\x14\x02\
    \x06\n\r\n\x05\x04z\x02\n\x01\x12\x04\xfb\x14\x07\x1a\n\r\n\x05\x04z\x02\
    \n\x03\x12\x04\xfb\x14\x1d\x1f\nL\n\x04\x04z\x02\x0b\x12\x04\xfd\x14\x02\
    \x1d\x1a>\x20when\x20there\x20are\x20common\x20vocabs\x20from\x20the\x20\
    common\x20vocab\x20list\x20used\n\n\r\n\x05\x04z\x02\x0b\x05\x12\x04\xfd\
    \x14\x02\x06\n\r\n\x05\x04z\x02\x0b\x01\x12\x04\xfd\x14\x07\x17\n\r\n\
    \x05\x04z\x02\x0b\x03\x12\x04\xfd\x14\x1a\x1c\nX\n\x04\x04z\x02\x0c\x12\
    \x04\xff\x14\x02\x20\x1aJ\x20when\x20the\x20current\x20password\x20is\
    \x20contained\x20in\x20the\x20new\x20password\x20or\x20vice\x20versa\n\n\
    \r\n\x05\x04z\x02\x0c\x05\x12\x04\xff\x14\x02\x06\n\r\n\x05\x04z\x02\x0c\
    \x01\x12\x04\xff\x14\x07\x1a\n\r\n\x05\x04z\x02\x0c\x03\x12\x04\xff\x14\
    \x1d\x1f\nE\n\x04\x04z\x02\r\x12\x04\x81\x15\x02\x1e\x1a7\x20when\x20pas\
    sword\x20has\x20to\x20be\x20changed\x20becauase\x20it's\x20too\x20old\n\
    \n\r\n\x05\x04z\x02\r\x05\x12\x04\x81\x15\x02\x06\n\r\n\x05\x04z\x02\r\
    \x01\x12\x04\x81\x15\x07\x18\n\r\n\x05\x04z\x02\r\x03\x12\x04\x81\x15\
    \x1b\x1d\n\x15\n\x02\x04{\x12\x06\x85\x15\0\x9e\x15\x01\x1a\x07\x20Video\
    \n\n\x0b\n\x03\x04{\x01\x12\x04\x85\x15\x08\r\n\x86\x01\n\x04\x04{\x02\0\
    \x12\x04\x88\x15\x02\x11\x1ax\x20This\x20is\x20a\x20URL\x20to\x20a\x20pu\
    blicly\x20accessible\x20video\x20file.\x20The\x20platform\x20will\x20dow\
    nload\x20this\x20file\x20server\n\x20side\x20and\x20then\x20process.\n\n\
    \r\n\x05\x04{\x02\0\x05\x12\x04\x88\x15\x02\x08\n\r\n\x05\x04{\x02\0\x01\
    \x12\x04\x88\x15\t\x0c\n\r\n\x05\x04{\x02\0\x03\x12\x04\x88\x15\x0f\x10\
    \n\x90\x03\n\x04\x04{\x02\x01\x12\x04\x8f\x15\x02\x13\x1a\x81\x03\x20The\
    \x20base64\x20field\x20is\x20using\x20video\x20file\x20bytes\x20directly\
    \x20in\x20the\x20request.\n\x20NOTE:\x20if\x20you're\x20sending\x20a\x20\
    json\x20request,\x20then\x20this\x20MUST\x20be\x20base64\x20encoded\x20b\
    efore\x20sending\x20(hence\n\x20the\x20name\x20here).\n\x20When\x20using\
    \x20our\x20grpc\x20clients,\x20you\x20DO\x20NOT\x20need\x20to\x20base64\
    \x20encode\n\x20it\x20yourself\x20since\x20the\x20clients\x20know\x20how\
    \x20to\x20do\x20this\x20for\x20you\x20automatically\x20and\x20will\x20av\
    oid\x20the\n\x20base64\x20encoding\x20if\x20they\x20send\x20a\x20binary\
    \x20request.\n\n\r\n\x05\x04{\x02\x01\x05\x12\x04\x8f\x15\x02\x07\n\r\n\
    \x05\x04{\x02\x01\x01\x12\x04\x8f\x15\x08\x0e\n\r\n\x05\x04{\x02\x01\x03\
    \x12\x04\x8f\x15\x11\x12\n\x0c\n\x04\x04{\x02\x02\x12\x04\x90\x15\x02\
    \x1f\n\r\n\x05\x04{\x02\x02\x05\x12\x04\x90\x15\x02\x06\n\r\n\x05\x04{\
    \x02\x02\x01\x12\x04\x90\x15\x07\x1a\n\r\n\x05\x04{\x02\x02\x03\x12\x04\
    \x90\x15\x1d\x1e\n\xe0\x01\n\x04\x04{\x02\x03\x12\x04\x95\x15\x02/\x1a\
    \xd1\x01\x20URL\x20of\x20thumbnail\x20image,\x20which\x20is\x20currently\
    \x20frame\x20at\x20position\x20of\x201s.\x20This\x20field\x20is\x20curre\
    ntly\n\x20used\x20only\x20in\x20response.\n\x20Deprecated\x20in\x20favou\
    r\x20of\x20thumbnail_hosted,\x20which\x20also\x20contains\x20alternate\
    \x20sizes\x20of\x20thumbnail\n\n\r\n\x05\x04{\x02\x03\x05\x12\x04\x95\
    \x15\x02\x08\n\r\n\x05\x04{\x02\x03\x01\x12\x04\x95\x15\t\x16\n\r\n\x05\
    \x04{\x02\x03\x03\x12\x04\x95\x15\x19\x1a\n\r\n\x05\x04{\x02\x03\x08\x12\
    \x04\x95\x15\x1b.\n\x0e\n\x06\x04{\x02\x03\x08\x03\x12\x04\x95\x15\x1c-\
    \n\x81\x01\n\x04\x04{\x02\x04\x12\x04\x98\x15\x02\x17\x1as\x20The\x20hos\
    ted\x20field\x20lists\x20original\x20video\x20hosted\x20in\x20Clarifai\
    \x20storage.\x20This\x20field\x20is\x20currently\x20used\n\x20only\x20in\
    \x20response.\n\n\r\n\x05\x04{\x02\x04\x06\x12\x04\x98\x15\x02\x0b\n\r\n\
    \x05\x04{\x02\x04\x01\x12\x04\x98\x15\x0c\x12\n\r\n\x05\x04{\x02\x04\x03\
    \x12\x04\x98\x15\x15\x16\n\xb9\x01\n\x04\x04{\x02\x05\x12\x04\x9b\x15\
    \x02!\x1a\xaa\x01\x20The\x20hosted\x20field\x20lists\x20various\x20sizes\
    \x20of\x20the\x20vide\x20thumbnail\x20hosted\x20in\x20Clarifai\x20storag\
    e,\x20with\x20'thumbnail'\x20as\x20the\x20full\x20size\n\x20This\x20fiel\
    d\x20is\x20currently\x20used\x20only\x20in\x20response.\n\n\r\n\x05\x04{\
    \x02\x05\x06\x12\x04\x9b\x15\x02\x0b\n\r\n\x05\x04{\x02\x05\x01\x12\x04\
    \x9b\x15\x0c\x1c\n\r\n\x05\x04{\x02\x05\x03\x12\x04\x9b\x15\x1f\x20\n\
    \x1a\n\x04\x04{\x02\x06\x12\x04\x9d\x15\x02\x1b\x1a\x0c\x20video\x20info\
    \n\n\r\n\x05\x04{\x02\x06\x06\x12\x04\x9d\x15\x02\x0b\n\r\n\x05\x04{\x02\
    \x06\x01\x12\x04\x9d\x15\x0c\x16\n\r\n\x05\x04{\x02\x06\x03\x12\x04\x9d\
    \x15\x19\x1a\n\x0c\n\x02\x04|\x12\x06\xa0\x15\0\xaf\x15\x01\n\x0b\n\x03\
    \x04|\x01\x12\x04\xa0\x15\x08\x11\n\x15\n\x04\x04|\x02\0\x12\x04\xa2\x15\
    \x02\x12\x1a\x07\x20width\n\n\r\n\x05\x04|\x02\0\x05\x12\x04\xa2\x15\x02\
    \x07\n\r\n\x05\x04|\x02\0\x01\x12\x04\xa2\x15\x08\r\n\r\n\x05\x04|\x02\0\
    \x03\x12\x04\xa2\x15\x10\x11\n\x16\n\x04\x04|\x02\x01\x12\x04\xa4\x15\
    \x02\x13\x1a\x08\x20height\n\n\r\n\x05\x04|\x02\x01\x05\x12\x04\xa4\x15\
    \x02\x07\n\r\n\x05\x04|\x02\x01\x01\x12\x04\xa4\x15\x08\x0e\n\r\n\x05\
    \x04|\x02\x01\x03\x12\x04\xa4\x15\x11\x12\n/\n\x04\x04|\x02\x02\x12\x04\
    \xa6\x15\x02\x10\x1a!\x20Frames\x20per\x20second\x20of\x20the\x20video.\
    \n\n\r\n\x05\x04|\x02\x02\x05\x12\x04\xa6\x15\x02\x07\n\r\n\x05\x04|\x02\
    \x02\x01\x12\x04\xa6\x15\x08\x0b\n\r\n\x05\x04|\x02\x02\x03\x12\x04\xa6\
    \x15\x0e\x0f\n\x1c\n\x04\x04|\x02\x03\x12\x04\xa8\x15\x02\x1a\x1a\x0e\
    \x20video\x20format\n\n\r\n\x05\x04|\x02\x03\x05\x12\x04\xa8\x15\x02\x08\
    \n\r\n\x05\x04|\x02\x03\x01\x12\x04\xa8\x15\t\x15\n\r\n\x05\x04|\x02\x03\
    \x03\x12\x04\xa8\x15\x18\x19\n$\n\x04\x04|\x02\x04\x12\x04\xaa\x15\x02\
    \x15\x1a\x16\x20video\x20track\x20bit\x20rate\n\n\r\n\x05\x04|\x02\x04\
    \x05\x12\x04\xaa\x15\x02\x07\n\r\n\x05\x04|\x02\x04\x01\x12\x04\xaa\x15\
    \x08\x10\n\r\n\x05\x04|\x02\x04\x03\x12\x04\xaa\x15\x13\x14\n!\n\x04\x04\
    |\x02\x05\x12\x04\xac\x15\x02\x18\x1a\x13\x20video\x20frame\x20count\n\n\
    \r\n\x05\x04|\x02\x05\x05\x12\x04\xac\x15\x02\x07\n\r\n\x05\x04|\x02\x05\
    \x01\x12\x04\xac\x15\x08\x13\n\r\n\x05\x04|\x02\x05\x03\x12\x04\xac\x15\
    \x16\x17\n)\n\x04\x04|\x02\x06\x12\x04\xae\x15\x02\x1d\x1a\x1b\x20video\
    \x20duration\x20in\x20seconds\n\n\r\n\x05\x04|\x02\x06\x05\x12\x04\xae\
    \x15\x02\x07\n\r\n\x05\x04|\x02\x06\x01\x12\x04\xae\x15\x08\x18\n\r\n\
    \x05\x04|\x02\x06\x03\x12\x04\xae\x15\x1b\x1c\n\x18\n\x02\x04}\x12\x06\
    \xb3\x15\0\xef\x15\x01\x1a\n\x20Workflow\n\n\x0b\n\x03\x04}\x01\x12\x04\
    \xb3\x15\x08\x10\n*\n\x04\x04}\x02\0\x12\x04\xb5\x15\x02\x10\x1a\x1c\x20\
    The\x20workflows's\x20unique\x20id.\n\n\r\n\x05\x04}\x02\0\x05\x12\x04\
    \xb5\x15\x02\x08\n\r\n\x05\x04}\x02\0\x01\x12\x04\xb5\x15\t\x0b\n\r\n\
    \x05\x04}\x02\0\x03\x12\x04\xb5\x15\x0e\x0f\n/\n\x04\x04}\x02\x01\x12\
    \x04\xb7\x15\x02\x14\x1a!\x20The\x20app\x20the\x20workflow\x20belongs\
    \x20to\n\n\r\n\x05\x04}\x02\x01\x05\x12\x04\xb7\x15\x02\x08\n\r\n\x05\
    \x04}\x02\x01\x01\x12\x04\xb7\x15\t\x0f\n\r\n\x05\x04}\x02\x01\x03\x12\
    \x04\xb7\x15\x12\x13\n\x83\x02\n\x04\x04}\x02\x02\x12\x04\xbe\x15\x02+\
    \x1a\xf4\x01\x20When\x20the\x20workflow\x20was\x20created.\x20We\x20foll\
    ow\x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\x20https://www.\
    ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15:04:05.999999Z\"\
    \x20so\x20you\x20can\x20expect\x20results\x20like\n\x20the\x20following\
    \x20from\x20the\x20API:\n\x20\"2017-04-11T21:50:50.223962Z\"\n\n\r\n\x05\
    \x04}\x02\x02\x06\x12\x04\xbe\x15\x02\x1b\n\r\n\x05\x04}\x02\x02\x01\x12\
    \x04\xbe\x15\x1c&\n\r\n\x05\x04}\x02\x02\x03\x12\x04\xbe\x15)*\n\xa1\x01\
    \n\x04\x04}\x02\x03\x12\x04\xc2\x15\x02\"\x1a\x92\x01\x20The\x20list\x20\
    of\x20nodes\x20retrieved\x20from\x20latest\x20workflow\x20version.\n\x20\
    Each\x20node\x20can\x20specify\x20an\x20input\x20node\x20that\x20it\x20c\
    onnects\x20to\x20in\x20order\x20to\x20define\x20the\x20graph.\n\n\r\n\
    \x05\x04}\x02\x03\x04\x12\x04\xc2\x15\x02\n\n\r\n\x05\x04}\x02\x03\x06\
    \x12\x04\xc2\x15\x0b\x17\n\r\n\x05\x04}\x02\x03\x01\x12\x04\xc2\x15\x18\
    \x1d\n\r\n\x05\x04}\x02\x03\x03\x12\x04\xc2\x15\x20!\n\x9f\x01\n\x04\x04\
    }\x02\x04\x12\x04\xc6\x15\x02&\x1a\x90\x01\x20To\x20handle\x20arbitrary\
    \x20json\x20metadata\x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20\
    https://github.com/google/protobuf/blob/master/src/google/protobuf/struc\
    t.proto\n\n\r\n\x05\x04}\x02\x04\x06\x12\x04\xc6\x15\x02\x18\n\r\n\x05\
    \x04}\x02\x04\x01\x12\x04\xc6\x15\x19!\n\r\n\x05\x04}\x02\x04\x03\x12\
    \x04\xc6\x15$%\n\xdd\x01\n\x04\x04}\x02\x05\x12\x04\xcb\x15\x02\x1c\x1a\
    \xce\x01\x20The\x20visibility\x20field\x20represents\x20whether\x20this\
    \x20message\x20is\x20privately/publicly\x20visible.\n\x20To\x20be\x20vis\
    ible\x20to\x20the\x20public\x20the\x20App\x20that\x20contains\x20it\x20A\
    ND\x20the\x20User\x20that\x20contains\x20the\x20App\x20must\n\x20also\
    \x20be\x20publicly\x20visible.\n\n\r\n\x05\x04}\x02\x05\x06\x12\x04\xcb\
    \x15\x02\x0c\n\r\n\x05\x04}\x02\x05\x01\x12\x04\xcb\x15\r\x17\n\r\n\x05\
    \x04}\x02\x05\x03\x12\x04\xcb\x15\x1a\x1b\n0\n\x04\x04}\x02\x06\x12\x04\
    \xce\x15\x02\x15\x1a\"\x20The\x20user\x20the\x20workflow\x20belongs\x20t\
    o\n\n\r\n\x05\x04}\x02\x06\x05\x12\x04\xce\x15\x02\x08\n\r\n\x05\x04}\
    \x02\x06\x01\x12\x04\xce\x15\t\x10\n\r\n\x05\x04}\x02\x06\x03\x12\x04\
    \xce\x15\x13\x14\n3\n\x04\x04}\x02\x07\x12\x04\xd1\x15\x02,\x1a%\x20When\
    \x20the\x20workflow\x20was\x20last\x20modified\n\n\r\n\x05\x04}\x02\x07\
    \x06\x12\x04\xd1\x15\x02\x1b\n\r\n\x05\x04}\x02\x07\x01\x12\x04\xd1\x15\
    \x1c'\n\r\n\x05\x04}\x02\x07\x03\x12\x04\xd1\x15*+\ni\n\x04\x04}\x02\x08\
    \x12\x04\xd4\x15\x02\x1e\x1a[\x20Info\x20about\x20the\x20workflow\x20ver\
    sion\x20used\x20to\x20return\x20the\x20latest\x20version\x20when\x20list\
    ing\x20Workflows.\n\n\r\n\x05\x04}\x02\x08\x06\x12\x04\xd4\x15\x02\x11\n\
    \r\n\x05\x04}\x02\x08\x01\x12\x04\xd4\x15\x12\x19\n\r\n\x05\x04}\x02\x08\
    \x03\x12\x04\xd4\x15\x1c\x1d\n\xab\x01\n\x04\x04}\x02\t\x12\x04\xd8\x15\
    \x02\x17\x1a\x9c\x01\x20Is\x20starred\x20by\x20the\x20requesting\x20user\
    \x20(only\x20showed\x20on\x20get/list\x20requests)\n\x20Please\x20use\
    \x20PostWorkflowStars/DeleteWorkflowStars\x20endpoints\x20to\x20star/uns\
    tar\x20a\x20workflow\n\n\r\n\x05\x04}\x02\t\x05\x12\x04\xd8\x15\x02\x06\
    \n\r\n\x05\x04}\x02\t\x01\x12\x04\xd8\x15\x07\x11\n\r\n\x05\x04}\x02\t\
    \x03\x12\x04\xd8\x15\x14\x16\ny\n\x04\x04}\x02\n\x12\x04\xdb\x15\x02\x18\
    \x1ak\x20How\x20many\x20users\x20have\x20starred\x20the\x20workflow\x20(\
    only\x20showed\x20on\x20get/list\x20requests)\n\x20Computed\x20value,\
    \x20not\x20editable\n\n\r\n\x05\x04}\x02\n\x05\x12\x04\xdb\x15\x02\x07\n\
    \r\n\x05\x04}\x02\n\x01\x12\x04\xdb\x15\x08\x12\n\r\n\x05\x04}\x02\n\x03\
    \x12\x04\xdb\x15\x15\x17\n5\n\x04\x04}\x02\x0b\x12\x04\xde\x15\x02\x1a\
    \x1a'\x20Short\x20description\x20about\x20this\x20workflow\n\n\r\n\x05\
    \x04}\x02\x0b\x05\x12\x04\xde\x15\x02\x08\n\r\n\x05\x04}\x02\x0b\x01\x12\
    \x04\xde\x15\t\x14\n\r\n\x05\x04}\x02\x0b\x03\x12\x04\xde\x15\x17\x19\nn\
    \n\x04\x04}\x02\x0c\x12\x04\xe2\x15\x02\x14\x1a`\x20Notes\x20for\x20the\
    \x20workflow\n\x20This\x20field\x20should\x20be\x20used\x20for\x20in-dep\
    th\x20notes\x20and\x20supports\x20up\x20to\x2064Kbs.\n\n\r\n\x05\x04}\
    \x02\x0c\x05\x12\x04\xe2\x15\x02\x08\n\r\n\x05\x04}\x02\x0c\x01\x12\x04\
    \xe2\x15\t\x0e\n\r\n\x05\x04}\x02\x0c\x03\x12\x04\xe2\x15\x11\x13\n,\n\
    \x04\x04}\x02\r\x12\x04\xe5\x15\x02P\x1a\x1e\x20Tags\x20from\x20use_case\
    s\x20category\n\n\r\n\x05\x04}\x02\r\x04\x12\x04\xe5\x15\x02\n\n\r\n\x05\
    \x04}\x02\r\x05\x12\x04\xe5\x15\x0b\x11\n\r\n\x05\x04}\x02\r\x01\x12\x04\
    \xe5\x15\x12\x1b\n\r\n\x05\x04}\x02\r\x03\x12\x04\xe5\x15\x1e\x20\n\r\n\
    \x05\x04}\x02\r\x08\x12\x04\xe5\x15!O\n\x10\n\x08\x04}\x02\r\x08\xd0\x86\
    \x03\x12\x04\xe5\x15\"N\n'\n\x04\x04}\x02\x0e\x12\x04\xe8\x15\x02U\x1a\
    \x19\x20Tags\x20for\x20check\x20consents\n\n\r\n\x05\x04}\x02\x0e\x04\
    \x12\x04\xe8\x15\x02\n\n\r\n\x05\x04}\x02\x0e\x05\x12\x04\xe8\x15\x0b\
    \x11\n\r\n\x05\x04}\x02\x0e\x01\x12\x04\xe8\x15\x12\x20\n\r\n\x05\x04}\
    \x02\x0e\x03\x12\x04\xe8\x15#%\n\r\n\x05\x04}\x02\x0e\x08\x12\x04\xe8\
    \x15&T\n\x10\n\x08\x04}\x02\x0e\x08\xd0\x86\x03\x12\x04\xe8\x15'S\n\xa2\
    \x01\n\x04\x04}\x02\x0f\x12\x04\xec\x15\x02&\x1a\x93\x01\x20bookmark\x20\
    info.\x20When\x20set,\x20this\x20workflow\x20is\x20a\x20bookmarked\x20wo\
    rkflow\x20of\x20this\x20app.\n\x20Info\x20in\x20this\x20field\x20will\
    \x20allow\x20you\x20to\x20find/access\x20original\x20workflow.\n\n\r\n\
    \x05\x04}\x02\x0f\x06\x12\x04\xec\x15\x02\x10\n\r\n\x05\x04}\x02\x0f\x01\
    \x12\x04\xec\x15\x11\x20\n\r\n\x05\x04}\x02\x0f\x03\x12\x04\xec\x15#%\n6\
    \n\x04\x04}\x02\x10\x12\x04\xee\x15\x02\x13\x1a(\x20Representative\x20im\
    age\x20for\x20this\x20workflow\n\n\r\n\x05\x04}\x02\x10\x06\x12\x04\xee\
    \x15\x02\x07\n\r\n\x05\x04}\x02\x10\x01\x12\x04\xee\x15\x08\r\n\r\n\x05\
    \x04}\x02\x10\x03\x12\x04\xee\x15\x10\x12\n\x1f\n\x02\x04~\x12\x06\xf2\
    \x15\0\x9a\x16\x01\x1a\x11\x20WorkflowVersion\n\n\x0b\n\x03\x04~\x01\x12\
    \x04\xf2\x15\x08\x17\n#\n\x04\x04~\x02\0\x12\x04\xf4\x15\x02\x10\x1a\x15\
    \x20Id\x20of\x20this\x20version.\n\n\r\n\x05\x04~\x02\0\x05\x12\x04\xf4\
    \x15\x02\x08\n\r\n\x05\x04~\x02\0\x01\x12\x04\xf4\x15\t\x0b\n\r\n\x05\
    \x04~\x02\0\x03\x12\x04\xf4\x15\x0e\x0f\n-\n\x04\x04~\x02\x01\x12\x04\
    \xf7\x15\x02\x19\x1a\x1f\x20Workflow\x20id\x20for\x20this\x20version.\n\
    \n\r\n\x05\x04~\x02\x01\x05\x12\x04\xf7\x15\x02\x08\n\r\n\x05\x04~\x02\
    \x01\x01\x12\x04\xf7\x15\t\x14\n\r\n\x05\x04~\x02\x01\x03\x12\x04\xf7\
    \x15\x17\x18\n\x8b\x01\n\x04\x04~\x02\x02\x12\x04\xfc\x15\x02+\x1a}\x20W\
    hen\x20the\x20version\x20was\x20created.\n\x20The\x20format\x20is\x20htt\
    ps://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:0\
    5.999999Z\".\n\n\r\n\x05\x04~\x02\x02\x06\x12\x04\xfc\x15\x02\x1b\n\r\n\
    \x05\x04~\x02\x02\x01\x12\x04\xfc\x15\x1c&\n\r\n\x05\x04~\x02\x02\x03\
    \x12\x04\xfc\x15)*\n\x9d\x01\n\x04\x04~\x02\x03\x12\x04\x81\x16\x02,\x1a\
    \x8e\x01\x20Most\x20recent\x20time\x20when\x20the\x20version\x20was\x20u\
    pdated.\n\x20The\x20format\x20is\x20https://www.ietf.org/rfc/rfc3339.txt\
    .\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\r\n\x05\x04~\x02\
    \x03\x06\x12\x04\x81\x16\x02\x1b\n\r\n\x05\x04~\x02\x03\x01\x12\x04\x81\
    \x16\x1c'\n\r\n\x05\x04~\x02\x03\x03\x12\x04\x81\x16*+\n\xdd\x01\n\x04\
    \x04~\x02\x04\x12\x04\x86\x16\x02\x1c\x1a\xce\x01\x20The\x20visibility\
    \x20field\x20represents\x20whether\x20this\x20message\x20is\x20privately\
    /publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20public\
    \x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20User\x20that\
    \x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20visibl\
    e.\n\n\r\n\x05\x04~\x02\x04\x06\x12\x04\x86\x16\x02\x0c\n\r\n\x05\x04~\
    \x02\x04\x01\x12\x04\x86\x16\r\x17\n\r\n\x05\x04~\x02\x04\x03\x12\x04\
    \x86\x16\x1a\x1b\n\x9c\x01\n\x04\x04~\x02\x05\x12\x04\x8a\x16\x02\"\x1a\
    \x8d\x01\x20The\x20list\x20of\x20nodes\x20that\x20make\x20up\x20the\x20w\
    orkflow\x20version.\x20Each\x20node\x20can\x20specify\x20an\x20input\x20\
    node\n\x20that\x20it\x20connects\x20to\x20in\x20order\x20to\x20define\
    \x20the\x20graph.\n\n\r\n\x05\x04~\x02\x05\x04\x12\x04\x8a\x16\x02\n\n\r\
    \n\x05\x04~\x02\x05\x06\x12\x04\x8a\x16\x0b\x17\n\r\n\x05\x04~\x02\x05\
    \x01\x12\x04\x8a\x16\x18\x1d\n\r\n\x05\x04~\x02\x05\x03\x12\x04\x8a\x16\
    \x20!\n\x9f\x01\n\x04\x04~\x02\x06\x12\x04\x8e\x16\x02&\x1a\x90\x01\x20T\
    o\x20handle\x20arbitrary\x20json\x20metadata\x20you\x20can\x20use\x20a\
    \x20struct\x20field:\n\x20https://github.com/google/protobuf/blob/master\
    /src/google/protobuf/struct.proto\n\n\r\n\x05\x04~\x02\x06\x06\x12\x04\
    \x8e\x16\x02\x18\n\r\n\x05\x04~\x02\x06\x01\x12\x04\x8e\x16\x19!\n\r\n\
    \x05\x04~\x02\x06\x03\x12\x04\x8e\x16$%\n8\n\x04\x04~\x02\x07\x12\x04\
    \x91\x16\x02\x14\x1a*\x20The\x20app\x20the\x20workflow\x20version\x20bel\
    ongs\x20to.\n\n\r\n\x05\x04~\x02\x07\x05\x12\x04\x91\x16\x02\x08\n\r\n\
    \x05\x04~\x02\x07\x01\x12\x04\x91\x16\t\x0f\n\r\n\x05\x04~\x02\x07\x03\
    \x12\x04\x91\x16\x12\x13\n9\n\x04\x04~\x02\x08\x12\x04\x93\x16\x02\x15\
    \x1a+\x20The\x20user\x20the\x20workflow\x20version\x20belongs\x20to.\n\n\
    \r\n\x05\x04~\x02\x08\x05\x12\x04\x93\x16\x02\x08\n\r\n\x05\x04~\x02\x08\
    \x01\x12\x04\x93\x16\t\x10\n\r\n\x05\x04~\x02\x08\x03\x12\x04\x93\x16\
    \x13\x14\n=\n\x04\x04~\x02\t\x12\x04\x96\x16\x02\x1a\x1a/\x20Short\x20de\
    scription\x20about\x20this\x20workflow\x20version\n\n\r\n\x05\x04~\x02\t\
    \x05\x12\x04\x96\x16\x02\x08\n\r\n\x05\x04~\x02\t\x01\x12\x04\x96\x16\t\
    \x14\n\r\n\x05\x04~\x02\t\x03\x12\x04\x96\x16\x17\x19\n;\n\x04\x04~\x02\
    \n\x12\x04\x99\x16\x02\x16\x1a-\x20License\x20associated\x20to\x20this\
    \x20workflow\x20version\n\n\r\n\x05\x04~\x02\n\x05\x12\x04\x99\x16\x02\
    \x08\n\r\n\x05\x04~\x02\n\x01\x12\x04\x99\x16\t\x10\n\r\n\x05\x04~\x02\n\
    \x03\x12\x04\x99\x16\x13\x15\n\x1c\n\x02\x04\x7f\x12\x06\x9d\x16\0\xae\
    \x16\x01\x1a\x0e\x20WorkflowNode\n\n\x0b\n\x03\x04\x7f\x01\x12\x04\x9d\
    \x16\x08\x14\nl\n\x04\x04\x7f\x02\0\x12\x04\xa0\x16\x02\x10\x1a^\x20An\
    \x20identifier\x20for\x20this\x20node\x20in\x20the\x20graph.\x20This\x20\
    is\x20used\x20when\x20connecting\x20NodeInputs\n\x20together.\n\n\r\n\
    \x05\x04\x7f\x02\0\x05\x12\x04\xa0\x16\x02\x08\n\r\n\x05\x04\x7f\x02\0\
    \x01\x12\x04\xa0\x16\t\x0b\n\r\n\x05\x04\x7f\x02\0\x03\x12\x04\xa0\x16\
    \x0e\x0f\n\x84\x01\n\x04\x04\x7f\x02\x01\x12\x04\xa4\x16\x02\x12\x1av\
    \x20The\x20model\x20that\x20will\x20do\x20the\x20processing\x20at\x20thi\
    s\x20node.\x20We\x20only\x20vlidate\x20the\x20model.id\x20and\n\x20model\
    .model_version.id\x20fields.\n\n\r\n\x05\x04\x7f\x02\x01\x06\x12\x04\xa4\
    \x16\x02\x07\n\r\n\x05\x04\x7f\x02\x01\x01\x12\x04\xa4\x16\x08\r\n\r\n\
    \x05\x04\x7f\x02\x01\x03\x12\x04\xa4\x16\x10\x11\n\x94\x01\n\x04\x04\x7f\
    \x02\x02\x12\x04\xa8\x16\x02%\x1a\x85\x01\x20Each\x20WorkflowNode\x20can\
    \x20connect\x20to\x20multiple\x20input\x20nodes\x20so\x20that\x20we\x20c\
    an\x20handle\x20multi-model\x20data\n\x20and\x20more\x20complex\x20workf\
    low\x20operations.\n\n\r\n\x05\x04\x7f\x02\x02\x04\x12\x04\xa8\x16\x02\n\
    \n\r\n\x05\x04\x7f\x02\x02\x06\x12\x04\xa8\x16\x0b\x14\n\r\n\x05\x04\x7f\
    \x02\x02\x01\x12\x04\xa8\x16\x15\x20\n\r\n\x05\x04\x7f\x02\x02\x03\x12\
    \x04\xa8\x16#$\n;\n\x04\x04\x7f\x02\x03\x12\x04\xaa\x16\x02\x1b\x1a-\x20\
    suppress\x20the\x20output\x20for\x20workflow\x20prediction\n\n\r\n\x05\
    \x04\x7f\x02\x03\x05\x12\x04\xaa\x16\x02\x06\n\r\n\x05\x04\x7f\x02\x03\
    \x01\x12\x04\xaa\x16\x07\x16\n\r\n\x05\x04\x7f\x02\x03\x03\x12\x04\xaa\
    \x16\x19\x1a\n\xb1\x01\n\x04\x04\x7f\x02\x04\x12\x04\xad\x16\x02&\x1a\
    \xa2\x01\x20Used\x20to\x20override\x20the\x20output_info.data\x20and\x20\
    output_info.params\x20of\x20the\x20model\x20specified\x20by\x20the\x20no\
    de.\n\x20Values\x20for\x20fields_map,\x20message,\x20and\x20output_confi\
    g\x20are\x20ignored.\n\n\r\n\x05\x04\x7f\x02\x04\x06\x12\x04\xad\x16\x02\
    \x0c\n\r\n\x05\x04\x7f\x02\x04\x01\x12\x04\xad\x16\r!\n\r\n\x05\x04\x7f\
    \x02\x04\x03\x12\x04\xad\x16$%\nD\n\x03\x04\x80\x01\x12\x06\xb1\x16\0\
    \xb4\x16\x01\x1a5\x20NodeInput\x20represents\x20inputs\x20to\x20a\x20nod\
    e\x20of\x20the\x20graph.\n\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\xb1\x16\
    \x08\x11\nl\n\x05\x04\x80\x01\x02\0\x12\x04\xb3\x16\x02\x15\x1a]\x20The\
    \x20id\x20to\x20a\x20connected\x20WorkflowNode\x20which\x20will\x20be\
    \x20used\x20as\x20an\x20input\x20for\x20current\x20WorkflowNode.\n\n\x0e\
    \n\x06\x04\x80\x01\x02\0\x05\x12\x04\xb3\x16\x02\x08\n\x0e\n\x06\x04\x80\
    \x01\x02\0\x01\x12\x04\xb3\x16\t\x10\n\x0e\n\x06\x04\x80\x01\x02\0\x03\
    \x12\x04\xb3\x16\x13\x14\nF\n\x03\x04\x81\x01\x12\x06\xb8\x16\0\xcb\x16\
    \x01\x1a7\x20WorkflowResult\n\x20One\x20result\x20per\x20input\x20in\x20\
    the\x20workflow.\n\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\xb8\x16\x08\x16\n\
    \r\n\x05\x04\x81\x01\x02\0\x12\x04\xb9\x16\x02\x10\n\x0e\n\x06\x04\x81\
    \x01\x02\0\x05\x12\x04\xb9\x16\x02\x08\n\x0e\n\x06\x04\x81\x01\x02\0\x01\
    \x12\x04\xb9\x16\t\x0b\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xb9\x16\
    \x0e\x0f\n\r\n\x05\x04\x81\x01\x02\x01\x12\x04\xba\x16\x02(\n\x0e\n\x06\
    \x04\x81\x01\x02\x01\x06\x12\x04\xba\x16\x02\x1c\n\x0e\n\x06\x04\x81\x01\
    \x02\x01\x01\x12\x04\xba\x16\x1d#\n\x0e\n\x06\x04\x81\x01\x02\x01\x03\
    \x12\x04\xba\x16&'\n\x82\x02\n\x05\x04\x81\x01\x02\x02\x12\x04\xc0\x16\
    \x02+\x1a\xf2\x01\x20When\x20the\x20object\x20was\x20created.\x20We\x20f\
    ollow\x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\x20https://w\
    ww.ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15:04:05.999999\
    Z\"\x20so\x20you\x20can\x20expect\x20results\x20like\n\x20the\x20followi\
    ng\x20from\x20the\x20API:\n\x20\"2017-04-11T21:50:50.223962Z\"\n\n\x0e\n\
    \x06\x04\x81\x01\x02\x02\x06\x12\x04\xc0\x16\x02\x1b\n\x0e\n\x06\x04\x81\
    \x01\x02\x02\x01\x12\x04\xc0\x16\x1c&\n\x0e\n\x06\x04\x81\x01\x02\x02\
    \x03\x12\x04\xc0\x16)*\n\xb6\x01\n\x05\x04\x81\x01\x02\x03\x12\x04\xc4\
    \x16\x02'\x1a\xa6\x01\x20The\x20model\x20that\x20this\x20WorkflowResult\
    \x20is\x20for.\n\x20DEPRECATED:\x20not\x20sure\x20why\x20there\x20ever\
    \x20was\x20a\x20model\x20here\x20because\x20each\x20output\x20shows\x20t\
    he\x20model\n\x20that\x20process\x20this\x20given\x20input.\n\n\x0e\n\
    \x06\x04\x81\x01\x02\x03\x06\x12\x04\xc4\x16\x02\x07\n\x0e\n\x06\x04\x81\
    \x01\x02\x03\x01\x12\x04\xc4\x16\x08\r\n\x0e\n\x06\x04\x81\x01\x02\x03\
    \x03\x12\x04\xc4\x16\x10\x11\n\x0e\n\x06\x04\x81\x01\x02\x03\x08\x12\x04\
    \xc4\x16\x13&\n\x0f\n\x07\x04\x81\x01\x02\x03\x08\x03\x12\x04\xc4\x16\
    \x14%\nh\n\x05\x04\x81\x01\x02\x04\x12\x04\xc6\x16\x02\x12\x1aY\x20The\
    \x20input\x20that\x20ran\x20through\x20the\x20workflow\x20to\x20generate\
    \x20the\x20outputs\x20in\x20this\x20WorkflowResult.\n\n\x0e\n\x06\x04\
    \x81\x01\x02\x04\x06\x12\x04\xc6\x16\x02\x07\n\x0e\n\x06\x04\x81\x01\x02\
    \x04\x01\x12\x04\xc6\x16\x08\r\n\x0e\n\x06\x04\x81\x01\x02\x04\x03\x12\
    \x04\xc6\x16\x10\x11\nD\n\x05\x04\x81\x01\x02\x05\x12\x04\xc8\x16\x02\
    \x1e\x1a5\x20For\x20each\x20model\x20in\x20the\x20workflow\x20we\x20retu\
    rn\x20an\x20Output.\n\n\x0e\n\x06\x04\x81\x01\x02\x05\x04\x12\x04\xc8\
    \x16\x02\n\n\x0e\n\x06\x04\x81\x01\x02\x05\x06\x12\x04\xc8\x16\x0b\x11\n\
    \x0e\n\x06\x04\x81\x01\x02\x05\x01\x12\x04\xc8\x16\x12\x19\n\x0e\n\x06\
    \x04\x81\x01\x02\x05\x03\x12\x04\xc8\x16\x1c\x1d\nD\n\x05\x04\x81\x01\
    \x02\x06\x12\x04\xca\x16\x02\x1b\x1a5\x20Indicate\x20if\x20the\x20output\
    \x20of\x20this\x20model\x20is\x20suppressed.\n\n\x0e\n\x06\x04\x81\x01\
    \x02\x06\x05\x12\x04\xca\x16\x02\x06\n\x0e\n\x06\x04\x81\x01\x02\x06\x01\
    \x12\x04\xca\x16\x07\x16\n\x0e\n\x06\x04\x81\x01\x02\x06\x03\x12\x04\xca\
    \x16\x19\x1a\n\x1e\n\x03\x04\x82\x01\x12\x06\xcf\x16\0\xd5\x16\x01\x1a\
    \x0f\x20WorkflowState\n\n\x0c\n\x04\x04\x82\x01\x01\x12\x04\xcf\x16\x08\
    \x15\n\xae\x02\n\x05\x04\x82\x01\x02\0\x12\x04\xd4\x16\x02\x10\x1a\x9e\
    \x02\x20A\x20unique\x20ID\x20for\x20the\x20workflow\x20state.\n\x20To\
    \x20start\x20saving\x20a\x20state\x20in\x20a\x20PostWorkflowResults\x20r\
    equest\x20set\x20this\x20ID\x20to\x20\"init\"\n\x20and\x20it\x20will\x20\
    return\x20a\x20newly\x20generated\x20unique\x20state\x20id\x20that\x20yo\
    u\x20can\x20then\x20pass\x20in\x20subsequent\n\x20PostWorkflowResults\
    \x20calls.\x20These\x20state\x20expire\x20after\x205\x20minutes\x20betwe\
    en\x20calls.\n\n\x0e\n\x06\x04\x82\x01\x02\0\x05\x12\x04\xd4\x16\x02\x08\
    \n\x0e\n\x06\x04\x82\x01\x02\0\x01\x12\x04\xd4\x16\t\x0b\n\x0e\n\x06\x04\
    \x82\x01\x02\0\x03\x12\x04\xd4\x16\x0e\x0f\n\x1f\n\x03\x04\x83\x01\x12\
    \x06\xd8\x16\0\x97\x17\x01\x1a\x10\x20AppDuplication\n\n\x0c\n\x04\x04\
    \x83\x01\x01\x12\x04\xd8\x16\x08\x16\nA\n\x05\x04\x83\x01\x02\0\x12\x04\
    \xda\x16\x02\x10\x1a2\x20The\x20unique\x20identifier\x20of\x20an\x20app\
    \x20duplication\x20job.\n\n\x0e\n\x06\x04\x83\x01\x02\0\x05\x12\x04\xda\
    \x16\x02\x08\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\xda\x16\t\x0b\n\
    \x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xda\x16\x0e\x0f\n\xec\x04\n\x05\
    \x04\x83\x01\x02\x01\x12\x04\xe9\x16\x02\x1b\x1a\xdc\x04\x20The\x20desti\
    nation\x20application\x20where\x20resources\x20are\x20written.\n\n\x20If\
    \x20the\x20destination\x20does\x20not\x20exist,\x20then\x20the\x20fields\
    \x20from\x20the\x20request\x20are\n\x20used\x20to\x20create\x20the\x20ap\
    plication.\x20If\x20a\x20field\x20is\x20not\x20set\x20or\x20not\x20suppo\
    rted,\n\x20then\x20it\x20will\x20be\x20copied\x20from\x20the\x20source\
    \x20app,\x20unless\x20otherwise\x20noted.\n\n\x20Note:\x20this\x20field\
    \x20can\x20be\x20empty\x20when\x20reading\x20app\x20duplication\x20jobs\
    \x20in\x20cases\n\x20where\x20the\x20app\x20has\x20been\x20deleted\x20or\
    \x20is\x20just\x20not\x20visible\x20to\x20the\x20caller.\n\n\x20########\
    ##\x20Supported\x20fields\x20##########\n\x20\x20-\x20description\n\x20\
    \x20-\x20id\x20\x20\x20\x20\x20\x20-\x20if\x20not\x20set,\x20then\x20gen\
    erated\x20automatically\n\x20\x20-\x20user_id\x20-\x20if\x20not\x20set,\
    \x20then\x20the\x20calling\x20user\x20is\x20used\x20as\x20the\x20app\x20\
    owner\n\n\x0e\n\x06\x04\x83\x01\x02\x01\x06\x12\x04\xe9\x16\x02\x05\n\
    \x0e\n\x06\x04\x83\x01\x02\x01\x01\x12\x04\xe9\x16\x06\x15\n\x0e\n\x06\
    \x04\x83\x01\x02\x01\x03\x12\x04\xe9\x16\x18\x1a\n\xaf\x02\n\x05\x04\x83\
    \x01\x02\x02\x12\x04\xf1\x16\x021\x1a\x9f\x02\x20The\x20ID\x20of\x20an\
    \x20existing\x20app\x20you\x20want\x20to\x20copy\x20data\x20into.\n\n\
    \x20If\x20not\x20provided,\x20then\x20we\x20will\x20create\x20a\x20new\
    \x20application\x20as\x20the\x20destination\x20instead.\n\x20The\x20vari\
    ous\x20new_app_*\x20fields\x20can\x20be\x20used\x20to\x20set\x20fields\
    \x20of\x20this\x20new\x20application.\n\n\x20Deprecated:\x20Use\x20desti\
    nation_app.id\x20with\x20an\x20existing\x20ID\x20instead.\n\n\x0e\n\x06\
    \x04\x83\x01\x02\x02\x05\x12\x04\xf1\x16\x02\x08\n\x0e\n\x06\x04\x83\x01\
    \x02\x02\x01\x12\x04\xf1\x16\t\x18\n\x0e\n\x06\x04\x83\x01\x02\x02\x03\
    \x12\x04\xf1\x16\x1b\x1c\n\x0e\n\x06\x04\x83\x01\x02\x02\x08\x12\x04\xf1\
    \x16\x1d0\n\x0f\n\x07\x04\x83\x01\x02\x02\x08\x03\x12\x04\xf1\x16\x1e/\n\
    \x99\x02\n\x05\x04\x83\x01\x02\x03\x12\x04\xf9\x16\x02,\x1a\x89\x02\x20T\
    he\x20ID\x20to\x20use\x20when\x20creating\x20a\x20new\x20application.\n\
    \x20You\x20cannot\x20set\x20this\x20field\x20when\x20copying\x20into\x20\
    an\x20existing\x20app,\x20i.e.,\x20when\x20existing_app_is\x20is\x20set.\
    \n\n\x20If\x20not\x20provided,\x20then\x20it\x20will\x20be\x20generated\
    \x20automatically.\n\n\x20Deprecated:\x20Use\x20destination_app.id\x20wi\
    th\x20a\x20new\x20ID\x20instead.\n\n\x0e\n\x06\x04\x83\x01\x02\x03\x05\
    \x12\x04\xf9\x16\x02\x08\n\x0e\n\x06\x04\x83\x01\x02\x03\x01\x12\x04\xf9\
    \x16\t\x13\n\x0e\n\x06\x04\x83\x01\x02\x03\x03\x12\x04\xf9\x16\x16\x17\n\
    \x0e\n\x06\x04\x83\x01\x02\x03\x08\x12\x04\xf9\x16\x18+\n\x0f\n\x07\x04\
    \x83\x01\x02\x03\x08\x03\x12\x04\xf9\x16\x19*\n\xc0\x02\n\x05\x04\x83\
    \x01\x02\x04\x12\x04\x81\x17\x02.\x1a\xb0\x02\x20The\x20name\x20to\x20us\
    e\x20when\x20creating\x20a\x20new\x20application.\n\x20You\x20cannot\x20\
    set\x20this\x20field\x20when\x20copying\x20into\x20an\x20existing\x20app\
    ,\x20i.e.,\x20when\x20existing_app_is\x20is\x20set.\n\n\x20If\x20not\x20\
    provided,\x20then\x20the\x20ID\x20of\x20the\x20new\x20application\x20is\
    \x20also\x20used\x20as\x20the\x20name.\n\n\x20Deprecated:\x20Application\
    \x20names\x20are\x20deprecated,\x20use\x20application\x20IDs\x20instead.\
    \n\n\x0e\n\x06\x04\x83\x01\x02\x04\x05\x12\x04\x81\x17\x02\x08\n\x0e\n\
    \x06\x04\x83\x01\x02\x04\x01\x12\x04\x81\x17\t\x15\n\x0e\n\x06\x04\x83\
    \x01\x02\x04\x03\x12\x04\x81\x17\x18\x19\n\x0e\n\x06\x04\x83\x01\x02\x04\
    \x08\x12\x04\x81\x17\x1a-\n\x0f\n\x07\x04\x83\x01\x02\x04\x08\x03\x12\
    \x04\x81\x17\x1b,\n7\n\x05\x04\x83\x01\x02\x05\x12\x04\x84\x17\x02(\x1a(\
    \x20The\x20status\x20of\x20the\x20app\x20duplication\x20job.\n\n\x0e\n\
    \x06\x04\x83\x01\x02\x05\x06\x12\x04\x84\x17\x02\x1c\n\x0e\n\x06\x04\x83\
    \x01\x02\x05\x01\x12\x04\x84\x17\x1d#\n\x0e\n\x06\x04\x83\x01\x02\x05\
    \x03\x12\x04\x84\x17&'\nC\n\x05\x04\x83\x01\x02\x06\x12\x04\x87\x17\x02+\
    \x1a4\x20The\x20time\x20when\x20the\x20app\x20duplication\x20job\x20was\
    \x20created.\n\n\x0e\n\x06\x04\x83\x01\x02\x06\x06\x12\x04\x87\x17\x02\
    \x1b\n\x0e\n\x06\x04\x83\x01\x02\x06\x01\x12\x04\x87\x17\x1c&\n\x0e\n\
    \x06\x04\x83\x01\x02\x06\x03\x12\x04\x87\x17)*\nO\n\x05\x04\x83\x01\x02\
    \x07\x12\x04\x8a\x17\x021\x1a@\x20The\x20last\x20time\x20when\x20the\x20\
    app\x20duplication\x20job\x20status\x20was\x20updated.\n\n\x0e\n\x06\x04\
    \x83\x01\x02\x07\x06\x12\x04\x8a\x17\x02\x1b\n\x0e\n\x06\x04\x83\x01\x02\
    \x07\x01\x12\x04\x8a\x17\x1c,\n\x0e\n\x06\x04\x83\x01\x02\x07\x03\x12\
    \x04\x8a\x17/0\n\\\n\x05\x04\x83\x01\x02\x08\x12\x04\x8d\x17\x02#\x1aM\
    \x20The\x20filter\x20specifies\x20which\x20resources\x20are\x20copied\
    \x20by\x20the\x20app\x20duplication\x20job.\n\n\x0e\n\x06\x04\x83\x01\
    \x02\x08\x06\x12\x04\x8d\x17\x02\x17\n\x0e\n\x06\x04\x83\x01\x02\x08\x01\
    \x12\x04\x8d\x17\x18\x1e\n\x0e\n\x06\x04\x83\x01\x02\x08\x03\x12\x04\x8d\
    \x17!\"\n\xbf\x01\n\x05\x04\x83\x01\x02\t\x12\x04\x96\x17\x02(\x1a\xaf\
    \x01\x20Copy\x20progress\x20for\x20each\x20resource\x20type\x20requested\
    \x20by\x20the\x20filter.\x20Possible\x20fields:\n\x20\x20-\x20inputs\n\
    \x20\x20-\x20concepts\n\x20\x20-\x20annotations\n\x20\x20-\x20models\n\
    \x20\x20-\x20workflows\n\x20\x20-\x20installed_module_versions\n\n\x0e\n\
    \x06\x04\x83\x01\x02\t\x04\x12\x04\x96\x17\x02\n\n\x0e\n\x06\x04\x83\x01\
    \x02\t\x06\x12\x04\x96\x17\x0b\x1a\n\x0e\n\x06\x04\x83\x01\x02\t\x01\x12\
    \x04\x96\x17\x1b#\n\x0e\n\x06\x04\x83\x01\x02\t\x03\x12\x04\x96\x17&'\n\
    \r\n\x03\x04\x84\x01\x12\x06\x99\x17\0\x9c\x17\x01\n\x0c\n\x04\x04\x84\
    \x01\x01\x12\x04\x99\x17\x08\x17\n\r\n\x05\x04\x84\x01\x02\0\x12\x04\x9a\
    \x17\x02\x13\n\x0e\n\x06\x04\x84\x01\x02\0\x05\x12\x04\x9a\x17\x02\x08\n\
    \x0e\n\x06\x04\x84\x01\x02\0\x01\x12\x04\x9a\x17\t\x0e\n\x0e\n\x06\x04\
    \x84\x01\x02\0\x03\x12\x04\x9a\x17\x11\x12\n\r\n\x05\x04\x84\x01\x02\x01\
    \x12\x04\x9b\x17\x02A\n\x0e\n\x06\x04\x84\x01\x02\x01\x05\x12\x04\x9b\
    \x17\x02\x07\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\x12\x04\x9b\x17\x08\r\n\
    \x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\x9b\x17\x10\x11\n\x0e\n\x06\
    \x04\x84\x01\x02\x01\x08\x12\x04\x9b\x17\x12@\n\x11\n\t\x04\x84\x01\x02\
    \x01\x08\xd0\x86\x03\x12\x04\x9b\x17\x13?\n&\n\x03\x04\x85\x01\x12\x06\
    \x9f\x17\0\xad\x17\x01\x1a\x17\x20AppDuplicationFilters\n\n\x0c\n\x04\
    \x04\x85\x01\x01\x12\x04\x9f\x17\x08\x1d\n\xa4\x01\n\x05\x04\x85\x01\x02\
    \0\x12\x04\xa2\x17\x02\x17\x1a\x94\x01\x20Copy\x20inputs.\x20Requires\
    \x20that\x20copy_concepts\x20is\x20also\x20set.\n\x20Note\x20that\x20thi\
    s\x20will\x20still\x20copy\x20input-level\x20annotations\x20even\x20if\
    \x20copy_annotations\x20is\x20not\x20set.\n\n\x0e\n\x06\x04\x85\x01\x02\
    \0\x05\x12\x04\xa2\x17\x02\x06\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\
    \xa2\x17\x07\x12\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\x04\xa2\x17\x15\
    \x16\n\x1f\n\x05\x04\x85\x01\x02\x01\x12\x04\xa4\x17\x02\x19\x1a\x10\x20\
    Copy\x20concepts.\n\n\x0e\n\x06\x04\x85\x01\x02\x01\x05\x12\x04\xa4\x17\
    \x02\x06\n\x0e\n\x06\x04\x85\x01\x02\x01\x01\x12\x04\xa4\x17\x07\x14\n\
    \x0e\n\x06\x04\x85\x01\x02\x01\x03\x12\x04\xa4\x17\x17\x18\n\\\n\x05\x04\
    \x85\x01\x02\x02\x12\x04\xa6\x17\x02\x1c\x1aM\x20Copy\x20annotations.\
    \x20Requires\x20that\x20copy_inputs\x20and\x20copy_concepts\x20are\x20al\
    so\x20set.\n\n\x0e\n\x06\x04\x85\x01\x02\x02\x05\x12\x04\xa6\x17\x02\x06\
    \n\x0e\n\x06\x04\x85\x01\x02\x02\x01\x12\x04\xa6\x17\x07\x17\n\x0e\n\x06\
    \x04\x85\x01\x02\x02\x03\x12\x04\xa6\x17\x1a\x1b\nF\n\x05\x04\x85\x01\
    \x02\x03\x12\x04\xa8\x17\x02\x17\x1a7\x20Copy\x20models.\x20Requires\x20\
    that\x20copy_concepts\x20is\x20also\x20set.\n\n\x0e\n\x06\x04\x85\x01\
    \x02\x03\x05\x12\x04\xa8\x17\x02\x06\n\x0e\n\x06\x04\x85\x01\x02\x03\x01\
    \x12\x04\xa8\x17\x07\x12\n\x0e\n\x06\x04\x85\x01\x02\x03\x03\x12\x04\xa8\
    \x17\x15\x16\n\x20\n\x05\x04\x85\x01\x02\x04\x12\x04\xaa\x17\x02\x1a\x1a\
    \x11\x20Copy\x20workflows.\n\n\x0e\n\x06\x04\x85\x01\x02\x04\x05\x12\x04\
    \xaa\x17\x02\x06\n\x0e\n\x06\x04\x85\x01\x02\x04\x01\x12\x04\xaa\x17\x07\
    \x15\n\x0e\n\x06\x04\x85\x01\x02\x04\x03\x12\x04\xaa\x17\x18\x19\n0\n\
    \x05\x04\x85\x01\x02\x05\x12\x04\xac\x17\x02*\x1a!\x20Copy\x20installed\
    \x20module\x20versions.\n\n\x0e\n\x06\x04\x85\x01\x02\x05\x05\x12\x04\
    \xac\x17\x02\x06\n\x0e\n\x06\x04\x85\x01\x02\x05\x01\x12\x04\xac\x17\x07\
    %\n\x0e\n\x06\x04\x85\x01\x02\x05\x03\x12\x04\xac\x17()\n\x1b\n\x03\x04\
    \x86\x01\x12\x06\xb0\x17\0\xd5\x17\x01\x1a\x0c\x20LabelOrder\n\n\x0c\n\
    \x04\x04\x86\x01\x01\x12\x04\xb0\x17\x08\x12\n\x20\n\x05\x04\x86\x01\x02\
    \0\x12\x04\xb2\x17\x02\x10\x1a\x11\x20id\x20of\x20the\x20order\n\n\x0e\n\
    \x06\x04\x86\x01\x02\0\x05\x12\x04\xb2\x17\x02\x08\n\x0e\n\x06\x04\x86\
    \x01\x02\0\x01\x12\x04\xb2\x17\t\x0b\n\x0e\n\x06\x04\x86\x01\x02\0\x03\
    \x12\x04\xb2\x17\x0e\x0f\n\"\n\x05\x04\x86\x01\x02\x01\x12\x04\xb5\x17\
    \x02\x12\x1a\x13\x20name\x20of\x20the\x20order\n\n\x0e\n\x06\x04\x86\x01\
    \x02\x01\x05\x12\x04\xb5\x17\x02\x08\n\x0e\n\x06\x04\x86\x01\x02\x01\x01\
    \x12\x04\xb5\x17\t\r\n\x0e\n\x06\x04\x86\x01\x02\x01\x03\x12\x04\xb5\x17\
    \x10\x11\n\xc2\x01\n\x05\x04\x86\x01\x02\x02\x12\x04\xbb\x17\x02(\x1a\
    \xb2\x01\x20status\x20of\x20the\x20order.\n\x20pending\x20(QA\x20lead\
    \x20review\x20the\x20order),\n\x20in\x20progress\x20(labeling\x20in\x20p\
    rogress),\n\x20ready\x20for\x20release\x20(passed\x20clarifai\x20QA\x20a\
    nd\x20client\x20can\x20review)\n\x20success\x20(released)\n\n\x0e\n\x06\
    \x04\x86\x01\x02\x02\x06\x12\x04\xbb\x17\x02\x1c\n\x0e\n\x06\x04\x86\x01\
    \x02\x02\x01\x12\x04\xbb\x17\x1d#\n\x0e\n\x06\x04\x86\x01\x02\x02\x03\
    \x12\x04\xbb\x17&'\n^\n\x05\x04\x86\x01\x02\x03\x12\x04\xbe\x17\x02\x18\
    \x1aO\x20if\x20set\x20to\x20true,\x20automatically\x20release\x20the\x20\
    labels\x20once\x20passed\x20clarifai\x20review.\n\n\x0e\n\x06\x04\x86\
    \x01\x02\x03\x05\x12\x04\xbe\x17\x02\x06\n\x0e\n\x06\x04\x86\x01\x02\x03\
    \x01\x12\x04\xbe\x17\x07\x13\n\x0e\n\x06\x04\x86\x01\x02\x03\x03\x12\x04\
    \xbe\x17\x16\x17\n-\n\x05\x04\x86\x01\x02\x04\x12\x04\xc1\x17\x02\x1b\
    \x1a\x1e\x20allow\x20input\x20without\x20any\x20tag.\n\n\x0e\n\x06\x04\
    \x86\x01\x02\x04\x05\x12\x04\xc1\x17\x02\x06\n\x0e\n\x06\x04\x86\x01\x02\
    \x04\x01\x12\x04\xc1\x17\x07\x16\n\x0e\n\x06\x04\x86\x01\x02\x04\x03\x12\
    \x04\xc1\x17\x19\x1a\nE\n\x05\x04\x86\x01\x02\x05\x12\x04\xc4\x17\x025\
    \x1a6\x20User\x20desired\x20estimation\x20when\x20the\x20task\x20should\
    \x20be\x20done\n\n\x0e\n\x06\x04\x86\x01\x02\x05\x06\x12\x04\xc4\x17\x02\
    \x1b\n\x0e\n\x06\x04\x86\x01\x02\x05\x01\x12\x04\xc4\x17\x1c0\n\x0e\n\
    \x06\x04\x86\x01\x02\x05\x03\x12\x04\xc4\x1734\nC\n\x05\x04\x86\x01\x02\
    \x06\x12\x04\xc7\x17\x026\x1a4\x20Clarifai\x20estimation\x20when\x20the\
    \x20task\x20should\x20be\x20done\x20.\n\n\x0e\n\x06\x04\x86\x01\x02\x06\
    \x06\x12\x04\xc7\x17\x02\x1b\n\x0e\n\x06\x04\x86\x01\x02\x06\x01\x12\x04\
    \xc7\x17\x1c1\n\x0e\n\x06\x04\x86\x01\x02\x06\x03\x12\x04\xc7\x1745\n*\n\
    \x05\x04\x86\x01\x02\x07\x12\x04\xca\x17\x02\x10\x1a\x1b\x20task\x20for\
    \x20this\x20label\x20order\n\n\x0e\n\x06\x04\x86\x01\x02\x07\x06\x12\x04\
    \xca\x17\x02\x06\n\x0e\n\x06\x04\x86\x01\x02\x07\x01\x12\x04\xca\x17\x07\
    \x0b\n\x0e\n\x06\x04\x86\x01\x02\x07\x03\x12\x04\xca\x17\x0e\x0f\n\x91\
    \x01\n\x05\x04\x86\x01\x02\x08\x12\x04\xcf\x17\x02+\x1a\x81\x01\x20When\
    \x20the\x20label\x20order\x20was\x20created.\n\x20The\x20format\x20is\
    \x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T\
    15:04:05.999999Z\".\n\n\x0e\n\x06\x04\x86\x01\x02\x08\x06\x12\x04\xcf\
    \x17\x02\x1b\n\x0e\n\x06\x04\x86\x01\x02\x08\x01\x12\x04\xcf\x17\x1c&\n\
    \x0e\n\x06\x04\x86\x01\x02\x08\x03\x12\x04\xcf\x17)*\n\xa2\x01\n\x05\x04\
    \x86\x01\x02\t\x12\x04\xd4\x17\x02-\x1a\x92\x01\x20Most\x20recent\x20tim\
    e\x20when\x20the\x20label\x20order\x20was\x20updated.\n\x20The\x20format\
    \x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-\
    01-02T15:04:05.999999Z\".\n\n\x0e\n\x06\x04\x86\x01\x02\t\x06\x12\x04\
    \xd4\x17\x02\x1b\n\x0e\n\x06\x04\x86\x01\x02\t\x01\x12\x04\xd4\x17\x1c'\
    \n\x0e\n\x06\x04\x86\x01\x02\t\x03\x12\x04\xd4\x17*,\nZ\n\x03\x04\x87\
    \x01\x12\x06\xd8\x17\0\xa8\x18\x01\x1aK\x20Task\x20is\x20the\x20work\x20\
    that\x20needs\x20to\x20be\x20done\x20for\x20labeling\x20the\x20inputs\
    \x20in\x20an\x20app.\n\n\x0c\n\x04\x04\x87\x01\x01\x12\x04\xd8\x17\x08\
    \x0c\n(\n\x05\x04\x87\x01\x02\0\x12\x04\xda\x17\x02\x10\x1a\x19\x20Uniqu\
    e\x20ID\x20for\x20the\x20task.\n\n\x0e\n\x06\x04\x87\x01\x02\0\x05\x12\
    \x04\xda\x17\x02\x08\n\x0e\n\x06\x04\x87\x01\x02\0\x01\x12\x04\xda\x17\t\
    \x0b\n\x0e\n\x06\x04\x87\x01\x02\0\x03\x12\x04\xda\x17\x0e\x0f\n\x89\x01\
    \n\x05\x04\x87\x01\x02\x01\x12\x04\xdf\x17\x02+\x1az\x20When\x20the\x20t\
    ask\x20was\x20created.\n\x20The\x20format\x20is\x20https://www.ietf.org/\
    rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\
    \x0e\n\x06\x04\x87\x01\x02\x01\x06\x12\x04\xdf\x17\x02\x1b\n\x0e\n\x06\
    \x04\x87\x01\x02\x01\x01\x12\x04\xdf\x17\x1c&\n\x0e\n\x06\x04\x87\x01\
    \x02\x01\x03\x12\x04\xdf\x17)*\n\x9b\x01\n\x05\x04\x87\x01\x02\x02\x12\
    \x04\xe4\x17\x02,\x1a\x8b\x01\x20Most\x20recent\x20time\x20when\x20the\
    \x20task\x20was\x20updated.\n\x20The\x20format\x20is\x20https://www.ietf\
    .org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\
    \n\n\x0e\n\x06\x04\x87\x01\x02\x02\x06\x12\x04\xe4\x17\x02\x1b\n\x0e\n\
    \x06\x04\x87\x01\x02\x02\x01\x12\x04\xe4\x17\x1c'\n\x0e\n\x06\x04\x87\
    \x01\x02\x02\x03\x12\x04\xe4\x17*+\n\x1b\n\x05\x04\x87\x01\x02\x03\x12\
    \x04\xe7\x17\x02\x14\x1a\x0c\x20Task\x20type.\n\n\x0e\n\x06\x04\x87\x01\
    \x02\x03\x06\x12\x04\xe7\x17\x02\n\n\x0e\n\x06\x04\x87\x01\x02\x03\x01\
    \x12\x04\xe7\x17\x0b\x0f\n\x0e\n\x06\x04\x87\x01\x02\x03\x03\x12\x04\xe7\
    \x17\x12\x13\n)\n\x05\x04\x87\x01\x02\x04\x12\x04\xea\x17\x02\x19\x1a\
    \x1a\x20Description\x20of\x20the\x20task.\n\n\x0e\n\x06\x04\x87\x01\x02\
    \x04\x05\x12\x04\xea\x17\x02\x08\n\x0e\n\x06\x04\x87\x01\x02\x04\x01\x12\
    \x04\xea\x17\t\x14\n\x0e\n\x06\x04\x87\x01\x02\x04\x03\x12\x04\xea\x17\
    \x17\x18\n\x20\n\x05\x04\x87\x01\x02\x05\x12\x04\xed\x17\x02\x18\x1a\x11\
    \x20Worker\x20details.\n\n\x0e\n\x06\x04\x87\x01\x02\x05\x06\x12\x04\xed\
    \x17\x02\x0c\n\x0e\n\x06\x04\x87\x01\x02\x05\x01\x12\x04\xed\x17\r\x13\n\
    \x0e\n\x06\x04\x87\x01\x02\x05\x03\x12\x04\xed\x17\x16\x17\nk\n\x05\x04\
    \x87\x01\x02\x06\x12\x04\xf1\x17\x026\x1a\\\x20List\x20of\x20concept\x20\
    ids\x20used\x20in\x20the\x20work\x20of\x20this\x20task.\n\x20DEPRECATED:\
    \x20Use\x20task.concepts\x20instead.\n\n\x0e\n\x06\x04\x87\x01\x02\x06\
    \x04\x12\x04\xf1\x17\x02\n\n\x0e\n\x06\x04\x87\x01\x02\x06\x05\x12\x04\
    \xf1\x17\x0b\x11\n\x0e\n\x06\x04\x87\x01\x02\x06\x01\x12\x04\xf1\x17\x12\
    \x1d\n\x0e\n\x06\x04\x87\x01\x02\x06\x03\x12\x04\xf1\x17\x20!\n\x0e\n\
    \x06\x04\x87\x01\x02\x06\x08\x12\x04\xf1\x17\"5\n\x0f\n\x07\x04\x87\x01\
    \x02\x06\x08\x03\x12\x04\xf1\x17#4\nQ\n\x05\x04\x87\x01\x02\x07\x12\x04\
    \xf4\x17\x02#\x1aB\x20List\x20of\x20inputs\x20used\x20in\x20this\x20task\
    \x20will\x20be\x20taken\x20from\x20this\x20source.\n\n\x0e\n\x06\x04\x87\
    \x01\x02\x07\x06\x12\x04\xf4\x17\x02\x11\n\x0e\n\x06\x04\x87\x01\x02\x07\
    \x01\x12\x04\xf4\x17\x12\x1e\n\x0e\n\x06\x04\x87\x01\x02\x07\x03\x12\x04\
    \xf4\x17!\"\no\n\x05\x04\x87\x01\x02\x08\x12\x04\xf7\x17\x02\x17\x1a`\
    \x20For\x20model\x20predictions\x20on\x20video:\x20Sample\x20delay\x20fo\
    r\x20video\x20predicting\x20(1\x20frame\x20per\x20N\x20milliseconds)\n\n\
    \x0e\n\x06\x04\x87\x01\x02\x08\x05\x12\x04\xf7\x17\x02\x08\n\x0e\n\x06\
    \x04\x87\x01\x02\x08\x01\x12\x04\xf7\x17\t\x12\n\x0e\n\x06\x04\x87\x01\
    \x02\x08\x03\x12\x04\xf7\x17\x15\x16\n&\n\x05\x04\x87\x01\x02\t\x12\x04\
    \xfa\x17\x02$\x1a\x17\x20AI\x20assistant\x20details.\n\n\x0e\n\x06\x04\
    \x87\x01\x02\t\x06\x12\x04\xfa\x17\x02\x11\n\x0e\n\x06\x04\x87\x01\x02\t\
    \x01\x12\x04\xfa\x17\x12\x1e\n\x0e\n\x06\x04\x87\x01\x02\t\x03\x12\x04\
    \xfa\x17!#\n\x20\n\x05\x04\x87\x01\x02\n\x12\x04\xfd\x17\x02\x19\x1a\x11\
    \x20Review\x20details.\n\n\x0e\n\x06\x04\x87\x01\x02\n\x06\x12\x04\xfd\
    \x17\x02\x0c\n\x0e\n\x06\x04\x87\x01\x02\n\x01\x12\x04\xfd\x17\r\x13\n\
    \x0e\n\x06\x04\x87\x01\x02\n\x03\x12\x04\xfd\x17\x16\x18\n%\n\x05\x04\
    \x87\x01\x02\x0b\x12\x04\x80\x18\x02)\x1a\x16\x20Status\x20of\x20this\
    \x20task.\n\n\x0e\n\x06\x04\x87\x01\x02\x0b\x06\x12\x04\x80\x18\x02\x1c\
    \n\x0e\n\x06\x04\x87\x01\x02\x0b\x01\x12\x04\x80\x18\x1d#\n\x0e\n\x06\
    \x04\x87\x01\x02\x0b\x03\x12\x04\x80\x18&(\nV\n\x05\x04\x87\x01\x02\x0c\
    \x12\x04\x83\x18\x02\x13\x1aG\x20Add\x20a\x20title\x20for\x20this\x20tas\
    k\x20to\x20quickly\x20recognise\x20it\x20in\x20a\x20list\x20of\x20tasks.\
    \n\n\x0e\n\x06\x04\x87\x01\x02\x0c\x05\x12\x04\x83\x18\x02\x08\n\x0e\n\
    \x06\x04\x87\x01\x02\x0c\x01\x12\x04\x83\x18\t\r\n\x0e\n\x06\x04\x87\x01\
    \x02\x0c\x03\x12\x04\x83\x18\x10\x12\n\r\n\x05\x04\x87\x01\x02\r\x12\x04\
    \x85\x18\x02+\n\x0e\n\x06\x04\x87\x01\x02\r\x06\x12\x04\x85\x18\x02\x14\
    \n\x0e\n\x06\x04\x87\x01\x02\r\x01\x12\x04\x85\x18\x15%\n\x0e\n\x06\x04\
    \x87\x01\x02\r\x03\x12\x04\x85\x18(*\n\x0f\n\x05\x04\x87\x01\x04\0\x12\
    \x06\x87\x18\x02\x90\x18\x03\n\x0e\n\x06\x04\x87\x01\x04\0\x01\x12\x04\
    \x87\x18\x07\x0f\n\x0f\n\x07\x04\x87\x01\x04\0\x02\0\x12\x04\x88\x18\x04\
    \x15\n\x10\n\x08\x04\x87\x01\x04\0\x02\0\x01\x12\x04\x88\x18\x04\x10\n\
    \x10\n\x08\x04\x87\x01\x04\0\x02\0\x02\x12\x04\x88\x18\x13\x14\n|\n\x07\
    \x04\x87\x01\x04\0\x02\x01\x12\x04\x8b\x18\x04\x20\x1ak\x20Concepts\x20c\
    lassification\x20tasks\x20annotate\x20concepts\x20for\x20the\x20overall\
    \x20image,\x20frame\x20of\x20video\x20or\x20section\x20of\x20text.\n\n\
    \x10\n\x08\x04\x87\x01\x04\0\x02\x01\x01\x12\x04\x8b\x18\x04\x1b\n\x10\n\
    \x08\x04\x87\x01\x04\0\x02\x01\x02\x12\x04\x8b\x18\x1e\x1f\n\x9e\x01\n\
    \x07\x04\x87\x01\x04\0\x02\x02\x12\x04\x8d\x18\x04\x1f\x1a\x8c\x01\x20Bo\
    unding\x20box\x20detection\x20tasks\x20annotate\x20rectangular\x20boundi\
    ng\x20box\x20regions\x20around\x20each\x20concept\x20in\x20an\x20image,\
    \x20frame\x20of\x20video\x20or\x20section\x20of\x20text.\n\n\x10\n\x08\
    \x04\x87\x01\x04\0\x02\x02\x01\x12\x04\x8d\x18\x04\x1a\n\x10\n\x08\x04\
    \x87\x01\x04\0\x02\x02\x02\x12\x04\x8d\x18\x1d\x1e\n\x85\x01\n\x07\x04\
    \x87\x01\x04\0\x02\x03\x12\x04\x8f\x18\x04\x1a\x1at\x20Polygon\x20detect\
    ion\x20tasks\x20annotate\x20free-form\x20regions\x20around\x20concepts\
    \x20in\x20an\x20image,\x20frame\x20of\x20video\x20or\x20section\x20of\
    \x20text.\n\n\x10\n\x08\x04\x87\x01\x04\0\x02\x03\x01\x12\x04\x8f\x18\
    \x04\x15\n\x10\n\x08\x04\x87\x01\x04\0\x02\x03\x02\x12\x04\x8f\x18\x18\
    \x19\n\xde\x01\n\x05\x04\x87\x01\x02\x0e\x12\x04\x95\x18\x02\x1d\x1a\xce\
    \x01\x20The\x20visibility\x20field\x20represents\x20whether\x20this\x20m\
    essage\x20is\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\
    \x20to\x20the\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\
    \x20the\x20User\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20b\
    e\x20publicly\x20visible.\n\n\x0e\n\x06\x04\x87\x01\x02\x0e\x06\x12\x04\
    \x95\x18\x02\x0c\n\x0e\n\x06\x04\x87\x01\x02\x0e\x01\x12\x04\x95\x18\r\
    \x17\n\x0e\n\x06\x04\x87\x01\x02\x0e\x03\x12\x04\x95\x18\x1a\x1c\n-\n\
    \x05\x04\x87\x01\x02\x0f\x12\x04\x98\x18\x02\x15\x1a\x1e\x20The\x20app\
    \x20the\x20task\x20belongs\x20to.\n\n\x0e\n\x06\x04\x87\x01\x02\x0f\x05\
    \x12\x04\x98\x18\x02\x08\n\x0e\n\x06\x04\x87\x01\x02\x0f\x01\x12\x04\x98\
    \x18\t\x0f\n\x0e\n\x06\x04\x87\x01\x02\x0f\x03\x12\x04\x98\x18\x12\x14\n\
    .\n\x05\x04\x87\x01\x02\x10\x12\x04\x9a\x18\x02\x16\x1a\x1f\x20The\x20us\
    er\x20the\x20task\x20belongs\x20to.\n\n\x0e\n\x06\x04\x87\x01\x02\x10\
    \x05\x12\x04\x9a\x18\x02\x08\n\x0e\n\x06\x04\x87\x01\x02\x10\x01\x12\x04\
    \x9a\x18\t\x10\n\x0e\n\x06\x04\x87\x01\x02\x10\x03\x12\x04\x9a\x18\x13\
    \x15\n5\n\x05\x04\x87\x01\x02\x11\x12\x04\x9d\x18\x02\x1d\x1a&\x20The\
    \x20label\x20order\x20the\x20task\x20belongs\x20to.\n\n\x0e\n\x06\x04\
    \x87\x01\x02\x11\x05\x12\x04\x9d\x18\x02\x08\n\x0e\n\x06\x04\x87\x01\x02\
    \x11\x01\x12\x04\x9d\x18\t\x17\n\x0e\n\x06\x04\x87\x01\x02\x11\x03\x12\
    \x04\x9d\x18\x1a\x1c\nP\n\x05\x04\x87\x01\x02\x12\x12\x04\xa0\x18\x02%\
    \x1aA\x20Ignore\x20Task.concept_ids\x20field\x20if\x20Task.TaskConcept\
    \x20are\x20supplied.\n\n\x0e\n\x06\x04\x87\x01\x02\x12\x04\x12\x04\xa0\
    \x18\x02\n\n\x0e\n\x06\x04\x87\x01\x02\x12\x06\x12\x04\xa0\x18\x0b\x16\n\
    \x0e\n\x06\x04\x87\x01\x02\x12\x01\x12\x04\xa0\x18\x17\x1f\n\x0e\n\x06\
    \x04\x87\x01\x02\x12\x03\x12\x04\xa0\x18\"$\n\xe5\x01\n\x05\x04\x87\x01\
    \x02\x13\x12\x04\xa4\x18\x02(\x1a\xd5\x01\x20Specify\x20whether\x20exist\
    ing\x20Annotations\x20within\x20the\x20same\x20app\x20that\x20are\x20gen\
    erated\x20by\x20other\x20auto\x20annotation\x20tasks\n\x20with\x20the\
    \x20specified\x20Concept\x20from\x20the\x20selected\x20Model\x20or\x20Wo\
    rkflow\x20should\x20deleted\x20before\x20executing\x20the\x20Task\n\n\
    \x0e\n\x06\x04\x87\x01\x02\x13\x05\x12\x04\xa4\x18\x02\x06\n\x0e\n\x06\
    \x04\x87\x01\x02\x13\x01\x12\x04\xa4\x18\x07\"\n\x0e\n\x06\x04\x87\x01\
    \x02\x13\x03\x12\x04\xa4\x18%'\n?\n\x05\x04\x87\x01\x02\x14\x12\x04\xa7\
    \x18\x02\x1b\x1a0\x20Tasks\x20metrics\x20are\x20filled\x20in\x20upon\x20\
    user-request.\n\n\x0e\n\x06\x04\x87\x01\x02\x14\x06\x12\x04\xa7\x18\x02\
    \r\n\x0e\n\x06\x04\x87\x01\x02\x14\x01\x12\x04\xa7\x18\x0e\x15\n\x0e\n\
    \x06\x04\x87\x01\x02\x14\x03\x12\x04\xa7\x18\x18\x1a\n#\n\x03\x04\x88\
    \x01\x12\x06\xab\x18\0\xb1\x18\x01\x1a\x14\x20AiAssistParameters\n\n\x0c\
    \n\x04\x04\x88\x01\x01\x12\x04\xab\x18\x08\x1a\nl\n\x05\x04\x88\x01\x02\
    \0\x12\x04\xad\x18\x02\x1a\x1a]\x20Min\x20and\x20max\x20threshold\x20val\
    ues\x20for\x20approving\x20annotations\x20by\x20default\x20based\x20on\
    \x20prediction\x20score\n\n\x0e\n\x06\x04\x88\x01\x02\0\x05\x12\x04\xad\
    \x18\x02\x07\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\x04\xad\x18\x08\x15\n\
    \x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\xad\x18\x18\x19\n\r\n\x05\x04\
    \x88\x01\x02\x01\x12\x04\xae\x18\x02\x1a\n\x0e\n\x06\x04\x88\x01\x02\x01\
    \x05\x12\x04\xae\x18\x02\x07\n\x0e\n\x06\x04\x88\x01\x02\x01\x01\x12\x04\
    \xae\x18\x08\x15\n\x0e\n\x06\x04\x88\x01\x02\x01\x03\x12\x04\xae\x18\x18\
    \x19\nE\n\x05\x04\x88\x01\x02\x02\x12\x04\xb0\x18\x02+\x1a6\x20ids\x20of\
    \x20concept\x20relations.\x20Used\x20in\x20AI\x20assist\x20workflow\n\n\
    \x0e\n\x06\x04\x88\x01\x02\x02\x04\x12\x04\xb0\x18\x02\n\n\x0e\n\x06\x04\
    \x88\x01\x02\x02\x05\x12\x04\xb0\x18\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\
    \x02\x01\x12\x04\xb0\x18\x12&\n\x0e\n\x06\x04\x88\x01\x02\x02\x03\x12\
    \x04\xb0\x18)*\n_\n\x03\x04\x89\x01\x12\x06\xb4\x18\0\xdd\x18\x01\x1aP\
    \x20TaskWorker\x20includes\x20information\x20about\x20the\x20workers\x20\
    that\x20will\x20work\x20on\x20this\x20task.\n\n\x0c\n\x04\x04\x89\x01\
    \x01\x12\x04\xb4\x18\x08\x12\n\x0c\n\x04\x04\x89\x01\t\x12\x04\xb5\x18\
    \x02\x10\n\r\n\x05\x04\x89\x01\t\0\x12\x04\xb5\x18\x0b\x0c\n\x0e\n\x06\
    \x04\x89\x01\t\0\x01\x12\x04\xb5\x18\x0b\x0c\n\x0e\n\x06\x04\x89\x01\t\0\
    \x02\x12\x04\xb5\x18\x0b\x0c\n\r\n\x05\x04\x89\x01\t\x01\x12\x04\xb5\x18\
    \x0e\x0f\n\x0e\n\x06\x04\x89\x01\t\x01\x01\x12\x04\xb5\x18\x0e\x0f\n\x0e\
    \n\x06\x04\x89\x01\t\x01\x02\x12\x04\xb5\x18\x0e\x0f\n!\n\x05\x04\x89\
    \x01\x02\0\x12\x04\xb8\x18\x02\"\x1a\x12\x20Worker\x20strategy.\n\n\x0e\
    \n\x06\x04\x89\x01\x02\0\x06\x12\x04\xb8\x18\x02\x14\n\x0e\n\x06\x04\x89\
    \x01\x02\0\x01\x12\x04\xb8\x18\x15\x1d\n\x0e\n\x06\x04\x89\x01\x02\0\x03\
    \x12\x04\xb8\x18\x20!\nV\n\x05\x04\x89\x01\x02\x01\x12\x04\xbc\x18\x023\
    \x1aG\x20Who\x20will\x20work\x20on\x20this\x20task.\n\x20DEPRECATED:\x20\
    Use\x20workers.user.id\x20instead.\n\n\x0e\n\x06\x04\x89\x01\x02\x01\x04\
    \x12\x04\xbc\x18\x02\n\n\x0e\n\x06\x04\x89\x01\x02\x01\x05\x12\x04\xbc\
    \x18\x0b\x11\n\x0e\n\x06\x04\x89\x01\x02\x01\x01\x12\x04\xbc\x18\x12\x1a\
    \n\x0e\n\x06\x04\x89\x01\x02\x01\x03\x12\x04\xbc\x18\x1d\x1e\n\x0e\n\x06\
    \x04\x89\x01\x02\x01\x08\x12\x04\xbc\x18\x1f2\n\x0f\n\x07\x04\x89\x01\
    \x02\x01\x08\x03\x12\x04\xbc\x18\x201\n\xec\x01\n\x05\x04\x89\x01\x02\
    \x02\x12\x04\xc2\x18\x02.\x1a\xdc\x01\x20Users\x20who\x20will\x20work\
    \x20on\x20this\x20task.\n\x20When\x20the\x20'worker.users'\x20field\x20i\
    s\x20additionally\x20requested,\x20then\x20all\x20user\n\x20info\x20is\
    \x20filled\x20for\x20the\x20workers.\x20Otherwise,\x20only\x20the\x20use\
    r\x20'id'\x20is\x20filled.\n\x20DEPRECATED:\x20Use\x20workers.user\x20in\
    stead.\n\n\x0e\n\x06\x04\x89\x01\x02\x02\x04\x12\x04\xc2\x18\x02\n\n\x0e\
    \n\x06\x04\x89\x01\x02\x02\x06\x12\x04\xc2\x18\x0b\x0f\n\x0e\n\x06\x04\
    \x89\x01\x02\x02\x01\x12\x04\xc2\x18\x10\x15\n\x0e\n\x06\x04\x89\x01\x02\
    \x02\x03\x12\x04\xc2\x18\x18\x19\n\x0e\n\x06\x04\x89\x01\x02\x02\x08\x12\
    \x04\xc2\x18\x1a-\n\x0f\n\x07\x04\x89\x01\x02\x02\x08\x03\x12\x04\xc2\
    \x18\x1b,\n3\n\x05\x04\x89\x01\x08\0\x12\x04\xc5\x18\x02Z\x1a$\x20Info\
    \x20based\x20on\x20the\x20worker\x20strategy,\n\n\x0e\n\x06\x04\x89\x01\
    \x08\0\x01\x12\x04\xc5\x18\x08\x15\n\r\n\x05\x04\x89\x01\x02\x03\x12\x04\
    \xc5\x18\x18X\n\x0e\n\x06\x04\x89\x01\x02\x03\x06\x12\x04\xc5\x18\x189\n\
    \x0e\n\x06\x04\x89\x01\x02\x03\x01\x12\x04\xc5\x18:S\n\x0e\n\x06\x04\x89\
    \x01\x02\x03\x03\x12\x04\xc5\x18VW\n\x0f\n\x05\x04\x89\x01\x04\0\x12\x06\
    \xc7\x18\x02\xd2\x18\x03\n\x0e\n\x06\x04\x89\x01\x04\0\x01\x12\x04\xc7\
    \x18\x07\x19\n\x0e\n\x06\x04\x89\x01\x04\0\x04\x12\x04\xc8\x18\x04\x0f\n\
    \x0f\n\x07\x04\x89\x01\x04\0\x04\0\x12\x04\xc8\x18\r\x0e\n\x10\n\x08\x04\
    \x89\x01\x04\0\x04\0\x01\x12\x04\xc8\x18\r\x0e\n\x10\n\x08\x04\x89\x01\
    \x04\0\x04\0\x02\x12\x04\xc8\x18\r\x0e\n\x0f\n\x07\x04\x89\x01\x04\0\x02\
    \0\x12\x04\xca\x18\x04\x20\n\x10\n\x08\x04\x89\x01\x04\0\x02\0\x01\x12\
    \x04\xca\x18\x04\x1b\n\x10\n\x08\x04\x89\x01\x04\0\x02\0\x02\x12\x04\xca\
    \x18\x1e\x1f\n~\n\x07\x04\x89\x01\x04\0\x02\x01\x12\x04\xce\x18\x04\x14\
    \x1am\x20The\x20inputs\x20will\x20be\x20partitioned\x20in\x20several\x20\
    partitions.\n\x20Each\x20worker\x20will\x20label\x20one\x20or\x20more\
    \x20input\x20partitions.\n\n\x10\n\x08\x04\x89\x01\x04\0\x02\x01\x01\x12\
    \x04\xce\x18\x04\x0f\n\x10\n\x08\x04\x89\x01\x04\0\x02\x01\x02\x12\x04\
    \xce\x18\x12\x13\nG\n\x07\x04\x89\x01\x04\0\x02\x02\x12\x04\xd1\x18\x04\
    \r\x1a6\x20Each\x20worker\x20will\x20label\x20all\x20inputs\x20from\x20i\
    nput\x20source.\n\n\x10\n\x08\x04\x89\x01\x04\0\x02\x02\x01\x12\x04\xd1\
    \x18\x04\x08\n\x10\n\x08\x04\x89\x01\x04\0\x02\x02\x02\x12\x04\xd1\x18\
    \x0b\x0c\n\x90\x02\n\x05\x04\x89\x01\x02\x04\x12\x04\xdc\x18\x02\x1e\x1a\
    \x80\x02\x20Workers\x20that\x20will\x20work\x20on\x20this\x20task.\n\n\
    \x20For\x20Auto\x20Annotation\x20Tasks:\n\x20\x20\x20the\x20worker\x20ca\
    n\x20be\x20either\x20a\x20model\x20or\x20a\x20workflow;\n\x20\x20\x20cur\
    rently\x20only\x20supports\x201\x20worker.\n\x20For\x20manual\x20labelin\
    g\x20Tasks:\n\x20\x20\x20the\x20workers\x20can\x20only\x20be\x20users;\n\
    \x20\x20\x20no\x20limitation\x20on\x20number\x20of\x20workers.\n\n\x0e\n\
    \x06\x04\x89\x01\x02\x04\x04\x12\x04\xdc\x18\x02\n\n\x0e\n\x06\x04\x89\
    \x01\x02\x04\x06\x12\x04\xdc\x18\x0b\x11\n\x0e\n\x06\x04\x89\x01\x02\x04\
    \x01\x12\x04\xdc\x18\x12\x19\n\x0e\n\x06\x04\x89\x01\x02\x04\x03\x12\x04\
    \xdc\x18\x1c\x1d\n2\n\x03\x04\x8a\x01\x12\x06\xe0\x18\0\x89\x19\x01\x1a#\
    \x20TaskWorkerPartitionedStrategyInfo\n\n\x0c\n\x04\x04\x8a\x01\x01\x12\
    \x04\xe0\x18\x08)\n9\n\x05\x04\x8a\x01\x02\0\x12\x04\xe2\x18\x02)\x1a*\
    \x20Define\x20how\x20the\x20partitioning\x20should\x20work.\n\n\x0e\n\
    \x06\x04\x8a\x01\x02\0\x06\x12\x04\xe2\x18\x02\x1f\n\x0e\n\x06\x04\x8a\
    \x01\x02\0\x01\x12\x04\xe2\x18\x20$\n\x0e\n\x06\x04\x8a\x01\x02\0\x03\
    \x12\x04\xe2\x18'(\n8\n\x05\x04\x8a\x01\x02\x01\x12\x04\xe5\x18\x02\x1e\
    \x1a)\x20How\x20many\x20workers\x20will\x20label\x20each\x20input.\n\n\
    \x0e\n\x06\x04\x8a\x01\x02\x01\x05\x12\x04\xe5\x18\x02\x07\n\x0e\n\x06\
    \x04\x8a\x01\x02\x01\x01\x12\x04\xe5\x18\x08\x19\n\x0e\n\x06\x04\x8a\x01\
    \x02\x01\x03\x12\x04\xe5\x18\x1c\x1d\n\xf7\x0b\n\x05\x04\x8a\x01\x02\x02\
    \x12\x04\xfd\x18\x02%\x1a\xe7\x0b\x20In\x20case\x20of\x20weighted\x20par\
    titioning,\x20map\x20user\x20ids\x20to\x20weights.\n\x20Each\x20labeler\
    \x20will\x20be\x20assigned\x20work\x20proportional\x20to\x20its\x20own\
    \x20weight\x20as\x20compared\x20to\x20the\x20sum\x20of\x20total\x20weigh\
    t.\n\n\x20EXAMPLE:\n\x20If\x20we\x20have\x203\x20workers,\x20and\x20weig\
    hts\x20=\x20{1:\x2030,\x202:\x2030,\x203:\x2040},\n\x20then\x20first\x20\
    worker\x20will\x20have\x20assigned\x2030%\x20of\x20the\x20work,\n\x20sec\
    ond\x20worker\x20will\x20have\x20assigned\x2030%\x20of\x20the\x20work,\n\
    \x20and\x20third\x20worker\x20will\x20have\x20assigned\x2040%\x20of\x20t\
    he\x20work.\n\x20You\x20may\x20use\x20weights\x20which\x20add\x20up\x20t\
    o\x20100,\x20but\x20it's\x20not\x20necessary.\n\x20For\x20example,\x20we\
    ights\x20{1:\x2030,\x202:\x2030,\x203:\x2040}\x20are\x20equivalent\x20wi\
    th\x20{1:\x203,\x202:\x203,\x203:\x204}\n\x20because\x20they\x20represen\
    t\x20the\x20same\x20percentages:\x20{1:\x2030%,\x202:\x2030%,\x203:\x204\
    0%}.\n\n\x20NOTE:\n\x20Note\x20that\x20no\x20worker\x20should\x20be\x20a\
    ssigned\x20a\x20weight\x20percentage\x20greater\x20than\x201/workers_per\
    _input.\n\x20It\x20is\x20mathematically\x20impossible\x20to\x20partition\
    \x20the\x20work\x20in\x20such\x20a\x20case.\n\x20Why?\x20Say,\x20we\x20h\
    ave\x203\x20workers.\x20And\x20workers_per_input\x20=\x202,\x20i.e.\x20e\
    ach\x20input\x20must\x20be\x20labeled\x20by\x202\x20workers.\n\x20Let's\
    \x20assign\x20weights\x20{1:\x2051%,\x202:\x2025%,\x203:\x2024%}.\n\x20N\
    ote\x20that\x20first\x20worker\x20has\x20a\x20weight\x20percentage\x20hi\
    gher\x20than\x201/workers_per_input\x20=\x201/2\x20=\x2050%.\n\x20If\x20\
    we\x20have\x20100\x20inputs,\x20then\x20a\x20total\x20of\x20100\x20*\x20\
    workers_per_input\x20=\x20200\x20cumulative\x20inputs\x20will\x20be\x20l\
    abeled\x20by\x20these\x203\x20workers.\n\x20Worker\x201\x20should\x20lab\
    el\x20102\x20cumulative\x20inputs,\x20while\x20worker\x202\x20and\x20wor\
    ker\x203\x20will\x20label\x2098\x20cumulative\x20inputs\x20together.\n\
    \x20No\x20matter\x20how\x20we\x20assign\x20the\x2098\x20cumulative\x20in\
    puts,\x20the\x202\x20workers\x20will\x20be\x20able\x20to\x20label\x20up\
    \x20to\x2098\x20actual\x20inputs.\n\x20This\x20means\x20the\x20remaining\
    \x202\x20inputs\x20will\x20be\x20labeled\x20only\x20by\x20worker\x201.\
    \x20This\x20contradicts\x20the\x20worker_per_input\x20=\x202\x20requirem\
    ent.\n\n\x0e\n\x06\x04\x8a\x01\x02\x02\x06\x12\x04\xfd\x18\x02\x18\n\x0e\
    \n\x06\x04\x8a\x01\x02\x02\x01\x12\x04\xfd\x18\x19\x20\n\x0e\n\x06\x04\
    \x8a\x01\x02\x02\x03\x12\x04\xfd\x18#$\n\x0f\n\x05\x04\x8a\x01\x04\0\x12\
    \x06\xff\x18\x02\x88\x19\x03\n\x0e\n\x06\x04\x8a\x01\x04\0\x01\x12\x04\
    \xff\x18\x07$\n\x0f\n\x07\x04\x8a\x01\x04\0\x02\0\x12\x04\x80\x19\x04,\n\
    \x10\n\x08\x04\x8a\x01\x04\0\x02\0\x01\x12\x04\x80\x19\x04'\n\x10\n\x08\
    \x04\x8a\x01\x04\0\x02\0\x02\x12\x04\x80\x19*+\nT\n\x07\x04\x8a\x01\x04\
    \0\x02\x01\x12\x04\x83\x19\x04\x0f\x1aC\x20Each\x20worker\x20will\x20lab\
    el\x20(approximately)\x20the\x20same\x20number\x20of\x20inputs.\n\n\x10\
    \n\x08\x04\x8a\x01\x04\0\x02\x01\x01\x12\x04\x83\x19\x04\n\n\x10\n\x08\
    \x04\x8a\x01\x04\0\x02\x01\x02\x12\x04\x83\x19\r\x0e\na\n\x07\x04\x8a\
    \x01\x04\0\x02\x02\x12\x04\x87\x19\x04\x11\x1aP\x20Each\x20worker\x20wil\
    l\x20have\x20an\x20assigned\x20weight.\n\x20See\x20weights\x20field\x20f\
    or\x20more\x20details.\n\n\x10\n\x08\x04\x8a\x01\x04\0\x02\x02\x01\x12\
    \x04\x87\x19\x04\x0c\n\x10\n\x08\x04\x8a\x01\x04\0\x02\x02\x02\x12\x04\
    \x87\x19\x0f\x10\n\x20\n\x03\x04\x8b\x01\x12\x06\x8c\x19\0\x9d\x19\x01\
    \x1a\x11\x20TaskInputSource\n\n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\x8c\
    \x19\x08\x17\n&\n\x05\x04\x8b\x01\x02\0\x12\x04\x8e\x19\x02\x1f\x1a\x17\
    \x20Type\x20of\x20input\x20source.\n\n\x0e\n\x06\x04\x8b\x01\x02\0\x06\
    \x12\x04\x8e\x19\x02\x15\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\x04\x8e\
    \x19\x16\x1a\n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\x8e\x19\x1d\x1e\n\
    K\n\x05\x04\x8b\x01\x02\x01\x12\x04\x91\x19\x02\x10\x1a<\x20If\x20type\
    \x20is\x20SAVED_SEARCH,\x20then\x20this\x20is\x20the\x20saved\x20search\
    \x20id.\n\n\x0e\n\x06\x04\x8b\x01\x02\x01\x05\x12\x04\x91\x19\x02\x08\n\
    \x0e\n\x06\x04\x8b\x01\x02\x01\x01\x12\x04\x91\x19\t\x0b\n\x0e\n\x06\x04\
    \x8b\x01\x02\x01\x03\x12\x04\x91\x19\x0e\x0f\n\x0f\n\x05\x04\x8b\x01\x04\
    \0\x12\x06\x93\x19\x02\x9c\x19\x03\n\x0e\n\x06\x04\x8b\x01\x04\0\x01\x12\
    \x04\x93\x19\x07\x1a\n\x0f\n\x07\x04\x8b\x01\x04\0\x02\0\x12\x04\x94\x19\
    \x04\"\n\x10\n\x08\x04\x8b\x01\x04\0\x02\0\x01\x12\x04\x94\x19\x04\x1d\n\
    \x10\n\x08\x04\x8b\x01\x04\0\x02\0\x02\x12\x04\x94\x19\x20!\n-\n\x07\x04\
    \x8b\x01\x04\0\x02\x01\x12\x04\x97\x19\x04\x13\x1a\x1c\x20Use\x20all\x20\
    inputs\x20in\x20the\x20app.\n\n\x10\n\x08\x04\x8b\x01\x04\0\x02\x01\x01\
    \x12\x04\x97\x19\x04\x0e\n\x10\n\x08\x04\x8b\x01\x04\0\x02\x01\x02\x12\
    \x04\x97\x19\x11\x12\n6\n\x07\x04\x8b\x01\x04\0\x02\x02\x12\x04\x99\x19\
    \x04\x15\x1a%\x20Use\x20the\x20inputs\x20from\x20a\x20saved\x20search.\n\
    \n\x10\n\x08\x04\x8b\x01\x04\0\x02\x02\x01\x12\x04\x99\x19\x04\x10\n\x10\
    \n\x08\x04\x8b\x01\x04\0\x02\x02\x02\x12\x04\x99\x19\x13\x14\n)\n\x07\
    \x04\x8b\x01\x04\0\x02\x03\x12\x04\x9b\x19\x04\x10\x1a\x18\x20Inputs\x20\
    from\x20a\x20dataset.\n\n\x10\n\x08\x04\x8b\x01\x04\0\x02\x03\x01\x12\
    \x04\x9b\x19\x04\x0b\n\x10\n\x08\x04\x8b\x01\x04\0\x02\x03\x02\x12\x04\
    \x9b\x19\x0e\x0f\n\x1b\n\x03\x04\x8c\x01\x12\x06\xa0\x19\0\xbf\x19\x01\
    \x1a\x0c\x20TaskReview\n\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xa0\x19\x08\
    \x12\n&\n\x05\x04\x8c\x01\x02\0\x12\x04\xa2\x19\x02\"\x1a\x17\x20Task\
    \x20review\x20strategy.\n\n\x0e\n\x06\x04\x8c\x01\x02\0\x06\x12\x04\xa2\
    \x19\x02\x14\n\x0e\n\x06\x04\x8c\x01\x02\0\x01\x12\x04\xa2\x19\x15\x1d\n\
    \x0e\n\x06\x04\x8c\x01\x02\0\x03\x12\x04\xa2\x19\x20!\nN\n\x05\x04\x8c\
    \x01\x02\x01\x12\x04\xa6\x19\x023\x1a?\x20Who\x20will\x20review\x20this\
    \x20task.\n\x20DEPRECATED:\x20Use\x20users.id\x20instead.\n\n\x0e\n\x06\
    \x04\x8c\x01\x02\x01\x04\x12\x04\xa6\x19\x02\n\n\x0e\n\x06\x04\x8c\x01\
    \x02\x01\x05\x12\x04\xa6\x19\x0b\x11\n\x0e\n\x06\x04\x8c\x01\x02\x01\x01\
    \x12\x04\xa6\x19\x12\x1a\n\x0e\n\x06\x04\x8c\x01\x02\x01\x03\x12\x04\xa6\
    \x19\x1d\x1e\n\x0e\n\x06\x04\x8c\x01\x02\x01\x08\x12\x04\xa6\x19\x1f2\n\
    \x0f\n\x07\x04\x8c\x01\x02\x01\x08\x03\x12\x04\xa6\x19\x201\n\xc6\x01\n\
    \x05\x04\x8c\x01\x02\x02\x12\x04\xab\x19\x02\x1a\x1a\xb6\x01\x20Users\
    \x20who\x20will\x20review\x20this\x20task.\n\x20When\x20the\x20'review.u\
    sers'\x20field\x20is\x20additionally\x20requested,\x20then\x20all\x20use\
    r\n\x20info\x20is\x20filled\x20for\x20the\x20reviewers.\x20Otherwise,\
    \x20only\x20the\x20user\x20'id'\x20is\x20filled.\n\n\x0e\n\x06\x04\x8c\
    \x01\x02\x02\x04\x12\x04\xab\x19\x02\n\n\x0e\n\x06\x04\x8c\x01\x02\x02\
    \x06\x12\x04\xab\x19\x0b\x0f\n\x0e\n\x06\x04\x8c\x01\x02\x02\x01\x12\x04\
    \xab\x19\x10\x15\n\x0e\n\x06\x04\x8c\x01\x02\x02\x03\x12\x04\xab\x19\x18\
    \x19\n5\n\x05\x04\x8c\x01\x08\0\x12\x06\xae\x19\x02\xb1\x19\x03\x1a$\x20\
    Info\x20based\x20on\x20the\x20review\x20strategy,\n\n\x0e\n\x06\x04\x8c\
    \x01\x08\0\x01\x12\x04\xae\x19\x08\x15\n\r\n\x05\x04\x8c\x01\x02\x03\x12\
    \x04\xaf\x19\x04:\n\x0e\n\x06\x04\x8c\x01\x02\x03\x06\x12\x04\xaf\x19\
    \x04\x20\n\x0e\n\x06\x04\x8c\x01\x02\x03\x01\x12\x04\xaf\x19!5\n\x0e\n\
    \x06\x04\x8c\x01\x02\x03\x03\x12\x04\xaf\x1989\n\r\n\x05\x04\x8c\x01\x02\
    \x04\x12\x04\xb0\x19\x04@\n\x0e\n\x06\x04\x8c\x01\x02\x04\x06\x12\x04\
    \xb0\x19\x04#\n\x0e\n\x06\x04\x8c\x01\x02\x04\x01\x12\x04\xb0\x19$;\n\
    \x0e\n\x06\x04\x8c\x01\x02\x04\x03\x12\x04\xb0\x19>?\n\x0f\n\x05\x04\x8c\
    \x01\x04\0\x12\x06\xb3\x19\x02\xbe\x19\x03\n\x0e\n\x06\x04\x8c\x01\x04\0\
    \x01\x12\x04\xb3\x19\x07\x19\n\x0f\n\x07\x04\x8c\x01\x04\0\x02\0\x12\x04\
    \xb4\x19\x04%\n\x10\n\x08\x04\x8c\x01\x04\0\x02\0\x01\x12\x04\xb4\x19\
    \x04\x20\n\x10\n\x08\x04\x8c\x01\x04\0\x02\0\x02\x12\x04\xb4\x19#$\n'\n\
    \x07\x04\x8c\x01\x04\0\x02\x01\x12\x04\xb7\x19\x04\r\x1a\x16\x20No\x20re\
    view\x20is\x20needed.\n\n\x10\n\x08\x04\x8c\x01\x04\0\x02\x01\x01\x12\
    \x04\xb7\x19\x04\x08\n\x10\n\x08\x04\x8c\x01\x04\0\x02\x01\x02\x12\x04\
    \xb7\x19\x0b\x0c\n*\n\x07\x04\x8c\x01\x04\0\x02\x02\x12\x04\xba\x19\x04\
    \x0f\x1a\x19\x20Manual\x20review\x20strategy.\n\n\x10\n\x08\x04\x8c\x01\
    \x04\0\x02\x02\x01\x12\x04\xba\x19\x04\n\n\x10\n\x08\x04\x8c\x01\x04\0\
    \x02\x02\x02\x12\x04\xba\x19\r\x0e\n-\n\x07\x04\x8c\x01\x04\0\x02\x03\
    \x12\x04\xbd\x19\x04\x12\x1a\x1c\x20Consensus\x20review\x20strategy.\n\n\
    \x10\n\x08\x04\x8c\x01\x04\0\x02\x03\x01\x12\x04\xbd\x19\x04\r\n\x10\n\
    \x08\x04\x8c\x01\x04\0\x02\x03\x02\x12\x04\xbd\x19\x10\x11\n-\n\x03\x04\
    \x8d\x01\x12\x06\xc2\x19\0\xc5\x19\x01\x1a\x1e\x20TaskReviewManualStrate\
    gyInfo\n\n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\xc2\x19\x08$\n\x82\x01\n\
    \x05\x04\x8d\x01\x02\0\x12\x04\xc4\x19\x02\x1e\x1as\x20This\x20field\x20\
    represents\x20the\x20percentage\x20of\x20inputs\x20that\x20will\x20be\
    \x20reviewed\x20by\x20reviewers.\x20It\x20is\x20a\x20value\x20between\
    \x200\x20and\x201.\n\n\x0e\n\x06\x04\x8d\x01\x02\0\x05\x12\x04\xc4\x19\
    \x02\x07\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xc4\x19\x08\x19\n\x0e\
    \n\x06\x04\x8d\x01\x02\0\x03\x12\x04\xc4\x19\x1c\x1d\n0\n\x03\x04\x8e\
    \x01\x12\x06\xc8\x19\0\xcd\x19\x01\x1a!\x20TaskReviewConsensusStrategyIn\
    fo\n\n\x0c\n\x04\x04\x8e\x01\x01\x12\x04\xc8\x19\x08'\n\x0c\n\x04\x04\
    \x8e\x01\t\x12\x04\xc9\x19\x02\r\n\r\n\x05\x04\x8e\x01\t\0\x12\x04\xc9\
    \x19\x0b\x0c\n\x0e\n\x06\x04\x8e\x01\t\0\x01\x12\x04\xc9\x19\x0b\x0c\n\
    \x0e\n\x06\x04\x8e\x01\t\0\x02\x12\x04\xc9\x19\x0b\x0c\nk\n\x05\x04\x8e\
    \x01\x02\0\x12\x04\xcc\x19\x02\x20\x1a\\\x20The\x20number\x20of\x20label\
    ers\x20that\x20need\x20to\x20agree\x20in\x20order\x20to\x20automatically\
    \x20approve\x20an\x20annotation.\n\n\x0e\n\x06\x04\x8e\x01\x02\0\x05\x12\
    \x04\xcc\x19\x02\x08\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\x04\xcc\x19\t\
    \x1b\n\x0e\n\x06\x04\x8e\x01\x02\0\x03\x12\x04\xcc\x19\x1e\x1f\n\x20\n\
    \x03\x04\x8f\x01\x12\x06\xd0\x19\0\xd5\x19\x01\x1a\x11\x20TaskAIAssistan\
    t\n\n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\xd0\x19\x08\x17\n\xb8\x01\n\x05\
    \x04\x8f\x01\x02\0\x12\x04\xd4\x19\x02\x19\x1a\xa8\x01\x20The\x20worker\
    \x20is\x20helped\x20by\x20an\x20AI\x20assistant.\n\x20This\x20field\x20i\
    s\x20the\x20workflow\x20id\x20which\x20is\x20used\x20to\x20assist\x20the\
    \x20worker\x20with\x20predictions.\n\x20If\x20empty,\x20then\x20AI\x20as\
    sistant\x20is\x20disabled.\n\n\x0e\n\x06\x04\x8f\x01\x02\0\x05\x12\x04\
    \xd4\x19\x02\x08\n\x0e\n\x06\x04\x8f\x01\x02\0\x01\x12\x04\xd4\x19\t\x14\
    \n\x0e\n\x06\x04\x8f\x01\x02\0\x03\x12\x04\xd4\x19\x17\x18\n\r\n\x03\x04\
    \x90\x01\x12\x06\xd7\x19\0\xed\x19\x01\n\x0c\n\x04\x04\x90\x01\x01\x12\
    \x04\xd7\x19\x08\x16\n\r\n\x05\x04\x90\x01\x02\0\x12\x04\xd8\x19\x02\x10\
    \n\x0e\n\x06\x04\x90\x01\x02\0\x05\x12\x04\xd8\x19\x02\x08\n\x0e\n\x06\
    \x04\x90\x01\x02\0\x01\x12\x04\xd8\x19\t\x0b\n\x0e\n\x06\x04\x90\x01\x02\
    \0\x03\x12\x04\xd8\x19\x0e\x0f\n}\n\x05\x04\x90\x01\x02\x01\x12\x04\xdd\
    \x19\x02+\x1an\x20Creation\x20time.\n\x20The\x20format\x20is\x20https://\
    www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999\
    999Z\".\n\n\x0e\n\x06\x04\x90\x01\x02\x01\x06\x12\x04\xdd\x19\x02\x1b\n\
    \x0e\n\x06\x04\x90\x01\x02\x01\x01\x12\x04\xdd\x19\x1c&\n\x0e\n\x06\x04\
    \x90\x01\x02\x01\x03\x12\x04\xdd\x19)*\n\x8d\x01\n\x05\x04\x90\x01\x02\
    \x02\x12\x04\xe2\x19\x02,\x1a~\x20Most\x20recent\x20modification\x20time\
    .\n\x20The\x20format\x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\
    \x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\x0e\n\x06\x04\x90\
    \x01\x02\x02\x06\x12\x04\xe2\x19\x02\x1b\n\x0e\n\x06\x04\x90\x01\x02\x02\
    \x01\x12\x04\xe2\x19\x1c'\n\x0e\n\x06\x04\x90\x01\x02\x02\x03\x12\x04\
    \xe2\x19*+\n!\n\x05\x04\x90\x01\x02\x03\x12\x04\xe5\x19\x02\x14\x1a\x12\
    \x20Assigned\x20worker.\n\n\x0e\n\x06\x04\x90\x01\x02\x03\x06\x12\x04\
    \xe5\x19\x02\x08\n\x0e\n\x06\x04\x90\x01\x02\x03\x01\x12\x04\xe5\x19\t\
    \x0f\n\x0e\n\x06\x04\x90\x01\x02\x03\x03\x12\x04\xe5\x19\x12\x13\n\x20\n\
    \x05\x04\x90\x01\x02\x04\x12\x04\xe8\x19\x02\x12\x1a\x11\x20Assigned\x20\
    input.\n\n\x0e\n\x06\x04\x90\x01\x02\x04\x06\x12\x04\xe8\x19\x02\x07\n\
    \x0e\n\x06\x04\x90\x01\x02\x04\x01\x12\x04\xe8\x19\x08\r\n\x0e\n\x06\x04\
    \x90\x01\x02\x04\x03\x12\x04\xe8\x19\x10\x11\nx\n\x05\x04\x90\x01\x02\
    \x05\x12\x04\xec\x19\x02(\x1ai\x20Assignment\x20status.\n\x20Read\x20as:\
    \x20This\x20is\x20the\x20status\x20of\x20the\x20work\x20assigned\x20to\
    \x20worker\x20W,\x20on\x20input\x20I\x20in\x20task\x20T.\n\n\x0e\n\x06\
    \x04\x90\x01\x02\x05\x06\x12\x04\xec\x19\x02\x1c\n\x0e\n\x06\x04\x90\x01\
    \x02\x05\x01\x12\x04\xec\x19\x1d#\n\x0e\n\x06\x04\x90\x01\x02\x05\x03\
    \x12\x04\xec\x19&'\n\xf0\x01\n\x03\x04\x91\x01\x12\x06\xf2\x19\0\xfd\x19\
    \x01\x1a\xe0\x01\x20TaskStatusCountPerUser\x20can\x20represent\x20one\
    \x20of\x20the\x20following:\n\x20*\x20count\x20of\x20task\x20annotations\
    \x20created\x20by\x20a\x20worker\x20for\x20each\x20valid\x20status,\n\
    \x20*\x20count\x20of\x20task\x20inputs\x20assigned\x20to\x20a\x20worker\
    \x20\x20(i.e.\x20task\x20assignments)\x20for\x20each\x20valid\x20status\
    \n\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\xf2\x19\x08\x1e\n0\n\x05\x04\x91\
    \x01\x02\0\x12\x04\xf4\x19\x02)\x1a!\x20Deprecated:\x20Use\x20worker\x20\
    instead.\n\n\x0e\n\x06\x04\x91\x01\x02\0\x05\x12\x04\xf4\x19\x02\x08\n\
    \x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\xf4\x19\t\x10\n\x0e\n\x06\x04\
    \x91\x01\x02\0\x03\x12\x04\xf4\x19\x13\x14\n\x0e\n\x06\x04\x91\x01\x02\0\
    \x08\x12\x04\xf4\x19\x15(\n\x0f\n\x07\x04\x91\x01\x02\0\x08\x03\x12\x04\
    \xf4\x19\x16'\n\r\n\x05\x04\x91\x01\x02\x01\x12\x04\xf6\x19\x02D\n\x0e\n\
    \x06\x04\x91\x01\x02\x01\x05\x12\x04\xf6\x19\x02\x08\n\x0e\n\x06\x04\x91\
    \x01\x02\x01\x01\x12\x04\xf6\x19\t\x10\n\x0e\n\x06\x04\x91\x01\x02\x01\
    \x03\x12\x04\xf6\x19\x13\x14\n\x0e\n\x06\x04\x91\x01\x02\x01\x08\x12\x04\
    \xf6\x19\x15C\n\x11\n\t\x04\x91\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xf6\
    \x19\x16B\n\r\n\x05\x04\x91\x01\x02\x02\x12\x04\xf7\x19\x02L\n\x0e\n\x06\
    \x04\x91\x01\x02\x02\x05\x12\x04\xf7\x19\x02\x08\n\x0e\n\x06\x04\x91\x01\
    \x02\x02\x01\x12\x04\xf7\x19\t\x18\n\x0e\n\x06\x04\x91\x01\x02\x02\x03\
    \x12\x04\xf7\x19\x1b\x1c\n\x0e\n\x06\x04\x91\x01\x02\x02\x08\x12\x04\xf7\
    \x19\x1dK\n\x11\n\t\x04\x91\x01\x02\x02\x08\xd0\x86\x03\x12\x04\xf7\x19\
    \x1eJ\n\r\n\x05\x04\x91\x01\x02\x03\x12\x04\xf8\x19\x02D\n\x0e\n\x06\x04\
    \x91\x01\x02\x03\x05\x12\x04\xf8\x19\x02\x08\n\x0e\n\x06\x04\x91\x01\x02\
    \x03\x01\x12\x04\xf8\x19\t\x10\n\x0e\n\x06\x04\x91\x01\x02\x03\x03\x12\
    \x04\xf8\x19\x13\x14\n\x0e\n\x06\x04\x91\x01\x02\x03\x08\x12\x04\xf8\x19\
    \x15C\n\x11\n\t\x04\x91\x01\x02\x03\x08\xd0\x86\x03\x12\x04\xf8\x19\x16B\
    \n\r\n\x05\x04\x91\x01\x02\x04\x12\x04\xf9\x19\x02J\n\x0e\n\x06\x04\x91\
    \x01\x02\x04\x05\x12\x04\xf9\x19\x02\x08\n\x0e\n\x06\x04\x91\x01\x02\x04\
    \x01\x12\x04\xf9\x19\t\x16\n\x0e\n\x06\x04\x91\x01\x02\x04\x03\x12\x04\
    \xf9\x19\x19\x1a\n\x0e\n\x06\x04\x91\x01\x02\x04\x08\x12\x04\xf9\x19\x1b\
    I\n\x11\n\t\x04\x91\x01\x02\x04\x08\xd0\x86\x03\x12\x04\xf9\x19\x1cH\n\r\
    \n\x05\x04\x91\x01\x02\x05\x12\x04\xfa\x19\x02V\n\x0e\n\x06\x04\x91\x01\
    \x02\x05\x05\x12\x04\xfa\x19\x02\x08\n\x0e\n\x06\x04\x91\x01\x02\x05\x01\
    \x12\x04\xfa\x19\t\"\n\x0e\n\x06\x04\x91\x01\x02\x05\x03\x12\x04\xfa\x19\
    %&\n\x0e\n\x06\x04\x91\x01\x02\x05\x08\x12\x04\xfa\x19'U\n\x11\n\t\x04\
    \x91\x01\x02\x05\x08\xd0\x86\x03\x12\x04\xfa\x19(T\n\r\n\x05\x04\x91\x01\
    \x02\x06\x12\x04\xfc\x19\x02\x14\n\x0e\n\x06\x04\x91\x01\x02\x06\x06\x12\
    \x04\xfc\x19\x02\x08\n\x0e\n\x06\x04\x91\x01\x02\x06\x01\x12\x04\xfc\x19\
    \t\x0f\n\x0e\n\x06\x04\x91\x01\x02\x06\x03\x12\x04\xfc\x19\x12\x13\n\r\n\
    \x03\x04\x92\x01\x12\x06\xff\x19\0\x87\x1a\x01\n\x0c\n\x04\x04\x92\x01\
    \x01\x12\x04\xff\x19\x08\x16\n\x9a\x02\n\x05\x04\x92\x01\x02\0\x12\x04\
    \x83\x1a\x02\x1e\x1a\x8a\x02\x20The\x20range\x20used\x20to\x20filter\x20\
    over\x20concept\x20values.\n\x20e.g.\x20GREATER_THAN_OR_EQUAL_TO\x200.7\
    \x20->\x20is_lower_inclusive\x20=\x20true,\x20lower\x20=\x200.7,\x20is_u\
    pper_inclusive\x20=\x20true,\x20upper\x20=\x201.0\n\x20e.g.\x20(0.3,\x20\
    0.75]\x20->\x20is_lower_inclusive\x20=\x20false,\x20lower\x20=\x200.3,\
    \x20is_upper_inclusive\x20=\x20true,\x20upper\x20=\x200.75\n\n\x0e\n\x06\
    \x04\x92\x01\x02\0\x05\x12\x04\x83\x1a\x02\x06\n\x0e\n\x06\x04\x92\x01\
    \x02\0\x01\x12\x04\x83\x1a\x07\x19\n\x0e\n\x06\x04\x92\x01\x02\0\x03\x12\
    \x04\x83\x1a\x1c\x1d\n\r\n\x05\x04\x92\x01\x02\x01\x12\x04\x84\x1a\x02\
    \x1e\n\x0e\n\x06\x04\x92\x01\x02\x01\x05\x12\x04\x84\x1a\x02\x06\n\x0e\n\
    \x06\x04\x92\x01\x02\x01\x01\x12\x04\x84\x1a\x07\x19\n\x0e\n\x06\x04\x92\
    \x01\x02\x01\x03\x12\x04\x84\x1a\x1c\x1d\n\r\n\x05\x04\x92\x01\x02\x02\
    \x12\x04\x85\x1a\x02\x12\n\x0e\n\x06\x04\x92\x01\x02\x02\x05\x12\x04\x85\
    \x1a\x02\x07\n\x0e\n\x06\x04\x92\x01\x02\x02\x01\x12\x04\x85\x1a\x08\r\n\
    \x0e\n\x06\x04\x92\x01\x02\x02\x03\x12\x04\x85\x1a\x10\x11\n\r\n\x05\x04\
    \x92\x01\x02\x03\x12\x04\x86\x1a\x02\x12\n\x0e\n\x06\x04\x92\x01\x02\x03\
    \x05\x12\x04\x86\x1a\x02\x07\n\x0e\n\x06\x04\x92\x01\x02\x03\x01\x12\x04\
    \x86\x1a\x08\r\n\x0e\n\x06\x04\x92\x01\x02\x03\x03\x12\x04\x86\x1a\x10\
    \x11\n\r\n\x03\x04\x93\x01\x12\x06\x89\x1a\0\x95\x1a\x01\n\x0c\n\x04\x04\
    \x93\x01\x01\x12\x04\x89\x1a\x08'\n\xc5\x02\n\x05\x04\x93\x01\x02\0\x12\
    \x04\x8e\x1a\x02#\x1a\xb5\x02\x20Filter\x20annotations\x20by\x20their\
    \x20annotation\x20data\x20type.\n\x20This\x20is\x20a\x20bit-mask\x20fiel\
    d\x20that\x20holds\x20multiple\x20AnnotationDataType\x20values\x20that\
    \x20are\x20combined\x20in\x20an\x20OR\x20fashion.\n\x20Example:\x20if\
    \x20annotation_data_types\x20=\x2034,\x20then\x20we\x20filter\x20annotat\
    ions\x20that\x20appear\x20as\x20a\x20mask\x20or\x20a\x20bounding\x20box,\
    \n\x20because\x20MASK\x20=\x2032\x20and\x20BOUNDING_BOX\x20=\x202.\n\n\
    \x0e\n\x06\x04\x93\x01\x02\0\x05\x12\x04\x8e\x1a\x02\x08\n\x0e\n\x06\x04\
    \x93\x01\x02\0\x01\x12\x04\x8e\x1a\t\x1e\n\x0e\n\x06\x04\x93\x01\x02\0\
    \x03\x12\x04\x8e\x1a!\"\n\x84\x01\n\x05\x04\x93\x01\x02\x01\x12\x04\x92\
    \x1a\x02%\x1au\x20Filter\x20annotations\x20by\x20concept\x20value.\n\x20\
    Only\x20concepts\x20that\x20fit\x20in\x20the\x20threshold\x20will\x20be\
    \x20used\x20to\x20generate\x20annotations.\n\n\x0e\n\x06\x04\x93\x01\x02\
    \x01\x06\x12\x04\x92\x1a\x02\x10\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\
    \x04\x92\x1a\x11\x20\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\x92\x1a\
    #$\nO\n\x05\x04\x93\x01\x02\x02\x12\x04\x94\x1a\x021\x1a@\x20The\x20outp\
    ut\x20annotations\x20will\x20be\x20created\x20using\x20this\x20status\
    \x20code.\n\n\x0e\n\x06\x04\x93\x01\x02\x02\x06\x12\x04\x94\x1a\x02\x20\
    \n\x0e\n\x06\x04\x93\x01\x02\x02\x01\x12\x04\x94\x1a!,\n\x0e\n\x06\x04\
    \x93\x01\x02\x02\x03\x12\x04\x94\x1a/0\n\r\n\x03\x04\x94\x01\x12\x06\x97\
    \x1a\0\x9b\x1a\x01\n\x0c\n\x04\x04\x94\x01\x01\x12\x04\x97\x1a\x08\x13\n\
    \x89\x01\n\x05\x04\x94\x01\x02\0\x12\x04\x99\x1a\x02\x16\x1az\x20For\x20\
    auto\x20annotation,\x20id/name\x20and\x20value,\x20user\x20+\x20app\x20i\
    d\x20must\x20be\x20specified.\x20For\x20other\x20tasks,\x20only\x20the\
    \x20id\x20field\x20is\x20required.\n\n\x0e\n\x06\x04\x94\x01\x02\0\x06\
    \x12\x04\x99\x1a\x02\t\n\x0e\n\x06\x04\x94\x01\x02\0\x01\x12\x04\x99\x1a\
    \n\x11\n\x0e\n\x06\x04\x94\x01\x02\0\x03\x12\x04\x99\x1a\x14\x15\n\r\n\
    \x05\x04\x94\x01\x02\x01\x12\x04\x9a\x1a\x02=\n\x0e\n\x06\x04\x94\x01\
    \x02\x01\x06\x12\x04\x9a\x1a\x02!\n\x0e\n\x06\x04\x94\x01\x02\x01\x01\
    \x12\x04\x9a\x1a\"8\n\x0e\n\x06\x04\x94\x01\x02\x01\x03\x12\x04\x9a\x1a;\
    <\n\x0c\n\x02\x05\x0b\x12\x06\x9c\x1a\0\xa4\x1a\x01\n\x0b\n\x03\x05\x0b\
    \x01\x12\x04\x9c\x1a\x05\x17\n\x0c\n\x04\x05\x0b\x02\0\x12\x04\x9d\x1a\
    \x02#\n\r\n\x05\x05\x0b\x02\0\x01\x12\x04\x9d\x1a\x02\x1e\n\r\n\x05\x05\
    \x0b\x02\0\x02\x12\x04\x9d\x1a!\"\n\x0c\n\x04\x05\x0b\x02\x01\x12\x04\
    \x9e\x1a\x02\n\n\r\n\x05\x05\x0b\x02\x01\x01\x12\x04\x9e\x1a\x02\x05\n\r\
    \n\x05\x05\x0b\x02\x01\x02\x12\x04\x9e\x1a\x08\t\n\x0c\n\x04\x05\x0b\x02\
    \x02\x12\x04\x9f\x1a\x02\x13\n\r\n\x05\x05\x0b\x02\x02\x01\x12\x04\x9f\
    \x1a\x02\x0e\n\r\n\x05\x05\x0b\x02\x02\x02\x12\x04\x9f\x1a\x11\x12\n\x0c\
    \n\x04\x05\x0b\x02\x03\x12\x04\xa0\x1a\x02\x0e\n\r\n\x05\x05\x0b\x02\x03\
    \x01\x12\x04\xa0\x1a\x02\t\n\r\n\x05\x05\x0b\x02\x03\x02\x12\x04\xa0\x1a\
    \x0c\r\n\x0c\n\x04\x05\x0b\x02\x04\x12\x04\xa1\x1a\x02\x0c\n\r\n\x05\x05\
    \x0b\x02\x04\x01\x12\x04\xa1\x1a\x02\x07\n\r\n\x05\x05\x0b\x02\x04\x02\
    \x12\x04\xa1\x1a\n\x0b\n\x0c\n\x04\x05\x0b\x02\x05\x12\x04\xa2\x1a\x02\
    \x0c\n\r\n\x05\x05\x0b\x02\x05\x01\x12\x04\xa2\x1a\x02\x06\n\r\n\x05\x05\
    \x0b\x02\x05\x02\x12\x04\xa2\x1a\t\x0b\n\x0c\n\x04\x05\x0b\x02\x06\x12\
    \x04\xa3\x1a\x02\x0c\n\r\n\x05\x05\x0b\x02\x06\x01\x12\x04\xa3\x1a\x02\
    \x06\n\r\n\x05\x05\x0b\x02\x06\x02\x12\x04\xa3\x1a\t\x0b\n\r\n\x03\x04\
    \x95\x01\x12\x06\xa7\x1a\0\xab\x1a\x01\n\x0c\n\x04\x04\x95\x01\x01\x12\
    \x04\xa7\x1a\x08\x13\n\x0c\n\x04\x04\x95\x01\t\x12\x04\xa8\x1a\x02\r\n\r\
    \n\x05\x04\x95\x01\t\0\x12\x04\xa8\x1a\x0b\x0c\n\x0e\n\x06\x04\x95\x01\t\
    \0\x01\x12\x04\xa8\x1a\x0b\x0c\n\x0e\n\x06\x04\x95\x01\t\0\x02\x12\x04\
    \xa8\x1a\x0b\x0c\n\r\n\x05\x04\x95\x01\x02\0\x12\x04\xaa\x1a\x02\x1b\n\
    \x0e\n\x06\x04\x95\x01\x02\0\x06\x12\x04\xaa\x1a\x02\x11\n\x0e\n\x06\x04\
    \x95\x01\x02\0\x01\x12\x04\xaa\x1a\x12\x16\n\x0e\n\x06\x04\x95\x01\x02\0\
    \x03\x12\x04\xaa\x1a\x19\x1a\n\r\n\x03\x04\x96\x01\x12\x06\xad\x1a\0\xb3\
    \x1a\x01\n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xad\x1a\x08\x17\nH\n\x05\
    \x04\x96\x01\x02\0\x12\x04\xaf\x1a\x02$\x1a9\x20Estimated\x20number\x20o\
    f\x20inputs\x20that\x20workers\x20have\x20worked\x20on.\n\n\x0e\n\x06\
    \x04\x96\x01\x02\0\x05\x12\x04\xaf\x1a\x02\x08\n\x0e\n\x06\x04\x96\x01\
    \x02\0\x01\x12\x04\xaf\x1a\t\x1f\n\x0e\n\x06\x04\x96\x01\x02\0\x03\x12\
    \x04\xaf\x1a\"#\n\x8a\x01\n\x05\x04\x96\x01\x02\x01\x12\x04\xb2\x1a\x02&\
    \x1a{\x20Estimated\x20percent\x20of\x20inputs\x20that\x20workers\x20have\
    \x20worked\x20on.\n\x20This\x20is\x20a\x20value\x20between\x200\x20and\
    \x20100,\x20where\x200\x20=\x200%\x20and\x20100\x20=\x20100%.\n\n\x0e\n\
    \x06\x04\x96\x01\x02\x01\x05\x12\x04\xb2\x1a\x02\x08\n\x0e\n\x06\x04\x96\
    \x01\x02\x01\x01\x12\x04\xb2\x1a\t!\n\x0e\n\x06\x04\x96\x01\x02\x01\x03\
    \x12\x04\xb2\x1a$%\n\x0c\n\x02\x05\x0c\x12\x06\xb5\x1a\0\xb8\x1a\x01\n\
    \x0b\n\x03\x05\x0c\x01\x12\x04\xb5\x1a\x05\r\n\x0c\n\x04\x05\x0c\x02\0\
    \x12\x04\xb6\x1a\x02\x0b\n\r\n\x05\x05\x0c\x02\0\x01\x12\x04\xb6\x1a\x02\
    \x06\n\r\n\x05\x05\x0c\x02\0\x02\x12\x04\xb6\x1a\t\n\n\x0c\n\x04\x05\x0c\
    \x02\x01\x12\x04\xb7\x1a\x02\n\n\r\n\x05\x05\x0c\x02\x01\x01\x12\x04\xb7\
    \x1a\x02\x05\n\r\n\x05\x05\x0c\x02\x01\x02\x12\x04\xb7\x1a\x08\t\n\x8c\
    \x01\n\x03\x04\x97\x01\x12\x06\xc4\x1a\0\xfe\x1a\x01\x1a}\x20Collector\
    \x20is\x20a\x20data\x20pathway\x20from\x20a\x20CollectorSource\x20to\x20\
    an\x20app\x20to\x20collect\x20data\x20automatically.\n\x20For\x20example\
    ,\x20a\x20CollectorSource\n\n\x0c\n\x04\x04\x97\x01\x01\x12\x04\xc4\x1a\
    \x08\x11\n-\n\x05\x04\x97\x01\x02\0\x12\x04\xc6\x1a\x02\x10\x1a\x1e\x20U\
    nique\x20ID\x20for\x20the\x20collector.\n\n\x0e\n\x06\x04\x97\x01\x02\0\
    \x05\x12\x04\xc6\x1a\x02\x08\n\x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\
    \xc6\x1a\t\x0b\n\x0e\n\x06\x04\x97\x01\x02\0\x03\x12\x04\xc6\x1a\x0e\x0f\
    \n>\n\x05\x04\x97\x01\x02\x01\x12\x04\xc9\x1a\x02\x19\x1a/\x20Human\x20r\
    eadable\x20description\x20for\x20the\x20collector.\n\n\x0e\n\x06\x04\x97\
    \x01\x02\x01\x05\x12\x04\xc9\x1a\x02\x08\n\x0e\n\x06\x04\x97\x01\x02\x01\
    \x01\x12\x04\xc9\x1a\t\x14\n\x0e\n\x06\x04\x97\x01\x02\x01\x03\x12\x04\
    \xc9\x1a\x17\x18\n\x84\x02\n\x05\x04\x97\x01\x02\x02\x12\x04\xd0\x1a\x02\
    +\x1a\xf4\x01\x20When\x20the\x20collector\x20is\x20created.\x20We\x20fol\
    low\x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\x20https://www\
    .ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15:04:05.999999Z\
    \"\x20so\x20you\x20can\x20expect\x20results\x20like\n\x20the\x20followin\
    g\x20from\x20the\x20API:\n\x20\"2017-04-11T21:50:50.223962Z\"\n\n\x0e\n\
    \x06\x04\x97\x01\x02\x02\x06\x12\x04\xd0\x1a\x02\x1b\n\x0e\n\x06\x04\x97\
    \x01\x02\x02\x01\x12\x04\xd0\x1a\x1c&\n\x0e\n\x06\x04\x97\x01\x02\x02\
    \x03\x12\x04\xd0\x1a)*\n\x9c\x06\n\x05\x04\x97\x01\x02\x03\x12\x04\xdc\
    \x1a\x02#\x1a\x8c\x06\x20This\x20is\x20a\x20workflow\x20to\x20run\x20inl\
    ine\x20in\x20model\x20predict\x20calls.\x20It\x20should\x20ONLY\x20have\
    \x20very\x20fast\x20and\n\x20light-weight\x20models\x20in\x20it\x20as\
    \x20it\x20will\x20effect\x20the\x20speed\x20of\x20the\x20predictions\x20\
    being\x20made.\n\x20This\x20workflow's\x20purpose\x20is\x20to\x20filter\
    \x20down\x20the\x20inputs\x20to\x20queue\x20for\x20the\x20collector\x20t\
    o\x20process.\n\x20The\x20input\x20to\x20this\x20workflow\x20is\x20going\
    \x20to\x20be\x20the\x20OUTPUT\x20of\x20the\x20model,\x20not\x20the\x20in\
    put\x20to\x20the\x20model\n\x20since\x20we\x20want\x20to\x20encourage\
    \x20having\x20fast\x20workflows\x20that\x20can\x20also\x20take\x20advant\
    age\x20of\x20the\x20model\n\x20outputs\x20to\x20make\x20deciions\x20(for\
    \x20example:\x20thresholding\x20based\x20on\x20concepts).\x20If\x20the\
    \x20workflow\n\x20output\x20has\x20any\x20field\x20that\x20is\x20non-emp\
    ty\x20then\x20the\x20input\x20will\x20be\x20queued\x20for\x20the\x20coll\
    ector\n\x20to\x20process\x20with\x20the\x20post_queue_workflow_id.\n\n\
    \x20As\x20a\x20simpler\x20alternative,\x20pre_queue_random_sample\x20can\
    \x20be\x20set\x20to\x20just\x20use\x20random\x20sampling\x20instead.\n\n\
    \x0e\n\x06\x04\x97\x01\x02\x03\x05\x12\x04\xdc\x1a\x02\x08\n\x0e\n\x06\
    \x04\x97\x01\x02\x03\x01\x12\x04\xdc\x1a\t\x1e\n\x0e\n\x06\x04\x97\x01\
    \x02\x03\x03\x12\x04\xdc\x1a!\"\n\xfe\x01\n\x05\x04\x97\x01\x02\x04\x12\
    \x04\xe1\x1a\x02$\x1a\xee\x01\x20Instead\x20of\x20needing\x20to\x20creat\
    e\x20a\x20new\x20workflow\x20for\x20pre_queue_workflow_id,\x20if\x20just\
    \x20random\x20sampling\n\x20of\x20the\x20model\x20inputs\x20is\x20requir\
    ed,\x20then\x20pre_queue_random_sample\x20can\x20be\x20set\x20to\x20a\
    \x20value\x20from\x20(0-1]\n\x20to\x20denote\x20the\x20fraction\x20of\
    \x20inputs\x20to\x20collect.\n\n\x0e\n\x06\x04\x97\x01\x02\x04\x05\x12\
    \x04\xe1\x1a\x02\x07\n\x0e\n\x06\x04\x97\x01\x02\x04\x01\x12\x04\xe1\x1a\
    \x08\x1f\n\x0e\n\x06\x04\x97\x01\x02\x04\x03\x12\x04\xe1\x1a\"#\n\x8c\
    \x03\n\x05\x04\x97\x01\x02\x05\x12\x04\xe8\x1a\x02$\x1a\xfc\x02\x20A\x20\
    workflow\x20to\x20run\x20to\x20after\x20the\x20collector\x20is\x20proces\
    sing\x20the\x20queued\x20input.\x20This\x20workflow\n\x20uses\x20the\x20\
    original\x20input\x20to\x20the\x20model\x20as\x20input\x20to\x20the\x20w\
    orkflow\x20so\x20that\x20you\x20can\x20run\x20additional\n\x20models\x20\
    as\x20well\x20on\x20that\x20input\x20to\x20decide\x20whether\x20to\x20qu\
    eue\x20the\x20model\x20or\x20not.\x20If\x20the\x20workflow\n\x20output\
    \x20has\x20any\x20field\x20that\x20is\x20non-empty\x20then\x20it\x20will\
    \x20be\x20passed\x20on\x20to\x20POST\x20/inputs\x20to\n\x20the\x20destin\
    ation\x20app.\n\n\x0e\n\x06\x04\x97\x01\x02\x05\x05\x12\x04\xe8\x1a\x02\
    \x08\n\x0e\n\x06\x04\x97\x01\x02\x05\x01\x12\x04\xe8\x1a\t\x1f\n\x0e\n\
    \x06\x04\x97\x01\x02\x05\x03\x12\x04\xe8\x1a\"#\n\xec\x02\n\x05\x04\x97\
    \x01\x02\x06\x12\x04\xef\x1a\x02'\x1a\xdc\x02\x20The\x20source\x20of\x20\
    the\x20collector\x20to\x20feed\x20data\x20into\x20this\x20app.\n\x20Note\
    (zeiler):\x20if\x20we\x20wanted\x20more\x20than\x20one\x20source\x20per\
    \x20collector\x20we\x20could\x20make\x20this\x20it's\x20own\n\x20object\
    \x20and\x20introduce\x20/collectors/{collector_id}/sources\n\x20We\x20wi\
    ll\x20keep\x20it\x20simple\x20for\x20now\x20and\x20have\x20just\x20one\
    \x20source\x20per\x20collector\x20since\x20a\x20user\x20can\x20make\n\
    \x20more\x20than\x20one\x20collector\x20in\x20the\x20same\x20app\x20anyw\
    ays.\n\n\x0e\n\x06\x04\x97\x01\x02\x06\x06\x12\x04\xef\x1a\x02\x11\n\x0e\
    \n\x06\x04\x97\x01\x02\x06\x01\x12\x04\xef\x1a\x12\"\n\x0e\n\x06\x04\x97\
    \x01\x02\x06\x03\x12\x04\xef\x1a%&\n\xd8\x03\n\x05\x04\x97\x01\x02\x07\
    \x12\x04\xf9\x1a\x02(\x1al\x20Status\x20for\x20the\x20collector.\x20This\
    \x20allows\x20you\x20to\x20pause\x20a\x20collector\x20without\x20having\
    \x20to\x20delete\x20it\x20as\n\x20an\x20example.\n2\xda\x02\x20This\x20i\
    s\x20the\x20workflow\x20ID\x20to\x20do\x20POST\x20/inputs\x20with\x20the\
    \x20collected\x20data\x20using.\n\x20This\x20needs\x20to\x20be\x20presen\
    t\x20at\x20all\x20times\x20in\x20this\x20app\x20for\x20the\x20collector\
    \x20to\x20work.\n\x20If\x20this\x20is\x20not\x20specified\x20then\x20it\
    \x20will\x20use\x20the\x20default_workflow_id\x20of\x20the\x20app.\n\x20\
    Note(zeiler):\x20not\x20yet\x20available,\x20uses\x20only\x20the\x20defa\
    ult\x20workflow\x20that\x20POST\x20/inputs\x20uses.\n\x20string\x20workf\
    low_id\x20=\x207;\n\n\x0e\n\x06\x04\x97\x01\x02\x07\x06\x12\x04\xf9\x1a\
    \x02\x1c\n\x0e\n\x06\x04\x97\x01\x02\x07\x01\x12\x04\xf9\x1a\x1d#\n\x0e\
    \n\x06\x04\x97\x01\x02\x07\x03\x12\x04\xf9\x1a&'\n\xc9\x01\n\x05\x04\x97\
    \x01\x02\x08\x12\x04\xfd\x1a\x02\x1b\x1a\xb9\x01\x20Whether\x20to\x20col\
    lect\x20outputs\x20or\x20not.\x20Default\x20is\x20false.\x20If\x20select\
    ed,\x20outputs\x20from\x20the\n\x20original\x20model\x20predict\x20call\
    \x20will\x20be\x20posted\x20as\x20annotations\x20along\x20with\x20the\
    \x20input\x20with\x20success\x20status.\n\n\x0e\n\x06\x04\x97\x01\x02\
    \x08\x05\x12\x04\xfd\x1a\x02\x06\n\x0e\n\x06\x04\x97\x01\x02\x08\x01\x12\
    \x04\xfd\x1a\x07\x16\n\x0e\n\x06\x04\x97\x01\x02\x08\x03\x12\x04\xfd\x1a\
    \x19\x1a\n\xdc\x01\n\x03\x04\x98\x01\x12\x06\x82\x1b\0\x89\x1b\x01\x1af\
    \x20Configuration\x20for\x20the\x20source\x20to\x20collect\x20data\x20fr\
    om.\n\x20Only\x20one\x20of\x20the\x20fields\x20can\x20be\x20present\x20a\
    t\x20a\x20time.\n\"e\x20The\x20ID\x20of\x20the\x20source\x20in\x20case\
    \x20we\x20want\x20to\x20implment\x20/collectors/{collector_id}/sources\n\
    \x20string\x20id\x20=\x201;\n\n\x0c\n\x04\x04\x98\x01\x01\x12\x04\x82\
    \x1b\x08\x17\n\xbc\x01\n\x05\x04\x98\x01\x02\0\x12\x04\x88\x1b\x02Q\x1a\
    \xac\x01\x20Collect\x20from\x20the\x20inputs\x20passed\x20in\x20for\x20P\
    ostModelOutputs\x20predictions\x20of\x20a\x20specific\x20model.\n\x20Thi\
    s\x20does\x20not\x20apply\x20to\x20models\x20used\x20within\x20workflows\
    ,\x20only\x20PostModelOutputs\x20calls.\n\n\x0e\n\x06\x04\x98\x01\x02\0\
    \x06\x12\x04\x88\x1b\x02$\n\x0e\n\x06\x04\x98\x01\x02\0\x01\x12\x04\x88\
    \x1b%L\n\x0e\n\x06\x04\x98\x01\x02\0\x03\x12\x04\x88\x1bOP\n|\n\x03\x04\
    \x99\x01\x12\x06\x8d\x1b\0\xab\x1b\x01\x1am\x20This\x20is\x20configurati\
    on\x20for\x20using\x20the\x20inputs\x20send\x20for\x20model\x20predictio\
    n\x20in\x20our\x20API\x20as\n\x20as\x20the\x20source\x20for\x20data.\n\n\
    \x0c\n\x04\x04\x99\x01\x01\x12\x04\x8d\x1b\x08*\n\xbc\x01\n\x05\x04\x99\
    \x01\x02\0\x12\x04\x91\x1b\x02\x1b\x1a\xac\x01\x20To\x20define\x20the\
    \x20model\x20that\x20we\x20should\x20collect\x20from\x20we\x20need\x20to\
    \x20specify\x20the\x20following\x204\x20IDs:\n\x20The\x20User\x20ID\x20o\
    f\x20the\x20model\x20we\x20want\x20to\x20collect\x20from.\n\x20This\x20i\
    s\x20User\x20B\x20in\x20the\x20example.\n\n\x0e\n\x06\x04\x99\x01\x02\0\
    \x05\x12\x04\x91\x1b\x02\x08\n\x0e\n\x06\x04\x99\x01\x02\0\x01\x12\x04\
    \x91\x1b\t\x16\n\x0e\n\x06\x04\x99\x01\x02\0\x03\x12\x04\x91\x1b\x19\x1a\
    \nA\n\x05\x04\x99\x01\x02\x01\x12\x04\x93\x1b\x02\x1a\x1a2\x20The\x20App\
    \x20ID\x20of\x20the\x20model\x20we\x20want\x20to\x20collect\x20from.\n\n\
    \x0e\n\x06\x04\x99\x01\x02\x01\x05\x12\x04\x93\x1b\x02\x08\n\x0e\n\x06\
    \x04\x99\x01\x02\x01\x01\x12\x04\x93\x1b\t\x15\n\x0e\n\x06\x04\x99\x01\
    \x02\x01\x03\x12\x04\x93\x1b\x18\x19\nC\n\x05\x04\x99\x01\x02\x02\x12\
    \x04\x95\x1b\x02\x16\x1a4\x20The\x20Model\x20ID\x20of\x20the\x20model\
    \x20we\x20want\x20to\x20collect\x20from.\n\n\x0e\n\x06\x04\x99\x01\x02\
    \x02\x05\x12\x04\x95\x1b\x02\x08\n\x0e\n\x06\x04\x99\x01\x02\x02\x01\x12\
    \x04\x95\x1b\t\x11\n\x0e\n\x06\x04\x99\x01\x02\x02\x03\x12\x04\x95\x1b\
    \x14\x15\nE\n\x05\x04\x99\x01\x02\x03\x12\x04\x97\x1b\x02\x1e\x1a6\x20Th\
    e\x20Version\x20ID\x20of\x20the\x20model\x20we\x20want\x20to\x20collect\
    \x20from.\n\n\x0e\n\x06\x04\x99\x01\x02\x03\x05\x12\x04\x97\x1b\x02\x08\
    \n\x0e\n\x06\x04\x99\x01\x02\x03\x01\x12\x04\x97\x1b\t\x19\n\x0e\n\x06\
    \x04\x99\x01\x02\x03\x03\x12\x04\x97\x1b\x1c\x1d\n\xdc\x01\n\x05\x04\x99\
    \x01\x02\x04\x12\x04\x9c\x1b\x02\x20\x1a\xcc\x01\x20This\x20key\x20is\
    \x20used\x20to\x20POST\x20/inputs\x20into\x20your\x20app\x20by\x20the\
    \x20collector.\x20It\x20can\x20be\x20an\x20API\x20key\x20or\x20a\n\x20PA\
    T.\x20This\x20needs\x20the\x20permissions\x20that\x20are\x20needed\x20fo\
    r\x20POST\x20/inputs\x20for\x20the\x20app_id\x20this\n\x20Collector\x20i\
    s\x20defined\x20in.\n\n\x0e\n\x06\x04\x99\x01\x02\x04\x05\x12\x04\x9c\
    \x1b\x02\x08\n\x0e\n\x06\x04\x99\x01\x02\x04\x01\x12\x04\x9c\x1b\t\x1b\n\
    \x0e\n\x06\x04\x99\x01\x02\x04\x03\x12\x04\x9c\x1b\x1e\x1f\n\x9e\x06\n\
    \x05\x04\x99\x01\x02\x05\x12\x04\xaa\x1b\x02\x1c\x1a\xaa\x01\x20This\x20\
    is\x20a\x20private\x20field\x20that\x20defaults\x20to\x20the\x20app\x20o\
    wner\x20for\x20public\x20users.\n\x20If\x20this\x20is\x20left\x20blank\
    \x20then\x20this\x20collector\x20will\x20collect\x20from\x20ALL\x20users\
    \x20calling\x20the\x20given\x20model.\n2\x88\x02\x20The\x20most\x20flexi\
    ble\x20scenario\x20is\x20User\x20C\x20creates\x20a\x20collector\x20and\
    \x20she\x20wants\x20to\x20ingest\x20User\x20A's\n\x20predictions\x20of\
    \x20User\x20B's\x20model\x20into\x20their\x20app\x20(User\x20C's\x20app)\
    ,\x20for\x20which\x20User\x20C\x20has\x20created\n\x20the\x20annotation\
    \x20workflow\x20using\x20a\x20combination\x20of\x20models,\x20perhaps\
    \x20from\x20User\x20D\x20even.\n2\xd6\x02\x20The\x20User\x20ID\x20of\x20\
    the\x20caller\x20of\x20the\x20model\x20we\x20want\x20to\x20collect\x20fr\
    om.\n\x20This\x20is\x20needed\x20because\x20the\x20below\x20Model's\x20i\
    ds\x20could\x20be\x20used\x20by\x20multiple\x20users\x20like\x20the\n\
    \x20clarifai/main\x20models\x20are\x20or\x20any\x20model\x20that\x20has\
    \x20been\x20shared\x20with\x20a\x20collaborator.\x20Therefore\x20we\n\
    \x20need\x20to\x20know\x20which\x20caller\x20of\x20the\x20model\x20to\
    \x20collect\x20inputs\x20from.\n\x20This\x20is\x20User\x20A\x20in\x20the\
    \x20example.\n\n\x0e\n\x06\x04\x99\x01\x02\x05\x05\x12\x04\xaa\x1b\x02\
    \x08\n\x0e\n\x06\x04\x99\x01\x02\x05\x01\x12\x04\xaa\x1b\t\x17\n\x0e\n\
    \x06\x04\x99\x01\x02\x05\x03\x12\x04\xaa\x1b\x1a\x1b\n\x1a\n\x03\x04\x9a\
    \x01\x12\x06\xae\x1b\0\xba\x1b\x01\x1a\x0b\x20StatValue\n\n\x0c\n\x04\
    \x04\x9a\x01\x01\x12\x04\xae\x1b\x08\x11\n:\n\x05\x04\x9a\x01\x02\0\x12\
    \x04\xb0\x1b\x02%\x1a+\x20The\x20time\x20of\x20the\x20event.\x20Defaults\
    \x20to\x20now().\n\n\x0e\n\x06\x04\x9a\x01\x02\0\x06\x12\x04\xb0\x1b\x02\
    \x1b\n\x0e\n\x06\x04\x9a\x01\x02\0\x01\x12\x04\xb0\x1b\x1c\x20\n\x0e\n\
    \x06\x04\x9a\x01\x02\0\x03\x12\x04\xb0\x1b#$\n9\n\x05\x04\x9a\x01\x02\
    \x01\x12\x04\xb3\x1b\x02\x12\x1a*\x20A\x20value\x20for\x20the\x20metric\
    \x20you're\x20recording.\n\n\x0e\n\x06\x04\x9a\x01\x02\x01\x05\x12\x04\
    \xb3\x1b\x02\x07\n\x0e\n\x06\x04\x9a\x01\x02\x01\x01\x12\x04\xb3\x1b\x08\
    \r\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\x12\x04\xb3\x1b\x10\x11\n\xd0\x02\
    \n\x05\x04\x9a\x01\x02\x02\x12\x04\xb9\x1b\x02\x1b\x1a\xc0\x02\x20List\
    \x20of\x20tags\x20to\x20attach\x20to\x20this\x20stat.\x20Each\x20should\
    \x20contain\x20one\x20colon\x20so\x20that\x20the\x20first\x20part\x20wil\
    l\n\x20be\x20used\x20as\x20a\x20tag\x20group\x20while\x20the\x20second\
    \x20being\x20the\x20tag\x20itself.\x20For\x20example:\x20[\"task_id:a\",\
    \n\x20\"worker_id:1\"].\x20These\x20tag\x20groups\x20like\x20\"task_id\"\
    \x20or\x20\"worker_id\"\x20are\x20important\x20for\x20aggregating\n\x20v\
    alues\x20in\x20the\x20StatValueAggregateQuery.\n\n\x0e\n\x06\x04\x9a\x01\
    \x02\x02\x04\x12\x04\xb9\x1b\x02\n\n\x0e\n\x06\x04\x9a\x01\x02\x02\x05\
    \x12\x04\xb9\x1b\x0b\x11\n\x0e\n\x06\x04\x9a\x01\x02\x02\x01\x12\x04\xb9\
    \x1b\x12\x16\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\x12\x04\xb9\x1b\x19\x1a\
    \n)\n\x03\x04\x9b\x01\x12\x06\xbd\x1b\0\xc3\x1b\x01\x1a\x1a\x20StatValue\
    AggregateResult\n\n\x0c\n\x04\x04\x9b\x01\x01\x12\x04\xbd\x1b\x08\x20\nH\
    \n\x05\x04\x9b\x01\x02\0\x12\x04\xbf\x1b\x028\x1a9\x20The\x20list\x20of\
    \x20repeated\x20aggregate\x20values\x20and\x20their\x20counts.\n\n\x0e\n\
    \x06\x04\x9b\x01\x02\0\x04\x12\x04\xbf\x1b\x02\n\n\x0e\n\x06\x04\x9b\x01\
    \x02\0\x06\x12\x04\xbf\x1b\x0b\x1d\n\x0e\n\x06\x04\x9b\x01\x02\0\x01\x12\
    \x04\xbf\x1b\x1e3\n\x0e\n\x06\x04\x9b\x01\x02\0\x03\x12\x04\xbf\x1b67\n6\
    \n\x05\x04\x9b\x01\x02\x01\x12\x04\xc2\x1b\x029\x1a'\x20The\x20query\x20\
    that\x20created\x20these\x20results.\n\n\x0e\n\x06\x04\x9b\x01\x02\x01\
    \x06\x12\x04\xc2\x1b\x02\x19\n\x0e\n\x06\x04\x9b\x01\x02\x01\x01\x12\x04\
    \xc2\x1b\x1a4\n\x0e\n\x06\x04\x9b\x01\x02\x01\x03\x12\x04\xc2\x1b78\n#\n\
    \x03\x04\x9c\x01\x12\x06\xc6\x1b\0\xd2\x1b\x01\x1a\x14\x20StatValueAggre\
    gate\n\n\x0c\n\x04\x04\x9c\x01\x01\x12\x04\xc6\x1b\x08\x1a\n\x88\x02\n\
    \x05\x04\x9c\x01\x02\0\x12\x04\xca\x1b\x02%\x1a\xf8\x01\x20The\x20time\
    \x20of\x20the\x20aggregation.\x20For\x20example,\x20if\x20you\x20aggrega\
    te\x20over\x20\"HOUR\"\x20buckets\x20then\x20you\x20can\n\x20expect\x20e\
    ach\x20hour\x20that\x20has\x20atleast\x20one\x20value\x20(matching\x20th\
    e\x20rest\x20of\x20your\x20query\x20fields)\x20will\x20have\n\x20a\x20St\
    atValueAggregate\x20with\x20the\x20time\x20filled\x20into\x20that\x20hou\
    r.\n\n\x0e\n\x06\x04\x9c\x01\x02\0\x06\x12\x04\xca\x1b\x02\x1b\n\x0e\n\
    \x06\x04\x9c\x01\x02\0\x01\x12\x04\xca\x1b\x1c\x20\n\x0e\n\x06\x04\x9c\
    \x01\x02\0\x03\x12\x04\xca\x1b#$\nJ\n\x05\x04\x9c\x01\x02\x01\x12\x04\
    \xcc\x1b\x02\x1c\x1a;\x20The\x20value\x20aggregated\x20according\x20to\
    \x20the\x20stat_value_agg_type\n\n\x0e\n\x06\x04\x9c\x01\x02\x01\x05\x12\
    \x04\xcc\x1b\x02\x07\n\x0e\n\x06\x04\x9c\x01\x02\x01\x01\x12\x04\xcc\x1b\
    \x08\x17\n\x0e\n\x06\x04\x9c\x01\x02\x01\x03\x12\x04\xcc\x1b\x1a\x1b\nQ\
    \n\x05\x04\x9c\x01\x02\x02\x12\x04\xce\x1b\x02\x13\x1aB\x20The\x20count\
    \x20of\x20the\x20stat\x20values\x20that\x20were\x20used\x20in\x20this\
    \x20aggregation.\n\n\x0e\n\x06\x04\x9c\x01\x02\x02\x05\x12\x04\xce\x1b\
    \x02\x08\n\x0e\n\x06\x04\x9c\x01\x02\x02\x01\x12\x04\xce\x1b\t\x0e\n\x0e\
    \n\x06\x04\x9c\x01\x02\x02\x03\x12\x04\xce\x1b\x11\x12\n\x93\x01\n\x05\
    \x04\x9c\x01\x02\x03\x12\x04\xd1\x1b\x02\x1b\x1a\x83\x01\x20The\x20tags\
    \x20for\x20this\x20aggregated_value\x20and\x20count.\x20This\x20will\x20\
    be\x20filled\x20in\x20if\x20tag\x20groups\x20were\x20used\x20in\n\x20the\
    \x20query\x20to\x20group\x20aggregations.\n\n\x0e\n\x06\x04\x9c\x01\x02\
    \x03\x04\x12\x04\xd1\x1b\x02\n\n\x0e\n\x06\x04\x9c\x01\x02\x03\x05\x12\
    \x04\xd1\x1b\x0b\x11\n\x0e\n\x06\x04\x9c\x01\x02\x03\x01\x12\x04\xd1\x1b\
    \x12\x16\n\x0e\n\x06\x04\x9c\x01\x02\x03\x03\x12\x04\xd1\x1b\x19\x1a\n(\
    \n\x03\x04\x9d\x01\x12\x06\xd5\x1b\0\xf7\x1b\x01\x1a\x19\x20StatValueAgg\
    regateQuery\n\n\x0c\n\x04\x04\x9d\x01\x01\x12\x04\xd5\x1b\x08\x1f\n\xbf\
    \x01\n\x05\x04\x9d\x01\x02\0\x12\x04\xd8\x1b\x02\x1b\x1a\xaf\x01\x20Thes\
    e\x20tags\x20are\x20used\x20to\x20filter\x20down\x20the\x20values\x20bef\
    ore\x20they\x20are\x20aggregated.\x20For\x20example,\n\x20if\x20you\x20w\
    ant\x20to\x20aggregate\x20values\x20for\x20\"task_id:a\"\x20you\x20could\
    \x20specify\x20that\x20as\x20a\x20tag\x20here.\n\n\x0e\n\x06\x04\x9d\x01\
    \x02\0\x04\x12\x04\xd8\x1b\x02\n\n\x0e\n\x06\x04\x9d\x01\x02\0\x05\x12\
    \x04\xd8\x1b\x0b\x11\n\x0e\n\x06\x04\x9d\x01\x02\0\x01\x12\x04\xd8\x1b\
    \x12\x16\n\x0e\n\x06\x04\x9d\x01\x02\0\x03\x12\x04\xd8\x1b\x19\x1a\n\xdc\
    \x04\n\x05\x04\x9d\x01\x02\x01\x12\x04\xe5\x1b\x02!\x1a\xcc\x04\x20These\
    \x20are\x20tag\x20groups\x20to\x20aggregate\x20over.\x20So\x20for\x20exa\
    mple\x20if\x20you\x20added\x20stat\x20values\x20with\x20tags\n\x20\"task\
    _id:a\"\x20and\x20others\x20with\x20\"task_id:b\",\x20then\x20added\x20[\
    \"task_id\"]\x20to\x20the\x20task\x20group,\x20it\x20the\n\x20aggregatio\
    n\x20would\x20return\x20StatValueAggregate\x20values\x20for\x20each\x20t\
    ask_id.\x20If\x20you\x20provide\x20more\x20than\n\x20one\x20tag_group\
    \x20the\x20response\x20will\x20return\x20all\x20rolled\x20up\x20combinat\
    ions\x20of\x20them.\x20For\x20example\n\x20[\"task_id\",\x20\"something\
    \"]\x20where\x20\"something:1\"\x20and\x20\"something:2\"\x20were\x20use\
    d\x20as\x20tags\x20for\x20some\n\x20values\x20then\x20you'd\x20get\x20St\
    atValueAggregate\x20values\x20back\x20for:\n\x20task_id\x20|\x20somethin\
    g\n\x20a\x20\x20\x20\x20\x20\x20\x20|\x201\n\x20a\x20\x20\x20\x20\x20\
    \x20\x20|\x202\n\x20b\x20\x20\x20\x20\x20\x20\x20|\x201\n\x20b\x20\x20\
    \x20\x20\x20\x20\x20|\x201\n\n\x0e\n\x06\x04\x9d\x01\x02\x01\x04\x12\x04\
    \xe5\x1b\x02\n\n\x0e\n\x06\x04\x9d\x01\x02\x01\x05\x12\x04\xe5\x1b\x0b\
    \x11\n\x0e\n\x06\x04\x9d\x01\x02\x01\x01\x12\x04\xe5\x1b\x12\x1c\n\x0e\n\
    \x06\x04\x9d\x01\x02\x01\x03\x12\x04\xe5\x1b\x1f\x20\n\x86\x01\n\x05\x04\
    \x9d\x01\x02\x02\x12\x04\xe9\x1b\x02+\x1aw\x20Aggregation\x20function\
    \x20to\x20use\x20over\x20the\x20values.\x20Count(value)\x20is\x20also\
    \x20always\x20returns.\n\x20Defaults\x20to\x20'sum'\x20if\x20not\x20prov\
    ided.\n\n\x0e\n\x06\x04\x9d\x01\x02\x02\x06\x12\x04\xe9\x1b\x02\x12\n\
    \x0e\n\x06\x04\x9d\x01\x02\x02\x01\x12\x04\xe9\x1b\x13&\n\x0e\n\x06\x04\
    \x9d\x01\x02\x02\x03\x12\x04\xe9\x1b)*\n\xf8\x01\n\x05\x04\x9d\x01\x02\
    \x03\x12\x04\xee\x1b\x02)\x1a\xe8\x01\x20Aggregation\x20bins\x20for\x20t\
    ime\x20where\x20the\x20values\x20will\x20be\x20aggregated\x20at\x20this\
    \x20bin\x20granualarity.\n\x20And\x20the\x20\"time\"\x20field\x20will\
    \x20be\x20returned\x20in\x20StatValueAggregate\x20object.\n\x20If\x20not\
    \x20provided\x20then\x20bins\x20are\x20not\x20used,\x20and\x20all\x20tim\
    e\x20is\x20aggregated\x20over.\n\n\x0e\n\x06\x04\x9d\x01\x02\x03\x06\x12\
    \x04\xee\x1b\x02\x11\n\x0e\n\x06\x04\x9d\x01\x02\x03\x01\x12\x04\xee\x1b\
    \x12$\n\x0e\n\x06\x04\x9d\x01\x02\x03\x03\x12\x04\xee\x1b'(\n\x99\x01\n\
    \x05\x04\x9d\x01\x02\x04\x12\x04\xf2\x1b\x02+\x1a\x89\x01\x20If\x20provi\
    ded\x20the\x20time\x20range\x20over\x20which\x20values\x20will\x20be\x20\
    >=\x20this\x20time.\x20If\x20not\x20provided\x20then\n\x20all\x20values\
    \x20will\x20be\x20used\x20back\x20to\x20start\x20of\x20time.\n\n\x0e\n\
    \x06\x04\x9d\x01\x02\x04\x06\x12\x04\xf2\x1b\x02\x1b\n\x0e\n\x06\x04\x9d\
    \x01\x02\x04\x01\x12\x04\xf2\x1b\x1c&\n\x0e\n\x06\x04\x9d\x01\x02\x04\
    \x03\x12\x04\xf2\x1b)*\n\x92\x01\n\x05\x04\x9d\x01\x02\x05\x12\x04\xf6\
    \x1b\x02)\x1a\x82\x01\x20If\x20provided\x20the\x20time\x20range\x20over\
    \x20which\x20values\x20will\x20be\x20<=\x20this\x20time.\x20If\x20not\
    \x20provided\x20then\x20all\n\x20values\x20will\x20be\x20used\x20up\x20u\
    ntil\x20now().\n\n\x0e\n\x06\x04\x9d\x01\x02\x05\x06\x12\x04\xf6\x1b\x02\
    \x1b\n\x0e\n\x06\x04\x9d\x01\x02\x05\x01\x12\x04\xf6\x1b\x1c$\n\x0e\n\
    \x06\x04\x9d\x01\x02\x05\x03\x12\x04\xf6\x1b'(\n\x0c\n\x02\x05\r\x12\x06\
    \xf8\x1b\0\xfb\x1b\x01\n\x0b\n\x03\x05\r\x01\x12\x04\xf8\x1b\x05\x15\n\
    \x0c\n\x04\x05\r\x02\0\x12\x04\xf9\x1b\x02\n\n\r\n\x05\x05\r\x02\0\x01\
    \x12\x04\xf9\x1b\x02\x05\n\r\n\x05\x05\r\x02\0\x02\x12\x04\xf9\x1b\x08\t\
    \n\x0c\n\x04\x05\r\x02\x01\x12\x04\xfa\x1b\x02\n\n\r\n\x05\x05\r\x02\x01\
    \x01\x12\x04\xfa\x1b\x02\x05\n\r\n\x05\x05\r\x02\x01\x02\x12\x04\xfa\x1b\
    \x08\t\n\x0c\n\x02\x05\x0e\x12\x06\xfd\x1b\0\x85\x1c\x01\n\x0b\n\x03\x05\
    \x0e\x01\x12\x04\xfd\x1b\x05\x14\n\x0c\n\x04\x05\x0e\x02\0\x12\x04\xfe\
    \x1b\x02\x12\n\r\n\x05\x05\x0e\x02\0\x01\x12\x04\xfe\x1b\x02\r\n\r\n\x05\
    \x05\x0e\x02\0\x02\x12\x04\xfe\x1b\x10\x11\n\x0c\n\x04\x05\x0e\x02\x01\
    \x12\x04\xff\x1b\x02\x0b\n\r\n\x05\x05\x0e\x02\x01\x01\x12\x04\xff\x1b\
    \x02\x06\n\r\n\x05\x05\x0e\x02\x01\x02\x12\x04\xff\x1b\t\n\n\x0c\n\x04\
    \x05\x0e\x02\x02\x12\x04\x80\x1c\x02\x0c\n\r\n\x05\x05\x0e\x02\x02\x01\
    \x12\x04\x80\x1c\x02\x07\n\r\n\x05\x05\x0e\x02\x02\x02\x12\x04\x80\x1c\n\
    \x0b\n\x0c\n\x04\x05\x0e\x02\x03\x12\x04\x81\x1c\x02\x0b\n\r\n\x05\x05\
    \x0e\x02\x03\x01\x12\x04\x81\x1c\x02\x06\n\r\n\x05\x05\x0e\x02\x03\x02\
    \x12\x04\x81\x1c\t\n\n\x0c\n\x04\x05\x0e\x02\x04\x12\x04\x82\x1c\x02\n\n\
    \r\n\x05\x05\x0e\x02\x04\x01\x12\x04\x82\x1c\x02\x05\n\r\n\x05\x05\x0e\
    \x02\x04\x02\x12\x04\x82\x1c\x08\t\n\x0c\n\x04\x05\x0e\x02\x05\x12\x04\
    \x83\x1c\x02\x0b\n\r\n\x05\x05\x0e\x02\x05\x01\x12\x04\x83\x1c\x02\x06\n\
    \r\n\x05\x05\x0e\x02\x05\x02\x12\x04\x83\x1c\t\n\n\x0c\n\x04\x05\x0e\x02\
    \x06\x12\x04\x84\x1c\x02\r\n\r\n\x05\x05\x0e\x02\x06\x01\x12\x04\x84\x1c\
    \x02\x08\n\r\n\x05\x05\x0e\x02\x06\x02\x12\x04\x84\x1c\x0b\x0c\n(\n\x03\
    \x04\x9e\x01\x12\x06\x94\x1c\0\x99\x1c\x01\x1a\x19\x20PCAProjectionCompa\
    rator\n\n\x0c\n\x04\x04\x9e\x01\x01\x12\x04\x94\x1c\x08\x1f\nO\n\x05\x04\
    \x9e\x01\x02\0\x12\x04\x96\x1c\x02\x1f\x1a@\x20Within\x20what\x20distanc\
    e\x20do\x20we\x20consider\x20two\x20annotations\x20duplicates\n\n\x0e\n\
    \x06\x04\x9e\x01\x02\0\x05\x12\x04\x96\x1c\x02\x07\n\x0e\n\x06\x04\x9e\
    \x01\x02\0\x01\x12\x04\x96\x1c\x08\x1a\n\x0e\n\x06\x04\x9e\x01\x02\0\x03\
    \x12\x04\x96\x1c\x1d\x1e\n;\n\x05\x04\x9e\x01\x02\x01\x12\x04\x98\x1c\
    \x02\x1e\x1a,\x20What\x20cluster\x20model\x20version\x20generated\x20the\
    se\n\n\x0e\n\x06\x04\x9e\x01\x02\x01\x05\x12\x04\x98\x1c\x02\x08\n\x0e\n\
    \x06\x04\x9e\x01\x02\x01\x01\x12\x04\x98\x1c\t\x19\n\x0e\n\x06\x04\x9e\
    \x01\x02\x01\x03\x12\x04\x98\x1c\x1c\x1d\n,\n\x03\x04\x9f\x01\x12\x06\
    \x9c\x1c\0\x9f\x1c\x01\x1a\x1d\x20DuplicateAnnotationsResults\n\n\x0c\n\
    \x04\x04\x9f\x01\x01\x12\x04\x9c\x1c\x08#\n\r\n\x05\x04\x9f\x01\x02\0\
    \x12\x04\x9d\x1c\x02%\n\x0e\n\x06\x04\x9f\x01\x02\0\x04\x12\x04\x9d\x1c\
    \x02\n\n\x0e\n\x06\x04\x9f\x01\x02\0\x05\x12\x04\x9d\x1c\x0b\x11\n\x0e\n\
    \x06\x04\x9f\x01\x02\0\x01\x12\x04\x9d\x1c\x12\x20\n\x0e\n\x06\x04\x9f\
    \x01\x02\0\x03\x12\x04\x9d\x1c#$\n\r\n\x05\x04\x9f\x01\x02\x01\x12\x04\
    \x9e\x1c\x02\x19\n\x0e\n\x06\x04\x9f\x01\x02\x01\x05\x12\x04\x9e\x1c\x02\
    \x07\n\x0e\n\x06\x04\x9f\x01\x02\x01\x01\x12\x04\x9e\x1c\x08\x14\n\x0e\n\
    \x06\x04\x9f\x01\x02\x01\x03\x12\x04\x9e\x1c\x17\x18\n\x87\x04\n\x03\x04\
    \xa0\x01\x12\x06\xa8\x1c\0\xb7\x1c\x01\x1a\xf7\x03\x20Visibility\x20repr\
    esents\x20how\x20visible\x20the\x20given\x20resource\x20is\x20to\x20othe\
    r\x20users.\n\x20When\x20authenticating\x20a\x20request\x20we\x20can\x20\
    tell\x20if\x20a\x20user\x20is\x20a\x20collaborator\x20or\x20a\x20teammat\
    e\x20for\x20the\n\x20the\x20app\x20that\x20contains\x20the\x20resource\
    \x20and\x20set\x20their\x20allowed\x20visibility.\x20We\x20use\x20that\
    \x20to\x20restrict\n\x20what\x20they\x20are\x20allowed\x20to\x20see:\n\
    \x20If\x20AllowedVisibility\x20is\x20PRIVATE\x20then\x20we\x20allow\x20P\
    RIVATE\x20(10),\x20ORG\x20(30),\x20PUBLIC\x20(50)\n\x20If\x20AllowedVisi\
    bility\x20is\x20ORG\x20then\x20we\x20allow\x20ORG\x20(30),\x20PUBLIC\x20\
    (50)\n\x20If\x20AllowedVisibility\x20is\x20PUBLIC\x20then\x20we\x20allow\
    \x20PUBLIC\x20(50)\x20only.\n\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\xa8\
    \x1c\x08\x12\n]\n\x05\x04\xa0\x01\x04\0\x12\x06\xaa\x1c\x02\xb5\x1c\x03\
    \x1aL\x20Gettable\x20defined\x20the\x20level\x20of\x20access\x20for\x20G\
    ET\x20operations\x20for\x20this\x20resource.\n\n\x0e\n\x06\x04\xa0\x01\
    \x04\0\x01\x12\x04\xaa\x1c\x07\x0f\n-\n\x07\x04\xa0\x01\x04\0\x02\0\x12\
    \x04\xac\x1c\x04\x1b\x1a\x1c\x20Default\x20value\x20not\x20allowed.\n\n\
    \x10\n\x08\x04\xa0\x01\x04\0\x02\0\x01\x12\x04\xac\x1c\x04\x16\n\x10\n\
    \x08\x04\xa0\x01\x04\0\x02\0\x02\x12\x04\xac\x1c\x19\x1a\nc\n\x07\x04\
    \xa0\x01\x04\0\x02\x01\x12\x04\xae\x1c\x04\x11\x1aR\x20PRIVATE\x20requir\
    es\x20collaborator\x20or\x20team\x20permissions\x20in\x20order\x20to\x20\
    GET\x20this\x20resource.\n\n\x10\n\x08\x04\xa0\x01\x04\0\x02\x01\x01\x12\
    \x04\xae\x1c\x04\x0b\n\x10\n\x08\x04\xa0\x01\x04\0\x02\x01\x02\x12\x04\
    \xae\x1c\x0e\x10\n\x8a\x01\n\x07\x04\xa0\x01\x04\0\x02\x02\x12\x04\xb1\
    \x1c\x04\r\x1ay\x20ORG\x20requires\x20you\x20to\x20be\x20in\x20the\x20sa\
    me\x20org\x20in\x20order\x20to\x20GET\x20this\x20resource,\x20but\x20don\
    't\x20have\x20to\x20be\x20a\n\x20teammate\x20or\x20collaborator.\n\n\x10\
    \n\x08\x04\xa0\x01\x04\0\x02\x02\x01\x12\x04\xb1\x1c\x04\x07\n\x10\n\x08\
    \x04\xa0\x01\x04\0\x02\x02\x02\x12\x04\xb1\x1c\n\x0c\n\x8b\x01\n\x07\x04\
    \xa0\x01\x04\0\x02\x03\x12\x04\xb4\x1c\x04\x10\x1az\x20PUBLIC\x20opens\
    \x20up\x20GET\x20access\x20to\x20the\x20resource\x20to\x20any\x20user\
    \x20on\x20the\x20platform\x20even\x20if\x20they\x20are\x20not\n\x20a\x20\
    teammate\x20or\x20collaborator.\n\n\x10\n\x08\x04\xa0\x01\x04\0\x02\x03\
    \x01\x12\x04\xb4\x1c\x04\n\n\x10\n\x08\x04\xa0\x01\x04\0\x02\x03\x02\x12\
    \x04\xb4\x1c\r\x0f\n\r\n\x05\x04\xa0\x01\x02\0\x12\x04\xb6\x1c\x02\x18\n\
    \x0e\n\x06\x04\xa0\x01\x02\0\x06\x12\x04\xb6\x1c\x02\n\n\x0e\n\x06\x04\
    \xa0\x01\x02\0\x01\x12\x04\xb6\x1c\x0b\x13\n\x0e\n\x06\x04\xa0\x01\x02\0\
    \x03\x12\x04\xb6\x1c\x16\x17\n\x1f\n\x03\x04\xa1\x01\x12\x06\xba\x1c\0\
    \xbf\x1c\x01\x1a\x10\x20TrendingMetric\n\n\x0c\n\x04\x04\xa1\x01\x01\x12\
    \x04\xba\x1c\x08\x16\n\r\n\x05\x04\xa1\x01\x02\0\x12\x04\xbb\x1c\x02\x15\
    \n\x0e\n\x06\x04\xa1\x01\x02\0\x05\x12\x04\xbb\x1c\x02\x08\n\x0e\n\x06\
    \x04\xa1\x01\x02\0\x01\x12\x04\xbb\x1c\t\x10\n\x0e\n\x06\x04\xa1\x01\x02\
    \0\x03\x12\x04\xbb\x1c\x13\x14\n\r\n\x05\x04\xa1\x01\x02\x01\x12\x04\xbc\
    \x1c\x02\x14\n\x0e\n\x06\x04\xa1\x01\x02\x01\x05\x12\x04\xbc\x1c\x02\x08\
    \n\x0e\n\x06\x04\xa1\x01\x02\x01\x01\x12\x04\xbc\x1c\t\x0f\n\x0e\n\x06\
    \x04\xa1\x01\x02\x01\x03\x12\x04\xbc\x1c\x12\x13\n\r\n\x05\x04\xa1\x01\
    \x02\x02\x12\x04\xbd\x1c\x02\x17\n\x0e\n\x06\x04\xa1\x01\x02\x02\x05\x12\
    \x04\xbd\x1c\x02\x08\n\x0e\n\x06\x04\xa1\x01\x02\x02\x01\x12\x04\xbd\x1c\
    \t\x12\n\x0e\n\x06\x04\xa1\x01\x02\x02\x03\x12\x04\xbd\x1c\x15\x16\n\r\n\
    \x05\x04\xa1\x01\x02\x03\x12\x04\xbe\x1c\x02\x18\n\x0e\n\x06\x04\xa1\x01\
    \x02\x03\x05\x12\x04\xbe\x1c\x02\x08\n\x0e\n\x06\x04\xa1\x01\x02\x03\x01\
    \x12\x04\xbe\x1c\t\x13\n\x0e\n\x06\x04\xa1\x01\x02\x03\x03\x12\x04\xbe\
    \x1c\x16\x17\n\x0c\n\x02\x05\x0f\x12\x06\xc1\x1c\0\xc7\x1c\x01\n\x0b\n\
    \x03\x05\x0f\x01\x12\x04\xc1\x1c\x05\x18\n\x0c\n\x04\x05\x0f\x02\0\x12\
    \x04\xc2\x1c\x02$\n\r\n\x05\x05\x0f\x02\0\x01\x12\x04\xc2\x1c\x02\x1f\n\
    \r\n\x05\x05\x0f\x02\0\x02\x12\x04\xc2\x1c\"#\n\x0c\n\x04\x05\x0f\x02\
    \x01\x12\x04\xc4\x1c\x02\x11\n\r\n\x05\x05\x0f\x02\x01\x01\x12\x04\xc4\
    \x1c\x02\x0c\n\r\n\x05\x05\x0f\x02\x01\x02\x12\x04\xc4\x1c\x0f\x10\n\x0c\
    \n\x04\x05\x0f\x02\x02\x12\x04\xc5\x1c\x02\x0f\n\r\n\x05\x05\x0f\x02\x02\
    \x01\x12\x04\xc5\x1c\x02\n\n\r\n\x05\x05\x0f\x02\x02\x02\x12\x04\xc5\x1c\
    \r\x0e\n\x0c\n\x04\x05\x0f\x02\x03\x12\x04\xc6\x1c\x02\r\n\r\n\x05\x05\
    \x0f\x02\x03\x01\x12\x04\xc6\x1c\x02\x08\n\r\n\x05\x05\x0f\x02\x03\x02\
    \x12\x04\xc6\x1c\x0b\x0c\n\r\n\x03\x04\xa2\x01\x12\x06\xcd\x1c\0\xd2\x1c\
    \x01\n\x0c\n\x04\x04\xa2\x01\x01\x12\x04\xcd\x1c\x08\x0f\n7\n\x05\x04\
    \xa2\x01\x02\0\x12\x04\xcf\x1c\x02\x12\x1a(\x20Display\x20name\x20of\x20\
    the\x20tag.\x20Ex.\x20\"English\"\n\n\x0e\n\x06\x04\xa2\x01\x02\0\x05\
    \x12\x04\xcf\x1c\x02\x08\n\x0e\n\x06\x04\xa2\x01\x02\0\x01\x12\x04\xcf\
    \x1c\t\r\n\x0e\n\x06\x04\xa2\x01\x02\0\x03\x12\x04\xcf\x1c\x10\x11\n3\n\
    \x05\x04\xa2\x01\x02\x01\x12\x04\xd1\x1c\x02\x10\x1a$\x20Id\x20value\x20\
    for\x20referencing.\x20Ex.\x20\"en\"\n\n\x0e\n\x06\x04\xa2\x01\x02\x01\
    \x05\x12\x04\xd1\x1c\x02\x08\n\x0e\n\x06\x04\xa2\x01\x02\x01\x01\x12\x04\
    \xd1\x1c\t\x0b\n\x0e\n\x06\x04\xa2\x01\x02\x01\x03\x12\x04\xd1\x1c\x0e\
    \x0f\n\x1c\n\x03\x04\xa3\x01\x12\x06\xd5\x1c\0\xdc\x1c\x01\x1a\r\x20Time\
    Segment\n\n\x0c\n\x04\x04\xa3\x01\x01\x12\x04\xd5\x1c\x08\x13\n2\n\x05\
    \x04\xa3\x01\x02\0\x12\x04\xd7\x1c\x02\x10\x1a#\x20A\x20unique\x20id\x20\
    for\x20the\x20time\x20segment.\n\n\x0e\n\x06\x04\xa3\x01\x02\0\x05\x12\
    \x04\xd7\x1c\x02\x08\n\x0e\n\x06\x04\xa3\x01\x02\0\x01\x12\x04\xd7\x1c\t\
    \x0b\n\x0e\n\x06\x04\xa3\x01\x02\0\x03\x12\x04\xd7\x1c\x0e\x0f\n\r\n\x05\
    \x04\xa3\x01\x02\x01\x12\x04\xd9\x1c\x02\x10\n\x0e\n\x06\x04\xa3\x01\x02\
    \x01\x06\x12\x04\xd9\x1c\x02\x06\n\x0e\n\x06\x04\xa3\x01\x02\x01\x01\x12\
    \x04\xd9\x1c\x07\x0b\n\x0e\n\x06\x04\xa3\x01\x02\x01\x03\x12\x04\xd9\x1c\
    \x0e\x0f\n\r\n\x05\x04\xa3\x01\x02\x02\x12\x04\xdb\x1c\x02\x19\n\x0e\n\
    \x06\x04\xa3\x01\x02\x02\x06\x12\x04\xdb\x1c\x02\n\n\x0e\n\x06\x04\xa3\
    \x01\x02\x02\x01\x12\x04\xdb\x1c\x0b\x14\n\x0e\n\x06\x04\xa3\x01\x02\x02\
    \x03\x12\x04\xdb\x1c\x17\x18\n\x19\n\x03\x04\xa4\x01\x12\x06\xdf\x1c\0\
    \xe7\x1c\x01\x1a\n\x20TimeInfo\n\n\x0c\n\x04\x04\xa4\x01\x01\x12\x04\xdf\
    \x1c\x08\x10\n\x0c\n\x04\x04\xa4\x01\t\x12\x04\xe0\x1c\x02\x0f\n\r\n\x05\
    \x04\xa4\x01\t\0\x12\x04\xe0\x1c\x0b\x0c\n\x0e\n\x06\x04\xa4\x01\t\0\x01\
    \x12\x04\xe0\x1c\x0b\x0c\n\x0e\n\x06\x04\xa4\x01\t\0\x02\x12\x04\xe0\x1c\
    \x0b\x0c\n\r\n\x05\x04\xa4\x01\t\x01\x12\x04\xe0\x1c\r\x0e\n\x0e\n\x06\
    \x04\xa4\x01\t\x01\x01\x12\x04\xe0\x1c\r\x0e\n\x0e\n\x06\x04\xa4\x01\t\
    \x01\x02\x12\x04\xe0\x1c\r\x0e\n!\n\x05\x04\xa4\x01\x02\0\x12\x04\xe2\
    \x1c\x02\x18\x1a\x12\x20Number\x20of\x20frames\n\n\x0e\n\x06\x04\xa4\x01\
    \x02\0\x05\x12\x04\xe2\x1c\x02\x08\n\x0e\n\x06\x04\xa4\x01\x02\0\x01\x12\
    \x04\xe2\x1c\t\x13\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\x12\x04\xe2\x1c\x16\
    \x17\n.\n\x05\x04\xa4\x01\x02\x01\x12\x04\xe4\x1c\x02\x17\x1a\x1f\x20Tim\
    estamp\x20where\x20track\x20begins.\n\n\x0e\n\x06\x04\xa4\x01\x02\x01\
    \x05\x12\x04\xe4\x1c\x02\x07\n\x0e\n\x06\x04\xa4\x01\x02\x01\x01\x12\x04\
    \xe4\x1c\x08\x12\n\x0e\n\x06\x04\xa4\x01\x02\x01\x03\x12\x04\xe4\x1c\x15\
    \x16\n,\n\x05\x04\xa4\x01\x02\x02\x12\x04\xe6\x1c\x02\x15\x1a\x1d\x20Tim\
    estamp\x20where\x20track\x20ends.\n\n\x0e\n\x06\x04\xa4\x01\x02\x02\x05\
    \x12\x04\xe6\x1c\x02\x07\n\x0e\n\x06\x04\xa4\x01\x02\x02\x01\x12\x04\xe6\
    \x1c\x08\x10\n\x0e\n\x06\x04\xa4\x01\x02\x02\x03\x12\x04\xe6\x1c\x13\x14\
    \n\x1a\n\x03\x04\xa5\x01\x12\x04\xee\x1c\0.\x1a\r\x20DatasetStar\n\n\x0c\
    \n\x04\x04\xa5\x01\x01\x12\x04\xee\x1c\x08\x13\n\r\n\x05\x04\xa5\x01\x02\
    \0\x12\x04\xee\x1c\x16,\n\x0e\n\x06\x04\xa5\x01\x02\0\x05\x12\x04\xee\
    \x1c\x16\x1c\n\x0e\n\x06\x04\xa5\x01\x02\0\x01\x12\x04\xee\x1c\x1d'\n\
    \x0e\n\x06\x04\xa5\x01\x02\0\x03\x12\x04\xee\x1c*+\n\x1b\n\x03\x04\xa6\
    \x01\x12\x06\xf1\x1c\0\xf4\x1c\x01\x1a\x0c\x20ModuleStar\n\n\x0c\n\x04\
    \x04\xa6\x01\x01\x12\x04\xf1\x1c\x08\x12\n&\n\x05\x04\xa6\x01\x02\0\x12\
    \x04\xf3\x1c\x02\x17\x1a\x17\x20Module\x20id\x20of\x20the\x20star\n\n\
    \x0e\n\x06\x04\xa6\x01\x02\0\x05\x12\x04\xf3\x1c\x02\x08\n\x0e\n\x06\x04\
    \xa6\x01\x02\0\x01\x12\x04\xf3\x1c\t\x12\n\x0e\n\x06\x04\xa6\x01\x02\0\
    \x03\x12\x04\xf3\x1c\x15\x16\nQ\n\x03\x04\xa7\x01\x12\x06\xf9\x1c\0\xa5\
    \x1d\x01\x1aB\x20An\x20app\x20module\x20that\x20a\x20user\x20created\x20\
    in\x20our\x20app\x20module\x20marketplace.\n\n\x0c\n\x04\x04\xa7\x01\x01\
    \x12\x04\xf9\x1c\x08\x0e\n\x0c\n\x04\x04\xa7\x01\t\x12\x04\xfa\x1c\x02\r\
    \n\r\n\x05\x04\xa7\x01\t\0\x12\x04\xfa\x1c\x0b\x0c\n\x0e\n\x06\x04\xa7\
    \x01\t\0\x01\x12\x04\xfa\x1c\x0b\x0c\n\x0e\n\x06\x04\xa7\x01\t\0\x02\x12\
    \x04\xfa\x1c\x0b\x0c\n1\n\x05\x04\xa7\x01\x02\0\x12\x04\xfc\x1c\x02\x10\
    \x1a\"\x20A\x20unique\x20ID\x20for\x20this\x20app\x20module.\n\n\x0e\n\
    \x06\x04\xa7\x01\x02\0\x05\x12\x04\xfc\x1c\x02\x08\n\x0e\n\x06\x04\xa7\
    \x01\x02\0\x01\x12\x04\xfc\x1c\t\x0b\n\x0e\n\x06\x04\xa7\x01\x02\0\x03\
    \x12\x04\xfc\x1c\x0e\x0f\nX\n\x05\x04\xa7\x01\x02\x01\x12\x04\xfe\x1c\
    \x02\x19\x1aI\x20A\x20short\x20description\x20for\x20this\x20app\x20modu\
    le\x20to\x20be\x20used\x20in\x20grids\x20of\x20modules.\n\n\x0e\n\x06\
    \x04\xa7\x01\x02\x01\x05\x12\x04\xfe\x1c\x02\x08\n\x0e\n\x06\x04\xa7\x01\
    \x02\x01\x01\x12\x04\xfe\x1c\t\x14\n\x0e\n\x06\x04\xa7\x01\x02\x01\x03\
    \x12\x04\xfe\x1c\x17\x18\n1\n\x05\x04\xa7\x01\x02\x02\x12\x04\x80\x1d\
    \x02+\x1a\"\x20When\x20the\x20app\x20module\x20was\x20created.\n\n\x0e\n\
    \x06\x04\xa7\x01\x02\x02\x06\x12\x04\x80\x1d\x02\x1b\n\x0e\n\x06\x04\xa7\
    \x01\x02\x02\x01\x12\x04\x80\x1d\x1c&\n\x0e\n\x06\x04\xa7\x01\x02\x02\
    \x03\x12\x04\x80\x1d)*\n7\n\x05\x04\xa7\x01\x02\x03\x12\x04\x82\x1d\x02,\
    \x1a(\x20When\x20the\x20app\x20module\x20was\x20last\x20modified.\n\n\
    \x0e\n\x06\x04\xa7\x01\x02\x03\x06\x12\x04\x82\x1d\x02\x1b\n\x0e\n\x06\
    \x04\xa7\x01\x02\x03\x01\x12\x04\x82\x1d\x1c'\n\x0e\n\x06\x04\xa7\x01\
    \x02\x03\x03\x12\x04\x82\x1d*+\n\x84\x02\n\x05\x04\xa7\x01\x02\x04\x12\
    \x04\x88\x1d\x02\x1c\x1a\xf4\x01\x20The\x20visibility\x20field\x20repres\
    ents\x20whether\x20this\x20message\x20is\x20privately/publicly\x20visibl\
    e.\n\x20To\x20be\x20visible\x20to\x20the\x20public\x20the\x20App\x20that\
    \x20contains\x20it\x20AND\x20the\x20User\x20that\x20contains\x20the\x20A\
    pp\x20must\n\x20also\x20be\x20publicly\x20visible.\n\x20Defaults\x20to\
    \x20PRIVATE\x20if\x20not\x20provided.\n\n\x0e\n\x06\x04\xa7\x01\x02\x04\
    \x06\x12\x04\x88\x1d\x02\x0c\n\x0e\n\x06\x04\xa7\x01\x02\x04\x01\x12\x04\
    \x88\x1d\r\x17\n\x0e\n\x06\x04\xa7\x01\x02\x04\x03\x12\x04\x88\x1d\x1a\
    \x1b\n\xba\x01\n\x05\x04\xa7\x01\x02\x05\x12\x04\x8d\x1d\x02&\x1a\xaa\
    \x01\x20To\x20handle\x20arbitrary\x20json\x20metadata\x20you\x20can\x20u\
    se\x20a\x20struct\x20field:\n\x20https://github.com/google/protobuf/blob\
    /master/src/google/protobuf/struct.proto\n\x20This\x20is\x20an\x20option\
    al\x20arg.\n\n\x0e\n\x06\x04\xa7\x01\x02\x05\x06\x12\x04\x8d\x1d\x02\x18\
    \n\x0e\n\x06\x04\xa7\x01\x02\x05\x01\x12\x04\x8d\x1d\x19!\n\x0e\n\x06\
    \x04\xa7\x01\x02\x05\x03\x12\x04\x8d\x1d$%\n/\n\x05\x04\xa7\x01\x02\x06\
    \x12\x04\x90\x1d\x02\x15\x1a\x20\x20The\x20creator\x20of\x20the\x20app\
    \x20module.\n\n\x0e\n\x06\x04\xa7\x01\x02\x06\x05\x12\x04\x90\x1d\x02\
    \x08\n\x0e\n\x06\x04\xa7\x01\x02\x06\x01\x12\x04\x90\x1d\t\x10\n\x0e\n\
    \x06\x04\xa7\x01\x02\x06\x03\x12\x04\x90\x1d\x13\x14\n7\n\x05\x04\xa7\
    \x01\x02\x07\x12\x04\x93\x1d\x02\x15\x1a(\x20The\x20app_id\x20this\x20mo\
    dule\x20was\x20created\x20in.\n\n\x0e\n\x06\x04\xa7\x01\x02\x07\x05\x12\
    \x04\x93\x1d\x02\x08\n\x0e\n\x06\x04\xa7\x01\x02\x07\x01\x12\x04\x93\x1d\
    \t\x0f\n\x0e\n\x06\x04\xa7\x01\x02\x07\x03\x12\x04\x93\x1d\x12\x14\nz\n\
    \x05\x04\xa7\x01\x02\x08\x12\x04\x97\x1d\x02$\x1ak\x20A\x20ModuleVersion\
    \x20which\x20is\x20used\x20when\x20listing\x20modules\x20to\x20include\
    \x20the\x20latest\x20module\x20version\n\x20in\x20the\x20response.\n\n\
    \x0e\n\x06\x04\xa7\x01\x02\x08\x06\x12\x04\x97\x1d\x02\x0f\n\x0e\n\x06\
    \x04\xa7\x01\x02\x08\x01\x12\x04\x97\x1d\x10\x1e\n\x0e\n\x06\x04\xa7\x01\
    \x02\x08\x03\x12\x04\x97\x1d!#\n\xa6\x01\n\x05\x04\xa7\x01\x02\t\x12\x04\
    \x9b\x1d\x02\x17\x1a\x96\x01\x20Is\x20starred\x20by\x20the\x20requesting\
    \x20user\x20(only\x20showed\x20on\x20get/list\x20requests)\n\x20Please\
    \x20use\x20PostModuleStars/DeleteModuleStars\x20endpoints\x20to\x20star/\
    unstar\x20a\x20module\n\n\x0e\n\x06\x04\xa7\x01\x02\t\x05\x12\x04\x9b\
    \x1d\x02\x06\n\x0e\n\x06\x04\xa7\x01\x02\t\x01\x12\x04\x9b\x1d\x07\x11\n\
    \x0e\n\x06\x04\xa7\x01\x02\t\x03\x12\x04\x9b\x1d\x14\x16\nx\n\x05\x04\
    \xa7\x01\x02\n\x12\x04\x9e\x1d\x02\x18\x1ai\x20How\x20many\x20users\x20h\
    ave\x20starred\x20the\x20module\x20(only\x20showed\x20on\x20get/list\x20\
    requests)\n\x20Computed\x20value,\x20not\x20editable\n\n\x0e\n\x06\x04\
    \xa7\x01\x02\n\x05\x12\x04\x9e\x1d\x02\x07\n\x0e\n\x06\x04\xa7\x01\x02\n\
    \x01\x12\x04\x9e\x1d\x08\x12\n\x0e\n\x06\x04\xa7\x01\x02\n\x03\x12\x04\
    \x9e\x1d\x15\x17\n\x9d\x01\n\x05\x04\xa7\x01\x02\x0b\x12\x04\xa2\x1d\x02\
    &\x1a\x8d\x01\x20bookmark\x20info.\x20When\x20set,\x20this\x20module\x20\
    is\x20a\x20bookmarked\x20module\x20of\x20this\x20app.\n\x20Info\x20in\
    \x20this\x20field\x20will\x20allow\x20you\x20to\x20find/access\x20origin\
    al\x20module.\n\n\x0e\n\x06\x04\xa7\x01\x02\x0b\x06\x12\x04\xa2\x1d\x02\
    \x10\n\x0e\n\x06\x04\xa7\x01\x02\x0b\x01\x12\x04\xa2\x1d\x11\x20\n\x0e\n\
    \x06\x04\xa7\x01\x02\x0b\x03\x12\x04\xa2\x1d#%\n5\n\x05\x04\xa7\x01\x02\
    \x0c\x12\x04\xa4\x1d\x02\x13\x1a&\x20Representative\x20image\x20for\x20t\
    his\x20module\n\n\x0e\n\x06\x04\xa7\x01\x02\x0c\x06\x12\x04\xa4\x1d\x02\
    \x07\n\x0e\n\x06\x04\xa7\x01\x02\x0c\x01\x12\x04\xa4\x1d\x08\r\n\x0e\n\
    \x06\x04\xa7\x01\x02\x0c\x03\x12\x04\xa4\x1d\x10\x12\n]\n\x03\x04\xa8\
    \x01\x12\x06\xa8\x1d\0\xeb\x1d\x01\x1aN\x20A\x20specific\x20version\x20o\
    f\x20an\x20app\x20module\x20that\x20is\x20available\x20for\x20assigning\
    \x20to\x20apps.\n\n\x0c\n\x04\x04\xa8\x01\x01\x12\x04\xa8\x1d\x08\x15\n\
    \x0c\n\x04\x04\xa8\x01\t\x12\x04\xa9\x1d\x02\r\n\r\n\x05\x04\xa8\x01\t\0\
    \x12\x04\xa9\x1d\x0b\x0c\n\x0e\n\x06\x04\xa8\x01\t\0\x01\x12\x04\xa9\x1d\
    \x0b\x0c\n\x0e\n\x06\x04\xa8\x01\t\0\x02\x12\x04\xa9\x1d\x0b\x0c\n>\n\
    \x05\x04\xa8\x01\x02\0\x12\x04\xab\x1d\x02\x10\x1a/\x20A\x20name\x20for\
    \x20this\x20version\x20like\x201_0,\x201_1_0,\x20etc.\n\n\x0e\n\x06\x04\
    \xa8\x01\x02\0\x05\x12\x04\xab\x1d\x02\x08\n\x0e\n\x06\x04\xa8\x01\x02\0\
    \x01\x12\x04\xab\x1d\t\x0b\n\x0e\n\x06\x04\xa8\x01\x02\0\x03\x12\x04\xab\
    \x1d\x0e\x0f\n4\n\x05\x04\xa8\x01\x02\x01\x12\x04\xad\x1d\x02\x17\x1a%\
    \x20The\x20module\x20this\x20version\x20belongs\x20to.\n\n\x0e\n\x06\x04\
    \xa8\x01\x02\x01\x05\x12\x04\xad\x1d\x02\x08\n\x0e\n\x06\x04\xa8\x01\x02\
    \x01\x01\x12\x04\xad\x1d\t\x12\n\x0e\n\x06\x04\xa8\x01\x02\x01\x03\x12\
    \x04\xad\x1d\x15\x16\n;\n\x05\x04\xa8\x01\x02\x02\x12\x04\xaf\x1d\x02\
    \x14\x1a,\x20The\x20app_id\x20this\x20module\x20version\x20belongs\x20to\
    .\n\n\x0e\n\x06\x04\xa8\x01\x02\x02\x05\x12\x04\xaf\x1d\x02\x08\n\x0e\n\
    \x06\x04\xa8\x01\x02\x02\x01\x12\x04\xaf\x1d\t\x0f\n\x0e\n\x06\x04\xa8\
    \x01\x02\x02\x03\x12\x04\xaf\x1d\x12\x13\n<\n\x05\x04\xa8\x01\x02\x03\
    \x12\x04\xb1\x1d\x02\x15\x1a-\x20The\x20user_id\x20this\x20module\x20ver\
    sion\x20belongs\x20to.\n\n\x0e\n\x06\x04\xa8\x01\x02\x03\x05\x12\x04\xb1\
    \x1d\x02\x08\n\x0e\n\x06\x04\xa8\x01\x02\x03\x01\x12\x04\xb1\x1d\t\x10\n\
    \x0e\n\x06\x04\xa8\x01\x02\x03\x03\x12\x04\xb1\x1d\x13\x14\n6\n\x05\x04\
    \xa8\x01\x02\x04\x12\x04\xb3\x1d\x02\x19\x1a'\x20A\x20short\x20descripti\
    on\x20for\x20this\x20version.\n\n\x0e\n\x06\x04\xa8\x01\x02\x04\x05\x12\
    \x04\xb3\x1d\x02\x08\n\x0e\n\x06\x04\xa8\x01\x02\x04\x01\x12\x04\xb3\x1d\
    \t\x14\n\x0e\n\x06\x04\xa8\x01\x02\x04\x03\x12\x04\xb3\x1d\x17\x18\n\xa2\
    \x01\n\x05\x04\xa8\x01\x02\x05\x12\x04\xb6\x1d\x02\x13\x1a\x92\x01\x20A\
    \x20markdown\x20formatted\x20string\x20to\x20detailed\x20description\x20\
    of\x20the\x20app\x20module.\n\x20This\x20is\x20within\x20each\x20version\
    \x20so\x20that\x20it\x20can\x20be\x20change\x20version\x20to\x20version.\
    \n\n\x0e\n\x06\x04\xa8\x01\x02\x05\x05\x12\x04\xb6\x1d\x02\x08\n\x0e\n\
    \x06\x04\xa8\x01\x02\x05\x01\x12\x04\xb6\x1d\t\x0e\n\x0e\n\x06\x04\xa8\
    \x01\x02\x05\x03\x12\x04\xb6\x1d\x11\x12\n9\n\x05\x04\xa8\x01\x02\x06\
    \x12\x04\xb8\x1d\x02+\x1a*\x20When\x20the\x20app\x20module\x20version\
    \x20was\x20created.\n\n\x0e\n\x06\x04\xa8\x01\x02\x06\x06\x12\x04\xb8\
    \x1d\x02\x1b\n\x0e\n\x06\x04\xa8\x01\x02\x06\x01\x12\x04\xb8\x1d\x1c&\n\
    \x0e\n\x06\x04\xa8\x01\x02\x06\x03\x12\x04\xb8\x1d)*\n?\n\x05\x04\xa8\
    \x01\x02\x07\x12\x04\xba\x1d\x02,\x1a0\x20When\x20the\x20app\x20module\
    \x20version\x20was\x20last\x20modified.\n\n\x0e\n\x06\x04\xa8\x01\x02\
    \x07\x06\x12\x04\xba\x1d\x02\x1b\n\x0e\n\x06\x04\xa8\x01\x02\x07\x01\x12\
    \x04\xba\x1d\x1c'\n\x0e\n\x06\x04\xa8\x01\x02\x07\x03\x12\x04\xba\x1d*+\
    \n\xe6\x05\n\x05\x04\xa8\x01\x02\x08\x12\x04\xc6\x1d\x02\x1d\x1a\xd6\x05\
    \x20The\x20code\x20repo\x20of\x20the\x20streamlit\x20app.\n\x20If\x20you\
    \x20are\x20still\x20developing\x20your\x20Module\x20you\x20should\x20cre\
    ate\x20a\x20ModuleVersion\n\x20with\x20an\x20empty\x20git_commit_url\x20\
    and\x20then\x20create\x20an\x20InstalledModuleVersion\n\x20with\x20a\x20\
    pre-deployed\x20deploy_url\x20(such\x20as\x20localhost\x20or\x20streamli\
    t\x20cloud).\n\x20Once\x20you\x20are\x20ready\x20to\x20create\x20a\x20pr\
    oduction,\x20create\x20a\x20new\x20ModuleVersion\x20with\n\x20the\x20rea\
    dy\x20git\x20url\x20to\x20a\x20specific\x20commit\x20that\x20you\x20woul\
    d\x20like\x20to\x20be\x20reviewed\x20by\x20the\n\x20Clarifai\x20team\x20\
    for\x20approval\x20within\x20our\x20community.\x20You\x20cannot\x20publi\
    sh\x20a\x20ModuleVersion\n\x20is\x20reviewed\x20and\x20approved.\x20Plea\
    se\x20only\x20provide\x20the\x20git_commit_url\x20when\x20you're\n\x20re\
    ady\x20for\x20a\x20review.\x20This\x20url\x20needs\x20to\x20include\x20a\
    \x20specific\x20commit,\x20for\x20example:\n\x20https://github.com/user/\
    repo/commit/767ff9c08ba3429c8e7b8825da148555\n\n\x0e\n\x06\x04\xa8\x01\
    \x02\x08\x05\x12\x04\xc6\x1d\x02\x08\n\x0e\n\x06\x04\xa8\x01\x02\x08\x01\
    \x12\x04\xc6\x1d\t\x17\n\x0e\n\x06\x04\xa8\x01\x02\x08\x03\x12\x04\xc6\
    \x1d\x1a\x1c\n\x0f\n\x05\x04\xa8\x01\x03\0\x12\x06\xc8\x1d\x02\xd0\x1d\
    \x03\n\x0e\n\x06\x04\xa8\x01\x03\0\x01\x12\x04\xc8\x1d\n\x16\n\x98\x01\n\
    \x07\x04\xa8\x01\x03\0\x02\0\x12\x04\xcb\x1d\x04\x15\x1a\x86\x01\x20This\
    \x20is\x20the\x20display\x20title\x20for\x20a\x20navbar\x20element\x20to\
    \x20link\x20to\x20a\x20specific\x20page.\n\x20The\x20name\x20for\x20this\
    \x20subnav\x20element\x20to\x20show\x20in\x20the\x20sidebar.\n\n\x10\n\
    \x08\x04\xa8\x01\x03\0\x02\0\x05\x12\x04\xcb\x1d\x04\n\n\x10\n\x08\x04\
    \xa8\x01\x03\0\x02\0\x01\x12\x04\xcb\x1d\x0b\x10\n\x10\n\x08\x04\xa8\x01\
    \x03\0\x02\0\x03\x12\x04\xcb\x1d\x13\x14\n'\n\x07\x04\xa8\x01\x03\0\x02\
    \x01\x12\x04\xcd\x1d\x04\x19\x1a\x16\x20The\x20query\x20param\x20name\n\
    \n\x10\n\x08\x04\xa8\x01\x03\0\x02\x01\x05\x12\x04\xcd\x1d\x04\n\n\x10\n\
    \x08\x04\xa8\x01\x03\0\x02\x01\x01\x12\x04\xcd\x1d\x0b\x14\n\x10\n\x08\
    \x04\xa8\x01\x03\0\x02\x01\x03\x12\x04\xcd\x1d\x17\x18\n(\n\x07\x04\xa8\
    \x01\x03\0\x02\x02\x12\x04\xcf\x1d\x04\x1b\x1a\x17\x20The\x20query\x20pa\
    ram\x20value\n\n\x10\n\x08\x04\xa8\x01\x03\0\x02\x02\x05\x12\x04\xcf\x1d\
    \x04\n\n\x10\n\x08\x04\xa8\x01\x03\0\x02\x02\x01\x12\x04\xcf\x1d\x0b\x16\
    \n\x10\n\x08\x04\xa8\x01\x03\0\x02\x02\x03\x12\x04\xcf\x1d\x19\x1a\n\x0f\
    \n\x05\x04\xa8\x01\x03\x01\x12\x06\xd2\x1d\x02\xda\x1d\x03\n\x0e\n\x06\
    \x04\xa8\x01\x03\x01\x01\x12\x04\xd2\x1d\n\x13\n\xdc\x01\n\x07\x04\xa8\
    \x01\x03\x01\x02\0\x12\x04\xd6\x1d\x04\x15\x1a\xca\x01\x20This\x20is\x20\
    the\x20left\x20side\x20title\x20for\x20this\x20module\x20and\x20for\x20b\
    rowser\x20tab\x20title\x20of\x20the\x20module.\n\x20We\x20have\x20this\
    \x20in\x20the\x20version\x20so\x20that\x20users\x20can\x20change\x20thos\
    e\x20settings\n\x20when\x20releasing\x20a\x20new\x20version\x20of\x20the\
    ir\x20module.\n\n\x10\n\x08\x04\xa8\x01\x03\x01\x02\0\x05\x12\x04\xd6\
    \x1d\x04\n\n\x10\n\x08\x04\xa8\x01\x03\x01\x02\0\x01\x12\x04\xd6\x1d\x0b\
    \x10\n\x10\n\x08\x04\xa8\x01\x03\x01\x02\0\x03\x12\x04\xd6\x1d\x13\x14\n\
    K\n\x07\x04\xa8\x01\x03\x01\x02\x01\x12\x04\xd9\x1d\x04.\x1a:\x20A\x20li\
    st\x20of\x20subnav\x20elements\x20to\x20put\x20under\x20the\x20module\
    \x20title.\n\n\x10\n\x08\x04\xa8\x01\x03\x01\x02\x01\x04\x12\x04\xd9\x1d\
    \x04\x0c\n\x10\n\x08\x04\xa8\x01\x03\x01\x02\x01\x06\x12\x04\xd9\x1d\r\
    \x19\n\x10\n\x08\x04\xa8\x01\x03\x01\x02\x01\x01\x12\x04\xd9\x1d\x1a)\n\
    \x10\n\x08\x04\xa8\x01\x03\x01\x02\x01\x03\x12\x04\xd9\x1d,-\n\r\n\x05\
    \x04\xa8\x01\x02\t\x12\x04\xdb\x1d\x02\x1c\n\x0e\n\x06\x04\xa8\x01\x02\t\
    \x06\x12\x04\xdb\x1d\x02\x0b\n\x0e\n\x06\x04\xa8\x01\x02\t\x01\x12\x04\
    \xdb\x1d\x0c\x16\n\x0e\n\x06\x04\xa8\x01\x02\t\x03\x12\x04\xdb\x1d\x19\
    \x1b\ny\n\x05\x04\xa8\x01\x02\n\x12\x04\xdf\x1d\x02\x15\x1aj\x20A\x20boo\
    lean\x20to\x20mark\x20if\x20Clarifai\x20has\x20approved\x20this\x20app\
    \x20version.\n\x20This\x20cannot\x20be\x20set\x20in\x20the\x20request\
    \x20to\x20True.\n\n\x0e\n\x06\x04\xa8\x01\x02\n\x05\x12\x04\xdf\x1d\x02\
    \x06\n\x0e\n\x06\x04\xa8\x01\x02\n\x01\x12\x04\xdf\x1d\x07\x0f\n\x0e\n\
    \x06\x04\xa8\x01\x02\n\x03\x12\x04\xdf\x1d\x12\x14\n\x84\x02\n\x05\x04\
    \xa8\x01\x02\x0b\x12\x04\xe5\x1d\x02\x1d\x1a\xf4\x01\x20The\x20visibilit\
    y\x20field\x20represents\x20whether\x20this\x20message\x20is\x20privatel\
    y/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20public\
    \x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20User\x20that\
    \x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20visibl\
    e.\n\x20Defaults\x20to\x20PRIVATE\x20if\x20not\x20provided.\n\n\x0e\n\
    \x06\x04\xa8\x01\x02\x0b\x06\x12\x04\xe5\x1d\x02\x0c\n\x0e\n\x06\x04\xa8\
    \x01\x02\x0b\x01\x12\x04\xe5\x1d\r\x17\n\x0e\n\x06\x04\xa8\x01\x02\x0b\
    \x03\x12\x04\xe5\x1d\x1a\x1c\n\xba\x01\n\x05\x04\xa8\x01\x02\x0c\x12\x04\
    \xea\x1d\x02'\x1a\xaa\x01\x20To\x20handle\x20arbitrary\x20json\x20metada\
    ta\x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20https://github.com\
    /google/protobuf/blob/master/src/google/protobuf/struct.proto\n\x20This\
    \x20is\x20an\x20optional\x20arg.\n\n\x0e\n\x06\x04\xa8\x01\x02\x0c\x06\
    \x12\x04\xea\x1d\x02\x18\n\x0e\n\x06\x04\xa8\x01\x02\x0c\x01\x12\x04\xea\
    \x1d\x19!\n\x0e\n\x06\x04\xa8\x01\x02\x0c\x03\x12\x04\xea\x1d$&\n\r\n\
    \x03\x04\xa9\x01\x12\x06\xed\x1d\0\x9f\x1e\x01\n\x0c\n\x04\x04\xa9\x01\
    \x01\x12\x04\xed\x1d\x08\x1e\nT\n\x05\x04\xa9\x01\x02\0\x12\x04\xef\x1d\
    \x02\x10\x1aE\x20A\x20unique\x20id\x20for\x20this\x20install.\x20This\
    \x20will\x20be\x20used\x20in\x20the\x20browser\x20url.\n\n\x0e\n\x06\x04\
    \xa9\x01\x02\0\x05\x12\x04\xef\x1d\x02\x08\n\x0e\n\x06\x04\xa9\x01\x02\0\
    \x01\x12\x04\xef\x1d\t\x0b\n\x0e\n\x06\x04\xa9\x01\x02\0\x03\x12\x04\xef\
    \x1d\x0e\x0f\n\xc6\x02\n\x05\x04\xa9\x01\x02\x01\x12\x04\xf7\x1d\x02#\
    \x1a\xb6\x02\x20The\x20installed\x20module\x20version\x20provided\x20her\
    e\x20so\x20that\x20we\x20users\x20don't\x20need\x20to\x20do\x20an\x20add\
    itional\n\x20fetch.\x20When\x20creating\x20a\x20new\x20InstalledModuleVe\
    rsion\x20you\x20should\x20provide\x20the:\n\x20module_version.user_id\n\
    \x20module_version.app_id\n\x20module_version.module_id\n\x20module_vers\
    ion.id\n\x20in\x20order\x20to\x20uniquely\x20define\x20which\x20module\
    \x20version.\n\n\x0e\n\x06\x04\xa9\x01\x02\x01\x06\x12\x04\xf7\x1d\x02\
    \x0f\n\x0e\n\x06\x04\xa9\x01\x02\x01\x01\x12\x04\xf7\x1d\x10\x1e\n\x0e\n\
    \x06\x04\xa9\x01\x02\x01\x03\x12\x04\xf7\x1d!\"\n\xd3\x01\n\x05\x04\xa9\
    \x01\x02\x02\x12\x04\xfb\x1d\x02\x14\x1a\xc3\x01\x20The\x20app_id\x20the\
    \x20ModuleVersion\x20is\x20installed\x20into\x20(not\x20necessary\x20whe\
    re\x20the\x20ModuleVersion\x20was\n\x20created).\x20This\x20doesn't\x20h\
    ave\x20to\x20be\x20provided\x20in\x20requests\x20to\x20install,\x20but\
    \x20will\x20be\x20returned\x20in\n\x20responses.\n\n\x0e\n\x06\x04\xa9\
    \x01\x02\x02\x05\x12\x04\xfb\x1d\x02\x08\n\x0e\n\x06\x04\xa9\x01\x02\x02\
    \x01\x12\x04\xfb\x1d\t\x0f\n\x0e\n\x06\x04\xa9\x01\x02\x02\x03\x12\x04\
    \xfb\x1d\x12\x13\n\xef\x01\n\x05\x04\xa9\x01\x02\x03\x12\x04\xff\x1d\x02\
    \x15\x1a\xdf\x01\x20The\x20user\x20that\x20the\x20app\x20belongs\x20to\
    \x20where\x20the\x20ModuleVersion\x20is\x20installed\x20into\x20(not\x20\
    necessary\x20where\n\x20the\x20ModuleVersion\x20was\x20created).\x20This\
    \x20doesn't\x20have\x20to\x20be\x20provided\x20in\x20requests\x20to\x20i\
    nstall,\x20but\n\x20will\x20be\x20returned\x20in\x20responses.\n\n\x0e\n\
    \x06\x04\xa9\x01\x02\x03\x05\x12\x04\xff\x1d\x02\x08\n\x0e\n\x06\x04\xa9\
    \x01\x02\x03\x01\x12\x04\xff\x1d\t\x10\n\x0e\n\x06\x04\xa9\x01\x02\x03\
    \x03\x12\x04\xff\x1d\x13\x14\n.\n\x05\x04\xa9\x01\x02\x04\x12\x04\x81\
    \x1e\x02+\x1a\x1f\x20When\x20the\x20install\x20was\x20created.\n\n\x0e\n\
    \x06\x04\xa9\x01\x02\x04\x06\x12\x04\x81\x1e\x02\x1b\n\x0e\n\x06\x04\xa9\
    \x01\x02\x04\x01\x12\x04\x81\x1e\x1c&\n\x0e\n\x06\x04\xa9\x01\x02\x04\
    \x03\x12\x04\x81\x1e)*\n4\n\x05\x04\xa9\x01\x02\x05\x12\x04\x83\x1e\x02,\
    \x1a%\x20When\x20the\x20install\x20was\x20last\x20modified.\n\n\x0e\n\
    \x06\x04\xa9\x01\x02\x05\x06\x12\x04\x83\x1e\x02\x1b\n\x0e\n\x06\x04\xa9\
    \x01\x02\x05\x01\x12\x04\x83\x1e\x1c'\n\x0e\n\x06\x04\xa9\x01\x02\x05\
    \x03\x12\x04\x83\x1e*+\n\xd0\x04\n\x05\x04\xa9\x01\x02\x06\x12\x04\x8d\
    \x1e\x02\x18\x1a\xc0\x04\x20The\x20URL\x20of\x20where\x20this\x20app\x20\
    module\x20version\x20is\x20deployed.\n\x20If\x20you\x20provide\x20this\
    \x20deploy_url\x20when\x20creating\x20the\x20install\x20then\x20it\x20wi\
    ll\n\x20be\x20treated\x20as\x20a\x20pre-deployed\x20module.\x20You\x20ca\
    n\x20only\x20use\x20a\x20pre-deployed\x20module\n\x20in\x20when\x20insta\
    lling\x20to\x20an\x20app_id\x20that\x20you\x20own\x20as\x20the\x20creato\
    r\x20of\x20the\x20module.\n\x20If\x20you\x20want\x20to\x20install\x20som\
    eone\x20elses\x20module\x20or\x20to\x20rely\x20on\x20Clarifai\x20deployi\
    ng\n\x20your\x20module\x20for\x20you,\x20leave\x20deploy_url\x20empty\
    \x20when\x20creating\x20the\x20install.\n\x20If\x20it\x20is\x20left\x20e\
    mpty,\x20then\x20deployment\x20will\x20occur\x20when\x20this\x20module\
    \x20version\x20is\n\x20installed\x20into\x20an\x20app\x20using\x20the\
    \x20git_commit_url\x20of\x20the\x20ModuleVersion.\n\n\x0e\n\x06\x04\xa9\
    \x01\x02\x06\x05\x12\x04\x8d\x1e\x02\x08\n\x0e\n\x06\x04\xa9\x01\x02\x06\
    \x01\x12\x04\x8d\x1e\t\x13\n\x0e\n\x06\x04\xa9\x01\x02\x06\x03\x12\x04\
    \x8d\x1e\x16\x17\n\xe0\x03\n\x05\x04\xa9\x01\x02\x07\x12\x04\x95\x1e\x02\
    \x1c\x1a\xd0\x03\x20The\x20visibility\x20field\x20represents\x20whether\
    \x20this\x20message\x20is\x20privately/publicly\x20visible.\n\x20To\x20b\
    e\x20visible\x20to\x20the\x20public\x20the\x20App\x20that\x20contains\
    \x20it\x20AND\x20the\x20User\x20that\x20contains\x20the\x20App\x20must\n\
    \x20also\x20be\x20publicly\x20visible.\x20For\x20the\x20InstalledModuleV\
    ersion\x20this\x20allows\x20the\x20app\x20owner\x20who\n\x20installed\
    \x20the\x20module\x20version\x20to\x20decide\x20if\x20they\x20want\x20ot\
    her\x20users\x20of\x20their\x20app\x20to\x20have\n\x20the\x20added\x20fu\
    nctionality\x20that\x20the\x20modules\x20version\x20provides\x20to\x20th\
    eir\x20app.\n\x20Defaults\x20to\x20PRIVATE\x20if\x20not\x20provided.\n\n\
    \x0e\n\x06\x04\xa9\x01\x02\x07\x06\x12\x04\x95\x1e\x02\x0c\n\x0e\n\x06\
    \x04\xa9\x01\x02\x07\x01\x12\x04\x95\x1e\r\x17\n\x0e\n\x06\x04\xa9\x01\
    \x02\x07\x03\x12\x04\x95\x1e\x1a\x1b\n\xed\x04\n\x05\x04\xa9\x01\x02\x08\
    \x12\x04\x9e\x1e\x02\x14\x1a\xdd\x04\x20The\x20key\x20ID\x20to\x20use\
    \x20for\x20making\x20requests\x20to\x20the\x20API\x20for\x20this\x20modu\
    le.\n\x20This\x20key\x20is\x20associated\x20to\x20this\x20installed\x20m\
    odule\x20version\x20by\x20PostInstalledModuleVersionsKey\n\x20request.\
    \x20The\x20key\x20is\x20associated\x20with\x20the\x20CALLER\x20not\x20th\
    e\x20App\x20Owner\x20where\x20this\x20module\x20is\x20installed\n\x20nor\
    \x20the\x20author\x20of\x20the\x20module.\x20This\x20allows\x20the\x20mo\
    dule\x20to\x20act\x20on\x20behalf\x20of\x20the\x20caller\x20at\x20all\n\
    \x20times\x20so\x20we\x20get\x20proper\x20permissions\x20the\x20caller\
    \x20has\x20(such\x20as\x20if\x20they\x20are\x20stranger,\x20teammate\x20\
    or\n\x20collaborator).\x20This\x20key\x20should\x20be\x20a\x20personal\
    \x20access\x20token\x20to\x20enable\x20modules\x20to\x20work\x20across\
    \x20apps\n\x20and\x20have\x20necessary\x20abilities\x20beyond\x20what\
    \x20app-specific\x20keys\x20offer.\n\n\x0e\n\x06\x04\xa9\x01\x02\x08\x05\
    \x12\x04\x9e\x1e\x02\x08\n\x0e\n\x06\x04\xa9\x01\x02\x08\x01\x12\x04\x9e\
    \x1e\t\x0f\n\x0e\n\x06\x04\xa9\x01\x02\x08\x03\x12\x04\x9e\x1e\x12\x13\n\
    \r\n\x03\x04\xaa\x01\x12\x06\xa1\x1e\0\xcd\x1e\x01\n\x0c\n\x04\x04\xaa\
    \x01\x01\x12\x04\xa1\x1e\x08\x15\n.\n\x05\x04\xaa\x01\x02\0\x12\x04\xa3\
    \x1e\x02\x10\x1a\x1f\x20id\x20of\x20the\x20Bulk\x20Operation\x20task\n\n\
    \x0e\n\x06\x04\xaa\x01\x02\0\x05\x12\x04\xa3\x1e\x02\x08\n\x0e\n\x06\x04\
    \xaa\x01\x02\0\x01\x12\x04\xa3\x1e\t\x0b\n\x0e\n\x06\x04\xaa\x01\x02\0\
    \x03\x12\x04\xa3\x1e\x0e\x0f\n\xec\x05\n\x05\x04\xaa\x01\x08\0\x12\x06\
    \xb0\x1e\x02\xb4\x1e\x03\x1a\xda\x05\x20Input\x20Source\x20could\x20be\
    \x20list\x20of\x20input\x20ids\x20or\x20a\x20Search\x20whose\x20results\
    \x20will\x20be\x20a\x20list\x20of\x20input\x20ids.\n\x20InputIDs:\n\x20\
    \x20\x20\x20\x20\x20List\x20of\x20input\x20ids\x20to\x20which\x20operati\
    on\x20to\x20be\x20applied\n\x20clarifai.api.Search:\n\x20\x20\x20\x20\
    \x20\x20A\x20Search(either\x20filter\x20or\x20rank\x20with\x20min\x20val\
    ue)\x20to\x20allow\x20filtering\x20down\x20the\x20entire\x20app's\n\x20\
    \x20\x20\x20\x20\x20sub-assets(image,\x20region\x20in\x20image,\x20frame\
    \x20in\x20video,\x20region\x20in\x20frame\x20in\x20video)\n\x20\x20\x20\
    \x20\x20\x20and\x20perform\x20operation\x20to\x20only\x20the\x20results\
    \x20of\x20this\x20search\x20query.\x20See\x20our\x20search\n\x20\x20\x20\
    \x20\x20\x20documentation\x20for\x20more\x20details\x20about\x20the\x20s\
    earch\x20Query\x20message.\n\x20\x20\x20\x20\x20\x20For\x20eg.,\x20filte\
    rs\x20the\x20asset/sub-asset\x20matching\x20the\x20search\x20and\x20perf\
    orms\x20specified\x20operation.\n\x20Dataset:\n\x20\x20\x20\x20\x20\x20A\
    \x20dataset,\x20whose\x20inputs\x20will\x20have\x20the\x20operation\x20a\
    pplied\x20to.\x20This\x20does\x20not\x20support\x20dataset\x20versions.\
    \n\n\x0e\n\x06\x04\xaa\x01\x08\0\x01\x12\x04\xb0\x1e\x08\x14\n\r\n\x05\
    \x04\xaa\x01\x02\x01\x12\x04\xb1\x1e\x04\x1b\n\x0e\n\x06\x04\xaa\x01\x02\
    \x01\x06\x12\x04\xb1\x1e\x04\x0c\n\x0e\n\x06\x04\xaa\x01\x02\x01\x01\x12\
    \x04\xb1\x1e\r\x16\n\x0e\n\x06\x04\xaa\x01\x02\x01\x03\x12\x04\xb1\x1e\
    \x19\x1a\n\r\n\x05\x04\xaa\x01\x02\x02\x12\x04\xb2\x1e\x04$\n\x0e\n\x06\
    \x04\xaa\x01\x02\x02\x06\x12\x04\xb2\x1e\x04\x17\n\x0e\n\x06\x04\xaa\x01\
    \x02\x02\x01\x12\x04\xb2\x1e\x18\x1e\n\x0e\n\x06\x04\xaa\x01\x02\x02\x03\
    \x12\x04\xb2\x1e!#\n\r\n\x05\x04\xaa\x01\x02\x03\x12\x04\xb3\x1e\x04\x19\
    \n\x0e\n\x06\x04\xaa\x01\x02\x03\x06\x12\x04\xb3\x1e\x04\x0b\n\x0e\n\x06\
    \x04\xaa\x01\x02\x03\x01\x12\x04\xb3\x1e\x0c\x13\n\x0e\n\x06\x04\xaa\x01\
    \x02\x03\x03\x12\x04\xb3\x1e\x16\x18\n%\n\x05\x04\xaa\x01\x02\x04\x12\
    \x04\xb7\x1e\x02\x1a\x1a\x16\x20Operation\x20to\x20perform\n\n\x0e\n\x06\
    \x04\xaa\x01\x02\x04\x06\x12\x04\xb7\x1e\x02\x0b\n\x0e\n\x06\x04\xaa\x01\
    \x02\x04\x01\x12\x04\xb7\x1e\x0c\x15\n\x0e\n\x06\x04\xaa\x01\x02\x04\x03\
    \x12\x04\xb7\x1e\x18\x19\nD\n\x05\x04\xaa\x01\x02\x05\x12\x04\xba\x1e\
    \x02\x14\x1a5\x20Application\x20ID\x20that\x20this\x20Operation\x20was\
    \x20created\x20from\n\n\x0e\n\x06\x04\xaa\x01\x02\x05\x05\x12\x04\xba\
    \x1e\x02\x08\n\x0e\n\x06\x04\xaa\x01\x02\x05\x01\x12\x04\xba\x1e\t\x0f\n\
    \x0e\n\x06\x04\xaa\x01\x02\x05\x03\x12\x04\xba\x1e\x12\x13\nR\n\x05\x04\
    \xaa\x01\x02\x06\x12\x04\xbd\x1e\x02(\x1aC\x20Status\x20(pending,\x20in-\
    progress,\x20completed,\x20failed)\x20of\x20the\x20operation\n\n\x0e\n\
    \x06\x04\xaa\x01\x02\x06\x06\x12\x04\xbd\x1e\x02\x1c\n\x0e\n\x06\x04\xaa\
    \x01\x02\x06\x01\x12\x04\xbd\x1e\x1d#\n\x0e\n\x06\x04\xaa\x01\x02\x06\
    \x03\x12\x04\xbd\x1e&'\n<\n\x05\x04\xaa\x01\x02\x07\x12\x04\xc0\x1e\x02\
    \x18\x1a-\x20Progress\x20of\x20an\x20on-going\x20Bulk\x20Operation\x20ta\
    sk\n\n\x0e\n\x06\x04\xaa\x01\x02\x07\x06\x12\x04\xc0\x1e\x02\n\n\x0e\n\
    \x06\x04\xaa\x01\x02\x07\x01\x12\x04\xc0\x1e\x0b\x13\n\x0e\n\x06\x04\xaa\
    \x01\x02\x07\x03\x12\x04\xc0\x1e\x16\x17\n4\n\x05\x04\xaa\x01\x02\x08\
    \x12\x04\xc3\x1e\x02\x18\x1a%\x20User\x20id\x20that\x20created\x20this\
    \x20operation\n\n\x0e\n\x06\x04\xaa\x01\x02\x08\x05\x12\x04\xc3\x1e\x02\
    \x08\n\x0e\n\x06\x04\xaa\x01\x02\x08\x01\x12\x04\xc3\x1e\t\x13\n\x0e\n\
    \x06\x04\xaa\x01\x02\x08\x03\x12\x04\xc3\x1e\x16\x17\n\x85\x02\n\x05\x04\
    \xaa\x01\x02\t\x12\x04\xca\x1e\x02+\x1a\xf5\x01\x20When\x20the\x20operat\
    ion\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20timestamp\n\x20\
    format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\x20format:\
    \n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20expect\x20r\
    esults\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\x20\"2017-\
    04-11T21:50:50.223962Z\"\n\n\x0e\n\x06\x04\xaa\x01\x02\t\x06\x12\x04\xca\
    \x1e\x02\x1b\n\x0e\n\x06\x04\xaa\x01\x02\t\x01\x12\x04\xca\x1e\x1c&\n\
    \x0e\n\x06\x04\xaa\x01\x02\t\x03\x12\x04\xca\x1e)*\n1\n\x05\x04\xaa\x01\
    \x02\n\x12\x04\xcc\x1e\x021\x1a\"\x20Last\x20time\x20the\x20status\x20go\
    t\x20updated\n\n\x0e\n\x06\x04\xaa\x01\x02\n\x06\x12\x04\xcc\x1e\x02\x1b\
    \n\x0e\n\x06\x04\xaa\x01\x02\n\x01\x12\x04\xcc\x1e\x1c,\n\x0e\n\x06\x04\
    \xaa\x01\x02\n\x03\x12\x04\xcc\x1e/0\n\x0b\n\x03\x04\xab\x01\x12\x04\xcf\
    \x1e\03\n\x0c\n\x04\x04\xab\x01\x01\x12\x04\xcf\x1e\x08\x10\n\r\n\x05\
    \x04\xab\x01\x02\0\x12\x04\xcf\x1e\x131\n\x0e\n\x06\x04\xab\x01\x02\0\
    \x04\x12\x04\xcf\x1e\x13\x1b\n\x0e\n\x06\x04\xab\x01\x02\0\x05\x12\x04\
    \xcf\x1e\x1c\"\n\x0e\n\x06\x04\xab\x01\x02\0\x01\x12\x04\xcf\x1e#,\n\x0e\
    \n\x06\x04\xab\x01\x02\0\x03\x12\x04\xcf\x1e/0\n\r\n\x03\x04\xac\x01\x12\
    \x06\xd1\x1e\0\xd4\x1e\x01\n\x0c\n\x04\x04\xac\x01\x01\x12\x04\xd1\x1e\
    \x08\x10\n\r\n\x05\x04\xac\x01\x02\0\x12\x04\xd2\x1e\x02\x17\n\x0e\n\x06\
    \x04\xac\x01\x02\0\x05\x12\x04\xd2\x1e\x02\x08\n\x0e\n\x06\x04\xac\x01\
    \x02\0\x01\x12\x04\xd2\x1e\t\x12\n\x0e\n\x06\x04\xac\x01\x02\0\x03\x12\
    \x04\xd2\x1e\x15\x16\n\r\n\x05\x04\xac\x01\x02\x01\x12\x04\xd3\x1e\x02\
    \x1f\n\x0e\n\x06\x04\xac\x01\x02\x01\x05\x12\x04\xd3\x1e\x02\x08\n\x0e\n\
    \x06\x04\xac\x01\x02\x01\x01\x12\x04\xd3\x1e\t\x1a\n\x0e\n\x06\x04\xac\
    \x01\x02\x01\x03\x12\x04\xd3\x1e\x1d\x1e\n\r\n\x03\x04\xad\x01\x12\x06\
    \xd6\x1e\0\x88\x1f\x01\n\x0c\n\x04\x04\xad\x01\x01\x12\x04\xd6\x1e\x08\
    \x11\n\x84\x11\n\x05\x04\xad\x01\x08\0\x12\x06\xfd\x1e\x02\x87\x1f\x03\
    \x1a\xf2\x10\x20Bulk\x20Operations\x20supported:\n\x20Concepts:\n\x20\
    \x20\x20\x20Operations:\x20add_concepts,\x20delete_concepts\n\x20\x20\
    \x20\x20AddConcepts:\n\x20\x20\x20\x20\x20\x20\x20\x20If\x20new\x20conce\
    pts\x20are\x20given,\x20add\x20concepts\x20operation\x20creates\x20new\
    \x20concepts\x20in\x20the\x20app\x20and\x20adds\x20them\x20to\x20the\x20\
    given\x20inputs'\x20annotations.\n\x20\x20\x20\x20\x20\x20\x20\x20If\x20\
    the\x20given\x20concept\x20already\x20exist,\x20the\x20label\x20value\
    \x20of\x20the\x20concept\x20is\x20updated\x20with\x20the\x20given\x20val\
    ue.\n\x20\x20\x20\x20DeleteConcepts:\n\x20\x20\x20\x20\x20\x20\x20\x20Re\
    move\x20the\x20matching\x20concept(s)\x20for\x20all\x20the\x20inputs\x20\
    in\x20input\x20source\x20(mentioned\x20above).\n\x20\x20\x20\x20\x20\x20\
    \x20\x20If\x20user\x20IDs\x20are\x20set,\x20concepts\x20will\x20be\x20de\
    leted\x20only\x20from\x20annotations\x20created\x20by\x20given\x20user\
    \x20ids.\n\x20\x20\x20\x20\x20\x20\x20\x20If\x20the\x20user\x20IDs\x20ar\
    e\x20not\x20set,\x20the\x20list\x20will\x20be\x20automatically\x20set\
    \x20with\x201\x20element\x20that\x20is\x20the\x20caller\x20user\x20ID.\n\
    \x20\x20\x20\x20Input\x20Source:\n\x20\x20\x20\x20\x20\x20\x20\x20Input\
    \x20ids\x20of\x20assets(images)\x20(or)\x20search\x20on\x20sub-assets(re\
    gion\x20in\x20image,\x20frame\x20in\x20video,\x20region\x20in\x20frame\
    \x20in\x20video)\n\x20Metadata:\n\x20\x20\x20\x20Operations:\x20add_meta\
    data,\x20delete_metadata\n\x20\x20\x20\x20AddMetadata:\n\x20\x20\x20\x20\
    \x20\x20\x20\x20Add\x20the\x20provided\x20metadata\x20to\x20the\x20input\
    \x20level\x20annotation\x20for\x20all\x20the\x20inputs\x20in\x20input\
    \x20source\x20(mentioned\x20above).\n\x20\x20\x20\x20\x20\x20\x20\x20If\
    \x20the\x20key(s)\x20already\x20exists,\x20it\x20will\x20overwrite\x20th\
    e\x20key(s)\x20with\x20the\x20corresponding\x20new\x20value(s).\n\x20\
    \x20\x20\x20DeleteMetadata:\n\x20\x20\x20\x20\x20\x20\x20\x20Remove\x20t\
    he\x20key,\x20value\x20pairs\x20that\x20match\x20the\x20given\x20metadat\
    a\x20from\x20the\x20existing\x20input\x20level\x20Annotations'\x20metada\
    ta\n\x20\x20\x20\x20\x20\x20\x20\x20for\x20all\x20the\x20inputs\x20in\
    \x20input\x20source\x20(mentioned\x20above).\n\x20\x20\x20\x20Input\x20S\
    ource:\n\x20\x20\x20\x20\x20\x20\x20\x20Input\x20ids\x20of\x20assets(ima\
    ges,\x20videos)\x20(or)\x20search\x20on\x20sub-assets(region\x20in\x20im\
    age,\x20frame\x20in\x20video,\x20region\x20in\x20frame\x20in\x20video)\n\
    \x20Geo:\n\x20\x20\x20\x20Operations:\x20overwrite_geo,\x20delete_geo\n\
    \x20\x20\x20\x20OverwriteGeo:\n\x20\x20\x20\x20\x20\x20\x20\x20Add\x20th\
    e\x20provided\x20geo\x20info\x20for\x20all\x20the\x20inputs\x20in\x20inp\
    ut\x20source\x20(mentioned\x20above).\n\x20\x20\x20\x20DeleteGeo:\n\x20\
    \x20\x20\x20\x20\x20\x20\x20Delete\x20Geo\x20info\x20for\x20all\x20the\
    \x20inputs\x20in\x20input\x20source\x20(mentioned\x20above).\n\x20\x20\
    \x20\x20Input\x20Source:\n\x20\x20\x20\x20\x20\x20\x20\x20Input\x20ids\
    \x20of\x20assets(images,\x20videos)\x20(or)\x20search\x20on\x20sub-asset\
    s(region\x20in\x20image,\x20frame\x20in\x20video,\x20region\x20in\x20fra\
    me\x20in\x20video)\n\x20Dataset\x20Inputs:\n\x20\x20\x20\x20Operations:\
    \x20add_to_dataset,\x20delete_from_dataset,\x20split_into_datasets\n\x20\
    \x20\x20\x20AddToDataset:\n\x20\x20\x20\x20\x20\x20\x20\x20Add\x20inputs\
    \x20to\x20a\x20dataset\n\x20\x20\x20\x20DeleteFromDataset:\n\x20\x20\x20\
    \x20\x20\x20\x20\x20Delete\x20inputs\x20from\x20a\x20dataset\n\x20\x20\
    \x20\x20SplitIntoDatasets:\n\x20\x20\x20\x20\x20\x20\x20\x20Randomly\x20\
    split\x20inputs\x20into\x20provided\x20dataset\x20ID's\x20with\x20provid\
    ed\x20percentages.\n\n\x0e\n\x06\x04\xad\x01\x08\0\x01\x12\x04\xfd\x1e\
    \x08\x11\n\r\n\x05\x04\xad\x01\x02\0\x12\x04\xfe\x1e\x04!\n\x0e\n\x06\
    \x04\xad\x01\x02\0\x06\x12\x04\xfe\x1e\x04\x0f\n\x0e\n\x06\x04\xad\x01\
    \x02\0\x01\x12\x04\xfe\x1e\x10\x1c\n\x0e\n\x06\x04\xad\x01\x02\0\x03\x12\
    \x04\xfe\x1e\x1f\x20\n\r\n\x05\x04\xad\x01\x02\x01\x12\x04\xff\x1e\x04'\
    \n\x0e\n\x06\x04\xad\x01\x02\x01\x06\x12\x04\xff\x1e\x04\x12\n\x0e\n\x06\
    \x04\xad\x01\x02\x01\x01\x12\x04\xff\x1e\x13\"\n\x0e\n\x06\x04\xad\x01\
    \x02\x01\x03\x12\x04\xff\x1e%&\n\r\n\x05\x04\xad\x01\x02\x02\x12\x04\x80\
    \x1f\x04!\n\x0e\n\x06\x04\xad\x01\x02\x02\x06\x12\x04\x80\x1f\x04\x0f\n\
    \x0e\n\x06\x04\xad\x01\x02\x02\x01\x12\x04\x80\x1f\x10\x1c\n\x0e\n\x06\
    \x04\xad\x01\x02\x02\x03\x12\x04\x80\x1f\x1f\x20\n\r\n\x05\x04\xad\x01\
    \x02\x03\x12\x04\x81\x1f\x04'\n\x0e\n\x06\x04\xad\x01\x02\x03\x06\x12\
    \x04\x81\x1f\x04\x12\n\x0e\n\x06\x04\xad\x01\x02\x03\x01\x12\x04\x81\x1f\
    \x13\"\n\x0e\n\x06\x04\xad\x01\x02\x03\x03\x12\x04\x81\x1f%&\n\r\n\x05\
    \x04\xad\x01\x02\x04\x12\x04\x82\x1f\x04#\n\x0e\n\x06\x04\xad\x01\x02\
    \x04\x06\x12\x04\x82\x1f\x04\x10\n\x0e\n\x06\x04\xad\x01\x02\x04\x01\x12\
    \x04\x82\x1f\x11\x1e\n\x0e\n\x06\x04\xad\x01\x02\x04\x03\x12\x04\x82\x1f\
    !\"\n\r\n\x05\x04\xad\x01\x02\x05\x12\x04\x83\x1f\x04\x1d\n\x0e\n\x06\
    \x04\xad\x01\x02\x05\x06\x12\x04\x83\x1f\x04\r\n\x0e\n\x06\x04\xad\x01\
    \x02\x05\x01\x12\x04\x83\x1f\x0e\x18\n\x0e\n\x06\x04\xad\x01\x02\x05\x03\
    \x12\x04\x83\x1f\x1b\x1c\n\r\n\x05\x04\xad\x01\x02\x06\x12\x04\x84\x1f\
    \x04.\n\x0e\n\x06\x04\xad\x01\x02\x06\x06\x12\x04\x84\x1f\x04\x15\n\x0e\
    \n\x06\x04\xad\x01\x02\x06\x01\x12\x04\x84\x1f\x16)\n\x0e\n\x06\x04\xad\
    \x01\x02\x06\x03\x12\x04\x84\x1f,-\n\r\n\x05\x04\xad\x01\x02\x07\x12\x04\
    \x85\x1f\x04$\n\x0e\n\x06\x04\xad\x01\x02\x07\x06\x12\x04\x85\x1f\x04\
    \x10\n\x0e\n\x06\x04\xad\x01\x02\x07\x01\x12\x04\x85\x1f\x11\x1f\n\x0e\n\
    \x06\x04\xad\x01\x02\x07\x03\x12\x04\x85\x1f\"#\n\r\n\x05\x04\xad\x01\
    \x02\x08\x12\x04\x86\x1f\x04.\n\x0e\n\x06\x04\xad\x01\x02\x08\x06\x12\
    \x04\x86\x1f\x04\x15\n\x0e\n\x06\x04\xad\x01\x02\x08\x01\x12\x04\x86\x1f\
    \x16)\n\x0e\n\x06\x04\xad\x01\x02\x08\x03\x12\x04\x86\x1f,-\n\x0b\n\x03\
    \x04\xae\x01\x12\x04\x8a\x1f\06\n\x0c\n\x04\x04\xae\x01\x01\x12\x04\x8a\
    \x1f\x08\x13\n\r\n\x05\x04\xae\x01\x02\0\x12\x04\x8a\x1f\x164\n\x0e\n\
    \x06\x04\xae\x01\x02\0\x04\x12\x04\x8a\x1f\x16\x1e\n\x0e\n\x06\x04\xae\
    \x01\x02\0\x06\x12\x04\x8a\x1f\x1f&\n\x0e\n\x06\x04\xae\x01\x02\0\x01\
    \x12\x04\x8a\x1f'/\n\x0e\n\x06\x04\xae\x01\x02\0\x03\x12\x04\x8a\x1f23\n\
    \r\n\x03\x04\xaf\x01\x12\x06\x8c\x1f\0\x8f\x1f\x01\n\x0c\n\x04\x04\xaf\
    \x01\x01\x12\x04\x8c\x1f\x08\x16\n\r\n\x05\x04\xaf\x01\x02\0\x12\x04\x8d\
    \x1f\x02\x20\n\x0e\n\x06\x04\xaf\x01\x02\0\x04\x12\x04\x8d\x1f\x02\n\n\
    \x0e\n\x06\x04\xaf\x01\x02\0\x06\x12\x04\x8d\x1f\x0b\x12\n\x0e\n\x06\x04\
    \xaf\x01\x02\0\x01\x12\x04\x8d\x1f\x13\x1b\n\x0e\n\x06\x04\xaf\x01\x02\0\
    \x03\x12\x04\x8d\x1f\x1e\x1f\n\r\n\x05\x04\xaf\x01\x02\x01\x12\x04\x8e\
    \x1f\x02\x1f\n\x0e\n\x06\x04\xaf\x01\x02\x01\x04\x12\x04\x8e\x1f\x02\n\n\
    \x0e\n\x06\x04\xaf\x01\x02\x01\x05\x12\x04\x8e\x1f\x0b\x11\n\x0e\n\x06\
    \x04\xaf\x01\x02\x01\x01\x12\x04\x8e\x1f\x12\x1a\n\x0e\n\x06\x04\xaf\x01\
    \x02\x01\x03\x12\x04\x8e\x1f\x1d\x1e\n\r\n\x03\x04\xb0\x01\x12\x06\x91\
    \x1f\0\x95\x1f\x01\n\x0c\n\x04\x04\xb0\x01\x01\x12\x04\x91\x1f\x08\x13\n\
    \xa0\x01\n\x05\x04\xb0\x01\x02\0\x12\x04\x94\x1f\x02&\x1a\x90\x01\x20To\
    \x20handle\x20arbitrary\x20json\x20metadata\x20you\x20can\x20use\x20a\
    \x20struct\x20field:\n\x20https://github.com/google/protobuf/blob/master\
    /src/google/protobuf/struct.proto\n\n\x0e\n\x06\x04\xb0\x01\x02\0\x06\
    \x12\x04\x94\x1f\x02\x18\n\x0e\n\x06\x04\xb0\x01\x02\0\x01\x12\x04\x94\
    \x1f\x19!\n\x0e\n\x06\x04\xb0\x01\x02\0\x03\x12\x04\x94\x1f$%\n\r\n\x03\
    \x04\xb1\x01\x12\x06\x97\x1f\0\x9b\x1f\x01\n\x0c\n\x04\x04\xb1\x01\x01\
    \x12\x04\x97\x1f\x08\x16\n\xa0\x01\n\x05\x04\xb1\x01\x02\0\x12\x04\x9a\
    \x1f\x02&\x1a\x90\x01\x20To\x20handle\x20arbitrary\x20json\x20metadata\
    \x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20https://github.com/g\
    oogle/protobuf/blob/master/src/google/protobuf/struct.proto\n\n\x0e\n\
    \x06\x04\xb1\x01\x02\0\x06\x12\x04\x9a\x1f\x02\x18\n\x0e\n\x06\x04\xb1\
    \x01\x02\0\x01\x12\x04\x9a\x1f\x19!\n\x0e\n\x06\x04\xb1\x01\x02\0\x03\
    \x12\x04\x9a\x1f$%\n\r\n\x03\x04\xb2\x01\x12\x06\x9d\x1f\0\xa0\x1f\x01\n\
    \x0c\n\x04\x04\xb2\x01\x01\x12\x04\x9d\x1f\x08\x14\n\x19\n\x05\x04\xb2\
    \x01\x02\0\x12\x04\x9f\x1f\x02\x0e\x1a\n\x20Geo\x20info\n\n\x0e\n\x06\
    \x04\xb2\x01\x02\0\x06\x12\x04\x9f\x1f\x02\x05\n\x0e\n\x06\x04\xb2\x01\
    \x02\0\x01\x12\x04\x9f\x1f\x06\t\n\x0e\n\x06\x04\xb2\x01\x02\0\x03\x12\
    \x04\x9f\x1f\x0c\r\n\x0b\n\x03\x04\xb3\x01\x12\x04\xa2\x1f\0\x14\n\x0c\n\
    \x04\x04\xb3\x01\x01\x12\x04\xa2\x1f\x08\x11\n\x0b\n\x03\x04\xb4\x01\x12\
    \x04\xa4\x1f\0/\n\x0c\n\x04\x04\xb4\x01\x01\x12\x04\xa4\x1f\x08\x14\n\r\
    \n\x05\x04\xb4\x01\x02\0\x12\x04\xa4\x1f\x17-\n\x0e\n\x06\x04\xb4\x01\
    \x02\0\x05\x12\x04\xa4\x1f\x17\x1d\n\x0e\n\x06\x04\xb4\x01\x02\0\x01\x12\
    \x04\xa4\x1f\x1e(\n\x0e\n\x06\x04\xb4\x01\x02\0\x03\x12\x04\xa4\x1f+,\n\
    \x0b\n\x03\x04\xb5\x01\x12\x04\xa6\x1f\04\n\x0c\n\x04\x04\xb5\x01\x01\
    \x12\x04\xa6\x1f\x08\x19\n\r\n\x05\x04\xb5\x01\x02\0\x12\x04\xa6\x1f\x1c\
    2\n\x0e\n\x06\x04\xb5\x01\x02\0\x05\x12\x04\xa6\x1f\x1c\"\n\x0e\n\x06\
    \x04\xb5\x01\x02\0\x01\x12\x04\xa6\x1f#-\n\x0e\n\x06\x04\xb5\x01\x02\0\
    \x03\x12\x04\xa6\x1f01\n\r\n\x03\x04\xb6\x01\x12\x06\xa8\x1f\0\xb0\x1f\
    \x01\n\x0c\n\x04\x04\xb6\x01\x01\x12\x04\xa8\x1f\x08\x19\n\r\n\x05\x04\
    \xb6\x01\x02\0\x12\x04\xa9\x1f\x02+\n\x0e\n\x06\x04\xb6\x01\x02\0\x04\
    \x12\x04\xa9\x1f\x02\n\n\x0e\n\x06\x04\xb6\x01\x02\0\x06\x12\x04\xa9\x1f\
    \x0b\x17\n\x0e\n\x06\x04\xb6\x01\x02\0\x01\x12\x04\xa9\x1f\x18&\n\x0e\n\
    \x06\x04\xb6\x01\x02\0\x03\x12\x04\xa9\x1f)*\n\r\n\x05\x04\xb6\x01\x02\
    \x01\x12\x04\xaa\x1f\x02\x20\n\x0e\n\x06\x04\xb6\x01\x02\x01\x06\x12\x04\
    \xaa\x1f\x02\x14\n\x0e\n\x06\x04\xb6\x01\x02\x01\x01\x12\x04\xaa\x1f\x15\
    \x1b\n\x0e\n\x06\x04\xb6\x01\x02\x01\x03\x12\x04\xaa\x1f\x1e\x1f\n\x0f\n\
    \x05\x04\xb6\x01\x04\0\x12\x06\xab\x1f\x02\xaf\x1f\x03\n\x0e\n\x06\x04\
    \xb6\x01\x04\0\x01\x12\x04\xab\x1f\x07\x19\n\x0f\n\x07\x04\xb6\x01\x04\0\
    \x02\0\x12\x04\xac\x1f\x04\x10\n\x10\n\x08\x04\xb6\x01\x04\0\x02\0\x01\
    \x12\x04\xac\x1f\x04\x0b\n\x10\n\x08\x04\xb6\x01\x04\0\x02\0\x02\x12\x04\
    \xac\x1f\x0e\x0f\nB\n\x07\x04\xb6\x01\x04\0\x02\x01\x12\x04\xae\x1f\x04\
    \x20\x1a1\x20We\x20will\x20randomly\x20split\x20inputs\x20into\x20the\
    \x20datasets\n\n\x10\n\x08\x04\xb6\x01\x04\0\x02\x01\x01\x12\x04\xae\x1f\
    \x04\x1b\n\x10\n\x08\x04\xb6\x01\x04\0\x02\x01\x02\x12\x04\xae\x1f\x1e\
    \x1f\n\r\n\x03\x04\xb7\x01\x12\x06\xb2\x1f\0\xba\x1f\x01\n\x0c\n\x04\x04\
    \xb7\x01\x01\x12\x04\xb2\x1f\x08\x14\n$\n\x05\x04\xb7\x01\x02\0\x12\x04\
    \xb4\x1f\x02\x16\x1a\x15\x20Expected\x20to\x20have\x20ID\n\n\x0e\n\x06\
    \x04\xb7\x01\x02\0\x06\x12\x04\xb4\x1f\x02\t\n\x0e\n\x06\x04\xb7\x01\x02\
    \0\x01\x12\x04\xb4\x1f\n\x11\n\x0e\n\x06\x04\xb7\x01\x02\0\x03\x12\x04\
    \xb4\x1f\x14\x15\n\x0f\n\x05\x04\xb7\x01\x08\0\x12\x06\xb5\x1f\x02\xb9\
    \x1f\x03\n\x0e\n\x06\x04\xb7\x01\x08\0\x01\x12\x04\xb5\x1f\x08\x13\nB\n\
    \x05\x04\xb7\x01\x02\x01\x12\x04\xb8\x1f\x04\x1a\x1a3\x20For\x20RANDOM_P\
    ERCENTAGE_SPLIT.\n\x20Values\x20from\x20(0,100]\n\n\x0e\n\x06\x04\xb7\
    \x01\x02\x01\x05\x12\x04\xb8\x1f\x04\n\n\x0e\n\x06\x04\xb7\x01\x02\x01\
    \x01\x12\x04\xb8\x1f\x0b\x15\n\x0e\n\x06\x04\xb7\x01\x02\x01\x03\x12\x04\
    \xb8\x1f\x18\x19\n\r\n\x03\x04\xb8\x01\x12\x06\xbd\x1f\0\xde\x1f\x01\n\
    \x0c\n\x04\x04\xb8\x01\x01\x12\x04\xbd\x1f\x08\x14\n\x0c\n\x04\x04\xb8\
    \x01\t\x12\x04\xbe\x1f\x02\x13\n\r\n\x05\x04\xb8\x01\t\0\x12\x04\xbe\x1f\
    \x0b\x0c\n\x0e\n\x06\x04\xb8\x01\t\0\x01\x12\x04\xbe\x1f\x0b\x0c\n\x0e\n\
    \x06\x04\xb8\x01\t\0\x02\x12\x04\xbe\x1f\x0b\x0c\n\r\n\x05\x04\xb8\x01\t\
    \x01\x12\x04\xbe\x1f\x0e\x0f\n\x0e\n\x06\x04\xb8\x01\t\x01\x01\x12\x04\
    \xbe\x1f\x0e\x0f\n\x0e\n\x06\x04\xb8\x01\t\x01\x02\x12\x04\xbe\x1f\x0e\
    \x0f\n\r\n\x05\x04\xb8\x01\t\x02\x12\x04\xbe\x1f\x11\x12\n\x0e\n\x06\x04\
    \xb8\x01\t\x02\x01\x12\x04\xbe\x1f\x11\x12\n\x0e\n\x06\x04\xb8\x01\t\x02\
    \x02\x12\x04\xbe\x1f\x11\x12\n\x1e\n\x05\x04\xb8\x01\x02\0\x12\x04\xc1\
    \x1f\x02\x10\x1a\x0f\x20id\x20of\x20the\x20job\n\n\x0e\n\x06\x04\xb8\x01\
    \x02\0\x05\x12\x04\xc1\x1f\x02\x08\n\x0e\n\x06\x04\xb8\x01\x02\0\x01\x12\
    \x04\xc1\x1f\t\x0b\n\x0e\n\x06\x04\xb8\x01\x02\0\x03\x12\x04\xc1\x1f\x0e\
    \x0f\ng\n\x05\x04\xb8\x01\x02\x01\x12\x04\xc4\x1f\x02\x1b\x1aX\x20If\x20\
    call\x20back\x20url\x20is\x20set,\x20we\x20will\x20send\x20a\x20Post\x20\
    request\x20to\x20this\x20endpoint\x20with\x20job\x20status.\n\n\x0e\n\
    \x06\x04\xb8\x01\x02\x01\x05\x12\x04\xc4\x1f\x02\x08\n\x0e\n\x06\x04\xb8\
    \x01\x02\x01\x01\x12\x04\xc4\x1f\t\x16\n\x0e\n\x06\x04\xb8\x01\x02\x01\
    \x03\x12\x04\xc4\x1f\x19\x1a\nS\n\x05\x04\xb8\x01\x02\x02\x12\x04\xc7\
    \x1f\x02\x15\x1aD\x20Personal\x20Access\x20Token\x20to\x20the\x20applica\
    tion\x20to\x20which\x20inputs\x20are\x20added\n\n\x0e\n\x06\x04\xb8\x01\
    \x02\x02\x05\x12\x04\xc7\x1f\x02\x08\n\x0e\n\x06\x04\xb8\x01\x02\x02\x01\
    \x12\x04\xc7\x1f\t\x10\n\x0e\n\x06\x04\xb8\x01\x02\x02\x03\x12\x04\xc7\
    \x1f\x13\x14\n=\n\x05\x04\xb8\x01\x02\x03\x12\x04\xca\x1f\x02$\x1a.\x20P\
    rogress\x20of\x20an\x20on-going\x20Input\x20Ingestion\x20task\n\n\x0e\n\
    \x06\x04\xb8\x01\x02\x03\x06\x12\x04\xca\x1f\x02\x16\n\x0e\n\x06\x04\xb8\
    \x01\x02\x03\x01\x12\x04\xca\x1f\x17\x1f\n\x0e\n\x06\x04\xb8\x01\x02\x03\
    \x03\x12\x04\xca\x1f\"#\n\x88\x01\n\x05\x04\xb8\x01\x02\x04\x12\x04\xcf\
    \x1f\x02+\x1ay\x20When\x20the\x20job\x20was\x20created.\n\x20The\x20form\
    at\x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"200\
    6-01-02T15:04:05.999999Z\".\n\n\x0e\n\x06\x04\xb8\x01\x02\x04\x06\x12\
    \x04\xcf\x1f\x02\x1b\n\x0e\n\x06\x04\xb8\x01\x02\x04\x01\x12\x04\xcf\x1f\
    \x1c&\n\x0e\n\x06\x04\xb8\x01\x02\x04\x03\x12\x04\xcf\x1f)*\n\x9a\x01\n\
    \x05\x04\xb8\x01\x02\x05\x12\x04\xd4\x1f\x02,\x1a\x8a\x01\x20Most\x20rec\
    ent\x20time\x20when\x20the\x20job\x20was\x20updated.\n\x20The\x20format\
    \x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-\
    01-02T15:04:05.999999Z\".\n\n\x0e\n\x06\x04\xb8\x01\x02\x05\x06\x12\x04\
    \xd4\x1f\x02\x1b\n\x0e\n\x06\x04\xb8\x01\x02\x05\x01\x12\x04\xd4\x1f\x1c\
    '\n\x0e\n\x06\x04\xb8\x01\x02\x05\x03\x12\x04\xd4\x1f*+\nL\n\x05\x04\xb8\
    \x01\x02\x06\x12\x04\xd7\x1f\x024\x1a=\x20Sub-jobs\x20that\x20extract\
    \x20inputs\x20from\x20the\x20cloud\x20and/or\x20archives\n\n\x0e\n\x06\
    \x04\xb8\x01\x02\x06\x04\x12\x04\xd7\x1f\x02\n\n\x0e\n\x06\x04\xb8\x01\
    \x02\x06\x06\x12\x04\xd7\x1f\x0b\x1e\n\x0e\n\x06\x04\xb8\x01\x02\x06\x01\
    \x12\x04\xd7\x1f\x1f.\n\x0e\n\x06\x04\xb8\x01\x02\x06\x03\x12\x04\xd7\
    \x1f13\n\x20\n\x05\x04\xb8\x01\x02\x07\x12\x04\xda\x1f\x02\x1f\x1a\x11\
    \x20Archive\x20uploads\n\n\x0e\n\x06\x04\xb8\x01\x02\x07\x04\x12\x04\xda\
    \x1f\x02\n\n\x0e\n\x06\x04\xb8\x01\x02\x07\x06\x12\x04\xda\x1f\x0b\x11\n\
    \x0e\n\x06\x04\xb8\x01\x02\x07\x01\x12\x04\xda\x1f\x12\x19\n\x0e\n\x06\
    \x04\xb8\x01\x02\x07\x03\x12\x04\xda\x1f\x1c\x1e\n\"\n\x05\x04\xb8\x01\
    \x02\x08\x12\x04\xdd\x1f\x02)\x1a\x13\x20Status\x20of\x20the\x20job\n\n\
    \x0e\n\x06\x04\xb8\x01\x02\x08\x06\x12\x04\xdd\x1f\x02\x1c\n\x0e\n\x06\
    \x04\xb8\x01\x02\x08\x01\x12\x04\xdd\x1f\x1d#\n\x0e\n\x06\x04\xb8\x01\
    \x02\x08\x03\x12\x04\xdd\x1f&(\n\r\n\x03\x04\xb9\x01\x12\x06\xe0\x1f\0\
    \xe5\x1f\x01\n\x0c\n\x04\x04\xb9\x01\x01\x12\x04\xe0\x1f\x08\x1c\n\r\n\
    \x05\x04\xb9\x01\x02\0\x12\x04\xe1\x1f\x02\x1b\n\x0e\n\x06\x04\xb9\x01\
    \x02\0\x05\x12\x04\xe1\x1f\x02\x08\n\x0e\n\x06\x04\xb9\x01\x02\0\x01\x12\
    \x04\xe1\x1f\t\x16\n\x0e\n\x06\x04\xb9\x01\x02\0\x03\x12\x04\xe1\x1f\x19\
    \x1a\n\r\n\x05\x04\xb9\x01\x02\x01\x12\x04\xe2\x1f\x02\x1f\n\x0e\n\x06\
    \x04\xb9\x01\x02\x01\x05\x12\x04\xe2\x1f\x02\x08\n\x0e\n\x06\x04\xb9\x01\
    \x02\x01\x01\x12\x04\xe2\x1f\t\x1a\n\x0e\n\x06\x04\xb9\x01\x02\x01\x03\
    \x12\x04\xe2\x1f\x1d\x1e\n\r\n\x05\x04\xb9\x01\x02\x02\x12\x04\xe3\x1f\
    \x02\x1b\n\x0e\n\x06\x04\xb9\x01\x02\x02\x05\x12\x04\xe3\x1f\x02\x08\n\
    \x0e\n\x06\x04\xb9\x01\x02\x02\x01\x12\x04\xe3\x1f\t\x16\n\x0e\n\x06\x04\
    \xb9\x01\x02\x02\x03\x12\x04\xe3\x1f\x19\x1a\n\r\n\x05\x04\xb9\x01\x02\
    \x03\x12\x04\xe4\x1f\x02\x1a\n\x0e\n\x06\x04\xb9\x01\x02\x03\x05\x12\x04\
    \xe4\x1f\x02\x08\n\x0e\n\x06\x04\xb9\x01\x02\x03\x01\x12\x04\xe4\x1f\t\
    \x15\n\x0e\n\x06\x04\xb9\x01\x02\x03\x03\x12\x04\xe4\x1f\x18\x19\n\r\n\
    \x03\x04\xba\x01\x12\x06\xe7\x1f\0\x85\x20\x01\n\x0c\n\x04\x04\xba\x01\
    \x01\x12\x04\xe7\x1f\x08\x0e\n\x1d\n\x05\x04\xba\x01\x02\0\x12\x04\xe9\
    \x1f\x02\x10\x1a\x0e\x20ID\x20of\x20upload\n\n\x0e\n\x06\x04\xba\x01\x02\
    \0\x05\x12\x04\xe9\x1f\x02\x08\n\x0e\n\x06\x04\xba\x01\x02\0\x01\x12\x04\
    \xe9\x1f\t\x0b\n\x0e\n\x06\x04\xba\x01\x02\0\x03\x12\x04\xe9\x1f\x0e\x0f\
    \n\x8b\x01\n\x05\x04\xba\x01\x02\x01\x12\x04\xee\x1f\x02+\x1a|\x20When\
    \x20the\x20upload\x20was\x20started.\n\x20The\x20format\x20is\x20https:/\
    /www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.99\
    9999Z\".\n\n\x0e\n\x06\x04\xba\x01\x02\x01\x06\x12\x04\xee\x1f\x02\x1b\n\
    \x0e\n\x06\x04\xba\x01\x02\x01\x01\x12\x04\xee\x1f\x1c&\n\x0e\n\x06\x04\
    \xba\x01\x02\x01\x03\x12\x04\xee\x1f)*\n\x9d\x01\n\x05\x04\xba\x01\x02\
    \x02\x12\x04\xf3\x1f\x02,\x1a\x8d\x01\x20Most\x20recent\x20time\x20when\
    \x20the\x20upload\x20was\x20updated.\n\x20The\x20format\x20is\x20https:/\
    /www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.99\
    9999Z\".\n\n\x0e\n\x06\x04\xba\x01\x02\x02\x06\x12\x04\xf3\x1f\x02\x1b\n\
    \x0e\n\x06\x04\xba\x01\x02\x02\x01\x12\x04\xf3\x1f\x1c'\n\x0e\n\x06\x04\
    \xba\x01\x02\x02\x03\x12\x04\xf3\x1f*+\n\x9a\x01\n\x05\x04\xba\x01\x02\
    \x03\x12\x04\xf8\x1f\x02+\x1a\x8a\x01\x20When\x20the\x20upload\x20will\
    \x20expire\x20and\x20be\x20deleted\n\x20The\x20format\x20is\x20https://w\
    ww.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.9999\
    99Z\".\n\n\x0e\n\x06\x04\xba\x01\x02\x03\x06\x12\x04\xf8\x1f\x02\x1b\n\
    \x0e\n\x06\x04\xba\x01\x02\x03\x01\x12\x04\xf8\x1f\x1c&\n\x0e\n\x06\x04\
    \xba\x01\x02\x03\x03\x12\x04\xf8\x1f)*\n%\n\x05\x04\xba\x01\x02\x04\x12\
    \x04\xfb\x1f\x02(\x1a\x16\x20Status\x20of\x20the\x20upload\n\n\x0e\n\x06\
    \x04\xba\x01\x02\x04\x06\x12\x04\xfb\x1f\x02\x1c\n\x0e\n\x06\x04\xba\x01\
    \x02\x04\x01\x12\x04\xfb\x1f\x1d#\n\x0e\n\x06\x04\xba\x01\x02\x04\x03\
    \x12\x04\xfb\x1f&'\n9\n\x05\x04\xba\x01\x02\x05\x12\x04\xfe\x1f\x02\x1a\
    \x1a*\x20name\x20of\x20uploaded\x20content\x20(e.g.\x20filename)\n\n\x0e\
    \n\x06\x04\xba\x01\x02\x05\x05\x12\x04\xfe\x1f\x02\x08\n\x0e\n\x06\x04\
    \xba\x01\x02\x05\x01\x12\x04\xfe\x1f\t\x15\n\x0e\n\x06\x04\xba\x01\x02\
    \x05\x03\x12\x04\xfe\x1f\x18\x19\n1\n\x05\x04\xba\x01\x02\x06\x12\x04\
    \x81\x20\x02\x1c\x1a\"\x20Total\x20size\x20of\x20the\x20upload\x20conten\
    t\n\n\x0e\n\x06\x04\xba\x01\x02\x06\x05\x12\x04\x81\x20\x02\x08\n\x0e\n\
    \x06\x04\xba\x01\x02\x06\x01\x12\x04\x81\x20\t\x17\n\x0e\n\x06\x04\xba\
    \x01\x02\x06\x03\x12\x04\x81\x20\x1a\x1b\n(\n\x05\x04\xba\x01\x02\x07\
    \x12\x04\x84\x20\x02\x19\x1a\x19\x20Url\x20of\x20uploaded\x20content\n\n\
    \x0e\n\x06\x04\xba\x01\x02\x07\x05\x12\x04\x84\x20\x02\x08\n\x0e\n\x06\
    \x04\xba\x01\x02\x07\x01\x12\x04\x84\x20\t\x14\n\x0e\n\x06\x04\xba\x01\
    \x02\x07\x03\x12\x04\x84\x20\x17\x18\n\r\n\x03\x04\xbb\x01\x12\x06\x87\
    \x20\0\x8b\x20\x01\n\x0c\n\x04\x04\xbb\x01\x01\x12\x04\x87\x20\x08\x19\n\
    \r\n\x05\x04\xbb\x01\x02\0\x12\x04\x88\x20\x02\x19\n\x0e\n\x06\x04\xbb\
    \x01\x02\0\x05\x12\x04\x88\x20\x02\x08\n\x0e\n\x06\x04\xbb\x01\x02\0\x01\
    \x12\x04\x88\x20\t\x14\n\x0e\n\x06\x04\xbb\x01\x02\0\x03\x12\x04\x88\x20\
    \x17\x18\n\r\n\x05\x04\xbb\x01\x02\x01\x12\x04\x89\x20\x02\x18\n\x0e\n\
    \x06\x04\xbb\x01\x02\x01\x05\x12\x04\x89\x20\x02\x07\n\x0e\n\x06\x04\xbb\
    \x01\x02\x01\x01\x12\x04\x89\x20\x08\x13\n\x0e\n\x06\x04\xbb\x01\x02\x01\
    \x03\x12\x04\x89\x20\x16\x17\n\r\n\x05\x04\xbb\x01\x02\x02\x12\x04\x8a\
    \x20\x02\x11\n\x0e\n\x06\x04\xbb\x01\x02\x02\x05\x12\x04\x8a\x20\x02\x07\
    \n\x0e\n\x06\x04\xbb\x01\x02\x02\x01\x12\x04\x8a\x20\x08\x0c\n\x0e\n\x06\
    \x04\xbb\x01\x02\x02\x03\x12\x04\x8a\x20\x0f\x10\n\xf7\x01\n\x03\x04\xbc\
    \x01\x12\x06\x90\x20\0\x95\x20\x01\x1a\xe7\x01\x20We\x20use\x20this\x20m\
    essage\x20to\x20communicate\x20with\x20Custom\x20Code\x20Operator\x20Bac\
    kend.\x20You\x20can\x20use\x20this\x20message\n\x20to\x20test\x20your\
    \x20custom\x20operator\x20code\x20locally.\n\x20We\x20expect\x20the\x20r\
    esponse\x20to\x20come\x20in\x20the\x20format\x20of\x20the\x20MultiOutput\
    Response\x20protobuf\x20message.\n\n\x0c\n\x04\x04\xbc\x01\x01\x12\x04\
    \x90\x20\x08!\n\r\n\x05\x04\xbc\x01\x02\0\x12\x04\x91\x20\x02\x1c\n\x0e\
    \n\x06\x04\xbc\x01\x02\0\x04\x12\x04\x91\x20\x02\n\n\x0e\n\x06\x04\xbc\
    \x01\x02\0\x06\x12\x04\x91\x20\x0b\x10\n\x0e\n\x06\x04\xbc\x01\x02\0\x01\
    \x12\x04\x91\x20\x11\x17\n\x0e\n\x06\x04\xbc\x01\x02\0\x03\x12\x04\x91\
    \x20\x1a\x1b\n+\n\x05\x04\xbc\x01\x02\x01\x12\x04\x94\x20\x02)\x1a\x1c\
    \x20support\x20arbitrary\x20metadata\n\n\x0e\n\x06\x04\xbc\x01\x02\x01\
    \x06\x12\x04\x94\x20\x02\x18\n\x0e\n\x06\x04\xbc\x01\x02\x01\x01\x12\x04\
    \x94\x20\x19!\n\x0e\n\x06\x04\xbc\x01\x02\x01\x03\x12\x04\x94\x20$(\n\r\
    \n\x03\x04\xbd\x01\x12\x06\x97\x20\0\xb2\x20\x01\n\x0c\n\x04\x04\xbd\x01\
    \x01\x12\x04\x97\x20\x08\x1b\n\r\n\x05\x04\xbd\x01\x02\0\x12\x04\x98\x20\
    \x02(\n\x0e\n\x06\x04\xbd\x01\x02\0\x06\x12\x04\x98\x20\x02\x1c\n\x0e\n\
    \x06\x04\xbd\x01\x02\0\x01\x12\x04\x98\x20\x1d#\n\x0e\n\x06\x04\xbd\x01\
    \x02\0\x03\x12\x04\x98\x20&'\n%\n\x05\x04\xbd\x01\x02\x01\x12\x04\x9b\
    \x20\x02\x10\x1a\x16\x20ID\x20of\x20extraction\x20job\n\n\x0e\n\x06\x04\
    \xbd\x01\x02\x01\x05\x12\x04\x9b\x20\x02\x08\n\x0e\n\x06\x04\xbd\x01\x02\
    \x01\x01\x12\x04\x9b\x20\t\x0b\n\x0e\n\x06\x04\xbd\x01\x02\x01\x03\x12\
    \x04\x9b\x20\x0e\x0f\n)\n\x05\x04\xbd\x01\x02\x02\x12\x04\x9e\x20\x02\
    \x11\x1a\x1a\x20Url\x20of\x20archive\x20or\x20bucket\n\n\x0e\n\x06\x04\
    \xbd\x01\x02\x02\x05\x12\x04\x9e\x20\x02\x08\n\x0e\n\x06\x04\xbd\x01\x02\
    \x02\x01\x12\x04\x9e\x20\t\x0c\n\x0e\n\x06\x04\xbd\x01\x02\x02\x03\x12\
    \x04\x9e\x20\x0f\x10\n+\n\x05\x04\xbd\x01\x02\x03\x12\x04\xa1\x20\x02+\
    \x1a\x1c\x20Progress\x20counts\x20of\x20the\x20job\n\n\x0e\n\x06\x04\xbd\
    \x01\x02\x03\x06\x12\x04\xa1\x20\x02\x1d\n\x0e\n\x06\x04\xbd\x01\x02\x03\
    \x01\x12\x04\xa1\x20\x1e&\n\x0e\n\x06\x04\xbd\x01\x02\x03\x03\x12\x04\
    \xa1\x20)*\n\x94\x01\n\x05\x04\xbd\x01\x02\x04\x12\x04\xa6\x20\x02+\x1a\
    \x84\x01\x20When\x20the\x20extraction\x20job\x20was\x20started.\n\x20The\
    \x20format\x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\
    \x20\"2006-01-02T15:04:05.999999Z\".\n\n\x0e\n\x06\x04\xbd\x01\x02\x04\
    \x06\x12\x04\xa6\x20\x02\x1b\n\x0e\n\x06\x04\xbd\x01\x02\x04\x01\x12\x04\
    \xa6\x20\x1c&\n\x0e\n\x06\x04\xbd\x01\x02\x04\x03\x12\x04\xa6\x20)*\n\
    \xa5\x01\n\x05\x04\xbd\x01\x02\x05\x12\x04\xab\x20\x02,\x1a\x95\x01\x20M\
    ost\x20recent\x20time\x20when\x20the\x20extraction\x20job\x20was\x20upda\
    ted.\n\x20The\x20format\x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\
    \x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\x0e\n\x06\x04\xbd\
    \x01\x02\x05\x06\x12\x04\xab\x20\x02\x1b\n\x0e\n\x06\x04\xbd\x01\x02\x05\
    \x01\x12\x04\xab\x20\x1c'\n\x0e\n\x06\x04\xbd\x01\x02\x05\x03\x12\x04\
    \xab\x20*+\n2\n\x05\x04\xbd\x01\x02\x06\x12\x04\xae\x20\x02=\x1a#\x20How\
    \x20to\x20handle\x20input\x20ID\x20conflicts.\n\n\x0e\n\x06\x04\xbd\x01\
    \x02\x06\x06\x12\x04\xae\x20\x02\x1b\n\x0e\n\x06\x04\xbd\x01\x02\x06\x01\
    \x12\x04\xae\x20\x1c8\n\x0e\n\x06\x04\xbd\x01\x02\x06\x03\x12\x04\xae\
    \x20;<\nM\n\x05\x04\xbd\x01\x02\x07\x12\x04\xb1\x20\x02\x1b\x1a>\x20Fiel\
    ds\x20set\x20in\x20the\x20template\x20are\x20added\x20to\x20all\x20gener\
    ated\x20inputs\n\n\x0e\n\x06\x04\xbd\x01\x02\x07\x06\x12\x04\xb1\x20\x02\
    \x07\n\x0e\n\x06\x04\xbd\x01\x02\x07\x01\x12\x04\xb1\x20\x08\x16\n\x0e\n\
    \x06\x04\xbd\x01\x02\x07\x03\x12\x04\xb1\x20\x19\x1a\n\r\n\x03\x04\xbe\
    \x01\x12\x06\xb4\x20\0\xc0\x20\x01\n\x0c\n\x04\x04\xbe\x01\x01\x12\x04\
    \xb4\x20\x08#\n\x0c\n\x04\x04\xbe\x01\t\x12\x04\xb5\x20\x02\r\n\r\n\x05\
    \x04\xbe\x01\t\0\x12\x04\xb5\x20\x0b\x0c\n\x0e\n\x06\x04\xbe\x01\t\0\x01\
    \x12\x04\xb5\x20\x0b\x0c\n\x0e\n\x06\x04\xbe\x01\t\0\x02\x12\x04\xb5\x20\
    \x0b\x0c\n\r\n\x05\x04\xbe\x01\x02\0\x12\x04\xb7\x20\x02\x20\n\x0e\n\x06\
    \x04\xbe\x01\x02\0\x05\x12\x04\xb7\x20\x02\x08\n\x0e\n\x06\x04\xbe\x01\
    \x02\0\x01\x12\x04\xb7\x20\t\x1b\n\x0e\n\x06\x04\xbe\x01\x02\0\x03\x12\
    \x04\xb7\x20\x1e\x1f\n\r\n\x05\x04\xbe\x01\x02\x01\x12\x04\xb8\x20\x02\
    \x20\n\x0e\n\x06\x04\xbe\x01\x02\x01\x05\x12\x04\xb8\x20\x02\x08\n\x0e\n\
    \x06\x04\xbe\x01\x02\x01\x01\x12\x04\xb8\x20\t\x1b\n\x0e\n\x06\x04\xbe\
    \x01\x02\x01\x03\x12\x04\xb8\x20\x1e\x1f\n\r\n\x05\x04\xbe\x01\x02\x02\
    \x12\x04\xb9\x20\x02\x20\n\x0e\n\x06\x04\xbe\x01\x02\x02\x05\x12\x04\xb9\
    \x20\x02\x08\n\x0e\n\x06\x04\xbe\x01\x02\x02\x01\x12\x04\xb9\x20\t\x1b\n\
    \x0e\n\x06\x04\xbe\x01\x02\x02\x03\x12\x04\xb9\x20\x1e\x1f\n\r\n\x05\x04\
    \xbe\x01\x02\x03\x12\x04\xba\x20\x02\x1f\n\x0e\n\x06\x04\xbe\x01\x02\x03\
    \x05\x12\x04\xba\x20\x02\x08\n\x0e\n\x06\x04\xbe\x01\x02\x03\x01\x12\x04\
    \xba\x20\t\x1a\n\x0e\n\x06\x04\xbe\x01\x02\x03\x03\x12\x04\xba\x20\x1d\
    \x1e\n\r\n\x05\x04\xbe\x01\x02\x04\x12\x04\xbc\x20\x02$\n\x0e\n\x06\x04\
    \xbe\x01\x02\x04\x05\x12\x04\xbc\x20\x02\x08\n\x0e\n\x06\x04\xbe\x01\x02\
    \x04\x01\x12\x04\xbc\x20\t\x1f\n\x0e\n\x06\x04\xbe\x01\x02\x04\x03\x12\
    \x04\xbc\x20\"#\n\r\n\x05\x04\xbe\x01\x02\x05\x12\x04\xbd\x20\x02(\n\x0e\
    \n\x06\x04\xbe\x01\x02\x05\x05\x12\x04\xbd\x20\x02\x08\n\x0e\n\x06\x04\
    \xbe\x01\x02\x05\x01\x12\x04\xbd\x20\t#\n\x0e\n\x06\x04\xbe\x01\x02\x05\
    \x03\x12\x04\xbd\x20&'\n\r\n\x05\x04\xbe\x01\x02\x06\x12\x04\xbe\x20\x02\
    &\n\x0e\n\x06\x04\xbe\x01\x02\x06\x05\x12\x04\xbe\x20\x02\x08\n\x0e\n\
    \x06\x04\xbe\x01\x02\x06\x01\x12\x04\xbe\x20\t!\n\x0e\n\x06\x04\xbe\x01\
    \x02\x06\x03\x12\x04\xbe\x20$%\n\r\n\x05\x04\xbe\x01\x02\x07\x12\x04\xbf\
    \x20\x02#\n\x0e\n\x06\x04\xbe\x01\x02\x07\x05\x12\x04\xbf\x20\x02\x08\n\
    \x0e\n\x06\x04\xbe\x01\x02\x07\x01\x12\x04\xbf\x20\t\x1e\n\x0e\n\x06\x04\
    \xbe\x01\x02\x07\x03\x12\x04\xbf\x20!\"\n\r\n\x03\x04\xbf\x01\x12\x06\
    \xc2\x20\0\xd0\x20\x01\n\x0c\n\x04\x04\xbf\x01\x01\x12\x04\xc2\x20\x08\
    \x18\n\xf0\x01\n\x05\x04\xbf\x01\x02\0\x12\x04\xc7\x20\x02\x1f\x1a\xe0\
    \x01\x20Collect\x20statistics\x20about\x20created\x20inputs\x20in\x20job\
    \x20with\x20given\x20ID.\n\x20On\x20Post\x20call:\n\x20*\x20If\x20job\
    \x20ID\x20is\x20empty,\x20then\x20job\x20is\x20automatically\x20created\
    \x20with\x20random\x20ID.\n\x20*\x20If\x20job\x20ID\x20is\x20non-empty,\
    \x20then\x20a\x20new\x20job\x20will\x20be\x20created\x20with\x20given\
    \x20ID.\n\n\x0e\n\x06\x04\xbf\x01\x02\0\x05\x12\x04\xc7\x20\x02\x08\n\
    \x0e\n\x06\x04\xbf\x01\x02\0\x01\x12\x04\xc7\x20\t\x1a\n\x0e\n\x06\x04\
    \xbf\x01\x02\0\x03\x12\x04\xc7\x20\x1d\x1e\n\r\n\x05\x04\xbf\x01\x02\x01\
    \x12\x04\xc9\x20\x02\x18\n\x0e\n\x06\x04\xbf\x01\x02\x01\x06\x12\x04\xc9\
    \x20\x02\x0f\n\x0e\n\x06\x04\xbf\x01\x02\x01\x01\x12\x04\xc9\x20\x10\x13\
    \n\x0e\n\x06\x04\xbf\x01\x02\x01\x03\x12\x04\xc9\x20\x16\x17\n2\n\x05\
    \x04\xbf\x01\x02\x02\x12\x04\xcc\x20\x02=\x1a#\x20How\x20to\x20handle\
    \x20input\x20ID\x20conflicts.\n\n\x0e\n\x06\x04\xbf\x01\x02\x02\x06\x12\
    \x04\xcc\x20\x02\x1b\n\x0e\n\x06\x04\xbf\x01\x02\x02\x01\x12\x04\xcc\x20\
    \x1c8\n\x0e\n\x06\x04\xbf\x01\x02\x02\x03\x12\x04\xcc\x20;<\nV\n\x05\x04\
    \xbf\x01\x02\x03\x12\x04\xcf\x20\x02\x1b\x1aG\x20Fields\x20set\x20in\x20\
    the\x20template\x20will\x20also\x20be\x20added\x20to\x20all\x20generated\
    \x20inputs\n\n\x0e\n\x06\x04\xbf\x01\x02\x03\x06\x12\x04\xcf\x20\x02\x07\
    \n\x0e\n\x06\x04\xbf\x01\x02\x03\x01\x12\x04\xcf\x20\x08\x16\n\x0e\n\x06\
    \x04\xbf\x01\x02\x03\x03\x12\x04\xcf\x20\x19\x1a\n\r\n\x03\x04\xc0\x01\
    \x12\x06\xd2\x20\0\xd8\x20\x01\n\x0c\n\x04\x04\xc0\x01\x01\x12\x04\xd2\
    \x20\x08\x15\nO\n\x05\x04\xc0\x01\x02\0\x12\x04\xd4\x20\x02\x11\x1a@\x20\
    Supported\x20providers\x20are\x20AWS\x20S3,\x20Azure\x20blob,\x20GCP\x20\
    cloud\x20storage.\n\n\x0e\n\x06\x04\xc0\x01\x02\0\x05\x12\x04\xd4\x20\
    \x02\x08\n\x0e\n\x06\x04\xc0\x01\x02\0\x01\x12\x04\xd4\x20\t\x0c\n\x0e\n\
    \x06\x04\xc0\x01\x02\0\x03\x12\x04\xd4\x20\x0f\x10\nH\n\x05\x04\xc0\x01\
    \x02\x01\x12\x04\xd7\x20\x02(\x1a9\x20Credentials\x20that\x20would\x20al\
    low\x20access\x20to\x20the\x20provided\x20url\n\n\x0e\n\x06\x04\xc0\x01\
    \x02\x01\x06\x12\x04\xd7\x20\x02\x17\n\x0e\n\x06\x04\xc0\x01\x02\x01\x01\
    \x12\x04\xd7\x20\x18#\n\x0e\n\x06\x04\xc0\x01\x02\x01\x03\x12\x04\xd7\
    \x20&'\n\r\n\x03\x04\xc1\x01\x12\x06\xda\x20\0\xe4\x20\x01\n\x0c\n\x04\
    \x04\xc1\x01\x01\x12\x04\xda\x20\x08\x1d\n\x0c\n\x04\x04\xc1\x01\t\x12\
    \x04\xdb\x20\x02\r\n\r\n\x05\x04\xc1\x01\t\0\x12\x04\xdb\x20\x0b\x0c\n\
    \x0e\n\x06\x04\xc1\x01\t\0\x01\x12\x04\xdb\x20\x0b\x0c\n\x0e\n\x06\x04\
    \xc1\x01\t\0\x02\x12\x04\xdb\x20\x0b\x0c\n\x0f\n\x05\x04\xc1\x01\x08\0\
    \x12\x06\xdc\x20\x02\xe3\x20\x03\n\x0e\n\x06\x04\xc1\x01\x08\0\x01\x12\
    \x04\xdc\x20\x08\x13\n7\n\x05\x04\xc1\x01\x02\0\x12\x04\xde\x20\x04\x1a\
    \x1a(\x20AWS\x20S3\x20credentials\x20for\x20authentication.\n\n\x0e\n\
    \x06\x04\xc1\x01\x02\0\x06\x12\x04\xde\x20\x04\x0c\n\x0e\n\x06\x04\xc1\
    \x01\x02\0\x01\x12\x04\xde\x20\r\x15\n\x0e\n\x06\x04\xc1\x01\x02\0\x03\
    \x12\x04\xde\x20\x18\x19\nn\n\x05\x04\xc1\x01\x02\x01\x12\x04\xe0\x20\
    \x04\x18\x1a_\x20GCP\x20Cloud\x20Storage\x20uses\x20service\x20account\
    \x20key\x20data(creds.json)\x20as\x20Byte\x20array\x20for\x20authenticat\
    ion.\n\n\x0e\n\x06\x04\xc1\x01\x02\x01\x05\x12\x04\xe0\x20\x04\t\n\x0e\n\
    \x06\x04\xc1\x01\x02\x01\x01\x12\x04\xe0\x20\n\x13\n\x0e\n\x06\x04\xc1\
    \x01\x02\x01\x03\x12\x04\xe0\x20\x16\x17\n;\n\x05\x04\xc1\x01\x02\x02\
    \x12\x04\xe2\x20\x04(\x1a,\x20Azure\x20Blob\x20credentials\x20for\x20aut\
    hentication.\n\n\x0e\n\x06\x04\xc1\x01\x02\x02\x06\x12\x04\xe2\x20\x04\
    \x12\n\x0e\n\x06\x04\xc1\x01\x02\x02\x01\x12\x04\xe2\x20\x13#\n\x0e\n\
    \x06\x04\xc1\x01\x02\x02\x03\x12\x04\xe2\x20&'\n,\n\x03\x04\xc2\x01\x12\
    \x06\xe7\x20\0\xee\x20\x01\x1a\x1d\x20AWS\x20S3\x20storage\x20credential\
    s.\n\n\x0c\n\x04\x04\xc2\x01\x01\x12\x04\xe7\x20\x08\x10\n\x0c\n\x04\x04\
    \xc2\x01\t\x12\x04\xe8\x20\x02\r\n\r\n\x05\x04\xc2\x01\t\0\x12\x04\xe8\
    \x20\x0b\x0c\n\x0e\n\x06\x04\xc2\x01\t\0\x01\x12\x04\xe8\x20\x0b\x0c\n\
    \x0e\n\x06\x04\xc2\x01\t\0\x02\x12\x04\xe8\x20\x0b\x0c\n\r\n\x05\x04\xc2\
    \x01\x02\0\x12\x04\xea\x20\x02\x14\n\x0e\n\x06\x04\xc2\x01\x02\0\x05\x12\
    \x04\xea\x20\x02\x08\n\x0e\n\x06\x04\xc2\x01\x02\0\x01\x12\x04\xea\x20\t\
    \x0f\n\x0e\n\x06\x04\xc2\x01\x02\0\x03\x12\x04\xea\x20\x12\x13\n\r\n\x05\
    \x04\xc2\x01\x02\x01\x12\x04\xeb\x20\x02\x10\n\x0e\n\x06\x04\xc2\x01\x02\
    \x01\x05\x12\x04\xeb\x20\x02\x08\n\x0e\n\x06\x04\xc2\x01\x02\x01\x01\x12\
    \x04\xeb\x20\t\x0b\n\x0e\n\x06\x04\xc2\x01\x02\x01\x03\x12\x04\xeb\x20\
    \x0e\x0f\n\r\n\x05\x04\xc2\x01\x02\x02\x12\x04\xec\x20\x02\x14\n\x0e\n\
    \x06\x04\xc2\x01\x02\x02\x05\x12\x04\xec\x20\x02\x08\n\x0e\n\x06\x04\xc2\
    \x01\x02\x02\x01\x12\x04\xec\x20\t\x0f\n\x0e\n\x06\x04\xc2\x01\x02\x02\
    \x03\x12\x04\xec\x20\x12\x13\n\r\n\x05\x04\xc2\x01\x02\x03\x12\x04\xed\
    \x20\x02\x13\n\x0e\n\x06\x04\xc2\x01\x02\x03\x05\x12\x04\xed\x20\x02\x08\
    \n\x0e\n\x06\x04\xc2\x01\x02\x03\x01\x12\x04\xed\x20\t\x0e\n\x0e\n\x06\
    \x04\xc2\x01\x02\x03\x03\x12\x04\xed\x20\x11\x12\n0\n\x03\x04\xc3\x01\
    \x12\x06\xf1\x20\0\xf4\x20\x01\x1a!\x20Azure\x20Blob\x20storage\x20crede\
    ntials.\n\n\x0c\n\x04\x04\xc3\x01\x01\x12\x04\xf1\x20\x08\x16\n\r\n\x05\
    \x04\xc3\x01\x02\0\x12\x04\xf2\x20\x02\x1a\n\x0e\n\x06\x04\xc3\x01\x02\0\
    \x05\x12\x04\xf2\x20\x02\x08\n\x0e\n\x06\x04\xc3\x01\x02\0\x01\x12\x04\
    \xf2\x20\t\x15\n\x0e\n\x06\x04\xc3\x01\x02\0\x03\x12\x04\xf2\x20\x18\x19\
    \n\r\n\x05\x04\xc3\x01\x02\x01\x12\x04\xf3\x20\x02\x19\n\x0e\n\x06\x04\
    \xc3\x01\x02\x01\x05\x12\x04\xf3\x20\x02\x08\n\x0e\n\x06\x04\xc3\x01\x02\
    \x01\x01\x12\x04\xf3\x20\t\x14\n\x0e\n\x06\x04\xc3\x01\x02\x01\x03\x12\
    \x04\xf3\x20\x17\x18\n\r\n\x03\x04\xc4\x01\x12\x06\xf6\x20\0\x86!\x01\n\
    \x0c\n\x04\x04\xc4\x01\x01\x12\x04\xf6\x20\x08\x14\n\xe1\x01\n\x05\x04\
    \xc4\x01\x02\0\x12\x04\xfa\x20\x02\x1f\x1a\xd1\x01\x20Collect\x20statist\
    ics\x20about\x20created\x20inputs\x20in\x20job\x20with\x20given\x20ID.\n\
    \x20*\x20If\x20job\x20ID\x20is\x20empty,\x20then\x20job\x20is\x20automat\
    ically\x20created\x20with\x20random\x20ID.\n\x20*\x20If\x20job\x20ID\x20\
    is\x20non-empty,\x20then\x20a\x20new\x20job\x20will\x20be\x20created\x20\
    with\x20given\x20ID.\n\n\x0e\n\x06\x04\xc4\x01\x02\0\x05\x12\x04\xfa\x20\
    \x02\x08\n\x0e\n\x06\x04\xc4\x01\x02\0\x01\x12\x04\xfa\x20\t\x1a\n\x0e\n\
    \x06\x04\xc4\x01\x02\0\x03\x12\x04\xfa\x20\x1d\x1e\nS\n\x05\x04\xc4\x01\
    \x02\x01\x12\x04\xfd\x20\x02\x15\x1aD\x20Personal\x20Access\x20Token\x20\
    to\x20the\x20application\x20to\x20which\x20inputs\x20are\x20added\n\n\
    \x0e\n\x06\x04\xc4\x01\x02\x01\x05\x12\x04\xfd\x20\x02\x08\n\x0e\n\x06\
    \x04\xc4\x01\x02\x01\x01\x12\x04\xfd\x20\t\x10\n\x0e\n\x06\x04\xc4\x01\
    \x02\x01\x03\x12\x04\xfd\x20\x13\x14\n\r\n\x05\x04\xc4\x01\x02\x02\x12\
    \x04\xff\x20\x02\x14\n\x0e\n\x06\x04\xc4\x01\x02\x02\x06\x12\x04\xff\x20\
    \x02\x08\n\x0e\n\x06\x04\xc4\x01\x02\x02\x01\x12\x04\xff\x20\t\x0f\n\x0e\
    \n\x06\x04\xc4\x01\x02\x02\x03\x12\x04\xff\x20\x12\x13\n2\n\x05\x04\xc4\
    \x01\x02\x03\x12\x04\x82!\x02=\x1a#\x20How\x20to\x20handle\x20input\x20I\
    D\x20conflicts.\n\n\x0e\n\x06\x04\xc4\x01\x02\x03\x06\x12\x04\x82!\x02\
    \x1b\n\x0e\n\x06\x04\xc4\x01\x02\x03\x01\x12\x04\x82!\x1c8\n\x0e\n\x06\
    \x04\xc4\x01\x02\x03\x03\x12\x04\x82!;<\nV\n\x05\x04\xc4\x01\x02\x04\x12\
    \x04\x85!\x02\x1b\x1aG\x20Fields\x20set\x20in\x20the\x20template\x20will\
    \x20also\x20be\x20added\x20to\x20all\x20generated\x20inputs\n\n\x0e\n\
    \x06\x04\xc4\x01\x02\x04\x06\x12\x04\x85!\x02\x07\n\x0e\n\x06\x04\xc4\
    \x01\x02\x04\x01\x12\x04\x85!\x08\x16\n\x0e\n\x06\x04\xc4\x01\x02\x04\
    \x03\x12\x04\x85!\x19\x1a\n\x0c\n\x02\x05\x10\x12\x06\x87!\0\x8c!\x01\n\
    \x0b\n\x03\x05\x10\x01\x12\x04\x87!\x05\x1e\n\x20\n\x04\x05\x10\x02\0\
    \x12\x04\x88!\x02+\"\x12\x20Defaults\x20to\x20SKIP\n\n\r\n\x05\x05\x10\
    \x02\0\x01\x12\x04\x88!\x02&\n\r\n\x05\x05\x10\x02\0\x02\x12\x04\x88!)*\
    \nH\n\x04\x05\x10\x02\x01\x12\x04\x8a!\x02\x0b\":\x20Mark\x20duplicate\
    \x20inputs\x20as\x20error\x20and\x20skip\x20processing\x20them.\n\n\r\n\
    \x05\x05\x10\x02\x01\x01\x12\x04\x8a!\x02\x06\n\r\n\x05\x05\x10\x02\x01\
    \x02\x12\x04\x8a!\t\n\n\xc2\x01\n\x04\x05\x10\x02\x02\x12\x04\x8b!\x02\r\
    \"\xb3\x01\x20Add\x20a\x20suffix\x20to\x20inputs\x20with\x20conflicting\
    \x20IDs.\x20Attempts\x20numeric\x20suffixes\x20\"-1\"\x20to\x20\"-9\"\
    \x20and\x20then\x20a\x20randomized\x20suffix.\x20Identical\x20ID's\x20in\
    \x20the\x20same\x20request\x20are\x20still\x20treated\x20as\x20errors.\n\
    \n\r\n\x05\x05\x10\x02\x02\x01\x12\x04\x8b!\x02\x08\n\r\n\x05\x05\x10\
    \x02\x02\x02\x12\x04\x8b!\x0b\x0c\n\r\n\x03\x04\xc5\x01\x12\x06\x8f!\0\
    \xa2!\x01\n\x0c\n\x04\x04\xc5\x01\x01\x12\x04\x8f!\x08\x16\n%\n\x05\x04\
    \xc5\x01\x02\0\x12\x04\x91!\x02\x10\x1a\x16\x20original\x20resource\x20i\
    d\n\n\x0e\n\x06\x04\xc5\x01\x02\0\x05\x12\x04\x91!\x02\x08\n\x0e\n\x06\
    \x04\xc5\x01\x02\0\x01\x12\x04\x91!\t\x0b\n\x0e\n\x06\x04\xc5\x01\x02\0\
    \x03\x12\x04\x91!\x0e\x0f\n)\n\x05\x04\xc5\x01\x02\x01\x12\x04\x94!\x02\
    \x14\x1a\x1a\x20original\x20resource\x20app\x20id\n\n\x0e\n\x06\x04\xc5\
    \x01\x02\x01\x05\x12\x04\x94!\x02\x08\n\x0e\n\x06\x04\xc5\x01\x02\x01\
    \x01\x12\x04\x94!\t\x0f\n\x0e\n\x06\x04\xc5\x01\x02\x01\x03\x12\x04\x94!\
    \x12\x13\n*\n\x05\x04\xc5\x01\x02\x02\x12\x04\x97!\x02\x15\x1a\x1b\x20or\
    iginal\x20resource\x20user\x20id\n\n\x0e\n\x06\x04\xc5\x01\x02\x02\x05\
    \x12\x04\x97!\x02\x08\n\x0e\n\x06\x04\xc5\x01\x02\x02\x01\x12\x04\x97!\t\
    \x10\n\x0e\n\x06\x04\xc5\x01\x02\x02\x03\x12\x04\x97!\x13\x14\n\x0f\n\
    \x05\x04\xc5\x01\x04\0\x12\x06\x99!\x02\x9f!\x03\n\x0e\n\x06\x04\xc5\x01\
    \x04\0\x01\x12\x04\x99!\x07\x13\n\x0f\n\x07\x04\xc5\x01\x04\0\x02\0\x12\
    \x04\x9a!\x04\x10\n\x10\n\x08\x04\xc5\x01\x04\0\x02\0\x01\x12\x04\x9a!\
    \x04\x0b\n\x10\n\x08\x04\xc5\x01\x04\0\x02\0\x02\x12\x04\x9a!\x0e\x0f\n\
    \x0f\n\x07\x04\xc5\x01\x04\0\x02\x01\x12\x04\x9b!\x04\x0e\n\x10\n\x08\
    \x04\xc5\x01\x04\0\x02\x01\x01\x12\x04\x9b!\x04\t\n\x10\n\x08\x04\xc5\
    \x01\x04\0\x02\x01\x02\x12\x04\x9b!\x0c\r\n\x0f\n\x07\x04\xc5\x01\x04\0\
    \x02\x02\x12\x04\x9c!\x04\x11\n\x10\n\x08\x04\xc5\x01\x04\0\x02\x02\x01\
    \x12\x04\x9c!\x04\x0c\n\x10\n\x08\x04\xc5\x01\x04\0\x02\x02\x02\x12\x04\
    \x9c!\x0f\x10\n\x0f\n\x07\x04\xc5\x01\x04\0\x02\x03\x12\x04\x9d!\x04\x10\
    \n\x10\n\x08\x04\xc5\x01\x04\0\x02\x03\x01\x12\x04\x9d!\x04\x0b\n\x10\n\
    \x08\x04\xc5\x01\x04\0\x02\x03\x02\x12\x04\x9d!\x0e\x0f\n\x0f\n\x07\x04\
    \xc5\x01\x04\0\x02\x04\x12\x04\x9e!\x04\x0f\n\x10\n\x08\x04\xc5\x01\x04\
    \0\x02\x04\x01\x12\x04\x9e!\x04\n\n\x10\n\x08\x04\xc5\x01\x04\0\x02\x04\
    \x02\x12\x04\x9e!\r\x0e\n\x1f\n\x05\x04\xc5\x01\x02\x03\x12\x04\xa1!\x02\
    !\x1a\x10\x20resource\x20type.\n\n\x0e\n\x06\x04\xc5\x01\x02\x03\x06\x12\
    \x04\xa1!\x02\x0e\n\x0e\n\x06\x04\xc5\x01\x02\x03\x01\x12\x04\xa1!\x0f\
    \x1c\n\x0e\n\x06\x04\xc5\x01\x02\x03\x03\x12\x04\xa1!\x1f\x20\n\xb7\x02\
    \n\x03\x04\xc6\x01\x12\x06\xad!\0\xdf!\x01\x1aR\x20A\x20worker\x20for\
    \x20compute\x20within\x20a\x20nodepool\x20of\x20instances.\n\x20This\x20\
    asks\x20the\x20API\x20for\x20work\n2\xd3\x01\x20Moving\x20the\x20runner\
    \x20label\x20matching\x20into\x20it's\x20own\x20object\x20so\x20that\x20\
    it\x20can\x20be\x20used\n\x20next\x20to\x20other\x20resource\x20types\
    \x20that\x20a\x20Runner\x20might\x20match\x20work\x20on.\n\x20message\
    \x20RunnerLabels\x20{\x20//\x20FUTURE\n\x20\x20\x20repeated\x20string\
    \x20labels\x20=\x201;\n\x20}\n\n\x0c\n\x04\x04\xc6\x01\x01\x12\x04\xad!\
    \x08\x0e\nr\n\x05\x04\xc6\x01\x02\0\x12\x04\xb0!\x02\x10\x1ac\x20A\x20un\
    ique\x20ID\x20for\x20this\x20app\x20module.\n\x20This\x20is\x20a\x20UUID\
    \x20since\x20runners\x20can\x20be\x20automatically\x20orchestrated.\n\n\
    \x0e\n\x06\x04\xc6\x01\x02\0\x05\x12\x04\xb0!\x02\x08\n\x0e\n\x06\x04\
    \xc6\x01\x02\0\x01\x12\x04\xb0!\t\x0b\n\x0e\n\x06\x04\xc6\x01\x02\0\x03\
    \x12\x04\xb0!\x0e\x0f\nX\n\x05\x04\xc6\x01\x02\x01\x12\x04\xb2!\x02\x19\
    \x1aI\x20A\x20short\x20description\x20for\x20this\x20app\x20module\x20to\
    \x20be\x20used\x20in\x20grids\x20of\x20modules.\n\n\x0e\n\x06\x04\xc6\
    \x01\x02\x01\x05\x12\x04\xb2!\x02\x08\n\x0e\n\x06\x04\xc6\x01\x02\x01\
    \x01\x12\x04\xb2!\t\x14\n\x0e\n\x06\x04\xc6\x01\x02\x01\x03\x12\x04\xb2!\
    \x17\x18\n1\n\x05\x04\xc6\x01\x02\x02\x12\x04\xb4!\x02+\x1a\"\x20When\
    \x20the\x20app\x20module\x20was\x20created.\n\n\x0e\n\x06\x04\xc6\x01\
    \x02\x02\x06\x12\x04\xb4!\x02\x1b\n\x0e\n\x06\x04\xc6\x01\x02\x02\x01\
    \x12\x04\xb4!\x1c&\n\x0e\n\x06\x04\xc6\x01\x02\x02\x03\x12\x04\xb4!)*\n7\
    \n\x05\x04\xc6\x01\x02\x03\x12\x04\xb6!\x02,\x1a(\x20When\x20the\x20app\
    \x20module\x20was\x20last\x20modified.\n\n\x0e\n\x06\x04\xc6\x01\x02\x03\
    \x06\x12\x04\xb6!\x02\x1b\n\x0e\n\x06\x04\xc6\x01\x02\x03\x01\x12\x04\
    \xb6!\x1c'\n\x0e\n\x06\x04\xc6\x01\x02\x03\x03\x12\x04\xb6!*+\n\xba\x01\
    \n\x05\x04\xc6\x01\x02\x04\x12\x04\xbb!\x02&\x1a\xaa\x01\x20To\x20handle\
    \x20arbitrary\x20json\x20metadata\x20you\x20can\x20use\x20a\x20struct\
    \x20field:\n\x20https://github.com/google/protobuf/blob/master/src/googl\
    e/protobuf/struct.proto\n\x20This\x20is\x20an\x20optional\x20arg.\n\n\
    \x0e\n\x06\x04\xc6\x01\x02\x04\x06\x12\x04\xbb!\x02\x18\n\x0e\n\x06\x04\
    \xc6\x01\x02\x04\x01\x12\x04\xbb!\x19!\n\x0e\n\x06\x04\xc6\x01\x02\x04\
    \x03\x12\x04\xbb!$%\nO\n\x05\x04\xc6\x01\x02\x05\x12\x04\xbe!\x02\x15\
    \x1a@\x20The\x20owner\x20of\x20the\x20runner.\x20Runners\x20belong\x20to\
    \x20a\x20user/org\x20account.\n\n\x0e\n\x06\x04\xc6\x01\x02\x05\x05\x12\
    \x04\xbe!\x02\x08\n\x0e\n\x06\x04\xc6\x01\x02\x05\x01\x12\x04\xbe!\t\x10\
    \n\x0e\n\x06\x04\xc6\x01\x02\x05\x03\x12\x04\xbe!\x13\x14\n7\n\x05\x04\
    \xc6\x01\x02\x06\x12\x04\xc1!\x021\x1a(\x20Labels\x20to\x20match\x20in\
    \x20order\x20to\x20find\x20work.\n\n\x0e\n\x06\x04\xc6\x01\x02\x06\x04\
    \x12\x04\xc1!\x02\n\n\x0e\n\x06\x04\xc6\x01\x02\x06\x05\x12\x04\xc1!\x0b\
    \x11\n\x0e\n\x06\x04\xc6\x01\x02\x06\x01\x12\x04\xc1!\x12\x18\n\x0e\n\
    \x06\x04\xc6\x01\x02\x06\x03\x12\x04\xc1!\x1b\x1c\n\x0e\n\x06\x04\xc6\
    \x01\x02\x06\x08\x12\x04\xc1!\x1d0\n\x0f\n\x07\x04\xc6\x01\x02\x06\x08\
    \x03\x12\x04\xc1!\x1e/\n\xdf\x01\n\x05\x04\xc6\x01\x08\0\x12\x06\xc7!\
    \x02\xcf!\x03\x1a\xcd\x01\x20RunnerObject\n\x20Instead\x20of\x20just\x20\
    matching\x20on\x20labels\x20we\x20might\x20want\x20to\x20have\x20more\
    \x20explicit\x20matching\x20of\x20what\n\x20work\x20this\x20runner\x20is\
    \x20looking\x20for.\n\x20The\x20thing\x20that\x20the\x20autoscaling\x20c\
    nfig\x20applies\x20to\x20for\x20this\x20nodepool.\n\n\x0e\n\x06\x04\xc6\
    \x01\x08\0\x01\x12\x04\xc7!\x08\x0e\n<\n\x05\x04\xc6\x01\x02\x07\x12\x04\
    \xc9!\x04\x14\x1a-\x20Model:\x20match\x20work\x20to\x20only\x20a\x20spec\
    ific\x20model.\n\n\x0e\n\x06\x04\xc6\x01\x02\x07\x06\x12\x04\xc9!\x04\t\
    \n\x0e\n\x06\x04\xc6\x01\x02\x07\x01\x12\x04\xc9!\n\x0f\n\x0e\n\x06\x04\
    \xc6\x01\x02\x07\x03\x12\x04\xc9!\x12\x13\n\x89\x02\n\x05\x04\xc6\x01\
    \x02\x08\x12\x04\xcb!\x04\x1b\x1a3\x20Workflow:\x20match\x20work\x20to\
    \x20only\x20a\x20specific\x20workflow.\n\"\xc4\x01\x20We\x20could\x20als\
    o\x20support\x20matching\x20by\x20labels\x20here\x20for\x20future\x20\"j\
    ob\"\x20like\x20functionality\x20where\n\x20the\x20item\x20itself\x20ful\
    ly\x20defines\x20the\x20work\x20that\x20needs\x20to\x20be\x20done.\n\x20\
    RunnerLabels\x20runner_labels\x20=\x2011;\x20//\x20FUTURE\n\n\x0e\n\x06\
    \x04\xc6\x01\x02\x08\x06\x12\x04\xcb!\x04\x0c\n\x0e\n\x06\x04\xc6\x01\
    \x02\x08\x01\x12\x04\xcb!\r\x15\n\x0e\n\x06\x04\xc6\x01\x02\x08\x03\x12\
    \x04\xcb!\x18\x1a\n\xd9\x01\n\x05\x04\xc6\x01\x02\t\x12\x04\xd4!\x02\x19\
    \x1a\xc9\x01\x20Runners\x20are\x20defined\x20within\x20nodepools\x20so\
    \x20this\x20field\x20needs\x20the\x20id\x20and\x20user_id\x20of\x20the\
    \x20nodepool\n\x20to\x20be\x20provided\x20when\x20creating\x20a\x20Runne\
    r.\n\x20This\x20nodepool\x20must\x20be\x20accessible\x20to\x20you\x20or\
    \x20an\x20org\x20you\x20are\x20part\x20of.\n\n\x0e\n\x06\x04\xc6\x01\x02\
    \t\x06\x12\x04\xd4!\x02\n\n\x0e\n\x06\x04\xc6\x01\x02\t\x01\x12\x04\xd4!\
    \x0b\x13\n\x0e\n\x06\x04\xc6\x01\x02\t\x03\x12\x04\xd4!\x16\x18\n\xc5\
    \x04\n\x05\x04\xc6\x01\x02\n\x12\x04\xde!\x02\x20\x1a\xb5\x04///////////\
    ///////////////\n\x20Need\x20resources\x20on\x20the\x20runner\x20so\x20w\
    e\x20can\x20schedule\x20this\x20Runner\x20into\x20the\x20Nodepool.\n\x20\
    If\x20this\x20runner\x20is\x20being\x20orchestrated\x20for\x20a\x20model\
    \x20then\x20the\x20orchestrator\x20will\x20set\x20this\x20to\x20the\n\
    \x20model\x20resource\x20requirements.\x20If\x20a\x20workflow\x20then\
    \x20it'll\x20compute\x20those\x20requirements\x20and\x20set\n\x20populat\
    e\x20this\x20resource\x20field.\n\x20Having\x20this\x20on\x20the\x20unde\
    rlying\x20object\x20like\x20Model\x20and\x20Workflow\x20allows\x20us\x20\
    to\x20represent\x20the\x20minimum\n\x20requirements\x20on\x20those\x20ob\
    ject,\x20which\x20may\x20be\x20less\x20than\x20what\x20the\x20Runner\x20\
    allocates\x20(as\x20a\x20safety\n\x20margin\x20for\x20the\x20runner\x20t\
    o\x20for\x20sure\x20run\x20the\x20resource).\n\n\x0e\n\x06\x04\xc6\x01\
    \x02\n\x06\x12\x04\xde!\x02\r\n\x0e\n\x06\x04\xc6\x01\x02\n\x01\x12\x04\
    \xde!\x0e\x1a\n\x0e\n\x06\x04\xc6\x01\x02\n\x03\x12\x04\xde!\x1d\x1f\n\
    \xde\x01\n\x03\x04\xc7\x01\x12\x06\xe8!\0\x90\"\x01\x1a\xce\x01\x20A\x20\
    nodepool\x20is\x20a\x20set\x20of\x20nodes\x20dedicated\x20for\x20a\x20gi\
    ven\x20user's\x20compute\x20needs.\n\x20This\x20compute\x20will\x20typic\
    ally\x20be\x20consumed\x20by\x20runners\x20and\x20in\x20the\x20future\
    \x20other\x20objects\n\x20like\x20UI\x20modules\x20may\x20be\x20assigned\
    \x20to\x20node\x20pools.\n\n\x0c\n\x04\x04\xc7\x01\x01\x12\x04\xe8!\x08\
    \x10\n5\n\x05\x04\xc7\x01\x02\0\x12\x04\xea!\x02\x10\x1a&\x20The\x20user\
    \x20defined\x20ID\x20of\x20the\x20nodepool.\n\n\x0e\n\x06\x04\xc7\x01\
    \x02\0\x05\x12\x04\xea!\x02\x08\n\x0e\n\x06\x04\xc7\x01\x02\0\x01\x12\
    \x04\xea!\t\x0b\n\x0e\n\x06\x04\xc7\x01\x02\0\x03\x12\x04\xea!\x0e\x0f\n\
    <\n\x05\x04\xc7\x01\x02\x01\x12\x04\xed!\x02\x15\x1a-\x20The\x20user/org\
    \x20that\x20this\x20nodepool\x20belongs\x20to.\n\n\x0e\n\x06\x04\xc7\x01\
    \x02\x01\x05\x12\x04\xed!\x02\x08\n\x0e\n\x06\x04\xc7\x01\x02\x01\x01\
    \x12\x04\xed!\t\x10\n\x0e\n\x06\x04\xc7\x01\x02\x01\x03\x12\x04\xed!\x13\
    \x14\n<\n\x05\x04\xc7\x01\x02\x02\x12\x04\xf0!\x02\x1f\x1a-\x20Which\x20\
    cloud\x20region\x20this\x20nodepool\x20is\x20within.\n\n\x0e\n\x06\x04\
    \xc7\x01\x02\x02\x06\x12\x04\xf0!\x02\r\n\x0e\n\x06\x04\xc7\x01\x02\x02\
    \x01\x12\x04\xf0!\x0e\x1a\n\x0e\n\x06\x04\xc7\x01\x02\x02\x03\x12\x04\
    \xf0!\x1d\x1e\n\xda\x01\n\x05\x04\xc7\x01\x04\0\x12\x06\xf5!\x02\xf9!\
    \x03\x1a\xc8\x01\x20Type\x20of\x20nodes\x20that\x20are\x20ok\x20for\x20i\
    nstances\x20in\x20this\x20pool.\n\x20If\x20both\x20spot\x20and\x20on-dem\
    and\x20are\x20provided\x20then\x20the\x20runner\x20will\x20be\x20able\
    \x20to\x20run\x20on\x20either\n\x20with\x20a\x20preference\x20for\x20spo\
    t\x20until\x20they\x20are\x20not\x20available.\n\n\x0e\n\x06\x04\xc7\x01\
    \x04\0\x01\x12\x04\xf5!\x07\x13\n\x0f\n\x07\x04\xc7\x01\x04\0\x02\0\x12\
    \x04\xf6!\x04\x1d\n\x10\n\x08\x04\xc7\x01\x04\0\x02\0\x01\x12\x04\xf6!\
    \x04\x18\n\x10\n\x08\x04\xc7\x01\x04\0\x02\0\x02\x12\x04\xf6!\x1b\x1c\n\
    \x0f\n\x07\x04\xc7\x01\x04\0\x02\x01\x12\x04\xf7!\x04\x16\n\x10\n\x08\
    \x04\xc7\x01\x04\0\x02\x01\x01\x12\x04\xf7!\x04\x11\n\x10\n\x08\x04\xc7\
    \x01\x04\0\x02\x01\x02\x12\x04\xf7!\x14\x15\n\x0f\n\x07\x04\xc7\x01\x04\
    \0\x02\x02\x12\x04\xf8!\x04\x12\n\x10\n\x08\x04\xc7\x01\x04\0\x02\x02\
    \x01\x12\x04\xf8!\x04\r\n\x10\n\x08\x04\xc7\x01\x04\0\x02\x02\x02\x12\
    \x04\xf8!\x10\x11\n\r\n\x05\x04\xc7\x01\x02\x03\x12\x04\xfa!\x02+\n\x0e\
    \n\x06\x04\xc7\x01\x02\x03\x04\x12\x04\xfa!\x02\n\n\x0e\n\x06\x04\xc7\
    \x01\x02\x03\x06\x12\x04\xfa!\x0b\x17\n\x0e\n\x06\x04\xc7\x01\x02\x03\
    \x01\x12\x04\xfa!\x18&\n\x0e\n\x06\x04\xc7\x01\x02\x03\x03\x12\x04\xfa!)\
    *\n\xfa\x01\n\x05\x04\xc7\x01\x02\x04\x12\x04\xff!\x02%\x1a\xc3\x01/////\
    ///////////////////////////////\n\x20The\x20instance\x20types\x20that\
    \x20will\x20be\x20available\x20in\x20this\x20pool\x20of\x20nodes.\n\x20C\
    larifai\x20offers\x20multiple\x20different\x20choices\x20that\x20combine\
    \x20cpu\x20cores,\x20memory\x20and\x20accelerator.\n\"%/////////////////\
    ///////////////////\n\n\x0e\n\x06\x04\xc7\x01\x02\x04\x04\x12\x04\xff!\
    \x02\n\n\x0e\n\x06\x04\xc7\x01\x02\x04\x05\x12\x04\xff!\x0b\x11\n\x0e\n\
    \x06\x04\xc7\x01\x02\x04\x01\x12\x04\xff!\x12\x20\n\x0e\n\x06\x04\xc7\
    \x01\x02\x04\x03\x12\x04\xff!#$\n\xa0\x01\n\x05\x04\xc7\x01\x02\x05\x12\
    \x04\x85\"\x02\x1b\x1a\x90\x01\x20Minimum\x20number\x20of\x20instances\
    \x20in\x20this\x20nodepool.\x20This\x20allows\x20the\x20nodeool\x20to\
    \x20scale\x20down\x20to\x20this\n\x20amount.\x20A\x20nodepool\x20needs\
    \x20a\x20minimum\x20of\x201\x20instance.\n\n\x0e\n\x06\x04\xc7\x01\x02\
    \x05\x05\x12\x04\x85\"\x02\x08\n\x0e\n\x06\x04\xc7\x01\x02\x05\x01\x12\
    \x04\x85\"\t\x16\n\x0e\n\x06\x04\xc7\x01\x02\x05\x03\x12\x04\x85\"\x19\
    \x1a\n\x82\x01\n\x05\x04\xc7\x01\x02\x06\x12\x04\x89\"\x02\x1c\x1as\x20A\
    n\x20upper\x20limit\x20on\x20the\x20number\x20of\x20instances\x20in\x20t\
    his\x20nodepool.\x20This\x20allows\x20the\x20nodepool\x20to\x20scale\n\
    \x20up\x20to\x20this\x20amount.\n\n\x0e\n\x06\x04\xc7\x01\x02\x06\x05\
    \x12\x04\x89\"\x02\x08\n\x0e\n\x06\x04\xc7\x01\x02\x06\x01\x12\x04\x89\"\
    \t\x16\n\x0e\n\x06\x04\xc7\x01\x02\x06\x03\x12\x04\x89\"\x19\x1b\n\xe4\
    \x02\n\x03\x04\xc8\x01\x12\x06\x99\"\0\xbd\"\x01\x1a\xd4\x02\x20We\x20de\
    fine\x20a\x20cloud\x20region\x20here\x20to\x20be\x20used\x20in\x20Nodepo\
    ols\x20and\x20by\x20the\x20cloud\x20agent.\n\x20There\x20will\x20be\x20o\
    ne\x20cloud\x20agent\x20per\x20CloudRegion.\n\x20This\x20allows\x20us\
    \x20to\x20define\x20CloudRegions\x20that\x20are\x20VPCs\x20within\x20one\
    \x20physical\x20cloud\x20and\x20have\x20that\n\x20managed\x20by\x20one\
    \x20cloud\x20agent\x20which\x20can\x20list\x20all\x20nodepools\x20for\
    \x20that\x20VPC\x20to\x20deploy\x20them\x20and\n\x20orchestrate\x20work\
    \x20within\x20them.\n\n\x0c\n\x04\x04\xc8\x01\x01\x12\x04\x99\"\x08\x13\
    \n\r\n\x05\x04\xc8\x01\x02\0\x12\x04\x9a\"\x02\x10\n\x0e\n\x06\x04\xc8\
    \x01\x02\0\x05\x12\x04\x9a\"\x02\x08\n\x0e\n\x06\x04\xc8\x01\x02\0\x01\
    \x12\x04\x9a\"\t\x0b\n\x0e\n\x06\x04\xc8\x01\x02\0\x03\x12\x04\x9a\"\x0e\
    \x0f\n\x0f\n\x05\x04\xc8\x01\x04\0\x12\x06\x9c\"\x02\xa6\"\x03\n\x0e\n\
    \x06\x04\xc8\x01\x04\0\x01\x12\x04\x9c\"\x07\x0c\n\x0f\n\x07\x04\xc8\x01\
    \x04\0\x02\0\x12\x04\x9d\"\x04\x15\n\x10\n\x08\x04\xc8\x01\x04\0\x02\0\
    \x01\x12\x04\x9d\"\x04\x10\n\x10\n\x08\x04\xc8\x01\x04\0\x02\0\x02\x12\
    \x04\x9d\"\x13\x14\n\xe2\x01\n\x07\x04\xc8\x01\x04\0\x02\x01\x12\x04\xa1\
    \"\x04\x14\x1a\xd0\x01\x20Run\x20on\x20a\x20user's\x20own\x20infrastruct\
    ure.\x20This\x20has\x20restrictions\x20on\x20who\x20can\x20access\x20res\
    ources\n\x20that\x20are\x20being\x20run\x20by\x20SELF_HOSTED\x20runners.\
    \x20Only\x20those\x20who\x20are\x20part\x20of\x20the\x20user/org\x20wher\
    e\x20they\n\x20exist\x20can\x20leverage\x20them.\n\n\x10\n\x08\x04\xc8\
    \x01\x04\0\x02\x01\x01\x12\x04\xa1\"\x04\x0f\n\x10\n\x08\x04\xc8\x01\x04\
    \0\x02\x01\x02\x12\x04\xa1\"\x12\x13\n\x0f\n\x07\x04\xc8\x01\x04\0\x02\
    \x02\x12\x04\xa2\"\x04\x0c\n\x10\n\x08\x04\xc8\x01\x04\0\x02\x02\x01\x12\
    \x04\xa2\"\x04\x07\n\x10\n\x08\x04\xc8\x01\x04\0\x02\x02\x02\x12\x04\xa2\
    \"\n\x0b\n\x0f\n\x07\x04\xc8\x01\x04\0\x02\x03\x12\x04\xa3\"\x04\x0c\n\
    \x10\n\x08\x04\xc8\x01\x04\0\x02\x03\x01\x12\x04\xa3\"\x04\x07\n\x10\n\
    \x08\x04\xc8\x01\x04\0\x02\x03\x02\x12\x04\xa3\"\n\x0b\n\x0f\n\x07\x04\
    \xc8\x01\x04\0\x02\x04\x12\x04\xa4\"\x04\x0e\n\x10\n\x08\x04\xc8\x01\x04\
    \0\x02\x04\x01\x12\x04\xa4\"\x04\t\n\x10\n\x08\x04\xc8\x01\x04\0\x02\x04\
    \x02\x12\x04\xa4\"\x0c\r\n\x0f\n\x07\x04\xc8\x01\x04\0\x02\x05\x12\x04\
    \xa5\"\x04\x0f\n\x10\n\x08\x04\xc8\x01\x04\0\x02\x05\x01\x12\x04\xa5\"\
    \x04\n\n\x10\n\x08\x04\xc8\x01\x04\0\x02\x05\x02\x12\x04\xa5\"\r\x0e\n\r\
    \n\x05\x04\xc8\x01\x02\x01\x12\x04\xa7\"\x02\x12\n\x0e\n\x06\x04\xc8\x01\
    \x02\x01\x06\x12\x04\xa7\"\x02\x07\n\x0e\n\x06\x04\xc8\x01\x02\x01\x01\
    \x12\x04\xa7\"\x08\r\n\x0e\n\x06\x04\xc8\x01\x02\x01\x03\x12\x04\xa7\"\
    \x10\x11\n\xa5\x01\n\x05\x04\xc8\x01\x02\x02\x12\x04\xab\"\x02\x14\x1a\
    \x95\x01\x20The\x20region.\x20The\x20naming\x20here\x20depends\x20on\x20\
    the\x20cloud\x20choice\x20above\x20and\x20will\x20be\x20validated\n\x20a\
    gainst\x20which\x20clouds+regions\x20that\x20Clarifai\x20currently\x20su\
    pports.\n\n\x0e\n\x06\x04\xc8\x01\x02\x02\x05\x12\x04\xab\"\x02\x08\n\
    \x0e\n\x06\x04\xc8\x01\x02\x02\x01\x12\x04\xab\"\t\x0f\n\x0e\n\x06\x04\
    \xc8\x01\x02\x02\x03\x12\x04\xab\"\x12\x13\n\xd0\x02\n\x03\x04\xc9\x01\
    \x12\x06\xcf\"\0\xed\"\x01\x1a\xc0\x02\x20These\x20are\x20the\x20resourc\
    e\x20needs\x20of\x20a\x20given\x20API\x20object\x20such\x20as\x20a\x20mo\
    del.\n\x20This\x20is\x20what\x20they\x20require\x20as\x20a\x20minimum\
    \x20to\x20run\x20and\x20will\x20be\x20used\x20upon\x20scheduling\n\x20as\
    \x20the\x20request\x20and\x20limit\x20for\x20the\x20k8s\x20pod.\x20If\
    \x20we\x20want\x20to\x20separate\x20limits\x20and\x20requests\x20in\x20t\
    he\n\x20future\x20we\x20can\x20allow\x20setting\x20a\x20limits\x20Comput\
    eInfo\x20and\x20a\x20requests\x20ComputeInfo.\n\n\x0c\n\x04\x04\xc9\x01\
    \x01\x12\x04\xcf\"\x08\x13\n\x20\n\x05\x04\xc9\x01\x02\0\x12\x04\xd1\"\
    \x02\x16\x1a\x11\x20Number\x20of\x20CPUs.\n\n\x0e\n\x06\x04\xc9\x01\x02\
    \0\x05\x12\x04\xd1\"\x02\x08\n\x0e\n\x06\x04\xc9\x01\x02\0\x01\x12\x04\
    \xd1\"\t\x11\n\x0e\n\x06\x04\xc9\x01\x02\0\x03\x12\x04\xd1\"\x14\x15\n:\
    \n\x05\x04\xc9\x01\x02\x01\x12\x04\xd3\"\x02\x18\x1a+\x20Amount\x20of\
    \x20CPU\x20memory\x20to\x20use\x20as\x20a\x20minimum.\n\n\x0e\n\x06\x04\
    \xc9\x01\x02\x01\x05\x12\x04\xd3\"\x02\x08\n\x0e\n\x06\x04\xc9\x01\x02\
    \x01\x01\x12\x04\xd3\"\t\x13\n\x0e\n\x06\x04\xc9\x01\x02\x01\x03\x12\x04\
    \xd3\"\x16\x17\n`\n\x05\x04\xc9\x01\x02\x02\x12\x04\xd5\"\x02\x1e\x1aQ\
    \x20Number\x20of\x20accelerators\x20(typically\x20GPUs,\x20TPUs,\x20etc.\
    \x20not\x20CPUs)\x20for\x20this\x20resource.\n\n\x0e\n\x06\x04\xc9\x01\
    \x02\x02\x05\x12\x04\xd5\"\x02\x08\n\x0e\n\x06\x04\xc9\x01\x02\x02\x01\
    \x12\x04\xd5\"\t\x19\n\x0e\n\x06\x04\xc9\x01\x02\x02\x03\x12\x04\xd5\"\
    \x1c\x1d\n\xa1\x04\n\x05\x04\xc9\x01\x02\x03\x12\x04\xd9\"\x02\x20\x1a\
    \x9e\x01\x20Amount\x20of\x20accelerator/GPU\x20memory\x20to\x20use\x20as\
    \x20a\x20minimum.\n\x20This\x20is\x20defined\x20per\x20accelerator.\n\
    \x20This\x20follows\x20the\x20format\x20used\x20by\x20kubernetes\x20like\
    \x201Ki,\x202Mi,\x203Gi,\x204Ti.\n\"\xf0\x02\x20The\x20supported\x20acce\
    lerators\x20that\x20the\x20resource\x20can\x20run\x20on.\x20If\x20the\
    \x20resource\x20requires\x20a\x20specific\n\x20accelerator\x20type\x20th\
    en\x20it\x20will\x20only\x20be\x20scheduled\x20on\x20nodes\x20that\x20ha\
    ve\x20that\x20type\x20of\x20accelerator.\n\x20If\x20there\x20is\x20no\
    \x20hard\x20requirements\x20beyond\x20the\x20number\x20of\x20accelerator\
    s\x20and\x20their\x20memory\x20then\x20this\n\x20field\x20can\x20be\x20l\
    eft\x20empty.\n\x20This\x20setting\x20will\x20cause\x20an\x20error\x20if\
    \x20num_accelerators\x20==\x200\n\n\x0e\n\x06\x04\xc9\x01\x02\x03\x05\
    \x12\x04\xd9\"\x02\x08\n\x0e\n\x06\x04\xc9\x01\x02\x03\x01\x12\x04\xd9\"\
    \t\x1b\n\x0e\n\x06\x04\xc9\x01\x02\x03\x03\x12\x04\xd9\"\x1e\x1f\n\xa3\
    \x01\n\x05\x04\xc9\x01\x02\x04\x12\x04\xe2\"\x02'\x1a\x93\x01\x20Or\x20s\
    hould\x20it\x20be\x20removed\x20completely\x20and\x20use\x20the\x20nodep\
    ool\x20accelerator\x20type\x20itself.\n\x20These\x20are\x20the\x20suppor\
    ted\x20accelerators\x20that\x20the\x20model\x20can\x20run\x20on.\n\n\x0e\
    \n\x06\x04\xc9\x01\x02\x04\x04\x12\x04\xe2\"\x02\n\n\x0e\n\x06\x04\xc9\
    \x01\x02\x04\x05\x12\x04\xe2\"\x0b\x11\n\x0e\n\x06\x04\xc9\x01\x02\x04\
    \x01\x12\x04\xe2\"\x12\"\n\x0e\n\x06\x04\xc9\x01\x02\x04\x03\x12\x04\xe2\
    \"%&\n\xa4\x02\n\x03\x04\xca\x01\x12\x06\xf5\"\0\x88#\x01\x1a\x94\x02\
    \x20It\x20might\x20be\x20better\x20to\x20do\x20this\x20as\x20runner\x20a\
    utoscaling\x20so\x20that\x20resources\n\x20of\x20a\x20model\x20are\x20ve\
    ry\x20simply\x20what\x20that\x20model\x20needs\x20at\x20minimum.\n\x20No\
    te\x20that\x20resources\x20for\x20things\x20like\x20modes\x20inside\x20r\
    unners\x20are\x20not\n\x20related\x20to\x20how\x20many\x20replicas\x20of\
    \x20those\x20runners\x20are\x20needed\x20to\x20handle\x20traffic.\n\n\
    \x0c\n\x04\x04\xca\x01\x01\x12\x04\xf5\"\x08\x17\n\xba\x01\n\x05\x04\xca\
    \x01\x02\0\x12\x04\xfa\"\x02\x1a\x1a\xaa\x01\x20The\x20minimum\x20number\
    \x20of\x20replicas\x20for\x20the\x20runner\x20to\x20have.\n\x20Defaults\
    \x20to\x200\x20which\x20means\x20autoscaling\x20can\x20scale\x20down\x20\
    to\x20zero.\n\x20If\x20you\x20want\x20a\x20replica\x20always\x20up\x20th\
    en\x20set\x20to\x20>=\x201.\n\n\x0e\n\x06\x04\xca\x01\x02\0\x05\x12\x04\
    \xfa\"\x02\x08\n\x0e\n\x06\x04\xca\x01\x02\0\x01\x12\x04\xfa\"\t\x15\n\
    \x0e\n\x06\x04\xca\x01\x02\0\x03\x12\x04\xfa\"\x18\x19\nK\n\x05\x04\xca\
    \x01\x02\x01\x12\x04\xfc\"\x02\x1a\x1a<\x20The\x20maximium\x20number\x20\
    of\x20replicas\x20to\x20scale\x20up\x20the\x20runner\x20to.\n\n\x0e\n\
    \x06\x04\xca\x01\x02\x01\x05\x12\x04\xfc\"\x02\x08\n\x0e\n\x06\x04\xca\
    \x01\x02\x01\x01\x12\x04\xfc\"\t\x15\n\x0e\n\x06\x04\xca\x01\x02\x01\x03\
    \x12\x04\xfc\"\x18\x19\nW\n\x05\x04\xca\x01\x02\x02\x12\x04\xff\"\x02%\
    \x1aH\x20The\x20number\x20of\x20seconds\x20of\x20traffic\x20history\x20t\
    o\x20consider\x20when\x20autoscaling.\n\n\x0e\n\x06\x04\xca\x01\x02\x02\
    \x05\x12\x04\xff\"\x02\x08\n\x0e\n\x06\x04\xca\x01\x02\x02\x01\x12\x04\
    \xff\"\t\x20\n\x0e\n\x06\x04\xca\x01\x02\x02\x03\x12\x04\xff\"#$\nM\n\
    \x05\x04\xca\x01\x02\x03\x12\x04\x81#\x02&\x1a>\x20The\x20time\x20to\x20\
    wait\x20before\x20scaling\x20down\x20after\x20the\x20last\x20request.\n\
    \n\x0e\n\x06\x04\xca\x01\x02\x03\x05\x12\x04\x81#\x02\x08\n\x0e\n\x06\
    \x04\xca\x01\x02\x03\x01\x12\x04\x81#\t!\n\x0e\n\x06\x04\xca\x01\x02\x03\
    \x03\x12\x04\x81#$%\nT\n\x05\x04\xca\x01\x02\x04\x12\x04\x83#\x02$\x1aE\
    \x20The\x20time\x20to\x20wait\x20between\x20scaling\x20up\x20replicas\
    \x20without\x20burst\x20traffic.\n\n\x0e\n\x06\x04\xca\x01\x02\x04\x05\
    \x12\x04\x83#\x02\x08\n\x0e\n\x06\x04\xca\x01\x02\x04\x01\x12\x04\x83#\t\
    \x1f\n\x0e\n\x06\x04\xca\x01\x02\x04\x03\x12\x04\x83#\"#\n\x91\x01\n\x05\
    \x04\xca\x01\x02\x05\x12\x04\x87#\x02\x1a\x1a\x81\x01\x20Depending\x20on\
    \x20your\x20plan\x20you\x20may\x20be\x20able\x20to\x20enable\x20packing\
    \x20of\x20resources\x20into\x20a\x20single\x20node\n\x20for\x20more\x20c\
    ompute\x20and\x20cost\x20efficiency.\n\n\x0e\n\x06\x04\xca\x01\x02\x05\
    \x05\x12\x04\x87#\x02\x06\n\x0e\n\x06\x04\xca\x01\x02\x05\x01\x12\x04\
    \x87#\x07\x15\n\x0e\n\x06\x04\xca\x01\x02\x05\x03\x12\x04\x87#\x18\x19\n\
    \xe5\x01\n\x03\x04\xcb\x01\x12\x06\x93#\0\xc4#\x01\x1a\xd5\x01\x20A\x20d\
    eployment\x20allows\x20you\x20to\x20configure\x20how\x20runners\x20for\
    \x20a\x20particular\x20type\x20of\x20resource\x20will\n\x20scale\x20up\
    \x20and\x20down.\x20These\x20are\x20unique\x20per\x20user_id,\x20nodepoo\
    l\x20and\x20model\x20so\x20for\x20differnet\x20nodepools\n\x20you\x20can\
    \x20scale\x20differently.\n\n\x0c\n\x04\x04\xcb\x01\x01\x12\x04\x93#\x08\
    \x12\n6\n\x05\x04\xcb\x01\x02\0\x12\x04\x95#\x02\x10\x1a'\x20An\x20id\
    \x20for\x20this\x20configured\x20deployment.\n\n\x0e\n\x06\x04\xcb\x01\
    \x02\0\x05\x12\x04\x95#\x02\x08\n\x0e\n\x06\x04\xcb\x01\x02\0\x01\x12\
    \x04\x95#\t\x0b\n\x0e\n\x06\x04\xcb\x01\x02\0\x03\x12\x04\x95#\x0e\x0f\n\
    V\n\x05\x04\xcb\x01\x02\x01\x12\x04\x97#\x02\x15\x1aG\x20The\x20user\x20\
    who\x20owns\x20the\x20deployment.\x20These\x20live\x20in\x20the\x20user/\
    org\x20account.\n\n\x0e\n\x06\x04\xcb\x01\x02\x01\x05\x12\x04\x97#\x02\
    \x08\n\x0e\n\x06\x04\xcb\x01\x02\x01\x01\x12\x04\x97#\t\x10\n\x0e\n\x06\
    \x04\xcb\x01\x02\x01\x03\x12\x04\x97#\x13\x14\n-\n\x05\x04\xcb\x01\x02\
    \x02\x12\x04\x99#\x02'\x1a\x1e\x20How\x20to\x20autoscale\x20the\x20objec\
    t.\n\n\x0e\n\x06\x04\xcb\x01\x02\x02\x06\x12\x04\x99#\x02\x11\n\x0e\n\
    \x06\x04\xcb\x01\x02\x02\x01\x12\x04\x99#\x12\"\n\x0e\n\x06\x04\xcb\x01\
    \x02\x02\x03\x12\x04\x99#%&\n\xf6\x03\n\x05\x04\xcb\x01\x02\x03\x12\x04\
    \xa1#\x02\"\x1a\xe6\x03\x20You\x20can\x20configure\x20different\x20autos\
    caling\x20per\x20nodepool(s).\n\x20These\x20nodepools\x20have\x20to\x20b\
    e\x20also\x20owned\x20by\x20the\x20same\x20user_id/org\x20as\x20this\x20\
    deployment.\n\x20If\x20there\x20is\x20more\x20than\x20one\x20nodepool\
    \x20we\x20use\x20the\x20model's\x20ComputeInfo\x20to\x20match\n\x20with\
    \x20what\x20the\x20nodepool\x20provides\x20to\x20decide\x20which\x20one\
    \x20can\x20handle\x20it\x20combined\x20with\x20the\n\x20NodepoolRank\x20\
    below.\x20Note:\x20even\x20within\x20a\x20single\x20nodepool\x20if\x20it\
    \x20is\x20heterogeneous\x20then\n\x20we\x20need\x20a\x20way\x20to\x20ran\
    k\x20scheduling\x20choices\x20when\x20we\x20don't\x20know\x20how\x20to\
    \x20decide\x20(like\x20a\x20model\n\x20supports\n\n\x0e\n\x06\x04\xcb\
    \x01\x02\x03\x04\x12\x04\xa1#\x02\n\n\x0e\n\x06\x04\xcb\x01\x02\x03\x06\
    \x12\x04\xa1#\x0b\x13\n\x0e\n\x06\x04\xcb\x01\x02\x03\x01\x12\x04\xa1#\
    \x14\x1d\n\x0e\n\x06\x04\xcb\x01\x02\x03\x03\x12\x04\xa1#\x20!\n\xb6\x01\
    \n\x05\x04\xcb\x01\x08\0\x12\x06\xa5#\x02\xae#\x03\x1a\xa4\x01\x20The\
    \x20thing\x20that\x20the\x20autoscaling\x20config\x20applies\x20to\x20fo\
    r\x20this\x20nodepool.\n\x20For\x20a\x20given\x20user_id,\x20nodepool_id\
    ,\x20and\x20object\x20ID\x20we\x20can\x20only\x20have\x20one\x20deployme\
    nt\x20as\x20it\x20defines\n\n\x0e\n\x06\x04\xcb\x01\x08\0\x01\x12\x04\
    \xa5#\x08\x0e\n\x16\n\x05\x04\xcb\x01\x02\x04\x12\x04\xa7#\x04\x14\x1a\
    \x07\x20Model\n\n\x0e\n\x06\x04\xcb\x01\x02\x04\x06\x12\x04\xa7#\x04\t\n\
    \x0e\n\x06\x04\xcb\x01\x02\x04\x01\x12\x04\xa7#\n\x0f\n\x0e\n\x06\x04\
    \xcb\x01\x02\x04\x03\x12\x04\xa7#\x12\x13\n\xaf\x02\n\x05\x04\xcb\x01\
    \x02\x05\x12\x04\xa9#\x04\x1a\x1a\n\x20Workflow\n\"\x93\x02\x20We\x20cou\
    ld\x20also\x20support\x20matching\x20by\x20labels\x20here\x20for\x20futu\
    re\x20\"job\"\x20like\x20functionality\x20where\n\x20the\x20item\x20itse\
    lf\x20fully\x20defines\x20the\x20work\x20that\x20needs\x20to\x20be\x20do\
    ne.\n\x20This\x20would\x20match\x20any\x20resources\x20that\x20have\x20t\
    hese\x20runner\x20labels\x20defined\x20on\x20them.\n\x20RunnerLabels\x20\
    runner_labels\x20=\x2011;\x20//\x20FUTURE\n\n\x0e\n\x06\x04\xcb\x01\x02\
    \x05\x06\x12\x04\xa9#\x04\x0c\n\x0e\n\x06\x04\xcb\x01\x02\x05\x01\x12\
    \x04\xa9#\r\x15\n\x0e\n\x06\x04\xcb\x01\x02\x05\x03\x12\x04\xa9#\x18\x19\
    \n\x92\x05\n\x05\x04\xcb\x01\x04\0\x12\x06\xb8#\x02\xc2#\x03\x1a\x80\x05\
    \x20In\x20some\x20scenarios\x20it\x20may\x20not\x20be\x20obvous\x20how\
    \x20we\x20should\x20schedule\x20a\x20resource\x20to\x20underlying\x20nod\
    es\n\x20within\x20the\x20nodepool(s)\x20above.\x20The\x20SchedulerChoice\
    \x20allows\x20us\x20to\x20specify\x20how\x20to\x20decide\x20which\n\x20n\
    odepool\x20to\x20use\x20when\x20there\x20are\x20multiple\x20nodepools\
    \x20and\x20how\x20to\x20decide\x20which\x20type\x20of\x20node\n\x20withi\
    n\x20a\x20nodepool\x20if\x20there\x20are\x20multiple\x20types.\n\x20If\
    \x20here\x20are\x20multiple\x20nondepools\x20then\x20a\x20decision\x20on\
    \x20which\x20to\x20use\x20comes\x20into\x20play\n\x20if\x20it\x20is\x20n\
    ot\x20specified\x20in\x20the\x20prediction\x20request.\n\x20Even\x20with\
    \x20a\x20single\x20nodepool\x20a\x20choice\x20may\x20come\x20up\x20such\
    \x20as\x20when\x20a\x20resource\x20that\x20needs\x20scheduling\n\x20has\
    \x20not\x20specified\x20the\x20accelerator\x20types\x20it\x20supports\
    \x20and\x20the\x20nodepool\x20has\x20multiple\x20types.\n\n\x0e\n\x06\
    \x04\xcb\x01\x04\0\x01\x12\x04\xb8#\x07\x17\n\x0f\n\x07\x04\xcb\x01\x04\
    \0\x02\0\x12\x04\xb9#\x04\"\n\x10\n\x08\x04\xcb\x01\x04\0\x02\0\x01\x12\
    \x04\xb9#\x04\x1d\n\x10\n\x08\x04\xcb\x01\x04\0\x02\0\x02\x12\x04\xb9#\
    \x20!\n2\n\x07\x04\xcb\x01\x04\0\x02\x01\x12\x04\xba#\x04\r\"!\x20fail\
    \x20if\x20there\x20is\x20any\x20ambiguity.\n\n\x10\n\x08\x04\xcb\x01\x04\
    \0\x02\x01\x01\x12\x04\xba#\x04\x08\n\x10\n\x08\x04\xcb\x01\x04\0\x02\
    \x01\x02\x12\x04\xba#\x0b\x0c\nG\n\x07\x04\xcb\x01\x04\0\x02\x02\x12\x04\
    \xbb#\x04\x0f\"6\x20randomly\x20pick\x20amongst\x20the\x20nodepools/node\
    s\x20to\x20assign.\n\n\x10\n\x08\x04\xcb\x01\x04\0\x02\x02\x01\x12\x04\
    \xbb#\x04\n\n\x10\n\x08\x04\xcb\x01\x04\0\x02\x02\x02\x12\x04\xbb#\r\x0e\
    \n5\n\x07\x04\xcb\x01\x04\0\x02\x03\x12\x04\xbc#\x04\x0e\"$\x20choose\
    \x20the\x20compute\x20that\x20is\x20cheaper\n\n\x10\n\x08\x04\xcb\x01\
    \x04\0\x02\x03\x01\x12\x04\xbc#\x04\t\n\x10\n\x08\x04\xcb\x01\x04\0\x02\
    \x03\x02\x12\x04\xbc#\x0c\r\n8\n\x07\x04\xcb\x01\x04\0\x02\x04\x12\x04\
    \xbd#\x04\x14\"'\x20schedule\x20to\x20the\x20fastest\x20known\x20iption.\
    \n\n\x10\n\x08\x04\xcb\x01\x04\0\x02\x04\x01\x12\x04\xbd#\x04\x0f\n\x10\
    \n\x08\x04\xcb\x01\x04\0\x02\x04\x02\x12\x04\xbd#\x12\x13\n5\n\x07\x04\
    \xcb\x01\x04\0\x02\x05\x12\x04\xbe#\x04\x10\"$\x20optimize\x20based\x20o\
    n\x20network\x20latency.\n\n\x10\n\x08\x04\xcb\x01\x04\0\x02\x05\x01\x12\
    \x04\xbe#\x04\x0b\n\x10\n\x08\x04\xcb\x01\x04\0\x02\x05\x02\x12\x04\xbe#\
    \x0e\x0f\nJ\n\x07\x04\xcb\x01\x04\0\x02\x06\x12\x04\xbf#\x04\x14\"9\x20s\
    end\x20to\x20the\x20least\x20used\x20nodepool\x20based\x20on\x20it's\x20\
    capacity.\n\n\x10\n\x08\x04\xcb\x01\x04\0\x02\x06\x01\x12\x04\xbf#\x04\
    \x0f\n\x10\n\x08\x04\xcb\x01\x04\0\x02\x06\x02\x12\x04\xbf#\x12\x13\n7\n\
    \x07\x04\xcb\x01\x04\0\x02\x07\x12\x04\xc0#\x04\x14\"&\x20choose\x20spot\
    \x20instances\x20over\x20on-demand\n\n\x10\n\x08\x04\xcb\x01\x04\0\x02\
    \x07\x01\x12\x04\xc0#\x04\x0f\n\x10\n\x08\x04\xcb\x01\x04\0\x02\x07\x02\
    \x12\x04\xc0#\x12\x13\n8\n\x07\x04\xcb\x01\x04\0\x02\x08\x12\x04\xc1#\
    \x04\x18\"'\x20choose\x20on-demand\x20instances\x20over\x20spot.\n\n\x10\
    \n\x08\x04\xcb\x01\x04\0\x02\x08\x01\x12\x04\xc1#\x04\x13\n\x10\n\x08\
    \x04\xcb\x01\x04\0\x02\x08\x02\x12\x04\xc1#\x16\x17\n\r\n\x05\x04\xcb\
    \x01\x02\x06\x12\x04\xc3#\x02)\n\x0e\n\x06\x04\xcb\x01\x02\x06\x06\x12\
    \x04\xc3#\x02\x12\n\x0e\n\x06\x04\xcb\x01\x02\x06\x01\x12\x04\xc3#\x13$\
    \n\x0e\n\x06\x04\xcb\x01\x02\x06\x03\x12\x04\xc3#'(\n\xc3\x03\n\x03\x04\
    \xcc\x01\x12\x06\xcf#\0\xdb#\x01\x1a\xb3\x03////////////////////////////\
    ////////////\n\x20Don't\x20need\x20RunnerSelector\x20if\x20we're\x20open\
    ing\x20up\x20endpoints\x20for\x20deployments.\n/////////////////////////\
    ///////////////\n\x20The\x20RunnerSelector\x20is\x20an\x20optional\x20fi\
    eld\x20we\x20can\x20provide\x20during\x20runtime\n\x20of\x20model/workfl\
    ow\x20predictions\x20to\x20specify\x20which\x20particular\x20runner\x20w\
    e\x20want\x20to\x20process\x20the\x20work.\n\x20This\x20can\x20optionall\
    y\x20be\x20used\x20to\x20select\x20a\x20particular\x20nodepool\x20and\
    \x20then\x20within\x20that\x20nodepool\n\x20a\x20particular\x20runner.\n\
    \n\x0c\n\x04\x04\xcc\x01\x01\x12\x04\xcf#\x08\x16\n\xfc\x02\n\x05\x04\
    \xcc\x01\x02\0\x12\x04\xd4#\x02\x18\x1a\xec\x02\x20A\x20particular\x20no\
    depool\x20for\x20the\x20resource\x20to\x20be\x20run\x20within.\x20This\
    \x20request\x20the\x20id\x20and\x20user_id\x20of\n\x20the\x20nodepool\
    \x20to\x20be\x20specified.\x20Runners\x20will\x20be\x20scaled\x20accordi\
    ng\x20to\x20a\x20deployment\x20for\x20the\x20given\n\x20resource\x20to\
    \x20be\x20run.\x20There\x20should\x20not\x20be\x20more\x20than\x20one\
    \x20deployment\x20in\x20this\x20nodepool\x20for\x20the\n\x20particular\
    \x20resource\x20to\x20run.\x20If\x20no\x20deployments\x20then\x20default\
    \x20autoscaling\x20will\x20be\x20used.\n\n\x0e\n\x06\x04\xcc\x01\x02\0\
    \x06\x12\x04\xd4#\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\0\x01\x12\x04\xd4#\
    \x0b\x13\n\x0e\n\x06\x04\xcc\x01\x02\0\x03\x12\x04\xd4#\x16\x17\nC\n\x05\
    \x04\xcc\x01\x02\x01\x12\x04\xd6#\x02\x14\x1a4\x20Optionally\x20a\x20par\
    tcular\x20runner\x20within\x20the\x20nodepool.\n\n\x0e\n\x06\x04\xcc\x01\
    \x02\x01\x06\x12\x04\xd6#\x02\x08\n\x0e\n\x06\x04\xcc\x01\x02\x01\x01\
    \x12\x04\xd6#\t\x0f\n\x0e\n\x06\x04\xcc\x01\x02\x01\x03\x12\x04\xd6#\x12\
    \x13\n\xb4\x01\n\x05\x04\xcc\x01\x02\x02\x12\x04\xd8#\x02\x1c\x1a8\x20Op\
    tionally\x20a\x20partcular\x20deployment\x20within\x20the\x20nodepool.\n\
    \"k\x20In\x20future\x20as\x20we\x20support\x20matching\x20runners\x20bas\
    ed\x20on\x20just\x20labels:\n\x20RunnerLabels\x20runner_labels\x20=\x203\
    ;\x20//\x20FUTURE\n\n\x0e\n\x06\x04\xcc\x01\x02\x02\x06\x12\x04\xd8#\x02\
    \x0c\n\x0e\n\x06\x04\xcc\x01\x02\x02\x01\x12\x04\xd8#\r\x17\n\x0e\n\x06\
    \x04\xcc\x01\x02\x02\x03\x12\x04\xd8#\x1a\x1b\n\x0c\n\x02\x05\x11\x12\
    \x06\xdc#\0\xe3#\x01\n\x0b\n\x03\x05\x11\x01\x12\x04\xdc#\x05\x15\n\x0c\
    \n\x04\x05\x11\x02\0\x12\x04\xdd#\x02\x0e\n\r\n\x05\x05\x11\x02\0\x01\
    \x12\x04\xdd#\x02\t\n\r\n\x05\x05\x11\x02\0\x02\x12\x04\xdd#\x0c\r\nB\n\
    \x04\x05\x11\x02\x01\x12\x04\xde#\x02\x12\"4\x20single\x20request,\x20si\
    ngle\x20response.\x20predict()\x20in\x20code\n\n\r\n\x05\x05\x11\x02\x01\
    \x01\x12\x04\xde#\x02\r\n\r\n\x05\x05\x11\x02\x01\x02\x12\x04\xde#\x10\
    \x11\nE\n\x04\x05\x11\x02\x02\x12\x04\xdf#\x02\x16\"7\x20single\x20reque\
    st,\x20streamed\x20response.\x20generate()\x20in\x20code\n\n\r\n\x05\x05\
    \x11\x02\x02\x01\x12\x04\xdf#\x02\x11\n\r\n\x05\x05\x11\x02\x02\x02\x12\
    \x04\xdf#\x14\x15\n4\n\x04\x05\x11\x02\x03\x12\x04\xe0#\x02\x16\"&\x20st\
    ream\x20of\x20requests,\x20single\x20response.\n\n\r\n\x05\x05\x11\x02\
    \x03\x01\x12\x04\xe0#\x02\x11\n\r\n\x05\x05\x11\x02\x03\x02\x12\x04\xe0#\
    \x14\x15\nI\n\x04\x05\x11\x02\x04\x12\x04\xe1#\x02\x1a\";\x20stream\x20o\
    f\x20requests,\x20stream\x20of\x20responses.\x20stream()\x20in\x20code\n\
    \n\r\n\x05\x05\x11\x02\x04\x01\x12\x04\xe1#\x02\x15\n\r\n\x05\x05\x11\
    \x02\x04\x02\x12\x04\xe1#\x18\x19\nM\n\x03\x04\xcd\x01\x12\x06\xe7#\0\
    \xed#\x01\x1a>\x20Processing\x20info\x20tells\x20the\x20runner\x20how\
    \x20to\x20process\x20a\x20RunnerItem\n\n\x0c\n\x04\x04\xcd\x01\x01\x12\
    \x04\xe7#\x08\x16\n=\n\x05\x04\xcd\x01\x02\0\x12\x04\xe9#\x02*\x1a.\x20T\
    he\x20type\x20of\x20method\x20witin\x20the\x20runner\x20to\x20call.\n\n\
    \x0e\n\x06\x04\xcd\x01\x02\0\x06\x12\x04\xe9#\x02\x12\n\x0e\n\x06\x04\
    \xcd\x01\x02\0\x01\x12\x04\xe9#\x13%\n\x0e\n\x06\x04\xcd\x01\x02\0\x03\
    \x12\x04\xe9#()\n\x97\x01\n\x05\x04\xcd\x01\x02\x01\x12\x04\xec#\x02(\
    \x1a\x87\x01\x20A\x20status\x20of\x20the\x20processing.\x20We\x20use\x20\
    this\x20for\x20signalling\x20end\x20of\x20a\x20request\x20stream,\x20a\
    \x20runner\n\x20item's\x20processing\x20should\x20be\x20cancelled,\x20et\
    c.\n\n\x0e\n\x06\x04\xcd\x01\x02\x01\x06\x12\x04\xec#\x02\x1c\n\x0e\n\
    \x06\x04\xcd\x01\x02\x01\x01\x12\x04\xec#\x1d#\n\x0e\n\x06\x04\xcd\x01\
    \x02\x01\x03\x12\x04\xec#&'b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(8);
            deps.push(super::status::file_descriptor().clone());
            deps.push(super::status_code::file_descriptor().clone());
            deps.push(super::extensions::file_descriptor().clone());
            deps.push(super::matrix::file_descriptor().clone());
            deps.push(super::extension::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::struct_::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::wrappers::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(208);
            messages.push(Annotation::generated_message_descriptor_data());
            messages.push(Worker::generated_message_descriptor_data());
            messages.push(App::generated_message_descriptor_data());
            messages.push(AppExtraInfo::generated_message_descriptor_data());
            messages.push(AppQuery::generated_message_descriptor_data());
            messages.push(AppResourceCounts::generated_message_descriptor_data());
            messages.push(Collaborator::generated_message_descriptor_data());
            messages.push(Collaboration::generated_message_descriptor_data());
            messages.push(Audio::generated_message_descriptor_data());
            messages.push(AudioInfo::generated_message_descriptor_data());
            messages.push(Track::generated_message_descriptor_data());
            messages.push(Cluster::generated_message_descriptor_data());
            messages.push(Color::generated_message_descriptor_data());
            messages.push(W3C::generated_message_descriptor_data());
            messages.push(UserAppIDSet::generated_message_descriptor_data());
            messages.push(PatchAction::generated_message_descriptor_data());
            messages.push(Concept::generated_message_descriptor_data());
            messages.push(KeypointInfo::generated_message_descriptor_data());
            messages.push(KeypointEdge::generated_message_descriptor_data());
            messages.push(ConceptExtraInfo::generated_message_descriptor_data());
            messages.push(ConceptCount::generated_message_descriptor_data());
            messages.push(ConceptTypeCount::generated_message_descriptor_data());
            messages.push(DetailConceptCount::generated_message_descriptor_data());
            messages.push(ConceptQuery::generated_message_descriptor_data());
            messages.push(ConceptRelation::generated_message_descriptor_data());
            messages.push(KnowledgeGraph::generated_message_descriptor_data());
            messages.push(ConceptMappingJob::generated_message_descriptor_data());
            messages.push(ConceptLanguage::generated_message_descriptor_data());
            messages.push(Data::generated_message_descriptor_data());
            messages.push(Region::generated_message_descriptor_data());
            messages.push(RegionInfo::generated_message_descriptor_data());
            messages.push(BoundingBox::generated_message_descriptor_data());
            messages.push(FrameInfo::generated_message_descriptor_data());
            messages.push(Frame::generated_message_descriptor_data());
            messages.push(Mask::generated_message_descriptor_data());
            messages.push(Polygon::generated_message_descriptor_data());
            messages.push(Point::generated_message_descriptor_data());
            messages.push(Span::generated_message_descriptor_data());
            messages.push(Token::generated_message_descriptor_data());
            messages.push(Embedding::generated_message_descriptor_data());
            messages.push(GeoPoint::generated_message_descriptor_data());
            messages.push(GeoLimit::generated_message_descriptor_data());
            messages.push(GeoBoxedPoint::generated_message_descriptor_data());
            messages.push(Geo::generated_message_descriptor_data());
            messages.push(Image::generated_message_descriptor_data());
            messages.push(ImageInfo::generated_message_descriptor_data());
            messages.push(HostedURL::generated_message_descriptor_data());
            messages.push(Input::generated_message_descriptor_data());
            messages.push(InputBatch::generated_message_descriptor_data());
            messages.push(InputCount::generated_message_descriptor_data());
            messages.push(Dataset::generated_message_descriptor_data());
            messages.push(AnnotationFilter::generated_message_descriptor_data());
            messages.push(DatasetInput::generated_message_descriptor_data());
            messages.push(DatasetVersion::generated_message_descriptor_data());
            messages.push(AnnotationFilterConfig::generated_message_descriptor_data());
            messages.push(ModelPredictConfig::generated_message_descriptor_data());
            messages.push(DatasetVersionMetrics::generated_message_descriptor_data());
            messages.push(DatasetVersionMetricsGroup::generated_message_descriptor_data());
            messages.push(DatasetVersionExportInfo::generated_message_descriptor_data());
            messages.push(DatasetVersionExport::generated_message_descriptor_data());
            messages.push(DatasetVersionProcessingInfo::generated_message_descriptor_data());
            messages.push(FrameInterpolationInfo::generated_message_descriptor_data());
            messages.push(WorkflowResultsSimilarity::generated_message_descriptor_data());
            messages.push(Key::generated_message_descriptor_data());
            messages.push(Model::generated_message_descriptor_data());
            messages.push(ModelReference::generated_message_descriptor_data());
            messages.push(ModelVersionInputExample::generated_message_descriptor_data());
            messages.push(OutputInfo::generated_message_descriptor_data());
            messages.push(InputInfo::generated_message_descriptor_data());
            messages.push(TrainInfo::generated_message_descriptor_data());
            messages.push(EvalInfo::generated_message_descriptor_data());
            messages.push(ImportInfo::generated_message_descriptor_data());
            messages.push(OutputConfig::generated_message_descriptor_data());
            messages.push(ModelType::generated_message_descriptor_data());
            messages.push(ModelLayerInfo::generated_message_descriptor_data());
            messages.push(TritonCondaEnvInfo::generated_message_descriptor_data());
            messages.push(LayerShape::generated_message_descriptor_data());
            messages.push(ModelTypeField::generated_message_descriptor_data());
            messages.push(ModelTypeRangeInfo::generated_message_descriptor_data());
            messages.push(ModelTypeEnumOption::generated_message_descriptor_data());
            messages.push(ModelTypeEnumOptionAlias::generated_message_descriptor_data());
            messages.push(ModelQuery::generated_message_descriptor_data());
            messages.push(ModelVersion::generated_message_descriptor_data());
            messages.push(BuildInfo::generated_message_descriptor_data());
            messages.push(ModelVersionExport::generated_message_descriptor_data());
            messages.push(PretrainedModelConfig::generated_message_descriptor_data());
            messages.push(TrainStats::generated_message_descriptor_data());
            messages.push(LossCurveEntry::generated_message_descriptor_data());
            messages.push(LabelCount::generated_message_descriptor_data());
            messages.push(LabelDistribution::generated_message_descriptor_data());
            messages.push(CooccurrenceMatrixEntry::generated_message_descriptor_data());
            messages.push(CooccurrenceMatrix::generated_message_descriptor_data());
            messages.push(ConfusionMatrixEntry::generated_message_descriptor_data());
            messages.push(ConfusionMatrix::generated_message_descriptor_data());
            messages.push(ROC::generated_message_descriptor_data());
            messages.push(PrecisionRecallCurve::generated_message_descriptor_data());
            messages.push(BinaryMetrics::generated_message_descriptor_data());
            messages.push(TrackerMetrics::generated_message_descriptor_data());
            messages.push(EvalTestSetEntry::generated_message_descriptor_data());
            messages.push(LOPQEvalResult::generated_message_descriptor_data());
            messages.push(MetricsSummary::generated_message_descriptor_data());
            messages.push(EvalMetrics::generated_message_descriptor_data());
            messages.push(ExtendedMetrics::generated_message_descriptor_data());
            messages.push(FieldsValue::generated_message_descriptor_data());
            messages.push(Output::generated_message_descriptor_data());
            messages.push(ScopeDeps::generated_message_descriptor_data());
            messages.push(EndpointDeps::generated_message_descriptor_data());
            messages.push(Hit::generated_message_descriptor_data());
            messages.push(HitCount::generated_message_descriptor_data());
            messages.push(And::generated_message_descriptor_data());
            messages.push(Query::generated_message_descriptor_data());
            messages.push(Search::generated_message_descriptor_data());
            messages.push(Filter::generated_message_descriptor_data());
            messages.push(TimeRange::generated_message_descriptor_data());
            messages.push(Rank::generated_message_descriptor_data());
            messages.push(AnnotationSearchMetrics::generated_message_descriptor_data());
            messages.push(Text::generated_message_descriptor_data());
            messages.push(TextInfo::generated_message_descriptor_data());
            messages.push(User::generated_message_descriptor_data());
            messages.push(UserDetail::generated_message_descriptor_data());
            messages.push(EmailAddress::generated_message_descriptor_data());
            messages.push(Password::generated_message_descriptor_data());
            messages.push(PasswordViolations::generated_message_descriptor_data());
            messages.push(Video::generated_message_descriptor_data());
            messages.push(VideoInfo::generated_message_descriptor_data());
            messages.push(Workflow::generated_message_descriptor_data());
            messages.push(WorkflowVersion::generated_message_descriptor_data());
            messages.push(WorkflowNode::generated_message_descriptor_data());
            messages.push(NodeInput::generated_message_descriptor_data());
            messages.push(WorkflowResult::generated_message_descriptor_data());
            messages.push(WorkflowState::generated_message_descriptor_data());
            messages.push(AppDuplication::generated_message_descriptor_data());
            messages.push(AppCopyProgress::generated_message_descriptor_data());
            messages.push(AppDuplicationFilters::generated_message_descriptor_data());
            messages.push(LabelOrder::generated_message_descriptor_data());
            messages.push(Task::generated_message_descriptor_data());
            messages.push(AiAssistParameters::generated_message_descriptor_data());
            messages.push(TaskWorker::generated_message_descriptor_data());
            messages.push(TaskWorkerPartitionedStrategyInfo::generated_message_descriptor_data());
            messages.push(TaskInputSource::generated_message_descriptor_data());
            messages.push(TaskReview::generated_message_descriptor_data());
            messages.push(TaskReviewManualStrategyInfo::generated_message_descriptor_data());
            messages.push(TaskReviewConsensusStrategyInfo::generated_message_descriptor_data());
            messages.push(TaskAIAssistant::generated_message_descriptor_data());
            messages.push(TaskAssignment::generated_message_descriptor_data());
            messages.push(TaskStatusCountPerUser::generated_message_descriptor_data());
            messages.push(ThresholdRange::generated_message_descriptor_data());
            messages.push(TaskConceptAutoAnnotationConfig::generated_message_descriptor_data());
            messages.push(TaskConcept::generated_message_descriptor_data());
            messages.push(TaskMetrics::generated_message_descriptor_data());
            messages.push(TaskWorkMetrics::generated_message_descriptor_data());
            messages.push(Collector::generated_message_descriptor_data());
            messages.push(CollectorSource::generated_message_descriptor_data());
            messages.push(APIPostModelOutputsCollectorSource::generated_message_descriptor_data());
            messages.push(StatValue::generated_message_descriptor_data());
            messages.push(StatValueAggregateResult::generated_message_descriptor_data());
            messages.push(StatValueAggregate::generated_message_descriptor_data());
            messages.push(StatValueAggregateQuery::generated_message_descriptor_data());
            messages.push(PCAProjectionComparator::generated_message_descriptor_data());
            messages.push(DuplicateAnnotationsResults::generated_message_descriptor_data());
            messages.push(Visibility::generated_message_descriptor_data());
            messages.push(TrendingMetric::generated_message_descriptor_data());
            messages.push(FullTag::generated_message_descriptor_data());
            messages.push(TimeSegment::generated_message_descriptor_data());
            messages.push(TimeInfo::generated_message_descriptor_data());
            messages.push(DatasetStar::generated_message_descriptor_data());
            messages.push(ModuleStar::generated_message_descriptor_data());
            messages.push(Module::generated_message_descriptor_data());
            messages.push(ModuleVersion::generated_message_descriptor_data());
            messages.push(InstalledModuleVersion::generated_message_descriptor_data());
            messages.push(BulkOperation::generated_message_descriptor_data());
            messages.push(InputIDs::generated_message_descriptor_data());
            messages.push(Progress::generated_message_descriptor_data());
            messages.push(Operation::generated_message_descriptor_data());
            messages.push(AddConcepts::generated_message_descriptor_data());
            messages.push(DeleteConcepts::generated_message_descriptor_data());
            messages.push(AddMetadata::generated_message_descriptor_data());
            messages.push(DeleteMetadata::generated_message_descriptor_data());
            messages.push(OverwriteGeo::generated_message_descriptor_data());
            messages.push(DeleteGeo::generated_message_descriptor_data());
            messages.push(AddToDataset::generated_message_descriptor_data());
            messages.push(DeleteFromDataset::generated_message_descriptor_data());
            messages.push(SplitIntoDatasets::generated_message_descriptor_data());
            messages.push(DatasetSplit::generated_message_descriptor_data());
            messages.push(InputsAddJob::generated_message_descriptor_data());
            messages.push(InputsAddJobProgress::generated_message_descriptor_data());
            messages.push(Upload::generated_message_descriptor_data());
            messages.push(UploadContentPart::generated_message_descriptor_data());
            messages.push(CustomCodeOperatorRequest::generated_message_descriptor_data());
            messages.push(InputsExtractionJob::generated_message_descriptor_data());
            messages.push(InputsExtractionJobProgress::generated_message_descriptor_data());
            messages.push(InputsDataSource::generated_message_descriptor_data());
            messages.push(DataSourceURL::generated_message_descriptor_data());
            messages.push(DataSourceCredentials::generated_message_descriptor_data());
            messages.push(AWSCreds::generated_message_descriptor_data());
            messages.push(AzureBlobCreds::generated_message_descriptor_data());
            messages.push(InputsUpload::generated_message_descriptor_data());
            messages.push(BookmarkOrigin::generated_message_descriptor_data());
            messages.push(Runner::generated_message_descriptor_data());
            messages.push(Nodepool::generated_message_descriptor_data());
            messages.push(CloudRegion::generated_message_descriptor_data());
            messages.push(ComputeInfo::generated_message_descriptor_data());
            messages.push(AutoscaleConfig::generated_message_descriptor_data());
            messages.push(Deployment::generated_message_descriptor_data());
            messages.push(RunnerSelector::generated_message_descriptor_data());
            messages.push(ProcessingInfo::generated_message_descriptor_data());
            messages.push(module_version::ModuleSubNav::generated_message_descriptor_data());
            messages.push(module_version::ModuleNav::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(32);
            enums.push(WorkflowModelUseCase::generated_enum_descriptor_data());
            enums.push(DatasetVersionRequestOrigin::generated_enum_descriptor_data());
            enums.push(DatasetVersionMetricsGroupType::generated_enum_descriptor_data());
            enums.push(DatasetVersionExportFormat::generated_enum_descriptor_data());
            enums.push(ExpirationAction::generated_enum_descriptor_data());
            enums.push(LicenseScope::generated_enum_descriptor_data());
            enums.push(DataType::generated_enum_descriptor_data());
            enums.push(ValueComparator::generated_enum_descriptor_data());
            enums.push(EvaluationType::generated_enum_descriptor_data());
            enums.push(APIEventType::generated_enum_descriptor_data());
            enums.push(UsageIntervalType::generated_enum_descriptor_data());
            enums.push(AnnotationDataType::generated_enum_descriptor_data());
            enums.push(RoleType::generated_enum_descriptor_data());
            enums.push(StatValueAggType::generated_enum_descriptor_data());
            enums.push(StatTimeAggType::generated_enum_descriptor_data());
            enums.push(ValidationErrorType::generated_enum_descriptor_data());
            enums.push(InputIDConflictResolution::generated_enum_descriptor_data());
            enums.push(RunnerMethodType::generated_enum_descriptor_data());
            enums.push(point::Visibility::generated_enum_descriptor_data());
            enums.push(model_type_field::ModelTypeFieldType::generated_enum_descriptor_data());
            enums.push(search::Metric::generated_enum_descriptor_data());
            enums.push(task::TaskType::generated_enum_descriptor_data());
            enums.push(task_worker::TaskWorkerStrategy::generated_enum_descriptor_data());
            enums.push(task_worker_partitioned_strategy_info::TaskWorkerPartitionedStrategy::generated_enum_descriptor_data());
            enums.push(task_input_source::TaskInputSourceType::generated_enum_descriptor_data());
            enums.push(task_review::TaskReviewStrategy::generated_enum_descriptor_data());
            enums.push(visibility::Gettable::generated_enum_descriptor_data());
            enums.push(split_into_datasets::DatasetSplitMethod::generated_enum_descriptor_data());
            enums.push(bookmark_origin::BookmarkType::generated_enum_descriptor_data());
            enums.push(nodepool::CapacityType::generated_enum_descriptor_data());
            enums.push(cloud_region::Cloud::generated_enum_descriptor_data());
            enums.push(deployment::SchedulingChoice::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
