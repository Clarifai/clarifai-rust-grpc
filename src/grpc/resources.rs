// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/clarifai/api/resources.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct Annotation {
    // message fields
    pub id: ::std::string::String,
    pub input_id: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<Data>,
    pub annotation_info: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub user_id: ::std::string::String,
    pub model_version_id: ::std::string::String,
    pub embed_model_version_id: ::std::string::String,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub trusted: bool,
    pub input_level: bool,
    pub consensus_info: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub task_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Annotation {
    fn default() -> &'a Annotation {
        <Annotation as ::protobuf::Message>::default_instance()
    }
}

impl Annotation {
    pub fn new() -> Annotation {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string input_id = 2;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }

    // .clarifai.api.Data data = 3;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // .google.protobuf.Struct annotation_info = 13;


    pub fn get_annotation_info(&self) -> &::protobuf::well_known_types::Struct {
        self.annotation_info.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_annotation_info(&mut self) {
        self.annotation_info.clear();
    }

    pub fn has_annotation_info(&self) -> bool {
        self.annotation_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_annotation_info(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.annotation_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation_info(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.annotation_info.is_none() {
            self.annotation_info.set_default();
        }
        self.annotation_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_annotation_info(&mut self) -> ::protobuf::well_known_types::Struct {
        self.annotation_info.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string user_id = 15;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // string model_version_id = 16;


    pub fn get_model_version_id(&self) -> &str {
        &self.model_version_id
    }
    pub fn clear_model_version_id(&mut self) {
        self.model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_id(&mut self, v: ::std::string::String) {
        self.model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_version_id
    }

    // Take field
    pub fn take_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_version_id, ::std::string::String::new())
    }

    // string embed_model_version_id = 14;


    pub fn get_embed_model_version_id(&self) -> &str {
        &self.embed_model_version_id
    }
    pub fn clear_embed_model_version_id(&mut self) {
        self.embed_model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_embed_model_version_id(&mut self, v: ::std::string::String) {
        self.embed_model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_embed_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.embed_model_version_id
    }

    // Take field
    pub fn take_embed_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.embed_model_version_id, ::std::string::String::new())
    }

    // .clarifai.api.status.Status status = 7;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .google.protobuf.Timestamp created_at = 8;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 9;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool trusted = 10;


    pub fn get_trusted(&self) -> bool {
        self.trusted
    }
    pub fn clear_trusted(&mut self) {
        self.trusted = false;
    }

    // Param is passed by value, moved
    pub fn set_trusted(&mut self, v: bool) {
        self.trusted = v;
    }

    // bool input_level = 17;


    pub fn get_input_level(&self) -> bool {
        self.input_level
    }
    pub fn clear_input_level(&mut self) {
        self.input_level = false;
    }

    // Param is passed by value, moved
    pub fn set_input_level(&mut self, v: bool) {
        self.input_level = v;
    }

    // .google.protobuf.Struct consensus_info = 18;


    pub fn get_consensus_info(&self) -> &::protobuf::well_known_types::Struct {
        self.consensus_info.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consensus_info(&mut self) {
        self.consensus_info.clear();
    }

    pub fn has_consensus_info(&self) -> bool {
        self.consensus_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consensus_info(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.consensus_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consensus_info(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.consensus_info.is_none() {
            self.consensus_info.set_default();
        }
        self.consensus_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_consensus_info(&mut self) -> ::protobuf::well_known_types::Struct {
        self.consensus_info.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string task_id = 19;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Annotation {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consensus_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotation_info)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_version_id)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.embed_model_version_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trusted = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.input_level = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consensus_info)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.annotation_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.user_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.model_version_id);
        }
        if !self.embed_model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.embed_model_version_id);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.trusted != false {
            my_size += 2;
        }
        if self.input_level != false {
            my_size += 3;
        }
        if let Some(ref v) = self.consensus_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.annotation_info.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(15, &self.user_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(16, &self.model_version_id)?;
        }
        if !self.embed_model_version_id.is_empty() {
            os.write_string(14, &self.embed_model_version_id)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.trusted != false {
            os.write_bool(10, self.trusted)?;
        }
        if self.input_level != false {
            os.write_bool(17, self.input_level)?;
        }
        if let Some(ref v) = self.consensus_info.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(19, &self.task_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Annotation {
        Annotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Annotation| { &m.id },
                |m: &mut Annotation| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &Annotation| { &m.input_id },
                |m: &mut Annotation| { &mut m.input_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &Annotation| { &m.data },
                |m: &mut Annotation| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "annotation_info",
                |m: &Annotation| { &m.annotation_info },
                |m: &mut Annotation| { &mut m.annotation_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &Annotation| { &m.user_id },
                |m: &mut Annotation| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_id",
                |m: &Annotation| { &m.model_version_id },
                |m: &mut Annotation| { &mut m.model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "embed_model_version_id",
                |m: &Annotation| { &m.embed_model_version_id },
                |m: &mut Annotation| { &mut m.embed_model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &Annotation| { &m.status },
                |m: &mut Annotation| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Annotation| { &m.created_at },
                |m: &mut Annotation| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &Annotation| { &m.modified_at },
                |m: &mut Annotation| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trusted",
                |m: &Annotation| { &m.trusted },
                |m: &mut Annotation| { &mut m.trusted },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "input_level",
                |m: &Annotation| { &m.input_level },
                |m: &mut Annotation| { &mut m.input_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "consensus_info",
                |m: &Annotation| { &m.consensus_info },
                |m: &mut Annotation| { &mut m.consensus_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &Annotation| { &m.task_id },
                |m: &mut Annotation| { &mut m.task_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Annotation>(
                "Annotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Annotation {
        static instance: ::protobuf::rt::LazyV2<Annotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Annotation::new)
    }
}

impl ::protobuf::Clear for Annotation {
    fn clear(&mut self) {
        self.id.clear();
        self.input_id.clear();
        self.data.clear();
        self.annotation_info.clear();
        self.user_id.clear();
        self.model_version_id.clear();
        self.embed_model_version_id.clear();
        self.status.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.trusted = false;
        self.input_level = false;
        self.consensus_info.clear();
        self.task_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Annotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct App {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub default_language: ::std::string::String,
    pub default_workflow_id: ::std::string::String,
    pub user_id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub legal_consent_status: u32,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub description: ::std::string::String,
    pub sample_ms: u32,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub data_tier_id: ::std::string::String,
    pub is_starred: bool,
    pub star_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a App {
    fn default() -> &'a App {
        <App as ::protobuf::Message>::default_instance()
    }
}

impl App {
    pub fn new() -> App {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string default_language = 3;


    pub fn get_default_language(&self) -> &str {
        &self.default_language
    }
    pub fn clear_default_language(&mut self) {
        self.default_language.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_language(&mut self, v: ::std::string::String) {
        self.default_language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_language(&mut self) -> &mut ::std::string::String {
        &mut self.default_language
    }

    // Take field
    pub fn take_default_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_language, ::std::string::String::new())
    }

    // string default_workflow_id = 4;


    pub fn get_default_workflow_id(&self) -> &str {
        &self.default_workflow_id
    }
    pub fn clear_default_workflow_id(&mut self) {
        self.default_workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_workflow_id(&mut self, v: ::std::string::String) {
        self.default_workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.default_workflow_id
    }

    // Take field
    pub fn take_default_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_workflow_id, ::std::string::String::new())
    }

    // string user_id = 5;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 6;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 17;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // uint32 legal_consent_status = 7;


    pub fn get_legal_consent_status(&self) -> u32 {
        self.legal_consent_status
    }
    pub fn clear_legal_consent_status(&mut self) {
        self.legal_consent_status = 0;
    }

    // Param is passed by value, moved
    pub fn set_legal_consent_status(&mut self, v: u32) {
        self.legal_consent_status = v;
    }

    // .google.protobuf.Struct metadata = 13;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string description = 14;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // uint32 sample_ms = 15;


    pub fn get_sample_ms(&self) -> u32 {
        self.sample_ms
    }
    pub fn clear_sample_ms(&mut self) {
        self.sample_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_sample_ms(&mut self, v: u32) {
        self.sample_ms = v;
    }

    // .clarifai.api.Visibility visibility = 16;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // string data_tier_id = 18;


    pub fn get_data_tier_id(&self) -> &str {
        &self.data_tier_id
    }
    pub fn clear_data_tier_id(&mut self) {
        self.data_tier_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_tier_id(&mut self, v: ::std::string::String) {
        self.data_tier_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_tier_id(&mut self) -> &mut ::std::string::String {
        &mut self.data_tier_id
    }

    // Take field
    pub fn take_data_tier_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data_tier_id, ::std::string::String::new())
    }

    // bool is_starred = 19;


    pub fn get_is_starred(&self) -> bool {
        self.is_starred
    }
    pub fn clear_is_starred(&mut self) {
        self.is_starred = false;
    }

    // Param is passed by value, moved
    pub fn set_is_starred(&mut self, v: bool) {
        self.is_starred = v;
    }

    // int32 star_count = 20;


    pub fn get_star_count(&self) -> i32 {
        self.star_count
    }
    pub fn clear_star_count(&mut self) {
        self.star_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_star_count(&mut self, v: i32) {
        self.star_count = v;
    }
}

impl ::protobuf::Message for App {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_language)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_workflow_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legal_consent_status = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sample_ms = tmp;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data_tier_id)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_starred = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.star_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.default_language.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.default_language);
        }
        if !self.default_workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.default_workflow_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.legal_consent_status != 0 {
            my_size += ::protobuf::rt::value_size(7, self.legal_consent_status, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.description);
        }
        if self.sample_ms != 0 {
            my_size += ::protobuf::rt::value_size(15, self.sample_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.data_tier_id.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.data_tier_id);
        }
        if self.is_starred != false {
            my_size += 3;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::value_size(20, self.star_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.default_language.is_empty() {
            os.write_string(3, &self.default_language)?;
        }
        if !self.default_workflow_id.is_empty() {
            os.write_string(4, &self.default_workflow_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(5, &self.user_id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.legal_consent_status != 0 {
            os.write_uint32(7, self.legal_consent_status)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.description.is_empty() {
            os.write_string(14, &self.description)?;
        }
        if self.sample_ms != 0 {
            os.write_uint32(15, self.sample_ms)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.data_tier_id.is_empty() {
            os.write_string(18, &self.data_tier_id)?;
        }
        if self.is_starred != false {
            os.write_bool(19, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(20, self.star_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> App {
        App::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &App| { &m.id },
                |m: &mut App| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &App| { &m.name },
                |m: &mut App| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_language",
                |m: &App| { &m.default_language },
                |m: &mut App| { &mut m.default_language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_workflow_id",
                |m: &App| { &m.default_workflow_id },
                |m: &mut App| { &mut m.default_workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &App| { &m.user_id },
                |m: &mut App| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &App| { &m.created_at },
                |m: &mut App| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &App| { &m.modified_at },
                |m: &mut App| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legal_consent_status",
                |m: &App| { &m.legal_consent_status },
                |m: &mut App| { &mut m.legal_consent_status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &App| { &m.metadata },
                |m: &mut App| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &App| { &m.description },
                |m: &mut App| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sample_ms",
                |m: &App| { &m.sample_ms },
                |m: &mut App| { &mut m.sample_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &App| { &m.visibility },
                |m: &mut App| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data_tier_id",
                |m: &App| { &m.data_tier_id },
                |m: &mut App| { &mut m.data_tier_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_starred",
                |m: &App| { &m.is_starred },
                |m: &mut App| { &mut m.is_starred },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "star_count",
                |m: &App| { &m.star_count },
                |m: &mut App| { &mut m.star_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<App>(
                "App",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static App {
        static instance: ::protobuf::rt::LazyV2<App> = ::protobuf::rt::LazyV2::INIT;
        instance.get(App::new)
    }
}

impl ::protobuf::Clear for App {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.default_language.clear();
        self.default_workflow_id.clear();
        self.user_id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.legal_consent_status = 0;
        self.metadata.clear();
        self.description.clear();
        self.sample_ms = 0;
        self.visibility.clear();
        self.data_tier_id.clear();
        self.is_starred = false;
        self.star_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for App {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppQuery {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppQuery {
    fn default() -> &'a AppQuery {
        <AppQuery as ::protobuf::Message>::default_instance()
    }
}

impl AppQuery {
    pub fn new() -> AppQuery {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AppQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppQuery {
        AppQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AppQuery| { &m.name },
                |m: &mut AppQuery| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppQuery>(
                "AppQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppQuery {
        static instance: ::protobuf::rt::LazyV2<AppQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppQuery::new)
    }
}

impl ::protobuf::Clear for AppQuery {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Collaborator {
    // message fields
    pub id: ::std::string::String,
    pub app: ::protobuf::SingularPtrField<App>,
    pub user: ::protobuf::SingularPtrField<User>,
    pub scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub deleted_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Collaborator {
    fn default() -> &'a Collaborator {
        <Collaborator as ::protobuf::Message>::default_instance()
    }
}

impl Collaborator {
    pub fn new() -> Collaborator {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.App app = 2;


    pub fn get_app(&self) -> &App {
        self.app.as_ref().unwrap_or_else(|| <App as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: App) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut App {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> App {
        self.app.take().unwrap_or_else(|| App::new())
    }

    // .clarifai.api.User user = 3;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // repeated string scopes = 4;


    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    // repeated string endpoints = 5;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp created_at = 6;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 7;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp deleted_at = 8;


    pub fn get_deleted_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.deleted_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deleted_at(&mut self) {
        self.deleted_at.clear();
    }

    pub fn has_deleted_at(&self) -> bool {
        self.deleted_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.deleted_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deleted_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.deleted_at.is_none() {
            self.deleted_at.set_default();
        }
        self.deleted_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_deleted_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.deleted_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Collaborator {
    fn is_initialized(&self) -> bool {
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deleted_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deleted_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deleted_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.scopes {
            os.write_string(4, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(5, &v)?;
        };
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deleted_at.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Collaborator {
        Collaborator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Collaborator| { &m.id },
                |m: &mut Collaborator| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<App>>(
                "app",
                |m: &Collaborator| { &m.app },
                |m: &mut Collaborator| { &mut m.app },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &Collaborator| { &m.user },
                |m: &mut Collaborator| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &Collaborator| { &m.scopes },
                |m: &mut Collaborator| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &Collaborator| { &m.endpoints },
                |m: &mut Collaborator| { &mut m.endpoints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Collaborator| { &m.created_at },
                |m: &mut Collaborator| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &Collaborator| { &m.modified_at },
                |m: &mut Collaborator| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "deleted_at",
                |m: &Collaborator| { &m.deleted_at },
                |m: &mut Collaborator| { &mut m.deleted_at },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Collaborator>(
                "Collaborator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Collaborator {
        static instance: ::protobuf::rt::LazyV2<Collaborator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Collaborator::new)
    }
}

impl ::protobuf::Clear for Collaborator {
    fn clear(&mut self) {
        self.id.clear();
        self.app.clear();
        self.user.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.deleted_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Collaborator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collaborator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Collaboration {
    // message fields
    pub app: ::protobuf::SingularPtrField<App>,
    pub app_owner: ::protobuf::SingularPtrField<User>,
    pub scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Collaboration {
    fn default() -> &'a Collaboration {
        <Collaboration as ::protobuf::Message>::default_instance()
    }
}

impl Collaboration {
    pub fn new() -> Collaboration {
        ::std::default::Default::default()
    }

    // .clarifai.api.App app = 1;


    pub fn get_app(&self) -> &App {
        self.app.as_ref().unwrap_or_else(|| <App as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: App) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut App {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> App {
        self.app.take().unwrap_or_else(|| App::new())
    }

    // .clarifai.api.User app_owner = 2;


    pub fn get_app_owner(&self) -> &User {
        self.app_owner.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app_owner(&mut self) {
        self.app_owner.clear();
    }

    pub fn has_app_owner(&self) -> bool {
        self.app_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_owner(&mut self, v: User) {
        self.app_owner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_owner(&mut self) -> &mut User {
        if self.app_owner.is_none() {
            self.app_owner.set_default();
        }
        self.app_owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_owner(&mut self) -> User {
        self.app_owner.take().unwrap_or_else(|| User::new())
    }

    // repeated string scopes = 3;


    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    // repeated string endpoints = 4;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp created_at = 5;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Collaboration {
    fn is_initialized(&self) -> bool {
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_owner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app_owner)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.app_owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.app_owner.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.scopes {
            os.write_string(3, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Collaboration {
        Collaboration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<App>>(
                "app",
                |m: &Collaboration| { &m.app },
                |m: &mut Collaboration| { &mut m.app },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "app_owner",
                |m: &Collaboration| { &m.app_owner },
                |m: &mut Collaboration| { &mut m.app_owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &Collaboration| { &m.scopes },
                |m: &mut Collaboration| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &Collaboration| { &m.endpoints },
                |m: &mut Collaboration| { &mut m.endpoints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Collaboration| { &m.created_at },
                |m: &mut Collaboration| { &mut m.created_at },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Collaboration>(
                "Collaboration",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Collaboration {
        static instance: ::protobuf::rt::LazyV2<Collaboration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Collaboration::new)
    }
}

impl ::protobuf::Clear for Collaboration {
    fn clear(&mut self) {
        self.app.clear();
        self.app_owner.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.created_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Collaboration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collaboration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Audio {
    // message fields
    pub url: ::std::string::String,
    pub base64: ::std::vec::Vec<u8>,
    pub allow_duplicate_url: bool,
    pub hosted: ::protobuf::SingularPtrField<HostedURL>,
    pub audio_info: ::protobuf::SingularPtrField<AudioInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Audio {
    fn default() -> &'a Audio {
        <Audio as ::protobuf::Message>::default_instance()
    }
}

impl Audio {
    pub fn new() -> Audio {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // bytes base64 = 2;


    pub fn get_base64(&self) -> &[u8] {
        &self.base64
    }
    pub fn clear_base64(&mut self) {
        self.base64.clear();
    }

    // Param is passed by value, moved
    pub fn set_base64(&mut self, v: ::std::vec::Vec<u8>) {
        self.base64 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base64(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.base64
    }

    // Take field
    pub fn take_base64(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.base64, ::std::vec::Vec::new())
    }

    // bool allow_duplicate_url = 4;


    pub fn get_allow_duplicate_url(&self) -> bool {
        self.allow_duplicate_url
    }
    pub fn clear_allow_duplicate_url(&mut self) {
        self.allow_duplicate_url = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_duplicate_url(&mut self, v: bool) {
        self.allow_duplicate_url = v;
    }

    // .clarifai.api.HostedURL hosted = 5;


    pub fn get_hosted(&self) -> &HostedURL {
        self.hosted.as_ref().unwrap_or_else(|| <HostedURL as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hosted(&mut self) {
        self.hosted.clear();
    }

    pub fn has_hosted(&self) -> bool {
        self.hosted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hosted(&mut self, v: HostedURL) {
        self.hosted = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hosted(&mut self) -> &mut HostedURL {
        if self.hosted.is_none() {
            self.hosted.set_default();
        }
        self.hosted.as_mut().unwrap()
    }

    // Take field
    pub fn take_hosted(&mut self) -> HostedURL {
        self.hosted.take().unwrap_or_else(|| HostedURL::new())
    }

    // .clarifai.api.AudioInfo audio_info = 6;


    pub fn get_audio_info(&self) -> &AudioInfo {
        self.audio_info.as_ref().unwrap_or_else(|| <AudioInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_audio_info(&mut self) {
        self.audio_info.clear();
    }

    pub fn has_audio_info(&self) -> bool {
        self.audio_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_info(&mut self, v: AudioInfo) {
        self.audio_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audio_info(&mut self) -> &mut AudioInfo {
        if self.audio_info.is_none() {
            self.audio_info.set_default();
        }
        self.audio_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_audio_info(&mut self) -> AudioInfo {
        self.audio_info.take().unwrap_or_else(|| AudioInfo::new())
    }
}

impl ::protobuf::Message for Audio {
    fn is_initialized(&self) -> bool {
        for v in &self.hosted {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.audio_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.base64)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_duplicate_url = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hosted)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.audio_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.base64.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.base64);
        }
        if self.allow_duplicate_url != false {
            my_size += 2;
        }
        if let Some(ref v) = self.hosted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.audio_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.base64.is_empty() {
            os.write_bytes(2, &self.base64)?;
        }
        if self.allow_duplicate_url != false {
            os.write_bool(4, self.allow_duplicate_url)?;
        }
        if let Some(ref v) = self.hosted.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.audio_info.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Audio {
        Audio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Audio| { &m.url },
                |m: &mut Audio| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "base64",
                |m: &Audio| { &m.base64 },
                |m: &mut Audio| { &mut m.base64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_duplicate_url",
                |m: &Audio| { &m.allow_duplicate_url },
                |m: &mut Audio| { &mut m.allow_duplicate_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostedURL>>(
                "hosted",
                |m: &Audio| { &m.hosted },
                |m: &mut Audio| { &mut m.hosted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AudioInfo>>(
                "audio_info",
                |m: &Audio| { &m.audio_info },
                |m: &mut Audio| { &mut m.audio_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Audio>(
                "Audio",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Audio {
        static instance: ::protobuf::rt::LazyV2<Audio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Audio::new)
    }
}

impl ::protobuf::Clear for Audio {
    fn clear(&mut self) {
        self.url.clear();
        self.base64.clear();
        self.allow_duplicate_url = false;
        self.hosted.clear();
        self.audio_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Audio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Audio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AudioInfo {
    // message fields
    pub audio_format: ::std::string::String,
    pub sample_rate: i32,
    pub duration_seconds: f32,
    pub bit_rate: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AudioInfo {
    fn default() -> &'a AudioInfo {
        <AudioInfo as ::protobuf::Message>::default_instance()
    }
}

impl AudioInfo {
    pub fn new() -> AudioInfo {
        ::std::default::Default::default()
    }

    // string audio_format = 1;


    pub fn get_audio_format(&self) -> &str {
        &self.audio_format
    }
    pub fn clear_audio_format(&mut self) {
        self.audio_format.clear();
    }

    // Param is passed by value, moved
    pub fn set_audio_format(&mut self, v: ::std::string::String) {
        self.audio_format = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audio_format(&mut self) -> &mut ::std::string::String {
        &mut self.audio_format
    }

    // Take field
    pub fn take_audio_format(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.audio_format, ::std::string::String::new())
    }

    // int32 sample_rate = 2;


    pub fn get_sample_rate(&self) -> i32 {
        self.sample_rate
    }
    pub fn clear_sample_rate(&mut self) {
        self.sample_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_sample_rate(&mut self, v: i32) {
        self.sample_rate = v;
    }

    // float duration_seconds = 3;


    pub fn get_duration_seconds(&self) -> f32 {
        self.duration_seconds
    }
    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = 0.;
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: f32) {
        self.duration_seconds = v;
    }

    // int32 bit_rate = 4;


    pub fn get_bit_rate(&self) -> i32 {
        self.bit_rate
    }
    pub fn clear_bit_rate(&mut self) {
        self.bit_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_bit_rate(&mut self, v: i32) {
        self.bit_rate = v;
    }
}

impl ::protobuf::Message for AudioInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.audio_format)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sample_rate = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration_seconds = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bit_rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.audio_format.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.audio_format);
        }
        if self.sample_rate != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sample_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.duration_seconds != 0. {
            my_size += 5;
        }
        if self.bit_rate != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bit_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.audio_format.is_empty() {
            os.write_string(1, &self.audio_format)?;
        }
        if self.sample_rate != 0 {
            os.write_int32(2, self.sample_rate)?;
        }
        if self.duration_seconds != 0. {
            os.write_float(3, self.duration_seconds)?;
        }
        if self.bit_rate != 0 {
            os.write_int32(4, self.bit_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AudioInfo {
        AudioInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audio_format",
                |m: &AudioInfo| { &m.audio_format },
                |m: &mut AudioInfo| { &mut m.audio_format },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sample_rate",
                |m: &AudioInfo| { &m.sample_rate },
                |m: &mut AudioInfo| { &mut m.sample_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "duration_seconds",
                |m: &AudioInfo| { &m.duration_seconds },
                |m: &mut AudioInfo| { &mut m.duration_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bit_rate",
                |m: &AudioInfo| { &m.bit_rate },
                |m: &mut AudioInfo| { &mut m.bit_rate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AudioInfo>(
                "AudioInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AudioInfo {
        static instance: ::protobuf::rt::LazyV2<AudioInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AudioInfo::new)
    }
}

impl ::protobuf::Clear for AudioInfo {
    fn clear(&mut self) {
        self.audio_format.clear();
        self.sample_rate = 0;
        self.duration_seconds = 0.;
        self.bit_rate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AudioInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Track {
    // message fields
    pub id: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<Data>,
    pub time_info: ::protobuf::SingularPtrField<TimeInfo>,
    pub quality: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Track {
    fn default() -> &'a Track {
        <Track as ::protobuf::Message>::default_instance()
    }
}

impl Track {
    pub fn new() -> Track {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Data data = 2;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // .clarifai.api.TimeInfo time_info = 4;


    pub fn get_time_info(&self) -> &TimeInfo {
        self.time_info.as_ref().unwrap_or_else(|| <TimeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_info(&mut self) {
        self.time_info.clear();
    }

    pub fn has_time_info(&self) -> bool {
        self.time_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_info(&mut self, v: TimeInfo) {
        self.time_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_info(&mut self) -> &mut TimeInfo {
        if self.time_info.is_none() {
            self.time_info.set_default();
        }
        self.time_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_info(&mut self) -> TimeInfo {
        self.time_info.take().unwrap_or_else(|| TimeInfo::new())
    }

    // float quality = 5;


    pub fn get_quality(&self) -> f32 {
        self.quality
    }
    pub fn clear_quality(&mut self) {
        self.quality = 0.;
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: f32) {
        self.quality = v;
    }
}

impl ::protobuf::Message for Track {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_info)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.quality = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.quality != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time_info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.quality != 0. {
            os.write_float(5, self.quality)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Track {
        Track::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Track| { &m.id },
                |m: &mut Track| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &Track| { &m.data },
                |m: &mut Track| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeInfo>>(
                "time_info",
                |m: &Track| { &m.time_info },
                |m: &mut Track| { &mut m.time_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "quality",
                |m: &Track| { &m.quality },
                |m: &mut Track| { &mut m.quality },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Track>(
                "Track",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Track {
        static instance: ::protobuf::rt::LazyV2<Track> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Track::new)
    }
}

impl ::protobuf::Clear for Track {
    fn clear(&mut self) {
        self.id.clear();
        self.data.clear();
        self.time_info.clear();
        self.quality = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Track {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Track {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cluster {
    // message fields
    pub id: ::std::string::String,
    pub count: u32,
    pub score: f32,
    pub hits: ::protobuf::RepeatedField<Hit>,
    pub projection: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cluster {
    fn default() -> &'a Cluster {
        <Cluster as ::protobuf::Message>::default_instance()
    }
}

impl Cluster {
    pub fn new() -> Cluster {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // uint32 count = 2;


    pub fn get_count(&self) -> u32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = v;
    }

    // float score = 3;


    pub fn get_score(&self) -> f32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = v;
    }

    // repeated .clarifai.api.Hit hits = 4;


    pub fn get_hits(&self) -> &[Hit] {
        &self.hits
    }
    pub fn clear_hits(&mut self) {
        self.hits.clear();
    }

    // Param is passed by value, moved
    pub fn set_hits(&mut self, v: ::protobuf::RepeatedField<Hit>) {
        self.hits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hits(&mut self) -> &mut ::protobuf::RepeatedField<Hit> {
        &mut self.hits
    }

    // Take field
    pub fn take_hits(&mut self) -> ::protobuf::RepeatedField<Hit> {
        ::std::mem::replace(&mut self.hits, ::protobuf::RepeatedField::new())
    }

    // repeated float projection = 5;


    pub fn get_projection(&self) -> &[f32] {
        &self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection.clear();
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: ::std::vec::Vec<f32>) {
        self.projection = v;
    }

    // Mutable pointer to the field.
    pub fn mut_projection(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.projection
    }

    // Take field
    pub fn take_projection(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.projection, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Cluster {
    fn is_initialized(&self) -> bool {
        for v in &self.hits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hits)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.projection)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.score != 0. {
            my_size += 5;
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 5 * self.projection.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.count != 0 {
            os.write_uint32(2, self.count)?;
        }
        if self.score != 0. {
            os.write_float(3, self.score)?;
        }
        for v in &self.hits {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.projection {
            os.write_float(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cluster {
        Cluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Cluster| { &m.id },
                |m: &mut Cluster| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &Cluster| { &m.count },
                |m: &mut Cluster| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &Cluster| { &m.score },
                |m: &mut Cluster| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hit>>(
                "hits",
                |m: &Cluster| { &m.hits },
                |m: &mut Cluster| { &mut m.hits },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "projection",
                |m: &Cluster| { &m.projection },
                |m: &mut Cluster| { &mut m.projection },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cluster>(
                "Cluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cluster {
        static instance: ::protobuf::rt::LazyV2<Cluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cluster::new)
    }
}

impl ::protobuf::Clear for Cluster {
    fn clear(&mut self) {
        self.id.clear();
        self.count = 0;
        self.score = 0.;
        self.hits.clear();
        self.projection.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Color {
    // message fields
    pub raw_hex: ::std::string::String,
    pub w3c: ::protobuf::SingularPtrField<W3C>,
    pub value: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Color {
    fn default() -> &'a Color {
        <Color as ::protobuf::Message>::default_instance()
    }
}

impl Color {
    pub fn new() -> Color {
        ::std::default::Default::default()
    }

    // string raw_hex = 1;


    pub fn get_raw_hex(&self) -> &str {
        &self.raw_hex
    }
    pub fn clear_raw_hex(&mut self) {
        self.raw_hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_hex(&mut self, v: ::std::string::String) {
        self.raw_hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_hex(&mut self) -> &mut ::std::string::String {
        &mut self.raw_hex
    }

    // Take field
    pub fn take_raw_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.raw_hex, ::std::string::String::new())
    }

    // .clarifai.api.W3C w3c = 2;


    pub fn get_w3c(&self) -> &W3C {
        self.w3c.as_ref().unwrap_or_else(|| <W3C as ::protobuf::Message>::default_instance())
    }
    pub fn clear_w3c(&mut self) {
        self.w3c.clear();
    }

    pub fn has_w3c(&self) -> bool {
        self.w3c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_w3c(&mut self, v: W3C) {
        self.w3c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_w3c(&mut self) -> &mut W3C {
        if self.w3c.is_none() {
            self.w3c.set_default();
        }
        self.w3c.as_mut().unwrap()
    }

    // Take field
    pub fn take_w3c(&mut self) -> W3C {
        self.w3c.take().unwrap_or_else(|| W3C::new())
    }

    // float value = 3;


    pub fn get_value(&self) -> f32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = v;
    }
}

impl ::protobuf::Message for Color {
    fn is_initialized(&self) -> bool {
        for v in &self.w3c {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.raw_hex)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.w3c)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.raw_hex.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.raw_hex);
        }
        if let Some(ref v) = self.w3c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.value != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.raw_hex.is_empty() {
            os.write_string(1, &self.raw_hex)?;
        }
        if let Some(ref v) = self.w3c.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.value != 0. {
            os.write_float(3, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Color {
        Color::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "raw_hex",
                |m: &Color| { &m.raw_hex },
                |m: &mut Color| { &mut m.raw_hex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<W3C>>(
                "w3c",
                |m: &Color| { &m.w3c },
                |m: &mut Color| { &mut m.w3c },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &Color| { &m.value },
                |m: &mut Color| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Color>(
                "Color",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Color {
        static instance: ::protobuf::rt::LazyV2<Color> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Color::new)
    }
}

impl ::protobuf::Clear for Color {
    fn clear(&mut self) {
        self.raw_hex.clear();
        self.w3c.clear();
        self.value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Color {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Color {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct W3C {
    // message fields
    pub hex: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a W3C {
    fn default() -> &'a W3C {
        <W3C as ::protobuf::Message>::default_instance()
    }
}

impl W3C {
    pub fn new() -> W3C {
        ::std::default::Default::default()
    }

    // string hex = 1;


    pub fn get_hex(&self) -> &str {
        &self.hex
    }
    pub fn clear_hex(&mut self) {
        self.hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_hex(&mut self, v: ::std::string::String) {
        self.hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hex(&mut self) -> &mut ::std::string::String {
        &mut self.hex
    }

    // Take field
    pub fn take_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hex, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for W3C {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hex)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hex.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hex);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hex.is_empty() {
            os.write_string(1, &self.hex)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> W3C {
        W3C::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hex",
                |m: &W3C| { &m.hex },
                |m: &mut W3C| { &mut m.hex },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &W3C| { &m.name },
                |m: &mut W3C| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<W3C>(
                "W3C",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static W3C {
        static instance: ::protobuf::rt::LazyV2<W3C> = ::protobuf::rt::LazyV2::INIT;
        instance.get(W3C::new)
    }
}

impl ::protobuf::Clear for W3C {
    fn clear(&mut self) {
        self.hex.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for W3C {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for W3C {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserAppIDSet {
    // message fields
    pub user_id: ::std::string::String,
    pub app_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserAppIDSet {
    fn default() -> &'a UserAppIDSet {
        <UserAppIDSet as ::protobuf::Message>::default_instance()
    }
}

impl UserAppIDSet {
    pub fn new() -> UserAppIDSet {
        ::std::default::Default::default()
    }

    // string user_id = 1;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // string app_id = 2;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserAppIDSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserAppIDSet {
        UserAppIDSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &UserAppIDSet| { &m.user_id },
                |m: &mut UserAppIDSet| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &UserAppIDSet| { &m.app_id },
                |m: &mut UserAppIDSet| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserAppIDSet>(
                "UserAppIDSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserAppIDSet {
        static instance: ::protobuf::rt::LazyV2<UserAppIDSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserAppIDSet::new)
    }
}

impl ::protobuf::Clear for UserAppIDSet {
    fn clear(&mut self) {
        self.user_id.clear();
        self.app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserAppIDSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAppIDSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAction {
    // message fields
    pub op: ::std::string::String,
    pub merge_conflict_resolution: ::std::string::String,
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAction {
    fn default() -> &'a PatchAction {
        <PatchAction as ::protobuf::Message>::default_instance()
    }
}

impl PatchAction {
    pub fn new() -> PatchAction {
        ::std::default::Default::default()
    }

    // string op = 1;


    pub fn get_op(&self) -> &str {
        &self.op
    }
    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::std::string::String) {
        self.op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut ::std::string::String {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op, ::std::string::String::new())
    }

    // string merge_conflict_resolution = 2;


    pub fn get_merge_conflict_resolution(&self) -> &str {
        &self.merge_conflict_resolution
    }
    pub fn clear_merge_conflict_resolution(&mut self) {
        self.merge_conflict_resolution.clear();
    }

    // Param is passed by value, moved
    pub fn set_merge_conflict_resolution(&mut self, v: ::std::string::String) {
        self.merge_conflict_resolution = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_conflict_resolution(&mut self) -> &mut ::std::string::String {
        &mut self.merge_conflict_resolution
    }

    // Take field
    pub fn take_merge_conflict_resolution(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.merge_conflict_resolution, ::std::string::String::new())
    }

    // string path = 3;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.merge_conflict_resolution)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.op);
        }
        if !self.merge_conflict_resolution.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.merge_conflict_resolution);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.op.is_empty() {
            os.write_string(1, &self.op)?;
        }
        if !self.merge_conflict_resolution.is_empty() {
            os.write_string(2, &self.merge_conflict_resolution)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAction {
        PatchAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "op",
                |m: &PatchAction| { &m.op },
                |m: &mut PatchAction| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "merge_conflict_resolution",
                |m: &PatchAction| { &m.merge_conflict_resolution },
                |m: &mut PatchAction| { &mut m.merge_conflict_resolution },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &PatchAction| { &m.path },
                |m: &mut PatchAction| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAction>(
                "PatchAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAction {
        static instance: ::protobuf::rt::LazyV2<PatchAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAction::new)
    }
}

impl ::protobuf::Clear for PatchAction {
    fn clear(&mut self) {
        self.op.clear();
        self.merge_conflict_resolution.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Concept {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub value: f32,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub language: ::std::string::String,
    pub app_id: ::std::string::String,
    pub definition: ::std::string::String,
    pub vocab_id: ::std::string::String,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub user_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Concept {
    fn default() -> &'a Concept {
        <Concept as ::protobuf::Message>::default_instance()
    }
}

impl Concept {
    pub fn new() -> Concept {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // float value = 3;


    pub fn get_value(&self) -> f32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = v;
    }

    // .google.protobuf.Timestamp created_at = 4;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string language = 5;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }

    // string app_id = 6;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string definition = 7;


    pub fn get_definition(&self) -> &str {
        &self.definition
    }
    pub fn clear_definition(&mut self) {
        self.definition.clear();
    }

    // Param is passed by value, moved
    pub fn set_definition(&mut self, v: ::std::string::String) {
        self.definition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_definition(&mut self) -> &mut ::std::string::String {
        &mut self.definition
    }

    // Take field
    pub fn take_definition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.definition, ::std::string::String::new())
    }

    // string vocab_id = 8;


    pub fn get_vocab_id(&self) -> &str {
        &self.vocab_id
    }
    pub fn clear_vocab_id(&mut self) {
        self.vocab_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_vocab_id(&mut self, v: ::std::string::String) {
        self.vocab_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vocab_id(&mut self) -> &mut ::std::string::String {
        &mut self.vocab_id
    }

    // Take field
    pub fn take_vocab_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vocab_id, ::std::string::String::new())
    }

    // .clarifai.api.Visibility visibility = 9;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // string user_id = 10;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Concept {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.definition)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vocab_id)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.value != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.language);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.app_id);
        }
        if !self.definition.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.definition);
        }
        if !self.vocab_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.vocab_id);
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.user_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.value != 0. {
            os.write_float(3, self.value)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.language.is_empty() {
            os.write_string(5, &self.language)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(6, &self.app_id)?;
        }
        if !self.definition.is_empty() {
            os.write_string(7, &self.definition)?;
        }
        if !self.vocab_id.is_empty() {
            os.write_string(8, &self.vocab_id)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(10, &self.user_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Concept {
        Concept::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Concept| { &m.id },
                |m: &mut Concept| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Concept| { &m.name },
                |m: &mut Concept| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &Concept| { &m.value },
                |m: &mut Concept| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Concept| { &m.created_at },
                |m: &mut Concept| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &Concept| { &m.language },
                |m: &mut Concept| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &Concept| { &m.app_id },
                |m: &mut Concept| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "definition",
                |m: &Concept| { &m.definition },
                |m: &mut Concept| { &mut m.definition },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vocab_id",
                |m: &Concept| { &m.vocab_id },
                |m: &mut Concept| { &mut m.vocab_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &Concept| { &m.visibility },
                |m: &mut Concept| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &Concept| { &m.user_id },
                |m: &mut Concept| { &mut m.user_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Concept>(
                "Concept",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Concept {
        static instance: ::protobuf::rt::LazyV2<Concept> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Concept::new)
    }
}

impl ::protobuf::Clear for Concept {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.value = 0.;
        self.created_at.clear();
        self.language.clear();
        self.app_id.clear();
        self.definition.clear();
        self.vocab_id.clear();
        self.visibility.clear();
        self.user_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Concept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Concept {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptCount {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub concept_type_count: ::protobuf::SingularPtrField<ConceptTypeCount>,
    pub detail_concept_count: ::protobuf::SingularPtrField<DetailConceptCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptCount {
    fn default() -> &'a ConceptCount {
        <ConceptCount as ::protobuf::Message>::default_instance()
    }
}

impl ConceptCount {
    pub fn new() -> ConceptCount {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .clarifai.api.ConceptTypeCount concept_type_count = 3;


    pub fn get_concept_type_count(&self) -> &ConceptTypeCount {
        self.concept_type_count.as_ref().unwrap_or_else(|| <ConceptTypeCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_concept_type_count(&mut self) {
        self.concept_type_count.clear();
    }

    pub fn has_concept_type_count(&self) -> bool {
        self.concept_type_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept_type_count(&mut self, v: ConceptTypeCount) {
        self.concept_type_count = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_type_count(&mut self) -> &mut ConceptTypeCount {
        if self.concept_type_count.is_none() {
            self.concept_type_count.set_default();
        }
        self.concept_type_count.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept_type_count(&mut self) -> ConceptTypeCount {
        self.concept_type_count.take().unwrap_or_else(|| ConceptTypeCount::new())
    }

    // .clarifai.api.DetailConceptCount detail_concept_count = 4;


    pub fn get_detail_concept_count(&self) -> &DetailConceptCount {
        self.detail_concept_count.as_ref().unwrap_or_else(|| <DetailConceptCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_detail_concept_count(&mut self) {
        self.detail_concept_count.clear();
    }

    pub fn has_detail_concept_count(&self) -> bool {
        self.detail_concept_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detail_concept_count(&mut self, v: DetailConceptCount) {
        self.detail_concept_count = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detail_concept_count(&mut self) -> &mut DetailConceptCount {
        if self.detail_concept_count.is_none() {
            self.detail_concept_count.set_default();
        }
        self.detail_concept_count.as_mut().unwrap()
    }

    // Take field
    pub fn take_detail_concept_count(&mut self) -> DetailConceptCount {
        self.detail_concept_count.take().unwrap_or_else(|| DetailConceptCount::new())
    }
}

impl ::protobuf::Message for ConceptCount {
    fn is_initialized(&self) -> bool {
        for v in &self.concept_type_count {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.detail_concept_count {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept_type_count)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.detail_concept_count)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.concept_type_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.detail_concept_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.concept_type_count.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.detail_concept_count.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptCount {
        ConceptCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ConceptCount| { &m.id },
                |m: &mut ConceptCount| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ConceptCount| { &m.name },
                |m: &mut ConceptCount| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConceptTypeCount>>(
                "concept_type_count",
                |m: &ConceptCount| { &m.concept_type_count },
                |m: &mut ConceptCount| { &mut m.concept_type_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DetailConceptCount>>(
                "detail_concept_count",
                |m: &ConceptCount| { &m.detail_concept_count },
                |m: &mut ConceptCount| { &mut m.detail_concept_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConceptCount>(
                "ConceptCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConceptCount {
        static instance: ::protobuf::rt::LazyV2<ConceptCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConceptCount::new)
    }
}

impl ::protobuf::Clear for ConceptCount {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.concept_type_count.clear();
        self.detail_concept_count.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptTypeCount {
    // message fields
    pub positive: u32,
    pub negative: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptTypeCount {
    fn default() -> &'a ConceptTypeCount {
        <ConceptTypeCount as ::protobuf::Message>::default_instance()
    }
}

impl ConceptTypeCount {
    pub fn new() -> ConceptTypeCount {
        ::std::default::Default::default()
    }

    // uint32 positive = 1;


    pub fn get_positive(&self) -> u32 {
        self.positive
    }
    pub fn clear_positive(&mut self) {
        self.positive = 0;
    }

    // Param is passed by value, moved
    pub fn set_positive(&mut self, v: u32) {
        self.positive = v;
    }

    // uint32 negative = 2;


    pub fn get_negative(&self) -> u32 {
        self.negative
    }
    pub fn clear_negative(&mut self) {
        self.negative = 0;
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: u32) {
        self.negative = v;
    }
}

impl ::protobuf::Message for ConceptTypeCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.positive = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.negative = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.positive != 0 {
            my_size += ::protobuf::rt::value_size(1, self.positive, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.negative != 0 {
            my_size += ::protobuf::rt::value_size(2, self.negative, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.positive != 0 {
            os.write_uint32(1, self.positive)?;
        }
        if self.negative != 0 {
            os.write_uint32(2, self.negative)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptTypeCount {
        ConceptTypeCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "positive",
                |m: &ConceptTypeCount| { &m.positive },
                |m: &mut ConceptTypeCount| { &mut m.positive },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "negative",
                |m: &ConceptTypeCount| { &m.negative },
                |m: &mut ConceptTypeCount| { &mut m.negative },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConceptTypeCount>(
                "ConceptTypeCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConceptTypeCount {
        static instance: ::protobuf::rt::LazyV2<ConceptTypeCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConceptTypeCount::new)
    }
}

impl ::protobuf::Clear for ConceptTypeCount {
    fn clear(&mut self) {
        self.positive = 0;
        self.negative = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptTypeCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptTypeCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DetailConceptCount {
    // message fields
    pub processed: ::protobuf::SingularPtrField<ConceptTypeCount>,
    pub to_process: ::protobuf::SingularPtrField<ConceptTypeCount>,
    pub errors: ::protobuf::SingularPtrField<ConceptTypeCount>,
    pub processing: ::protobuf::SingularPtrField<ConceptTypeCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DetailConceptCount {
    fn default() -> &'a DetailConceptCount {
        <DetailConceptCount as ::protobuf::Message>::default_instance()
    }
}

impl DetailConceptCount {
    pub fn new() -> DetailConceptCount {
        ::std::default::Default::default()
    }

    // .clarifai.api.ConceptTypeCount processed = 1;


    pub fn get_processed(&self) -> &ConceptTypeCount {
        self.processed.as_ref().unwrap_or_else(|| <ConceptTypeCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_processed(&mut self) {
        self.processed.clear();
    }

    pub fn has_processed(&self) -> bool {
        self.processed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processed(&mut self, v: ConceptTypeCount) {
        self.processed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_processed(&mut self) -> &mut ConceptTypeCount {
        if self.processed.is_none() {
            self.processed.set_default();
        }
        self.processed.as_mut().unwrap()
    }

    // Take field
    pub fn take_processed(&mut self) -> ConceptTypeCount {
        self.processed.take().unwrap_or_else(|| ConceptTypeCount::new())
    }

    // .clarifai.api.ConceptTypeCount to_process = 2;


    pub fn get_to_process(&self) -> &ConceptTypeCount {
        self.to_process.as_ref().unwrap_or_else(|| <ConceptTypeCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_to_process(&mut self) {
        self.to_process.clear();
    }

    pub fn has_to_process(&self) -> bool {
        self.to_process.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_process(&mut self, v: ConceptTypeCount) {
        self.to_process = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_process(&mut self) -> &mut ConceptTypeCount {
        if self.to_process.is_none() {
            self.to_process.set_default();
        }
        self.to_process.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_process(&mut self) -> ConceptTypeCount {
        self.to_process.take().unwrap_or_else(|| ConceptTypeCount::new())
    }

    // .clarifai.api.ConceptTypeCount errors = 3;


    pub fn get_errors(&self) -> &ConceptTypeCount {
        self.errors.as_ref().unwrap_or_else(|| <ConceptTypeCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    pub fn has_errors(&self) -> bool {
        self.errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ConceptTypeCount) {
        self.errors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errors(&mut self) -> &mut ConceptTypeCount {
        if self.errors.is_none() {
            self.errors.set_default();
        }
        self.errors.as_mut().unwrap()
    }

    // Take field
    pub fn take_errors(&mut self) -> ConceptTypeCount {
        self.errors.take().unwrap_or_else(|| ConceptTypeCount::new())
    }

    // .clarifai.api.ConceptTypeCount processing = 4;


    pub fn get_processing(&self) -> &ConceptTypeCount {
        self.processing.as_ref().unwrap_or_else(|| <ConceptTypeCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_processing(&mut self) {
        self.processing.clear();
    }

    pub fn has_processing(&self) -> bool {
        self.processing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processing(&mut self, v: ConceptTypeCount) {
        self.processing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_processing(&mut self) -> &mut ConceptTypeCount {
        if self.processing.is_none() {
            self.processing.set_default();
        }
        self.processing.as_mut().unwrap()
    }

    // Take field
    pub fn take_processing(&mut self) -> ConceptTypeCount {
        self.processing.take().unwrap_or_else(|| ConceptTypeCount::new())
    }
}

impl ::protobuf::Message for DetailConceptCount {
    fn is_initialized(&self) -> bool {
        for v in &self.processed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.to_process {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.errors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.processing {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.processed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.to_process)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.errors)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.processing)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.processed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.to_process.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.errors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.processing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.processed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.to_process.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.errors.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.processing.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetailConceptCount {
        DetailConceptCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConceptTypeCount>>(
                "processed",
                |m: &DetailConceptCount| { &m.processed },
                |m: &mut DetailConceptCount| { &mut m.processed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConceptTypeCount>>(
                "to_process",
                |m: &DetailConceptCount| { &m.to_process },
                |m: &mut DetailConceptCount| { &mut m.to_process },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConceptTypeCount>>(
                "errors",
                |m: &DetailConceptCount| { &m.errors },
                |m: &mut DetailConceptCount| { &mut m.errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConceptTypeCount>>(
                "processing",
                |m: &DetailConceptCount| { &m.processing },
                |m: &mut DetailConceptCount| { &mut m.processing },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DetailConceptCount>(
                "DetailConceptCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DetailConceptCount {
        static instance: ::protobuf::rt::LazyV2<DetailConceptCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DetailConceptCount::new)
    }
}

impl ::protobuf::Clear for DetailConceptCount {
    fn clear(&mut self) {
        self.processed.clear();
        self.to_process.clear();
        self.errors.clear();
        self.processing.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetailConceptCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailConceptCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptQuery {
    // message fields
    pub name: ::std::string::String,
    pub language: ::std::string::String,
    pub workflow_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptQuery {
    fn default() -> &'a ConceptQuery {
        <ConceptQuery as ::protobuf::Message>::default_instance()
    }
}

impl ConceptQuery {
    pub fn new() -> ConceptQuery {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string language = 2;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }

    // string workflow_id = 3;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConceptQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language);
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.workflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.language.is_empty() {
            os.write_string(2, &self.language)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(3, &self.workflow_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptQuery {
        ConceptQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ConceptQuery| { &m.name },
                |m: &mut ConceptQuery| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &ConceptQuery| { &m.language },
                |m: &mut ConceptQuery| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &ConceptQuery| { &m.workflow_id },
                |m: &mut ConceptQuery| { &mut m.workflow_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConceptQuery>(
                "ConceptQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConceptQuery {
        static instance: ::protobuf::rt::LazyV2<ConceptQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConceptQuery::new)
    }
}

impl ::protobuf::Clear for ConceptQuery {
    fn clear(&mut self) {
        self.name.clear();
        self.language.clear();
        self.workflow_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptRelation {
    // message fields
    pub id: ::std::string::String,
    pub subject_concept: ::protobuf::SingularPtrField<Concept>,
    pub object_concept: ::protobuf::SingularPtrField<Concept>,
    pub predicate: ::std::string::String,
    pub knowledge_graph_id: ::std::string::String,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptRelation {
    fn default() -> &'a ConceptRelation {
        <ConceptRelation as ::protobuf::Message>::default_instance()
    }
}

impl ConceptRelation {
    pub fn new() -> ConceptRelation {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Concept subject_concept = 2;


    pub fn get_subject_concept(&self) -> &Concept {
        self.subject_concept.as_ref().unwrap_or_else(|| <Concept as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subject_concept(&mut self) {
        self.subject_concept.clear();
    }

    pub fn has_subject_concept(&self) -> bool {
        self.subject_concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_concept(&mut self, v: Concept) {
        self.subject_concept = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject_concept(&mut self) -> &mut Concept {
        if self.subject_concept.is_none() {
            self.subject_concept.set_default();
        }
        self.subject_concept.as_mut().unwrap()
    }

    // Take field
    pub fn take_subject_concept(&mut self) -> Concept {
        self.subject_concept.take().unwrap_or_else(|| Concept::new())
    }

    // .clarifai.api.Concept object_concept = 3;


    pub fn get_object_concept(&self) -> &Concept {
        self.object_concept.as_ref().unwrap_or_else(|| <Concept as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_concept(&mut self) {
        self.object_concept.clear();
    }

    pub fn has_object_concept(&self) -> bool {
        self.object_concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_concept(&mut self, v: Concept) {
        self.object_concept = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_concept(&mut self) -> &mut Concept {
        if self.object_concept.is_none() {
            self.object_concept.set_default();
        }
        self.object_concept.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_concept(&mut self) -> Concept {
        self.object_concept.take().unwrap_or_else(|| Concept::new())
    }

    // string predicate = 4;


    pub fn get_predicate(&self) -> &str {
        &self.predicate
    }
    pub fn clear_predicate(&mut self) {
        self.predicate.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicate(&mut self, v: ::std::string::String) {
        self.predicate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predicate(&mut self) -> &mut ::std::string::String {
        &mut self.predicate
    }

    // Take field
    pub fn take_predicate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.predicate, ::std::string::String::new())
    }

    // string knowledge_graph_id = 5;


    pub fn get_knowledge_graph_id(&self) -> &str {
        &self.knowledge_graph_id
    }
    pub fn clear_knowledge_graph_id(&mut self) {
        self.knowledge_graph_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_knowledge_graph_id(&mut self, v: ::std::string::String) {
        self.knowledge_graph_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_knowledge_graph_id(&mut self) -> &mut ::std::string::String {
        &mut self.knowledge_graph_id
    }

    // Take field
    pub fn take_knowledge_graph_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.knowledge_graph_id, ::std::string::String::new())
    }

    // .clarifai.api.Visibility visibility = 6;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }
}

impl ::protobuf::Message for ConceptRelation {
    fn is_initialized(&self) -> bool {
        for v in &self.subject_concept {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.object_concept {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subject_concept)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_concept)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.predicate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.knowledge_graph_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.subject_concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.object_concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.predicate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.predicate);
        }
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.knowledge_graph_id);
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.subject_concept.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.object_concept.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.predicate.is_empty() {
            os.write_string(4, &self.predicate)?;
        }
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(5, &self.knowledge_graph_id)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptRelation {
        ConceptRelation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ConceptRelation| { &m.id },
                |m: &mut ConceptRelation| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Concept>>(
                "subject_concept",
                |m: &ConceptRelation| { &m.subject_concept },
                |m: &mut ConceptRelation| { &mut m.subject_concept },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Concept>>(
                "object_concept",
                |m: &ConceptRelation| { &m.object_concept },
                |m: &mut ConceptRelation| { &mut m.object_concept },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "predicate",
                |m: &ConceptRelation| { &m.predicate },
                |m: &mut ConceptRelation| { &mut m.predicate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "knowledge_graph_id",
                |m: &ConceptRelation| { &m.knowledge_graph_id },
                |m: &mut ConceptRelation| { &mut m.knowledge_graph_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &ConceptRelation| { &m.visibility },
                |m: &mut ConceptRelation| { &mut m.visibility },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConceptRelation>(
                "ConceptRelation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConceptRelation {
        static instance: ::protobuf::rt::LazyV2<ConceptRelation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConceptRelation::new)
    }
}

impl ::protobuf::Clear for ConceptRelation {
    fn clear(&mut self) {
        self.id.clear();
        self.subject_concept.clear();
        self.object_concept.clear();
        self.predicate.clear();
        self.knowledge_graph_id.clear();
        self.visibility.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptRelation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptRelation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KnowledgeGraph {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub examples_app_id: ::std::string::String,
    pub sampled_examples_app_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KnowledgeGraph {
    fn default() -> &'a KnowledgeGraph {
        <KnowledgeGraph as ::protobuf::Message>::default_instance()
    }
}

impl KnowledgeGraph {
    pub fn new() -> KnowledgeGraph {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string examples_app_id = 4;


    pub fn get_examples_app_id(&self) -> &str {
        &self.examples_app_id
    }
    pub fn clear_examples_app_id(&mut self) {
        self.examples_app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_examples_app_id(&mut self, v: ::std::string::String) {
        self.examples_app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_examples_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.examples_app_id
    }

    // Take field
    pub fn take_examples_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.examples_app_id, ::std::string::String::new())
    }

    // string sampled_examples_app_id = 5;


    pub fn get_sampled_examples_app_id(&self) -> &str {
        &self.sampled_examples_app_id
    }
    pub fn clear_sampled_examples_app_id(&mut self) {
        self.sampled_examples_app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_sampled_examples_app_id(&mut self, v: ::std::string::String) {
        self.sampled_examples_app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sampled_examples_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.sampled_examples_app_id
    }

    // Take field
    pub fn take_sampled_examples_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sampled_examples_app_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KnowledgeGraph {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.examples_app_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sampled_examples_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.examples_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.examples_app_id);
        }
        if !self.sampled_examples_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sampled_examples_app_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.examples_app_id.is_empty() {
            os.write_string(4, &self.examples_app_id)?;
        }
        if !self.sampled_examples_app_id.is_empty() {
            os.write_string(5, &self.sampled_examples_app_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KnowledgeGraph {
        KnowledgeGraph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &KnowledgeGraph| { &m.id },
                |m: &mut KnowledgeGraph| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &KnowledgeGraph| { &m.name },
                |m: &mut KnowledgeGraph| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &KnowledgeGraph| { &m.description },
                |m: &mut KnowledgeGraph| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "examples_app_id",
                |m: &KnowledgeGraph| { &m.examples_app_id },
                |m: &mut KnowledgeGraph| { &mut m.examples_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sampled_examples_app_id",
                |m: &KnowledgeGraph| { &m.sampled_examples_app_id },
                |m: &mut KnowledgeGraph| { &mut m.sampled_examples_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KnowledgeGraph>(
                "KnowledgeGraph",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KnowledgeGraph {
        static instance: ::protobuf::rt::LazyV2<KnowledgeGraph> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KnowledgeGraph::new)
    }
}

impl ::protobuf::Clear for KnowledgeGraph {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.description.clear();
        self.examples_app_id.clear();
        self.sampled_examples_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KnowledgeGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KnowledgeGraph {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptMappingJob {
    // message fields
    pub knowledge_graph_id: ::std::string::String,
    pub concept_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptMappingJob {
    fn default() -> &'a ConceptMappingJob {
        <ConceptMappingJob as ::protobuf::Message>::default_instance()
    }
}

impl ConceptMappingJob {
    pub fn new() -> ConceptMappingJob {
        ::std::default::Default::default()
    }

    // string knowledge_graph_id = 1;


    pub fn get_knowledge_graph_id(&self) -> &str {
        &self.knowledge_graph_id
    }
    pub fn clear_knowledge_graph_id(&mut self) {
        self.knowledge_graph_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_knowledge_graph_id(&mut self, v: ::std::string::String) {
        self.knowledge_graph_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_knowledge_graph_id(&mut self) -> &mut ::std::string::String {
        &mut self.knowledge_graph_id
    }

    // Take field
    pub fn take_knowledge_graph_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.knowledge_graph_id, ::std::string::String::new())
    }

    // repeated string concept_ids = 2;


    pub fn get_concept_ids(&self) -> &[::std::string::String] {
        &self.concept_ids
    }
    pub fn clear_concept_ids(&mut self) {
        self.concept_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concept_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concept_ids
    }

    // Take field
    pub fn take_concept_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concept_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConceptMappingJob {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.knowledge_graph_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concept_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.knowledge_graph_id);
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(1, &self.knowledge_graph_id)?;
        }
        for v in &self.concept_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptMappingJob {
        ConceptMappingJob::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "knowledge_graph_id",
                |m: &ConceptMappingJob| { &m.knowledge_graph_id },
                |m: &mut ConceptMappingJob| { &mut m.knowledge_graph_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_ids",
                |m: &ConceptMappingJob| { &m.concept_ids },
                |m: &mut ConceptMappingJob| { &mut m.concept_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConceptMappingJob>(
                "ConceptMappingJob",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConceptMappingJob {
        static instance: ::protobuf::rt::LazyV2<ConceptMappingJob> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConceptMappingJob::new)
    }
}

impl ::protobuf::Clear for ConceptMappingJob {
    fn clear(&mut self) {
        self.knowledge_graph_id.clear();
        self.concept_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptMappingJob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptMappingJob {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptLanguage {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub definition: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptLanguage {
    fn default() -> &'a ConceptLanguage {
        <ConceptLanguage as ::protobuf::Message>::default_instance()
    }
}

impl ConceptLanguage {
    pub fn new() -> ConceptLanguage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string definition = 3;


    pub fn get_definition(&self) -> &str {
        &self.definition
    }
    pub fn clear_definition(&mut self) {
        self.definition.clear();
    }

    // Param is passed by value, moved
    pub fn set_definition(&mut self, v: ::std::string::String) {
        self.definition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_definition(&mut self) -> &mut ::std::string::String {
        &mut self.definition
    }

    // Take field
    pub fn take_definition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.definition, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConceptLanguage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.definition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.definition.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.definition);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.definition.is_empty() {
            os.write_string(3, &self.definition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptLanguage {
        ConceptLanguage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ConceptLanguage| { &m.id },
                |m: &mut ConceptLanguage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ConceptLanguage| { &m.name },
                |m: &mut ConceptLanguage| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "definition",
                |m: &ConceptLanguage| { &m.definition },
                |m: &mut ConceptLanguage| { &mut m.definition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConceptLanguage>(
                "ConceptLanguage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConceptLanguage {
        static instance: ::protobuf::rt::LazyV2<ConceptLanguage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConceptLanguage::new)
    }
}

impl ::protobuf::Clear for ConceptLanguage {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.definition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptLanguage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptLanguage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Data {
    // message fields
    pub image: ::protobuf::SingularPtrField<Image>,
    pub video: ::protobuf::SingularPtrField<Video>,
    pub concepts: ::protobuf::RepeatedField<Concept>,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub geo: ::protobuf::SingularPtrField<Geo>,
    pub colors: ::protobuf::RepeatedField<Color>,
    pub clusters: ::protobuf::RepeatedField<Cluster>,
    pub embeddings: ::protobuf::RepeatedField<Embedding>,
    pub regions: ::protobuf::RepeatedField<Region>,
    pub frames: ::protobuf::RepeatedField<Frame>,
    pub text: ::protobuf::SingularPtrField<Text>,
    pub audio: ::protobuf::SingularPtrField<Audio>,
    pub tracks: ::protobuf::RepeatedField<Track>,
    pub time_segments: ::protobuf::RepeatedField<TimeSegment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Data {
    fn default() -> &'a Data {
        <Data as ::protobuf::Message>::default_instance()
    }
}

impl Data {
    pub fn new() -> Data {
        ::std::default::Default::default()
    }

    // .clarifai.api.Image image = 1;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut Image {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    // .clarifai.api.Video video = 2;


    pub fn get_video(&self) -> &Video {
        self.video.as_ref().unwrap_or_else(|| <Video as ::protobuf::Message>::default_instance())
    }
    pub fn clear_video(&mut self) {
        self.video.clear();
    }

    pub fn has_video(&self) -> bool {
        self.video.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video(&mut self, v: Video) {
        self.video = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video(&mut self) -> &mut Video {
        if self.video.is_none() {
            self.video.set_default();
        }
        self.video.as_mut().unwrap()
    }

    // Take field
    pub fn take_video(&mut self) -> Video {
        self.video.take().unwrap_or_else(|| Video::new())
    }

    // repeated .clarifai.api.Concept concepts = 3;


    pub fn get_concepts(&self) -> &[Concept] {
        &self.concepts
    }
    pub fn clear_concepts(&mut self) {
        self.concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concepts(&mut self, v: ::protobuf::RepeatedField<Concept>) {
        self.concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concepts(&mut self) -> &mut ::protobuf::RepeatedField<Concept> {
        &mut self.concepts
    }

    // Take field
    pub fn take_concepts(&mut self) -> ::protobuf::RepeatedField<Concept> {
        ::std::mem::replace(&mut self.concepts, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Struct metadata = 5;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .clarifai.api.Geo geo = 6;


    pub fn get_geo(&self) -> &Geo {
        self.geo.as_ref().unwrap_or_else(|| <Geo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_geo(&mut self) {
        self.geo.clear();
    }

    pub fn has_geo(&self) -> bool {
        self.geo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo(&mut self, v: Geo) {
        self.geo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geo(&mut self) -> &mut Geo {
        if self.geo.is_none() {
            self.geo.set_default();
        }
        self.geo.as_mut().unwrap()
    }

    // Take field
    pub fn take_geo(&mut self) -> Geo {
        self.geo.take().unwrap_or_else(|| Geo::new())
    }

    // repeated .clarifai.api.Color colors = 7;


    pub fn get_colors(&self) -> &[Color] {
        &self.colors
    }
    pub fn clear_colors(&mut self) {
        self.colors.clear();
    }

    // Param is passed by value, moved
    pub fn set_colors(&mut self, v: ::protobuf::RepeatedField<Color>) {
        self.colors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_colors(&mut self) -> &mut ::protobuf::RepeatedField<Color> {
        &mut self.colors
    }

    // Take field
    pub fn take_colors(&mut self) -> ::protobuf::RepeatedField<Color> {
        ::std::mem::replace(&mut self.colors, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.Cluster clusters = 8;


    pub fn get_clusters(&self) -> &[Cluster] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<Cluster>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<Cluster> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<Cluster> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.Embedding embeddings = 9;


    pub fn get_embeddings(&self) -> &[Embedding] {
        &self.embeddings
    }
    pub fn clear_embeddings(&mut self) {
        self.embeddings.clear();
    }

    // Param is passed by value, moved
    pub fn set_embeddings(&mut self, v: ::protobuf::RepeatedField<Embedding>) {
        self.embeddings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_embeddings(&mut self) -> &mut ::protobuf::RepeatedField<Embedding> {
        &mut self.embeddings
    }

    // Take field
    pub fn take_embeddings(&mut self) -> ::protobuf::RepeatedField<Embedding> {
        ::std::mem::replace(&mut self.embeddings, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.Region regions = 11;


    pub fn get_regions(&self) -> &[Region] {
        &self.regions
    }
    pub fn clear_regions(&mut self) {
        self.regions.clear();
    }

    // Param is passed by value, moved
    pub fn set_regions(&mut self, v: ::protobuf::RepeatedField<Region>) {
        self.regions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_regions(&mut self) -> &mut ::protobuf::RepeatedField<Region> {
        &mut self.regions
    }

    // Take field
    pub fn take_regions(&mut self) -> ::protobuf::RepeatedField<Region> {
        ::std::mem::replace(&mut self.regions, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.Frame frames = 12;


    pub fn get_frames(&self) -> &[Frame] {
        &self.frames
    }
    pub fn clear_frames(&mut self) {
        self.frames.clear();
    }

    // Param is passed by value, moved
    pub fn set_frames(&mut self, v: ::protobuf::RepeatedField<Frame>) {
        self.frames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frames(&mut self) -> &mut ::protobuf::RepeatedField<Frame> {
        &mut self.frames
    }

    // Take field
    pub fn take_frames(&mut self) -> ::protobuf::RepeatedField<Frame> {
        ::std::mem::replace(&mut self.frames, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Text text = 13;


    pub fn get_text(&self) -> &Text {
        self.text.as_ref().unwrap_or_else(|| <Text as ::protobuf::Message>::default_instance())
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Text) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut Text {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> Text {
        self.text.take().unwrap_or_else(|| Text::new())
    }

    // .clarifai.api.Audio audio = 14;


    pub fn get_audio(&self) -> &Audio {
        self.audio.as_ref().unwrap_or_else(|| <Audio as ::protobuf::Message>::default_instance())
    }
    pub fn clear_audio(&mut self) {
        self.audio.clear();
    }

    pub fn has_audio(&self) -> bool {
        self.audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio(&mut self, v: Audio) {
        self.audio = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audio(&mut self) -> &mut Audio {
        if self.audio.is_none() {
            self.audio.set_default();
        }
        self.audio.as_mut().unwrap()
    }

    // Take field
    pub fn take_audio(&mut self) -> Audio {
        self.audio.take().unwrap_or_else(|| Audio::new())
    }

    // repeated .clarifai.api.Track tracks = 15;


    pub fn get_tracks(&self) -> &[Track] {
        &self.tracks
    }
    pub fn clear_tracks(&mut self) {
        self.tracks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tracks(&mut self, v: ::protobuf::RepeatedField<Track>) {
        self.tracks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tracks(&mut self) -> &mut ::protobuf::RepeatedField<Track> {
        &mut self.tracks
    }

    // Take field
    pub fn take_tracks(&mut self) -> ::protobuf::RepeatedField<Track> {
        ::std::mem::replace(&mut self.tracks, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.TimeSegment time_segments = 16;


    pub fn get_time_segments(&self) -> &[TimeSegment] {
        &self.time_segments
    }
    pub fn clear_time_segments(&mut self) {
        self.time_segments.clear();
    }

    // Param is passed by value, moved
    pub fn set_time_segments(&mut self, v: ::protobuf::RepeatedField<TimeSegment>) {
        self.time_segments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_time_segments(&mut self) -> &mut ::protobuf::RepeatedField<TimeSegment> {
        &mut self.time_segments
    }

    // Take field
    pub fn take_time_segments(&mut self) -> ::protobuf::RepeatedField<TimeSegment> {
        ::std::mem::replace(&mut self.time_segments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Data {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.video {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.geo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.colors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.embeddings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.regions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frames {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.audio {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tracks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_segments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.video)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concepts)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geo)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.colors)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.embeddings)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.regions)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frames)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.audio)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tracks)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.time_segments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.video.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.geo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.embeddings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.regions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tracks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.time_segments {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.video.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concepts {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.geo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.colors {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.clusters {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.embeddings {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.regions {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.frames {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.audio.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tracks {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.time_segments {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Data {
        Data::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Data| { &m.image },
                |m: &mut Data| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Video>>(
                "video",
                |m: &Data| { &m.video },
                |m: &mut Data| { &mut m.video },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Concept>>(
                "concepts",
                |m: &Data| { &m.concepts },
                |m: &mut Data| { &mut m.concepts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &Data| { &m.metadata },
                |m: &mut Data| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Geo>>(
                "geo",
                |m: &Data| { &m.geo },
                |m: &mut Data| { &mut m.geo },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Color>>(
                "colors",
                |m: &Data| { &m.colors },
                |m: &mut Data| { &mut m.colors },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cluster>>(
                "clusters",
                |m: &Data| { &m.clusters },
                |m: &mut Data| { &mut m.clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Embedding>>(
                "embeddings",
                |m: &Data| { &m.embeddings },
                |m: &mut Data| { &mut m.embeddings },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Region>>(
                "regions",
                |m: &Data| { &m.regions },
                |m: &mut Data| { &mut m.regions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Frame>>(
                "frames",
                |m: &Data| { &m.frames },
                |m: &mut Data| { &mut m.frames },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Text>>(
                "text",
                |m: &Data| { &m.text },
                |m: &mut Data| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Audio>>(
                "audio",
                |m: &Data| { &m.audio },
                |m: &mut Data| { &mut m.audio },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Track>>(
                "tracks",
                |m: &Data| { &m.tracks },
                |m: &mut Data| { &mut m.tracks },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeSegment>>(
                "time_segments",
                |m: &Data| { &m.time_segments },
                |m: &mut Data| { &mut m.time_segments },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Data>(
                "Data",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Data {
        static instance: ::protobuf::rt::LazyV2<Data> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Data::new)
    }
}

impl ::protobuf::Clear for Data {
    fn clear(&mut self) {
        self.image.clear();
        self.video.clear();
        self.concepts.clear();
        self.metadata.clear();
        self.geo.clear();
        self.colors.clear();
        self.clusters.clear();
        self.embeddings.clear();
        self.regions.clear();
        self.frames.clear();
        self.text.clear();
        self.audio.clear();
        self.tracks.clear();
        self.time_segments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Data {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Data {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Region {
    // message fields
    pub id: ::std::string::String,
    pub region_info: ::protobuf::SingularPtrField<RegionInfo>,
    pub data: ::protobuf::SingularPtrField<Data>,
    pub value: f32,
    pub track_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Region {
    fn default() -> &'a Region {
        <Region as ::protobuf::Message>::default_instance()
    }
}

impl Region {
    pub fn new() -> Region {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.RegionInfo region_info = 2;


    pub fn get_region_info(&self) -> &RegionInfo {
        self.region_info.as_ref().unwrap_or_else(|| <RegionInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_region_info(&mut self) {
        self.region_info.clear();
    }

    pub fn has_region_info(&self) -> bool {
        self.region_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_info(&mut self, v: RegionInfo) {
        self.region_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_info(&mut self) -> &mut RegionInfo {
        if self.region_info.is_none() {
            self.region_info.set_default();
        }
        self.region_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_info(&mut self) -> RegionInfo {
        self.region_info.take().unwrap_or_else(|| RegionInfo::new())
    }

    // .clarifai.api.Data data = 3;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // float value = 4;


    pub fn get_value(&self) -> f32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = v;
    }

    // string track_id = 5;


    pub fn get_track_id(&self) -> &str {
        &self.track_id
    }
    pub fn clear_track_id(&mut self) {
        self.track_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_track_id(&mut self, v: ::std::string::String) {
        self.track_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_track_id(&mut self) -> &mut ::std::string::String {
        &mut self.track_id
    }

    // Take field
    pub fn take_track_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.track_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Region {
    fn is_initialized(&self) -> bool {
        for v in &self.region_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_info)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.track_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.region_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.value != 0. {
            my_size += 5;
        }
        if !self.track_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.track_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.region_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.value != 0. {
            os.write_float(4, self.value)?;
        }
        if !self.track_id.is_empty() {
            os.write_string(5, &self.track_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Region {
        Region::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Region| { &m.id },
                |m: &mut Region| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RegionInfo>>(
                "region_info",
                |m: &Region| { &m.region_info },
                |m: &mut Region| { &mut m.region_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &Region| { &m.data },
                |m: &mut Region| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &Region| { &m.value },
                |m: &mut Region| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "track_id",
                |m: &Region| { &m.track_id },
                |m: &mut Region| { &mut m.track_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Region>(
                "Region",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Region {
        static instance: ::protobuf::rt::LazyV2<Region> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Region::new)
    }
}

impl ::protobuf::Clear for Region {
    fn clear(&mut self) {
        self.id.clear();
        self.region_info.clear();
        self.data.clear();
        self.value = 0.;
        self.track_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Region {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Region {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegionInfo {
    // message fields
    pub bounding_box: ::protobuf::SingularPtrField<BoundingBox>,
    pub mask: ::protobuf::SingularPtrField<Mask>,
    pub polygon: ::protobuf::SingularPtrField<Polygon>,
    pub point: ::protobuf::SingularPtrField<Point>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegionInfo {
    fn default() -> &'a RegionInfo {
        <RegionInfo as ::protobuf::Message>::default_instance()
    }
}

impl RegionInfo {
    pub fn new() -> RegionInfo {
        ::std::default::Default::default()
    }

    // .clarifai.api.BoundingBox bounding_box = 1;


    pub fn get_bounding_box(&self) -> &BoundingBox {
        self.bounding_box.as_ref().unwrap_or_else(|| <BoundingBox as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bounding_box(&mut self) {
        self.bounding_box.clear();
    }

    pub fn has_bounding_box(&self) -> bool {
        self.bounding_box.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounding_box(&mut self, v: BoundingBox) {
        self.bounding_box = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bounding_box(&mut self) -> &mut BoundingBox {
        if self.bounding_box.is_none() {
            self.bounding_box.set_default();
        }
        self.bounding_box.as_mut().unwrap()
    }

    // Take field
    pub fn take_bounding_box(&mut self) -> BoundingBox {
        self.bounding_box.take().unwrap_or_else(|| BoundingBox::new())
    }

    // .clarifai.api.Mask mask = 4;


    pub fn get_mask(&self) -> &Mask {
        self.mask.as_ref().unwrap_or_else(|| <Mask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: Mask) {
        self.mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut Mask {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> Mask {
        self.mask.take().unwrap_or_else(|| Mask::new())
    }

    // .clarifai.api.Polygon polygon = 5;


    pub fn get_polygon(&self) -> &Polygon {
        self.polygon.as_ref().unwrap_or_else(|| <Polygon as ::protobuf::Message>::default_instance())
    }
    pub fn clear_polygon(&mut self) {
        self.polygon.clear();
    }

    pub fn has_polygon(&self) -> bool {
        self.polygon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_polygon(&mut self, v: Polygon) {
        self.polygon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_polygon(&mut self) -> &mut Polygon {
        if self.polygon.is_none() {
            self.polygon.set_default();
        }
        self.polygon.as_mut().unwrap()
    }

    // Take field
    pub fn take_polygon(&mut self) -> Polygon {
        self.polygon.take().unwrap_or_else(|| Polygon::new())
    }

    // .clarifai.api.Point point = 6;


    pub fn get_point(&self) -> &Point {
        self.point.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_point(&mut self) {
        self.point.clear();
    }

    pub fn has_point(&self) -> bool {
        self.point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point(&mut self, v: Point) {
        self.point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_point(&mut self) -> &mut Point {
        if self.point.is_none() {
            self.point.set_default();
        }
        self.point.as_mut().unwrap()
    }

    // Take field
    pub fn take_point(&mut self) -> Point {
        self.point.take().unwrap_or_else(|| Point::new())
    }
}

impl ::protobuf::Message for RegionInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.bounding_box {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.polygon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bounding_box)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mask)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.polygon)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bounding_box.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.polygon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bounding_box.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.polygon.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.point.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegionInfo {
        RegionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BoundingBox>>(
                "bounding_box",
                |m: &RegionInfo| { &m.bounding_box },
                |m: &mut RegionInfo| { &mut m.bounding_box },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Mask>>(
                "mask",
                |m: &RegionInfo| { &m.mask },
                |m: &mut RegionInfo| { &mut m.mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Polygon>>(
                "polygon",
                |m: &RegionInfo| { &m.polygon },
                |m: &mut RegionInfo| { &mut m.polygon },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "point",
                |m: &RegionInfo| { &m.point },
                |m: &mut RegionInfo| { &mut m.point },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegionInfo>(
                "RegionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegionInfo {
        static instance: ::protobuf::rt::LazyV2<RegionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegionInfo::new)
    }
}

impl ::protobuf::Clear for RegionInfo {
    fn clear(&mut self) {
        self.bounding_box.clear();
        self.mask.clear();
        self.polygon.clear();
        self.point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BoundingBox {
    // message fields
    pub top_row: f32,
    pub left_col: f32,
    pub bottom_row: f32,
    pub right_col: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BoundingBox {
    fn default() -> &'a BoundingBox {
        <BoundingBox as ::protobuf::Message>::default_instance()
    }
}

impl BoundingBox {
    pub fn new() -> BoundingBox {
        ::std::default::Default::default()
    }

    // float top_row = 1;


    pub fn get_top_row(&self) -> f32 {
        self.top_row
    }
    pub fn clear_top_row(&mut self) {
        self.top_row = 0.;
    }

    // Param is passed by value, moved
    pub fn set_top_row(&mut self, v: f32) {
        self.top_row = v;
    }

    // float left_col = 2;


    pub fn get_left_col(&self) -> f32 {
        self.left_col
    }
    pub fn clear_left_col(&mut self) {
        self.left_col = 0.;
    }

    // Param is passed by value, moved
    pub fn set_left_col(&mut self, v: f32) {
        self.left_col = v;
    }

    // float bottom_row = 3;


    pub fn get_bottom_row(&self) -> f32 {
        self.bottom_row
    }
    pub fn clear_bottom_row(&mut self) {
        self.bottom_row = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bottom_row(&mut self, v: f32) {
        self.bottom_row = v;
    }

    // float right_col = 4;


    pub fn get_right_col(&self) -> f32 {
        self.right_col
    }
    pub fn clear_right_col(&mut self) {
        self.right_col = 0.;
    }

    // Param is passed by value, moved
    pub fn set_right_col(&mut self, v: f32) {
        self.right_col = v;
    }
}

impl ::protobuf::Message for BoundingBox {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.top_row = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.left_col = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bottom_row = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.right_col = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.top_row != 0. {
            my_size += 5;
        }
        if self.left_col != 0. {
            my_size += 5;
        }
        if self.bottom_row != 0. {
            my_size += 5;
        }
        if self.right_col != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.top_row != 0. {
            os.write_float(1, self.top_row)?;
        }
        if self.left_col != 0. {
            os.write_float(2, self.left_col)?;
        }
        if self.bottom_row != 0. {
            os.write_float(3, self.bottom_row)?;
        }
        if self.right_col != 0. {
            os.write_float(4, self.right_col)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BoundingBox {
        BoundingBox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "top_row",
                |m: &BoundingBox| { &m.top_row },
                |m: &mut BoundingBox| { &mut m.top_row },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "left_col",
                |m: &BoundingBox| { &m.left_col },
                |m: &mut BoundingBox| { &mut m.left_col },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "bottom_row",
                |m: &BoundingBox| { &m.bottom_row },
                |m: &mut BoundingBox| { &mut m.bottom_row },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "right_col",
                |m: &BoundingBox| { &m.right_col },
                |m: &mut BoundingBox| { &mut m.right_col },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BoundingBox>(
                "BoundingBox",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BoundingBox {
        static instance: ::protobuf::rt::LazyV2<BoundingBox> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BoundingBox::new)
    }
}

impl ::protobuf::Clear for BoundingBox {
    fn clear(&mut self) {
        self.top_row = 0.;
        self.left_col = 0.;
        self.bottom_row = 0.;
        self.right_col = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BoundingBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BoundingBox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FrameInfo {
    // message fields
    pub index: u32,
    pub time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FrameInfo {
    fn default() -> &'a FrameInfo {
        <FrameInfo as ::protobuf::Message>::default_instance()
    }
}

impl FrameInfo {
    pub fn new() -> FrameInfo {
        ::std::default::Default::default()
    }

    // uint32 index = 1;


    pub fn get_index(&self) -> u32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    // uint32 time = 2;


    pub fn get_time(&self) -> u32 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = v;
    }
}

impl ::protobuf::Message for FrameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        if self.time != 0 {
            os.write_uint32(2, self.time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FrameInfo {
        FrameInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index",
                |m: &FrameInfo| { &m.index },
                |m: &mut FrameInfo| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time",
                |m: &FrameInfo| { &m.time },
                |m: &mut FrameInfo| { &mut m.time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FrameInfo>(
                "FrameInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FrameInfo {
        static instance: ::protobuf::rt::LazyV2<FrameInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FrameInfo::new)
    }
}

impl ::protobuf::Clear for FrameInfo {
    fn clear(&mut self) {
        self.index = 0;
        self.time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FrameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Frame {
    // message fields
    pub frame_info: ::protobuf::SingularPtrField<FrameInfo>,
    pub data: ::protobuf::SingularPtrField<Data>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Frame {
    fn default() -> &'a Frame {
        <Frame as ::protobuf::Message>::default_instance()
    }
}

impl Frame {
    pub fn new() -> Frame {
        ::std::default::Default::default()
    }

    // .clarifai.api.FrameInfo frame_info = 1;


    pub fn get_frame_info(&self) -> &FrameInfo {
        self.frame_info.as_ref().unwrap_or_else(|| <FrameInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frame_info(&mut self) {
        self.frame_info.clear();
    }

    pub fn has_frame_info(&self) -> bool {
        self.frame_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_info(&mut self, v: FrameInfo) {
        self.frame_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frame_info(&mut self) -> &mut FrameInfo {
        if self.frame_info.is_none() {
            self.frame_info.set_default();
        }
        self.frame_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_frame_info(&mut self) -> FrameInfo {
        self.frame_info.take().unwrap_or_else(|| FrameInfo::new())
    }

    // .clarifai.api.Data data = 2;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // string id = 3;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Frame {
    fn is_initialized(&self) -> bool {
        for v in &self.frame_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frame_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.frame_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.frame_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Frame {
        Frame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FrameInfo>>(
                "frame_info",
                |m: &Frame| { &m.frame_info },
                |m: &mut Frame| { &mut m.frame_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &Frame| { &m.data },
                |m: &mut Frame| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Frame| { &m.id },
                |m: &mut Frame| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Frame>(
                "Frame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Frame {
        static instance: ::protobuf::rt::LazyV2<Frame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Frame::new)
    }
}

impl ::protobuf::Clear for Frame {
    fn clear(&mut self) {
        self.frame_info.clear();
        self.data.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Frame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Frame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mask {
    // message fields
    pub image: ::protobuf::SingularPtrField<Image>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mask {
    fn default() -> &'a Mask {
        <Mask as ::protobuf::Message>::default_instance()
    }
}

impl Mask {
    pub fn new() -> Mask {
        ::std::default::Default::default()
    }

    // .clarifai.api.Image image = 2;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut Image {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }
}

impl ::protobuf::Message for Mask {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mask {
        Mask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Mask| { &m.image },
                |m: &mut Mask| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mask>(
                "Mask",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mask {
        static instance: ::protobuf::rt::LazyV2<Mask> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mask::new)
    }
}

impl ::protobuf::Clear for Mask {
    fn clear(&mut self) {
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mask {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Polygon {
    // message fields
    pub points: ::protobuf::RepeatedField<Point>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Polygon {
    fn default() -> &'a Polygon {
        <Polygon as ::protobuf::Message>::default_instance()
    }
}

impl Polygon {
    pub fn new() -> Polygon {
        ::std::default::Default::default()
    }

    // repeated .clarifai.api.Point points = 1;


    pub fn get_points(&self) -> &[Point] {
        &self.points
    }
    pub fn clear_points(&mut self) {
        self.points.clear();
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: ::protobuf::RepeatedField<Point>) {
        self.points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_points(&mut self) -> &mut ::protobuf::RepeatedField<Point> {
        &mut self.points
    }

    // Take field
    pub fn take_points(&mut self) -> ::protobuf::RepeatedField<Point> {
        ::std::mem::replace(&mut self.points, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Polygon {
    fn is_initialized(&self) -> bool {
        for v in &self.points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.points)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.points {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Polygon {
        Polygon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "points",
                |m: &Polygon| { &m.points },
                |m: &mut Polygon| { &mut m.points },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Polygon>(
                "Polygon",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Polygon {
        static instance: ::protobuf::rt::LazyV2<Polygon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Polygon::new)
    }
}

impl ::protobuf::Clear for Polygon {
    fn clear(&mut self) {
        self.points.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Polygon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Polygon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Point {
    // message fields
    pub row: f32,
    pub col: f32,
    pub z: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    // float row = 1;


    pub fn get_row(&self) -> f32 {
        self.row
    }
    pub fn clear_row(&mut self) {
        self.row = 0.;
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: f32) {
        self.row = v;
    }

    // float col = 2;


    pub fn get_col(&self) -> f32 {
        self.col
    }
    pub fn clear_col(&mut self) {
        self.col = 0.;
    }

    // Param is passed by value, moved
    pub fn set_col(&mut self, v: f32) {
        self.col = v;
    }

    // float z = 3;


    pub fn get_z(&self) -> f32 {
        self.z
    }
    pub fn clear_z(&mut self) {
        self.z = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = v;
    }
}

impl ::protobuf::Message for Point {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.row = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.col = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.row != 0. {
            my_size += 5;
        }
        if self.col != 0. {
            my_size += 5;
        }
        if self.z != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.row != 0. {
            os.write_float(1, self.row)?;
        }
        if self.col != 0. {
            os.write_float(2, self.col)?;
        }
        if self.z != 0. {
            os.write_float(3, self.z)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Point {
        Point::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "row",
                |m: &Point| { &m.row },
                |m: &mut Point| { &mut m.row },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "col",
                |m: &Point| { &m.col },
                |m: &mut Point| { &mut m.col },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "z",
                |m: &Point| { &m.z },
                |m: &mut Point| { &mut m.z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Point>(
                "Point",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Point {
        static instance: ::protobuf::rt::LazyV2<Point> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Point::new)
    }
}

impl ::protobuf::Clear for Point {
    fn clear(&mut self) {
        self.row = 0.;
        self.col = 0.;
        self.z = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Embedding {
    // message fields
    pub vector: ::std::vec::Vec<f32>,
    pub num_dimensions: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Embedding {
    fn default() -> &'a Embedding {
        <Embedding as ::protobuf::Message>::default_instance()
    }
}

impl Embedding {
    pub fn new() -> Embedding {
        ::std::default::Default::default()
    }

    // repeated float vector = 1;


    pub fn get_vector(&self) -> &[f32] {
        &self.vector
    }
    pub fn clear_vector(&mut self) {
        self.vector.clear();
    }

    // Param is passed by value, moved
    pub fn set_vector(&mut self, v: ::std::vec::Vec<f32>) {
        self.vector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vector(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.vector
    }

    // Take field
    pub fn take_vector(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.vector, ::std::vec::Vec::new())
    }

    // uint32 num_dimensions = 2;


    pub fn get_num_dimensions(&self) -> u32 {
        self.num_dimensions
    }
    pub fn clear_num_dimensions(&mut self) {
        self.num_dimensions = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_dimensions(&mut self, v: u32) {
        self.num_dimensions = v;
    }
}

impl ::protobuf::Message for Embedding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.vector)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_dimensions = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vector.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.vector.len() * 4) as u32) + (self.vector.len() * 4) as u32;
        }
        if self.num_dimensions != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_dimensions, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.vector.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.vector.len() * 4) as u32)?;
            for v in &self.vector {
                os.write_float_no_tag(*v)?;
            };
        }
        if self.num_dimensions != 0 {
            os.write_uint32(2, self.num_dimensions)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Embedding {
        Embedding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "vector",
                |m: &Embedding| { &m.vector },
                |m: &mut Embedding| { &mut m.vector },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_dimensions",
                |m: &Embedding| { &m.num_dimensions },
                |m: &mut Embedding| { &mut m.num_dimensions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Embedding>(
                "Embedding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Embedding {
        static instance: ::protobuf::rt::LazyV2<Embedding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Embedding::new)
    }
}

impl ::protobuf::Clear for Embedding {
    fn clear(&mut self) {
        self.vector.clear();
        self.num_dimensions = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Embedding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Embedding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GeoPoint {
    // message fields
    pub longitude: f32,
    pub latitude: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeoPoint {
    fn default() -> &'a GeoPoint {
        <GeoPoint as ::protobuf::Message>::default_instance()
    }
}

impl GeoPoint {
    pub fn new() -> GeoPoint {
        ::std::default::Default::default()
    }

    // float longitude = 1;


    pub fn get_longitude(&self) -> f32 {
        self.longitude
    }
    pub fn clear_longitude(&mut self) {
        self.longitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_longitude(&mut self, v: f32) {
        self.longitude = v;
    }

    // float latitude = 2;


    pub fn get_latitude(&self) -> f32 {
        self.latitude
    }
    pub fn clear_latitude(&mut self) {
        self.latitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latitude(&mut self, v: f32) {
        self.latitude = v;
    }
}

impl ::protobuf::Message for GeoPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.longitude = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.latitude = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.longitude != 0. {
            my_size += 5;
        }
        if self.latitude != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.longitude != 0. {
            os.write_float(1, self.longitude)?;
        }
        if self.latitude != 0. {
            os.write_float(2, self.latitude)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeoPoint {
        GeoPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "longitude",
                |m: &GeoPoint| { &m.longitude },
                |m: &mut GeoPoint| { &mut m.longitude },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "latitude",
                |m: &GeoPoint| { &m.latitude },
                |m: &mut GeoPoint| { &mut m.latitude },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GeoPoint>(
                "GeoPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GeoPoint {
        static instance: ::protobuf::rt::LazyV2<GeoPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GeoPoint::new)
    }
}

impl ::protobuf::Clear for GeoPoint {
    fn clear(&mut self) {
        self.longitude = 0.;
        self.latitude = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeoPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GeoLimit {
    // message fields
    pub field_type: ::std::string::String,
    pub value: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeoLimit {
    fn default() -> &'a GeoLimit {
        <GeoLimit as ::protobuf::Message>::default_instance()
    }
}

impl GeoLimit {
    pub fn new() -> GeoLimit {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // float value = 2;


    pub fn get_value(&self) -> f32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = v;
    }
}

impl ::protobuf::Message for GeoLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if self.value != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if self.value != 0. {
            os.write_float(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeoLimit {
        GeoLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &GeoLimit| { &m.field_type },
                |m: &mut GeoLimit| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &GeoLimit| { &m.value },
                |m: &mut GeoLimit| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GeoLimit>(
                "GeoLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GeoLimit {
        static instance: ::protobuf::rt::LazyV2<GeoLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GeoLimit::new)
    }
}

impl ::protobuf::Clear for GeoLimit {
    fn clear(&mut self) {
        self.field_type.clear();
        self.value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeoLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GeoBoxedPoint {
    // message fields
    pub geo_point: ::protobuf::SingularPtrField<GeoPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GeoBoxedPoint {
    fn default() -> &'a GeoBoxedPoint {
        <GeoBoxedPoint as ::protobuf::Message>::default_instance()
    }
}

impl GeoBoxedPoint {
    pub fn new() -> GeoBoxedPoint {
        ::std::default::Default::default()
    }

    // .clarifai.api.GeoPoint geo_point = 1;


    pub fn get_geo_point(&self) -> &GeoPoint {
        self.geo_point.as_ref().unwrap_or_else(|| <GeoPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_geo_point(&mut self) {
        self.geo_point.clear();
    }

    pub fn has_geo_point(&self) -> bool {
        self.geo_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo_point(&mut self, v: GeoPoint) {
        self.geo_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geo_point(&mut self) -> &mut GeoPoint {
        if self.geo_point.is_none() {
            self.geo_point.set_default();
        }
        self.geo_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_geo_point(&mut self) -> GeoPoint {
        self.geo_point.take().unwrap_or_else(|| GeoPoint::new())
    }
}

impl ::protobuf::Message for GeoBoxedPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.geo_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geo_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.geo_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.geo_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeoBoxedPoint {
        GeoBoxedPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeoPoint>>(
                "geo_point",
                |m: &GeoBoxedPoint| { &m.geo_point },
                |m: &mut GeoBoxedPoint| { &mut m.geo_point },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GeoBoxedPoint>(
                "GeoBoxedPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GeoBoxedPoint {
        static instance: ::protobuf::rt::LazyV2<GeoBoxedPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GeoBoxedPoint::new)
    }
}

impl ::protobuf::Clear for GeoBoxedPoint {
    fn clear(&mut self) {
        self.geo_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeoBoxedPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoBoxedPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Geo {
    // message fields
    pub geo_point: ::protobuf::SingularPtrField<GeoPoint>,
    pub geo_limit: ::protobuf::SingularPtrField<GeoLimit>,
    pub geo_box: ::protobuf::RepeatedField<GeoBoxedPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Geo {
    fn default() -> &'a Geo {
        <Geo as ::protobuf::Message>::default_instance()
    }
}

impl Geo {
    pub fn new() -> Geo {
        ::std::default::Default::default()
    }

    // .clarifai.api.GeoPoint geo_point = 1;


    pub fn get_geo_point(&self) -> &GeoPoint {
        self.geo_point.as_ref().unwrap_or_else(|| <GeoPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_geo_point(&mut self) {
        self.geo_point.clear();
    }

    pub fn has_geo_point(&self) -> bool {
        self.geo_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo_point(&mut self, v: GeoPoint) {
        self.geo_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geo_point(&mut self) -> &mut GeoPoint {
        if self.geo_point.is_none() {
            self.geo_point.set_default();
        }
        self.geo_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_geo_point(&mut self) -> GeoPoint {
        self.geo_point.take().unwrap_or_else(|| GeoPoint::new())
    }

    // .clarifai.api.GeoLimit geo_limit = 2;


    pub fn get_geo_limit(&self) -> &GeoLimit {
        self.geo_limit.as_ref().unwrap_or_else(|| <GeoLimit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_geo_limit(&mut self) {
        self.geo_limit.clear();
    }

    pub fn has_geo_limit(&self) -> bool {
        self.geo_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo_limit(&mut self, v: GeoLimit) {
        self.geo_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_geo_limit(&mut self) -> &mut GeoLimit {
        if self.geo_limit.is_none() {
            self.geo_limit.set_default();
        }
        self.geo_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_geo_limit(&mut self) -> GeoLimit {
        self.geo_limit.take().unwrap_or_else(|| GeoLimit::new())
    }

    // repeated .clarifai.api.GeoBoxedPoint geo_box = 3;


    pub fn get_geo_box(&self) -> &[GeoBoxedPoint] {
        &self.geo_box
    }
    pub fn clear_geo_box(&mut self) {
        self.geo_box.clear();
    }

    // Param is passed by value, moved
    pub fn set_geo_box(&mut self, v: ::protobuf::RepeatedField<GeoBoxedPoint>) {
        self.geo_box = v;
    }

    // Mutable pointer to the field.
    pub fn mut_geo_box(&mut self) -> &mut ::protobuf::RepeatedField<GeoBoxedPoint> {
        &mut self.geo_box
    }

    // Take field
    pub fn take_geo_box(&mut self) -> ::protobuf::RepeatedField<GeoBoxedPoint> {
        ::std::mem::replace(&mut self.geo_box, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Geo {
    fn is_initialized(&self) -> bool {
        for v in &self.geo_point {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.geo_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.geo_box {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geo_point)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.geo_limit)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.geo_box)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.geo_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.geo_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.geo_box {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.geo_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.geo_limit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.geo_box {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Geo {
        Geo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeoPoint>>(
                "geo_point",
                |m: &Geo| { &m.geo_point },
                |m: &mut Geo| { &mut m.geo_point },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeoLimit>>(
                "geo_limit",
                |m: &Geo| { &m.geo_limit },
                |m: &mut Geo| { &mut m.geo_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GeoBoxedPoint>>(
                "geo_box",
                |m: &Geo| { &m.geo_box },
                |m: &mut Geo| { &mut m.geo_box },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Geo>(
                "Geo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Geo {
        static instance: ::protobuf::rt::LazyV2<Geo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Geo::new)
    }
}

impl ::protobuf::Clear for Geo {
    fn clear(&mut self) {
        self.geo_point.clear();
        self.geo_limit.clear();
        self.geo_box.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Geo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Geo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Image {
    // message fields
    pub url: ::std::string::String,
    pub base64: ::std::vec::Vec<u8>,
    pub allow_duplicate_url: bool,
    pub hosted: ::protobuf::SingularPtrField<HostedURL>,
    pub image_info: ::protobuf::SingularPtrField<ImageInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // bytes base64 = 2;


    pub fn get_base64(&self) -> &[u8] {
        &self.base64
    }
    pub fn clear_base64(&mut self) {
        self.base64.clear();
    }

    // Param is passed by value, moved
    pub fn set_base64(&mut self, v: ::std::vec::Vec<u8>) {
        self.base64 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base64(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.base64
    }

    // Take field
    pub fn take_base64(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.base64, ::std::vec::Vec::new())
    }

    // bool allow_duplicate_url = 4;


    pub fn get_allow_duplicate_url(&self) -> bool {
        self.allow_duplicate_url
    }
    pub fn clear_allow_duplicate_url(&mut self) {
        self.allow_duplicate_url = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_duplicate_url(&mut self, v: bool) {
        self.allow_duplicate_url = v;
    }

    // .clarifai.api.HostedURL hosted = 5;


    pub fn get_hosted(&self) -> &HostedURL {
        self.hosted.as_ref().unwrap_or_else(|| <HostedURL as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hosted(&mut self) {
        self.hosted.clear();
    }

    pub fn has_hosted(&self) -> bool {
        self.hosted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hosted(&mut self, v: HostedURL) {
        self.hosted = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hosted(&mut self) -> &mut HostedURL {
        if self.hosted.is_none() {
            self.hosted.set_default();
        }
        self.hosted.as_mut().unwrap()
    }

    // Take field
    pub fn take_hosted(&mut self) -> HostedURL {
        self.hosted.take().unwrap_or_else(|| HostedURL::new())
    }

    // .clarifai.api.ImageInfo image_info = 6;


    pub fn get_image_info(&self) -> &ImageInfo {
        self.image_info.as_ref().unwrap_or_else(|| <ImageInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_image_info(&mut self) {
        self.image_info.clear();
    }

    pub fn has_image_info(&self) -> bool {
        self.image_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_info(&mut self, v: ImageInfo) {
        self.image_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_info(&mut self) -> &mut ImageInfo {
        if self.image_info.is_none() {
            self.image_info.set_default();
        }
        self.image_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_info(&mut self) -> ImageInfo {
        self.image_info.take().unwrap_or_else(|| ImageInfo::new())
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        for v in &self.hosted {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.base64)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_duplicate_url = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hosted)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.base64.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.base64);
        }
        if self.allow_duplicate_url != false {
            my_size += 2;
        }
        if let Some(ref v) = self.hosted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.image_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.base64.is_empty() {
            os.write_bytes(2, &self.base64)?;
        }
        if self.allow_duplicate_url != false {
            os.write_bool(4, self.allow_duplicate_url)?;
        }
        if let Some(ref v) = self.hosted.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.image_info.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Image| { &m.url },
                |m: &mut Image| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "base64",
                |m: &Image| { &m.base64 },
                |m: &mut Image| { &mut m.base64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_duplicate_url",
                |m: &Image| { &m.allow_duplicate_url },
                |m: &mut Image| { &mut m.allow_duplicate_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostedURL>>(
                "hosted",
                |m: &Image| { &m.hosted },
                |m: &mut Image| { &mut m.hosted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImageInfo>>(
                "image_info",
                |m: &Image| { &m.image_info },
                |m: &mut Image| { &mut m.image_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image>(
                "Image",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image {
        static instance: ::protobuf::rt::LazyV2<Image> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image::new)
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.url.clear();
        self.base64.clear();
        self.allow_duplicate_url = false;
        self.hosted.clear();
        self.image_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageInfo {
    // message fields
    pub width: i32,
    pub height: i32,
    pub format: ::std::string::String,
    pub color_mode: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageInfo {
    fn default() -> &'a ImageInfo {
        <ImageInfo as ::protobuf::Message>::default_instance()
    }
}

impl ImageInfo {
    pub fn new() -> ImageInfo {
        ::std::default::Default::default()
    }

    // int32 width = 1;


    pub fn get_width(&self) -> i32 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = v;
    }

    // int32 height = 2;


    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // string format = 3;


    pub fn get_format(&self) -> &str {
        &self.format
    }
    pub fn clear_format(&mut self) {
        self.format.clear();
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        &mut self.format
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.format, ::std::string::String::new())
    }

    // string color_mode = 4;


    pub fn get_color_mode(&self) -> &str {
        &self.color_mode
    }
    pub fn clear_color_mode(&mut self) {
        self.color_mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_color_mode(&mut self, v: ::std::string::String) {
        self.color_mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color_mode(&mut self) -> &mut ::std::string::String {
        &mut self.color_mode
    }

    // Take field
    pub fn take_color_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color_mode, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ImageInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.format)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color_mode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(1, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.format.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.format);
        }
        if !self.color_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.color_mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.width != 0 {
            os.write_int32(1, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        if !self.format.is_empty() {
            os.write_string(3, &self.format)?;
        }
        if !self.color_mode.is_empty() {
            os.write_string(4, &self.color_mode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageInfo {
        ImageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &ImageInfo| { &m.width },
                |m: &mut ImageInfo| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &ImageInfo| { &m.height },
                |m: &mut ImageInfo| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "format",
                |m: &ImageInfo| { &m.format },
                |m: &mut ImageInfo| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color_mode",
                |m: &ImageInfo| { &m.color_mode },
                |m: &mut ImageInfo| { &mut m.color_mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImageInfo>(
                "ImageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImageInfo {
        static instance: ::protobuf::rt::LazyV2<ImageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImageInfo::new)
    }
}

impl ::protobuf::Clear for ImageInfo {
    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.format.clear();
        self.color_mode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HostedURL {
    // message fields
    pub prefix: ::std::string::String,
    pub suffix: ::std::string::String,
    pub sizes: ::protobuf::RepeatedField<::std::string::String>,
    pub crossorigin: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HostedURL {
    fn default() -> &'a HostedURL {
        <HostedURL as ::protobuf::Message>::default_instance()
    }
}

impl HostedURL {
    pub fn new() -> HostedURL {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // string suffix = 2;


    pub fn get_suffix(&self) -> &str {
        &self.suffix
    }
    pub fn clear_suffix(&mut self) {
        self.suffix.clear();
    }

    // Param is passed by value, moved
    pub fn set_suffix(&mut self, v: ::std::string::String) {
        self.suffix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_suffix(&mut self) -> &mut ::std::string::String {
        &mut self.suffix
    }

    // Take field
    pub fn take_suffix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.suffix, ::std::string::String::new())
    }

    // repeated string sizes = 3;


    pub fn get_sizes(&self) -> &[::std::string::String] {
        &self.sizes
    }
    pub fn clear_sizes(&mut self) {
        self.sizes.clear();
    }

    // Param is passed by value, moved
    pub fn set_sizes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.sizes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sizes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.sizes
    }

    // Take field
    pub fn take_sizes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.sizes, ::protobuf::RepeatedField::new())
    }

    // string crossorigin = 4;


    pub fn get_crossorigin(&self) -> &str {
        &self.crossorigin
    }
    pub fn clear_crossorigin(&mut self) {
        self.crossorigin.clear();
    }

    // Param is passed by value, moved
    pub fn set_crossorigin(&mut self, v: ::std::string::String) {
        self.crossorigin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crossorigin(&mut self) -> &mut ::std::string::String {
        &mut self.crossorigin
    }

    // Take field
    pub fn take_crossorigin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.crossorigin, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HostedURL {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.suffix)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.sizes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.crossorigin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if !self.suffix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.suffix);
        }
        for value in &self.sizes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.crossorigin.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.crossorigin);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if !self.suffix.is_empty() {
            os.write_string(2, &self.suffix)?;
        }
        for v in &self.sizes {
            os.write_string(3, &v)?;
        };
        if !self.crossorigin.is_empty() {
            os.write_string(4, &self.crossorigin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HostedURL {
        HostedURL::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix",
                |m: &HostedURL| { &m.prefix },
                |m: &mut HostedURL| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "suffix",
                |m: &HostedURL| { &m.suffix },
                |m: &mut HostedURL| { &mut m.suffix },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sizes",
                |m: &HostedURL| { &m.sizes },
                |m: &mut HostedURL| { &mut m.sizes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "crossorigin",
                |m: &HostedURL| { &m.crossorigin },
                |m: &mut HostedURL| { &mut m.crossorigin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HostedURL>(
                "HostedURL",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HostedURL {
        static instance: ::protobuf::rt::LazyV2<HostedURL> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HostedURL::new)
    }
}

impl ::protobuf::Clear for HostedURL {
    fn clear(&mut self) {
        self.prefix.clear();
        self.suffix.clear();
        self.sizes.clear();
        self.crossorigin.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HostedURL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostedURL {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Input {
    // message fields
    pub id: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<Data>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub dataset_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Input {
    fn default() -> &'a Input {
        <Input as ::protobuf::Message>::default_instance()
    }
}

impl Input {
    pub fn new() -> Input {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Data data = 2;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // .google.protobuf.Timestamp created_at = 4;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 5;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .clarifai.api.status.Status status = 6;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string dataset_ids = 7;


    pub fn get_dataset_ids(&self) -> &[::std::string::String] {
        &self.dataset_ids
    }
    pub fn clear_dataset_ids(&mut self) {
        self.dataset_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dataset_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dataset_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dataset_ids
    }

    // Take field
    pub fn take_dataset_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dataset_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Input {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dataset_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.dataset_ids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.dataset_ids {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Input {
        Input::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Input| { &m.id },
                |m: &mut Input| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &Input| { &m.data },
                |m: &mut Input| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Input| { &m.created_at },
                |m: &mut Input| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &Input| { &m.modified_at },
                |m: &mut Input| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &Input| { &m.status },
                |m: &mut Input| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset_ids",
                |m: &Input| { &m.dataset_ids },
                |m: &mut Input| { &mut m.dataset_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Input>(
                "Input",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Input {
        static instance: ::protobuf::rt::LazyV2<Input> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Input::new)
    }
}

impl ::protobuf::Clear for Input {
    fn clear(&mut self) {
        self.id.clear();
        self.data.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.status.clear();
        self.dataset_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Input {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Input {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InputCount {
    // message fields
    pub processed: u32,
    pub to_process: u32,
    pub errors: u32,
    pub processing: u32,
    pub reindexed: u32,
    pub to_reindex: u32,
    pub reindex_errors: u32,
    pub reindexing: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputCount {
    fn default() -> &'a InputCount {
        <InputCount as ::protobuf::Message>::default_instance()
    }
}

impl InputCount {
    pub fn new() -> InputCount {
        ::std::default::Default::default()
    }

    // uint32 processed = 1;


    pub fn get_processed(&self) -> u32 {
        self.processed
    }
    pub fn clear_processed(&mut self) {
        self.processed = 0;
    }

    // Param is passed by value, moved
    pub fn set_processed(&mut self, v: u32) {
        self.processed = v;
    }

    // uint32 to_process = 2;


    pub fn get_to_process(&self) -> u32 {
        self.to_process
    }
    pub fn clear_to_process(&mut self) {
        self.to_process = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_process(&mut self, v: u32) {
        self.to_process = v;
    }

    // uint32 errors = 3;


    pub fn get_errors(&self) -> u32 {
        self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: u32) {
        self.errors = v;
    }

    // uint32 processing = 4;


    pub fn get_processing(&self) -> u32 {
        self.processing
    }
    pub fn clear_processing(&mut self) {
        self.processing = 0;
    }

    // Param is passed by value, moved
    pub fn set_processing(&mut self, v: u32) {
        self.processing = v;
    }

    // uint32 reindexed = 5;


    pub fn get_reindexed(&self) -> u32 {
        self.reindexed
    }
    pub fn clear_reindexed(&mut self) {
        self.reindexed = 0;
    }

    // Param is passed by value, moved
    pub fn set_reindexed(&mut self, v: u32) {
        self.reindexed = v;
    }

    // uint32 to_reindex = 6;


    pub fn get_to_reindex(&self) -> u32 {
        self.to_reindex
    }
    pub fn clear_to_reindex(&mut self) {
        self.to_reindex = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_reindex(&mut self, v: u32) {
        self.to_reindex = v;
    }

    // uint32 reindex_errors = 7;


    pub fn get_reindex_errors(&self) -> u32 {
        self.reindex_errors
    }
    pub fn clear_reindex_errors(&mut self) {
        self.reindex_errors = 0;
    }

    // Param is passed by value, moved
    pub fn set_reindex_errors(&mut self, v: u32) {
        self.reindex_errors = v;
    }

    // uint32 reindexing = 8;


    pub fn get_reindexing(&self) -> u32 {
        self.reindexing
    }
    pub fn clear_reindexing(&mut self) {
        self.reindexing = 0;
    }

    // Param is passed by value, moved
    pub fn set_reindexing(&mut self, v: u32) {
        self.reindexing = v;
    }
}

impl ::protobuf::Message for InputCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.processed = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.to_process = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errors = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.processing = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reindexed = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.to_reindex = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reindex_errors = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reindexing = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.processed != 0 {
            my_size += ::protobuf::rt::value_size(1, self.processed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.to_process != 0 {
            my_size += ::protobuf::rt::value_size(2, self.to_process, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.errors != 0 {
            my_size += ::protobuf::rt::value_size(3, self.errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.processing != 0 {
            my_size += ::protobuf::rt::value_size(4, self.processing, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reindexed != 0 {
            my_size += ::protobuf::rt::value_size(5, self.reindexed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.to_reindex != 0 {
            my_size += ::protobuf::rt::value_size(6, self.to_reindex, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reindex_errors != 0 {
            my_size += ::protobuf::rt::value_size(7, self.reindex_errors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reindexing != 0 {
            my_size += ::protobuf::rt::value_size(8, self.reindexing, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.processed != 0 {
            os.write_uint32(1, self.processed)?;
        }
        if self.to_process != 0 {
            os.write_uint32(2, self.to_process)?;
        }
        if self.errors != 0 {
            os.write_uint32(3, self.errors)?;
        }
        if self.processing != 0 {
            os.write_uint32(4, self.processing)?;
        }
        if self.reindexed != 0 {
            os.write_uint32(5, self.reindexed)?;
        }
        if self.to_reindex != 0 {
            os.write_uint32(6, self.to_reindex)?;
        }
        if self.reindex_errors != 0 {
            os.write_uint32(7, self.reindex_errors)?;
        }
        if self.reindexing != 0 {
            os.write_uint32(8, self.reindexing)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputCount {
        InputCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "processed",
                |m: &InputCount| { &m.processed },
                |m: &mut InputCount| { &mut m.processed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "to_process",
                |m: &InputCount| { &m.to_process },
                |m: &mut InputCount| { &mut m.to_process },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errors",
                |m: &InputCount| { &m.errors },
                |m: &mut InputCount| { &mut m.errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "processing",
                |m: &InputCount| { &m.processing },
                |m: &mut InputCount| { &mut m.processing },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reindexed",
                |m: &InputCount| { &m.reindexed },
                |m: &mut InputCount| { &mut m.reindexed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "to_reindex",
                |m: &InputCount| { &m.to_reindex },
                |m: &mut InputCount| { &mut m.to_reindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reindex_errors",
                |m: &InputCount| { &m.reindex_errors },
                |m: &mut InputCount| { &mut m.reindex_errors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reindexing",
                |m: &InputCount| { &m.reindexing },
                |m: &mut InputCount| { &mut m.reindexing },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InputCount>(
                "InputCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputCount {
        static instance: ::protobuf::rt::LazyV2<InputCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InputCount::new)
    }
}

impl ::protobuf::Clear for InputCount {
    fn clear(&mut self) {
        self.processed = 0;
        self.to_process = 0;
        self.errors = 0;
        self.processing = 0;
        self.reindexed = 0;
        self.to_reindex = 0;
        self.reindex_errors = 0;
        self.reindexing = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatasetFilter {
    // message fields
    pub id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub user_id: ::std::string::String,
    pub app_id: ::std::string::String,
    pub dataset_id: ::std::string::String,
    pub saved_search: ::protobuf::SingularPtrField<Search>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatasetFilter {
    fn default() -> &'a DatasetFilter {
        <DatasetFilter as ::protobuf::Message>::default_instance()
    }
}

impl DatasetFilter {
    pub fn new() -> DatasetFilter {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 3;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string user_id = 4;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // string app_id = 5;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dataset_id = 6;


    pub fn get_dataset_id(&self) -> &str {
        &self.dataset_id
    }
    pub fn clear_dataset_id(&mut self) {
        self.dataset_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset_id(&mut self, v: ::std::string::String) {
        self.dataset_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset_id(&mut self) -> &mut ::std::string::String {
        &mut self.dataset_id
    }

    // Take field
    pub fn take_dataset_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataset_id, ::std::string::String::new())
    }

    // .clarifai.api.Search saved_search = 8;


    pub fn get_saved_search(&self) -> &Search {
        self.saved_search.as_ref().unwrap_or_else(|| <Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_saved_search(&mut self) {
        self.saved_search.clear();
    }

    pub fn has_saved_search(&self) -> bool {
        self.saved_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_saved_search(&mut self, v: Search) {
        self.saved_search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saved_search(&mut self) -> &mut Search {
        if self.saved_search.is_none() {
            self.saved_search.set_default();
        }
        self.saved_search.as_mut().unwrap()
    }

    // Take field
    pub fn take_saved_search(&mut self) -> Search {
        self.saved_search.take().unwrap_or_else(|| Search::new())
    }
}

impl ::protobuf::Message for DatasetFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.saved_search {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataset_id)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.saved_search)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.app_id);
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.dataset_id);
        }
        if let Some(ref v) = self.saved_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(4, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(5, &self.app_id)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(6, &self.dataset_id)?;
        }
        if let Some(ref v) = self.saved_search.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatasetFilter {
        DatasetFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &DatasetFilter| { &m.id },
                |m: &mut DatasetFilter| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &DatasetFilter| { &m.created_at },
                |m: &mut DatasetFilter| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &DatasetFilter| { &m.modified_at },
                |m: &mut DatasetFilter| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &DatasetFilter| { &m.user_id },
                |m: &mut DatasetFilter| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &DatasetFilter| { &m.app_id },
                |m: &mut DatasetFilter| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset_id",
                |m: &DatasetFilter| { &m.dataset_id },
                |m: &mut DatasetFilter| { &mut m.dataset_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Search>>(
                "saved_search",
                |m: &DatasetFilter| { &m.saved_search },
                |m: &mut DatasetFilter| { &mut m.saved_search },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatasetFilter>(
                "DatasetFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatasetFilter {
        static instance: ::protobuf::rt::LazyV2<DatasetFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatasetFilter::new)
    }
}

impl ::protobuf::Clear for DatasetFilter {
    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.user_id.clear();
        self.app_id.clear();
        self.dataset_id.clear();
        self.saved_search.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatasetFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatasetVersion {
    // message fields
    pub id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub app_id: ::std::string::String,
    pub user_id: ::std::string::String,
    pub dataset_id: ::std::string::String,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub description: ::std::string::String,
    pub summary: ::protobuf::SingularPtrField<DatasetVersionSummary>,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub embed_model_version_ids: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub data_config: ::std::option::Option<DatasetVersion_oneof_data_config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatasetVersion {
    fn default() -> &'a DatasetVersion {
        <DatasetVersion as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DatasetVersion_oneof_data_config {
    dataset_filter_config(DatasetVersionDatasetFilterConfig),
}

impl DatasetVersion {
    pub fn new() -> DatasetVersion {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 3;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string app_id = 4;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string user_id = 5;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // string dataset_id = 6;


    pub fn get_dataset_id(&self) -> &str {
        &self.dataset_id
    }
    pub fn clear_dataset_id(&mut self) {
        self.dataset_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset_id(&mut self, v: ::std::string::String) {
        self.dataset_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset_id(&mut self) -> &mut ::std::string::String {
        &mut self.dataset_id
    }

    // Take field
    pub fn take_dataset_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataset_id, ::std::string::String::new())
    }

    // .clarifai.api.DatasetVersionDatasetFilterConfig dataset_filter_config = 7;


    pub fn get_dataset_filter_config(&self) -> &DatasetVersionDatasetFilterConfig {
        match self.data_config {
            ::std::option::Option::Some(DatasetVersion_oneof_data_config::dataset_filter_config(ref v)) => v,
            _ => <DatasetVersionDatasetFilterConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dataset_filter_config(&mut self) {
        self.data_config = ::std::option::Option::None;
    }

    pub fn has_dataset_filter_config(&self) -> bool {
        match self.data_config {
            ::std::option::Option::Some(DatasetVersion_oneof_data_config::dataset_filter_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dataset_filter_config(&mut self, v: DatasetVersionDatasetFilterConfig) {
        self.data_config = ::std::option::Option::Some(DatasetVersion_oneof_data_config::dataset_filter_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dataset_filter_config(&mut self) -> &mut DatasetVersionDatasetFilterConfig {
        if let ::std::option::Option::Some(DatasetVersion_oneof_data_config::dataset_filter_config(_)) = self.data_config {
        } else {
            self.data_config = ::std::option::Option::Some(DatasetVersion_oneof_data_config::dataset_filter_config(DatasetVersionDatasetFilterConfig::new()));
        }
        match self.data_config {
            ::std::option::Option::Some(DatasetVersion_oneof_data_config::dataset_filter_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dataset_filter_config(&mut self) -> DatasetVersionDatasetFilterConfig {
        if self.has_dataset_filter_config() {
            match self.data_config.take() {
                ::std::option::Option::Some(DatasetVersion_oneof_data_config::dataset_filter_config(v)) => v,
                _ => panic!(),
            }
        } else {
            DatasetVersionDatasetFilterConfig::new()
        }
    }

    // .clarifai.api.status.Status status = 8;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // string description = 10;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .clarifai.api.DatasetVersionSummary summary = 11;


    pub fn get_summary(&self) -> &DatasetVersionSummary {
        self.summary.as_ref().unwrap_or_else(|| <DatasetVersionSummary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: DatasetVersionSummary) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut DatasetVersionSummary {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> DatasetVersionSummary {
        self.summary.take().unwrap_or_else(|| DatasetVersionSummary::new())
    }

    // .google.protobuf.Struct metadata = 12;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .clarifai.api.Visibility visibility = 13;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // repeated string embed_model_version_ids = 14;


    pub fn get_embed_model_version_ids(&self) -> &[::std::string::String] {
        &self.embed_model_version_ids
    }
    pub fn clear_embed_model_version_ids(&mut self) {
        self.embed_model_version_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_embed_model_version_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.embed_model_version_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_embed_model_version_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.embed_model_version_ids
    }

    // Take field
    pub fn take_embed_model_version_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.embed_model_version_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DatasetVersion {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(DatasetVersion_oneof_data_config::dataset_filter_config(ref v)) = self.data_config {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataset_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data_config = ::std::option::Option::Some(DatasetVersion_oneof_data_config::dataset_filter_config(is.read_message()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.summary)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.embed_model_version_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_id);
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.dataset_id);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.description);
        }
        if let Some(ref v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.embed_model_version_ids {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.data_config {
            match v {
                &DatasetVersion_oneof_data_config::dataset_filter_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(4, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(5, &self.user_id)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(6, &self.dataset_id)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.description.is_empty() {
            os.write_string(10, &self.description)?;
        }
        if let Some(ref v) = self.summary.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.embed_model_version_ids {
            os.write_string(14, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.data_config {
            match v {
                &DatasetVersion_oneof_data_config::dataset_filter_config(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatasetVersion {
        DatasetVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &DatasetVersion| { &m.id },
                |m: &mut DatasetVersion| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &DatasetVersion| { &m.created_at },
                |m: &mut DatasetVersion| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &DatasetVersion| { &m.modified_at },
                |m: &mut DatasetVersion| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &DatasetVersion| { &m.app_id },
                |m: &mut DatasetVersion| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &DatasetVersion| { &m.user_id },
                |m: &mut DatasetVersion| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset_id",
                |m: &DatasetVersion| { &m.dataset_id },
                |m: &mut DatasetVersion| { &mut m.dataset_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DatasetVersionDatasetFilterConfig>(
                "dataset_filter_config",
                DatasetVersion::has_dataset_filter_config,
                DatasetVersion::get_dataset_filter_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &DatasetVersion| { &m.status },
                |m: &mut DatasetVersion| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &DatasetVersion| { &m.description },
                |m: &mut DatasetVersion| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatasetVersionSummary>>(
                "summary",
                |m: &DatasetVersion| { &m.summary },
                |m: &mut DatasetVersion| { &mut m.summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &DatasetVersion| { &m.metadata },
                |m: &mut DatasetVersion| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &DatasetVersion| { &m.visibility },
                |m: &mut DatasetVersion| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "embed_model_version_ids",
                |m: &DatasetVersion| { &m.embed_model_version_ids },
                |m: &mut DatasetVersion| { &mut m.embed_model_version_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatasetVersion>(
                "DatasetVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatasetVersion {
        static instance: ::protobuf::rt::LazyV2<DatasetVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatasetVersion::new)
    }
}

impl ::protobuf::Clear for DatasetVersion {
    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.dataset_id.clear();
        self.data_config = ::std::option::Option::None;
        self.status.clear();
        self.description.clear();
        self.summary.clear();
        self.metadata.clear();
        self.visibility.clear();
        self.embed_model_version_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatasetVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatasetVersionDatasetFilterConfig {
    // message fields
    pub dataset_filter: ::protobuf::SingularPtrField<DatasetFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatasetVersionDatasetFilterConfig {
    fn default() -> &'a DatasetVersionDatasetFilterConfig {
        <DatasetVersionDatasetFilterConfig as ::protobuf::Message>::default_instance()
    }
}

impl DatasetVersionDatasetFilterConfig {
    pub fn new() -> DatasetVersionDatasetFilterConfig {
        ::std::default::Default::default()
    }

    // .clarifai.api.DatasetFilter dataset_filter = 1;


    pub fn get_dataset_filter(&self) -> &DatasetFilter {
        self.dataset_filter.as_ref().unwrap_or_else(|| <DatasetFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dataset_filter(&mut self) {
        self.dataset_filter.clear();
    }

    pub fn has_dataset_filter(&self) -> bool {
        self.dataset_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataset_filter(&mut self, v: DatasetFilter) {
        self.dataset_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset_filter(&mut self) -> &mut DatasetFilter {
        if self.dataset_filter.is_none() {
            self.dataset_filter.set_default();
        }
        self.dataset_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataset_filter(&mut self) -> DatasetFilter {
        self.dataset_filter.take().unwrap_or_else(|| DatasetFilter::new())
    }
}

impl ::protobuf::Message for DatasetVersionDatasetFilterConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.dataset_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataset_filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataset_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataset_filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatasetVersionDatasetFilterConfig {
        DatasetVersionDatasetFilterConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatasetFilter>>(
                "dataset_filter",
                |m: &DatasetVersionDatasetFilterConfig| { &m.dataset_filter },
                |m: &mut DatasetVersionDatasetFilterConfig| { &mut m.dataset_filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatasetVersionDatasetFilterConfig>(
                "DatasetVersionDatasetFilterConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatasetVersionDatasetFilterConfig {
        static instance: ::protobuf::rt::LazyV2<DatasetVersionDatasetFilterConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatasetVersionDatasetFilterConfig::new)
    }
}

impl ::protobuf::Clear for DatasetVersionDatasetFilterConfig {
    fn clear(&mut self) {
        self.dataset_filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatasetVersionDatasetFilterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersionDatasetFilterConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatasetVersionSummary {
    // message fields
    pub input_counts: ::std::collections::HashMap<::std::string::String, u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatasetVersionSummary {
    fn default() -> &'a DatasetVersionSummary {
        <DatasetVersionSummary as ::protobuf::Message>::default_instance()
    }
}

impl DatasetVersionSummary {
    pub fn new() -> DatasetVersionSummary {
        ::std::default::Default::default()
    }

    // repeated .clarifai.api.DatasetVersionSummary.InputCountsEntry input_counts = 1;


    pub fn get_input_counts(&self) -> &::std::collections::HashMap<::std::string::String, u64> {
        &self.input_counts
    }
    pub fn clear_input_counts(&mut self) {
        self.input_counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_counts(&mut self, v: ::std::collections::HashMap<::std::string::String, u64>) {
        self.input_counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_counts(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u64> {
        &mut self.input_counts
    }

    // Take field
    pub fn take_input_counts(&mut self) -> ::std::collections::HashMap<::std::string::String, u64> {
        ::std::mem::replace(&mut self.input_counts, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DatasetVersionSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(wire_type, is, &mut self.input_counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(1, &self.input_counts);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(1, &self.input_counts, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatasetVersionSummary {
        DatasetVersionSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(
                "input_counts",
                |m: &DatasetVersionSummary| { &m.input_counts },
                |m: &mut DatasetVersionSummary| { &mut m.input_counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatasetVersionSummary>(
                "DatasetVersionSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatasetVersionSummary {
        static instance: ::protobuf::rt::LazyV2<DatasetVersionSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatasetVersionSummary::new)
    }
}

impl ::protobuf::Clear for DatasetVersionSummary {
    fn clear(&mut self) {
        self.input_counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatasetVersionSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetVersionSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkflowResultsSimilarity {
    // message fields
    pub probe_input: ::protobuf::SingularPtrField<Input>,
    pub pool_results: ::protobuf::RepeatedField<Hit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorkflowResultsSimilarity {
    fn default() -> &'a WorkflowResultsSimilarity {
        <WorkflowResultsSimilarity as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowResultsSimilarity {
    pub fn new() -> WorkflowResultsSimilarity {
        ::std::default::Default::default()
    }

    // .clarifai.api.Input probe_input = 1;


    pub fn get_probe_input(&self) -> &Input {
        self.probe_input.as_ref().unwrap_or_else(|| <Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_probe_input(&mut self) {
        self.probe_input.clear();
    }

    pub fn has_probe_input(&self) -> bool {
        self.probe_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_probe_input(&mut self, v: Input) {
        self.probe_input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_probe_input(&mut self) -> &mut Input {
        if self.probe_input.is_none() {
            self.probe_input.set_default();
        }
        self.probe_input.as_mut().unwrap()
    }

    // Take field
    pub fn take_probe_input(&mut self) -> Input {
        self.probe_input.take().unwrap_or_else(|| Input::new())
    }

    // repeated .clarifai.api.Hit pool_results = 2;


    pub fn get_pool_results(&self) -> &[Hit] {
        &self.pool_results
    }
    pub fn clear_pool_results(&mut self) {
        self.pool_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_pool_results(&mut self, v: ::protobuf::RepeatedField<Hit>) {
        self.pool_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pool_results(&mut self) -> &mut ::protobuf::RepeatedField<Hit> {
        &mut self.pool_results
    }

    // Take field
    pub fn take_pool_results(&mut self) -> ::protobuf::RepeatedField<Hit> {
        ::std::mem::replace(&mut self.pool_results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WorkflowResultsSimilarity {
    fn is_initialized(&self) -> bool {
        for v in &self.probe_input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pool_results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.probe_input)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pool_results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.probe_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pool_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.probe_input.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pool_results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkflowResultsSimilarity {
        WorkflowResultsSimilarity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Input>>(
                "probe_input",
                |m: &WorkflowResultsSimilarity| { &m.probe_input },
                |m: &mut WorkflowResultsSimilarity| { &mut m.probe_input },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hit>>(
                "pool_results",
                |m: &WorkflowResultsSimilarity| { &m.pool_results },
                |m: &mut WorkflowResultsSimilarity| { &mut m.pool_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorkflowResultsSimilarity>(
                "WorkflowResultsSimilarity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorkflowResultsSimilarity {
        static instance: ::protobuf::rt::LazyV2<WorkflowResultsSimilarity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorkflowResultsSimilarity::new)
    }
}

impl ::protobuf::Clear for WorkflowResultsSimilarity {
    fn clear(&mut self) {
        self.probe_input.clear();
        self.pool_results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkflowResultsSimilarity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowResultsSimilarity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    pub description: ::std::string::String,
    pub scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    pub apps: ::protobuf::RepeatedField<App>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub expires_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub authorized_idp_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string type = 8;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated string scopes = 3;


    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    // repeated string endpoints = 7;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.App apps = 4;


    pub fn get_apps(&self) -> &[App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp created_at = 5;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp expires_at = 6;


    pub fn get_expires_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expires_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expires_at(&mut self) {
        self.expires_at.clear();
    }

    pub fn has_expires_at(&self) -> bool {
        self.expires_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expires_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expires_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expires_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expires_at.is_none() {
            self.expires_at.set_default();
        }
        self.expires_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_expires_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expires_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated string authorized_idp_ids = 9;


    pub fn get_authorized_idp_ids(&self) -> &[::std::string::String] {
        &self.authorized_idp_ids
    }
    pub fn clear_authorized_idp_ids(&mut self) {
        self.authorized_idp_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_authorized_idp_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.authorized_idp_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authorized_idp_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.authorized_idp_ids
    }

    // Take field
    pub fn take_authorized_idp_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.authorized_idp_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Key {
    fn is_initialized(&self) -> bool {
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expires_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expires_at)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.authorized_idp_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.field_type);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expires_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.authorized_idp_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(8, &self.field_type)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.scopes {
            os.write_string(3, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(7, &v)?;
        };
        for v in &self.apps {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expires_at.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.authorized_idp_ids {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key {
        Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Key| { &m.id },
                |m: &mut Key| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Key| { &m.field_type },
                |m: &mut Key| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Key| { &m.description },
                |m: &mut Key| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &Key| { &m.scopes },
                |m: &mut Key| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &Key| { &m.endpoints },
                |m: &mut Key| { &mut m.endpoints },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<App>>(
                "apps",
                |m: &Key| { &m.apps },
                |m: &mut Key| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Key| { &m.created_at },
                |m: &mut Key| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "expires_at",
                |m: &Key| { &m.expires_at },
                |m: &mut Key| { &mut m.expires_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authorized_idp_ids",
                |m: &Key| { &m.authorized_idp_ids },
                |m: &mut Key| { &mut m.authorized_idp_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Key>(
                "Key",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Key {
        static instance: ::protobuf::rt::LazyV2<Key> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Key::new)
    }
}

impl ::protobuf::Clear for Key {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type.clear();
        self.description.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.apps.clear();
        self.created_at.clear();
        self.expires_at.clear();
        self.authorized_idp_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Model {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub app_id: ::std::string::String,
    pub output_info: ::protobuf::SingularPtrField<OutputInfo>,
    pub model_version: ::protobuf::SingularPtrField<ModelVersion>,
    pub display_name: ::std::string::String,
    pub user_id: ::std::string::String,
    pub input_info: ::protobuf::SingularPtrField<InputInfo>,
    pub train_info: ::protobuf::SingularPtrField<TrainInfo>,
    pub model_type_id: ::std::string::String,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub description: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub notes: ::std::string::String,
    pub toolkits: ::protobuf::RepeatedField<::std::string::String>,
    pub use_cases: ::protobuf::RepeatedField<::std::string::String>,
    pub languages: ::protobuf::RepeatedField<::std::string::String>,
    pub is_starred: bool,
    pub star_count: i32,
    pub import_info: ::protobuf::SingularPtrField<ImportInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Model {
    fn default() -> &'a Model {
        <Model as ::protobuf::Message>::default_instance()
    }
}

impl Model {
    pub fn new() -> Model {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 3;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 19;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string app_id = 4;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // .clarifai.api.OutputInfo output_info = 5;


    pub fn get_output_info(&self) -> &OutputInfo {
        self.output_info.as_ref().unwrap_or_else(|| <OutputInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_info(&mut self) {
        self.output_info.clear();
    }

    pub fn has_output_info(&self) -> bool {
        self.output_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_info(&mut self, v: OutputInfo) {
        self.output_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_info(&mut self) -> &mut OutputInfo {
        if self.output_info.is_none() {
            self.output_info.set_default();
        }
        self.output_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_info(&mut self) -> OutputInfo {
        self.output_info.take().unwrap_or_else(|| OutputInfo::new())
    }

    // .clarifai.api.ModelVersion model_version = 6;


    pub fn get_model_version(&self) -> &ModelVersion {
        self.model_version.as_ref().unwrap_or_else(|| <ModelVersion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_version(&mut self) {
        self.model_version.clear();
    }

    pub fn has_model_version(&self) -> bool {
        self.model_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_version(&mut self, v: ModelVersion) {
        self.model_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version(&mut self) -> &mut ModelVersion {
        if self.model_version.is_none() {
            self.model_version.set_default();
        }
        self.model_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_version(&mut self) -> ModelVersion {
        self.model_version.take().unwrap_or_else(|| ModelVersion::new())
    }

    // string display_name = 7;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string user_id = 9;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // .clarifai.api.InputInfo input_info = 12;


    pub fn get_input_info(&self) -> &InputInfo {
        self.input_info.as_ref().unwrap_or_else(|| <InputInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_info(&mut self) {
        self.input_info.clear();
    }

    pub fn has_input_info(&self) -> bool {
        self.input_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_info(&mut self, v: InputInfo) {
        self.input_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_info(&mut self) -> &mut InputInfo {
        if self.input_info.is_none() {
            self.input_info.set_default();
        }
        self.input_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_info(&mut self) -> InputInfo {
        self.input_info.take().unwrap_or_else(|| InputInfo::new())
    }

    // .clarifai.api.TrainInfo train_info = 13;


    pub fn get_train_info(&self) -> &TrainInfo {
        self.train_info.as_ref().unwrap_or_else(|| <TrainInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_train_info(&mut self) {
        self.train_info.clear();
    }

    pub fn has_train_info(&self) -> bool {
        self.train_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train_info(&mut self, v: TrainInfo) {
        self.train_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_train_info(&mut self) -> &mut TrainInfo {
        if self.train_info.is_none() {
            self.train_info.set_default();
        }
        self.train_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_train_info(&mut self) -> TrainInfo {
        self.train_info.take().unwrap_or_else(|| TrainInfo::new())
    }

    // string model_type_id = 14;


    pub fn get_model_type_id(&self) -> &str {
        &self.model_type_id
    }
    pub fn clear_model_type_id(&mut self) {
        self.model_type_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_type_id(&mut self, v: ::std::string::String) {
        self.model_type_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_type_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_type_id
    }

    // Take field
    pub fn take_model_type_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_type_id, ::std::string::String::new())
    }

    // .clarifai.api.Visibility visibility = 15;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // string description = 16;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.protobuf.Struct metadata = 17;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string notes = 18;


    pub fn get_notes(&self) -> &str {
        &self.notes
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::std::string::String) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notes(&mut self) -> &mut ::std::string::String {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notes, ::std::string::String::new())
    }

    // repeated string toolkits = 20;


    pub fn get_toolkits(&self) -> &[::std::string::String] {
        &self.toolkits
    }
    pub fn clear_toolkits(&mut self) {
        self.toolkits.clear();
    }

    // Param is passed by value, moved
    pub fn set_toolkits(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.toolkits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_toolkits(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.toolkits
    }

    // Take field
    pub fn take_toolkits(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.toolkits, ::protobuf::RepeatedField::new())
    }

    // repeated string use_cases = 21;


    pub fn get_use_cases(&self) -> &[::std::string::String] {
        &self.use_cases
    }
    pub fn clear_use_cases(&mut self) {
        self.use_cases.clear();
    }

    // Param is passed by value, moved
    pub fn set_use_cases(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.use_cases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_use_cases(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.use_cases
    }

    // Take field
    pub fn take_use_cases(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.use_cases, ::protobuf::RepeatedField::new())
    }

    // repeated string languages = 25;


    pub fn get_languages(&self) -> &[::std::string::String] {
        &self.languages
    }
    pub fn clear_languages(&mut self) {
        self.languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_languages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_languages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.languages
    }

    // Take field
    pub fn take_languages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.languages, ::protobuf::RepeatedField::new())
    }

    // bool is_starred = 22;


    pub fn get_is_starred(&self) -> bool {
        self.is_starred
    }
    pub fn clear_is_starred(&mut self) {
        self.is_starred = false;
    }

    // Param is passed by value, moved
    pub fn set_is_starred(&mut self, v: bool) {
        self.is_starred = v;
    }

    // int32 star_count = 23;


    pub fn get_star_count(&self) -> i32 {
        self.star_count
    }
    pub fn clear_star_count(&mut self) {
        self.star_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_star_count(&mut self, v: i32) {
        self.star_count = v;
    }

    // .clarifai.api.ImportInfo import_info = 24;


    pub fn get_import_info(&self) -> &ImportInfo {
        self.import_info.as_ref().unwrap_or_else(|| <ImportInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_import_info(&mut self) {
        self.import_info.clear();
    }

    pub fn has_import_info(&self) -> bool {
        self.import_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_import_info(&mut self, v: ImportInfo) {
        self.import_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_import_info(&mut self) -> &mut ImportInfo {
        if self.import_info.is_none() {
            self.import_info.set_default();
        }
        self.import_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_import_info(&mut self) -> ImportInfo {
        self.import_info.take().unwrap_or_else(|| ImportInfo::new())
    }
}

impl ::protobuf::Message for Model {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.train_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.import_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_info)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_version)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_info)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.train_info)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_type_id)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notes)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.toolkits)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.use_cases)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.languages)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_starred = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.star_count = tmp;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.import_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_id);
        }
        if let Some(ref v) = self.output_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.display_name);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.user_id);
        }
        if let Some(ref v) = self.input_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.train_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.model_type_id);
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.description);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.notes);
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.use_cases {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(25, &value);
        };
        if self.is_starred != false {
            my_size += 3;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::value_size(23, self.star_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.import_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(4, &self.app_id)?;
        }
        if let Some(ref v) = self.output_info.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model_version.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(7, &self.display_name)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(9, &self.user_id)?;
        }
        if let Some(ref v) = self.input_info.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.train_info.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(14, &self.model_type_id)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.description.is_empty() {
            os.write_string(16, &self.description)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.notes.is_empty() {
            os.write_string(18, &self.notes)?;
        }
        for v in &self.toolkits {
            os.write_string(20, &v)?;
        };
        for v in &self.use_cases {
            os.write_string(21, &v)?;
        };
        for v in &self.languages {
            os.write_string(25, &v)?;
        };
        if self.is_starred != false {
            os.write_bool(22, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(23, self.star_count)?;
        }
        if let Some(ref v) = self.import_info.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Model {
        Model::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Model| { &m.id },
                |m: &mut Model| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Model| { &m.name },
                |m: &mut Model| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Model| { &m.created_at },
                |m: &mut Model| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &Model| { &m.modified_at },
                |m: &mut Model| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &Model| { &m.app_id },
                |m: &mut Model| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputInfo>>(
                "output_info",
                |m: &Model| { &m.output_info },
                |m: &mut Model| { &mut m.output_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelVersion>>(
                "model_version",
                |m: &Model| { &m.model_version },
                |m: &mut Model| { &mut m.model_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &Model| { &m.display_name },
                |m: &mut Model| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &Model| { &m.user_id },
                |m: &mut Model| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputInfo>>(
                "input_info",
                |m: &Model| { &m.input_info },
                |m: &mut Model| { &mut m.input_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrainInfo>>(
                "train_info",
                |m: &Model| { &m.train_info },
                |m: &mut Model| { &mut m.train_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_type_id",
                |m: &Model| { &m.model_type_id },
                |m: &mut Model| { &mut m.model_type_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &Model| { &m.visibility },
                |m: &mut Model| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Model| { &m.description },
                |m: &mut Model| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &Model| { &m.metadata },
                |m: &mut Model| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notes",
                |m: &Model| { &m.notes },
                |m: &mut Model| { &mut m.notes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "toolkits",
                |m: &Model| { &m.toolkits },
                |m: &mut Model| { &mut m.toolkits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "use_cases",
                |m: &Model| { &m.use_cases },
                |m: &mut Model| { &mut m.use_cases },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "languages",
                |m: &Model| { &m.languages },
                |m: &mut Model| { &mut m.languages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_starred",
                |m: &Model| { &m.is_starred },
                |m: &mut Model| { &mut m.is_starred },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "star_count",
                |m: &Model| { &m.star_count },
                |m: &mut Model| { &mut m.star_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImportInfo>>(
                "import_info",
                |m: &Model| { &m.import_info },
                |m: &mut Model| { &mut m.import_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Model>(
                "Model",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Model {
        static instance: ::protobuf::rt::LazyV2<Model> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Model::new)
    }
}

impl ::protobuf::Clear for Model {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.app_id.clear();
        self.output_info.clear();
        self.model_version.clear();
        self.display_name.clear();
        self.user_id.clear();
        self.input_info.clear();
        self.train_info.clear();
        self.model_type_id.clear();
        self.visibility.clear();
        self.description.clear();
        self.metadata.clear();
        self.notes.clear();
        self.toolkits.clear();
        self.use_cases.clear();
        self.languages.clear();
        self.is_starred = false;
        self.star_count = 0;
        self.import_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Model {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Model {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelReference {
    // message fields
    pub id: ::std::string::String,
    pub model_id: ::std::string::String,
    pub url: ::std::string::String,
    pub name: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelReference {
    fn default() -> &'a ModelReference {
        <ModelReference as ::protobuf::Message>::default_instance()
    }
}

impl ModelReference {
    pub fn new() -> ModelReference {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string url = 3;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct metadata = 5;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for ModelReference {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelReference {
        ModelReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ModelReference| { &m.id },
                |m: &mut ModelReference| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &ModelReference| { &m.model_id },
                |m: &mut ModelReference| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ModelReference| { &m.url },
                |m: &mut ModelReference| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ModelReference| { &m.name },
                |m: &mut ModelReference| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &ModelReference| { &m.metadata },
                |m: &mut ModelReference| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelReference>(
                "ModelReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelReference {
        static instance: ::protobuf::rt::LazyV2<ModelReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelReference::new)
    }
}

impl ::protobuf::Clear for ModelReference {
    fn clear(&mut self) {
        self.id.clear();
        self.model_id.clear();
        self.url.clear();
        self.name.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelVersionInputExample {
    // message fields
    pub id: ::std::string::String,
    pub model_id: ::std::string::String,
    pub model_version_id: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<Data>,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelVersionInputExample {
    fn default() -> &'a ModelVersionInputExample {
        <ModelVersionInputExample as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionInputExample {
    pub fn new() -> ModelVersionInputExample {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string model_version_id = 3;


    pub fn get_model_version_id(&self) -> &str {
        &self.model_version_id
    }
    pub fn clear_model_version_id(&mut self) {
        self.model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_id(&mut self, v: ::std::string::String) {
        self.model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_version_id
    }

    // Take field
    pub fn take_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_version_id, ::std::string::String::new())
    }

    // .clarifai.api.Data data = 4;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 6;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModelVersionInputExample {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelVersionInputExample {
        ModelVersionInputExample::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ModelVersionInputExample| { &m.id },
                |m: &mut ModelVersionInputExample| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &ModelVersionInputExample| { &m.model_id },
                |m: &mut ModelVersionInputExample| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_id",
                |m: &ModelVersionInputExample| { &m.model_version_id },
                |m: &mut ModelVersionInputExample| { &mut m.model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &ModelVersionInputExample| { &m.data },
                |m: &mut ModelVersionInputExample| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ModelVersionInputExample| { &m.name },
                |m: &mut ModelVersionInputExample| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ModelVersionInputExample| { &m.description },
                |m: &mut ModelVersionInputExample| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelVersionInputExample>(
                "ModelVersionInputExample",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelVersionInputExample {
        static instance: ::protobuf::rt::LazyV2<ModelVersionInputExample> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelVersionInputExample::new)
    }
}

impl ::protobuf::Clear for ModelVersionInputExample {
    fn clear(&mut self) {
        self.id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.data.clear();
        self.name.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelVersionInputExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionInputExample {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputInfo {
    // message fields
    pub data: ::protobuf::SingularPtrField<Data>,
    pub output_config: ::protobuf::SingularPtrField<OutputConfig>,
    pub message: ::std::string::String,
    pub field_type: ::std::string::String,
    pub type_ext: ::std::string::String,
    pub fields_map: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub params: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputInfo {
    fn default() -> &'a OutputInfo {
        <OutputInfo as ::protobuf::Message>::default_instance()
    }
}

impl OutputInfo {
    pub fn new() -> OutputInfo {
        ::std::default::Default::default()
    }

    // .clarifai.api.Data data = 1;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // .clarifai.api.OutputConfig output_config = 2;


    pub fn get_output_config(&self) -> &OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> OutputConfig {
        self.output_config.take().unwrap_or_else(|| OutputConfig::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string type = 4;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string type_ext = 5;


    pub fn get_type_ext(&self) -> &str {
        &self.type_ext
    }
    pub fn clear_type_ext(&mut self) {
        self.type_ext.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_ext(&mut self, v: ::std::string::String) {
        self.type_ext = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_ext(&mut self) -> &mut ::std::string::String {
        &mut self.type_ext
    }

    // Take field
    pub fn take_type_ext(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.type_ext, ::std::string::String::new())
    }

    // .google.protobuf.Struct fields_map = 6;


    pub fn get_fields_map(&self) -> &::protobuf::well_known_types::Struct {
        self.fields_map.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fields_map(&mut self) {
        self.fields_map.clear();
    }

    pub fn has_fields_map(&self) -> bool {
        self.fields_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fields_map(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.fields_map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fields_map(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.fields_map.is_none() {
            self.fields_map.set_default();
        }
        self.fields_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_fields_map(&mut self) -> ::protobuf::well_known_types::Struct {
        self.fields_map.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .google.protobuf.Struct params = 7;


    pub fn get_params(&self) -> &::protobuf::well_known_types::Struct {
        self.params.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::well_known_types::Struct {
        self.params.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for OutputInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fields_map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.type_ext)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fields_map)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.field_type);
        }
        if !self.type_ext.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.type_ext);
        }
        if let Some(ref v) = self.fields_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(4, &self.field_type)?;
        }
        if !self.type_ext.is_empty() {
            os.write_string(5, &self.type_ext)?;
        }
        if let Some(ref v) = self.fields_map.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputInfo {
        OutputInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &OutputInfo| { &m.data },
                |m: &mut OutputInfo| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputConfig>>(
                "output_config",
                |m: &OutputInfo| { &m.output_config },
                |m: &mut OutputInfo| { &mut m.output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &OutputInfo| { &m.message },
                |m: &mut OutputInfo| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &OutputInfo| { &m.field_type },
                |m: &mut OutputInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type_ext",
                |m: &OutputInfo| { &m.type_ext },
                |m: &mut OutputInfo| { &mut m.type_ext },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "fields_map",
                |m: &OutputInfo| { &m.fields_map },
                |m: &mut OutputInfo| { &mut m.fields_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "params",
                |m: &OutputInfo| { &m.params },
                |m: &mut OutputInfo| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputInfo>(
                "OutputInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputInfo {
        static instance: ::protobuf::rt::LazyV2<OutputInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputInfo::new)
    }
}

impl ::protobuf::Clear for OutputInfo {
    fn clear(&mut self) {
        self.data.clear();
        self.output_config.clear();
        self.message.clear();
        self.field_type.clear();
        self.type_ext.clear();
        self.fields_map.clear();
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InputInfo {
    // message fields
    pub fields_map: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub params: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputInfo {
    fn default() -> &'a InputInfo {
        <InputInfo as ::protobuf::Message>::default_instance()
    }
}

impl InputInfo {
    pub fn new() -> InputInfo {
        ::std::default::Default::default()
    }

    // .google.protobuf.Struct fields_map = 1;


    pub fn get_fields_map(&self) -> &::protobuf::well_known_types::Struct {
        self.fields_map.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fields_map(&mut self) {
        self.fields_map.clear();
    }

    pub fn has_fields_map(&self) -> bool {
        self.fields_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fields_map(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.fields_map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fields_map(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.fields_map.is_none() {
            self.fields_map.set_default();
        }
        self.fields_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_fields_map(&mut self) -> ::protobuf::well_known_types::Struct {
        self.fields_map.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .google.protobuf.Struct params = 2;


    pub fn get_params(&self) -> &::protobuf::well_known_types::Struct {
        self.params.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::well_known_types::Struct {
        self.params.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for InputInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.fields_map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fields_map)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fields_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fields_map.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputInfo {
        InputInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "fields_map",
                |m: &InputInfo| { &m.fields_map },
                |m: &mut InputInfo| { &mut m.fields_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "params",
                |m: &InputInfo| { &m.params },
                |m: &mut InputInfo| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InputInfo>(
                "InputInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputInfo {
        static instance: ::protobuf::rt::LazyV2<InputInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InputInfo::new)
    }
}

impl ::protobuf::Clear for InputInfo {
    fn clear(&mut self) {
        self.fields_map.clear();
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrainInfo {
    // message fields
    pub params: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrainInfo {
    fn default() -> &'a TrainInfo {
        <TrainInfo as ::protobuf::Message>::default_instance()
    }
}

impl TrainInfo {
    pub fn new() -> TrainInfo {
        ::std::default::Default::default()
    }

    // .google.protobuf.Struct params = 1;


    pub fn get_params(&self) -> &::protobuf::well_known_types::Struct {
        self.params.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::well_known_types::Struct {
        self.params.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for TrainInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrainInfo {
        TrainInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "params",
                |m: &TrainInfo| { &m.params },
                |m: &mut TrainInfo| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrainInfo>(
                "TrainInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrainInfo {
        static instance: ::protobuf::rt::LazyV2<TrainInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrainInfo::new)
    }
}

impl ::protobuf::Clear for TrainInfo {
    fn clear(&mut self) {
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrainInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportInfo {
    // message fields
    pub params: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportInfo {
    fn default() -> &'a ImportInfo {
        <ImportInfo as ::protobuf::Message>::default_instance()
    }
}

impl ImportInfo {
    pub fn new() -> ImportInfo {
        ::std::default::Default::default()
    }

    // .google.protobuf.Struct params = 1;


    pub fn get_params(&self) -> &::protobuf::well_known_types::Struct {
        self.params.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::well_known_types::Struct {
        self.params.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for ImportInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportInfo {
        ImportInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "params",
                |m: &ImportInfo| { &m.params },
                |m: &mut ImportInfo| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImportInfo>(
                "ImportInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImportInfo {
        static instance: ::protobuf::rt::LazyV2<ImportInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImportInfo::new)
    }
}

impl ::protobuf::Clear for ImportInfo {
    fn clear(&mut self) {
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImportInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputConfig {
    // message fields
    pub concepts_mutually_exclusive: bool,
    pub closed_environment: bool,
    pub existing_model_id: ::std::string::String,
    pub language: ::std::string::String,
    pub hyper_parameters: ::std::string::String,
    pub max_concepts: u32,
    pub min_value: f32,
    pub select_concepts: ::protobuf::RepeatedField<Concept>,
    pub training_timeout: u32,
    pub sample_ms: u32,
    pub hyper_params: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub embed_model_version_id: ::std::string::String,
    pub fail_on_missing_positive_examples: bool,
    pub model_metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputConfig {
    fn default() -> &'a OutputConfig {
        <OutputConfig as ::protobuf::Message>::default_instance()
    }
}

impl OutputConfig {
    pub fn new() -> OutputConfig {
        ::std::default::Default::default()
    }

    // bool concepts_mutually_exclusive = 1;


    pub fn get_concepts_mutually_exclusive(&self) -> bool {
        self.concepts_mutually_exclusive
    }
    pub fn clear_concepts_mutually_exclusive(&mut self) {
        self.concepts_mutually_exclusive = false;
    }

    // Param is passed by value, moved
    pub fn set_concepts_mutually_exclusive(&mut self, v: bool) {
        self.concepts_mutually_exclusive = v;
    }

    // bool closed_environment = 2;


    pub fn get_closed_environment(&self) -> bool {
        self.closed_environment
    }
    pub fn clear_closed_environment(&mut self) {
        self.closed_environment = false;
    }

    // Param is passed by value, moved
    pub fn set_closed_environment(&mut self, v: bool) {
        self.closed_environment = v;
    }

    // string existing_model_id = 3;


    pub fn get_existing_model_id(&self) -> &str {
        &self.existing_model_id
    }
    pub fn clear_existing_model_id(&mut self) {
        self.existing_model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_existing_model_id(&mut self, v: ::std::string::String) {
        self.existing_model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_existing_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.existing_model_id
    }

    // Take field
    pub fn take_existing_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.existing_model_id, ::std::string::String::new())
    }

    // string language = 4;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }

    // string hyper_parameters = 5;


    pub fn get_hyper_parameters(&self) -> &str {
        &self.hyper_parameters
    }
    pub fn clear_hyper_parameters(&mut self) {
        self.hyper_parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_hyper_parameters(&mut self, v: ::std::string::String) {
        self.hyper_parameters = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hyper_parameters(&mut self) -> &mut ::std::string::String {
        &mut self.hyper_parameters
    }

    // Take field
    pub fn take_hyper_parameters(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hyper_parameters, ::std::string::String::new())
    }

    // uint32 max_concepts = 6;


    pub fn get_max_concepts(&self) -> u32 {
        self.max_concepts
    }
    pub fn clear_max_concepts(&mut self) {
        self.max_concepts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_concepts(&mut self, v: u32) {
        self.max_concepts = v;
    }

    // float min_value = 7;


    pub fn get_min_value(&self) -> f32 {
        self.min_value
    }
    pub fn clear_min_value(&mut self) {
        self.min_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_value(&mut self, v: f32) {
        self.min_value = v;
    }

    // repeated .clarifai.api.Concept select_concepts = 8;


    pub fn get_select_concepts(&self) -> &[Concept] {
        &self.select_concepts
    }
    pub fn clear_select_concepts(&mut self) {
        self.select_concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_select_concepts(&mut self, v: ::protobuf::RepeatedField<Concept>) {
        self.select_concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_select_concepts(&mut self) -> &mut ::protobuf::RepeatedField<Concept> {
        &mut self.select_concepts
    }

    // Take field
    pub fn take_select_concepts(&mut self) -> ::protobuf::RepeatedField<Concept> {
        ::std::mem::replace(&mut self.select_concepts, ::protobuf::RepeatedField::new())
    }

    // uint32 training_timeout = 9;


    pub fn get_training_timeout(&self) -> u32 {
        self.training_timeout
    }
    pub fn clear_training_timeout(&mut self) {
        self.training_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_training_timeout(&mut self, v: u32) {
        self.training_timeout = v;
    }

    // uint32 sample_ms = 10;


    pub fn get_sample_ms(&self) -> u32 {
        self.sample_ms
    }
    pub fn clear_sample_ms(&mut self) {
        self.sample_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_sample_ms(&mut self, v: u32) {
        self.sample_ms = v;
    }

    // .google.protobuf.Struct hyper_params = 13;


    pub fn get_hyper_params(&self) -> &::protobuf::well_known_types::Struct {
        self.hyper_params.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hyper_params(&mut self) {
        self.hyper_params.clear();
    }

    pub fn has_hyper_params(&self) -> bool {
        self.hyper_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hyper_params(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.hyper_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hyper_params(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.hyper_params.is_none() {
            self.hyper_params.set_default();
        }
        self.hyper_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_hyper_params(&mut self) -> ::protobuf::well_known_types::Struct {
        self.hyper_params.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string embed_model_version_id = 14;


    pub fn get_embed_model_version_id(&self) -> &str {
        &self.embed_model_version_id
    }
    pub fn clear_embed_model_version_id(&mut self) {
        self.embed_model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_embed_model_version_id(&mut self, v: ::std::string::String) {
        self.embed_model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_embed_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.embed_model_version_id
    }

    // Take field
    pub fn take_embed_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.embed_model_version_id, ::std::string::String::new())
    }

    // bool fail_on_missing_positive_examples = 15;


    pub fn get_fail_on_missing_positive_examples(&self) -> bool {
        self.fail_on_missing_positive_examples
    }
    pub fn clear_fail_on_missing_positive_examples(&mut self) {
        self.fail_on_missing_positive_examples = false;
    }

    // Param is passed by value, moved
    pub fn set_fail_on_missing_positive_examples(&mut self, v: bool) {
        self.fail_on_missing_positive_examples = v;
    }

    // .google.protobuf.Struct model_metadata = 17;


    pub fn get_model_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.model_metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_metadata(&mut self) {
        self.model_metadata.clear();
    }

    pub fn has_model_metadata(&self) -> bool {
        self.model_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.model_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.model_metadata.is_none() {
            self.model_metadata.set_default();
        }
        self.model_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.model_metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for OutputConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.select_concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hyper_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.concepts_mutually_exclusive = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.closed_environment = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.existing_model_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hyper_parameters)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_concepts = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min_value = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.select_concepts)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.training_timeout = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sample_ms = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hyper_params)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.embed_model_version_id)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fail_on_missing_positive_examples = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.concepts_mutually_exclusive != false {
            my_size += 2;
        }
        if self.closed_environment != false {
            my_size += 2;
        }
        if !self.existing_model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.existing_model_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language);
        }
        if !self.hyper_parameters.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.hyper_parameters);
        }
        if self.max_concepts != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_concepts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_value != 0. {
            my_size += 5;
        }
        for value in &self.select_concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.training_timeout != 0 {
            my_size += ::protobuf::rt::value_size(9, self.training_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sample_ms != 0 {
            my_size += ::protobuf::rt::value_size(10, self.sample_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hyper_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.embed_model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.embed_model_version_id);
        }
        if self.fail_on_missing_positive_examples != false {
            my_size += 2;
        }
        if let Some(ref v) = self.model_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.concepts_mutually_exclusive != false {
            os.write_bool(1, self.concepts_mutually_exclusive)?;
        }
        if self.closed_environment != false {
            os.write_bool(2, self.closed_environment)?;
        }
        if !self.existing_model_id.is_empty() {
            os.write_string(3, &self.existing_model_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(4, &self.language)?;
        }
        if !self.hyper_parameters.is_empty() {
            os.write_string(5, &self.hyper_parameters)?;
        }
        if self.max_concepts != 0 {
            os.write_uint32(6, self.max_concepts)?;
        }
        if self.min_value != 0. {
            os.write_float(7, self.min_value)?;
        }
        for v in &self.select_concepts {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.training_timeout != 0 {
            os.write_uint32(9, self.training_timeout)?;
        }
        if self.sample_ms != 0 {
            os.write_uint32(10, self.sample_ms)?;
        }
        if let Some(ref v) = self.hyper_params.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.embed_model_version_id.is_empty() {
            os.write_string(14, &self.embed_model_version_id)?;
        }
        if self.fail_on_missing_positive_examples != false {
            os.write_bool(15, self.fail_on_missing_positive_examples)?;
        }
        if let Some(ref v) = self.model_metadata.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputConfig {
        OutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "concepts_mutually_exclusive",
                |m: &OutputConfig| { &m.concepts_mutually_exclusive },
                |m: &mut OutputConfig| { &mut m.concepts_mutually_exclusive },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "closed_environment",
                |m: &OutputConfig| { &m.closed_environment },
                |m: &mut OutputConfig| { &mut m.closed_environment },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "existing_model_id",
                |m: &OutputConfig| { &m.existing_model_id },
                |m: &mut OutputConfig| { &mut m.existing_model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &OutputConfig| { &m.language },
                |m: &mut OutputConfig| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hyper_parameters",
                |m: &OutputConfig| { &m.hyper_parameters },
                |m: &mut OutputConfig| { &mut m.hyper_parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_concepts",
                |m: &OutputConfig| { &m.max_concepts },
                |m: &mut OutputConfig| { &mut m.max_concepts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min_value",
                |m: &OutputConfig| { &m.min_value },
                |m: &mut OutputConfig| { &mut m.min_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Concept>>(
                "select_concepts",
                |m: &OutputConfig| { &m.select_concepts },
                |m: &mut OutputConfig| { &mut m.select_concepts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "training_timeout",
                |m: &OutputConfig| { &m.training_timeout },
                |m: &mut OutputConfig| { &mut m.training_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sample_ms",
                |m: &OutputConfig| { &m.sample_ms },
                |m: &mut OutputConfig| { &mut m.sample_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "hyper_params",
                |m: &OutputConfig| { &m.hyper_params },
                |m: &mut OutputConfig| { &mut m.hyper_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "embed_model_version_id",
                |m: &OutputConfig| { &m.embed_model_version_id },
                |m: &mut OutputConfig| { &mut m.embed_model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fail_on_missing_positive_examples",
                |m: &OutputConfig| { &m.fail_on_missing_positive_examples },
                |m: &mut OutputConfig| { &mut m.fail_on_missing_positive_examples },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "model_metadata",
                |m: &OutputConfig| { &m.model_metadata },
                |m: &mut OutputConfig| { &mut m.model_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputConfig>(
                "OutputConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputConfig {
        static instance: ::protobuf::rt::LazyV2<OutputConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputConfig::new)
    }
}

impl ::protobuf::Clear for OutputConfig {
    fn clear(&mut self) {
        self.concepts_mutually_exclusive = false;
        self.closed_environment = false;
        self.existing_model_id.clear();
        self.language.clear();
        self.hyper_parameters.clear();
        self.max_concepts = 0;
        self.min_value = 0.;
        self.select_concepts.clear();
        self.training_timeout = 0;
        self.sample_ms = 0;
        self.hyper_params.clear();
        self.embed_model_version_id.clear();
        self.fail_on_missing_positive_examples = false;
        self.model_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelType {
    // message fields
    pub id: ::std::string::String,
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub field_type: ::std::string::String,
    pub input_fields: ::protobuf::RepeatedField<::std::string::String>,
    pub output_fields: ::protobuf::RepeatedField<::std::string::String>,
    pub trainable: bool,
    pub creatable: bool,
    pub internal_only: bool,
    pub model_type_fields: ::protobuf::RepeatedField<ModelTypeField>,
    pub requires_sequential_frames: bool,
    pub evaluable: bool,
    pub expected_pretrained_input_fields: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub expected_pretrained_output_fields: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelType {
    fn default() -> &'a ModelType {
        <ModelType as ::protobuf::Message>::default_instance()
    }
}

impl ModelType {
    pub fn new() -> ModelType {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string title = 2;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string type = 4;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // repeated string input_fields = 5;


    pub fn get_input_fields(&self) -> &[::std::string::String] {
        &self.input_fields
    }
    pub fn clear_input_fields(&mut self) {
        self.input_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input_fields
    }

    // Take field
    pub fn take_input_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input_fields, ::protobuf::RepeatedField::new())
    }

    // repeated string output_fields = 6;


    pub fn get_output_fields(&self) -> &[::std::string::String] {
        &self.output_fields
    }
    pub fn clear_output_fields(&mut self) {
        self.output_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.output_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.output_fields
    }

    // Take field
    pub fn take_output_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.output_fields, ::protobuf::RepeatedField::new())
    }

    // bool trainable = 8;


    pub fn get_trainable(&self) -> bool {
        self.trainable
    }
    pub fn clear_trainable(&mut self) {
        self.trainable = false;
    }

    // Param is passed by value, moved
    pub fn set_trainable(&mut self, v: bool) {
        self.trainable = v;
    }

    // bool creatable = 9;


    pub fn get_creatable(&self) -> bool {
        self.creatable
    }
    pub fn clear_creatable(&mut self) {
        self.creatable = false;
    }

    // Param is passed by value, moved
    pub fn set_creatable(&mut self, v: bool) {
        self.creatable = v;
    }

    // bool internal_only = 10;


    pub fn get_internal_only(&self) -> bool {
        self.internal_only
    }
    pub fn clear_internal_only(&mut self) {
        self.internal_only = false;
    }

    // Param is passed by value, moved
    pub fn set_internal_only(&mut self, v: bool) {
        self.internal_only = v;
    }

    // repeated .clarifai.api.ModelTypeField model_type_fields = 11;


    pub fn get_model_type_fields(&self) -> &[ModelTypeField] {
        &self.model_type_fields
    }
    pub fn clear_model_type_fields(&mut self) {
        self.model_type_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_type_fields(&mut self, v: ::protobuf::RepeatedField<ModelTypeField>) {
        self.model_type_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_type_fields(&mut self) -> &mut ::protobuf::RepeatedField<ModelTypeField> {
        &mut self.model_type_fields
    }

    // Take field
    pub fn take_model_type_fields(&mut self) -> ::protobuf::RepeatedField<ModelTypeField> {
        ::std::mem::replace(&mut self.model_type_fields, ::protobuf::RepeatedField::new())
    }

    // bool requires_sequential_frames = 12;


    pub fn get_requires_sequential_frames(&self) -> bool {
        self.requires_sequential_frames
    }
    pub fn clear_requires_sequential_frames(&mut self) {
        self.requires_sequential_frames = false;
    }

    // Param is passed by value, moved
    pub fn set_requires_sequential_frames(&mut self, v: bool) {
        self.requires_sequential_frames = v;
    }

    // bool evaluable = 13;


    pub fn get_evaluable(&self) -> bool {
        self.evaluable
    }
    pub fn clear_evaluable(&mut self) {
        self.evaluable = false;
    }

    // Param is passed by value, moved
    pub fn set_evaluable(&mut self, v: bool) {
        self.evaluable = v;
    }

    // .google.protobuf.Struct expected_pretrained_input_fields = 14;


    pub fn get_expected_pretrained_input_fields(&self) -> &::protobuf::well_known_types::Struct {
        self.expected_pretrained_input_fields.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expected_pretrained_input_fields(&mut self) {
        self.expected_pretrained_input_fields.clear();
    }

    pub fn has_expected_pretrained_input_fields(&self) -> bool {
        self.expected_pretrained_input_fields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_pretrained_input_fields(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.expected_pretrained_input_fields = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expected_pretrained_input_fields(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.expected_pretrained_input_fields.is_none() {
            self.expected_pretrained_input_fields.set_default();
        }
        self.expected_pretrained_input_fields.as_mut().unwrap()
    }

    // Take field
    pub fn take_expected_pretrained_input_fields(&mut self) -> ::protobuf::well_known_types::Struct {
        self.expected_pretrained_input_fields.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .google.protobuf.Struct expected_pretrained_output_fields = 15;


    pub fn get_expected_pretrained_output_fields(&self) -> &::protobuf::well_known_types::Struct {
        self.expected_pretrained_output_fields.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expected_pretrained_output_fields(&mut self) {
        self.expected_pretrained_output_fields.clear();
    }

    pub fn has_expected_pretrained_output_fields(&self) -> bool {
        self.expected_pretrained_output_fields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_pretrained_output_fields(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.expected_pretrained_output_fields = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expected_pretrained_output_fields(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.expected_pretrained_output_fields.is_none() {
            self.expected_pretrained_output_fields.set_default();
        }
        self.expected_pretrained_output_fields.as_mut().unwrap()
    }

    // Take field
    pub fn take_expected_pretrained_output_fields(&mut self) -> ::protobuf::well_known_types::Struct {
        self.expected_pretrained_output_fields.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for ModelType {
    fn is_initialized(&self) -> bool {
        for v in &self.model_type_fields {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expected_pretrained_input_fields {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expected_pretrained_output_fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input_fields)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.output_fields)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trainable = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.creatable = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.internal_only = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_type_fields)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requires_sequential_frames = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.evaluable = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expected_pretrained_input_fields)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expected_pretrained_output_fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.field_type);
        }
        for value in &self.input_fields {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.output_fields {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.trainable != false {
            my_size += 2;
        }
        if self.creatable != false {
            my_size += 2;
        }
        if self.internal_only != false {
            my_size += 2;
        }
        for value in &self.model_type_fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.requires_sequential_frames != false {
            my_size += 2;
        }
        if self.evaluable != false {
            my_size += 2;
        }
        if let Some(ref v) = self.expected_pretrained_input_fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expected_pretrained_output_fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(4, &self.field_type)?;
        }
        for v in &self.input_fields {
            os.write_string(5, &v)?;
        };
        for v in &self.output_fields {
            os.write_string(6, &v)?;
        };
        if self.trainable != false {
            os.write_bool(8, self.trainable)?;
        }
        if self.creatable != false {
            os.write_bool(9, self.creatable)?;
        }
        if self.internal_only != false {
            os.write_bool(10, self.internal_only)?;
        }
        for v in &self.model_type_fields {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.requires_sequential_frames != false {
            os.write_bool(12, self.requires_sequential_frames)?;
        }
        if self.evaluable != false {
            os.write_bool(13, self.evaluable)?;
        }
        if let Some(ref v) = self.expected_pretrained_input_fields.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expected_pretrained_output_fields.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelType {
        ModelType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ModelType| { &m.id },
                |m: &mut ModelType| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ModelType| { &m.title },
                |m: &mut ModelType| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ModelType| { &m.description },
                |m: &mut ModelType| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &ModelType| { &m.field_type },
                |m: &mut ModelType| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_fields",
                |m: &ModelType| { &m.input_fields },
                |m: &mut ModelType| { &mut m.input_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output_fields",
                |m: &ModelType| { &m.output_fields },
                |m: &mut ModelType| { &mut m.output_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trainable",
                |m: &ModelType| { &m.trainable },
                |m: &mut ModelType| { &mut m.trainable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "creatable",
                |m: &ModelType| { &m.creatable },
                |m: &mut ModelType| { &mut m.creatable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "internal_only",
                |m: &ModelType| { &m.internal_only },
                |m: &mut ModelType| { &mut m.internal_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelTypeField>>(
                "model_type_fields",
                |m: &ModelType| { &m.model_type_fields },
                |m: &mut ModelType| { &mut m.model_type_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requires_sequential_frames",
                |m: &ModelType| { &m.requires_sequential_frames },
                |m: &mut ModelType| { &mut m.requires_sequential_frames },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "evaluable",
                |m: &ModelType| { &m.evaluable },
                |m: &mut ModelType| { &mut m.evaluable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "expected_pretrained_input_fields",
                |m: &ModelType| { &m.expected_pretrained_input_fields },
                |m: &mut ModelType| { &mut m.expected_pretrained_input_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "expected_pretrained_output_fields",
                |m: &ModelType| { &m.expected_pretrained_output_fields },
                |m: &mut ModelType| { &mut m.expected_pretrained_output_fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelType>(
                "ModelType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelType {
        static instance: ::protobuf::rt::LazyV2<ModelType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelType::new)
    }
}

impl ::protobuf::Clear for ModelType {
    fn clear(&mut self) {
        self.id.clear();
        self.title.clear();
        self.description.clear();
        self.field_type.clear();
        self.input_fields.clear();
        self.output_fields.clear();
        self.trainable = false;
        self.creatable = false;
        self.internal_only = false;
        self.model_type_fields.clear();
        self.requires_sequential_frames = false;
        self.evaluable = false;
        self.expected_pretrained_input_fields.clear();
        self.expected_pretrained_output_fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelTypeField {
    // message fields
    pub path: ::std::string::String,
    pub field_type: ModelTypeField_ModelTypeFieldType,
    pub default_value: ::protobuf::SingularPtrField<::protobuf::well_known_types::Value>,
    pub description: ::std::string::String,
    pub placeholder: ::std::string::String,
    pub model_type_enum_options: ::protobuf::RepeatedField<ModelTypeEnumOption>,
    pub internal_only: bool,
    pub required: bool,
    pub model_type_range_info: ::protobuf::SingularPtrField<ModelTypeRangeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelTypeField {
    fn default() -> &'a ModelTypeField {
        <ModelTypeField as ::protobuf::Message>::default_instance()
    }
}

impl ModelTypeField {
    pub fn new() -> ModelTypeField {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .clarifai.api.ModelTypeField.ModelTypeFieldType field_type = 2;


    pub fn get_field_type(&self) -> ModelTypeField_ModelTypeFieldType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ModelTypeField_ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ModelTypeField_ModelTypeFieldType) {
        self.field_type = v;
    }

    // .google.protobuf.Value default_value = 3;


    pub fn get_default_value(&self) -> &::protobuf::well_known_types::Value {
        self.default_value.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_value(&mut self) {
        self.default_value.clear();
    }

    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::protobuf::well_known_types::Value) {
        self.default_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::protobuf::well_known_types::Value {
        if self.default_value.is_none() {
            self.default_value.set_default();
        }
        self.default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::protobuf::well_known_types::Value {
        self.default_value.take().unwrap_or_else(|| ::protobuf::well_known_types::Value::new())
    }

    // string description = 4;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string placeholder = 5;


    pub fn get_placeholder(&self) -> &str {
        &self.placeholder
    }
    pub fn clear_placeholder(&mut self) {
        self.placeholder.clear();
    }

    // Param is passed by value, moved
    pub fn set_placeholder(&mut self, v: ::std::string::String) {
        self.placeholder = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placeholder(&mut self) -> &mut ::std::string::String {
        &mut self.placeholder
    }

    // Take field
    pub fn take_placeholder(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.placeholder, ::std::string::String::new())
    }

    // repeated .clarifai.api.ModelTypeEnumOption model_type_enum_options = 6;


    pub fn get_model_type_enum_options(&self) -> &[ModelTypeEnumOption] {
        &self.model_type_enum_options
    }
    pub fn clear_model_type_enum_options(&mut self) {
        self.model_type_enum_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_type_enum_options(&mut self, v: ::protobuf::RepeatedField<ModelTypeEnumOption>) {
        self.model_type_enum_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_type_enum_options(&mut self) -> &mut ::protobuf::RepeatedField<ModelTypeEnumOption> {
        &mut self.model_type_enum_options
    }

    // Take field
    pub fn take_model_type_enum_options(&mut self) -> ::protobuf::RepeatedField<ModelTypeEnumOption> {
        ::std::mem::replace(&mut self.model_type_enum_options, ::protobuf::RepeatedField::new())
    }

    // bool internal_only = 7;


    pub fn get_internal_only(&self) -> bool {
        self.internal_only
    }
    pub fn clear_internal_only(&mut self) {
        self.internal_only = false;
    }

    // Param is passed by value, moved
    pub fn set_internal_only(&mut self, v: bool) {
        self.internal_only = v;
    }

    // bool required = 8;


    pub fn get_required(&self) -> bool {
        self.required
    }
    pub fn clear_required(&mut self) {
        self.required = false;
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: bool) {
        self.required = v;
    }

    // .clarifai.api.ModelTypeRangeInfo model_type_range_info = 9;


    pub fn get_model_type_range_info(&self) -> &ModelTypeRangeInfo {
        self.model_type_range_info.as_ref().unwrap_or_else(|| <ModelTypeRangeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_type_range_info(&mut self) {
        self.model_type_range_info.clear();
    }

    pub fn has_model_type_range_info(&self) -> bool {
        self.model_type_range_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_type_range_info(&mut self, v: ModelTypeRangeInfo) {
        self.model_type_range_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_type_range_info(&mut self) -> &mut ModelTypeRangeInfo {
        if self.model_type_range_info.is_none() {
            self.model_type_range_info.set_default();
        }
        self.model_type_range_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_type_range_info(&mut self) -> ModelTypeRangeInfo {
        self.model_type_range_info.take().unwrap_or_else(|| ModelTypeRangeInfo::new())
    }
}

impl ::protobuf::Message for ModelTypeField {
    fn is_initialized(&self) -> bool {
        for v in &self.default_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_type_enum_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_type_range_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.placeholder)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_type_enum_options)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.internal_only = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.required = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_type_range_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.field_type != ModelTypeField_ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if let Some(ref v) = self.default_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if !self.placeholder.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.placeholder);
        }
        for value in &self.model_type_enum_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.internal_only != false {
            my_size += 2;
        }
        if self.required != false {
            my_size += 2;
        }
        if let Some(ref v) = self.model_type_range_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.field_type != ModelTypeField_ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.default_value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if !self.placeholder.is_empty() {
            os.write_string(5, &self.placeholder)?;
        }
        for v in &self.model_type_enum_options {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.internal_only != false {
            os.write_bool(7, self.internal_only)?;
        }
        if self.required != false {
            os.write_bool(8, self.required)?;
        }
        if let Some(ref v) = self.model_type_range_info.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelTypeField {
        ModelTypeField::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &ModelTypeField| { &m.path },
                |m: &mut ModelTypeField| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ModelTypeField_ModelTypeFieldType>>(
                "field_type",
                |m: &ModelTypeField| { &m.field_type },
                |m: &mut ModelTypeField| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(
                "default_value",
                |m: &ModelTypeField| { &m.default_value },
                |m: &mut ModelTypeField| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ModelTypeField| { &m.description },
                |m: &mut ModelTypeField| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "placeholder",
                |m: &ModelTypeField| { &m.placeholder },
                |m: &mut ModelTypeField| { &mut m.placeholder },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelTypeEnumOption>>(
                "model_type_enum_options",
                |m: &ModelTypeField| { &m.model_type_enum_options },
                |m: &mut ModelTypeField| { &mut m.model_type_enum_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "internal_only",
                |m: &ModelTypeField| { &m.internal_only },
                |m: &mut ModelTypeField| { &mut m.internal_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "required",
                |m: &ModelTypeField| { &m.required },
                |m: &mut ModelTypeField| { &mut m.required },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelTypeRangeInfo>>(
                "model_type_range_info",
                |m: &ModelTypeField| { &m.model_type_range_info },
                |m: &mut ModelTypeField| { &mut m.model_type_range_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelTypeField>(
                "ModelTypeField",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelTypeField {
        static instance: ::protobuf::rt::LazyV2<ModelTypeField> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelTypeField::new)
    }
}

impl ::protobuf::Clear for ModelTypeField {
    fn clear(&mut self) {
        self.path.clear();
        self.field_type = ModelTypeField_ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE;
        self.default_value.clear();
        self.description.clear();
        self.placeholder.clear();
        self.model_type_enum_options.clear();
        self.internal_only = false;
        self.required = false;
        self.model_type_range_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelTypeField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelTypeField {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ModelTypeField_ModelTypeFieldType {
    INVALID_MODEL_TYPE_FIELD_TYPE = 0,
    BOOLEAN = 1,
    STRING = 2,
    NUMBER = 3,
    ARRAY_OF_CONCEPTS = 4,
    ARRAY_OF_CONCEPTS_WITH_THRESHOLD = 5,
    RANGE = 7,
    ENUM = 8,
    COLLABORATORS = 9,
    JSON = 10,
    ARRAY_OF_NUMBERS = 11,
    WORKFLOW_EMBED_MODELS = 12,
    ARRAY_OF_STRINGS = 13,
    RECURSIVE_ENUM = 14,
}

impl ::protobuf::ProtobufEnum for ModelTypeField_ModelTypeFieldType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ModelTypeField_ModelTypeFieldType> {
        match value {
            0 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE),
            1 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::BOOLEAN),
            2 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::STRING),
            3 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::NUMBER),
            4 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::ARRAY_OF_CONCEPTS),
            5 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::ARRAY_OF_CONCEPTS_WITH_THRESHOLD),
            7 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::RANGE),
            8 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::ENUM),
            9 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::COLLABORATORS),
            10 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::JSON),
            11 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::ARRAY_OF_NUMBERS),
            12 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::WORKFLOW_EMBED_MODELS),
            13 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::ARRAY_OF_STRINGS),
            14 => ::std::option::Option::Some(ModelTypeField_ModelTypeFieldType::RECURSIVE_ENUM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ModelTypeField_ModelTypeFieldType] = &[
            ModelTypeField_ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE,
            ModelTypeField_ModelTypeFieldType::BOOLEAN,
            ModelTypeField_ModelTypeFieldType::STRING,
            ModelTypeField_ModelTypeFieldType::NUMBER,
            ModelTypeField_ModelTypeFieldType::ARRAY_OF_CONCEPTS,
            ModelTypeField_ModelTypeFieldType::ARRAY_OF_CONCEPTS_WITH_THRESHOLD,
            ModelTypeField_ModelTypeFieldType::RANGE,
            ModelTypeField_ModelTypeFieldType::ENUM,
            ModelTypeField_ModelTypeFieldType::COLLABORATORS,
            ModelTypeField_ModelTypeFieldType::JSON,
            ModelTypeField_ModelTypeFieldType::ARRAY_OF_NUMBERS,
            ModelTypeField_ModelTypeFieldType::WORKFLOW_EMBED_MODELS,
            ModelTypeField_ModelTypeFieldType::ARRAY_OF_STRINGS,
            ModelTypeField_ModelTypeFieldType::RECURSIVE_ENUM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ModelTypeField_ModelTypeFieldType>("ModelTypeField.ModelTypeFieldType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ModelTypeField_ModelTypeFieldType {
}

impl ::std::default::Default for ModelTypeField_ModelTypeFieldType {
    fn default() -> Self {
        ModelTypeField_ModelTypeFieldType::INVALID_MODEL_TYPE_FIELD_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelTypeField_ModelTypeFieldType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelTypeRangeInfo {
    // message fields
    pub min: f32,
    pub max: f32,
    pub step: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelTypeRangeInfo {
    fn default() -> &'a ModelTypeRangeInfo {
        <ModelTypeRangeInfo as ::protobuf::Message>::default_instance()
    }
}

impl ModelTypeRangeInfo {
    pub fn new() -> ModelTypeRangeInfo {
        ::std::default::Default::default()
    }

    // float min = 1;


    pub fn get_min(&self) -> f32 {
        self.min
    }
    pub fn clear_min(&mut self) {
        self.min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: f32) {
        self.min = v;
    }

    // float max = 2;


    pub fn get_max(&self) -> f32 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: f32) {
        self.max = v;
    }

    // float step = 3;


    pub fn get_step(&self) -> f32 {
        self.step
    }
    pub fn clear_step(&mut self) {
        self.step = 0.;
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: f32) {
        self.step = v;
    }
}

impl ::protobuf::Message for ModelTypeRangeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.step = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min != 0. {
            my_size += 5;
        }
        if self.max != 0. {
            my_size += 5;
        }
        if self.step != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min != 0. {
            os.write_float(1, self.min)?;
        }
        if self.max != 0. {
            os.write_float(2, self.max)?;
        }
        if self.step != 0. {
            os.write_float(3, self.step)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelTypeRangeInfo {
        ModelTypeRangeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min",
                |m: &ModelTypeRangeInfo| { &m.min },
                |m: &mut ModelTypeRangeInfo| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max",
                |m: &ModelTypeRangeInfo| { &m.max },
                |m: &mut ModelTypeRangeInfo| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "step",
                |m: &ModelTypeRangeInfo| { &m.step },
                |m: &mut ModelTypeRangeInfo| { &mut m.step },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelTypeRangeInfo>(
                "ModelTypeRangeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelTypeRangeInfo {
        static instance: ::protobuf::rt::LazyV2<ModelTypeRangeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelTypeRangeInfo::new)
    }
}

impl ::protobuf::Clear for ModelTypeRangeInfo {
    fn clear(&mut self) {
        self.min = 0.;
        self.max = 0.;
        self.step = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelTypeRangeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelTypeRangeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelTypeEnumOption {
    // message fields
    pub id: ::std::string::String,
    pub description: ::std::string::String,
    pub model_type_fields: ::protobuf::RepeatedField<ModelTypeField>,
    pub internal_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelTypeEnumOption {
    fn default() -> &'a ModelTypeEnumOption {
        <ModelTypeEnumOption as ::protobuf::Message>::default_instance()
    }
}

impl ModelTypeEnumOption {
    pub fn new() -> ModelTypeEnumOption {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated .clarifai.api.ModelTypeField model_type_fields = 3;


    pub fn get_model_type_fields(&self) -> &[ModelTypeField] {
        &self.model_type_fields
    }
    pub fn clear_model_type_fields(&mut self) {
        self.model_type_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_type_fields(&mut self, v: ::protobuf::RepeatedField<ModelTypeField>) {
        self.model_type_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_type_fields(&mut self) -> &mut ::protobuf::RepeatedField<ModelTypeField> {
        &mut self.model_type_fields
    }

    // Take field
    pub fn take_model_type_fields(&mut self) -> ::protobuf::RepeatedField<ModelTypeField> {
        ::std::mem::replace(&mut self.model_type_fields, ::protobuf::RepeatedField::new())
    }

    // bool internal_only = 4;


    pub fn get_internal_only(&self) -> bool {
        self.internal_only
    }
    pub fn clear_internal_only(&mut self) {
        self.internal_only = false;
    }

    // Param is passed by value, moved
    pub fn set_internal_only(&mut self, v: bool) {
        self.internal_only = v;
    }
}

impl ::protobuf::Message for ModelTypeEnumOption {
    fn is_initialized(&self) -> bool {
        for v in &self.model_type_fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_type_fields)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.internal_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.model_type_fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.internal_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.model_type_fields {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.internal_only != false {
            os.write_bool(4, self.internal_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelTypeEnumOption {
        ModelTypeEnumOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ModelTypeEnumOption| { &m.id },
                |m: &mut ModelTypeEnumOption| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ModelTypeEnumOption| { &m.description },
                |m: &mut ModelTypeEnumOption| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelTypeField>>(
                "model_type_fields",
                |m: &ModelTypeEnumOption| { &m.model_type_fields },
                |m: &mut ModelTypeEnumOption| { &mut m.model_type_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "internal_only",
                |m: &ModelTypeEnumOption| { &m.internal_only },
                |m: &mut ModelTypeEnumOption| { &mut m.internal_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelTypeEnumOption>(
                "ModelTypeEnumOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelTypeEnumOption {
        static instance: ::protobuf::rt::LazyV2<ModelTypeEnumOption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelTypeEnumOption::new)
    }
}

impl ::protobuf::Clear for ModelTypeEnumOption {
    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.model_type_fields.clear();
        self.internal_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelTypeEnumOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelTypeEnumOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelQuery {
    // message fields
    pub name: ::std::string::String,
    pub field_type: ::std::string::String,
    pub model_type_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelQuery {
    fn default() -> &'a ModelQuery {
        <ModelQuery as ::protobuf::Message>::default_instance()
    }
}

impl ModelQuery {
    pub fn new() -> ModelQuery {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string model_type_id = 3;


    pub fn get_model_type_id(&self) -> &str {
        &self.model_type_id
    }
    pub fn clear_model_type_id(&mut self) {
        self.model_type_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_type_id(&mut self, v: ::std::string::String) {
        self.model_type_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_type_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_type_id
    }

    // Take field
    pub fn take_model_type_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_type_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModelQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_type_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_type_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(3, &self.model_type_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelQuery {
        ModelQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ModelQuery| { &m.name },
                |m: &mut ModelQuery| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &ModelQuery| { &m.field_type },
                |m: &mut ModelQuery| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_type_id",
                |m: &ModelQuery| { &m.model_type_id },
                |m: &mut ModelQuery| { &mut m.model_type_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelQuery>(
                "ModelQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelQuery {
        static instance: ::protobuf::rt::LazyV2<ModelQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelQuery::new)
    }
}

impl ::protobuf::Clear for ModelQuery {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type.clear();
        self.model_type_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelVersion {
    // message fields
    pub id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub active_concept_count: u32,
    pub metrics: ::protobuf::SingularPtrField<EvalMetrics>,
    pub total_input_count: u32,
    pub completed_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub description: ::std::string::String,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub app_id: ::std::string::String,
    pub user_id: ::std::string::String,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub license: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelVersion {
    fn default() -> &'a ModelVersion {
        <ModelVersion as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersion {
    pub fn new() -> ModelVersion {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .clarifai.api.status.Status status = 3;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // uint32 active_concept_count = 4;


    pub fn get_active_concept_count(&self) -> u32 {
        self.active_concept_count
    }
    pub fn clear_active_concept_count(&mut self) {
        self.active_concept_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_active_concept_count(&mut self, v: u32) {
        self.active_concept_count = v;
    }

    // .clarifai.api.EvalMetrics metrics = 5;


    pub fn get_metrics(&self) -> &EvalMetrics {
        self.metrics.as_ref().unwrap_or_else(|| <EvalMetrics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    pub fn has_metrics(&self) -> bool {
        self.metrics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: EvalMetrics) {
        self.metrics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metrics(&mut self) -> &mut EvalMetrics {
        if self.metrics.is_none() {
            self.metrics.set_default();
        }
        self.metrics.as_mut().unwrap()
    }

    // Take field
    pub fn take_metrics(&mut self) -> EvalMetrics {
        self.metrics.take().unwrap_or_else(|| EvalMetrics::new())
    }

    // uint32 total_input_count = 6;


    pub fn get_total_input_count(&self) -> u32 {
        self.total_input_count
    }
    pub fn clear_total_input_count(&mut self) {
        self.total_input_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_input_count(&mut self, v: u32) {
        self.total_input_count = v;
    }

    // .google.protobuf.Timestamp completed_at = 10;


    pub fn get_completed_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.completed_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_completed_at(&mut self) {
        self.completed_at.clear();
    }

    pub fn has_completed_at(&self) -> bool {
        self.completed_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.completed_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_completed_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.completed_at.is_none() {
            self.completed_at.set_default();
        }
        self.completed_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_completed_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.completed_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string description = 11;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .clarifai.api.Visibility visibility = 12;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // string app_id = 13;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string user_id = 14;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp modified_at = 15;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Struct metadata = 16;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string license = 17;


    pub fn get_license(&self) -> &str {
        &self.license
    }
    pub fn clear_license(&mut self) {
        self.license.clear();
    }

    // Param is passed by value, moved
    pub fn set_license(&mut self, v: ::std::string::String) {
        self.license = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license(&mut self) -> &mut ::std::string::String {
        &mut self.license
    }

    // Take field
    pub fn take_license(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.license, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModelVersion {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.completed_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_concept_count = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metrics)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_input_count = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.completed_at)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.license)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.active_concept_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.active_concept_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.total_input_count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.total_input_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.completed_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.description);
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.user_id);
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.license);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.active_concept_count != 0 {
            os.write_uint32(4, self.active_concept_count)?;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.total_input_count != 0 {
            os.write_uint32(6, self.total_input_count)?;
        }
        if let Some(ref v) = self.completed_at.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.description.is_empty() {
            os.write_string(11, &self.description)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(13, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(14, &self.user_id)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.license.is_empty() {
            os.write_string(17, &self.license)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelVersion {
        ModelVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ModelVersion| { &m.id },
                |m: &mut ModelVersion| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &ModelVersion| { &m.created_at },
                |m: &mut ModelVersion| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &ModelVersion| { &m.status },
                |m: &mut ModelVersion| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_concept_count",
                |m: &ModelVersion| { &m.active_concept_count },
                |m: &mut ModelVersion| { &mut m.active_concept_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EvalMetrics>>(
                "metrics",
                |m: &ModelVersion| { &m.metrics },
                |m: &mut ModelVersion| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_input_count",
                |m: &ModelVersion| { &m.total_input_count },
                |m: &mut ModelVersion| { &mut m.total_input_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "completed_at",
                |m: &ModelVersion| { &m.completed_at },
                |m: &mut ModelVersion| { &mut m.completed_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ModelVersion| { &m.description },
                |m: &mut ModelVersion| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &ModelVersion| { &m.visibility },
                |m: &mut ModelVersion| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &ModelVersion| { &m.app_id },
                |m: &mut ModelVersion| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &ModelVersion| { &m.user_id },
                |m: &mut ModelVersion| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &ModelVersion| { &m.modified_at },
                |m: &mut ModelVersion| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &ModelVersion| { &m.metadata },
                |m: &mut ModelVersion| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "license",
                |m: &ModelVersion| { &m.license },
                |m: &mut ModelVersion| { &mut m.license },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelVersion>(
                "ModelVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelVersion {
        static instance: ::protobuf::rt::LazyV2<ModelVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelVersion::new)
    }
}

impl ::protobuf::Clear for ModelVersion {
    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.status.clear();
        self.active_concept_count = 0;
        self.metrics.clear();
        self.total_input_count = 0;
        self.completed_at.clear();
        self.description.clear();
        self.visibility.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.modified_at.clear();
        self.metadata.clear();
        self.license.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PretrainedModelConfig {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    pub input_fields_map: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub output_fields_map: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub data_provider_params: ::std::string::String,
    pub model_zip_url: ::std::string::String,
    pub overwrite: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PretrainedModelConfig {
    fn default() -> &'a PretrainedModelConfig {
        <PretrainedModelConfig as ::protobuf::Message>::default_instance()
    }
}

impl PretrainedModelConfig {
    pub fn new() -> PretrainedModelConfig {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string type = 2;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // .google.protobuf.Struct input_fields_map = 3;


    pub fn get_input_fields_map(&self) -> &::protobuf::well_known_types::Struct {
        self.input_fields_map.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_fields_map(&mut self) {
        self.input_fields_map.clear();
    }

    pub fn has_input_fields_map(&self) -> bool {
        self.input_fields_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_fields_map(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.input_fields_map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_fields_map(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.input_fields_map.is_none() {
            self.input_fields_map.set_default();
        }
        self.input_fields_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_fields_map(&mut self) -> ::protobuf::well_known_types::Struct {
        self.input_fields_map.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .google.protobuf.Struct output_fields_map = 4;


    pub fn get_output_fields_map(&self) -> &::protobuf::well_known_types::Struct {
        self.output_fields_map.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_fields_map(&mut self) {
        self.output_fields_map.clear();
    }

    pub fn has_output_fields_map(&self) -> bool {
        self.output_fields_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_fields_map(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.output_fields_map = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_fields_map(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.output_fields_map.is_none() {
            self.output_fields_map.set_default();
        }
        self.output_fields_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_fields_map(&mut self) -> ::protobuf::well_known_types::Struct {
        self.output_fields_map.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string data_provider_params = 5;


    pub fn get_data_provider_params(&self) -> &str {
        &self.data_provider_params
    }
    pub fn clear_data_provider_params(&mut self) {
        self.data_provider_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_provider_params(&mut self, v: ::std::string::String) {
        self.data_provider_params = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_provider_params(&mut self) -> &mut ::std::string::String {
        &mut self.data_provider_params
    }

    // Take field
    pub fn take_data_provider_params(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data_provider_params, ::std::string::String::new())
    }

    // string model_zip_url = 6;


    pub fn get_model_zip_url(&self) -> &str {
        &self.model_zip_url
    }
    pub fn clear_model_zip_url(&mut self) {
        self.model_zip_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_zip_url(&mut self, v: ::std::string::String) {
        self.model_zip_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_zip_url(&mut self) -> &mut ::std::string::String {
        &mut self.model_zip_url
    }

    // Take field
    pub fn take_model_zip_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_zip_url, ::std::string::String::new())
    }

    // bool overwrite = 7;


    pub fn get_overwrite(&self) -> bool {
        self.overwrite
    }
    pub fn clear_overwrite(&mut self) {
        self.overwrite = false;
    }

    // Param is passed by value, moved
    pub fn set_overwrite(&mut self, v: bool) {
        self.overwrite = v;
    }
}

impl ::protobuf::Message for PretrainedModelConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.input_fields_map {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_fields_map {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_fields_map)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_fields_map)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data_provider_params)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_zip_url)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overwrite = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if let Some(ref v) = self.input_fields_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_fields_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.data_provider_params.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.data_provider_params);
        }
        if !self.model_zip_url.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model_zip_url);
        }
        if self.overwrite != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if let Some(ref v) = self.input_fields_map.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_fields_map.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.data_provider_params.is_empty() {
            os.write_string(5, &self.data_provider_params)?;
        }
        if !self.model_zip_url.is_empty() {
            os.write_string(6, &self.model_zip_url)?;
        }
        if self.overwrite != false {
            os.write_bool(7, self.overwrite)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PretrainedModelConfig {
        PretrainedModelConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PretrainedModelConfig| { &m.id },
                |m: &mut PretrainedModelConfig| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &PretrainedModelConfig| { &m.field_type },
                |m: &mut PretrainedModelConfig| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "input_fields_map",
                |m: &PretrainedModelConfig| { &m.input_fields_map },
                |m: &mut PretrainedModelConfig| { &mut m.input_fields_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "output_fields_map",
                |m: &PretrainedModelConfig| { &m.output_fields_map },
                |m: &mut PretrainedModelConfig| { &mut m.output_fields_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data_provider_params",
                |m: &PretrainedModelConfig| { &m.data_provider_params },
                |m: &mut PretrainedModelConfig| { &mut m.data_provider_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_zip_url",
                |m: &PretrainedModelConfig| { &m.model_zip_url },
                |m: &mut PretrainedModelConfig| { &mut m.model_zip_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "overwrite",
                |m: &PretrainedModelConfig| { &m.overwrite },
                |m: &mut PretrainedModelConfig| { &mut m.overwrite },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PretrainedModelConfig>(
                "PretrainedModelConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PretrainedModelConfig {
        static instance: ::protobuf::rt::LazyV2<PretrainedModelConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PretrainedModelConfig::new)
    }
}

impl ::protobuf::Clear for PretrainedModelConfig {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type.clear();
        self.input_fields_map.clear();
        self.output_fields_map.clear();
        self.data_provider_params.clear();
        self.model_zip_url.clear();
        self.overwrite = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PretrainedModelConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PretrainedModelConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrainStats {
    // message fields
    pub loss_curve: ::protobuf::RepeatedField<LossCurveEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrainStats {
    fn default() -> &'a TrainStats {
        <TrainStats as ::protobuf::Message>::default_instance()
    }
}

impl TrainStats {
    pub fn new() -> TrainStats {
        ::std::default::Default::default()
    }

    // repeated .clarifai.api.LossCurveEntry loss_curve = 1;


    pub fn get_loss_curve(&self) -> &[LossCurveEntry] {
        &self.loss_curve
    }
    pub fn clear_loss_curve(&mut self) {
        self.loss_curve.clear();
    }

    // Param is passed by value, moved
    pub fn set_loss_curve(&mut self, v: ::protobuf::RepeatedField<LossCurveEntry>) {
        self.loss_curve = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loss_curve(&mut self) -> &mut ::protobuf::RepeatedField<LossCurveEntry> {
        &mut self.loss_curve
    }

    // Take field
    pub fn take_loss_curve(&mut self) -> ::protobuf::RepeatedField<LossCurveEntry> {
        ::std::mem::replace(&mut self.loss_curve, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TrainStats {
    fn is_initialized(&self) -> bool {
        for v in &self.loss_curve {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.loss_curve)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.loss_curve {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.loss_curve {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrainStats {
        TrainStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LossCurveEntry>>(
                "loss_curve",
                |m: &TrainStats| { &m.loss_curve },
                |m: &mut TrainStats| { &mut m.loss_curve },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrainStats>(
                "TrainStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrainStats {
        static instance: ::protobuf::rt::LazyV2<TrainStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrainStats::new)
    }
}

impl ::protobuf::Clear for TrainStats {
    fn clear(&mut self) {
        self.loss_curve.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrainStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrainStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LossCurveEntry {
    // message fields
    pub epoch: u32,
    pub global_step: u32,
    pub cost: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LossCurveEntry {
    fn default() -> &'a LossCurveEntry {
        <LossCurveEntry as ::protobuf::Message>::default_instance()
    }
}

impl LossCurveEntry {
    pub fn new() -> LossCurveEntry {
        ::std::default::Default::default()
    }

    // uint32 epoch = 1;


    pub fn get_epoch(&self) -> u32 {
        self.epoch
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u32) {
        self.epoch = v;
    }

    // uint32 global_step = 2;


    pub fn get_global_step(&self) -> u32 {
        self.global_step
    }
    pub fn clear_global_step(&mut self) {
        self.global_step = 0;
    }

    // Param is passed by value, moved
    pub fn set_global_step(&mut self, v: u32) {
        self.global_step = v;
    }

    // float cost = 3;


    pub fn get_cost(&self) -> f32 {
        self.cost
    }
    pub fn clear_cost(&mut self) {
        self.cost = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cost(&mut self, v: f32) {
        self.cost = v;
    }
}

impl ::protobuf::Message for LossCurveEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.epoch = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.global_step = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cost = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epoch != 0 {
            my_size += ::protobuf::rt::value_size(1, self.epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.global_step != 0 {
            my_size += ::protobuf::rt::value_size(2, self.global_step, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cost != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epoch != 0 {
            os.write_uint32(1, self.epoch)?;
        }
        if self.global_step != 0 {
            os.write_uint32(2, self.global_step)?;
        }
        if self.cost != 0. {
            os.write_float(3, self.cost)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LossCurveEntry {
        LossCurveEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "epoch",
                |m: &LossCurveEntry| { &m.epoch },
                |m: &mut LossCurveEntry| { &mut m.epoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "global_step",
                |m: &LossCurveEntry| { &m.global_step },
                |m: &mut LossCurveEntry| { &mut m.global_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cost",
                |m: &LossCurveEntry| { &m.cost },
                |m: &mut LossCurveEntry| { &mut m.cost },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LossCurveEntry>(
                "LossCurveEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LossCurveEntry {
        static instance: ::protobuf::rt::LazyV2<LossCurveEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LossCurveEntry::new)
    }
}

impl ::protobuf::Clear for LossCurveEntry {
    fn clear(&mut self) {
        self.epoch = 0;
        self.global_step = 0;
        self.cost = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LossCurveEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LossCurveEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelCount {
    // message fields
    pub concept_name: ::std::string::String,
    pub count: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabelCount {
    fn default() -> &'a LabelCount {
        <LabelCount as ::protobuf::Message>::default_instance()
    }
}

impl LabelCount {
    pub fn new() -> LabelCount {
        ::std::default::Default::default()
    }

    // string concept_name = 1;


    pub fn get_concept_name(&self) -> &str {
        &self.concept_name
    }
    pub fn clear_concept_name(&mut self) {
        self.concept_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_name(&mut self, v: ::std::string::String) {
        self.concept_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_name(&mut self) -> &mut ::std::string::String {
        &mut self.concept_name
    }

    // Take field
    pub fn take_concept_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_name, ::std::string::String::new())
    }

    // uint32 count = 2;


    pub fn get_count(&self) -> u32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = v;
    }
}

impl ::protobuf::Message for LabelCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.concept_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.concept_name);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.concept_name.is_empty() {
            os.write_string(1, &self.concept_name)?;
        }
        if self.count != 0 {
            os.write_uint32(2, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelCount {
        LabelCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_name",
                |m: &LabelCount| { &m.concept_name },
                |m: &mut LabelCount| { &mut m.concept_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &LabelCount| { &m.count },
                |m: &mut LabelCount| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabelCount>(
                "LabelCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabelCount {
        static instance: ::protobuf::rt::LazyV2<LabelCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabelCount::new)
    }
}

impl ::protobuf::Clear for LabelCount {
    fn clear(&mut self) {
        self.concept_name.clear();
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelDistribution {
    // message fields
    pub positive_label_counts: ::protobuf::RepeatedField<LabelCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabelDistribution {
    fn default() -> &'a LabelDistribution {
        <LabelDistribution as ::protobuf::Message>::default_instance()
    }
}

impl LabelDistribution {
    pub fn new() -> LabelDistribution {
        ::std::default::Default::default()
    }

    // repeated .clarifai.api.LabelCount positive_label_counts = 1;


    pub fn get_positive_label_counts(&self) -> &[LabelCount] {
        &self.positive_label_counts
    }
    pub fn clear_positive_label_counts(&mut self) {
        self.positive_label_counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_positive_label_counts(&mut self, v: ::protobuf::RepeatedField<LabelCount>) {
        self.positive_label_counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_positive_label_counts(&mut self) -> &mut ::protobuf::RepeatedField<LabelCount> {
        &mut self.positive_label_counts
    }

    // Take field
    pub fn take_positive_label_counts(&mut self) -> ::protobuf::RepeatedField<LabelCount> {
        ::std::mem::replace(&mut self.positive_label_counts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LabelDistribution {
    fn is_initialized(&self) -> bool {
        for v in &self.positive_label_counts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.positive_label_counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.positive_label_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.positive_label_counts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelDistribution {
        LabelDistribution::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelCount>>(
                "positive_label_counts",
                |m: &LabelDistribution| { &m.positive_label_counts },
                |m: &mut LabelDistribution| { &mut m.positive_label_counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabelDistribution>(
                "LabelDistribution",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabelDistribution {
        static instance: ::protobuf::rt::LazyV2<LabelDistribution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabelDistribution::new)
    }
}

impl ::protobuf::Clear for LabelDistribution {
    fn clear(&mut self) {
        self.positive_label_counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelDistribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelDistribution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CooccurrenceMatrixEntry {
    // message fields
    pub row: ::std::string::String,
    pub col: ::std::string::String,
    pub count: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CooccurrenceMatrixEntry {
    fn default() -> &'a CooccurrenceMatrixEntry {
        <CooccurrenceMatrixEntry as ::protobuf::Message>::default_instance()
    }
}

impl CooccurrenceMatrixEntry {
    pub fn new() -> CooccurrenceMatrixEntry {
        ::std::default::Default::default()
    }

    // string row = 1;


    pub fn get_row(&self) -> &str {
        &self.row
    }
    pub fn clear_row(&mut self) {
        self.row.clear();
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: ::std::string::String) {
        self.row = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row(&mut self) -> &mut ::std::string::String {
        &mut self.row
    }

    // Take field
    pub fn take_row(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.row, ::std::string::String::new())
    }

    // string col = 2;


    pub fn get_col(&self) -> &str {
        &self.col
    }
    pub fn clear_col(&mut self) {
        self.col.clear();
    }

    // Param is passed by value, moved
    pub fn set_col(&mut self, v: ::std::string::String) {
        self.col = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_col(&mut self) -> &mut ::std::string::String {
        &mut self.col
    }

    // Take field
    pub fn take_col(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.col, ::std::string::String::new())
    }

    // uint32 count = 3;


    pub fn get_count(&self) -> u32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = v;
    }
}

impl ::protobuf::Message for CooccurrenceMatrixEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.row)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.col)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.row.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.row);
        }
        if !self.col.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.col);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.row.is_empty() {
            os.write_string(1, &self.row)?;
        }
        if !self.col.is_empty() {
            os.write_string(2, &self.col)?;
        }
        if self.count != 0 {
            os.write_uint32(3, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CooccurrenceMatrixEntry {
        CooccurrenceMatrixEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "row",
                |m: &CooccurrenceMatrixEntry| { &m.row },
                |m: &mut CooccurrenceMatrixEntry| { &mut m.row },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "col",
                |m: &CooccurrenceMatrixEntry| { &m.col },
                |m: &mut CooccurrenceMatrixEntry| { &mut m.col },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &CooccurrenceMatrixEntry| { &m.count },
                |m: &mut CooccurrenceMatrixEntry| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CooccurrenceMatrixEntry>(
                "CooccurrenceMatrixEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CooccurrenceMatrixEntry {
        static instance: ::protobuf::rt::LazyV2<CooccurrenceMatrixEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CooccurrenceMatrixEntry::new)
    }
}

impl ::protobuf::Clear for CooccurrenceMatrixEntry {
    fn clear(&mut self) {
        self.row.clear();
        self.col.clear();
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CooccurrenceMatrixEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CooccurrenceMatrixEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CooccurrenceMatrix {
    // message fields
    pub matrix: ::protobuf::RepeatedField<CooccurrenceMatrixEntry>,
    pub concept_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CooccurrenceMatrix {
    fn default() -> &'a CooccurrenceMatrix {
        <CooccurrenceMatrix as ::protobuf::Message>::default_instance()
    }
}

impl CooccurrenceMatrix {
    pub fn new() -> CooccurrenceMatrix {
        ::std::default::Default::default()
    }

    // repeated .clarifai.api.CooccurrenceMatrixEntry matrix = 1;


    pub fn get_matrix(&self) -> &[CooccurrenceMatrixEntry] {
        &self.matrix
    }
    pub fn clear_matrix(&mut self) {
        self.matrix.clear();
    }

    // Param is passed by value, moved
    pub fn set_matrix(&mut self, v: ::protobuf::RepeatedField<CooccurrenceMatrixEntry>) {
        self.matrix = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matrix(&mut self) -> &mut ::protobuf::RepeatedField<CooccurrenceMatrixEntry> {
        &mut self.matrix
    }

    // Take field
    pub fn take_matrix(&mut self) -> ::protobuf::RepeatedField<CooccurrenceMatrixEntry> {
        ::std::mem::replace(&mut self.matrix, ::protobuf::RepeatedField::new())
    }

    // repeated string concept_ids = 2;


    pub fn get_concept_ids(&self) -> &[::std::string::String] {
        &self.concept_ids
    }
    pub fn clear_concept_ids(&mut self) {
        self.concept_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concept_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concept_ids
    }

    // Take field
    pub fn take_concept_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concept_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CooccurrenceMatrix {
    fn is_initialized(&self) -> bool {
        for v in &self.matrix {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matrix)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concept_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matrix {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matrix {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.concept_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CooccurrenceMatrix {
        CooccurrenceMatrix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CooccurrenceMatrixEntry>>(
                "matrix",
                |m: &CooccurrenceMatrix| { &m.matrix },
                |m: &mut CooccurrenceMatrix| { &mut m.matrix },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_ids",
                |m: &CooccurrenceMatrix| { &m.concept_ids },
                |m: &mut CooccurrenceMatrix| { &mut m.concept_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CooccurrenceMatrix>(
                "CooccurrenceMatrix",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CooccurrenceMatrix {
        static instance: ::protobuf::rt::LazyV2<CooccurrenceMatrix> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CooccurrenceMatrix::new)
    }
}

impl ::protobuf::Clear for CooccurrenceMatrix {
    fn clear(&mut self) {
        self.matrix.clear();
        self.concept_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CooccurrenceMatrix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CooccurrenceMatrix {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfusionMatrixEntry {
    // message fields
    pub predicted: ::std::string::String,
    pub actual: ::std::string::String,
    pub value: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfusionMatrixEntry {
    fn default() -> &'a ConfusionMatrixEntry {
        <ConfusionMatrixEntry as ::protobuf::Message>::default_instance()
    }
}

impl ConfusionMatrixEntry {
    pub fn new() -> ConfusionMatrixEntry {
        ::std::default::Default::default()
    }

    // string predicted = 1;


    pub fn get_predicted(&self) -> &str {
        &self.predicted
    }
    pub fn clear_predicted(&mut self) {
        self.predicted.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicted(&mut self, v: ::std::string::String) {
        self.predicted = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predicted(&mut self) -> &mut ::std::string::String {
        &mut self.predicted
    }

    // Take field
    pub fn take_predicted(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.predicted, ::std::string::String::new())
    }

    // string actual = 2;


    pub fn get_actual(&self) -> &str {
        &self.actual
    }
    pub fn clear_actual(&mut self) {
        self.actual.clear();
    }

    // Param is passed by value, moved
    pub fn set_actual(&mut self, v: ::std::string::String) {
        self.actual = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actual(&mut self) -> &mut ::std::string::String {
        &mut self.actual
    }

    // Take field
    pub fn take_actual(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actual, ::std::string::String::new())
    }

    // float value = 4;


    pub fn get_value(&self) -> f32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = v;
    }
}

impl ::protobuf::Message for ConfusionMatrixEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.predicted)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actual)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.predicted.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.predicted);
        }
        if !self.actual.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.actual);
        }
        if self.value != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.predicted.is_empty() {
            os.write_string(1, &self.predicted)?;
        }
        if !self.actual.is_empty() {
            os.write_string(2, &self.actual)?;
        }
        if self.value != 0. {
            os.write_float(4, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfusionMatrixEntry {
        ConfusionMatrixEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "predicted",
                |m: &ConfusionMatrixEntry| { &m.predicted },
                |m: &mut ConfusionMatrixEntry| { &mut m.predicted },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actual",
                |m: &ConfusionMatrixEntry| { &m.actual },
                |m: &mut ConfusionMatrixEntry| { &mut m.actual },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &ConfusionMatrixEntry| { &m.value },
                |m: &mut ConfusionMatrixEntry| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfusionMatrixEntry>(
                "ConfusionMatrixEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfusionMatrixEntry {
        static instance: ::protobuf::rt::LazyV2<ConfusionMatrixEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfusionMatrixEntry::new)
    }
}

impl ::protobuf::Clear for ConfusionMatrixEntry {
    fn clear(&mut self) {
        self.predicted.clear();
        self.actual.clear();
        self.value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfusionMatrixEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfusionMatrixEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfusionMatrix {
    // message fields
    pub matrix: ::protobuf::RepeatedField<ConfusionMatrixEntry>,
    pub concept_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfusionMatrix {
    fn default() -> &'a ConfusionMatrix {
        <ConfusionMatrix as ::protobuf::Message>::default_instance()
    }
}

impl ConfusionMatrix {
    pub fn new() -> ConfusionMatrix {
        ::std::default::Default::default()
    }

    // repeated .clarifai.api.ConfusionMatrixEntry matrix = 1;


    pub fn get_matrix(&self) -> &[ConfusionMatrixEntry] {
        &self.matrix
    }
    pub fn clear_matrix(&mut self) {
        self.matrix.clear();
    }

    // Param is passed by value, moved
    pub fn set_matrix(&mut self, v: ::protobuf::RepeatedField<ConfusionMatrixEntry>) {
        self.matrix = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matrix(&mut self) -> &mut ::protobuf::RepeatedField<ConfusionMatrixEntry> {
        &mut self.matrix
    }

    // Take field
    pub fn take_matrix(&mut self) -> ::protobuf::RepeatedField<ConfusionMatrixEntry> {
        ::std::mem::replace(&mut self.matrix, ::protobuf::RepeatedField::new())
    }

    // repeated string concept_ids = 2;


    pub fn get_concept_ids(&self) -> &[::std::string::String] {
        &self.concept_ids
    }
    pub fn clear_concept_ids(&mut self) {
        self.concept_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concept_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concept_ids
    }

    // Take field
    pub fn take_concept_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concept_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConfusionMatrix {
    fn is_initialized(&self) -> bool {
        for v in &self.matrix {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matrix)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concept_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matrix {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matrix {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.concept_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfusionMatrix {
        ConfusionMatrix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfusionMatrixEntry>>(
                "matrix",
                |m: &ConfusionMatrix| { &m.matrix },
                |m: &mut ConfusionMatrix| { &mut m.matrix },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_ids",
                |m: &ConfusionMatrix| { &m.concept_ids },
                |m: &mut ConfusionMatrix| { &mut m.concept_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfusionMatrix>(
                "ConfusionMatrix",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfusionMatrix {
        static instance: ::protobuf::rt::LazyV2<ConfusionMatrix> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfusionMatrix::new)
    }
}

impl ::protobuf::Clear for ConfusionMatrix {
    fn clear(&mut self) {
        self.matrix.clear();
        self.concept_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfusionMatrix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfusionMatrix {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ROC {
    // message fields
    pub fpr: ::std::vec::Vec<f32>,
    pub tpr: ::std::vec::Vec<f32>,
    pub thresholds: ::std::vec::Vec<f32>,
    pub fpr_per_image: ::std::vec::Vec<f32>,
    pub fpr_per_object: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ROC {
    fn default() -> &'a ROC {
        <ROC as ::protobuf::Message>::default_instance()
    }
}

impl ROC {
    pub fn new() -> ROC {
        ::std::default::Default::default()
    }

    // repeated float fpr = 1;


    pub fn get_fpr(&self) -> &[f32] {
        &self.fpr
    }
    pub fn clear_fpr(&mut self) {
        self.fpr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fpr(&mut self, v: ::std::vec::Vec<f32>) {
        self.fpr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fpr(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.fpr
    }

    // Take field
    pub fn take_fpr(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.fpr, ::std::vec::Vec::new())
    }

    // repeated float tpr = 2;


    pub fn get_tpr(&self) -> &[f32] {
        &self.tpr
    }
    pub fn clear_tpr(&mut self) {
        self.tpr.clear();
    }

    // Param is passed by value, moved
    pub fn set_tpr(&mut self, v: ::std::vec::Vec<f32>) {
        self.tpr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tpr(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.tpr
    }

    // Take field
    pub fn take_tpr(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.tpr, ::std::vec::Vec::new())
    }

    // repeated float thresholds = 3;


    pub fn get_thresholds(&self) -> &[f32] {
        &self.thresholds
    }
    pub fn clear_thresholds(&mut self) {
        self.thresholds.clear();
    }

    // Param is passed by value, moved
    pub fn set_thresholds(&mut self, v: ::std::vec::Vec<f32>) {
        self.thresholds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_thresholds(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.thresholds
    }

    // Take field
    pub fn take_thresholds(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.thresholds, ::std::vec::Vec::new())
    }

    // repeated float fpr_per_image = 4;


    pub fn get_fpr_per_image(&self) -> &[f32] {
        &self.fpr_per_image
    }
    pub fn clear_fpr_per_image(&mut self) {
        self.fpr_per_image.clear();
    }

    // Param is passed by value, moved
    pub fn set_fpr_per_image(&mut self, v: ::std::vec::Vec<f32>) {
        self.fpr_per_image = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fpr_per_image(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.fpr_per_image
    }

    // Take field
    pub fn take_fpr_per_image(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.fpr_per_image, ::std::vec::Vec::new())
    }

    // repeated float fpr_per_object = 5;


    pub fn get_fpr_per_object(&self) -> &[f32] {
        &self.fpr_per_object
    }
    pub fn clear_fpr_per_object(&mut self) {
        self.fpr_per_object.clear();
    }

    // Param is passed by value, moved
    pub fn set_fpr_per_object(&mut self, v: ::std::vec::Vec<f32>) {
        self.fpr_per_object = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fpr_per_object(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.fpr_per_object
    }

    // Take field
    pub fn take_fpr_per_object(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.fpr_per_object, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ROC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.fpr)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.tpr)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.thresholds)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.fpr_per_image)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.fpr_per_object)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.fpr.len() as u32;
        my_size += 5 * self.tpr.len() as u32;
        my_size += 5 * self.thresholds.len() as u32;
        my_size += 5 * self.fpr_per_image.len() as u32;
        my_size += 5 * self.fpr_per_object.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fpr {
            os.write_float(1, *v)?;
        };
        for v in &self.tpr {
            os.write_float(2, *v)?;
        };
        for v in &self.thresholds {
            os.write_float(3, *v)?;
        };
        for v in &self.fpr_per_image {
            os.write_float(4, *v)?;
        };
        for v in &self.fpr_per_object {
            os.write_float(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ROC {
        ROC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fpr",
                |m: &ROC| { &m.fpr },
                |m: &mut ROC| { &mut m.fpr },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tpr",
                |m: &ROC| { &m.tpr },
                |m: &mut ROC| { &mut m.tpr },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "thresholds",
                |m: &ROC| { &m.thresholds },
                |m: &mut ROC| { &mut m.thresholds },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fpr_per_image",
                |m: &ROC| { &m.fpr_per_image },
                |m: &mut ROC| { &mut m.fpr_per_image },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fpr_per_object",
                |m: &ROC| { &m.fpr_per_object },
                |m: &mut ROC| { &mut m.fpr_per_object },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ROC>(
                "ROC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ROC {
        static instance: ::protobuf::rt::LazyV2<ROC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ROC::new)
    }
}

impl ::protobuf::Clear for ROC {
    fn clear(&mut self) {
        self.fpr.clear();
        self.tpr.clear();
        self.thresholds.clear();
        self.fpr_per_image.clear();
        self.fpr_per_object.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ROC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ROC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrecisionRecallCurve {
    // message fields
    pub recall: ::std::vec::Vec<f32>,
    pub precision: ::std::vec::Vec<f32>,
    pub thresholds: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrecisionRecallCurve {
    fn default() -> &'a PrecisionRecallCurve {
        <PrecisionRecallCurve as ::protobuf::Message>::default_instance()
    }
}

impl PrecisionRecallCurve {
    pub fn new() -> PrecisionRecallCurve {
        ::std::default::Default::default()
    }

    // repeated float recall = 1;


    pub fn get_recall(&self) -> &[f32] {
        &self.recall
    }
    pub fn clear_recall(&mut self) {
        self.recall.clear();
    }

    // Param is passed by value, moved
    pub fn set_recall(&mut self, v: ::std::vec::Vec<f32>) {
        self.recall = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recall(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.recall
    }

    // Take field
    pub fn take_recall(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.recall, ::std::vec::Vec::new())
    }

    // repeated float precision = 2;


    pub fn get_precision(&self) -> &[f32] {
        &self.precision
    }
    pub fn clear_precision(&mut self) {
        self.precision.clear();
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: ::std::vec::Vec<f32>) {
        self.precision = v;
    }

    // Mutable pointer to the field.
    pub fn mut_precision(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.precision
    }

    // Take field
    pub fn take_precision(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.precision, ::std::vec::Vec::new())
    }

    // repeated float thresholds = 3;


    pub fn get_thresholds(&self) -> &[f32] {
        &self.thresholds
    }
    pub fn clear_thresholds(&mut self) {
        self.thresholds.clear();
    }

    // Param is passed by value, moved
    pub fn set_thresholds(&mut self, v: ::std::vec::Vec<f32>) {
        self.thresholds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_thresholds(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.thresholds
    }

    // Take field
    pub fn take_thresholds(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.thresholds, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PrecisionRecallCurve {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.recall)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.precision)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.thresholds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.recall.len() as u32;
        my_size += 5 * self.precision.len() as u32;
        my_size += 5 * self.thresholds.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.recall {
            os.write_float(1, *v)?;
        };
        for v in &self.precision {
            os.write_float(2, *v)?;
        };
        for v in &self.thresholds {
            os.write_float(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrecisionRecallCurve {
        PrecisionRecallCurve::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "recall",
                |m: &PrecisionRecallCurve| { &m.recall },
                |m: &mut PrecisionRecallCurve| { &mut m.recall },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "precision",
                |m: &PrecisionRecallCurve| { &m.precision },
                |m: &mut PrecisionRecallCurve| { &mut m.precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "thresholds",
                |m: &PrecisionRecallCurve| { &m.thresholds },
                |m: &mut PrecisionRecallCurve| { &mut m.thresholds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrecisionRecallCurve>(
                "PrecisionRecallCurve",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrecisionRecallCurve {
        static instance: ::protobuf::rt::LazyV2<PrecisionRecallCurve> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrecisionRecallCurve::new)
    }
}

impl ::protobuf::Clear for PrecisionRecallCurve {
    fn clear(&mut self) {
        self.recall.clear();
        self.precision.clear();
        self.thresholds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrecisionRecallCurve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrecisionRecallCurve {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BinaryMetrics {
    // message fields
    pub num_pos: u32,
    pub num_neg: u32,
    pub num_tot: u32,
    pub roc_auc: f32,
    pub f1: f32,
    pub concept: ::protobuf::SingularPtrField<Concept>,
    pub roc_curve: ::protobuf::SingularPtrField<ROC>,
    pub precision_recall_curve: ::protobuf::SingularPtrField<PrecisionRecallCurve>,
    pub avg_precision: f32,
    pub area_name: ::std::string::String,
    pub area_min: f64,
    pub area_max: f64,
    pub iou: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryMetrics {
    fn default() -> &'a BinaryMetrics {
        <BinaryMetrics as ::protobuf::Message>::default_instance()
    }
}

impl BinaryMetrics {
    pub fn new() -> BinaryMetrics {
        ::std::default::Default::default()
    }

    // uint32 num_pos = 1;


    pub fn get_num_pos(&self) -> u32 {
        self.num_pos
    }
    pub fn clear_num_pos(&mut self) {
        self.num_pos = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pos(&mut self, v: u32) {
        self.num_pos = v;
    }

    // uint32 num_neg = 2;


    pub fn get_num_neg(&self) -> u32 {
        self.num_neg
    }
    pub fn clear_num_neg(&mut self) {
        self.num_neg = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_neg(&mut self, v: u32) {
        self.num_neg = v;
    }

    // uint32 num_tot = 3;


    pub fn get_num_tot(&self) -> u32 {
        self.num_tot
    }
    pub fn clear_num_tot(&mut self) {
        self.num_tot = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_tot(&mut self, v: u32) {
        self.num_tot = v;
    }

    // float roc_auc = 4;


    pub fn get_roc_auc(&self) -> f32 {
        self.roc_auc
    }
    pub fn clear_roc_auc(&mut self) {
        self.roc_auc = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roc_auc(&mut self, v: f32) {
        self.roc_auc = v;
    }

    // float f1 = 5;


    pub fn get_f1(&self) -> f32 {
        self.f1
    }
    pub fn clear_f1(&mut self) {
        self.f1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_f1(&mut self, v: f32) {
        self.f1 = v;
    }

    // .clarifai.api.Concept concept = 6;


    pub fn get_concept(&self) -> &Concept {
        self.concept.as_ref().unwrap_or_else(|| <Concept as ::protobuf::Message>::default_instance())
    }
    pub fn clear_concept(&mut self) {
        self.concept.clear();
    }

    pub fn has_concept(&self) -> bool {
        self.concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept(&mut self, v: Concept) {
        self.concept = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept(&mut self) -> &mut Concept {
        if self.concept.is_none() {
            self.concept.set_default();
        }
        self.concept.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept(&mut self) -> Concept {
        self.concept.take().unwrap_or_else(|| Concept::new())
    }

    // .clarifai.api.ROC roc_curve = 7;


    pub fn get_roc_curve(&self) -> &ROC {
        self.roc_curve.as_ref().unwrap_or_else(|| <ROC as ::protobuf::Message>::default_instance())
    }
    pub fn clear_roc_curve(&mut self) {
        self.roc_curve.clear();
    }

    pub fn has_roc_curve(&self) -> bool {
        self.roc_curve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roc_curve(&mut self, v: ROC) {
        self.roc_curve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_roc_curve(&mut self) -> &mut ROC {
        if self.roc_curve.is_none() {
            self.roc_curve.set_default();
        }
        self.roc_curve.as_mut().unwrap()
    }

    // Take field
    pub fn take_roc_curve(&mut self) -> ROC {
        self.roc_curve.take().unwrap_or_else(|| ROC::new())
    }

    // .clarifai.api.PrecisionRecallCurve precision_recall_curve = 8;


    pub fn get_precision_recall_curve(&self) -> &PrecisionRecallCurve {
        self.precision_recall_curve.as_ref().unwrap_or_else(|| <PrecisionRecallCurve as ::protobuf::Message>::default_instance())
    }
    pub fn clear_precision_recall_curve(&mut self) {
        self.precision_recall_curve.clear();
    }

    pub fn has_precision_recall_curve(&self) -> bool {
        self.precision_recall_curve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precision_recall_curve(&mut self, v: PrecisionRecallCurve) {
        self.precision_recall_curve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_precision_recall_curve(&mut self) -> &mut PrecisionRecallCurve {
        if self.precision_recall_curve.is_none() {
            self.precision_recall_curve.set_default();
        }
        self.precision_recall_curve.as_mut().unwrap()
    }

    // Take field
    pub fn take_precision_recall_curve(&mut self) -> PrecisionRecallCurve {
        self.precision_recall_curve.take().unwrap_or_else(|| PrecisionRecallCurve::new())
    }

    // float avg_precision = 9;


    pub fn get_avg_precision(&self) -> f32 {
        self.avg_precision
    }
    pub fn clear_avg_precision(&mut self) {
        self.avg_precision = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_precision(&mut self, v: f32) {
        self.avg_precision = v;
    }

    // string area_name = 10;


    pub fn get_area_name(&self) -> &str {
        &self.area_name
    }
    pub fn clear_area_name(&mut self) {
        self.area_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_area_name(&mut self, v: ::std::string::String) {
        self.area_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_area_name(&mut self) -> &mut ::std::string::String {
        &mut self.area_name
    }

    // Take field
    pub fn take_area_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.area_name, ::std::string::String::new())
    }

    // double area_min = 11;


    pub fn get_area_min(&self) -> f64 {
        self.area_min
    }
    pub fn clear_area_min(&mut self) {
        self.area_min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_area_min(&mut self, v: f64) {
        self.area_min = v;
    }

    // double area_max = 12;


    pub fn get_area_max(&self) -> f64 {
        self.area_max
    }
    pub fn clear_area_max(&mut self) {
        self.area_max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_area_max(&mut self, v: f64) {
        self.area_max = v;
    }

    // float iou = 13;


    pub fn get_iou(&self) -> f32 {
        self.iou
    }
    pub fn clear_iou(&mut self) {
        self.iou = 0.;
    }

    // Param is passed by value, moved
    pub fn set_iou(&mut self, v: f32) {
        self.iou = v;
    }
}

impl ::protobuf::Message for BinaryMetrics {
    fn is_initialized(&self) -> bool {
        for v in &self.concept {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.roc_curve {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.precision_recall_curve {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_pos = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_neg = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_tot = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roc_auc = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.f1 = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.roc_curve)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.precision_recall_curve)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.avg_precision = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.area_name)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.area_min = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.area_max = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.iou = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_pos != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_pos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_neg != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_neg, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_tot != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_tot, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.roc_auc != 0. {
            my_size += 5;
        }
        if self.f1 != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.roc_curve.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.precision_recall_curve.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.avg_precision != 0. {
            my_size += 5;
        }
        if !self.area_name.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.area_name);
        }
        if self.area_min != 0. {
            my_size += 9;
        }
        if self.area_max != 0. {
            my_size += 9;
        }
        if self.iou != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_pos != 0 {
            os.write_uint32(1, self.num_pos)?;
        }
        if self.num_neg != 0 {
            os.write_uint32(2, self.num_neg)?;
        }
        if self.num_tot != 0 {
            os.write_uint32(3, self.num_tot)?;
        }
        if self.roc_auc != 0. {
            os.write_float(4, self.roc_auc)?;
        }
        if self.f1 != 0. {
            os.write_float(5, self.f1)?;
        }
        if let Some(ref v) = self.concept.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.roc_curve.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.precision_recall_curve.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.avg_precision != 0. {
            os.write_float(9, self.avg_precision)?;
        }
        if !self.area_name.is_empty() {
            os.write_string(10, &self.area_name)?;
        }
        if self.area_min != 0. {
            os.write_double(11, self.area_min)?;
        }
        if self.area_max != 0. {
            os.write_double(12, self.area_max)?;
        }
        if self.iou != 0. {
            os.write_float(13, self.iou)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryMetrics {
        BinaryMetrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_pos",
                |m: &BinaryMetrics| { &m.num_pos },
                |m: &mut BinaryMetrics| { &mut m.num_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_neg",
                |m: &BinaryMetrics| { &m.num_neg },
                |m: &mut BinaryMetrics| { &mut m.num_neg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_tot",
                |m: &BinaryMetrics| { &m.num_tot },
                |m: &mut BinaryMetrics| { &mut m.num_tot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "roc_auc",
                |m: &BinaryMetrics| { &m.roc_auc },
                |m: &mut BinaryMetrics| { &mut m.roc_auc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "f1",
                |m: &BinaryMetrics| { &m.f1 },
                |m: &mut BinaryMetrics| { &mut m.f1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Concept>>(
                "concept",
                |m: &BinaryMetrics| { &m.concept },
                |m: &mut BinaryMetrics| { &mut m.concept },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ROC>>(
                "roc_curve",
                |m: &BinaryMetrics| { &m.roc_curve },
                |m: &mut BinaryMetrics| { &mut m.roc_curve },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrecisionRecallCurve>>(
                "precision_recall_curve",
                |m: &BinaryMetrics| { &m.precision_recall_curve },
                |m: &mut BinaryMetrics| { &mut m.precision_recall_curve },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "avg_precision",
                |m: &BinaryMetrics| { &m.avg_precision },
                |m: &mut BinaryMetrics| { &mut m.avg_precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "area_name",
                |m: &BinaryMetrics| { &m.area_name },
                |m: &mut BinaryMetrics| { &mut m.area_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "area_min",
                |m: &BinaryMetrics| { &m.area_min },
                |m: &mut BinaryMetrics| { &mut m.area_min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "area_max",
                |m: &BinaryMetrics| { &m.area_max },
                |m: &mut BinaryMetrics| { &mut m.area_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "iou",
                |m: &BinaryMetrics| { &m.iou },
                |m: &mut BinaryMetrics| { &mut m.iou },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BinaryMetrics>(
                "BinaryMetrics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BinaryMetrics {
        static instance: ::protobuf::rt::LazyV2<BinaryMetrics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryMetrics::new)
    }
}

impl ::protobuf::Clear for BinaryMetrics {
    fn clear(&mut self) {
        self.num_pos = 0;
        self.num_neg = 0;
        self.num_tot = 0;
        self.roc_auc = 0.;
        self.f1 = 0.;
        self.concept.clear();
        self.roc_curve.clear();
        self.precision_recall_curve.clear();
        self.avg_precision = 0.;
        self.area_name.clear();
        self.area_min = 0.;
        self.area_max = 0.;
        self.iou = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BinaryMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryMetrics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrackerMetrics {
    // message fields
    pub mot_mota: f32,
    pub mot_num_switches: i32,
    pub morse_frag: f32,
    pub avg_precision: f32,
    pub aiid: ::std::string::String,
    pub unique_switch_rate: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrackerMetrics {
    fn default() -> &'a TrackerMetrics {
        <TrackerMetrics as ::protobuf::Message>::default_instance()
    }
}

impl TrackerMetrics {
    pub fn new() -> TrackerMetrics {
        ::std::default::Default::default()
    }

    // float mot_mota = 1;


    pub fn get_mot_mota(&self) -> f32 {
        self.mot_mota
    }
    pub fn clear_mot_mota(&mut self) {
        self.mot_mota = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mot_mota(&mut self, v: f32) {
        self.mot_mota = v;
    }

    // int32 mot_num_switches = 2;


    pub fn get_mot_num_switches(&self) -> i32 {
        self.mot_num_switches
    }
    pub fn clear_mot_num_switches(&mut self) {
        self.mot_num_switches = 0;
    }

    // Param is passed by value, moved
    pub fn set_mot_num_switches(&mut self, v: i32) {
        self.mot_num_switches = v;
    }

    // float morse_frag = 3;


    pub fn get_morse_frag(&self) -> f32 {
        self.morse_frag
    }
    pub fn clear_morse_frag(&mut self) {
        self.morse_frag = 0.;
    }

    // Param is passed by value, moved
    pub fn set_morse_frag(&mut self, v: f32) {
        self.morse_frag = v;
    }

    // float avg_precision = 4;


    pub fn get_avg_precision(&self) -> f32 {
        self.avg_precision
    }
    pub fn clear_avg_precision(&mut self) {
        self.avg_precision = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_precision(&mut self, v: f32) {
        self.avg_precision = v;
    }

    // string aiid = 5;


    pub fn get_aiid(&self) -> &str {
        &self.aiid
    }
    pub fn clear_aiid(&mut self) {
        self.aiid.clear();
    }

    // Param is passed by value, moved
    pub fn set_aiid(&mut self, v: ::std::string::String) {
        self.aiid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aiid(&mut self) -> &mut ::std::string::String {
        &mut self.aiid
    }

    // Take field
    pub fn take_aiid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.aiid, ::std::string::String::new())
    }

    // float unique_switch_rate = 6;


    pub fn get_unique_switch_rate(&self) -> f32 {
        self.unique_switch_rate
    }
    pub fn clear_unique_switch_rate(&mut self) {
        self.unique_switch_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_unique_switch_rate(&mut self, v: f32) {
        self.unique_switch_rate = v;
    }
}

impl ::protobuf::Message for TrackerMetrics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mot_mota = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mot_num_switches = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.morse_frag = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.avg_precision = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.aiid)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.unique_switch_rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mot_mota != 0. {
            my_size += 5;
        }
        if self.mot_num_switches != 0 {
            my_size += ::protobuf::rt::value_size(2, self.mot_num_switches, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.morse_frag != 0. {
            my_size += 5;
        }
        if self.avg_precision != 0. {
            my_size += 5;
        }
        if !self.aiid.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.aiid);
        }
        if self.unique_switch_rate != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mot_mota != 0. {
            os.write_float(1, self.mot_mota)?;
        }
        if self.mot_num_switches != 0 {
            os.write_int32(2, self.mot_num_switches)?;
        }
        if self.morse_frag != 0. {
            os.write_float(3, self.morse_frag)?;
        }
        if self.avg_precision != 0. {
            os.write_float(4, self.avg_precision)?;
        }
        if !self.aiid.is_empty() {
            os.write_string(5, &self.aiid)?;
        }
        if self.unique_switch_rate != 0. {
            os.write_float(6, self.unique_switch_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrackerMetrics {
        TrackerMetrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mot_mota",
                |m: &TrackerMetrics| { &m.mot_mota },
                |m: &mut TrackerMetrics| { &mut m.mot_mota },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mot_num_switches",
                |m: &TrackerMetrics| { &m.mot_num_switches },
                |m: &mut TrackerMetrics| { &mut m.mot_num_switches },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "morse_frag",
                |m: &TrackerMetrics| { &m.morse_frag },
                |m: &mut TrackerMetrics| { &mut m.morse_frag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "avg_precision",
                |m: &TrackerMetrics| { &m.avg_precision },
                |m: &mut TrackerMetrics| { &mut m.avg_precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "aiid",
                |m: &TrackerMetrics| { &m.aiid },
                |m: &mut TrackerMetrics| { &mut m.aiid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "unique_switch_rate",
                |m: &TrackerMetrics| { &m.unique_switch_rate },
                |m: &mut TrackerMetrics| { &mut m.unique_switch_rate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrackerMetrics>(
                "TrackerMetrics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrackerMetrics {
        static instance: ::protobuf::rt::LazyV2<TrackerMetrics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrackerMetrics::new)
    }
}

impl ::protobuf::Clear for TrackerMetrics {
    fn clear(&mut self) {
        self.mot_mota = 0.;
        self.mot_num_switches = 0;
        self.morse_frag = 0.;
        self.avg_precision = 0.;
        self.aiid.clear();
        self.unique_switch_rate = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrackerMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrackerMetrics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EvalTestSetEntry {
    // message fields
    pub id: ::std::string::String,
    pub url: ::std::string::String,
    pub input: ::protobuf::SingularPtrField<Input>,
    pub predicted_concepts: ::protobuf::RepeatedField<Concept>,
    pub ground_truth_concepts: ::protobuf::RepeatedField<Concept>,
    pub annotation: ::protobuf::SingularPtrField<Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EvalTestSetEntry {
    fn default() -> &'a EvalTestSetEntry {
        <EvalTestSetEntry as ::protobuf::Message>::default_instance()
    }
}

impl EvalTestSetEntry {
    pub fn new() -> EvalTestSetEntry {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // .clarifai.api.Input input = 6;


    pub fn get_input(&self) -> &Input {
        self.input.as_ref().unwrap_or_else(|| <Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: Input) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut Input {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> Input {
        self.input.take().unwrap_or_else(|| Input::new())
    }

    // repeated .clarifai.api.Concept predicted_concepts = 3;


    pub fn get_predicted_concepts(&self) -> &[Concept] {
        &self.predicted_concepts
    }
    pub fn clear_predicted_concepts(&mut self) {
        self.predicted_concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicted_concepts(&mut self, v: ::protobuf::RepeatedField<Concept>) {
        self.predicted_concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_predicted_concepts(&mut self) -> &mut ::protobuf::RepeatedField<Concept> {
        &mut self.predicted_concepts
    }

    // Take field
    pub fn take_predicted_concepts(&mut self) -> ::protobuf::RepeatedField<Concept> {
        ::std::mem::replace(&mut self.predicted_concepts, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.Concept ground_truth_concepts = 4;


    pub fn get_ground_truth_concepts(&self) -> &[Concept] {
        &self.ground_truth_concepts
    }
    pub fn clear_ground_truth_concepts(&mut self) {
        self.ground_truth_concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_ground_truth_concepts(&mut self, v: ::protobuf::RepeatedField<Concept>) {
        self.ground_truth_concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ground_truth_concepts(&mut self) -> &mut ::protobuf::RepeatedField<Concept> {
        &mut self.ground_truth_concepts
    }

    // Take field
    pub fn take_ground_truth_concepts(&mut self) -> ::protobuf::RepeatedField<Concept> {
        ::std::mem::replace(&mut self.ground_truth_concepts, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Annotation annotation = 5;


    pub fn get_annotation(&self) -> &Annotation {
        self.annotation.as_ref().unwrap_or_else(|| <Annotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }

    pub fn has_annotation(&self) -> bool {
        self.annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: Annotation) {
        self.annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation(&mut self) -> &mut Annotation {
        if self.annotation.is_none() {
            self.annotation.set_default();
        }
        self.annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_annotation(&mut self) -> Annotation {
        self.annotation.take().unwrap_or_else(|| Annotation::new())
    }
}

impl ::protobuf::Message for EvalTestSetEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.predicted_concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ground_truth_concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.predicted_concepts)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ground_truth_concepts)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.predicted_concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ground_truth_concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.predicted_concepts {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ground_truth_concepts {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.annotation.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EvalTestSetEntry {
        EvalTestSetEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &EvalTestSetEntry| { &m.id },
                |m: &mut EvalTestSetEntry| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &EvalTestSetEntry| { &m.url },
                |m: &mut EvalTestSetEntry| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Input>>(
                "input",
                |m: &EvalTestSetEntry| { &m.input },
                |m: &mut EvalTestSetEntry| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Concept>>(
                "predicted_concepts",
                |m: &EvalTestSetEntry| { &m.predicted_concepts },
                |m: &mut EvalTestSetEntry| { &mut m.predicted_concepts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Concept>>(
                "ground_truth_concepts",
                |m: &EvalTestSetEntry| { &m.ground_truth_concepts },
                |m: &mut EvalTestSetEntry| { &mut m.ground_truth_concepts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotation>>(
                "annotation",
                |m: &EvalTestSetEntry| { &m.annotation },
                |m: &mut EvalTestSetEntry| { &mut m.annotation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EvalTestSetEntry>(
                "EvalTestSetEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EvalTestSetEntry {
        static instance: ::protobuf::rt::LazyV2<EvalTestSetEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EvalTestSetEntry::new)
    }
}

impl ::protobuf::Clear for EvalTestSetEntry {
    fn clear(&mut self) {
        self.id.clear();
        self.url.clear();
        self.input.clear();
        self.predicted_concepts.clear();
        self.ground_truth_concepts.clear();
        self.annotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EvalTestSetEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvalTestSetEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LOPQEvalResult {
    // message fields
    pub k: i32,
    pub recall_vs_brute_force: f32,
    pub kendall_tau_vs_brute_force: f32,
    pub most_frequent_code_percent: f32,
    pub lopq_ndcg: f32,
    pub brute_force_ndcg: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LOPQEvalResult {
    fn default() -> &'a LOPQEvalResult {
        <LOPQEvalResult as ::protobuf::Message>::default_instance()
    }
}

impl LOPQEvalResult {
    pub fn new() -> LOPQEvalResult {
        ::std::default::Default::default()
    }

    // int32 k = 1;


    pub fn get_k(&self) -> i32 {
        self.k
    }
    pub fn clear_k(&mut self) {
        self.k = 0;
    }

    // Param is passed by value, moved
    pub fn set_k(&mut self, v: i32) {
        self.k = v;
    }

    // float recall_vs_brute_force = 2;


    pub fn get_recall_vs_brute_force(&self) -> f32 {
        self.recall_vs_brute_force
    }
    pub fn clear_recall_vs_brute_force(&mut self) {
        self.recall_vs_brute_force = 0.;
    }

    // Param is passed by value, moved
    pub fn set_recall_vs_brute_force(&mut self, v: f32) {
        self.recall_vs_brute_force = v;
    }

    // float kendall_tau_vs_brute_force = 3;


    pub fn get_kendall_tau_vs_brute_force(&self) -> f32 {
        self.kendall_tau_vs_brute_force
    }
    pub fn clear_kendall_tau_vs_brute_force(&mut self) {
        self.kendall_tau_vs_brute_force = 0.;
    }

    // Param is passed by value, moved
    pub fn set_kendall_tau_vs_brute_force(&mut self, v: f32) {
        self.kendall_tau_vs_brute_force = v;
    }

    // float most_frequent_code_percent = 4;


    pub fn get_most_frequent_code_percent(&self) -> f32 {
        self.most_frequent_code_percent
    }
    pub fn clear_most_frequent_code_percent(&mut self) {
        self.most_frequent_code_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_most_frequent_code_percent(&mut self, v: f32) {
        self.most_frequent_code_percent = v;
    }

    // float lopq_ndcg = 5;


    pub fn get_lopq_ndcg(&self) -> f32 {
        self.lopq_ndcg
    }
    pub fn clear_lopq_ndcg(&mut self) {
        self.lopq_ndcg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lopq_ndcg(&mut self, v: f32) {
        self.lopq_ndcg = v;
    }

    // float brute_force_ndcg = 6;


    pub fn get_brute_force_ndcg(&self) -> f32 {
        self.brute_force_ndcg
    }
    pub fn clear_brute_force_ndcg(&mut self) {
        self.brute_force_ndcg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_brute_force_ndcg(&mut self, v: f32) {
        self.brute_force_ndcg = v;
    }
}

impl ::protobuf::Message for LOPQEvalResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.k = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.recall_vs_brute_force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.kendall_tau_vs_brute_force = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.most_frequent_code_percent = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.lopq_ndcg = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.brute_force_ndcg = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.k != 0 {
            my_size += ::protobuf::rt::value_size(1, self.k, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.recall_vs_brute_force != 0. {
            my_size += 5;
        }
        if self.kendall_tau_vs_brute_force != 0. {
            my_size += 5;
        }
        if self.most_frequent_code_percent != 0. {
            my_size += 5;
        }
        if self.lopq_ndcg != 0. {
            my_size += 5;
        }
        if self.brute_force_ndcg != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.k != 0 {
            os.write_int32(1, self.k)?;
        }
        if self.recall_vs_brute_force != 0. {
            os.write_float(2, self.recall_vs_brute_force)?;
        }
        if self.kendall_tau_vs_brute_force != 0. {
            os.write_float(3, self.kendall_tau_vs_brute_force)?;
        }
        if self.most_frequent_code_percent != 0. {
            os.write_float(4, self.most_frequent_code_percent)?;
        }
        if self.lopq_ndcg != 0. {
            os.write_float(5, self.lopq_ndcg)?;
        }
        if self.brute_force_ndcg != 0. {
            os.write_float(6, self.brute_force_ndcg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LOPQEvalResult {
        LOPQEvalResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "k",
                |m: &LOPQEvalResult| { &m.k },
                |m: &mut LOPQEvalResult| { &mut m.k },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "recall_vs_brute_force",
                |m: &LOPQEvalResult| { &m.recall_vs_brute_force },
                |m: &mut LOPQEvalResult| { &mut m.recall_vs_brute_force },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "kendall_tau_vs_brute_force",
                |m: &LOPQEvalResult| { &m.kendall_tau_vs_brute_force },
                |m: &mut LOPQEvalResult| { &mut m.kendall_tau_vs_brute_force },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "most_frequent_code_percent",
                |m: &LOPQEvalResult| { &m.most_frequent_code_percent },
                |m: &mut LOPQEvalResult| { &mut m.most_frequent_code_percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "lopq_ndcg",
                |m: &LOPQEvalResult| { &m.lopq_ndcg },
                |m: &mut LOPQEvalResult| { &mut m.lopq_ndcg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "brute_force_ndcg",
                |m: &LOPQEvalResult| { &m.brute_force_ndcg },
                |m: &mut LOPQEvalResult| { &mut m.brute_force_ndcg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LOPQEvalResult>(
                "LOPQEvalResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LOPQEvalResult {
        static instance: ::protobuf::rt::LazyV2<LOPQEvalResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LOPQEvalResult::new)
    }
}

impl ::protobuf::Clear for LOPQEvalResult {
    fn clear(&mut self) {
        self.k = 0;
        self.recall_vs_brute_force = 0.;
        self.kendall_tau_vs_brute_force = 0.;
        self.most_frequent_code_percent = 0.;
        self.lopq_ndcg = 0.;
        self.brute_force_ndcg = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LOPQEvalResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LOPQEvalResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricsSummary {
    // message fields
    pub top1_accuracy: f32,
    pub top5_accuracy: f32,
    pub macro_avg_roc_auc: f32,
    pub macro_std_roc_auc: f32,
    pub macro_avg_f1_score: f32,
    pub macro_std_f1_score: f32,
    pub macro_avg_precision: f32,
    pub macro_avg_recall: f32,
    pub mean_avg_precision_iou_50: f32,
    pub mean_avg_precision_iou_range: f32,
    pub lopq_metrics: ::protobuf::RepeatedField<LOPQEvalResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricsSummary {
    fn default() -> &'a MetricsSummary {
        <MetricsSummary as ::protobuf::Message>::default_instance()
    }
}

impl MetricsSummary {
    pub fn new() -> MetricsSummary {
        ::std::default::Default::default()
    }

    // float top1_accuracy = 1;


    pub fn get_top1_accuracy(&self) -> f32 {
        self.top1_accuracy
    }
    pub fn clear_top1_accuracy(&mut self) {
        self.top1_accuracy = 0.;
    }

    // Param is passed by value, moved
    pub fn set_top1_accuracy(&mut self, v: f32) {
        self.top1_accuracy = v;
    }

    // float top5_accuracy = 2;


    pub fn get_top5_accuracy(&self) -> f32 {
        self.top5_accuracy
    }
    pub fn clear_top5_accuracy(&mut self) {
        self.top5_accuracy = 0.;
    }

    // Param is passed by value, moved
    pub fn set_top5_accuracy(&mut self, v: f32) {
        self.top5_accuracy = v;
    }

    // float macro_avg_roc_auc = 3;


    pub fn get_macro_avg_roc_auc(&self) -> f32 {
        self.macro_avg_roc_auc
    }
    pub fn clear_macro_avg_roc_auc(&mut self) {
        self.macro_avg_roc_auc = 0.;
    }

    // Param is passed by value, moved
    pub fn set_macro_avg_roc_auc(&mut self, v: f32) {
        self.macro_avg_roc_auc = v;
    }

    // float macro_std_roc_auc = 4;


    pub fn get_macro_std_roc_auc(&self) -> f32 {
        self.macro_std_roc_auc
    }
    pub fn clear_macro_std_roc_auc(&mut self) {
        self.macro_std_roc_auc = 0.;
    }

    // Param is passed by value, moved
    pub fn set_macro_std_roc_auc(&mut self, v: f32) {
        self.macro_std_roc_auc = v;
    }

    // float macro_avg_f1_score = 5;


    pub fn get_macro_avg_f1_score(&self) -> f32 {
        self.macro_avg_f1_score
    }
    pub fn clear_macro_avg_f1_score(&mut self) {
        self.macro_avg_f1_score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_macro_avg_f1_score(&mut self, v: f32) {
        self.macro_avg_f1_score = v;
    }

    // float macro_std_f1_score = 6;


    pub fn get_macro_std_f1_score(&self) -> f32 {
        self.macro_std_f1_score
    }
    pub fn clear_macro_std_f1_score(&mut self) {
        self.macro_std_f1_score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_macro_std_f1_score(&mut self, v: f32) {
        self.macro_std_f1_score = v;
    }

    // float macro_avg_precision = 7;


    pub fn get_macro_avg_precision(&self) -> f32 {
        self.macro_avg_precision
    }
    pub fn clear_macro_avg_precision(&mut self) {
        self.macro_avg_precision = 0.;
    }

    // Param is passed by value, moved
    pub fn set_macro_avg_precision(&mut self, v: f32) {
        self.macro_avg_precision = v;
    }

    // float macro_avg_recall = 8;


    pub fn get_macro_avg_recall(&self) -> f32 {
        self.macro_avg_recall
    }
    pub fn clear_macro_avg_recall(&mut self) {
        self.macro_avg_recall = 0.;
    }

    // Param is passed by value, moved
    pub fn set_macro_avg_recall(&mut self, v: f32) {
        self.macro_avg_recall = v;
    }

    // float mean_avg_precision_iou_50 = 10;


    pub fn get_mean_avg_precision_iou_50(&self) -> f32 {
        self.mean_avg_precision_iou_50
    }
    pub fn clear_mean_avg_precision_iou_50(&mut self) {
        self.mean_avg_precision_iou_50 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mean_avg_precision_iou_50(&mut self, v: f32) {
        self.mean_avg_precision_iou_50 = v;
    }

    // float mean_avg_precision_iou_range = 11;


    pub fn get_mean_avg_precision_iou_range(&self) -> f32 {
        self.mean_avg_precision_iou_range
    }
    pub fn clear_mean_avg_precision_iou_range(&mut self) {
        self.mean_avg_precision_iou_range = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mean_avg_precision_iou_range(&mut self, v: f32) {
        self.mean_avg_precision_iou_range = v;
    }

    // repeated .clarifai.api.LOPQEvalResult lopq_metrics = 9;


    pub fn get_lopq_metrics(&self) -> &[LOPQEvalResult] {
        &self.lopq_metrics
    }
    pub fn clear_lopq_metrics(&mut self) {
        self.lopq_metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_lopq_metrics(&mut self, v: ::protobuf::RepeatedField<LOPQEvalResult>) {
        self.lopq_metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lopq_metrics(&mut self) -> &mut ::protobuf::RepeatedField<LOPQEvalResult> {
        &mut self.lopq_metrics
    }

    // Take field
    pub fn take_lopq_metrics(&mut self) -> ::protobuf::RepeatedField<LOPQEvalResult> {
        ::std::mem::replace(&mut self.lopq_metrics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MetricsSummary {
    fn is_initialized(&self) -> bool {
        for v in &self.lopq_metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.top1_accuracy = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.top5_accuracy = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.macro_avg_roc_auc = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.macro_std_roc_auc = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.macro_avg_f1_score = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.macro_std_f1_score = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.macro_avg_precision = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.macro_avg_recall = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mean_avg_precision_iou_50 = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mean_avg_precision_iou_range = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.lopq_metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.top1_accuracy != 0. {
            my_size += 5;
        }
        if self.top5_accuracy != 0. {
            my_size += 5;
        }
        if self.macro_avg_roc_auc != 0. {
            my_size += 5;
        }
        if self.macro_std_roc_auc != 0. {
            my_size += 5;
        }
        if self.macro_avg_f1_score != 0. {
            my_size += 5;
        }
        if self.macro_std_f1_score != 0. {
            my_size += 5;
        }
        if self.macro_avg_precision != 0. {
            my_size += 5;
        }
        if self.macro_avg_recall != 0. {
            my_size += 5;
        }
        if self.mean_avg_precision_iou_50 != 0. {
            my_size += 5;
        }
        if self.mean_avg_precision_iou_range != 0. {
            my_size += 5;
        }
        for value in &self.lopq_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.top1_accuracy != 0. {
            os.write_float(1, self.top1_accuracy)?;
        }
        if self.top5_accuracy != 0. {
            os.write_float(2, self.top5_accuracy)?;
        }
        if self.macro_avg_roc_auc != 0. {
            os.write_float(3, self.macro_avg_roc_auc)?;
        }
        if self.macro_std_roc_auc != 0. {
            os.write_float(4, self.macro_std_roc_auc)?;
        }
        if self.macro_avg_f1_score != 0. {
            os.write_float(5, self.macro_avg_f1_score)?;
        }
        if self.macro_std_f1_score != 0. {
            os.write_float(6, self.macro_std_f1_score)?;
        }
        if self.macro_avg_precision != 0. {
            os.write_float(7, self.macro_avg_precision)?;
        }
        if self.macro_avg_recall != 0. {
            os.write_float(8, self.macro_avg_recall)?;
        }
        if self.mean_avg_precision_iou_50 != 0. {
            os.write_float(10, self.mean_avg_precision_iou_50)?;
        }
        if self.mean_avg_precision_iou_range != 0. {
            os.write_float(11, self.mean_avg_precision_iou_range)?;
        }
        for v in &self.lopq_metrics {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricsSummary {
        MetricsSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "top1_accuracy",
                |m: &MetricsSummary| { &m.top1_accuracy },
                |m: &mut MetricsSummary| { &mut m.top1_accuracy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "top5_accuracy",
                |m: &MetricsSummary| { &m.top5_accuracy },
                |m: &mut MetricsSummary| { &mut m.top5_accuracy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "macro_avg_roc_auc",
                |m: &MetricsSummary| { &m.macro_avg_roc_auc },
                |m: &mut MetricsSummary| { &mut m.macro_avg_roc_auc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "macro_std_roc_auc",
                |m: &MetricsSummary| { &m.macro_std_roc_auc },
                |m: &mut MetricsSummary| { &mut m.macro_std_roc_auc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "macro_avg_f1_score",
                |m: &MetricsSummary| { &m.macro_avg_f1_score },
                |m: &mut MetricsSummary| { &mut m.macro_avg_f1_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "macro_std_f1_score",
                |m: &MetricsSummary| { &m.macro_std_f1_score },
                |m: &mut MetricsSummary| { &mut m.macro_std_f1_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "macro_avg_precision",
                |m: &MetricsSummary| { &m.macro_avg_precision },
                |m: &mut MetricsSummary| { &mut m.macro_avg_precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "macro_avg_recall",
                |m: &MetricsSummary| { &m.macro_avg_recall },
                |m: &mut MetricsSummary| { &mut m.macro_avg_recall },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mean_avg_precision_iou_50",
                |m: &MetricsSummary| { &m.mean_avg_precision_iou_50 },
                |m: &mut MetricsSummary| { &mut m.mean_avg_precision_iou_50 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mean_avg_precision_iou_range",
                |m: &MetricsSummary| { &m.mean_avg_precision_iou_range },
                |m: &mut MetricsSummary| { &mut m.mean_avg_precision_iou_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LOPQEvalResult>>(
                "lopq_metrics",
                |m: &MetricsSummary| { &m.lopq_metrics },
                |m: &mut MetricsSummary| { &mut m.lopq_metrics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricsSummary>(
                "MetricsSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MetricsSummary {
        static instance: ::protobuf::rt::LazyV2<MetricsSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetricsSummary::new)
    }
}

impl ::protobuf::Clear for MetricsSummary {
    fn clear(&mut self) {
        self.top1_accuracy = 0.;
        self.top5_accuracy = 0.;
        self.macro_avg_roc_auc = 0.;
        self.macro_std_roc_auc = 0.;
        self.macro_avg_f1_score = 0.;
        self.macro_std_f1_score = 0.;
        self.macro_avg_precision = 0.;
        self.macro_avg_recall = 0.;
        self.mean_avg_precision_iou_50 = 0.;
        self.mean_avg_precision_iou_range = 0.;
        self.lopq_metrics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricsSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricsSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EvalMetrics {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub id: ::std::string::String,
    pub summary: ::protobuf::SingularPtrField<MetricsSummary>,
    pub confusion_matrix: ::protobuf::SingularPtrField<ConfusionMatrix>,
    pub cooccurrence_matrix: ::protobuf::SingularPtrField<CooccurrenceMatrix>,
    pub label_counts: ::protobuf::SingularPtrField<LabelDistribution>,
    pub binary_metrics: ::protobuf::RepeatedField<BinaryMetrics>,
    pub test_set: ::protobuf::RepeatedField<EvalTestSetEntry>,
    pub metrics_by_area: ::protobuf::RepeatedField<BinaryMetrics>,
    pub metrics_by_class: ::protobuf::RepeatedField<BinaryMetrics>,
    pub tracker_metrics: ::protobuf::RepeatedField<TrackerMetrics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EvalMetrics {
    fn default() -> &'a EvalMetrics {
        <EvalMetrics as ::protobuf::Message>::default_instance()
    }
}

impl EvalMetrics {
    pub fn new() -> EvalMetrics {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // string id = 10;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.MetricsSummary summary = 2;


    pub fn get_summary(&self) -> &MetricsSummary {
        self.summary.as_ref().unwrap_or_else(|| <MetricsSummary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: MetricsSummary) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut MetricsSummary {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> MetricsSummary {
        self.summary.take().unwrap_or_else(|| MetricsSummary::new())
    }

    // .clarifai.api.ConfusionMatrix confusion_matrix = 3;


    pub fn get_confusion_matrix(&self) -> &ConfusionMatrix {
        self.confusion_matrix.as_ref().unwrap_or_else(|| <ConfusionMatrix as ::protobuf::Message>::default_instance())
    }
    pub fn clear_confusion_matrix(&mut self) {
        self.confusion_matrix.clear();
    }

    pub fn has_confusion_matrix(&self) -> bool {
        self.confusion_matrix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confusion_matrix(&mut self, v: ConfusionMatrix) {
        self.confusion_matrix = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confusion_matrix(&mut self) -> &mut ConfusionMatrix {
        if self.confusion_matrix.is_none() {
            self.confusion_matrix.set_default();
        }
        self.confusion_matrix.as_mut().unwrap()
    }

    // Take field
    pub fn take_confusion_matrix(&mut self) -> ConfusionMatrix {
        self.confusion_matrix.take().unwrap_or_else(|| ConfusionMatrix::new())
    }

    // .clarifai.api.CooccurrenceMatrix cooccurrence_matrix = 4;


    pub fn get_cooccurrence_matrix(&self) -> &CooccurrenceMatrix {
        self.cooccurrence_matrix.as_ref().unwrap_or_else(|| <CooccurrenceMatrix as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cooccurrence_matrix(&mut self) {
        self.cooccurrence_matrix.clear();
    }

    pub fn has_cooccurrence_matrix(&self) -> bool {
        self.cooccurrence_matrix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooccurrence_matrix(&mut self, v: CooccurrenceMatrix) {
        self.cooccurrence_matrix = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cooccurrence_matrix(&mut self) -> &mut CooccurrenceMatrix {
        if self.cooccurrence_matrix.is_none() {
            self.cooccurrence_matrix.set_default();
        }
        self.cooccurrence_matrix.as_mut().unwrap()
    }

    // Take field
    pub fn take_cooccurrence_matrix(&mut self) -> CooccurrenceMatrix {
        self.cooccurrence_matrix.take().unwrap_or_else(|| CooccurrenceMatrix::new())
    }

    // .clarifai.api.LabelDistribution label_counts = 5;


    pub fn get_label_counts(&self) -> &LabelDistribution {
        self.label_counts.as_ref().unwrap_or_else(|| <LabelDistribution as ::protobuf::Message>::default_instance())
    }
    pub fn clear_label_counts(&mut self) {
        self.label_counts.clear();
    }

    pub fn has_label_counts(&self) -> bool {
        self.label_counts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label_counts(&mut self, v: LabelDistribution) {
        self.label_counts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label_counts(&mut self) -> &mut LabelDistribution {
        if self.label_counts.is_none() {
            self.label_counts.set_default();
        }
        self.label_counts.as_mut().unwrap()
    }

    // Take field
    pub fn take_label_counts(&mut self) -> LabelDistribution {
        self.label_counts.take().unwrap_or_else(|| LabelDistribution::new())
    }

    // repeated .clarifai.api.BinaryMetrics binary_metrics = 6;


    pub fn get_binary_metrics(&self) -> &[BinaryMetrics] {
        &self.binary_metrics
    }
    pub fn clear_binary_metrics(&mut self) {
        self.binary_metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_metrics(&mut self, v: ::protobuf::RepeatedField<BinaryMetrics>) {
        self.binary_metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_metrics(&mut self) -> &mut ::protobuf::RepeatedField<BinaryMetrics> {
        &mut self.binary_metrics
    }

    // Take field
    pub fn take_binary_metrics(&mut self) -> ::protobuf::RepeatedField<BinaryMetrics> {
        ::std::mem::replace(&mut self.binary_metrics, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.EvalTestSetEntry test_set = 7;


    pub fn get_test_set(&self) -> &[EvalTestSetEntry] {
        &self.test_set
    }
    pub fn clear_test_set(&mut self) {
        self.test_set.clear();
    }

    // Param is passed by value, moved
    pub fn set_test_set(&mut self, v: ::protobuf::RepeatedField<EvalTestSetEntry>) {
        self.test_set = v;
    }

    // Mutable pointer to the field.
    pub fn mut_test_set(&mut self) -> &mut ::protobuf::RepeatedField<EvalTestSetEntry> {
        &mut self.test_set
    }

    // Take field
    pub fn take_test_set(&mut self) -> ::protobuf::RepeatedField<EvalTestSetEntry> {
        ::std::mem::replace(&mut self.test_set, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.BinaryMetrics metrics_by_area = 8;


    pub fn get_metrics_by_area(&self) -> &[BinaryMetrics] {
        &self.metrics_by_area
    }
    pub fn clear_metrics_by_area(&mut self) {
        self.metrics_by_area.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics_by_area(&mut self, v: ::protobuf::RepeatedField<BinaryMetrics>) {
        self.metrics_by_area = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics_by_area(&mut self) -> &mut ::protobuf::RepeatedField<BinaryMetrics> {
        &mut self.metrics_by_area
    }

    // Take field
    pub fn take_metrics_by_area(&mut self) -> ::protobuf::RepeatedField<BinaryMetrics> {
        ::std::mem::replace(&mut self.metrics_by_area, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.BinaryMetrics metrics_by_class = 9;


    pub fn get_metrics_by_class(&self) -> &[BinaryMetrics] {
        &self.metrics_by_class
    }
    pub fn clear_metrics_by_class(&mut self) {
        self.metrics_by_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics_by_class(&mut self, v: ::protobuf::RepeatedField<BinaryMetrics>) {
        self.metrics_by_class = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics_by_class(&mut self) -> &mut ::protobuf::RepeatedField<BinaryMetrics> {
        &mut self.metrics_by_class
    }

    // Take field
    pub fn take_metrics_by_class(&mut self) -> ::protobuf::RepeatedField<BinaryMetrics> {
        ::std::mem::replace(&mut self.metrics_by_class, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.TrackerMetrics tracker_metrics = 11;


    pub fn get_tracker_metrics(&self) -> &[TrackerMetrics] {
        &self.tracker_metrics
    }
    pub fn clear_tracker_metrics(&mut self) {
        self.tracker_metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_tracker_metrics(&mut self, v: ::protobuf::RepeatedField<TrackerMetrics>) {
        self.tracker_metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tracker_metrics(&mut self) -> &mut ::protobuf::RepeatedField<TrackerMetrics> {
        &mut self.tracker_metrics
    }

    // Take field
    pub fn take_tracker_metrics(&mut self) -> ::protobuf::RepeatedField<TrackerMetrics> {
        ::std::mem::replace(&mut self.tracker_metrics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EvalMetrics {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.confusion_matrix {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cooccurrence_matrix {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_counts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.test_set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metrics_by_area {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metrics_by_class {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tracker_metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.summary)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.confusion_matrix)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cooccurrence_matrix)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.label_counts)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.binary_metrics)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.test_set)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metrics_by_area)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metrics_by_class)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tracker_metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.id);
        }
        if let Some(ref v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.confusion_matrix.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cooccurrence_matrix.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.label_counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.binary_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.test_set {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.metrics_by_area {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.metrics_by_class {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tracker_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(10, &self.id)?;
        }
        if let Some(ref v) = self.summary.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.confusion_matrix.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cooccurrence_matrix.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.label_counts.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.binary_metrics {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.test_set {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.metrics_by_area {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.metrics_by_class {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tracker_metrics {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EvalMetrics {
        EvalMetrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &EvalMetrics| { &m.status },
                |m: &mut EvalMetrics| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &EvalMetrics| { &m.id },
                |m: &mut EvalMetrics| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricsSummary>>(
                "summary",
                |m: &EvalMetrics| { &m.summary },
                |m: &mut EvalMetrics| { &mut m.summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfusionMatrix>>(
                "confusion_matrix",
                |m: &EvalMetrics| { &m.confusion_matrix },
                |m: &mut EvalMetrics| { &mut m.confusion_matrix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CooccurrenceMatrix>>(
                "cooccurrence_matrix",
                |m: &EvalMetrics| { &m.cooccurrence_matrix },
                |m: &mut EvalMetrics| { &mut m.cooccurrence_matrix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelDistribution>>(
                "label_counts",
                |m: &EvalMetrics| { &m.label_counts },
                |m: &mut EvalMetrics| { &mut m.label_counts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BinaryMetrics>>(
                "binary_metrics",
                |m: &EvalMetrics| { &m.binary_metrics },
                |m: &mut EvalMetrics| { &mut m.binary_metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EvalTestSetEntry>>(
                "test_set",
                |m: &EvalMetrics| { &m.test_set },
                |m: &mut EvalMetrics| { &mut m.test_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BinaryMetrics>>(
                "metrics_by_area",
                |m: &EvalMetrics| { &m.metrics_by_area },
                |m: &mut EvalMetrics| { &mut m.metrics_by_area },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BinaryMetrics>>(
                "metrics_by_class",
                |m: &EvalMetrics| { &m.metrics_by_class },
                |m: &mut EvalMetrics| { &mut m.metrics_by_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrackerMetrics>>(
                "tracker_metrics",
                |m: &EvalMetrics| { &m.tracker_metrics },
                |m: &mut EvalMetrics| { &mut m.tracker_metrics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EvalMetrics>(
                "EvalMetrics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EvalMetrics {
        static instance: ::protobuf::rt::LazyV2<EvalMetrics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EvalMetrics::new)
    }
}

impl ::protobuf::Clear for EvalMetrics {
    fn clear(&mut self) {
        self.status.clear();
        self.id.clear();
        self.summary.clear();
        self.confusion_matrix.clear();
        self.cooccurrence_matrix.clear();
        self.label_counts.clear();
        self.binary_metrics.clear();
        self.test_set.clear();
        self.metrics_by_area.clear();
        self.metrics_by_class.clear();
        self.tracker_metrics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EvalMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvalMetrics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldsValue {
    // message fields
    pub confusion_matrix: bool,
    pub cooccurrence_matrix: bool,
    pub label_counts: bool,
    pub binary_metrics: bool,
    pub test_set: bool,
    pub metrics_by_area: bool,
    pub metrics_by_class: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldsValue {
    fn default() -> &'a FieldsValue {
        <FieldsValue as ::protobuf::Message>::default_instance()
    }
}

impl FieldsValue {
    pub fn new() -> FieldsValue {
        ::std::default::Default::default()
    }

    // bool confusion_matrix = 1;


    pub fn get_confusion_matrix(&self) -> bool {
        self.confusion_matrix
    }
    pub fn clear_confusion_matrix(&mut self) {
        self.confusion_matrix = false;
    }

    // Param is passed by value, moved
    pub fn set_confusion_matrix(&mut self, v: bool) {
        self.confusion_matrix = v;
    }

    // bool cooccurrence_matrix = 2;


    pub fn get_cooccurrence_matrix(&self) -> bool {
        self.cooccurrence_matrix
    }
    pub fn clear_cooccurrence_matrix(&mut self) {
        self.cooccurrence_matrix = false;
    }

    // Param is passed by value, moved
    pub fn set_cooccurrence_matrix(&mut self, v: bool) {
        self.cooccurrence_matrix = v;
    }

    // bool label_counts = 3;


    pub fn get_label_counts(&self) -> bool {
        self.label_counts
    }
    pub fn clear_label_counts(&mut self) {
        self.label_counts = false;
    }

    // Param is passed by value, moved
    pub fn set_label_counts(&mut self, v: bool) {
        self.label_counts = v;
    }

    // bool binary_metrics = 4;


    pub fn get_binary_metrics(&self) -> bool {
        self.binary_metrics
    }
    pub fn clear_binary_metrics(&mut self) {
        self.binary_metrics = false;
    }

    // Param is passed by value, moved
    pub fn set_binary_metrics(&mut self, v: bool) {
        self.binary_metrics = v;
    }

    // bool test_set = 5;


    pub fn get_test_set(&self) -> bool {
        self.test_set
    }
    pub fn clear_test_set(&mut self) {
        self.test_set = false;
    }

    // Param is passed by value, moved
    pub fn set_test_set(&mut self, v: bool) {
        self.test_set = v;
    }

    // bool metrics_by_area = 6;


    pub fn get_metrics_by_area(&self) -> bool {
        self.metrics_by_area
    }
    pub fn clear_metrics_by_area(&mut self) {
        self.metrics_by_area = false;
    }

    // Param is passed by value, moved
    pub fn set_metrics_by_area(&mut self, v: bool) {
        self.metrics_by_area = v;
    }

    // bool metrics_by_class = 7;


    pub fn get_metrics_by_class(&self) -> bool {
        self.metrics_by_class
    }
    pub fn clear_metrics_by_class(&mut self) {
        self.metrics_by_class = false;
    }

    // Param is passed by value, moved
    pub fn set_metrics_by_class(&mut self, v: bool) {
        self.metrics_by_class = v;
    }
}

impl ::protobuf::Message for FieldsValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.confusion_matrix = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cooccurrence_matrix = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.label_counts = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.binary_metrics = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.test_set = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.metrics_by_area = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.metrics_by_class = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.confusion_matrix != false {
            my_size += 2;
        }
        if self.cooccurrence_matrix != false {
            my_size += 2;
        }
        if self.label_counts != false {
            my_size += 2;
        }
        if self.binary_metrics != false {
            my_size += 2;
        }
        if self.test_set != false {
            my_size += 2;
        }
        if self.metrics_by_area != false {
            my_size += 2;
        }
        if self.metrics_by_class != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.confusion_matrix != false {
            os.write_bool(1, self.confusion_matrix)?;
        }
        if self.cooccurrence_matrix != false {
            os.write_bool(2, self.cooccurrence_matrix)?;
        }
        if self.label_counts != false {
            os.write_bool(3, self.label_counts)?;
        }
        if self.binary_metrics != false {
            os.write_bool(4, self.binary_metrics)?;
        }
        if self.test_set != false {
            os.write_bool(5, self.test_set)?;
        }
        if self.metrics_by_area != false {
            os.write_bool(6, self.metrics_by_area)?;
        }
        if self.metrics_by_class != false {
            os.write_bool(7, self.metrics_by_class)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldsValue {
        FieldsValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "confusion_matrix",
                |m: &FieldsValue| { &m.confusion_matrix },
                |m: &mut FieldsValue| { &mut m.confusion_matrix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "cooccurrence_matrix",
                |m: &FieldsValue| { &m.cooccurrence_matrix },
                |m: &mut FieldsValue| { &mut m.cooccurrence_matrix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "label_counts",
                |m: &FieldsValue| { &m.label_counts },
                |m: &mut FieldsValue| { &mut m.label_counts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "binary_metrics",
                |m: &FieldsValue| { &m.binary_metrics },
                |m: &mut FieldsValue| { &mut m.binary_metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "test_set",
                |m: &FieldsValue| { &m.test_set },
                |m: &mut FieldsValue| { &mut m.test_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "metrics_by_area",
                |m: &FieldsValue| { &m.metrics_by_area },
                |m: &mut FieldsValue| { &mut m.metrics_by_area },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "metrics_by_class",
                |m: &FieldsValue| { &m.metrics_by_class },
                |m: &mut FieldsValue| { &mut m.metrics_by_class },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldsValue>(
                "FieldsValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldsValue {
        static instance: ::protobuf::rt::LazyV2<FieldsValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldsValue::new)
    }
}

impl ::protobuf::Clear for FieldsValue {
    fn clear(&mut self) {
        self.confusion_matrix = false;
        self.cooccurrence_matrix = false;
        self.label_counts = false;
        self.binary_metrics = false;
        self.test_set = false;
        self.metrics_by_area = false;
        self.metrics_by_class = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldsValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldsValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Output {
    // message fields
    pub id: ::std::string::String,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub model: ::protobuf::SingularPtrField<Model>,
    pub input: ::protobuf::SingularPtrField<Input>,
    pub data: ::protobuf::SingularPtrField<Data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Output {
    fn default() -> &'a Output {
        <Output as ::protobuf::Message>::default_instance()
    }
}

impl Output {
    pub fn new() -> Output {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.status.Status status = 2;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .google.protobuf.Timestamp created_at = 3;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .clarifai.api.Model model = 4;


    pub fn get_model(&self) -> &Model {
        self.model.as_ref().unwrap_or_else(|| <Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> Model {
        self.model.take().unwrap_or_else(|| Model::new())
    }

    // .clarifai.api.Input input = 5;


    pub fn get_input(&self) -> &Input {
        self.input.as_ref().unwrap_or_else(|| <Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: Input) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut Input {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> Input {
        self.input.take().unwrap_or_else(|| Input::new())
    }

    // .clarifai.api.Data data = 6;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }
}

impl ::protobuf::Message for Output {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Output {
        Output::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Output| { &m.id },
                |m: &mut Output| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &Output| { &m.status },
                |m: &mut Output| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Output| { &m.created_at },
                |m: &mut Output| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Model>>(
                "model",
                |m: &Output| { &m.model },
                |m: &mut Output| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Input>>(
                "input",
                |m: &Output| { &m.input },
                |m: &mut Output| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &Output| { &m.data },
                |m: &mut Output| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Output>(
                "Output",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Output {
        static instance: ::protobuf::rt::LazyV2<Output> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Output::new)
    }
}

impl ::protobuf::Clear for Output {
    fn clear(&mut self) {
        self.id.clear();
        self.status.clear();
        self.created_at.clear();
        self.model.clear();
        self.input.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Output {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Output {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScopeDeps {
    // message fields
    pub scope: ::std::string::String,
    pub depending_scopes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScopeDeps {
    fn default() -> &'a ScopeDeps {
        <ScopeDeps as ::protobuf::Message>::default_instance()
    }
}

impl ScopeDeps {
    pub fn new() -> ScopeDeps {
        ::std::default::Default::default()
    }

    // string scope = 1;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // repeated string depending_scopes = 2;


    pub fn get_depending_scopes(&self) -> &[::std::string::String] {
        &self.depending_scopes
    }
    pub fn clear_depending_scopes(&mut self) {
        self.depending_scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_depending_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.depending_scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_depending_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.depending_scopes
    }

    // Take field
    pub fn take_depending_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.depending_scopes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScopeDeps {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.depending_scopes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.scope);
        }
        for value in &self.depending_scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.scope.is_empty() {
            os.write_string(1, &self.scope)?;
        }
        for v in &self.depending_scopes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScopeDeps {
        ScopeDeps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &ScopeDeps| { &m.scope },
                |m: &mut ScopeDeps| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "depending_scopes",
                |m: &ScopeDeps| { &m.depending_scopes },
                |m: &mut ScopeDeps| { &mut m.depending_scopes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScopeDeps>(
                "ScopeDeps",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScopeDeps {
        static instance: ::protobuf::rt::LazyV2<ScopeDeps> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScopeDeps::new)
    }
}

impl ::protobuf::Clear for ScopeDeps {
    fn clear(&mut self) {
        self.scope.clear();
        self.depending_scopes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScopeDeps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopeDeps {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointDeps {
    // message fields
    pub endpoint: ::std::string::String,
    pub depending_scopes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndpointDeps {
    fn default() -> &'a EndpointDeps {
        <EndpointDeps as ::protobuf::Message>::default_instance()
    }
}

impl EndpointDeps {
    pub fn new() -> EndpointDeps {
        ::std::default::Default::default()
    }

    // string endpoint = 1;


    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    // repeated string depending_scopes = 2;


    pub fn get_depending_scopes(&self) -> &[::std::string::String] {
        &self.depending_scopes
    }
    pub fn clear_depending_scopes(&mut self) {
        self.depending_scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_depending_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.depending_scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_depending_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.depending_scopes
    }

    // Take field
    pub fn take_depending_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.depending_scopes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EndpointDeps {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.depending_scopes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.endpoint);
        }
        for value in &self.depending_scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.endpoint.is_empty() {
            os.write_string(1, &self.endpoint)?;
        }
        for v in &self.depending_scopes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndpointDeps {
        EndpointDeps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoint",
                |m: &EndpointDeps| { &m.endpoint },
                |m: &mut EndpointDeps| { &mut m.endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "depending_scopes",
                |m: &EndpointDeps| { &m.depending_scopes },
                |m: &mut EndpointDeps| { &mut m.depending_scopes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EndpointDeps>(
                "EndpointDeps",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EndpointDeps {
        static instance: ::protobuf::rt::LazyV2<EndpointDeps> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndpointDeps::new)
    }
}

impl ::protobuf::Clear for EndpointDeps {
    fn clear(&mut self) {
        self.endpoint.clear();
        self.depending_scopes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointDeps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointDeps {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hit {
    // message fields
    pub score: f32,
    pub input: ::protobuf::SingularPtrField<Input>,
    pub annotation: ::protobuf::SingularPtrField<Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hit {
    fn default() -> &'a Hit {
        <Hit as ::protobuf::Message>::default_instance()
    }
}

impl Hit {
    pub fn new() -> Hit {
        ::std::default::Default::default()
    }

    // float score = 1;


    pub fn get_score(&self) -> f32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = v;
    }

    // .clarifai.api.Input input = 2;


    pub fn get_input(&self) -> &Input {
        self.input.as_ref().unwrap_or_else(|| <Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: Input) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut Input {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> Input {
        self.input.take().unwrap_or_else(|| Input::new())
    }

    // .clarifai.api.Annotation annotation = 3;


    pub fn get_annotation(&self) -> &Annotation {
        self.annotation.as_ref().unwrap_or_else(|| <Annotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }

    pub fn has_annotation(&self) -> bool {
        self.annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: Annotation) {
        self.annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation(&mut self) -> &mut Annotation {
        if self.annotation.is_none() {
            self.annotation.set_default();
        }
        self.annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_annotation(&mut self) -> Annotation {
        self.annotation.take().unwrap_or_else(|| Annotation::new())
    }
}

impl ::protobuf::Message for Hit {
    fn is_initialized(&self) -> bool {
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.score != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.score != 0. {
            os.write_float(1, self.score)?;
        }
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hit {
        Hit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &Hit| { &m.score },
                |m: &mut Hit| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Input>>(
                "input",
                |m: &Hit| { &m.input },
                |m: &mut Hit| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotation>>(
                "annotation",
                |m: &Hit| { &m.annotation },
                |m: &mut Hit| { &mut m.annotation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Hit>(
                "Hit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Hit {
        static instance: ::protobuf::rt::LazyV2<Hit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Hit::new)
    }
}

impl ::protobuf::Clear for Hit {
    fn clear(&mut self) {
        self.score = 0.;
        self.input.clear();
        self.annotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct And {
    // message fields
    pub input: ::protobuf::SingularPtrField<Input>,
    pub output: ::protobuf::SingularPtrField<Output>,
    pub negate: bool,
    pub annotation: ::protobuf::SingularPtrField<Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a And {
    fn default() -> &'a And {
        <And as ::protobuf::Message>::default_instance()
    }
}

impl And {
    pub fn new() -> And {
        ::std::default::Default::default()
    }

    // .clarifai.api.Input input = 1;


    pub fn get_input(&self) -> &Input {
        self.input.as_ref().unwrap_or_else(|| <Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: Input) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut Input {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> Input {
        self.input.take().unwrap_or_else(|| Input::new())
    }

    // .clarifai.api.Output output = 2;


    pub fn get_output(&self) -> &Output {
        self.output.as_ref().unwrap_or_else(|| <Output as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    pub fn has_output(&self) -> bool {
        self.output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: Output) {
        self.output = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut Output {
        if self.output.is_none() {
            self.output.set_default();
        }
        self.output.as_mut().unwrap()
    }

    // Take field
    pub fn take_output(&mut self) -> Output {
        self.output.take().unwrap_or_else(|| Output::new())
    }

    // bool negate = 3;


    pub fn get_negate(&self) -> bool {
        self.negate
    }
    pub fn clear_negate(&mut self) {
        self.negate = false;
    }

    // Param is passed by value, moved
    pub fn set_negate(&mut self, v: bool) {
        self.negate = v;
    }

    // .clarifai.api.Annotation annotation = 4;


    pub fn get_annotation(&self) -> &Annotation {
        self.annotation.as_ref().unwrap_or_else(|| <Annotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }

    pub fn has_annotation(&self) -> bool {
        self.annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: Annotation) {
        self.annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation(&mut self) -> &mut Annotation {
        if self.annotation.is_none() {
            self.annotation.set_default();
        }
        self.annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_annotation(&mut self) -> Annotation {
        self.annotation.take().unwrap_or_else(|| Annotation::new())
    }
}

impl ::protobuf::Message for And {
    fn is_initialized(&self) -> bool {
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.negate = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.negate != false {
            my_size += 2;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.negate != false {
            os.write_bool(3, self.negate)?;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> And {
        And::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Input>>(
                "input",
                |m: &And| { &m.input },
                |m: &mut And| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Output>>(
                "output",
                |m: &And| { &m.output },
                |m: &mut And| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "negate",
                |m: &And| { &m.negate },
                |m: &mut And| { &mut m.negate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotation>>(
                "annotation",
                |m: &And| { &m.annotation },
                |m: &mut And| { &mut m.annotation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<And>(
                "And",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static And {
        static instance: ::protobuf::rt::LazyV2<And> = ::protobuf::rt::LazyV2::INIT;
        instance.get(And::new)
    }
}

impl ::protobuf::Clear for And {
    fn clear(&mut self) {
        self.input.clear();
        self.output.clear();
        self.negate = false;
        self.annotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for And {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for And {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Query {
    // message fields
    pub ands: ::protobuf::RepeatedField<And>,
    pub language: ::std::string::String,
    pub filters: ::protobuf::RepeatedField<Filter>,
    pub ranks: ::protobuf::RepeatedField<Rank>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Query {
    fn default() -> &'a Query {
        <Query as ::protobuf::Message>::default_instance()
    }
}

impl Query {
    pub fn new() -> Query {
        ::std::default::Default::default()
    }

    // repeated .clarifai.api.And ands = 1;


    pub fn get_ands(&self) -> &[And] {
        &self.ands
    }
    pub fn clear_ands(&mut self) {
        self.ands.clear();
    }

    // Param is passed by value, moved
    pub fn set_ands(&mut self, v: ::protobuf::RepeatedField<And>) {
        self.ands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ands(&mut self) -> &mut ::protobuf::RepeatedField<And> {
        &mut self.ands
    }

    // Take field
    pub fn take_ands(&mut self) -> ::protobuf::RepeatedField<And> {
        ::std::mem::replace(&mut self.ands, ::protobuf::RepeatedField::new())
    }

    // string language = 2;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }

    // repeated .clarifai.api.Filter filters = 3;


    pub fn get_filters(&self) -> &[Filter] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<Filter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<Filter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<Filter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.Rank ranks = 4;


    pub fn get_ranks(&self) -> &[Rank] {
        &self.ranks
    }
    pub fn clear_ranks(&mut self) {
        self.ranks.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranks(&mut self, v: ::protobuf::RepeatedField<Rank>) {
        self.ranks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranks(&mut self) -> &mut ::protobuf::RepeatedField<Rank> {
        &mut self.ranks
    }

    // Take field
    pub fn take_ranks(&mut self) -> ::protobuf::RepeatedField<Rank> {
        ::std::mem::replace(&mut self.ranks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Query {
    fn is_initialized(&self) -> bool {
        for v in &self.ands {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ands)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ands {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ranks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ands {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.language.is_empty() {
            os.write_string(2, &self.language)?;
        }
        for v in &self.filters {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ranks {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Query {
        Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<And>>(
                "ands",
                |m: &Query| { &m.ands },
                |m: &mut Query| { &mut m.ands },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &Query| { &m.language },
                |m: &mut Query| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Filter>>(
                "filters",
                |m: &Query| { &m.filters },
                |m: &mut Query| { &mut m.filters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rank>>(
                "ranks",
                |m: &Query| { &m.ranks },
                |m: &mut Query| { &mut m.ranks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Query>(
                "Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Query {
        static instance: ::protobuf::rt::LazyV2<Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Query::new)
    }
}

impl ::protobuf::Clear for Query {
    fn clear(&mut self) {
        self.ands.clear();
        self.language.clear();
        self.filters.clear();
        self.ranks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Search {
    // message fields
    pub query: ::protobuf::SingularPtrField<Query>,
    pub id: ::std::string::String,
    pub application_id: ::std::string::String,
    pub name: ::std::string::String,
    pub as_of: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub git_hash: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub algorithm: ::std::string::String,
    pub save: bool,
    pub min_value: f32,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Search {
    fn default() -> &'a Search {
        <Search as ::protobuf::Message>::default_instance()
    }
}

impl Search {
    pub fn new() -> Search {
        ::std::default::Default::default()
    }

    // .clarifai.api.Query query = 1;


    pub fn get_query(&self) -> &Query {
        self.query.as_ref().unwrap_or_else(|| <Query as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: Query) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut Query {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> Query {
        self.query.take().unwrap_or_else(|| Query::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string application_id = 3;


    pub fn get_application_id(&self) -> &str {
        &self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: ::std::string::String) {
        self.application_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_application_id(&mut self) -> &mut ::std::string::String {
        &mut self.application_id
    }

    // Take field
    pub fn take_application_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.application_id, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp as_of = 5;


    pub fn get_as_of(&self) -> &::protobuf::well_known_types::Timestamp {
        self.as_of.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_as_of(&mut self) {
        self.as_of.clear();
    }

    pub fn has_as_of(&self) -> bool {
        self.as_of.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_of(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.as_of = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_as_of(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.as_of.is_none() {
            self.as_of.set_default();
        }
        self.as_of.as_mut().unwrap()
    }

    // Take field
    pub fn take_as_of(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.as_of.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string git_hash = 6;


    pub fn get_git_hash(&self) -> &str {
        &self.git_hash
    }
    pub fn clear_git_hash(&mut self) {
        self.git_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_git_hash(&mut self, v: ::std::string::String) {
        self.git_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_git_hash(&mut self) -> &mut ::std::string::String {
        &mut self.git_hash
    }

    // Take field
    pub fn take_git_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.git_hash, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 7;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 8;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string algorithm = 9;


    pub fn get_algorithm(&self) -> &str {
        &self.algorithm
    }
    pub fn clear_algorithm(&mut self) {
        self.algorithm.clear();
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: ::std::string::String) {
        self.algorithm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_algorithm(&mut self) -> &mut ::std::string::String {
        &mut self.algorithm
    }

    // Take field
    pub fn take_algorithm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.algorithm, ::std::string::String::new())
    }

    // bool save = 10;


    pub fn get_save(&self) -> bool {
        self.save
    }
    pub fn clear_save(&mut self) {
        self.save = false;
    }

    // Param is passed by value, moved
    pub fn set_save(&mut self, v: bool) {
        self.save = v;
    }

    // float min_value = 11;


    pub fn get_min_value(&self) -> f32 {
        self.min_value
    }
    pub fn clear_min_value(&mut self) {
        self.min_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_value(&mut self, v: f32) {
        self.min_value = v;
    }

    // .clarifai.api.Visibility visibility = 12;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }
}

impl ::protobuf::Message for Search {
    fn is_initialized(&self) -> bool {
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.as_of {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.application_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.as_of)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.git_hash)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.algorithm)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.save = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min_value = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if !self.application_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.application_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if let Some(ref v) = self.as_of.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.git_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.git_hash);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.algorithm.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.algorithm);
        }
        if self.save != false {
            my_size += 2;
        }
        if self.min_value != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if !self.application_id.is_empty() {
            os.write_string(3, &self.application_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if let Some(ref v) = self.as_of.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.git_hash.is_empty() {
            os.write_string(6, &self.git_hash)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.algorithm.is_empty() {
            os.write_string(9, &self.algorithm)?;
        }
        if self.save != false {
            os.write_bool(10, self.save)?;
        }
        if self.min_value != 0. {
            os.write_float(11, self.min_value)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Search {
        Search::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Query>>(
                "query",
                |m: &Search| { &m.query },
                |m: &mut Search| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Search| { &m.id },
                |m: &mut Search| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "application_id",
                |m: &Search| { &m.application_id },
                |m: &mut Search| { &mut m.application_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Search| { &m.name },
                |m: &mut Search| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "as_of",
                |m: &Search| { &m.as_of },
                |m: &mut Search| { &mut m.as_of },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "git_hash",
                |m: &Search| { &m.git_hash },
                |m: &mut Search| { &mut m.git_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Search| { &m.created_at },
                |m: &mut Search| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &Search| { &m.modified_at },
                |m: &mut Search| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "algorithm",
                |m: &Search| { &m.algorithm },
                |m: &mut Search| { &mut m.algorithm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "save",
                |m: &Search| { &m.save },
                |m: &mut Search| { &mut m.save },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min_value",
                |m: &Search| { &m.min_value },
                |m: &mut Search| { &mut m.min_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &Search| { &m.visibility },
                |m: &mut Search| { &mut m.visibility },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Search>(
                "Search",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Search {
        static instance: ::protobuf::rt::LazyV2<Search> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Search::new)
    }
}

impl ::protobuf::Clear for Search {
    fn clear(&mut self) {
        self.query.clear();
        self.id.clear();
        self.application_id.clear();
        self.name.clear();
        self.as_of.clear();
        self.git_hash.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.algorithm.clear();
        self.save = false;
        self.min_value = 0.;
        self.visibility.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Search {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Search {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Filter {
    // message fields
    pub negate: bool,
    pub annotation: ::protobuf::SingularPtrField<Annotation>,
    pub input: ::protobuf::SingularPtrField<Input>,
    pub last_updated_time_range: ::protobuf::SingularPtrField<TimeRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Filter {
    fn default() -> &'a Filter {
        <Filter as ::protobuf::Message>::default_instance()
    }
}

impl Filter {
    pub fn new() -> Filter {
        ::std::default::Default::default()
    }

    // bool negate = 3;


    pub fn get_negate(&self) -> bool {
        self.negate
    }
    pub fn clear_negate(&mut self) {
        self.negate = false;
    }

    // Param is passed by value, moved
    pub fn set_negate(&mut self, v: bool) {
        self.negate = v;
    }

    // .clarifai.api.Annotation annotation = 4;


    pub fn get_annotation(&self) -> &Annotation {
        self.annotation.as_ref().unwrap_or_else(|| <Annotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }

    pub fn has_annotation(&self) -> bool {
        self.annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: Annotation) {
        self.annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation(&mut self) -> &mut Annotation {
        if self.annotation.is_none() {
            self.annotation.set_default();
        }
        self.annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_annotation(&mut self) -> Annotation {
        self.annotation.take().unwrap_or_else(|| Annotation::new())
    }

    // .clarifai.api.Input input = 5;


    pub fn get_input(&self) -> &Input {
        self.input.as_ref().unwrap_or_else(|| <Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: Input) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut Input {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> Input {
        self.input.take().unwrap_or_else(|| Input::new())
    }

    // .clarifai.api.TimeRange last_updated_time_range = 6;


    pub fn get_last_updated_time_range(&self) -> &TimeRange {
        self.last_updated_time_range.as_ref().unwrap_or_else(|| <TimeRange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated_time_range(&mut self) {
        self.last_updated_time_range.clear();
    }

    pub fn has_last_updated_time_range(&self) -> bool {
        self.last_updated_time_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated_time_range(&mut self, v: TimeRange) {
        self.last_updated_time_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated_time_range(&mut self) -> &mut TimeRange {
        if self.last_updated_time_range.is_none() {
            self.last_updated_time_range.set_default();
        }
        self.last_updated_time_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated_time_range(&mut self) -> TimeRange {
        self.last_updated_time_range.take().unwrap_or_else(|| TimeRange::new())
    }
}

impl ::protobuf::Message for Filter {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated_time_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.negate = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotation)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated_time_range)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.negate != false {
            my_size += 2;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated_time_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.negate != false {
            os.write_bool(3, self.negate)?;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated_time_range.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Filter {
        Filter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "negate",
                |m: &Filter| { &m.negate },
                |m: &mut Filter| { &mut m.negate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotation>>(
                "annotation",
                |m: &Filter| { &m.annotation },
                |m: &mut Filter| { &mut m.annotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Input>>(
                "input",
                |m: &Filter| { &m.input },
                |m: &mut Filter| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeRange>>(
                "last_updated_time_range",
                |m: &Filter| { &m.last_updated_time_range },
                |m: &mut Filter| { &mut m.last_updated_time_range },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Filter>(
                "Filter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Filter {
        static instance: ::protobuf::rt::LazyV2<Filter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Filter::new)
    }
}

impl ::protobuf::Clear for Filter {
    fn clear(&mut self) {
        self.negate = false;
        self.annotation.clear();
        self.input.clear();
        self.last_updated_time_range.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Filter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeRange {
    // message fields
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeRange {
    fn default() -> &'a TimeRange {
        <TimeRange as ::protobuf::Message>::default_instance()
    }
}

impl TimeRange {
    pub fn new() -> TimeRange {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp start_time = 1;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 2;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for TimeRange {
    fn is_initialized(&self) -> bool {
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeRange {
        TimeRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &TimeRange| { &m.start_time },
                |m: &mut TimeRange| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &TimeRange| { &m.end_time },
                |m: &mut TimeRange| { &mut m.end_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeRange>(
                "TimeRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeRange {
        static instance: ::protobuf::rt::LazyV2<TimeRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeRange::new)
    }
}

impl ::protobuf::Clear for TimeRange {
    fn clear(&mut self) {
        self.start_time.clear();
        self.end_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rank {
    // message fields
    pub negate: bool,
    pub annotation: ::protobuf::SingularPtrField<Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rank {
    fn default() -> &'a Rank {
        <Rank as ::protobuf::Message>::default_instance()
    }
}

impl Rank {
    pub fn new() -> Rank {
        ::std::default::Default::default()
    }

    // bool negate = 3;


    pub fn get_negate(&self) -> bool {
        self.negate
    }
    pub fn clear_negate(&mut self) {
        self.negate = false;
    }

    // Param is passed by value, moved
    pub fn set_negate(&mut self, v: bool) {
        self.negate = v;
    }

    // .clarifai.api.Annotation annotation = 4;


    pub fn get_annotation(&self) -> &Annotation {
        self.annotation.as_ref().unwrap_or_else(|| <Annotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }

    pub fn has_annotation(&self) -> bool {
        self.annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: Annotation) {
        self.annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation(&mut self) -> &mut Annotation {
        if self.annotation.is_none() {
            self.annotation.set_default();
        }
        self.annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_annotation(&mut self) -> Annotation {
        self.annotation.take().unwrap_or_else(|| Annotation::new())
    }
}

impl ::protobuf::Message for Rank {
    fn is_initialized(&self) -> bool {
        for v in &self.annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.negate = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.negate != false {
            my_size += 2;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.negate != false {
            os.write_bool(3, self.negate)?;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rank {
        Rank::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "negate",
                |m: &Rank| { &m.negate },
                |m: &mut Rank| { &mut m.negate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotation>>(
                "annotation",
                |m: &Rank| { &m.annotation },
                |m: &mut Rank| { &mut m.annotation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rank>(
                "Rank",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rank {
        static instance: ::protobuf::rt::LazyV2<Rank> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rank::new)
    }
}

impl ::protobuf::Clear for Rank {
    fn clear(&mut self) {
        self.negate = false;
        self.annotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rank {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rank {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnnotationSearchMetrics {
    // message fields
    pub ground_truth: ::protobuf::SingularPtrField<Search>,
    pub search_to_eval: ::protobuf::SingularPtrField<Search>,
    pub metrics: ::protobuf::SingularPtrField<EvalMetrics>,
    pub data: ::protobuf::SingularPtrField<Data>,
    pub active_concept_count: u32,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnnotationSearchMetrics {
    fn default() -> &'a AnnotationSearchMetrics {
        <AnnotationSearchMetrics as ::protobuf::Message>::default_instance()
    }
}

impl AnnotationSearchMetrics {
    pub fn new() -> AnnotationSearchMetrics {
        ::std::default::Default::default()
    }

    // .clarifai.api.Search ground_truth = 1;


    pub fn get_ground_truth(&self) -> &Search {
        self.ground_truth.as_ref().unwrap_or_else(|| <Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ground_truth(&mut self) {
        self.ground_truth.clear();
    }

    pub fn has_ground_truth(&self) -> bool {
        self.ground_truth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ground_truth(&mut self, v: Search) {
        self.ground_truth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ground_truth(&mut self) -> &mut Search {
        if self.ground_truth.is_none() {
            self.ground_truth.set_default();
        }
        self.ground_truth.as_mut().unwrap()
    }

    // Take field
    pub fn take_ground_truth(&mut self) -> Search {
        self.ground_truth.take().unwrap_or_else(|| Search::new())
    }

    // .clarifai.api.Search search_to_eval = 2;


    pub fn get_search_to_eval(&self) -> &Search {
        self.search_to_eval.as_ref().unwrap_or_else(|| <Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_search_to_eval(&mut self) {
        self.search_to_eval.clear();
    }

    pub fn has_search_to_eval(&self) -> bool {
        self.search_to_eval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_to_eval(&mut self, v: Search) {
        self.search_to_eval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_to_eval(&mut self) -> &mut Search {
        if self.search_to_eval.is_none() {
            self.search_to_eval.set_default();
        }
        self.search_to_eval.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_to_eval(&mut self) -> Search {
        self.search_to_eval.take().unwrap_or_else(|| Search::new())
    }

    // .clarifai.api.EvalMetrics metrics = 3;


    pub fn get_metrics(&self) -> &EvalMetrics {
        self.metrics.as_ref().unwrap_or_else(|| <EvalMetrics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    pub fn has_metrics(&self) -> bool {
        self.metrics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: EvalMetrics) {
        self.metrics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metrics(&mut self) -> &mut EvalMetrics {
        if self.metrics.is_none() {
            self.metrics.set_default();
        }
        self.metrics.as_mut().unwrap()
    }

    // Take field
    pub fn take_metrics(&mut self) -> EvalMetrics {
        self.metrics.take().unwrap_or_else(|| EvalMetrics::new())
    }

    // .clarifai.api.Data data = 4;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // uint32 active_concept_count = 5;


    pub fn get_active_concept_count(&self) -> u32 {
        self.active_concept_count
    }
    pub fn clear_active_concept_count(&mut self) {
        self.active_concept_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_active_concept_count(&mut self, v: u32) {
        self.active_concept_count = v;
    }

    // .clarifai.api.Visibility visibility = 6;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }
}

impl ::protobuf::Message for AnnotationSearchMetrics {
    fn is_initialized(&self) -> bool {
        for v in &self.ground_truth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search_to_eval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ground_truth)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search_to_eval)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metrics)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_concept_count = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ground_truth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.search_to_eval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.active_concept_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.active_concept_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ground_truth.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.search_to_eval.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.active_concept_count != 0 {
            os.write_uint32(5, self.active_concept_count)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnnotationSearchMetrics {
        AnnotationSearchMetrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Search>>(
                "ground_truth",
                |m: &AnnotationSearchMetrics| { &m.ground_truth },
                |m: &mut AnnotationSearchMetrics| { &mut m.ground_truth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Search>>(
                "search_to_eval",
                |m: &AnnotationSearchMetrics| { &m.search_to_eval },
                |m: &mut AnnotationSearchMetrics| { &mut m.search_to_eval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EvalMetrics>>(
                "metrics",
                |m: &AnnotationSearchMetrics| { &m.metrics },
                |m: &mut AnnotationSearchMetrics| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &AnnotationSearchMetrics| { &m.data },
                |m: &mut AnnotationSearchMetrics| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_concept_count",
                |m: &AnnotationSearchMetrics| { &m.active_concept_count },
                |m: &mut AnnotationSearchMetrics| { &mut m.active_concept_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &AnnotationSearchMetrics| { &m.visibility },
                |m: &mut AnnotationSearchMetrics| { &mut m.visibility },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AnnotationSearchMetrics>(
                "AnnotationSearchMetrics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AnnotationSearchMetrics {
        static instance: ::protobuf::rt::LazyV2<AnnotationSearchMetrics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AnnotationSearchMetrics::new)
    }
}

impl ::protobuf::Clear for AnnotationSearchMetrics {
    fn clear(&mut self) {
        self.ground_truth.clear();
        self.search_to_eval.clear();
        self.metrics.clear();
        self.data.clear();
        self.active_concept_count = 0;
        self.visibility.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnnotationSearchMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotationSearchMetrics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Text {
    // message fields
    pub raw: ::std::string::String,
    pub url: ::std::string::String,
    pub allow_duplicate_url: bool,
    pub hosted: ::protobuf::SingularPtrField<HostedURL>,
    pub text_info: ::protobuf::SingularPtrField<TextInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Text {
    fn default() -> &'a Text {
        <Text as ::protobuf::Message>::default_instance()
    }
}

impl Text {
    pub fn new() -> Text {
        ::std::default::Default::default()
    }

    // string raw = 1;


    pub fn get_raw(&self) -> &str {
        &self.raw
    }
    pub fn clear_raw(&mut self) {
        self.raw.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw(&mut self, v: ::std::string::String) {
        self.raw = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw(&mut self) -> &mut ::std::string::String {
        &mut self.raw
    }

    // Take field
    pub fn take_raw(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.raw, ::std::string::String::new())
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // bool allow_duplicate_url = 3;


    pub fn get_allow_duplicate_url(&self) -> bool {
        self.allow_duplicate_url
    }
    pub fn clear_allow_duplicate_url(&mut self) {
        self.allow_duplicate_url = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_duplicate_url(&mut self, v: bool) {
        self.allow_duplicate_url = v;
    }

    // .clarifai.api.HostedURL hosted = 4;


    pub fn get_hosted(&self) -> &HostedURL {
        self.hosted.as_ref().unwrap_or_else(|| <HostedURL as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hosted(&mut self) {
        self.hosted.clear();
    }

    pub fn has_hosted(&self) -> bool {
        self.hosted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hosted(&mut self, v: HostedURL) {
        self.hosted = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hosted(&mut self) -> &mut HostedURL {
        if self.hosted.is_none() {
            self.hosted.set_default();
        }
        self.hosted.as_mut().unwrap()
    }

    // Take field
    pub fn take_hosted(&mut self) -> HostedURL {
        self.hosted.take().unwrap_or_else(|| HostedURL::new())
    }

    // .clarifai.api.TextInfo text_info = 5;


    pub fn get_text_info(&self) -> &TextInfo {
        self.text_info.as_ref().unwrap_or_else(|| <TextInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_text_info(&mut self) {
        self.text_info.clear();
    }

    pub fn has_text_info(&self) -> bool {
        self.text_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_info(&mut self, v: TextInfo) {
        self.text_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text_info(&mut self) -> &mut TextInfo {
        if self.text_info.is_none() {
            self.text_info.set_default();
        }
        self.text_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_text_info(&mut self) -> TextInfo {
        self.text_info.take().unwrap_or_else(|| TextInfo::new())
    }
}

impl ::protobuf::Message for Text {
    fn is_initialized(&self) -> bool {
        for v in &self.hosted {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.raw)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_duplicate_url = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hosted)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.raw.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.raw);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if self.allow_duplicate_url != false {
            my_size += 2;
        }
        if let Some(ref v) = self.hosted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.text_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.raw.is_empty() {
            os.write_string(1, &self.raw)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if self.allow_duplicate_url != false {
            os.write_bool(3, self.allow_duplicate_url)?;
        }
        if let Some(ref v) = self.hosted.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.text_info.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Text {
        Text::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "raw",
                |m: &Text| { &m.raw },
                |m: &mut Text| { &mut m.raw },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Text| { &m.url },
                |m: &mut Text| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_duplicate_url",
                |m: &Text| { &m.allow_duplicate_url },
                |m: &mut Text| { &mut m.allow_duplicate_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostedURL>>(
                "hosted",
                |m: &Text| { &m.hosted },
                |m: &mut Text| { &mut m.hosted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TextInfo>>(
                "text_info",
                |m: &Text| { &m.text_info },
                |m: &mut Text| { &mut m.text_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Text>(
                "Text",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Text {
        static instance: ::protobuf::rt::LazyV2<Text> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Text::new)
    }
}

impl ::protobuf::Clear for Text {
    fn clear(&mut self) {
        self.raw.clear();
        self.url.clear();
        self.allow_duplicate_url = false;
        self.hosted.clear();
        self.text_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Text {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Text {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextInfo {
    // message fields
    pub char_count: i32,
    pub encoding: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextInfo {
    fn default() -> &'a TextInfo {
        <TextInfo as ::protobuf::Message>::default_instance()
    }
}

impl TextInfo {
    pub fn new() -> TextInfo {
        ::std::default::Default::default()
    }

    // int32 char_count = 1;


    pub fn get_char_count(&self) -> i32 {
        self.char_count
    }
    pub fn clear_char_count(&mut self) {
        self.char_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_char_count(&mut self, v: i32) {
        self.char_count = v;
    }

    // string encoding = 2;


    pub fn get_encoding(&self) -> &str {
        &self.encoding
    }
    pub fn clear_encoding(&mut self) {
        self.encoding.clear();
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: ::std::string::String) {
        self.encoding = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoding(&mut self) -> &mut ::std::string::String {
        &mut self.encoding
    }

    // Take field
    pub fn take_encoding(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.encoding, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TextInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.char_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.encoding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.char_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.char_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.encoding.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.encoding);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.char_count != 0 {
            os.write_int32(1, self.char_count)?;
        }
        if !self.encoding.is_empty() {
            os.write_string(2, &self.encoding)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextInfo {
        TextInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "char_count",
                |m: &TextInfo| { &m.char_count },
                |m: &mut TextInfo| { &mut m.char_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encoding",
                |m: &TextInfo| { &m.encoding },
                |m: &mut TextInfo| { &mut m.encoding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TextInfo>(
                "TextInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TextInfo {
        static instance: ::protobuf::rt::LazyV2<TextInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TextInfo::new)
    }
}

impl ::protobuf::Clear for TextInfo {
    fn clear(&mut self) {
        self.char_count = 0;
        self.encoding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User {
    // message fields
    pub id: ::std::string::String,
    pub primary_email: ::std::string::String,
    pub first_name: ::std::string::String,
    pub last_name: ::std::string::String,
    pub company_name: ::std::string::String,
    pub job_title: ::std::string::String,
    pub job_role: ::std::string::String,
    pub bill_type: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub date_gdpr_consent: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub date_tos_consent: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub date_marketing_consent: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub email_addresses: ::protobuf::RepeatedField<EmailAddress>,
    pub is_org_admin: bool,
    pub two_factor_auth_enabled: bool,
    pub teams_count: u32,
    pub is_starred: bool,
    pub star_count: i32,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub user_detail: ::protobuf::SingularPtrField<UserDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a User {
    fn default() -> &'a User {
        <User as ::protobuf::Message>::default_instance()
    }
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string primary_email = 2;


    pub fn get_primary_email(&self) -> &str {
        &self.primary_email
    }
    pub fn clear_primary_email(&mut self) {
        self.primary_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_email(&mut self, v: ::std::string::String) {
        self.primary_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_email(&mut self) -> &mut ::std::string::String {
        &mut self.primary_email
    }

    // Take field
    pub fn take_primary_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.primary_email, ::std::string::String::new())
    }

    // string first_name = 3;


    pub fn get_first_name(&self) -> &str {
        &self.first_name
    }
    pub fn clear_first_name(&mut self) {
        self.first_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_first_name(&mut self, v: ::std::string::String) {
        self.first_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_name(&mut self) -> &mut ::std::string::String {
        &mut self.first_name
    }

    // Take field
    pub fn take_first_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.first_name, ::std::string::String::new())
    }

    // string last_name = 4;


    pub fn get_last_name(&self) -> &str {
        &self.last_name
    }
    pub fn clear_last_name(&mut self) {
        self.last_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_name(&mut self, v: ::std::string::String) {
        self.last_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_name(&mut self) -> &mut ::std::string::String {
        &mut self.last_name
    }

    // Take field
    pub fn take_last_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_name, ::std::string::String::new())
    }

    // string company_name = 5;


    pub fn get_company_name(&self) -> &str {
        &self.company_name
    }
    pub fn clear_company_name(&mut self) {
        self.company_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_company_name(&mut self, v: ::std::string::String) {
        self.company_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_company_name(&mut self) -> &mut ::std::string::String {
        &mut self.company_name
    }

    // Take field
    pub fn take_company_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.company_name, ::std::string::String::new())
    }

    // string job_title = 19;


    pub fn get_job_title(&self) -> &str {
        &self.job_title
    }
    pub fn clear_job_title(&mut self) {
        self.job_title.clear();
    }

    // Param is passed by value, moved
    pub fn set_job_title(&mut self, v: ::std::string::String) {
        self.job_title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job_title(&mut self) -> &mut ::std::string::String {
        &mut self.job_title
    }

    // Take field
    pub fn take_job_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.job_title, ::std::string::String::new())
    }

    // string job_role = 20;


    pub fn get_job_role(&self) -> &str {
        &self.job_role
    }
    pub fn clear_job_role(&mut self) {
        self.job_role.clear();
    }

    // Param is passed by value, moved
    pub fn set_job_role(&mut self, v: ::std::string::String) {
        self.job_role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job_role(&mut self) -> &mut ::std::string::String {
        &mut self.job_role
    }

    // Take field
    pub fn take_job_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.job_role, ::std::string::String::new())
    }

    // string bill_type = 7;


    pub fn get_bill_type(&self) -> &str {
        &self.bill_type
    }
    pub fn clear_bill_type(&mut self) {
        self.bill_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_bill_type(&mut self, v: ::std::string::String) {
        self.bill_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bill_type(&mut self) -> &mut ::std::string::String {
        &mut self.bill_type
    }

    // Take field
    pub fn take_bill_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bill_type, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 6;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp date_gdpr_consent = 8;


    pub fn get_date_gdpr_consent(&self) -> &::protobuf::well_known_types::Timestamp {
        self.date_gdpr_consent.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_date_gdpr_consent(&mut self) {
        self.date_gdpr_consent.clear();
    }

    pub fn has_date_gdpr_consent(&self) -> bool {
        self.date_gdpr_consent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_gdpr_consent(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.date_gdpr_consent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date_gdpr_consent(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.date_gdpr_consent.is_none() {
            self.date_gdpr_consent.set_default();
        }
        self.date_gdpr_consent.as_mut().unwrap()
    }

    // Take field
    pub fn take_date_gdpr_consent(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.date_gdpr_consent.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp date_tos_consent = 9;


    pub fn get_date_tos_consent(&self) -> &::protobuf::well_known_types::Timestamp {
        self.date_tos_consent.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_date_tos_consent(&mut self) {
        self.date_tos_consent.clear();
    }

    pub fn has_date_tos_consent(&self) -> bool {
        self.date_tos_consent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_tos_consent(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.date_tos_consent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date_tos_consent(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.date_tos_consent.is_none() {
            self.date_tos_consent.set_default();
        }
        self.date_tos_consent.as_mut().unwrap()
    }

    // Take field
    pub fn take_date_tos_consent(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.date_tos_consent.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp date_marketing_consent = 10;


    pub fn get_date_marketing_consent(&self) -> &::protobuf::well_known_types::Timestamp {
        self.date_marketing_consent.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_date_marketing_consent(&mut self) {
        self.date_marketing_consent.clear();
    }

    pub fn has_date_marketing_consent(&self) -> bool {
        self.date_marketing_consent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_marketing_consent(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.date_marketing_consent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date_marketing_consent(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.date_marketing_consent.is_none() {
            self.date_marketing_consent.set_default();
        }
        self.date_marketing_consent.as_mut().unwrap()
    }

    // Take field
    pub fn take_date_marketing_consent(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.date_marketing_consent.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Struct metadata = 11;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // repeated .clarifai.api.EmailAddress email_addresses = 12;


    pub fn get_email_addresses(&self) -> &[EmailAddress] {
        &self.email_addresses
    }
    pub fn clear_email_addresses(&mut self) {
        self.email_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_addresses(&mut self, v: ::protobuf::RepeatedField<EmailAddress>) {
        self.email_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_email_addresses(&mut self) -> &mut ::protobuf::RepeatedField<EmailAddress> {
        &mut self.email_addresses
    }

    // Take field
    pub fn take_email_addresses(&mut self) -> ::protobuf::RepeatedField<EmailAddress> {
        ::std::mem::replace(&mut self.email_addresses, ::protobuf::RepeatedField::new())
    }

    // bool is_org_admin = 14;


    pub fn get_is_org_admin(&self) -> bool {
        self.is_org_admin
    }
    pub fn clear_is_org_admin(&mut self) {
        self.is_org_admin = false;
    }

    // Param is passed by value, moved
    pub fn set_is_org_admin(&mut self, v: bool) {
        self.is_org_admin = v;
    }

    // bool two_factor_auth_enabled = 15;


    pub fn get_two_factor_auth_enabled(&self) -> bool {
        self.two_factor_auth_enabled
    }
    pub fn clear_two_factor_auth_enabled(&mut self) {
        self.two_factor_auth_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_two_factor_auth_enabled(&mut self, v: bool) {
        self.two_factor_auth_enabled = v;
    }

    // uint32 teams_count = 16;


    pub fn get_teams_count(&self) -> u32 {
        self.teams_count
    }
    pub fn clear_teams_count(&mut self) {
        self.teams_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_teams_count(&mut self, v: u32) {
        self.teams_count = v;
    }

    // bool is_starred = 21;


    pub fn get_is_starred(&self) -> bool {
        self.is_starred
    }
    pub fn clear_is_starred(&mut self) {
        self.is_starred = false;
    }

    // Param is passed by value, moved
    pub fn set_is_starred(&mut self, v: bool) {
        self.is_starred = v;
    }

    // int32 star_count = 22;


    pub fn get_star_count(&self) -> i32 {
        self.star_count
    }
    pub fn clear_star_count(&mut self) {
        self.star_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_star_count(&mut self, v: i32) {
        self.star_count = v;
    }

    // .clarifai.api.Visibility visibility = 17;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // .clarifai.api.UserDetail user_detail = 18;


    pub fn get_user_detail(&self) -> &UserDetail {
        self.user_detail.as_ref().unwrap_or_else(|| <UserDetail as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_detail(&mut self) {
        self.user_detail.clear();
    }

    pub fn has_user_detail(&self) -> bool {
        self.user_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_detail(&mut self, v: UserDetail) {
        self.user_detail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_detail(&mut self) -> &mut UserDetail {
        if self.user_detail.is_none() {
            self.user_detail.set_default();
        }
        self.user_detail.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_detail(&mut self) -> UserDetail {
        self.user_detail.take().unwrap_or_else(|| UserDetail::new())
    }
}

impl ::protobuf::Message for User {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.date_gdpr_consent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.date_tos_consent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.date_marketing_consent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.email_addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.primary_email)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.first_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.last_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.company_name)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.job_title)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.job_role)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bill_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.date_gdpr_consent)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.date_tos_consent)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.date_marketing_consent)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.email_addresses)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_org_admin = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.two_factor_auth_enabled = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teams_count = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_starred = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.star_count = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_detail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.primary_email.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.primary_email);
        }
        if !self.first_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.first_name);
        }
        if !self.last_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.last_name);
        }
        if !self.company_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.company_name);
        }
        if !self.job_title.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.job_title);
        }
        if !self.job_role.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.job_role);
        }
        if !self.bill_type.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.bill_type);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.date_gdpr_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.date_tos_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.date_marketing_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.email_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.is_org_admin != false {
            my_size += 2;
        }
        if self.two_factor_auth_enabled != false {
            my_size += 2;
        }
        if self.teams_count != 0 {
            my_size += ::protobuf::rt::value_size(16, self.teams_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_starred != false {
            my_size += 3;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::value_size(22, self.star_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_detail.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.primary_email.is_empty() {
            os.write_string(2, &self.primary_email)?;
        }
        if !self.first_name.is_empty() {
            os.write_string(3, &self.first_name)?;
        }
        if !self.last_name.is_empty() {
            os.write_string(4, &self.last_name)?;
        }
        if !self.company_name.is_empty() {
            os.write_string(5, &self.company_name)?;
        }
        if !self.job_title.is_empty() {
            os.write_string(19, &self.job_title)?;
        }
        if !self.job_role.is_empty() {
            os.write_string(20, &self.job_role)?;
        }
        if !self.bill_type.is_empty() {
            os.write_string(7, &self.bill_type)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.date_gdpr_consent.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.date_tos_consent.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.date_marketing_consent.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.email_addresses {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.is_org_admin != false {
            os.write_bool(14, self.is_org_admin)?;
        }
        if self.two_factor_auth_enabled != false {
            os.write_bool(15, self.two_factor_auth_enabled)?;
        }
        if self.teams_count != 0 {
            os.write_uint32(16, self.teams_count)?;
        }
        if self.is_starred != false {
            os.write_bool(21, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(22, self.star_count)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_detail.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User {
        User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &User| { &m.id },
                |m: &mut User| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "primary_email",
                |m: &User| { &m.primary_email },
                |m: &mut User| { &mut m.primary_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "first_name",
                |m: &User| { &m.first_name },
                |m: &mut User| { &mut m.first_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_name",
                |m: &User| { &m.last_name },
                |m: &mut User| { &mut m.last_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "company_name",
                |m: &User| { &m.company_name },
                |m: &mut User| { &mut m.company_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "job_title",
                |m: &User| { &m.job_title },
                |m: &mut User| { &mut m.job_title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "job_role",
                |m: &User| { &m.job_role },
                |m: &mut User| { &mut m.job_role },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bill_type",
                |m: &User| { &m.bill_type },
                |m: &mut User| { &mut m.bill_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &User| { &m.created_at },
                |m: &mut User| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "date_gdpr_consent",
                |m: &User| { &m.date_gdpr_consent },
                |m: &mut User| { &mut m.date_gdpr_consent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "date_tos_consent",
                |m: &User| { &m.date_tos_consent },
                |m: &mut User| { &mut m.date_tos_consent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "date_marketing_consent",
                |m: &User| { &m.date_marketing_consent },
                |m: &mut User| { &mut m.date_marketing_consent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &User| { &m.metadata },
                |m: &mut User| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EmailAddress>>(
                "email_addresses",
                |m: &User| { &m.email_addresses },
                |m: &mut User| { &mut m.email_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_org_admin",
                |m: &User| { &m.is_org_admin },
                |m: &mut User| { &mut m.is_org_admin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "two_factor_auth_enabled",
                |m: &User| { &m.two_factor_auth_enabled },
                |m: &mut User| { &mut m.two_factor_auth_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "teams_count",
                |m: &User| { &m.teams_count },
                |m: &mut User| { &mut m.teams_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_starred",
                |m: &User| { &m.is_starred },
                |m: &mut User| { &mut m.is_starred },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "star_count",
                |m: &User| { &m.star_count },
                |m: &mut User| { &mut m.star_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &User| { &m.visibility },
                |m: &mut User| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserDetail>>(
                "user_detail",
                |m: &User| { &m.user_detail },
                |m: &mut User| { &mut m.user_detail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<User>(
                "User",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static User {
        static instance: ::protobuf::rt::LazyV2<User> = ::protobuf::rt::LazyV2::INIT;
        instance.get(User::new)
    }
}

impl ::protobuf::Clear for User {
    fn clear(&mut self) {
        self.id.clear();
        self.primary_email.clear();
        self.first_name.clear();
        self.last_name.clear();
        self.company_name.clear();
        self.job_title.clear();
        self.job_role.clear();
        self.bill_type.clear();
        self.created_at.clear();
        self.date_gdpr_consent.clear();
        self.date_tos_consent.clear();
        self.date_marketing_consent.clear();
        self.metadata.clear();
        self.email_addresses.clear();
        self.is_org_admin = false;
        self.two_factor_auth_enabled = false;
        self.teams_count = 0;
        self.is_starred = false;
        self.star_count = 0;
        self.visibility.clear();
        self.user_detail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserDetail {
    // message fields
    pub primary_email: ::std::string::String,
    pub bill_type: ::std::string::String,
    pub date_gdpr_consent: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub date_tos_consent: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub date_marketing_consent: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub email_addresses: ::protobuf::RepeatedField<EmailAddress>,
    pub is_org_admin: bool,
    pub two_factor_auth_enabled: bool,
    pub teams_count: u32,
    pub country: ::std::string::String,
    pub state: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserDetail {
    fn default() -> &'a UserDetail {
        <UserDetail as ::protobuf::Message>::default_instance()
    }
}

impl UserDetail {
    pub fn new() -> UserDetail {
        ::std::default::Default::default()
    }

    // string primary_email = 1;


    pub fn get_primary_email(&self) -> &str {
        &self.primary_email
    }
    pub fn clear_primary_email(&mut self) {
        self.primary_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_email(&mut self, v: ::std::string::String) {
        self.primary_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_email(&mut self) -> &mut ::std::string::String {
        &mut self.primary_email
    }

    // Take field
    pub fn take_primary_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.primary_email, ::std::string::String::new())
    }

    // string bill_type = 2;


    pub fn get_bill_type(&self) -> &str {
        &self.bill_type
    }
    pub fn clear_bill_type(&mut self) {
        self.bill_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_bill_type(&mut self, v: ::std::string::String) {
        self.bill_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bill_type(&mut self) -> &mut ::std::string::String {
        &mut self.bill_type
    }

    // Take field
    pub fn take_bill_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bill_type, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp date_gdpr_consent = 3;


    pub fn get_date_gdpr_consent(&self) -> &::protobuf::well_known_types::Timestamp {
        self.date_gdpr_consent.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_date_gdpr_consent(&mut self) {
        self.date_gdpr_consent.clear();
    }

    pub fn has_date_gdpr_consent(&self) -> bool {
        self.date_gdpr_consent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_gdpr_consent(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.date_gdpr_consent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date_gdpr_consent(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.date_gdpr_consent.is_none() {
            self.date_gdpr_consent.set_default();
        }
        self.date_gdpr_consent.as_mut().unwrap()
    }

    // Take field
    pub fn take_date_gdpr_consent(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.date_gdpr_consent.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp date_tos_consent = 4;


    pub fn get_date_tos_consent(&self) -> &::protobuf::well_known_types::Timestamp {
        self.date_tos_consent.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_date_tos_consent(&mut self) {
        self.date_tos_consent.clear();
    }

    pub fn has_date_tos_consent(&self) -> bool {
        self.date_tos_consent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_tos_consent(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.date_tos_consent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date_tos_consent(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.date_tos_consent.is_none() {
            self.date_tos_consent.set_default();
        }
        self.date_tos_consent.as_mut().unwrap()
    }

    // Take field
    pub fn take_date_tos_consent(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.date_tos_consent.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp date_marketing_consent = 5;


    pub fn get_date_marketing_consent(&self) -> &::protobuf::well_known_types::Timestamp {
        self.date_marketing_consent.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_date_marketing_consent(&mut self) {
        self.date_marketing_consent.clear();
    }

    pub fn has_date_marketing_consent(&self) -> bool {
        self.date_marketing_consent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_marketing_consent(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.date_marketing_consent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date_marketing_consent(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.date_marketing_consent.is_none() {
            self.date_marketing_consent.set_default();
        }
        self.date_marketing_consent.as_mut().unwrap()
    }

    // Take field
    pub fn take_date_marketing_consent(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.date_marketing_consent.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Struct metadata = 6;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // repeated .clarifai.api.EmailAddress email_addresses = 7;


    pub fn get_email_addresses(&self) -> &[EmailAddress] {
        &self.email_addresses
    }
    pub fn clear_email_addresses(&mut self) {
        self.email_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_addresses(&mut self, v: ::protobuf::RepeatedField<EmailAddress>) {
        self.email_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_email_addresses(&mut self) -> &mut ::protobuf::RepeatedField<EmailAddress> {
        &mut self.email_addresses
    }

    // Take field
    pub fn take_email_addresses(&mut self) -> ::protobuf::RepeatedField<EmailAddress> {
        ::std::mem::replace(&mut self.email_addresses, ::protobuf::RepeatedField::new())
    }

    // bool is_org_admin = 8;


    pub fn get_is_org_admin(&self) -> bool {
        self.is_org_admin
    }
    pub fn clear_is_org_admin(&mut self) {
        self.is_org_admin = false;
    }

    // Param is passed by value, moved
    pub fn set_is_org_admin(&mut self, v: bool) {
        self.is_org_admin = v;
    }

    // bool two_factor_auth_enabled = 9;


    pub fn get_two_factor_auth_enabled(&self) -> bool {
        self.two_factor_auth_enabled
    }
    pub fn clear_two_factor_auth_enabled(&mut self) {
        self.two_factor_auth_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_two_factor_auth_enabled(&mut self, v: bool) {
        self.two_factor_auth_enabled = v;
    }

    // uint32 teams_count = 10;


    pub fn get_teams_count(&self) -> u32 {
        self.teams_count
    }
    pub fn clear_teams_count(&mut self) {
        self.teams_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_teams_count(&mut self, v: u32) {
        self.teams_count = v;
    }

    // string country = 11;


    pub fn get_country(&self) -> &str {
        &self.country
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        &mut self.country
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.country, ::std::string::String::new())
    }

    // string state = 12;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserDetail {
    fn is_initialized(&self) -> bool {
        for v in &self.date_gdpr_consent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.date_tos_consent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.date_marketing_consent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.email_addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.primary_email)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bill_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.date_gdpr_consent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.date_tos_consent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.date_marketing_consent)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.email_addresses)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_org_admin = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.two_factor_auth_enabled = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teams_count = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.country)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.primary_email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.primary_email);
        }
        if !self.bill_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bill_type);
        }
        if let Some(ref v) = self.date_gdpr_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.date_tos_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.date_marketing_consent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.email_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.is_org_admin != false {
            my_size += 2;
        }
        if self.two_factor_auth_enabled != false {
            my_size += 2;
        }
        if self.teams_count != 0 {
            my_size += ::protobuf::rt::value_size(10, self.teams_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.country.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.country);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.primary_email.is_empty() {
            os.write_string(1, &self.primary_email)?;
        }
        if !self.bill_type.is_empty() {
            os.write_string(2, &self.bill_type)?;
        }
        if let Some(ref v) = self.date_gdpr_consent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.date_tos_consent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.date_marketing_consent.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.email_addresses {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.is_org_admin != false {
            os.write_bool(8, self.is_org_admin)?;
        }
        if self.two_factor_auth_enabled != false {
            os.write_bool(9, self.two_factor_auth_enabled)?;
        }
        if self.teams_count != 0 {
            os.write_uint32(10, self.teams_count)?;
        }
        if !self.country.is_empty() {
            os.write_string(11, &self.country)?;
        }
        if !self.state.is_empty() {
            os.write_string(12, &self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserDetail {
        UserDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "primary_email",
                |m: &UserDetail| { &m.primary_email },
                |m: &mut UserDetail| { &mut m.primary_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bill_type",
                |m: &UserDetail| { &m.bill_type },
                |m: &mut UserDetail| { &mut m.bill_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "date_gdpr_consent",
                |m: &UserDetail| { &m.date_gdpr_consent },
                |m: &mut UserDetail| { &mut m.date_gdpr_consent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "date_tos_consent",
                |m: &UserDetail| { &m.date_tos_consent },
                |m: &mut UserDetail| { &mut m.date_tos_consent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "date_marketing_consent",
                |m: &UserDetail| { &m.date_marketing_consent },
                |m: &mut UserDetail| { &mut m.date_marketing_consent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &UserDetail| { &m.metadata },
                |m: &mut UserDetail| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EmailAddress>>(
                "email_addresses",
                |m: &UserDetail| { &m.email_addresses },
                |m: &mut UserDetail| { &mut m.email_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_org_admin",
                |m: &UserDetail| { &m.is_org_admin },
                |m: &mut UserDetail| { &mut m.is_org_admin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "two_factor_auth_enabled",
                |m: &UserDetail| { &m.two_factor_auth_enabled },
                |m: &mut UserDetail| { &mut m.two_factor_auth_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "teams_count",
                |m: &UserDetail| { &m.teams_count },
                |m: &mut UserDetail| { &mut m.teams_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &UserDetail| { &m.country },
                |m: &mut UserDetail| { &mut m.country },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &UserDetail| { &m.state },
                |m: &mut UserDetail| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserDetail>(
                "UserDetail",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserDetail {
        static instance: ::protobuf::rt::LazyV2<UserDetail> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserDetail::new)
    }
}

impl ::protobuf::Clear for UserDetail {
    fn clear(&mut self) {
        self.primary_email.clear();
        self.bill_type.clear();
        self.date_gdpr_consent.clear();
        self.date_tos_consent.clear();
        self.date_marketing_consent.clear();
        self.metadata.clear();
        self.email_addresses.clear();
        self.is_org_admin = false;
        self.two_factor_auth_enabled = false;
        self.teams_count = 0;
        self.country.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EmailAddress {
    // message fields
    pub email: ::std::string::String,
    pub primary: bool,
    pub verified: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmailAddress {
    fn default() -> &'a EmailAddress {
        <EmailAddress as ::protobuf::Message>::default_instance()
    }
}

impl EmailAddress {
    pub fn new() -> EmailAddress {
        ::std::default::Default::default()
    }

    // string email = 1;


    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    // bool primary = 2;


    pub fn get_primary(&self) -> bool {
        self.primary
    }
    pub fn clear_primary(&mut self) {
        self.primary = false;
    }

    // Param is passed by value, moved
    pub fn set_primary(&mut self, v: bool) {
        self.primary = v;
    }

    // bool verified = 3;


    pub fn get_verified(&self) -> bool {
        self.verified
    }
    pub fn clear_verified(&mut self) {
        self.verified = false;
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: bool) {
        self.verified = v;
    }
}

impl ::protobuf::Message for EmailAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.primary = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verified = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email);
        }
        if self.primary != false {
            my_size += 2;
        }
        if self.verified != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.email.is_empty() {
            os.write_string(1, &self.email)?;
        }
        if self.primary != false {
            os.write_bool(2, self.primary)?;
        }
        if self.verified != false {
            os.write_bool(3, self.verified)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmailAddress {
        EmailAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &EmailAddress| { &m.email },
                |m: &mut EmailAddress| { &mut m.email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "primary",
                |m: &EmailAddress| { &m.primary },
                |m: &mut EmailAddress| { &mut m.primary },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "verified",
                |m: &EmailAddress| { &m.verified },
                |m: &mut EmailAddress| { &mut m.verified },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmailAddress>(
                "EmailAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EmailAddress {
        static instance: ::protobuf::rt::LazyV2<EmailAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmailAddress::new)
    }
}

impl ::protobuf::Clear for EmailAddress {
    fn clear(&mut self) {
        self.email.clear();
        self.primary = false;
        self.verified = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmailAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmailAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Password {
    // message fields
    pub plaintext: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Password {
    fn default() -> &'a Password {
        <Password as ::protobuf::Message>::default_instance()
    }
}

impl Password {
    pub fn new() -> Password {
        ::std::default::Default::default()
    }

    // string plaintext = 1;


    pub fn get_plaintext(&self) -> &str {
        &self.plaintext
    }
    pub fn clear_plaintext(&mut self) {
        self.plaintext.clear();
    }

    // Param is passed by value, moved
    pub fn set_plaintext(&mut self, v: ::std::string::String) {
        self.plaintext = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plaintext(&mut self) -> &mut ::std::string::String {
        &mut self.plaintext
    }

    // Take field
    pub fn take_plaintext(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.plaintext, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Password {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.plaintext)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.plaintext.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.plaintext);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.plaintext.is_empty() {
            os.write_string(1, &self.plaintext)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Password {
        Password::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "plaintext",
                |m: &Password| { &m.plaintext },
                |m: &mut Password| { &mut m.plaintext },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Password>(
                "Password",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Password {
        static instance: ::protobuf::rt::LazyV2<Password> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Password::new)
    }
}

impl ::protobuf::Clear for Password {
    fn clear(&mut self) {
        self.plaintext.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Password {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Password {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PasswordViolations {
    // message fields
    pub minimum_length: bool,
    pub maximum_length: bool,
    pub upper_case_needed: bool,
    pub lower_case_needed: bool,
    pub numeric_needed: bool,
    pub non_alphanumeric_needed: bool,
    pub password_reuse: bool,
    pub exclude_names: bool,
    pub exclude_email: bool,
    pub no_confusing_letters: bool,
    pub no_simple_passwords: bool,
    pub no_common_vocabs: bool,
    pub no_overlap_with_old: bool,
    pub password_lifespan: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PasswordViolations {
    fn default() -> &'a PasswordViolations {
        <PasswordViolations as ::protobuf::Message>::default_instance()
    }
}

impl PasswordViolations {
    pub fn new() -> PasswordViolations {
        ::std::default::Default::default()
    }

    // bool minimum_length = 1;


    pub fn get_minimum_length(&self) -> bool {
        self.minimum_length
    }
    pub fn clear_minimum_length(&mut self) {
        self.minimum_length = false;
    }

    // Param is passed by value, moved
    pub fn set_minimum_length(&mut self, v: bool) {
        self.minimum_length = v;
    }

    // bool maximum_length = 2;


    pub fn get_maximum_length(&self) -> bool {
        self.maximum_length
    }
    pub fn clear_maximum_length(&mut self) {
        self.maximum_length = false;
    }

    // Param is passed by value, moved
    pub fn set_maximum_length(&mut self, v: bool) {
        self.maximum_length = v;
    }

    // bool upper_case_needed = 3;


    pub fn get_upper_case_needed(&self) -> bool {
        self.upper_case_needed
    }
    pub fn clear_upper_case_needed(&mut self) {
        self.upper_case_needed = false;
    }

    // Param is passed by value, moved
    pub fn set_upper_case_needed(&mut self, v: bool) {
        self.upper_case_needed = v;
    }

    // bool lower_case_needed = 4;


    pub fn get_lower_case_needed(&self) -> bool {
        self.lower_case_needed
    }
    pub fn clear_lower_case_needed(&mut self) {
        self.lower_case_needed = false;
    }

    // Param is passed by value, moved
    pub fn set_lower_case_needed(&mut self, v: bool) {
        self.lower_case_needed = v;
    }

    // bool numeric_needed = 5;


    pub fn get_numeric_needed(&self) -> bool {
        self.numeric_needed
    }
    pub fn clear_numeric_needed(&mut self) {
        self.numeric_needed = false;
    }

    // Param is passed by value, moved
    pub fn set_numeric_needed(&mut self, v: bool) {
        self.numeric_needed = v;
    }

    // bool non_alphanumeric_needed = 6;


    pub fn get_non_alphanumeric_needed(&self) -> bool {
        self.non_alphanumeric_needed
    }
    pub fn clear_non_alphanumeric_needed(&mut self) {
        self.non_alphanumeric_needed = false;
    }

    // Param is passed by value, moved
    pub fn set_non_alphanumeric_needed(&mut self, v: bool) {
        self.non_alphanumeric_needed = v;
    }

    // bool password_reuse = 7;


    pub fn get_password_reuse(&self) -> bool {
        self.password_reuse
    }
    pub fn clear_password_reuse(&mut self) {
        self.password_reuse = false;
    }

    // Param is passed by value, moved
    pub fn set_password_reuse(&mut self, v: bool) {
        self.password_reuse = v;
    }

    // bool exclude_names = 8;


    pub fn get_exclude_names(&self) -> bool {
        self.exclude_names
    }
    pub fn clear_exclude_names(&mut self) {
        self.exclude_names = false;
    }

    // Param is passed by value, moved
    pub fn set_exclude_names(&mut self, v: bool) {
        self.exclude_names = v;
    }

    // bool exclude_email = 9;


    pub fn get_exclude_email(&self) -> bool {
        self.exclude_email
    }
    pub fn clear_exclude_email(&mut self) {
        self.exclude_email = false;
    }

    // Param is passed by value, moved
    pub fn set_exclude_email(&mut self, v: bool) {
        self.exclude_email = v;
    }

    // bool no_confusing_letters = 10;


    pub fn get_no_confusing_letters(&self) -> bool {
        self.no_confusing_letters
    }
    pub fn clear_no_confusing_letters(&mut self) {
        self.no_confusing_letters = false;
    }

    // Param is passed by value, moved
    pub fn set_no_confusing_letters(&mut self, v: bool) {
        self.no_confusing_letters = v;
    }

    // bool no_simple_passwords = 11;


    pub fn get_no_simple_passwords(&self) -> bool {
        self.no_simple_passwords
    }
    pub fn clear_no_simple_passwords(&mut self) {
        self.no_simple_passwords = false;
    }

    // Param is passed by value, moved
    pub fn set_no_simple_passwords(&mut self, v: bool) {
        self.no_simple_passwords = v;
    }

    // bool no_common_vocabs = 12;


    pub fn get_no_common_vocabs(&self) -> bool {
        self.no_common_vocabs
    }
    pub fn clear_no_common_vocabs(&mut self) {
        self.no_common_vocabs = false;
    }

    // Param is passed by value, moved
    pub fn set_no_common_vocabs(&mut self, v: bool) {
        self.no_common_vocabs = v;
    }

    // bool no_overlap_with_old = 13;


    pub fn get_no_overlap_with_old(&self) -> bool {
        self.no_overlap_with_old
    }
    pub fn clear_no_overlap_with_old(&mut self) {
        self.no_overlap_with_old = false;
    }

    // Param is passed by value, moved
    pub fn set_no_overlap_with_old(&mut self, v: bool) {
        self.no_overlap_with_old = v;
    }

    // bool password_lifespan = 14;


    pub fn get_password_lifespan(&self) -> bool {
        self.password_lifespan
    }
    pub fn clear_password_lifespan(&mut self) {
        self.password_lifespan = false;
    }

    // Param is passed by value, moved
    pub fn set_password_lifespan(&mut self, v: bool) {
        self.password_lifespan = v;
    }
}

impl ::protobuf::Message for PasswordViolations {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.minimum_length = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.maximum_length = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.upper_case_needed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lower_case_needed = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.numeric_needed = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.non_alphanumeric_needed = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.password_reuse = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exclude_names = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exclude_email = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_confusing_letters = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_simple_passwords = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_common_vocabs = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_overlap_with_old = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.password_lifespan = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.minimum_length != false {
            my_size += 2;
        }
        if self.maximum_length != false {
            my_size += 2;
        }
        if self.upper_case_needed != false {
            my_size += 2;
        }
        if self.lower_case_needed != false {
            my_size += 2;
        }
        if self.numeric_needed != false {
            my_size += 2;
        }
        if self.non_alphanumeric_needed != false {
            my_size += 2;
        }
        if self.password_reuse != false {
            my_size += 2;
        }
        if self.exclude_names != false {
            my_size += 2;
        }
        if self.exclude_email != false {
            my_size += 2;
        }
        if self.no_confusing_letters != false {
            my_size += 2;
        }
        if self.no_simple_passwords != false {
            my_size += 2;
        }
        if self.no_common_vocabs != false {
            my_size += 2;
        }
        if self.no_overlap_with_old != false {
            my_size += 2;
        }
        if self.password_lifespan != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.minimum_length != false {
            os.write_bool(1, self.minimum_length)?;
        }
        if self.maximum_length != false {
            os.write_bool(2, self.maximum_length)?;
        }
        if self.upper_case_needed != false {
            os.write_bool(3, self.upper_case_needed)?;
        }
        if self.lower_case_needed != false {
            os.write_bool(4, self.lower_case_needed)?;
        }
        if self.numeric_needed != false {
            os.write_bool(5, self.numeric_needed)?;
        }
        if self.non_alphanumeric_needed != false {
            os.write_bool(6, self.non_alphanumeric_needed)?;
        }
        if self.password_reuse != false {
            os.write_bool(7, self.password_reuse)?;
        }
        if self.exclude_names != false {
            os.write_bool(8, self.exclude_names)?;
        }
        if self.exclude_email != false {
            os.write_bool(9, self.exclude_email)?;
        }
        if self.no_confusing_letters != false {
            os.write_bool(10, self.no_confusing_letters)?;
        }
        if self.no_simple_passwords != false {
            os.write_bool(11, self.no_simple_passwords)?;
        }
        if self.no_common_vocabs != false {
            os.write_bool(12, self.no_common_vocabs)?;
        }
        if self.no_overlap_with_old != false {
            os.write_bool(13, self.no_overlap_with_old)?;
        }
        if self.password_lifespan != false {
            os.write_bool(14, self.password_lifespan)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PasswordViolations {
        PasswordViolations::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "minimum_length",
                |m: &PasswordViolations| { &m.minimum_length },
                |m: &mut PasswordViolations| { &mut m.minimum_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "maximum_length",
                |m: &PasswordViolations| { &m.maximum_length },
                |m: &mut PasswordViolations| { &mut m.maximum_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "upper_case_needed",
                |m: &PasswordViolations| { &m.upper_case_needed },
                |m: &mut PasswordViolations| { &mut m.upper_case_needed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lower_case_needed",
                |m: &PasswordViolations| { &m.lower_case_needed },
                |m: &mut PasswordViolations| { &mut m.lower_case_needed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "numeric_needed",
                |m: &PasswordViolations| { &m.numeric_needed },
                |m: &mut PasswordViolations| { &mut m.numeric_needed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "non_alphanumeric_needed",
                |m: &PasswordViolations| { &m.non_alphanumeric_needed },
                |m: &mut PasswordViolations| { &mut m.non_alphanumeric_needed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "password_reuse",
                |m: &PasswordViolations| { &m.password_reuse },
                |m: &mut PasswordViolations| { &mut m.password_reuse },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "exclude_names",
                |m: &PasswordViolations| { &m.exclude_names },
                |m: &mut PasswordViolations| { &mut m.exclude_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "exclude_email",
                |m: &PasswordViolations| { &m.exclude_email },
                |m: &mut PasswordViolations| { &mut m.exclude_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_confusing_letters",
                |m: &PasswordViolations| { &m.no_confusing_letters },
                |m: &mut PasswordViolations| { &mut m.no_confusing_letters },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_simple_passwords",
                |m: &PasswordViolations| { &m.no_simple_passwords },
                |m: &mut PasswordViolations| { &mut m.no_simple_passwords },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_common_vocabs",
                |m: &PasswordViolations| { &m.no_common_vocabs },
                |m: &mut PasswordViolations| { &mut m.no_common_vocabs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_overlap_with_old",
                |m: &PasswordViolations| { &m.no_overlap_with_old },
                |m: &mut PasswordViolations| { &mut m.no_overlap_with_old },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "password_lifespan",
                |m: &PasswordViolations| { &m.password_lifespan },
                |m: &mut PasswordViolations| { &mut m.password_lifespan },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PasswordViolations>(
                "PasswordViolations",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PasswordViolations {
        static instance: ::protobuf::rt::LazyV2<PasswordViolations> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PasswordViolations::new)
    }
}

impl ::protobuf::Clear for PasswordViolations {
    fn clear(&mut self) {
        self.minimum_length = false;
        self.maximum_length = false;
        self.upper_case_needed = false;
        self.lower_case_needed = false;
        self.numeric_needed = false;
        self.non_alphanumeric_needed = false;
        self.password_reuse = false;
        self.exclude_names = false;
        self.exclude_email = false;
        self.no_confusing_letters = false;
        self.no_simple_passwords = false;
        self.no_common_vocabs = false;
        self.no_overlap_with_old = false;
        self.password_lifespan = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PasswordViolations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PasswordViolations {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Video {
    // message fields
    pub url: ::std::string::String,
    pub base64: ::std::vec::Vec<u8>,
    pub allow_duplicate_url: bool,
    pub thumbnail_url: ::std::string::String,
    pub hosted: ::protobuf::SingularPtrField<HostedURL>,
    pub video_info: ::protobuf::SingularPtrField<VideoInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Video {
    fn default() -> &'a Video {
        <Video as ::protobuf::Message>::default_instance()
    }
}

impl Video {
    pub fn new() -> Video {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // bytes base64 = 2;


    pub fn get_base64(&self) -> &[u8] {
        &self.base64
    }
    pub fn clear_base64(&mut self) {
        self.base64.clear();
    }

    // Param is passed by value, moved
    pub fn set_base64(&mut self, v: ::std::vec::Vec<u8>) {
        self.base64 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base64(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.base64
    }

    // Take field
    pub fn take_base64(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.base64, ::std::vec::Vec::new())
    }

    // bool allow_duplicate_url = 4;


    pub fn get_allow_duplicate_url(&self) -> bool {
        self.allow_duplicate_url
    }
    pub fn clear_allow_duplicate_url(&mut self) {
        self.allow_duplicate_url = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_duplicate_url(&mut self, v: bool) {
        self.allow_duplicate_url = v;
    }

    // string thumbnail_url = 5;


    pub fn get_thumbnail_url(&self) -> &str {
        &self.thumbnail_url
    }
    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        &mut self.thumbnail_url
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.thumbnail_url, ::std::string::String::new())
    }

    // .clarifai.api.HostedURL hosted = 6;


    pub fn get_hosted(&self) -> &HostedURL {
        self.hosted.as_ref().unwrap_or_else(|| <HostedURL as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hosted(&mut self) {
        self.hosted.clear();
    }

    pub fn has_hosted(&self) -> bool {
        self.hosted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hosted(&mut self, v: HostedURL) {
        self.hosted = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hosted(&mut self) -> &mut HostedURL {
        if self.hosted.is_none() {
            self.hosted.set_default();
        }
        self.hosted.as_mut().unwrap()
    }

    // Take field
    pub fn take_hosted(&mut self) -> HostedURL {
        self.hosted.take().unwrap_or_else(|| HostedURL::new())
    }

    // .clarifai.api.VideoInfo video_info = 7;


    pub fn get_video_info(&self) -> &VideoInfo {
        self.video_info.as_ref().unwrap_or_else(|| <VideoInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_video_info(&mut self) {
        self.video_info.clear();
    }

    pub fn has_video_info(&self) -> bool {
        self.video_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_info(&mut self, v: VideoInfo) {
        self.video_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_info(&mut self) -> &mut VideoInfo {
        if self.video_info.is_none() {
            self.video_info.set_default();
        }
        self.video_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_info(&mut self) -> VideoInfo {
        self.video_info.take().unwrap_or_else(|| VideoInfo::new())
    }
}

impl ::protobuf::Message for Video {
    fn is_initialized(&self) -> bool {
        for v in &self.hosted {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.video_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.base64)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_duplicate_url = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.thumbnail_url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hosted)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.video_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.base64.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.base64);
        }
        if self.allow_duplicate_url != false {
            my_size += 2;
        }
        if !self.thumbnail_url.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.thumbnail_url);
        }
        if let Some(ref v) = self.hosted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.video_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.base64.is_empty() {
            os.write_bytes(2, &self.base64)?;
        }
        if self.allow_duplicate_url != false {
            os.write_bool(4, self.allow_duplicate_url)?;
        }
        if !self.thumbnail_url.is_empty() {
            os.write_string(5, &self.thumbnail_url)?;
        }
        if let Some(ref v) = self.hosted.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.video_info.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Video {
        Video::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Video| { &m.url },
                |m: &mut Video| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "base64",
                |m: &Video| { &m.base64 },
                |m: &mut Video| { &mut m.base64 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_duplicate_url",
                |m: &Video| { &m.allow_duplicate_url },
                |m: &mut Video| { &mut m.allow_duplicate_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnail_url",
                |m: &Video| { &m.thumbnail_url },
                |m: &mut Video| { &mut m.thumbnail_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostedURL>>(
                "hosted",
                |m: &Video| { &m.hosted },
                |m: &mut Video| { &mut m.hosted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoInfo>>(
                "video_info",
                |m: &Video| { &m.video_info },
                |m: &mut Video| { &mut m.video_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Video>(
                "Video",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Video {
        static instance: ::protobuf::rt::LazyV2<Video> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Video::new)
    }
}

impl ::protobuf::Clear for Video {
    fn clear(&mut self) {
        self.url.clear();
        self.base64.clear();
        self.allow_duplicate_url = false;
        self.thumbnail_url.clear();
        self.hosted.clear();
        self.video_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Video {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Video {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VideoInfo {
    // message fields
    pub width: i32,
    pub height: i32,
    pub fps: f32,
    pub video_format: ::std::string::String,
    pub bit_rate: i32,
    pub frame_count: i32,
    pub duration_seconds: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoInfo {
    fn default() -> &'a VideoInfo {
        <VideoInfo as ::protobuf::Message>::default_instance()
    }
}

impl VideoInfo {
    pub fn new() -> VideoInfo {
        ::std::default::Default::default()
    }

    // int32 width = 1;


    pub fn get_width(&self) -> i32 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = v;
    }

    // int32 height = 2;


    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // float fps = 3;


    pub fn get_fps(&self) -> f32 {
        self.fps
    }
    pub fn clear_fps(&mut self) {
        self.fps = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fps(&mut self, v: f32) {
        self.fps = v;
    }

    // string video_format = 4;


    pub fn get_video_format(&self) -> &str {
        &self.video_format
    }
    pub fn clear_video_format(&mut self) {
        self.video_format.clear();
    }

    // Param is passed by value, moved
    pub fn set_video_format(&mut self, v: ::std::string::String) {
        self.video_format = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_format(&mut self) -> &mut ::std::string::String {
        &mut self.video_format
    }

    // Take field
    pub fn take_video_format(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.video_format, ::std::string::String::new())
    }

    // int32 bit_rate = 5;


    pub fn get_bit_rate(&self) -> i32 {
        self.bit_rate
    }
    pub fn clear_bit_rate(&mut self) {
        self.bit_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_bit_rate(&mut self, v: i32) {
        self.bit_rate = v;
    }

    // int32 frame_count = 6;


    pub fn get_frame_count(&self) -> i32 {
        self.frame_count
    }
    pub fn clear_frame_count(&mut self) {
        self.frame_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_frame_count(&mut self, v: i32) {
        self.frame_count = v;
    }

    // float duration_seconds = 7;


    pub fn get_duration_seconds(&self) -> f32 {
        self.duration_seconds
    }
    pub fn clear_duration_seconds(&mut self) {
        self.duration_seconds = 0.;
    }

    // Param is passed by value, moved
    pub fn set_duration_seconds(&mut self, v: f32) {
        self.duration_seconds = v;
    }
}

impl ::protobuf::Message for VideoInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fps = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.video_format)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bit_rate = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.frame_count = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration_seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(1, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fps != 0. {
            my_size += 5;
        }
        if !self.video_format.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.video_format);
        }
        if self.bit_rate != 0 {
            my_size += ::protobuf::rt::value_size(5, self.bit_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frame_count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.frame_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.duration_seconds != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.width != 0 {
            os.write_int32(1, self.width)?;
        }
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        if self.fps != 0. {
            os.write_float(3, self.fps)?;
        }
        if !self.video_format.is_empty() {
            os.write_string(4, &self.video_format)?;
        }
        if self.bit_rate != 0 {
            os.write_int32(5, self.bit_rate)?;
        }
        if self.frame_count != 0 {
            os.write_int32(6, self.frame_count)?;
        }
        if self.duration_seconds != 0. {
            os.write_float(7, self.duration_seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoInfo {
        VideoInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &VideoInfo| { &m.width },
                |m: &mut VideoInfo| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &VideoInfo| { &m.height },
                |m: &mut VideoInfo| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fps",
                |m: &VideoInfo| { &m.fps },
                |m: &mut VideoInfo| { &mut m.fps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "video_format",
                |m: &VideoInfo| { &m.video_format },
                |m: &mut VideoInfo| { &mut m.video_format },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bit_rate",
                |m: &VideoInfo| { &m.bit_rate },
                |m: &mut VideoInfo| { &mut m.bit_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "frame_count",
                |m: &VideoInfo| { &m.frame_count },
                |m: &mut VideoInfo| { &mut m.frame_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "duration_seconds",
                |m: &VideoInfo| { &m.duration_seconds },
                |m: &mut VideoInfo| { &mut m.duration_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoInfo>(
                "VideoInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoInfo {
        static instance: ::protobuf::rt::LazyV2<VideoInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoInfo::new)
    }
}

impl ::protobuf::Clear for VideoInfo {
    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.fps = 0.;
        self.video_format.clear();
        self.bit_rate = 0;
        self.frame_count = 0;
        self.duration_seconds = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Workflow {
    // message fields
    pub id: ::std::string::String,
    pub app_id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub nodes: ::protobuf::RepeatedField<WorkflowNode>,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub user_id: ::std::string::String,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub version: ::protobuf::SingularPtrField<WorkflowVersion>,
    pub is_starred: bool,
    pub star_count: i32,
    pub description: ::std::string::String,
    pub notes: ::std::string::String,
    pub use_cases: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Workflow {
    fn default() -> &'a Workflow {
        <Workflow as ::protobuf::Message>::default_instance()
    }
}

impl Workflow {
    pub fn new() -> Workflow {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string app_id = 2;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 3;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated .clarifai.api.WorkflowNode nodes = 4;


    pub fn get_nodes(&self) -> &[WorkflowNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<WorkflowNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<WorkflowNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<WorkflowNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Struct metadata = 5;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .clarifai.api.Visibility visibility = 6;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // string user_id = 7;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp modified_at = 8;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .clarifai.api.WorkflowVersion version = 9;


    pub fn get_version(&self) -> &WorkflowVersion {
        self.version.as_ref().unwrap_or_else(|| <WorkflowVersion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: WorkflowVersion) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut WorkflowVersion {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> WorkflowVersion {
        self.version.take().unwrap_or_else(|| WorkflowVersion::new())
    }

    // bool is_starred = 10;


    pub fn get_is_starred(&self) -> bool {
        self.is_starred
    }
    pub fn clear_is_starred(&mut self) {
        self.is_starred = false;
    }

    // Param is passed by value, moved
    pub fn set_is_starred(&mut self, v: bool) {
        self.is_starred = v;
    }

    // int32 star_count = 11;


    pub fn get_star_count(&self) -> i32 {
        self.star_count
    }
    pub fn clear_star_count(&mut self) {
        self.star_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_star_count(&mut self, v: i32) {
        self.star_count = v;
    }

    // string description = 12;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string notes = 13;


    pub fn get_notes(&self) -> &str {
        &self.notes
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::std::string::String) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notes(&mut self) -> &mut ::std::string::String {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notes, ::std::string::String::new())
    }

    // repeated string use_cases = 14;


    pub fn get_use_cases(&self) -> &[::std::string::String] {
        &self.use_cases
    }
    pub fn clear_use_cases(&mut self) {
        self.use_cases.clear();
    }

    // Param is passed by value, moved
    pub fn set_use_cases(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.use_cases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_use_cases(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.use_cases
    }

    // Take field
    pub fn take_use_cases(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.use_cases, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Workflow {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_starred = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.star_count = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notes)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.use_cases)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.user_id);
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_starred != false {
            my_size += 2;
        }
        if self.star_count != 0 {
            my_size += ::protobuf::rt::value_size(11, self.star_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.description);
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.notes);
        }
        for value in &self.use_cases {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.nodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(7, &self.user_id)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_starred != false {
            os.write_bool(10, self.is_starred)?;
        }
        if self.star_count != 0 {
            os.write_int32(11, self.star_count)?;
        }
        if !self.description.is_empty() {
            os.write_string(12, &self.description)?;
        }
        if !self.notes.is_empty() {
            os.write_string(13, &self.notes)?;
        }
        for v in &self.use_cases {
            os.write_string(14, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Workflow {
        Workflow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Workflow| { &m.id },
                |m: &mut Workflow| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &Workflow| { &m.app_id },
                |m: &mut Workflow| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Workflow| { &m.created_at },
                |m: &mut Workflow| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorkflowNode>>(
                "nodes",
                |m: &Workflow| { &m.nodes },
                |m: &mut Workflow| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &Workflow| { &m.metadata },
                |m: &mut Workflow| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &Workflow| { &m.visibility },
                |m: &mut Workflow| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &Workflow| { &m.user_id },
                |m: &mut Workflow| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &Workflow| { &m.modified_at },
                |m: &mut Workflow| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorkflowVersion>>(
                "version",
                |m: &Workflow| { &m.version },
                |m: &mut Workflow| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_starred",
                |m: &Workflow| { &m.is_starred },
                |m: &mut Workflow| { &mut m.is_starred },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "star_count",
                |m: &Workflow| { &m.star_count },
                |m: &mut Workflow| { &mut m.star_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Workflow| { &m.description },
                |m: &mut Workflow| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notes",
                |m: &Workflow| { &m.notes },
                |m: &mut Workflow| { &mut m.notes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "use_cases",
                |m: &Workflow| { &m.use_cases },
                |m: &mut Workflow| { &mut m.use_cases },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Workflow>(
                "Workflow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Workflow {
        static instance: ::protobuf::rt::LazyV2<Workflow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Workflow::new)
    }
}

impl ::protobuf::Clear for Workflow {
    fn clear(&mut self) {
        self.id.clear();
        self.app_id.clear();
        self.created_at.clear();
        self.nodes.clear();
        self.metadata.clear();
        self.visibility.clear();
        self.user_id.clear();
        self.modified_at.clear();
        self.version.clear();
        self.is_starred = false;
        self.star_count = 0;
        self.description.clear();
        self.notes.clear();
        self.use_cases.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Workflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Workflow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkflowVersion {
    // message fields
    pub id: ::std::string::String,
    pub workflow_id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub nodes: ::protobuf::RepeatedField<WorkflowNode>,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub app_id: ::std::string::String,
    pub user_id: ::std::string::String,
    pub description: ::std::string::String,
    pub license: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorkflowVersion {
    fn default() -> &'a WorkflowVersion {
        <WorkflowVersion as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowVersion {
    pub fn new() -> WorkflowVersion {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 3;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 4;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .clarifai.api.Visibility visibility = 5;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // repeated .clarifai.api.WorkflowNode nodes = 6;


    pub fn get_nodes(&self) -> &[WorkflowNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<WorkflowNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<WorkflowNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<WorkflowNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Struct metadata = 7;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string app_id = 8;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string user_id = 9;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // string description = 10;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string license = 11;


    pub fn get_license(&self) -> &str {
        &self.license
    }
    pub fn clear_license(&mut self) {
        self.license.clear();
    }

    // Param is passed by value, moved
    pub fn set_license(&mut self, v: ::std::string::String) {
        self.license = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license(&mut self) -> &mut ::std::string::String {
        &mut self.license
    }

    // Take field
    pub fn take_license(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.license, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WorkflowVersion {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.license)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.user_id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.description);
        }
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.license);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.nodes {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(8, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(9, &self.user_id)?;
        }
        if !self.description.is_empty() {
            os.write_string(10, &self.description)?;
        }
        if !self.license.is_empty() {
            os.write_string(11, &self.license)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkflowVersion {
        WorkflowVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &WorkflowVersion| { &m.id },
                |m: &mut WorkflowVersion| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &WorkflowVersion| { &m.workflow_id },
                |m: &mut WorkflowVersion| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &WorkflowVersion| { &m.created_at },
                |m: &mut WorkflowVersion| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &WorkflowVersion| { &m.modified_at },
                |m: &mut WorkflowVersion| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &WorkflowVersion| { &m.visibility },
                |m: &mut WorkflowVersion| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorkflowNode>>(
                "nodes",
                |m: &WorkflowVersion| { &m.nodes },
                |m: &mut WorkflowVersion| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &WorkflowVersion| { &m.metadata },
                |m: &mut WorkflowVersion| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &WorkflowVersion| { &m.app_id },
                |m: &mut WorkflowVersion| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &WorkflowVersion| { &m.user_id },
                |m: &mut WorkflowVersion| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &WorkflowVersion| { &m.description },
                |m: &mut WorkflowVersion| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "license",
                |m: &WorkflowVersion| { &m.license },
                |m: &mut WorkflowVersion| { &mut m.license },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorkflowVersion>(
                "WorkflowVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorkflowVersion {
        static instance: ::protobuf::rt::LazyV2<WorkflowVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorkflowVersion::new)
    }
}

impl ::protobuf::Clear for WorkflowVersion {
    fn clear(&mut self) {
        self.id.clear();
        self.workflow_id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.visibility.clear();
        self.nodes.clear();
        self.metadata.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.description.clear();
        self.license.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkflowVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkflowNode {
    // message fields
    pub id: ::std::string::String,
    pub model: ::protobuf::SingularPtrField<Model>,
    pub node_inputs: ::protobuf::RepeatedField<NodeInput>,
    pub suppress_output: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorkflowNode {
    fn default() -> &'a WorkflowNode {
        <WorkflowNode as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowNode {
    pub fn new() -> WorkflowNode {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Model model = 2;


    pub fn get_model(&self) -> &Model {
        self.model.as_ref().unwrap_or_else(|| <Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> Model {
        self.model.take().unwrap_or_else(|| Model::new())
    }

    // repeated .clarifai.api.NodeInput node_inputs = 3;


    pub fn get_node_inputs(&self) -> &[NodeInput] {
        &self.node_inputs
    }
    pub fn clear_node_inputs(&mut self) {
        self.node_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_inputs(&mut self, v: ::protobuf::RepeatedField<NodeInput>) {
        self.node_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node_inputs(&mut self) -> &mut ::protobuf::RepeatedField<NodeInput> {
        &mut self.node_inputs
    }

    // Take field
    pub fn take_node_inputs(&mut self) -> ::protobuf::RepeatedField<NodeInput> {
        ::std::mem::replace(&mut self.node_inputs, ::protobuf::RepeatedField::new())
    }

    // bool suppress_output = 4;


    pub fn get_suppress_output(&self) -> bool {
        self.suppress_output
    }
    pub fn clear_suppress_output(&mut self) {
        self.suppress_output = false;
    }

    // Param is passed by value, moved
    pub fn set_suppress_output(&mut self, v: bool) {
        self.suppress_output = v;
    }
}

impl ::protobuf::Message for WorkflowNode {
    fn is_initialized(&self) -> bool {
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node_inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node_inputs)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.suppress_output = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.node_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.suppress_output != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.node_inputs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.suppress_output != false {
            os.write_bool(4, self.suppress_output)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkflowNode {
        WorkflowNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &WorkflowNode| { &m.id },
                |m: &mut WorkflowNode| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Model>>(
                "model",
                |m: &WorkflowNode| { &m.model },
                |m: &mut WorkflowNode| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInput>>(
                "node_inputs",
                |m: &WorkflowNode| { &m.node_inputs },
                |m: &mut WorkflowNode| { &mut m.node_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "suppress_output",
                |m: &WorkflowNode| { &m.suppress_output },
                |m: &mut WorkflowNode| { &mut m.suppress_output },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorkflowNode>(
                "WorkflowNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorkflowNode {
        static instance: ::protobuf::rt::LazyV2<WorkflowNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorkflowNode::new)
    }
}

impl ::protobuf::Clear for WorkflowNode {
    fn clear(&mut self) {
        self.id.clear();
        self.model.clear();
        self.node_inputs.clear();
        self.suppress_output = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkflowNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInput {
    // message fields
    pub node_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInput {
    fn default() -> &'a NodeInput {
        <NodeInput as ::protobuf::Message>::default_instance()
    }
}

impl NodeInput {
    pub fn new() -> NodeInput {
        ::std::default::Default::default()
    }

    // string node_id = 1;


    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInput {
        NodeInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_id",
                |m: &NodeInput| { &m.node_id },
                |m: &mut NodeInput| { &mut m.node_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInput>(
                "NodeInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInput {
        static instance: ::protobuf::rt::LazyV2<NodeInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInput::new)
    }
}

impl ::protobuf::Clear for NodeInput {
    fn clear(&mut self) {
        self.node_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkflowResult {
    // message fields
    pub id: ::std::string::String,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub model: ::protobuf::SingularPtrField<Model>,
    pub input: ::protobuf::SingularPtrField<Input>,
    pub outputs: ::protobuf::RepeatedField<Output>,
    pub suppress_output: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorkflowResult {
    fn default() -> &'a WorkflowResult {
        <WorkflowResult as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowResult {
    pub fn new() -> WorkflowResult {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.status.Status status = 2;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .google.protobuf.Timestamp created_at = 3;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .clarifai.api.Model model = 4;


    pub fn get_model(&self) -> &Model {
        self.model.as_ref().unwrap_or_else(|| <Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> Model {
        self.model.take().unwrap_or_else(|| Model::new())
    }

    // .clarifai.api.Input input = 5;


    pub fn get_input(&self) -> &Input {
        self.input.as_ref().unwrap_or_else(|| <Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: Input) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut Input {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> Input {
        self.input.take().unwrap_or_else(|| Input::new())
    }

    // repeated .clarifai.api.Output outputs = 6;


    pub fn get_outputs(&self) -> &[Output] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<Output>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<Output> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<Output> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // bool suppress_output = 7;


    pub fn get_suppress_output(&self) -> bool {
        self.suppress_output
    }
    pub fn clear_suppress_output(&mut self) {
        self.suppress_output = false;
    }

    // Param is passed by value, moved
    pub fn set_suppress_output(&mut self, v: bool) {
        self.suppress_output = v;
    }
}

impl ::protobuf::Message for WorkflowResult {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.suppress_output = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.suppress_output != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.outputs {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.suppress_output != false {
            os.write_bool(7, self.suppress_output)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkflowResult {
        WorkflowResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &WorkflowResult| { &m.id },
                |m: &mut WorkflowResult| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &WorkflowResult| { &m.status },
                |m: &mut WorkflowResult| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &WorkflowResult| { &m.created_at },
                |m: &mut WorkflowResult| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Model>>(
                "model",
                |m: &WorkflowResult| { &m.model },
                |m: &mut WorkflowResult| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Input>>(
                "input",
                |m: &WorkflowResult| { &m.input },
                |m: &mut WorkflowResult| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Output>>(
                "outputs",
                |m: &WorkflowResult| { &m.outputs },
                |m: &mut WorkflowResult| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "suppress_output",
                |m: &WorkflowResult| { &m.suppress_output },
                |m: &mut WorkflowResult| { &mut m.suppress_output },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorkflowResult>(
                "WorkflowResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorkflowResult {
        static instance: ::protobuf::rt::LazyV2<WorkflowResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorkflowResult::new)
    }
}

impl ::protobuf::Clear for WorkflowResult {
    fn clear(&mut self) {
        self.id.clear();
        self.status.clear();
        self.created_at.clear();
        self.model.clear();
        self.input.clear();
        self.outputs.clear();
        self.suppress_output = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkflowResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkflowState {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WorkflowState {
    fn default() -> &'a WorkflowState {
        <WorkflowState as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowState {
    pub fn new() -> WorkflowState {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WorkflowState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkflowState {
        WorkflowState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &WorkflowState| { &m.id },
                |m: &mut WorkflowState| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WorkflowState>(
                "WorkflowState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WorkflowState {
        static instance: ::protobuf::rt::LazyV2<WorkflowState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WorkflowState::new)
    }
}

impl ::protobuf::Clear for WorkflowState {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkflowState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppDuplication {
    // message fields
    pub id: ::std::string::String,
    pub new_app_id: ::std::string::String,
    pub new_app_name: ::std::string::String,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub last_modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub filter: ::protobuf::SingularPtrField<AppDuplicationFilters>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppDuplication {
    fn default() -> &'a AppDuplication {
        <AppDuplication as ::protobuf::Message>::default_instance()
    }
}

impl AppDuplication {
    pub fn new() -> AppDuplication {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string new_app_id = 2;


    pub fn get_new_app_id(&self) -> &str {
        &self.new_app_id
    }
    pub fn clear_new_app_id(&mut self) {
        self.new_app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_app_id(&mut self, v: ::std::string::String) {
        self.new_app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.new_app_id
    }

    // Take field
    pub fn take_new_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.new_app_id, ::std::string::String::new())
    }

    // string new_app_name = 3;


    pub fn get_new_app_name(&self) -> &str {
        &self.new_app_name
    }
    pub fn clear_new_app_name(&mut self) {
        self.new_app_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_app_name(&mut self, v: ::std::string::String) {
        self.new_app_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_app_name(&mut self) -> &mut ::std::string::String {
        &mut self.new_app_name
    }

    // Take field
    pub fn take_new_app_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.new_app_name, ::std::string::String::new())
    }

    // .clarifai.api.status.Status status = 4;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .google.protobuf.Timestamp created_at = 5;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp last_modified_at = 6;


    pub fn get_last_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_modified_at(&mut self) {
        self.last_modified_at.clear();
    }

    pub fn has_last_modified_at(&self) -> bool {
        self.last_modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_modified_at.is_none() {
            self.last_modified_at.set_default();
        }
        self.last_modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .clarifai.api.AppDuplicationFilters filter = 7;


    pub fn get_filter(&self) -> &AppDuplicationFilters {
        self.filter.as_ref().unwrap_or_else(|| <AppDuplicationFilters as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: AppDuplicationFilters) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut AppDuplicationFilters {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> AppDuplicationFilters {
        self.filter.take().unwrap_or_else(|| AppDuplicationFilters::new())
    }
}

impl ::protobuf::Message for AppDuplication {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.new_app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.new_app_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_modified_at)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.new_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new_app_id);
        }
        if !self.new_app_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.new_app_name);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.new_app_id.is_empty() {
            os.write_string(2, &self.new_app_id)?;
        }
        if !self.new_app_name.is_empty() {
            os.write_string(3, &self.new_app_name)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_modified_at.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDuplication {
        AppDuplication::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &AppDuplication| { &m.id },
                |m: &mut AppDuplication| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "new_app_id",
                |m: &AppDuplication| { &m.new_app_id },
                |m: &mut AppDuplication| { &mut m.new_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "new_app_name",
                |m: &AppDuplication| { &m.new_app_name },
                |m: &mut AppDuplication| { &mut m.new_app_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &AppDuplication| { &m.status },
                |m: &mut AppDuplication| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &AppDuplication| { &m.created_at },
                |m: &mut AppDuplication| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_modified_at",
                |m: &AppDuplication| { &m.last_modified_at },
                |m: &mut AppDuplication| { &mut m.last_modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppDuplicationFilters>>(
                "filter",
                |m: &AppDuplication| { &m.filter },
                |m: &mut AppDuplication| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppDuplication>(
                "AppDuplication",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppDuplication {
        static instance: ::protobuf::rt::LazyV2<AppDuplication> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppDuplication::new)
    }
}

impl ::protobuf::Clear for AppDuplication {
    fn clear(&mut self) {
        self.id.clear();
        self.new_app_id.clear();
        self.new_app_name.clear();
        self.status.clear();
        self.created_at.clear();
        self.last_modified_at.clear();
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDuplication {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDuplication {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppDuplicationFilters {
    // message fields
    pub copy_inputs: bool,
    pub copy_concepts: bool,
    pub copy_annotations: bool,
    pub copy_models: bool,
    pub copy_workflows: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppDuplicationFilters {
    fn default() -> &'a AppDuplicationFilters {
        <AppDuplicationFilters as ::protobuf::Message>::default_instance()
    }
}

impl AppDuplicationFilters {
    pub fn new() -> AppDuplicationFilters {
        ::std::default::Default::default()
    }

    // bool copy_inputs = 1;


    pub fn get_copy_inputs(&self) -> bool {
        self.copy_inputs
    }
    pub fn clear_copy_inputs(&mut self) {
        self.copy_inputs = false;
    }

    // Param is passed by value, moved
    pub fn set_copy_inputs(&mut self, v: bool) {
        self.copy_inputs = v;
    }

    // bool copy_concepts = 2;


    pub fn get_copy_concepts(&self) -> bool {
        self.copy_concepts
    }
    pub fn clear_copy_concepts(&mut self) {
        self.copy_concepts = false;
    }

    // Param is passed by value, moved
    pub fn set_copy_concepts(&mut self, v: bool) {
        self.copy_concepts = v;
    }

    // bool copy_annotations = 3;


    pub fn get_copy_annotations(&self) -> bool {
        self.copy_annotations
    }
    pub fn clear_copy_annotations(&mut self) {
        self.copy_annotations = false;
    }

    // Param is passed by value, moved
    pub fn set_copy_annotations(&mut self, v: bool) {
        self.copy_annotations = v;
    }

    // bool copy_models = 4;


    pub fn get_copy_models(&self) -> bool {
        self.copy_models
    }
    pub fn clear_copy_models(&mut self) {
        self.copy_models = false;
    }

    // Param is passed by value, moved
    pub fn set_copy_models(&mut self, v: bool) {
        self.copy_models = v;
    }

    // bool copy_workflows = 5;


    pub fn get_copy_workflows(&self) -> bool {
        self.copy_workflows
    }
    pub fn clear_copy_workflows(&mut self) {
        self.copy_workflows = false;
    }

    // Param is passed by value, moved
    pub fn set_copy_workflows(&mut self, v: bool) {
        self.copy_workflows = v;
    }
}

impl ::protobuf::Message for AppDuplicationFilters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.copy_inputs = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.copy_concepts = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.copy_annotations = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.copy_models = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.copy_workflows = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.copy_inputs != false {
            my_size += 2;
        }
        if self.copy_concepts != false {
            my_size += 2;
        }
        if self.copy_annotations != false {
            my_size += 2;
        }
        if self.copy_models != false {
            my_size += 2;
        }
        if self.copy_workflows != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.copy_inputs != false {
            os.write_bool(1, self.copy_inputs)?;
        }
        if self.copy_concepts != false {
            os.write_bool(2, self.copy_concepts)?;
        }
        if self.copy_annotations != false {
            os.write_bool(3, self.copy_annotations)?;
        }
        if self.copy_models != false {
            os.write_bool(4, self.copy_models)?;
        }
        if self.copy_workflows != false {
            os.write_bool(5, self.copy_workflows)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDuplicationFilters {
        AppDuplicationFilters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "copy_inputs",
                |m: &AppDuplicationFilters| { &m.copy_inputs },
                |m: &mut AppDuplicationFilters| { &mut m.copy_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "copy_concepts",
                |m: &AppDuplicationFilters| { &m.copy_concepts },
                |m: &mut AppDuplicationFilters| { &mut m.copy_concepts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "copy_annotations",
                |m: &AppDuplicationFilters| { &m.copy_annotations },
                |m: &mut AppDuplicationFilters| { &mut m.copy_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "copy_models",
                |m: &AppDuplicationFilters| { &m.copy_models },
                |m: &mut AppDuplicationFilters| { &mut m.copy_models },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "copy_workflows",
                |m: &AppDuplicationFilters| { &m.copy_workflows },
                |m: &mut AppDuplicationFilters| { &mut m.copy_workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppDuplicationFilters>(
                "AppDuplicationFilters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppDuplicationFilters {
        static instance: ::protobuf::rt::LazyV2<AppDuplicationFilters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppDuplicationFilters::new)
    }
}

impl ::protobuf::Clear for AppDuplicationFilters {
    fn clear(&mut self) {
        self.copy_inputs = false;
        self.copy_concepts = false;
        self.copy_annotations = false;
        self.copy_models = false;
        self.copy_workflows = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDuplicationFilters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDuplicationFilters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Task {
    // message fields
    pub id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modified_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub field_type: Task_TaskType,
    pub description: ::std::string::String,
    pub worker: ::protobuf::SingularPtrField<TaskWorker>,
    pub concept_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub input_source: ::protobuf::SingularPtrField<TaskInputSource>,
    pub sample_ms: u32,
    pub ai_assistant: ::protobuf::SingularPtrField<TaskAIAssistant>,
    pub review: ::protobuf::SingularPtrField<TaskReview>,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub name: ::std::string::String,
    pub ai_assist_params: ::protobuf::SingularPtrField<AiAssistParameters>,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub app_id: ::std::string::String,
    pub user_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Task {
    fn default() -> &'a Task {
        <Task as ::protobuf::Message>::default_instance()
    }
}

impl Task {
    pub fn new() -> Task {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modified_at = 3;


    pub fn get_modified_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modified_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modified_at(&mut self) {
        self.modified_at.clear();
    }

    pub fn has_modified_at(&self) -> bool {
        self.modified_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modified_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modified_at.is_none() {
            self.modified_at.set_default();
        }
        self.modified_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modified_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .clarifai.api.Task.TaskType type = 4;


    pub fn get_field_type(&self) -> Task_TaskType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Task_TaskType::TYPE_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Task_TaskType) {
        self.field_type = v;
    }

    // string description = 5;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .clarifai.api.TaskWorker worker = 6;


    pub fn get_worker(&self) -> &TaskWorker {
        self.worker.as_ref().unwrap_or_else(|| <TaskWorker as ::protobuf::Message>::default_instance())
    }
    pub fn clear_worker(&mut self) {
        self.worker.clear();
    }

    pub fn has_worker(&self) -> bool {
        self.worker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worker(&mut self, v: TaskWorker) {
        self.worker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker(&mut self) -> &mut TaskWorker {
        if self.worker.is_none() {
            self.worker.set_default();
        }
        self.worker.as_mut().unwrap()
    }

    // Take field
    pub fn take_worker(&mut self) -> TaskWorker {
        self.worker.take().unwrap_or_else(|| TaskWorker::new())
    }

    // repeated string concept_ids = 7;


    pub fn get_concept_ids(&self) -> &[::std::string::String] {
        &self.concept_ids
    }
    pub fn clear_concept_ids(&mut self) {
        self.concept_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concept_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concept_ids
    }

    // Take field
    pub fn take_concept_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concept_ids, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.TaskInputSource input_source = 8;


    pub fn get_input_source(&self) -> &TaskInputSource {
        self.input_source.as_ref().unwrap_or_else(|| <TaskInputSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_source(&mut self) {
        self.input_source.clear();
    }

    pub fn has_input_source(&self) -> bool {
        self.input_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_source(&mut self, v: TaskInputSource) {
        self.input_source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_source(&mut self) -> &mut TaskInputSource {
        if self.input_source.is_none() {
            self.input_source.set_default();
        }
        self.input_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_source(&mut self) -> TaskInputSource {
        self.input_source.take().unwrap_or_else(|| TaskInputSource::new())
    }

    // uint32 sample_ms = 9;


    pub fn get_sample_ms(&self) -> u32 {
        self.sample_ms
    }
    pub fn clear_sample_ms(&mut self) {
        self.sample_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_sample_ms(&mut self, v: u32) {
        self.sample_ms = v;
    }

    // .clarifai.api.TaskAIAssistant ai_assistant = 10;


    pub fn get_ai_assistant(&self) -> &TaskAIAssistant {
        self.ai_assistant.as_ref().unwrap_or_else(|| <TaskAIAssistant as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ai_assistant(&mut self) {
        self.ai_assistant.clear();
    }

    pub fn has_ai_assistant(&self) -> bool {
        self.ai_assistant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ai_assistant(&mut self, v: TaskAIAssistant) {
        self.ai_assistant = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ai_assistant(&mut self) -> &mut TaskAIAssistant {
        if self.ai_assistant.is_none() {
            self.ai_assistant.set_default();
        }
        self.ai_assistant.as_mut().unwrap()
    }

    // Take field
    pub fn take_ai_assistant(&mut self) -> TaskAIAssistant {
        self.ai_assistant.take().unwrap_or_else(|| TaskAIAssistant::new())
    }

    // .clarifai.api.TaskReview review = 11;


    pub fn get_review(&self) -> &TaskReview {
        self.review.as_ref().unwrap_or_else(|| <TaskReview as ::protobuf::Message>::default_instance())
    }
    pub fn clear_review(&mut self) {
        self.review.clear();
    }

    pub fn has_review(&self) -> bool {
        self.review.is_some()
    }

    // Param is passed by value, moved
    pub fn set_review(&mut self, v: TaskReview) {
        self.review = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_review(&mut self) -> &mut TaskReview {
        if self.review.is_none() {
            self.review.set_default();
        }
        self.review.as_mut().unwrap()
    }

    // Take field
    pub fn take_review(&mut self) -> TaskReview {
        self.review.take().unwrap_or_else(|| TaskReview::new())
    }

    // .clarifai.api.status.Status status = 12;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // string name = 13;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .clarifai.api.AiAssistParameters ai_assist_params = 14;


    pub fn get_ai_assist_params(&self) -> &AiAssistParameters {
        self.ai_assist_params.as_ref().unwrap_or_else(|| <AiAssistParameters as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ai_assist_params(&mut self) {
        self.ai_assist_params.clear();
    }

    pub fn has_ai_assist_params(&self) -> bool {
        self.ai_assist_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ai_assist_params(&mut self, v: AiAssistParameters) {
        self.ai_assist_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ai_assist_params(&mut self) -> &mut AiAssistParameters {
        if self.ai_assist_params.is_none() {
            self.ai_assist_params.set_default();
        }
        self.ai_assist_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_ai_assist_params(&mut self) -> AiAssistParameters {
        self.ai_assist_params.take().unwrap_or_else(|| AiAssistParameters::new())
    }

    // .clarifai.api.Visibility visibility = 15;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // string app_id = 16;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string user_id = 17;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Task {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modified_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.worker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ai_assistant {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.review {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ai_assist_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modified_at)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.worker)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concept_ids)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_source)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sample_ms = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ai_assistant)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.review)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ai_assist_params)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.field_type != Task_TaskType::TYPE_NOT_SET {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.description);
        }
        if let Some(ref v) = self.worker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.input_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.sample_ms != 0 {
            my_size += ::protobuf::rt::value_size(9, self.sample_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ai_assistant.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.review.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.name);
        }
        if let Some(ref v) = self.ai_assist_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.app_id);
        }
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.user_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modified_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.field_type != Task_TaskType::TYPE_NOT_SET {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.description.is_empty() {
            os.write_string(5, &self.description)?;
        }
        if let Some(ref v) = self.worker.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_ids {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.input_source.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.sample_ms != 0 {
            os.write_uint32(9, self.sample_ms)?;
        }
        if let Some(ref v) = self.ai_assistant.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.review.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(13, &self.name)?;
        }
        if let Some(ref v) = self.ai_assist_params.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(16, &self.app_id)?;
        }
        if !self.user_id.is_empty() {
            os.write_string(17, &self.user_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Task {
        Task::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Task| { &m.id },
                |m: &mut Task| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Task| { &m.created_at },
                |m: &mut Task| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modified_at",
                |m: &Task| { &m.modified_at },
                |m: &mut Task| { &mut m.modified_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Task_TaskType>>(
                "type",
                |m: &Task| { &m.field_type },
                |m: &mut Task| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Task| { &m.description },
                |m: &mut Task| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskWorker>>(
                "worker",
                |m: &Task| { &m.worker },
                |m: &mut Task| { &mut m.worker },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_ids",
                |m: &Task| { &m.concept_ids },
                |m: &mut Task| { &mut m.concept_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskInputSource>>(
                "input_source",
                |m: &Task| { &m.input_source },
                |m: &mut Task| { &mut m.input_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sample_ms",
                |m: &Task| { &m.sample_ms },
                |m: &mut Task| { &mut m.sample_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskAIAssistant>>(
                "ai_assistant",
                |m: &Task| { &m.ai_assistant },
                |m: &mut Task| { &mut m.ai_assistant },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskReview>>(
                "review",
                |m: &Task| { &m.review },
                |m: &mut Task| { &mut m.review },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &Task| { &m.status },
                |m: &mut Task| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Task| { &m.name },
                |m: &mut Task| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AiAssistParameters>>(
                "ai_assist_params",
                |m: &Task| { &m.ai_assist_params },
                |m: &mut Task| { &mut m.ai_assist_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Visibility>>(
                "visibility",
                |m: &Task| { &m.visibility },
                |m: &mut Task| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &Task| { &m.app_id },
                |m: &mut Task| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &Task| { &m.user_id },
                |m: &mut Task| { &mut m.user_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Task>(
                "Task",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Task {
        static instance: ::protobuf::rt::LazyV2<Task> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Task::new)
    }
}

impl ::protobuf::Clear for Task {
    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.modified_at.clear();
        self.field_type = Task_TaskType::TYPE_NOT_SET;
        self.description.clear();
        self.worker.clear();
        self.concept_ids.clear();
        self.input_source.clear();
        self.sample_ms = 0;
        self.ai_assistant.clear();
        self.review.clear();
        self.status.clear();
        self.name.clear();
        self.ai_assist_params.clear();
        self.visibility.clear();
        self.app_id.clear();
        self.user_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Task {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Task {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Task_TaskType {
    TYPE_NOT_SET = 0,
    CONCEPTS_CLASSIFICATION = 1,
    BOUNDING_BOX_DETECTION = 2,
    POLYGON_DETECTION = 3,
}

impl ::protobuf::ProtobufEnum for Task_TaskType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Task_TaskType> {
        match value {
            0 => ::std::option::Option::Some(Task_TaskType::TYPE_NOT_SET),
            1 => ::std::option::Option::Some(Task_TaskType::CONCEPTS_CLASSIFICATION),
            2 => ::std::option::Option::Some(Task_TaskType::BOUNDING_BOX_DETECTION),
            3 => ::std::option::Option::Some(Task_TaskType::POLYGON_DETECTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Task_TaskType] = &[
            Task_TaskType::TYPE_NOT_SET,
            Task_TaskType::CONCEPTS_CLASSIFICATION,
            Task_TaskType::BOUNDING_BOX_DETECTION,
            Task_TaskType::POLYGON_DETECTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Task_TaskType>("Task.TaskType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Task_TaskType {
}

impl ::std::default::Default for Task_TaskType {
    fn default() -> Self {
        Task_TaskType::TYPE_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for Task_TaskType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AiAssistParameters {
    // message fields
    pub min_threshold: f32,
    pub max_threshold: f32,
    pub concept_relation_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AiAssistParameters {
    fn default() -> &'a AiAssistParameters {
        <AiAssistParameters as ::protobuf::Message>::default_instance()
    }
}

impl AiAssistParameters {
    pub fn new() -> AiAssistParameters {
        ::std::default::Default::default()
    }

    // float min_threshold = 1;


    pub fn get_min_threshold(&self) -> f32 {
        self.min_threshold
    }
    pub fn clear_min_threshold(&mut self) {
        self.min_threshold = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_threshold(&mut self, v: f32) {
        self.min_threshold = v;
    }

    // float max_threshold = 2;


    pub fn get_max_threshold(&self) -> f32 {
        self.max_threshold
    }
    pub fn clear_max_threshold(&mut self) {
        self.max_threshold = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_threshold(&mut self, v: f32) {
        self.max_threshold = v;
    }

    // repeated string concept_relation_ids = 3;


    pub fn get_concept_relation_ids(&self) -> &[::std::string::String] {
        &self.concept_relation_ids
    }
    pub fn clear_concept_relation_ids(&mut self) {
        self.concept_relation_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_relation_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concept_relation_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_relation_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concept_relation_ids
    }

    // Take field
    pub fn take_concept_relation_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concept_relation_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AiAssistParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min_threshold = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_threshold = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concept_relation_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_threshold != 0. {
            my_size += 5;
        }
        if self.max_threshold != 0. {
            my_size += 5;
        }
        for value in &self.concept_relation_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min_threshold != 0. {
            os.write_float(1, self.min_threshold)?;
        }
        if self.max_threshold != 0. {
            os.write_float(2, self.max_threshold)?;
        }
        for v in &self.concept_relation_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AiAssistParameters {
        AiAssistParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min_threshold",
                |m: &AiAssistParameters| { &m.min_threshold },
                |m: &mut AiAssistParameters| { &mut m.min_threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_threshold",
                |m: &AiAssistParameters| { &m.max_threshold },
                |m: &mut AiAssistParameters| { &mut m.max_threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_relation_ids",
                |m: &AiAssistParameters| { &m.concept_relation_ids },
                |m: &mut AiAssistParameters| { &mut m.concept_relation_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AiAssistParameters>(
                "AiAssistParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AiAssistParameters {
        static instance: ::protobuf::rt::LazyV2<AiAssistParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AiAssistParameters::new)
    }
}

impl ::protobuf::Clear for AiAssistParameters {
    fn clear(&mut self) {
        self.min_threshold = 0.;
        self.max_threshold = 0.;
        self.concept_relation_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AiAssistParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AiAssistParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskWorker {
    // message fields
    pub strategy: TaskWorker_TaskWorkerStrategy,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub strategy_info: ::std::option::Option<TaskWorker_oneof_strategy_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskWorker {
    fn default() -> &'a TaskWorker {
        <TaskWorker as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TaskWorker_oneof_strategy_info {
    partitioned_strategy_info(TaskWorkerPartitionedStrategyInfo),
}

impl TaskWorker {
    pub fn new() -> TaskWorker {
        ::std::default::Default::default()
    }

    // .clarifai.api.TaskWorker.TaskWorkerStrategy strategy = 1;


    pub fn get_strategy(&self) -> TaskWorker_TaskWorkerStrategy {
        self.strategy
    }
    pub fn clear_strategy(&mut self) {
        self.strategy = TaskWorker_TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: TaskWorker_TaskWorkerStrategy) {
        self.strategy = v;
    }

    // repeated string user_ids = 2;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.TaskWorkerPartitionedStrategyInfo partitioned_strategy_info = 3;


    pub fn get_partitioned_strategy_info(&self) -> &TaskWorkerPartitionedStrategyInfo {
        match self.strategy_info {
            ::std::option::Option::Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(ref v)) => v,
            _ => <TaskWorkerPartitionedStrategyInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_partitioned_strategy_info(&mut self) {
        self.strategy_info = ::std::option::Option::None;
    }

    pub fn has_partitioned_strategy_info(&self) -> bool {
        match self.strategy_info {
            ::std::option::Option::Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_partitioned_strategy_info(&mut self, v: TaskWorkerPartitionedStrategyInfo) {
        self.strategy_info = ::std::option::Option::Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_partitioned_strategy_info(&mut self) -> &mut TaskWorkerPartitionedStrategyInfo {
        if let ::std::option::Option::Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(_)) = self.strategy_info {
        } else {
            self.strategy_info = ::std::option::Option::Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(TaskWorkerPartitionedStrategyInfo::new()));
        }
        match self.strategy_info {
            ::std::option::Option::Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_partitioned_strategy_info(&mut self) -> TaskWorkerPartitionedStrategyInfo {
        if self.has_partitioned_strategy_info() {
            match self.strategy_info.take() {
                ::std::option::Option::Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(v)) => v,
                _ => panic!(),
            }
        } else {
            TaskWorkerPartitionedStrategyInfo::new()
        }
    }
}

impl ::protobuf::Message for TaskWorker {
    fn is_initialized(&self) -> bool {
        if let Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(ref v)) = self.strategy_info {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.strategy, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.strategy_info = ::std::option::Option::Some(TaskWorker_oneof_strategy_info::partitioned_strategy_info(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.strategy != TaskWorker_TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.strategy);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.strategy_info {
            match v {
                &TaskWorker_oneof_strategy_info::partitioned_strategy_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.strategy != TaskWorker_TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.strategy))?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.strategy_info {
            match v {
                &TaskWorker_oneof_strategy_info::partitioned_strategy_info(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskWorker {
        TaskWorker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskWorker_TaskWorkerStrategy>>(
                "strategy",
                |m: &TaskWorker| { &m.strategy },
                |m: &mut TaskWorker| { &mut m.strategy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &TaskWorker| { &m.user_ids },
                |m: &mut TaskWorker| { &mut m.user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TaskWorkerPartitionedStrategyInfo>(
                "partitioned_strategy_info",
                TaskWorker::has_partitioned_strategy_info,
                TaskWorker::get_partitioned_strategy_info,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskWorker>(
                "TaskWorker",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskWorker {
        static instance: ::protobuf::rt::LazyV2<TaskWorker> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskWorker::new)
    }
}

impl ::protobuf::Clear for TaskWorker {
    fn clear(&mut self) {
        self.strategy = TaskWorker_TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET;
        self.user_ids.clear();
        self.strategy_info = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskWorker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskWorker {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskWorker_TaskWorkerStrategy {
    WORKER_STRATEGY_NOT_SET = 0,
    PARTITIONED = 2,
    FULL = 3,
}

impl ::protobuf::ProtobufEnum for TaskWorker_TaskWorkerStrategy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskWorker_TaskWorkerStrategy> {
        match value {
            0 => ::std::option::Option::Some(TaskWorker_TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET),
            2 => ::std::option::Option::Some(TaskWorker_TaskWorkerStrategy::PARTITIONED),
            3 => ::std::option::Option::Some(TaskWorker_TaskWorkerStrategy::FULL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskWorker_TaskWorkerStrategy] = &[
            TaskWorker_TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET,
            TaskWorker_TaskWorkerStrategy::PARTITIONED,
            TaskWorker_TaskWorkerStrategy::FULL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TaskWorker_TaskWorkerStrategy>("TaskWorker.TaskWorkerStrategy", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TaskWorker_TaskWorkerStrategy {
}

impl ::std::default::Default for TaskWorker_TaskWorkerStrategy {
    fn default() -> Self {
        TaskWorker_TaskWorkerStrategy::WORKER_STRATEGY_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskWorker_TaskWorkerStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskWorkerPartitionedStrategyInfo {
    // message fields
    pub field_type: TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy,
    pub workers_per_input: i32,
    pub weights: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskWorkerPartitionedStrategyInfo {
    fn default() -> &'a TaskWorkerPartitionedStrategyInfo {
        <TaskWorkerPartitionedStrategyInfo as ::protobuf::Message>::default_instance()
    }
}

impl TaskWorkerPartitionedStrategyInfo {
    pub fn new() -> TaskWorkerPartitionedStrategyInfo {
        ::std::default::Default::default()
    }

    // .clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy type = 1;


    pub fn get_field_type(&self) -> TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy) {
        self.field_type = v;
    }

    // int32 workers_per_input = 2;


    pub fn get_workers_per_input(&self) -> i32 {
        self.workers_per_input
    }
    pub fn clear_workers_per_input(&mut self) {
        self.workers_per_input = 0;
    }

    // Param is passed by value, moved
    pub fn set_workers_per_input(&mut self, v: i32) {
        self.workers_per_input = v;
    }

    // .google.protobuf.Struct weights = 3;


    pub fn get_weights(&self) -> &::protobuf::well_known_types::Struct {
        self.weights.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_weights(&mut self) {
        self.weights.clear();
    }

    pub fn has_weights(&self) -> bool {
        self.weights.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weights(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.weights = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weights(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.weights.is_none() {
            self.weights.set_default();
        }
        self.weights.as_mut().unwrap()
    }

    // Take field
    pub fn take_weights(&mut self) -> ::protobuf::well_known_types::Struct {
        self.weights.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for TaskWorkerPartitionedStrategyInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.weights {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.workers_per_input = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weights)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.workers_per_input != 0 {
            my_size += ::protobuf::rt::value_size(2, self.workers_per_input, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.weights.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.workers_per_input != 0 {
            os.write_int32(2, self.workers_per_input)?;
        }
        if let Some(ref v) = self.weights.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskWorkerPartitionedStrategyInfo {
        TaskWorkerPartitionedStrategyInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy>>(
                "type",
                |m: &TaskWorkerPartitionedStrategyInfo| { &m.field_type },
                |m: &mut TaskWorkerPartitionedStrategyInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "workers_per_input",
                |m: &TaskWorkerPartitionedStrategyInfo| { &m.workers_per_input },
                |m: &mut TaskWorkerPartitionedStrategyInfo| { &mut m.workers_per_input },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "weights",
                |m: &TaskWorkerPartitionedStrategyInfo| { &m.weights },
                |m: &mut TaskWorkerPartitionedStrategyInfo| { &mut m.weights },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskWorkerPartitionedStrategyInfo>(
                "TaskWorkerPartitionedStrategyInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskWorkerPartitionedStrategyInfo {
        static instance: ::protobuf::rt::LazyV2<TaskWorkerPartitionedStrategyInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskWorkerPartitionedStrategyInfo::new)
    }
}

impl ::protobuf::Clear for TaskWorkerPartitionedStrategyInfo {
    fn clear(&mut self) {
        self.field_type = TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET;
        self.workers_per_input = 0;
        self.weights.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskWorkerPartitionedStrategyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskWorkerPartitionedStrategyInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
    PARTITIONED_WORKER_STRATEGY_NOT_SET = 0,
    EVENLY = 1,
    WEIGHTED = 2,
}

impl ::protobuf::ProtobufEnum for TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy> {
        match value {
            0 => ::std::option::Option::Some(TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET),
            1 => ::std::option::Option::Some(TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::EVENLY),
            2 => ::std::option::Option::Some(TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::WEIGHTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy] = &[
            TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET,
            TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::EVENLY,
            TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::WEIGHTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy>("TaskWorkerPartitionedStrategyInfo.TaskWorkerPartitionedStrategy", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
}

impl ::std::default::Default for TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
    fn default() -> Self {
        TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy::PARTITIONED_WORKER_STRATEGY_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskWorkerPartitionedStrategyInfo_TaskWorkerPartitionedStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskInputSource {
    // message fields
    pub field_type: TaskInputSource_TaskInputSourceType,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskInputSource {
    fn default() -> &'a TaskInputSource {
        <TaskInputSource as ::protobuf::Message>::default_instance()
    }
}

impl TaskInputSource {
    pub fn new() -> TaskInputSource {
        ::std::default::Default::default()
    }

    // .clarifai.api.TaskInputSource.TaskInputSourceType type = 1;


    pub fn get_field_type(&self) -> TaskInputSource_TaskInputSourceType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = TaskInputSource_TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TaskInputSource_TaskInputSourceType) {
        self.field_type = v;
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TaskInputSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != TaskInputSource_TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != TaskInputSource_TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskInputSource {
        TaskInputSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskInputSource_TaskInputSourceType>>(
                "type",
                |m: &TaskInputSource| { &m.field_type },
                |m: &mut TaskInputSource| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &TaskInputSource| { &m.id },
                |m: &mut TaskInputSource| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskInputSource>(
                "TaskInputSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskInputSource {
        static instance: ::protobuf::rt::LazyV2<TaskInputSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskInputSource::new)
    }
}

impl ::protobuf::Clear for TaskInputSource {
    fn clear(&mut self) {
        self.field_type = TaskInputSource_TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET;
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskInputSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskInputSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskInputSource_TaskInputSourceType {
    INPUT_SOURCE_TYPE_NOT_SET = 0,
    ALL_INPUTS = 1,
    SAVED_SEARCH = 2,
}

impl ::protobuf::ProtobufEnum for TaskInputSource_TaskInputSourceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskInputSource_TaskInputSourceType> {
        match value {
            0 => ::std::option::Option::Some(TaskInputSource_TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET),
            1 => ::std::option::Option::Some(TaskInputSource_TaskInputSourceType::ALL_INPUTS),
            2 => ::std::option::Option::Some(TaskInputSource_TaskInputSourceType::SAVED_SEARCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskInputSource_TaskInputSourceType] = &[
            TaskInputSource_TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET,
            TaskInputSource_TaskInputSourceType::ALL_INPUTS,
            TaskInputSource_TaskInputSourceType::SAVED_SEARCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TaskInputSource_TaskInputSourceType>("TaskInputSource.TaskInputSourceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TaskInputSource_TaskInputSourceType {
}

impl ::std::default::Default for TaskInputSource_TaskInputSourceType {
    fn default() -> Self {
        TaskInputSource_TaskInputSourceType::INPUT_SOURCE_TYPE_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskInputSource_TaskInputSourceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskReview {
    // message fields
    pub strategy: TaskReview_TaskReviewStrategy,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub strategy_info: ::std::option::Option<TaskReview_oneof_strategy_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskReview {
    fn default() -> &'a TaskReview {
        <TaskReview as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TaskReview_oneof_strategy_info {
    manual_strategy_info(TaskReviewManualStrategyInfo),
    consensus_strategy_info(TaskReviewConsensusStrategyInfo),
}

impl TaskReview {
    pub fn new() -> TaskReview {
        ::std::default::Default::default()
    }

    // .clarifai.api.TaskReview.TaskReviewStrategy strategy = 1;


    pub fn get_strategy(&self) -> TaskReview_TaskReviewStrategy {
        self.strategy
    }
    pub fn clear_strategy(&mut self) {
        self.strategy = TaskReview_TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: TaskReview_TaskReviewStrategy) {
        self.strategy = v;
    }

    // repeated string user_ids = 2;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.TaskReviewManualStrategyInfo manual_strategy_info = 3;


    pub fn get_manual_strategy_info(&self) -> &TaskReviewManualStrategyInfo {
        match self.strategy_info {
            ::std::option::Option::Some(TaskReview_oneof_strategy_info::manual_strategy_info(ref v)) => v,
            _ => <TaskReviewManualStrategyInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_manual_strategy_info(&mut self) {
        self.strategy_info = ::std::option::Option::None;
    }

    pub fn has_manual_strategy_info(&self) -> bool {
        match self.strategy_info {
            ::std::option::Option::Some(TaskReview_oneof_strategy_info::manual_strategy_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_manual_strategy_info(&mut self, v: TaskReviewManualStrategyInfo) {
        self.strategy_info = ::std::option::Option::Some(TaskReview_oneof_strategy_info::manual_strategy_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_manual_strategy_info(&mut self) -> &mut TaskReviewManualStrategyInfo {
        if let ::std::option::Option::Some(TaskReview_oneof_strategy_info::manual_strategy_info(_)) = self.strategy_info {
        } else {
            self.strategy_info = ::std::option::Option::Some(TaskReview_oneof_strategy_info::manual_strategy_info(TaskReviewManualStrategyInfo::new()));
        }
        match self.strategy_info {
            ::std::option::Option::Some(TaskReview_oneof_strategy_info::manual_strategy_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_manual_strategy_info(&mut self) -> TaskReviewManualStrategyInfo {
        if self.has_manual_strategy_info() {
            match self.strategy_info.take() {
                ::std::option::Option::Some(TaskReview_oneof_strategy_info::manual_strategy_info(v)) => v,
                _ => panic!(),
            }
        } else {
            TaskReviewManualStrategyInfo::new()
        }
    }

    // .clarifai.api.TaskReviewConsensusStrategyInfo consensus_strategy_info = 4;


    pub fn get_consensus_strategy_info(&self) -> &TaskReviewConsensusStrategyInfo {
        match self.strategy_info {
            ::std::option::Option::Some(TaskReview_oneof_strategy_info::consensus_strategy_info(ref v)) => v,
            _ => <TaskReviewConsensusStrategyInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_consensus_strategy_info(&mut self) {
        self.strategy_info = ::std::option::Option::None;
    }

    pub fn has_consensus_strategy_info(&self) -> bool {
        match self.strategy_info {
            ::std::option::Option::Some(TaskReview_oneof_strategy_info::consensus_strategy_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_consensus_strategy_info(&mut self, v: TaskReviewConsensusStrategyInfo) {
        self.strategy_info = ::std::option::Option::Some(TaskReview_oneof_strategy_info::consensus_strategy_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_consensus_strategy_info(&mut self) -> &mut TaskReviewConsensusStrategyInfo {
        if let ::std::option::Option::Some(TaskReview_oneof_strategy_info::consensus_strategy_info(_)) = self.strategy_info {
        } else {
            self.strategy_info = ::std::option::Option::Some(TaskReview_oneof_strategy_info::consensus_strategy_info(TaskReviewConsensusStrategyInfo::new()));
        }
        match self.strategy_info {
            ::std::option::Option::Some(TaskReview_oneof_strategy_info::consensus_strategy_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_consensus_strategy_info(&mut self) -> TaskReviewConsensusStrategyInfo {
        if self.has_consensus_strategy_info() {
            match self.strategy_info.take() {
                ::std::option::Option::Some(TaskReview_oneof_strategy_info::consensus_strategy_info(v)) => v,
                _ => panic!(),
            }
        } else {
            TaskReviewConsensusStrategyInfo::new()
        }
    }
}

impl ::protobuf::Message for TaskReview {
    fn is_initialized(&self) -> bool {
        if let Some(TaskReview_oneof_strategy_info::manual_strategy_info(ref v)) = self.strategy_info {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TaskReview_oneof_strategy_info::consensus_strategy_info(ref v)) = self.strategy_info {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.strategy, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.strategy_info = ::std::option::Option::Some(TaskReview_oneof_strategy_info::manual_strategy_info(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.strategy_info = ::std::option::Option::Some(TaskReview_oneof_strategy_info::consensus_strategy_info(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.strategy != TaskReview_TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.strategy);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.strategy_info {
            match v {
                &TaskReview_oneof_strategy_info::manual_strategy_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TaskReview_oneof_strategy_info::consensus_strategy_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.strategy != TaskReview_TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.strategy))?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.strategy_info {
            match v {
                &TaskReview_oneof_strategy_info::manual_strategy_info(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TaskReview_oneof_strategy_info::consensus_strategy_info(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskReview {
        TaskReview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskReview_TaskReviewStrategy>>(
                "strategy",
                |m: &TaskReview| { &m.strategy },
                |m: &mut TaskReview| { &mut m.strategy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &TaskReview| { &m.user_ids },
                |m: &mut TaskReview| { &mut m.user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TaskReviewManualStrategyInfo>(
                "manual_strategy_info",
                TaskReview::has_manual_strategy_info,
                TaskReview::get_manual_strategy_info,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TaskReviewConsensusStrategyInfo>(
                "consensus_strategy_info",
                TaskReview::has_consensus_strategy_info,
                TaskReview::get_consensus_strategy_info,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskReview>(
                "TaskReview",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskReview {
        static instance: ::protobuf::rt::LazyV2<TaskReview> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskReview::new)
    }
}

impl ::protobuf::Clear for TaskReview {
    fn clear(&mut self) {
        self.strategy = TaskReview_TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET;
        self.user_ids.clear();
        self.strategy_info = ::std::option::Option::None;
        self.strategy_info = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskReview {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskReview_TaskReviewStrategy {
    TASK_REVIEW_STRATEGY_NOT_SET = 0,
    NONE = 1,
    MANUAL = 2,
    CONSENSUS = 3,
}

impl ::protobuf::ProtobufEnum for TaskReview_TaskReviewStrategy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskReview_TaskReviewStrategy> {
        match value {
            0 => ::std::option::Option::Some(TaskReview_TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET),
            1 => ::std::option::Option::Some(TaskReview_TaskReviewStrategy::NONE),
            2 => ::std::option::Option::Some(TaskReview_TaskReviewStrategy::MANUAL),
            3 => ::std::option::Option::Some(TaskReview_TaskReviewStrategy::CONSENSUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskReview_TaskReviewStrategy] = &[
            TaskReview_TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET,
            TaskReview_TaskReviewStrategy::NONE,
            TaskReview_TaskReviewStrategy::MANUAL,
            TaskReview_TaskReviewStrategy::CONSENSUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TaskReview_TaskReviewStrategy>("TaskReview.TaskReviewStrategy", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TaskReview_TaskReviewStrategy {
}

impl ::std::default::Default for TaskReview_TaskReviewStrategy {
    fn default() -> Self {
        TaskReview_TaskReviewStrategy::TASK_REVIEW_STRATEGY_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskReview_TaskReviewStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskReviewManualStrategyInfo {
    // message fields
    pub sample_percentage: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskReviewManualStrategyInfo {
    fn default() -> &'a TaskReviewManualStrategyInfo {
        <TaskReviewManualStrategyInfo as ::protobuf::Message>::default_instance()
    }
}

impl TaskReviewManualStrategyInfo {
    pub fn new() -> TaskReviewManualStrategyInfo {
        ::std::default::Default::default()
    }

    // float sample_percentage = 1;


    pub fn get_sample_percentage(&self) -> f32 {
        self.sample_percentage
    }
    pub fn clear_sample_percentage(&mut self) {
        self.sample_percentage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_sample_percentage(&mut self, v: f32) {
        self.sample_percentage = v;
    }
}

impl ::protobuf::Message for TaskReviewManualStrategyInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.sample_percentage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sample_percentage != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sample_percentage != 0. {
            os.write_float(1, self.sample_percentage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskReviewManualStrategyInfo {
        TaskReviewManualStrategyInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "sample_percentage",
                |m: &TaskReviewManualStrategyInfo| { &m.sample_percentage },
                |m: &mut TaskReviewManualStrategyInfo| { &mut m.sample_percentage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskReviewManualStrategyInfo>(
                "TaskReviewManualStrategyInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskReviewManualStrategyInfo {
        static instance: ::protobuf::rt::LazyV2<TaskReviewManualStrategyInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskReviewManualStrategyInfo::new)
    }
}

impl ::protobuf::Clear for TaskReviewManualStrategyInfo {
    fn clear(&mut self) {
        self.sample_percentage = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskReviewManualStrategyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskReviewManualStrategyInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskReviewConsensusStrategyInfo {
    // message fields
    pub approval_threshold: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskReviewConsensusStrategyInfo {
    fn default() -> &'a TaskReviewConsensusStrategyInfo {
        <TaskReviewConsensusStrategyInfo as ::protobuf::Message>::default_instance()
    }
}

impl TaskReviewConsensusStrategyInfo {
    pub fn new() -> TaskReviewConsensusStrategyInfo {
        ::std::default::Default::default()
    }

    // uint32 approval_threshold = 2;


    pub fn get_approval_threshold(&self) -> u32 {
        self.approval_threshold
    }
    pub fn clear_approval_threshold(&mut self) {
        self.approval_threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_approval_threshold(&mut self, v: u32) {
        self.approval_threshold = v;
    }
}

impl ::protobuf::Message for TaskReviewConsensusStrategyInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.approval_threshold = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.approval_threshold != 0 {
            my_size += ::protobuf::rt::value_size(2, self.approval_threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.approval_threshold != 0 {
            os.write_uint32(2, self.approval_threshold)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskReviewConsensusStrategyInfo {
        TaskReviewConsensusStrategyInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "approval_threshold",
                |m: &TaskReviewConsensusStrategyInfo| { &m.approval_threshold },
                |m: &mut TaskReviewConsensusStrategyInfo| { &mut m.approval_threshold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskReviewConsensusStrategyInfo>(
                "TaskReviewConsensusStrategyInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskReviewConsensusStrategyInfo {
        static instance: ::protobuf::rt::LazyV2<TaskReviewConsensusStrategyInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskReviewConsensusStrategyInfo::new)
    }
}

impl ::protobuf::Clear for TaskReviewConsensusStrategyInfo {
    fn clear(&mut self) {
        self.approval_threshold = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskReviewConsensusStrategyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskReviewConsensusStrategyInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskAIAssistant {
    // message fields
    pub workflow_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskAIAssistant {
    fn default() -> &'a TaskAIAssistant {
        <TaskAIAssistant as ::protobuf::Message>::default_instance()
    }
}

impl TaskAIAssistant {
    pub fn new() -> TaskAIAssistant {
        ::std::default::Default::default()
    }

    // string workflow_id = 1;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TaskAIAssistant {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.workflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.workflow_id.is_empty() {
            os.write_string(1, &self.workflow_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskAIAssistant {
        TaskAIAssistant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &TaskAIAssistant| { &m.workflow_id },
                |m: &mut TaskAIAssistant| { &mut m.workflow_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskAIAssistant>(
                "TaskAIAssistant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskAIAssistant {
        static instance: ::protobuf::rt::LazyV2<TaskAIAssistant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskAIAssistant::new)
    }
}

impl ::protobuf::Clear for TaskAIAssistant {
    fn clear(&mut self) {
        self.workflow_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskAIAssistant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskAIAssistant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskStatusCountPerUser {
    // message fields
    pub user_id: ::std::string::String,
    pub pending: u32,
    pub awaiting_review: u32,
    pub success: u32,
    pub review_denied: u32,
    pub awaiting_consensus_review: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TaskStatusCountPerUser {
    fn default() -> &'a TaskStatusCountPerUser {
        <TaskStatusCountPerUser as ::protobuf::Message>::default_instance()
    }
}

impl TaskStatusCountPerUser {
    pub fn new() -> TaskStatusCountPerUser {
        ::std::default::Default::default()
    }

    // string user_id = 1;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // uint32 pending = 2;


    pub fn get_pending(&self) -> u32 {
        self.pending
    }
    pub fn clear_pending(&mut self) {
        self.pending = 0;
    }

    // Param is passed by value, moved
    pub fn set_pending(&mut self, v: u32) {
        self.pending = v;
    }

    // uint32 awaiting_review = 3;


    pub fn get_awaiting_review(&self) -> u32 {
        self.awaiting_review
    }
    pub fn clear_awaiting_review(&mut self) {
        self.awaiting_review = 0;
    }

    // Param is passed by value, moved
    pub fn set_awaiting_review(&mut self, v: u32) {
        self.awaiting_review = v;
    }

    // uint32 success = 4;


    pub fn get_success(&self) -> u32 {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = 0;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: u32) {
        self.success = v;
    }

    // uint32 review_denied = 5;


    pub fn get_review_denied(&self) -> u32 {
        self.review_denied
    }
    pub fn clear_review_denied(&mut self) {
        self.review_denied = 0;
    }

    // Param is passed by value, moved
    pub fn set_review_denied(&mut self, v: u32) {
        self.review_denied = v;
    }

    // uint32 awaiting_consensus_review = 6;


    pub fn get_awaiting_consensus_review(&self) -> u32 {
        self.awaiting_consensus_review
    }
    pub fn clear_awaiting_consensus_review(&mut self) {
        self.awaiting_consensus_review = 0;
    }

    // Param is passed by value, moved
    pub fn set_awaiting_consensus_review(&mut self, v: u32) {
        self.awaiting_consensus_review = v;
    }
}

impl ::protobuf::Message for TaskStatusCountPerUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pending = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.awaiting_review = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.success = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.review_denied = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.awaiting_consensus_review = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if self.pending != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pending, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.awaiting_review != 0 {
            my_size += ::protobuf::rt::value_size(3, self.awaiting_review, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.success != 0 {
            my_size += ::protobuf::rt::value_size(4, self.success, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.review_denied != 0 {
            my_size += ::protobuf::rt::value_size(5, self.review_denied, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.awaiting_consensus_review != 0 {
            my_size += ::protobuf::rt::value_size(6, self.awaiting_consensus_review, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if self.pending != 0 {
            os.write_uint32(2, self.pending)?;
        }
        if self.awaiting_review != 0 {
            os.write_uint32(3, self.awaiting_review)?;
        }
        if self.success != 0 {
            os.write_uint32(4, self.success)?;
        }
        if self.review_denied != 0 {
            os.write_uint32(5, self.review_denied)?;
        }
        if self.awaiting_consensus_review != 0 {
            os.write_uint32(6, self.awaiting_consensus_review)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskStatusCountPerUser {
        TaskStatusCountPerUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &TaskStatusCountPerUser| { &m.user_id },
                |m: &mut TaskStatusCountPerUser| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pending",
                |m: &TaskStatusCountPerUser| { &m.pending },
                |m: &mut TaskStatusCountPerUser| { &mut m.pending },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "awaiting_review",
                |m: &TaskStatusCountPerUser| { &m.awaiting_review },
                |m: &mut TaskStatusCountPerUser| { &mut m.awaiting_review },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "success",
                |m: &TaskStatusCountPerUser| { &m.success },
                |m: &mut TaskStatusCountPerUser| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "review_denied",
                |m: &TaskStatusCountPerUser| { &m.review_denied },
                |m: &mut TaskStatusCountPerUser| { &mut m.review_denied },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "awaiting_consensus_review",
                |m: &TaskStatusCountPerUser| { &m.awaiting_consensus_review },
                |m: &mut TaskStatusCountPerUser| { &mut m.awaiting_consensus_review },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TaskStatusCountPerUser>(
                "TaskStatusCountPerUser",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TaskStatusCountPerUser {
        static instance: ::protobuf::rt::LazyV2<TaskStatusCountPerUser> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TaskStatusCountPerUser::new)
    }
}

impl ::protobuf::Clear for TaskStatusCountPerUser {
    fn clear(&mut self) {
        self.user_id.clear();
        self.pending = 0;
        self.awaiting_review = 0;
        self.success = 0;
        self.review_denied = 0;
        self.awaiting_consensus_review = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskStatusCountPerUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskStatusCountPerUser {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Collector {
    // message fields
    pub id: ::std::string::String,
    pub description: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub pre_queue_workflow_id: ::std::string::String,
    pub post_queue_workflow_id: ::std::string::String,
    pub collector_source: ::protobuf::SingularPtrField<CollectorSource>,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Collector {
    fn default() -> &'a Collector {
        <Collector as ::protobuf::Message>::default_instance()
    }
}

impl Collector {
    pub fn new() -> Collector {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 3;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string pre_queue_workflow_id = 4;


    pub fn get_pre_queue_workflow_id(&self) -> &str {
        &self.pre_queue_workflow_id
    }
    pub fn clear_pre_queue_workflow_id(&mut self) {
        self.pre_queue_workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_pre_queue_workflow_id(&mut self, v: ::std::string::String) {
        self.pre_queue_workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_queue_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.pre_queue_workflow_id
    }

    // Take field
    pub fn take_pre_queue_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pre_queue_workflow_id, ::std::string::String::new())
    }

    // string post_queue_workflow_id = 5;


    pub fn get_post_queue_workflow_id(&self) -> &str {
        &self.post_queue_workflow_id
    }
    pub fn clear_post_queue_workflow_id(&mut self) {
        self.post_queue_workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_post_queue_workflow_id(&mut self, v: ::std::string::String) {
        self.post_queue_workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post_queue_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.post_queue_workflow_id
    }

    // Take field
    pub fn take_post_queue_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.post_queue_workflow_id, ::std::string::String::new())
    }

    // .clarifai.api.CollectorSource collector_source = 6;


    pub fn get_collector_source(&self) -> &CollectorSource {
        self.collector_source.as_ref().unwrap_or_else(|| <CollectorSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_collector_source(&mut self) {
        self.collector_source.clear();
    }

    pub fn has_collector_source(&self) -> bool {
        self.collector_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collector_source(&mut self, v: CollectorSource) {
        self.collector_source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collector_source(&mut self) -> &mut CollectorSource {
        if self.collector_source.is_none() {
            self.collector_source.set_default();
        }
        self.collector_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_collector_source(&mut self) -> CollectorSource {
        self.collector_source.take().unwrap_or_else(|| CollectorSource::new())
    }

    // .clarifai.api.status.Status status = 7;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }
}

impl ::protobuf::Message for Collector {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collector_source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pre_queue_workflow_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.post_queue_workflow_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.collector_source)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.pre_queue_workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pre_queue_workflow_id);
        }
        if !self.post_queue_workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.post_queue_workflow_id);
        }
        if let Some(ref v) = self.collector_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.pre_queue_workflow_id.is_empty() {
            os.write_string(4, &self.pre_queue_workflow_id)?;
        }
        if !self.post_queue_workflow_id.is_empty() {
            os.write_string(5, &self.post_queue_workflow_id)?;
        }
        if let Some(ref v) = self.collector_source.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Collector {
        Collector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Collector| { &m.id },
                |m: &mut Collector| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Collector| { &m.description },
                |m: &mut Collector| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &Collector| { &m.created_at },
                |m: &mut Collector| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pre_queue_workflow_id",
                |m: &Collector| { &m.pre_queue_workflow_id },
                |m: &mut Collector| { &mut m.pre_queue_workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "post_queue_workflow_id",
                |m: &Collector| { &m.post_queue_workflow_id },
                |m: &mut Collector| { &mut m.post_queue_workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CollectorSource>>(
                "collector_source",
                |m: &Collector| { &m.collector_source },
                |m: &mut Collector| { &mut m.collector_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &Collector| { &m.status },
                |m: &mut Collector| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Collector>(
                "Collector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Collector {
        static instance: ::protobuf::rt::LazyV2<Collector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Collector::new)
    }
}

impl ::protobuf::Clear for Collector {
    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.created_at.clear();
        self.pre_queue_workflow_id.clear();
        self.post_queue_workflow_id.clear();
        self.collector_source.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Collector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CollectorSource {
    // message fields
    pub api_post_model_outputs_collector_source: ::protobuf::SingularPtrField<APIPostModelOutputsCollectorSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CollectorSource {
    fn default() -> &'a CollectorSource {
        <CollectorSource as ::protobuf::Message>::default_instance()
    }
}

impl CollectorSource {
    pub fn new() -> CollectorSource {
        ::std::default::Default::default()
    }

    // .clarifai.api.APIPostModelOutputsCollectorSource api_post_model_outputs_collector_source = 2;


    pub fn get_api_post_model_outputs_collector_source(&self) -> &APIPostModelOutputsCollectorSource {
        self.api_post_model_outputs_collector_source.as_ref().unwrap_or_else(|| <APIPostModelOutputsCollectorSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_api_post_model_outputs_collector_source(&mut self) {
        self.api_post_model_outputs_collector_source.clear();
    }

    pub fn has_api_post_model_outputs_collector_source(&self) -> bool {
        self.api_post_model_outputs_collector_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_api_post_model_outputs_collector_source(&mut self, v: APIPostModelOutputsCollectorSource) {
        self.api_post_model_outputs_collector_source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_api_post_model_outputs_collector_source(&mut self) -> &mut APIPostModelOutputsCollectorSource {
        if self.api_post_model_outputs_collector_source.is_none() {
            self.api_post_model_outputs_collector_source.set_default();
        }
        self.api_post_model_outputs_collector_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_api_post_model_outputs_collector_source(&mut self) -> APIPostModelOutputsCollectorSource {
        self.api_post_model_outputs_collector_source.take().unwrap_or_else(|| APIPostModelOutputsCollectorSource::new())
    }
}

impl ::protobuf::Message for CollectorSource {
    fn is_initialized(&self) -> bool {
        for v in &self.api_post_model_outputs_collector_source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.api_post_model_outputs_collector_source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.api_post_model_outputs_collector_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.api_post_model_outputs_collector_source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CollectorSource {
        CollectorSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<APIPostModelOutputsCollectorSource>>(
                "api_post_model_outputs_collector_source",
                |m: &CollectorSource| { &m.api_post_model_outputs_collector_source },
                |m: &mut CollectorSource| { &mut m.api_post_model_outputs_collector_source },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CollectorSource>(
                "CollectorSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CollectorSource {
        static instance: ::protobuf::rt::LazyV2<CollectorSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CollectorSource::new)
    }
}

impl ::protobuf::Clear for CollectorSource {
    fn clear(&mut self) {
        self.api_post_model_outputs_collector_source.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CollectorSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectorSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct APIPostModelOutputsCollectorSource {
    // message fields
    pub model_user_id: ::std::string::String,
    pub model_app_id: ::std::string::String,
    pub model_id: ::std::string::String,
    pub model_version_id: ::std::string::String,
    pub post_inputs_key_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a APIPostModelOutputsCollectorSource {
    fn default() -> &'a APIPostModelOutputsCollectorSource {
        <APIPostModelOutputsCollectorSource as ::protobuf::Message>::default_instance()
    }
}

impl APIPostModelOutputsCollectorSource {
    pub fn new() -> APIPostModelOutputsCollectorSource {
        ::std::default::Default::default()
    }

    // string model_user_id = 1;


    pub fn get_model_user_id(&self) -> &str {
        &self.model_user_id
    }
    pub fn clear_model_user_id(&mut self) {
        self.model_user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_user_id(&mut self, v: ::std::string::String) {
        self.model_user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_user_id
    }

    // Take field
    pub fn take_model_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_user_id, ::std::string::String::new())
    }

    // string model_app_id = 2;


    pub fn get_model_app_id(&self) -> &str {
        &self.model_app_id
    }
    pub fn clear_model_app_id(&mut self) {
        self.model_app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_app_id(&mut self, v: ::std::string::String) {
        self.model_app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_app_id
    }

    // Take field
    pub fn take_model_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_app_id, ::std::string::String::new())
    }

    // string model_id = 3;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string model_version_id = 4;


    pub fn get_model_version_id(&self) -> &str {
        &self.model_version_id
    }
    pub fn clear_model_version_id(&mut self) {
        self.model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_id(&mut self, v: ::std::string::String) {
        self.model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_version_id
    }

    // Take field
    pub fn take_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_version_id, ::std::string::String::new())
    }

    // string post_inputs_key_id = 5;


    pub fn get_post_inputs_key_id(&self) -> &str {
        &self.post_inputs_key_id
    }
    pub fn clear_post_inputs_key_id(&mut self) {
        self.post_inputs_key_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_post_inputs_key_id(&mut self, v: ::std::string::String) {
        self.post_inputs_key_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post_inputs_key_id(&mut self) -> &mut ::std::string::String {
        &mut self.post_inputs_key_id
    }

    // Take field
    pub fn take_post_inputs_key_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.post_inputs_key_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for APIPostModelOutputsCollectorSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_version_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.post_inputs_key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.model_user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.model_user_id);
        }
        if !self.model_app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_app_id);
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.model_version_id);
        }
        if !self.post_inputs_key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.post_inputs_key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.model_user_id.is_empty() {
            os.write_string(1, &self.model_user_id)?;
        }
        if !self.model_app_id.is_empty() {
            os.write_string(2, &self.model_app_id)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(3, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(4, &self.model_version_id)?;
        }
        if !self.post_inputs_key_id.is_empty() {
            os.write_string(5, &self.post_inputs_key_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> APIPostModelOutputsCollectorSource {
        APIPostModelOutputsCollectorSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_user_id",
                |m: &APIPostModelOutputsCollectorSource| { &m.model_user_id },
                |m: &mut APIPostModelOutputsCollectorSource| { &mut m.model_user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_app_id",
                |m: &APIPostModelOutputsCollectorSource| { &m.model_app_id },
                |m: &mut APIPostModelOutputsCollectorSource| { &mut m.model_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &APIPostModelOutputsCollectorSource| { &m.model_id },
                |m: &mut APIPostModelOutputsCollectorSource| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_id",
                |m: &APIPostModelOutputsCollectorSource| { &m.model_version_id },
                |m: &mut APIPostModelOutputsCollectorSource| { &mut m.model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "post_inputs_key_id",
                |m: &APIPostModelOutputsCollectorSource| { &m.post_inputs_key_id },
                |m: &mut APIPostModelOutputsCollectorSource| { &mut m.post_inputs_key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<APIPostModelOutputsCollectorSource>(
                "APIPostModelOutputsCollectorSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static APIPostModelOutputsCollectorSource {
        static instance: ::protobuf::rt::LazyV2<APIPostModelOutputsCollectorSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(APIPostModelOutputsCollectorSource::new)
    }
}

impl ::protobuf::Clear for APIPostModelOutputsCollectorSource {
    fn clear(&mut self) {
        self.model_user_id.clear();
        self.model_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.post_inputs_key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for APIPostModelOutputsCollectorSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIPostModelOutputsCollectorSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatValue {
    // message fields
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub value: f32,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatValue {
    fn default() -> &'a StatValue {
        <StatValue as ::protobuf::Message>::default_instance()
    }
}

impl StatValue {
    pub fn new() -> StatValue {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp time = 1;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // float value = 2;


    pub fn get_value(&self) -> f32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = v;
    }

    // repeated string tags = 3;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StatValue {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.value != 0. {
            my_size += 5;
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.value != 0. {
            os.write_float(2, self.value)?;
        }
        for v in &self.tags {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatValue {
        StatValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time",
                |m: &StatValue| { &m.time },
                |m: &mut StatValue| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &StatValue| { &m.value },
                |m: &mut StatValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &StatValue| { &m.tags },
                |m: &mut StatValue| { &mut m.tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatValue>(
                "StatValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatValue {
        static instance: ::protobuf::rt::LazyV2<StatValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatValue::new)
    }
}

impl ::protobuf::Clear for StatValue {
    fn clear(&mut self) {
        self.time.clear();
        self.value = 0.;
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatValueAggregateResult {
    // message fields
    pub stat_value_aggregates: ::protobuf::RepeatedField<StatValueAggregate>,
    pub stat_value_aggregate_query: ::protobuf::SingularPtrField<StatValueAggregateQuery>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatValueAggregateResult {
    fn default() -> &'a StatValueAggregateResult {
        <StatValueAggregateResult as ::protobuf::Message>::default_instance()
    }
}

impl StatValueAggregateResult {
    pub fn new() -> StatValueAggregateResult {
        ::std::default::Default::default()
    }

    // repeated .clarifai.api.StatValueAggregate stat_value_aggregates = 1;


    pub fn get_stat_value_aggregates(&self) -> &[StatValueAggregate] {
        &self.stat_value_aggregates
    }
    pub fn clear_stat_value_aggregates(&mut self) {
        self.stat_value_aggregates.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_value_aggregates(&mut self, v: ::protobuf::RepeatedField<StatValueAggregate>) {
        self.stat_value_aggregates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_value_aggregates(&mut self) -> &mut ::protobuf::RepeatedField<StatValueAggregate> {
        &mut self.stat_value_aggregates
    }

    // Take field
    pub fn take_stat_value_aggregates(&mut self) -> ::protobuf::RepeatedField<StatValueAggregate> {
        ::std::mem::replace(&mut self.stat_value_aggregates, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.StatValueAggregateQuery stat_value_aggregate_query = 2;


    pub fn get_stat_value_aggregate_query(&self) -> &StatValueAggregateQuery {
        self.stat_value_aggregate_query.as_ref().unwrap_or_else(|| <StatValueAggregateQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stat_value_aggregate_query(&mut self) {
        self.stat_value_aggregate_query.clear();
    }

    pub fn has_stat_value_aggregate_query(&self) -> bool {
        self.stat_value_aggregate_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value_aggregate_query(&mut self, v: StatValueAggregateQuery) {
        self.stat_value_aggregate_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat_value_aggregate_query(&mut self) -> &mut StatValueAggregateQuery {
        if self.stat_value_aggregate_query.is_none() {
            self.stat_value_aggregate_query.set_default();
        }
        self.stat_value_aggregate_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat_value_aggregate_query(&mut self) -> StatValueAggregateQuery {
        self.stat_value_aggregate_query.take().unwrap_or_else(|| StatValueAggregateQuery::new())
    }
}

impl ::protobuf::Message for StatValueAggregateResult {
    fn is_initialized(&self) -> bool {
        for v in &self.stat_value_aggregates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_value_aggregate_query {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_value_aggregates)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat_value_aggregate_query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stat_value_aggregates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.stat_value_aggregate_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stat_value_aggregates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.stat_value_aggregate_query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatValueAggregateResult {
        StatValueAggregateResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatValueAggregate>>(
                "stat_value_aggregates",
                |m: &StatValueAggregateResult| { &m.stat_value_aggregates },
                |m: &mut StatValueAggregateResult| { &mut m.stat_value_aggregates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatValueAggregateQuery>>(
                "stat_value_aggregate_query",
                |m: &StatValueAggregateResult| { &m.stat_value_aggregate_query },
                |m: &mut StatValueAggregateResult| { &mut m.stat_value_aggregate_query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatValueAggregateResult>(
                "StatValueAggregateResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatValueAggregateResult {
        static instance: ::protobuf::rt::LazyV2<StatValueAggregateResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatValueAggregateResult::new)
    }
}

impl ::protobuf::Clear for StatValueAggregateResult {
    fn clear(&mut self) {
        self.stat_value_aggregates.clear();
        self.stat_value_aggregate_query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatValueAggregateResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValueAggregateResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatValueAggregate {
    // message fields
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub aggregate_value: f32,
    pub count: u64,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatValueAggregate {
    fn default() -> &'a StatValueAggregate {
        <StatValueAggregate as ::protobuf::Message>::default_instance()
    }
}

impl StatValueAggregate {
    pub fn new() -> StatValueAggregate {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp time = 1;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // float aggregate_value = 2;


    pub fn get_aggregate_value(&self) -> f32 {
        self.aggregate_value
    }
    pub fn clear_aggregate_value(&mut self) {
        self.aggregate_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_aggregate_value(&mut self, v: f32) {
        self.aggregate_value = v;
    }

    // uint64 count = 3;


    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }

    // repeated string tags = 4;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StatValueAggregate {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.aggregate_value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.aggregate_value != 0. {
            my_size += 5;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.aggregate_value != 0. {
            os.write_float(2, self.aggregate_value)?;
        }
        if self.count != 0 {
            os.write_uint64(3, self.count)?;
        }
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatValueAggregate {
        StatValueAggregate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time",
                |m: &StatValueAggregate| { &m.time },
                |m: &mut StatValueAggregate| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "aggregate_value",
                |m: &StatValueAggregate| { &m.aggregate_value },
                |m: &mut StatValueAggregate| { &mut m.aggregate_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "count",
                |m: &StatValueAggregate| { &m.count },
                |m: &mut StatValueAggregate| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &StatValueAggregate| { &m.tags },
                |m: &mut StatValueAggregate| { &mut m.tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatValueAggregate>(
                "StatValueAggregate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatValueAggregate {
        static instance: ::protobuf::rt::LazyV2<StatValueAggregate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatValueAggregate::new)
    }
}

impl ::protobuf::Clear for StatValueAggregate {
    fn clear(&mut self) {
        self.time.clear();
        self.aggregate_value = 0.;
        self.count = 0;
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatValueAggregate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValueAggregate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatValueAggregateQuery {
    // message fields
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub tag_groups: ::protobuf::RepeatedField<::std::string::String>,
    pub stat_value_agg_type: StatValueAggType,
    pub stat_time_agg_type: StatTimeAggType,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatValueAggregateQuery {
    fn default() -> &'a StatValueAggregateQuery {
        <StatValueAggregateQuery as ::protobuf::Message>::default_instance()
    }
}

impl StatValueAggregateQuery {
    pub fn new() -> StatValueAggregateQuery {
        ::std::default::Default::default()
    }

    // repeated string tags = 1;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // repeated string tag_groups = 2;


    pub fn get_tag_groups(&self) -> &[::std::string::String] {
        &self.tag_groups
    }
    pub fn clear_tag_groups(&mut self) {
        self.tag_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag_groups(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tag_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tag_groups(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tag_groups
    }

    // Take field
    pub fn take_tag_groups(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tag_groups, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.StatValueAggType stat_value_agg_type = 3;


    pub fn get_stat_value_agg_type(&self) -> StatValueAggType {
        self.stat_value_agg_type
    }
    pub fn clear_stat_value_agg_type(&mut self) {
        self.stat_value_agg_type = StatValueAggType::SUM;
    }

    // Param is passed by value, moved
    pub fn set_stat_value_agg_type(&mut self, v: StatValueAggType) {
        self.stat_value_agg_type = v;
    }

    // .clarifai.api.StatTimeAggType stat_time_agg_type = 4;


    pub fn get_stat_time_agg_type(&self) -> StatTimeAggType {
        self.stat_time_agg_type
    }
    pub fn clear_stat_time_agg_type(&mut self) {
        self.stat_time_agg_type = StatTimeAggType::NO_TIME_AGG;
    }

    // Param is passed by value, moved
    pub fn set_stat_time_agg_type(&mut self, v: StatTimeAggType) {
        self.stat_time_agg_type = v;
    }

    // .google.protobuf.Timestamp start_time = 5;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 6;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for StatValueAggregateQuery {
    fn is_initialized(&self) -> bool {
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tag_groups)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stat_value_agg_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stat_time_agg_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.tag_groups {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.stat_value_agg_type != StatValueAggType::SUM {
            my_size += ::protobuf::rt::enum_size(3, self.stat_value_agg_type);
        }
        if self.stat_time_agg_type != StatTimeAggType::NO_TIME_AGG {
            my_size += ::protobuf::rt::enum_size(4, self.stat_time_agg_type);
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tags {
            os.write_string(1, &v)?;
        };
        for v in &self.tag_groups {
            os.write_string(2, &v)?;
        };
        if self.stat_value_agg_type != StatValueAggType::SUM {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.stat_value_agg_type))?;
        }
        if self.stat_time_agg_type != StatTimeAggType::NO_TIME_AGG {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.stat_time_agg_type))?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatValueAggregateQuery {
        StatValueAggregateQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &StatValueAggregateQuery| { &m.tags },
                |m: &mut StatValueAggregateQuery| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag_groups",
                |m: &StatValueAggregateQuery| { &m.tag_groups },
                |m: &mut StatValueAggregateQuery| { &mut m.tag_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatValueAggType>>(
                "stat_value_agg_type",
                |m: &StatValueAggregateQuery| { &m.stat_value_agg_type },
                |m: &mut StatValueAggregateQuery| { &mut m.stat_value_agg_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatTimeAggType>>(
                "stat_time_agg_type",
                |m: &StatValueAggregateQuery| { &m.stat_time_agg_type },
                |m: &mut StatValueAggregateQuery| { &mut m.stat_time_agg_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &StatValueAggregateQuery| { &m.start_time },
                |m: &mut StatValueAggregateQuery| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &StatValueAggregateQuery| { &m.end_time },
                |m: &mut StatValueAggregateQuery| { &mut m.end_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatValueAggregateQuery>(
                "StatValueAggregateQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatValueAggregateQuery {
        static instance: ::protobuf::rt::LazyV2<StatValueAggregateQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatValueAggregateQuery::new)
    }
}

impl ::protobuf::Clear for StatValueAggregateQuery {
    fn clear(&mut self) {
        self.tags.clear();
        self.tag_groups.clear();
        self.stat_value_agg_type = StatValueAggType::SUM;
        self.stat_time_agg_type = StatTimeAggType::NO_TIME_AGG;
        self.start_time.clear();
        self.end_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatValueAggregateQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValueAggregateQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Visibility {
    // message fields
    pub gettable: Visibility_Gettable,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Visibility {
    fn default() -> &'a Visibility {
        <Visibility as ::protobuf::Message>::default_instance()
    }
}

impl Visibility {
    pub fn new() -> Visibility {
        ::std::default::Default::default()
    }

    // .clarifai.api.Visibility.Gettable gettable = 1;


    pub fn get_gettable(&self) -> Visibility_Gettable {
        self.gettable
    }
    pub fn clear_gettable(&mut self) {
        self.gettable = Visibility_Gettable::UNKNOWN_VISIBILITY;
    }

    // Param is passed by value, moved
    pub fn set_gettable(&mut self, v: Visibility_Gettable) {
        self.gettable = v;
    }
}

impl ::protobuf::Message for Visibility {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.gettable, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gettable != Visibility_Gettable::UNKNOWN_VISIBILITY {
            my_size += ::protobuf::rt::enum_size(1, self.gettable);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.gettable != Visibility_Gettable::UNKNOWN_VISIBILITY {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.gettable))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Visibility {
        Visibility::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Visibility_Gettable>>(
                "gettable",
                |m: &Visibility| { &m.gettable },
                |m: &mut Visibility| { &mut m.gettable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Visibility>(
                "Visibility",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Visibility {
        static instance: ::protobuf::rt::LazyV2<Visibility> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Visibility::new)
    }
}

impl ::protobuf::Clear for Visibility {
    fn clear(&mut self) {
        self.gettable = Visibility_Gettable::UNKNOWN_VISIBILITY;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Visibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Visibility {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Visibility_Gettable {
    UNKNOWN_VISIBILITY = 0,
    PRIVATE = 10,
    ORG = 30,
    PUBLIC = 50,
}

impl ::protobuf::ProtobufEnum for Visibility_Gettable {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Visibility_Gettable> {
        match value {
            0 => ::std::option::Option::Some(Visibility_Gettable::UNKNOWN_VISIBILITY),
            10 => ::std::option::Option::Some(Visibility_Gettable::PRIVATE),
            30 => ::std::option::Option::Some(Visibility_Gettable::ORG),
            50 => ::std::option::Option::Some(Visibility_Gettable::PUBLIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Visibility_Gettable] = &[
            Visibility_Gettable::UNKNOWN_VISIBILITY,
            Visibility_Gettable::PRIVATE,
            Visibility_Gettable::ORG,
            Visibility_Gettable::PUBLIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Visibility_Gettable>("Visibility.Gettable", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Visibility_Gettable {
}

impl ::std::default::Default for Visibility_Gettable {
    fn default() -> Self {
        Visibility_Gettable::UNKNOWN_VISIBILITY
    }
}

impl ::protobuf::reflect::ProtobufValue for Visibility_Gettable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrendingMetric {
    // message fields
    pub user_id: ::std::string::String,
    pub app_id: ::std::string::String,
    pub object_id: ::std::string::String,
    pub view_count: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrendingMetric {
    fn default() -> &'a TrendingMetric {
        <TrendingMetric as ::protobuf::Message>::default_instance()
    }
}

impl TrendingMetric {
    pub fn new() -> TrendingMetric {
        ::std::default::Default::default()
    }

    // string user_id = 1;


    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }
    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    // string app_id = 2;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string object_id = 3;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // uint64 view_count = 4;


    pub fn get_view_count(&self) -> u64 {
        self.view_count
    }
    pub fn clear_view_count(&mut self) {
        self.view_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_view_count(&mut self, v: u64) {
        self.view_count = v;
    }
}

impl ::protobuf::Message for TrendingMetric {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.view_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object_id);
        }
        if self.view_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.view_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if !self.object_id.is_empty() {
            os.write_string(3, &self.object_id)?;
        }
        if self.view_count != 0 {
            os.write_uint64(4, self.view_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrendingMetric {
        TrendingMetric::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_id",
                |m: &TrendingMetric| { &m.user_id },
                |m: &mut TrendingMetric| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &TrendingMetric| { &m.app_id },
                |m: &mut TrendingMetric| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &TrendingMetric| { &m.object_id },
                |m: &mut TrendingMetric| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "view_count",
                |m: &TrendingMetric| { &m.view_count },
                |m: &mut TrendingMetric| { &mut m.view_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrendingMetric>(
                "TrendingMetric",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrendingMetric {
        static instance: ::protobuf::rt::LazyV2<TrendingMetric> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrendingMetric::new)
    }
}

impl ::protobuf::Clear for TrendingMetric {
    fn clear(&mut self) {
        self.user_id.clear();
        self.app_id.clear();
        self.object_id.clear();
        self.view_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrendingMetric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrendingMetric {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeSegment {
    // message fields
    pub id: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<Data>,
    pub time_info: ::protobuf::SingularPtrField<TimeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeSegment {
    fn default() -> &'a TimeSegment {
        <TimeSegment as ::protobuf::Message>::default_instance()
    }
}

impl TimeSegment {
    pub fn new() -> TimeSegment {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Data data = 2;


    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| <Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    // .clarifai.api.TimeInfo time_info = 3;


    pub fn get_time_info(&self) -> &TimeInfo {
        self.time_info.as_ref().unwrap_or_else(|| <TimeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_info(&mut self) {
        self.time_info.clear();
    }

    pub fn has_time_info(&self) -> bool {
        self.time_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_info(&mut self, v: TimeInfo) {
        self.time_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_info(&mut self) -> &mut TimeInfo {
        if self.time_info.is_none() {
            self.time_info.set_default();
        }
        self.time_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_info(&mut self) -> TimeInfo {
        self.time_info.take().unwrap_or_else(|| TimeInfo::new())
    }
}

impl ::protobuf::Message for TimeSegment {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeSegment {
        TimeSegment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &TimeSegment| { &m.id },
                |m: &mut TimeSegment| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                "data",
                |m: &TimeSegment| { &m.data },
                |m: &mut TimeSegment| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeInfo>>(
                "time_info",
                |m: &TimeSegment| { &m.time_info },
                |m: &mut TimeSegment| { &mut m.time_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeSegment>(
                "TimeSegment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeSegment {
        static instance: ::protobuf::rt::LazyV2<TimeSegment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeSegment::new)
    }
}

impl ::protobuf::Clear for TimeSegment {
    fn clear(&mut self) {
        self.id.clear();
        self.data.clear();
        self.time_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeSegment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeSegment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeInfo {
    // message fields
    pub num_frames: u32,
    pub begin_time: u32,
    pub end_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeInfo {
    fn default() -> &'a TimeInfo {
        <TimeInfo as ::protobuf::Message>::default_instance()
    }
}

impl TimeInfo {
    pub fn new() -> TimeInfo {
        ::std::default::Default::default()
    }

    // uint32 num_frames = 1;


    pub fn get_num_frames(&self) -> u32 {
        self.num_frames
    }
    pub fn clear_num_frames(&mut self) {
        self.num_frames = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_frames(&mut self, v: u32) {
        self.num_frames = v;
    }

    // uint32 begin_time = 2;


    pub fn get_begin_time(&self) -> u32 {
        self.begin_time
    }
    pub fn clear_begin_time(&mut self) {
        self.begin_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_begin_time(&mut self, v: u32) {
        self.begin_time = v;
    }

    // uint32 end_time = 3;


    pub fn get_end_time(&self) -> u32 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = v;
    }
}

impl ::protobuf::Message for TimeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_frames = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.begin_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_frames != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_frames, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.begin_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.begin_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.end_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_frames != 0 {
            os.write_uint32(1, self.num_frames)?;
        }
        if self.begin_time != 0 {
            os.write_uint32(2, self.begin_time)?;
        }
        if self.end_time != 0 {
            os.write_uint32(3, self.end_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeInfo {
        TimeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_frames",
                |m: &TimeInfo| { &m.num_frames },
                |m: &mut TimeInfo| { &mut m.num_frames },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "begin_time",
                |m: &TimeInfo| { &m.begin_time },
                |m: &mut TimeInfo| { &mut m.begin_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "end_time",
                |m: &TimeInfo| { &m.end_time },
                |m: &mut TimeInfo| { &mut m.end_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeInfo>(
                "TimeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeInfo {
        static instance: ::protobuf::rt::LazyV2<TimeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeInfo::new)
    }
}

impl ::protobuf::Clear for TimeInfo {
    fn clear(&mut self) {
        self.num_frames = 0;
        self.begin_time = 0;
        self.end_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExpirationAction {
    EXPIRATION_ACTION_NOT_SET = 0,
    DELAY = 1,
    EXPIRY = 2,
}

impl ::protobuf::ProtobufEnum for ExpirationAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExpirationAction> {
        match value {
            0 => ::std::option::Option::Some(ExpirationAction::EXPIRATION_ACTION_NOT_SET),
            1 => ::std::option::Option::Some(ExpirationAction::DELAY),
            2 => ::std::option::Option::Some(ExpirationAction::EXPIRY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExpirationAction] = &[
            ExpirationAction::EXPIRATION_ACTION_NOT_SET,
            ExpirationAction::DELAY,
            ExpirationAction::EXPIRY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExpirationAction>("ExpirationAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExpirationAction {
}

impl ::std::default::Default for ExpirationAction {
    fn default() -> Self {
        ExpirationAction::EXPIRATION_ACTION_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpirationAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LicenseScope {
    LICENSE_SCOPE_NOT_SET = 0,
    PREDICT = 1,
    TRAIN = 2,
    SEARCH = 3,
}

impl ::protobuf::ProtobufEnum for LicenseScope {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LicenseScope> {
        match value {
            0 => ::std::option::Option::Some(LicenseScope::LICENSE_SCOPE_NOT_SET),
            1 => ::std::option::Option::Some(LicenseScope::PREDICT),
            2 => ::std::option::Option::Some(LicenseScope::TRAIN),
            3 => ::std::option::Option::Some(LicenseScope::SEARCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LicenseScope] = &[
            LicenseScope::LICENSE_SCOPE_NOT_SET,
            LicenseScope::PREDICT,
            LicenseScope::TRAIN,
            LicenseScope::SEARCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LicenseScope>("LicenseScope", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LicenseScope {
}

impl ::std::default::Default for LicenseScope {
    fn default() -> Self {
        LicenseScope::LICENSE_SCOPE_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for LicenseScope {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ValueComparator {
    CONCEPT_THRESHOLD_NOT_SET = 0,
    GREATER_THAN = 1,
    GREATER_THAN_OR_EQUAL = 2,
    LESS_THAN = 3,
    LESS_THAN_OR_EQUAL = 4,
    EQUAL = 5,
}

impl ::protobuf::ProtobufEnum for ValueComparator {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValueComparator> {
        match value {
            0 => ::std::option::Option::Some(ValueComparator::CONCEPT_THRESHOLD_NOT_SET),
            1 => ::std::option::Option::Some(ValueComparator::GREATER_THAN),
            2 => ::std::option::Option::Some(ValueComparator::GREATER_THAN_OR_EQUAL),
            3 => ::std::option::Option::Some(ValueComparator::LESS_THAN),
            4 => ::std::option::Option::Some(ValueComparator::LESS_THAN_OR_EQUAL),
            5 => ::std::option::Option::Some(ValueComparator::EQUAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ValueComparator] = &[
            ValueComparator::CONCEPT_THRESHOLD_NOT_SET,
            ValueComparator::GREATER_THAN,
            ValueComparator::GREATER_THAN_OR_EQUAL,
            ValueComparator::LESS_THAN,
            ValueComparator::LESS_THAN_OR_EQUAL,
            ValueComparator::EQUAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ValueComparator>("ValueComparator", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ValueComparator {
}

impl ::std::default::Default for ValueComparator {
    fn default() -> Self {
        ValueComparator::CONCEPT_THRESHOLD_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueComparator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EvaluationType {
    Classification = 0,
    Detection = 1,
}

impl ::protobuf::ProtobufEnum for EvaluationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EvaluationType> {
        match value {
            0 => ::std::option::Option::Some(EvaluationType::Classification),
            1 => ::std::option::Option::Some(EvaluationType::Detection),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EvaluationType] = &[
            EvaluationType::Classification,
            EvaluationType::Detection,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EvaluationType>("EvaluationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EvaluationType {
}

impl ::std::default::Default for EvaluationType {
    fn default() -> Self {
        EvaluationType::Classification
    }
}

impl ::protobuf::reflect::ProtobufValue for EvaluationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum APIEventType {
    API_EVENT_TYPE_NOT_SET = 0,
    ON_PREM_PREDICT = 1,
    ON_PREM_TRAIN = 2,
    ON_PREM_SEARCH = 3,
}

impl ::protobuf::ProtobufEnum for APIEventType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<APIEventType> {
        match value {
            0 => ::std::option::Option::Some(APIEventType::API_EVENT_TYPE_NOT_SET),
            1 => ::std::option::Option::Some(APIEventType::ON_PREM_PREDICT),
            2 => ::std::option::Option::Some(APIEventType::ON_PREM_TRAIN),
            3 => ::std::option::Option::Some(APIEventType::ON_PREM_SEARCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [APIEventType] = &[
            APIEventType::API_EVENT_TYPE_NOT_SET,
            APIEventType::ON_PREM_PREDICT,
            APIEventType::ON_PREM_TRAIN,
            APIEventType::ON_PREM_SEARCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<APIEventType>("APIEventType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for APIEventType {
}

impl ::std::default::Default for APIEventType {
    fn default() -> Self {
        APIEventType::API_EVENT_TYPE_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for APIEventType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UsageIntervalType {
    undef = 0,
    day = 1,
    month = 2,
    year = 3,
}

impl ::protobuf::ProtobufEnum for UsageIntervalType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UsageIntervalType> {
        match value {
            0 => ::std::option::Option::Some(UsageIntervalType::undef),
            1 => ::std::option::Option::Some(UsageIntervalType::day),
            2 => ::std::option::Option::Some(UsageIntervalType::month),
            3 => ::std::option::Option::Some(UsageIntervalType::year),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UsageIntervalType] = &[
            UsageIntervalType::undef,
            UsageIntervalType::day,
            UsageIntervalType::month,
            UsageIntervalType::year,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UsageIntervalType>("UsageIntervalType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UsageIntervalType {
}

impl ::std::default::Default for UsageIntervalType {
    fn default() -> Self {
        UsageIntervalType::undef
    }
}

impl ::protobuf::reflect::ProtobufValue for UsageIntervalType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RoleType {
    TEAM = 0,
    ORG = 1,
}

impl ::protobuf::ProtobufEnum for RoleType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RoleType> {
        match value {
            0 => ::std::option::Option::Some(RoleType::TEAM),
            1 => ::std::option::Option::Some(RoleType::ORG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RoleType] = &[
            RoleType::TEAM,
            RoleType::ORG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RoleType>("RoleType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RoleType {
}

impl ::std::default::Default for RoleType {
    fn default() -> Self {
        RoleType::TEAM
    }
}

impl ::protobuf::reflect::ProtobufValue for RoleType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StatValueAggType {
    SUM = 0,
    AVG = 1,
}

impl ::protobuf::ProtobufEnum for StatValueAggType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatValueAggType> {
        match value {
            0 => ::std::option::Option::Some(StatValueAggType::SUM),
            1 => ::std::option::Option::Some(StatValueAggType::AVG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StatValueAggType] = &[
            StatValueAggType::SUM,
            StatValueAggType::AVG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StatValueAggType>("StatValueAggType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StatValueAggType {
}

impl ::std::default::Default for StatValueAggType {
    fn default() -> Self {
        StatValueAggType::SUM
    }
}

impl ::protobuf::reflect::ProtobufValue for StatValueAggType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StatTimeAggType {
    NO_TIME_AGG = 0,
    YEAR = 1,
    MONTH = 2,
    WEEK = 3,
    DAY = 4,
    HOUR = 5,
    MINUTE = 6,
}

impl ::protobuf::ProtobufEnum for StatTimeAggType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatTimeAggType> {
        match value {
            0 => ::std::option::Option::Some(StatTimeAggType::NO_TIME_AGG),
            1 => ::std::option::Option::Some(StatTimeAggType::YEAR),
            2 => ::std::option::Option::Some(StatTimeAggType::MONTH),
            3 => ::std::option::Option::Some(StatTimeAggType::WEEK),
            4 => ::std::option::Option::Some(StatTimeAggType::DAY),
            5 => ::std::option::Option::Some(StatTimeAggType::HOUR),
            6 => ::std::option::Option::Some(StatTimeAggType::MINUTE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StatTimeAggType] = &[
            StatTimeAggType::NO_TIME_AGG,
            StatTimeAggType::YEAR,
            StatTimeAggType::MONTH,
            StatTimeAggType::WEEK,
            StatTimeAggType::DAY,
            StatTimeAggType::HOUR,
            StatTimeAggType::MINUTE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StatTimeAggType>("StatTimeAggType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StatTimeAggType {
}

impl ::std::default::Default for StatTimeAggType {
    fn default() -> Self {
        StatTimeAggType::NO_TIME_AGG
    }
}

impl ::protobuf::reflect::ProtobufValue for StatTimeAggType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ValidationErrorType {
    VALIDATION_ERROR_TYPE_NOT_SET = 0,
    RESTRICTED = 1,
    DATABASE = 2,
    FORMAT = 3,
}

impl ::protobuf::ProtobufEnum for ValidationErrorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValidationErrorType> {
        match value {
            0 => ::std::option::Option::Some(ValidationErrorType::VALIDATION_ERROR_TYPE_NOT_SET),
            1 => ::std::option::Option::Some(ValidationErrorType::RESTRICTED),
            2 => ::std::option::Option::Some(ValidationErrorType::DATABASE),
            3 => ::std::option::Option::Some(ValidationErrorType::FORMAT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ValidationErrorType] = &[
            ValidationErrorType::VALIDATION_ERROR_TYPE_NOT_SET,
            ValidationErrorType::RESTRICTED,
            ValidationErrorType::DATABASE,
            ValidationErrorType::FORMAT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ValidationErrorType>("ValidationErrorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ValidationErrorType {
}

impl ::std::default::Default for ValidationErrorType {
    fn default() -> Self {
        ValidationErrorType::VALIDATION_ERROR_TYPE_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidationErrorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"proto/clarifai/api/resources.proto\x12\x0cclarifai.api\x1a&proto/cla\
    rifai/api/status/status.proto\x1a)proto/clarifai/api/utils/extensions.pr\
    oto\x1a(proto/clarifai/auth/util/extension.proto\x1a\x1cgoogle/protobuf/\
    struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\x80\x05\n\nAnnotat\
    ion\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\n\x08input_id\x18\
    \x02\x20\x01(\tR\x07inputId\x12&\n\x04data\x18\x03\x20\x01(\x0b2\x12.cla\
    rifai.api.DataR\x04data\x12@\n\x0fannotation_info\x18\r\x20\x01(\x0b2\
    \x17.google.protobuf.StructR\x0eannotationInfo\x12\x17\n\x07user_id\x18\
    \x0f\x20\x01(\tR\x06userId\x12(\n\x10model_version_id\x18\x10\x20\x01(\t\
    R\x0emodelVersionId\x127\n\x16embed_model_version_id\x18\x0e\x20\x01(\tR\
    \x13embedModelVersionIdB\x02\x18\x01\x123\n\x06status\x18\x07\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x129\n\ncreated_at\x18\
    \x08\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bm\
    odified_at\x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedA\
    t\x12\x1c\n\x07trusted\x18\n\x20\x01(\x08R\x07trustedB\x02\x18\x01\x12\
    \x1f\n\x0binput_level\x18\x11\x20\x01(\x08R\ninputLevel\x12>\n\x0econsen\
    sus_info\x18\x12\x20\x01(\x0b2\x17.google.protobuf.StructR\rconsensusInf\
    o\x12\x17\n\x07task_id\x18\x13\x20\x01(\tR\x06taskIdJ\x04\x08\x04\x10\
    \x05J\x04\x08\x05\x10\x06J\x04\x08\x06\x10\x07J\x04\x08\x0b\x10\x0cJ\x04\
    \x08\x0c\x10\r\"\xe7\x04\n\x03App\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12)\n\x10default_l\
    anguage\x18\x03\x20\x01(\tR\x0fdefaultLanguage\x12.\n\x13default_workflo\
    w_id\x18\x04\x20\x01(\tR\x11defaultWorkflowId\x12\x17\n\x07user_id\x18\
    \x05\x20\x01(\tR\x06userId\x129\n\ncreated_at\x18\x06\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x11\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x120\n\x14legal_co\
    nsent_status\x18\x07\x20\x01(\rR\x12legalConsentStatus\x123\n\x08metadat\
    a\x18\r\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\x12\x20\n\
    \x0bdescription\x18\x0e\x20\x01(\tR\x0bdescription\x12\x1b\n\tsample_ms\
    \x18\x0f\x20\x01(\rR\x08sampleMs\x128\n\nvisibility\x18\x10\x20\x01(\x0b\
    2\x18.clarifai.api.VisibilityR\nvisibility\x12\x20\n\x0cdata_tier_id\x18\
    \x12\x20\x01(\tR\ndataTierId\x12\x1d\n\nis_starred\x18\x13\x20\x01(\x08R\
    \tisStarred\x12\x1d\n\nstar_count\x18\x14\x20\x01(\x05R\tstarCountJ\x04\
    \x08\n\x10\x0bJ\x04\x08\x0b\x10\x0cJ\x04\x08\x0c\x10\r\"\x1e\n\x08AppQue\
    ry\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\xd4\x02\n\x0cCollabor\
    ator\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12#\n\x03app\x18\x02\x20\
    \x01(\x0b2\x11.clarifai.api.AppR\x03app\x12&\n\x04user\x18\x03\x20\x01(\
    \x0b2\x12.clarifai.api.UserR\x04user\x12\x16\n\x06scopes\x18\x04\x20\x03\
    (\tR\x06scopes\x12\x1c\n\tendpoints\x18\x05\x20\x03(\tR\tendpoints\x129\
    \n\ncreated_at\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcre\
    atedAt\x12;\n\x0bmodified_at\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.T\
    imestampR\nmodifiedAt\x129\n\ndeleted_at\x18\x08\x20\x01(\x0b2\x1a.googl\
    e.protobuf.TimestampR\tdeletedAt\"\xd6\x01\n\rCollaboration\x12#\n\x03ap\
    p\x18\x01\x20\x01(\x0b2\x11.clarifai.api.AppR\x03app\x12/\n\tapp_owner\
    \x18\x02\x20\x01(\x0b2\x12.clarifai.api.UserR\x08appOwner\x12\x16\n\x06s\
    copes\x18\x03\x20\x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\x04\x20\x03\
    (\tR\tendpoints\x129\n\ncreated_at\x18\x05\x20\x01(\x0b2\x1a.google.prot\
    obuf.TimestampR\tcreatedAt\"\xca\x01\n\x05Audio\x12\x10\n\x03url\x18\x01\
    \x20\x01(\tR\x03url\x12\x16\n\x06base64\x18\x02\x20\x01(\x0cR\x06base64\
    \x12.\n\x13allow_duplicate_url\x18\x04\x20\x01(\x08R\x11allowDuplicateUr\
    l\x12/\n\x06hosted\x18\x05\x20\x01(\x0b2\x17.clarifai.api.HostedURLR\x06\
    hosted\x126\n\naudio_info\x18\x06\x20\x01(\x0b2\x17.clarifai.api.AudioIn\
    foR\taudioInfo\"\x95\x01\n\tAudioInfo\x12!\n\x0caudio_format\x18\x01\x20\
    \x01(\tR\x0baudioFormat\x12\x1f\n\x0bsample_rate\x18\x02\x20\x01(\x05R\n\
    sampleRate\x12)\n\x10duration_seconds\x18\x03\x20\x01(\x02R\x0fdurationS\
    econds\x12\x19\n\x08bit_rate\x18\x04\x20\x01(\x05R\x07bitRate\"\x94\x01\
    \n\x05Track\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12&\n\x04data\x18\
    \x02\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\x123\n\ttime_info\x18\
    \x04\x20\x01(\x0b2\x16.clarifai.api.TimeInfoR\x08timeInfo\x12\x18\n\x07q\
    uality\x18\x05\x20\x01(\x02R\x07qualityJ\x04\x08\x03\x10\x04\"\x8c\x01\n\
    \x07Cluster\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05count\
    \x18\x02\x20\x01(\rR\x05count\x12\x14\n\x05score\x18\x03\x20\x01(\x02R\
    \x05score\x12%\n\x04hits\x18\x04\x20\x03(\x0b2\x11.clarifai.api.HitR\x04\
    hits\x12\x1e\n\nprojection\x18\x05\x20\x03(\x02R\nprojection\"a\n\x05Col\
    or\x12\x17\n\x07raw_hex\x18\x01\x20\x01(\tR\x06rawHex\x12#\n\x03w3c\x18\
    \x02\x20\x01(\x0b2\x11.clarifai.api.W3CR\x03w3c\x12\x1a\n\x05value\x18\
    \x03\x20\x01(\x02R\x05valueB\x04\x80\xb5\x18\x01\"+\n\x03W3C\x12\x10\n\
    \x03hex\x18\x01\x20\x01(\tR\x03hex\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\">\n\x0cUserAppIDSet\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\
    \x06userId\x12\x15\n\x06app_id\x18\x02\x20\x01(\tR\x05appId\"m\n\x0bPatc\
    hAction\x12\x0e\n\x02op\x18\x01\x20\x01(\tR\x02op\x12:\n\x19merge_confli\
    ct_resolution\x18\x02\x20\x01(\tR\x17mergeConflictResolution\x12\x12\n\
    \x04path\x18\x03\x20\x01(\tR\x04path\"\xcc\x02\n\x07Concept\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12!\n\x05value\x18\x03\x20\x01(\x02R\x05valueB\x0b\x80\xb5\x18\
    \x01\xd5\xb5\x18\0\0\x80?\x129\n\ncreated_at\x18\x04\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.TimestampR\tcreatedAt\x12\x1a\n\x08language\x18\x05\x20\
    \x01(\tR\x08language\x12\x15\n\x06app_id\x18\x06\x20\x01(\tR\x05appId\
    \x12\x1e\n\ndefinition\x18\x07\x20\x01(\tR\ndefinition\x12\x19\n\x08voca\
    b_id\x18\x08\x20\x01(\tR\x07vocabId\x128\n\nvisibility\x18\t\x20\x01(\
    \x0b2\x18.clarifai.api.VisibilityR\nvisibility\x12\x17\n\x07user_id\x18\
    \n\x20\x01(\tR\x06userId\"\xd4\x01\n\x0cConceptCount\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    L\n\x12concept_type_count\x18\x03\x20\x01(\x0b2\x1e.clarifai.api.Concept\
    TypeCountR\x10conceptTypeCount\x12R\n\x14detail_concept_count\x18\x04\
    \x20\x01(\x0b2\x20.clarifai.api.DetailConceptCountR\x12detailConceptCoun\
    t\"V\n\x10ConceptTypeCount\x12\x20\n\x08positive\x18\x01\x20\x01(\rR\x08\
    positiveB\x04\x80\xb5\x18\x01\x12\x20\n\x08negative\x18\x02\x20\x01(\rR\
    \x08negativeB\x04\x80\xb5\x18\x01\"\x89\x02\n\x12DetailConceptCount\x12<\
    \n\tprocessed\x18\x01\x20\x01(\x0b2\x1e.clarifai.api.ConceptTypeCountR\t\
    processed\x12=\n\nto_process\x18\x02\x20\x01(\x0b2\x1e.clarifai.api.Conc\
    eptTypeCountR\ttoProcess\x126\n\x06errors\x18\x03\x20\x01(\x0b2\x1e.clar\
    ifai.api.ConceptTypeCountR\x06errors\x12>\n\nprocessing\x18\x04\x20\x01(\
    \x0b2\x1e.clarifai.api.ConceptTypeCountR\nprocessing\"_\n\x0cConceptQuer\
    y\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08language\
    \x18\x02\x20\x01(\tR\x08language\x12\x1f\n\x0bworkflow_id\x18\x03\x20\
    \x01(\tR\nworkflowId\"\xa5\x02\n\x0fConceptRelation\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12>\n\x0fsubject_concept\x18\x02\x20\x01(\x0b2\
    \x15.clarifai.api.ConceptR\x0esubjectConcept\x12<\n\x0eobject_concept\
    \x18\x03\x20\x01(\x0b2\x15.clarifai.api.ConceptR\robjectConcept\x12\x1c\
    \n\tpredicate\x18\x04\x20\x01(\tR\tpredicate\x12,\n\x12knowledge_graph_i\
    d\x18\x05\x20\x01(\tR\x10knowledgeGraphId\x128\n\nvisibility\x18\x06\x20\
    \x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibility\"\xb5\x01\n\x0eKnowl\
    edgeGraph\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\t\
    R\x0bdescription\x12&\n\x0fexamples_app_id\x18\x04\x20\x01(\tR\rexamples\
    AppId\x125\n\x17sampled_examples_app_id\x18\x05\x20\x01(\tR\x14sampledEx\
    amplesAppId\"b\n\x11ConceptMappingJob\x12,\n\x12knowledge_graph_id\x18\
    \x01\x20\x01(\tR\x10knowledgeGraphId\x12\x1f\n\x0bconcept_ids\x18\x02\
    \x20\x03(\tR\nconceptIds\"U\n\x0fConceptLanguage\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1e\
    \n\ndefinition\x18\x03\x20\x01(\tR\ndefinition\"\xab\x05\n\x04Data\x12)\
    \n\x05image\x18\x01\x20\x01(\x0b2\x13.clarifai.api.ImageR\x05image\x12)\
    \n\x05video\x18\x02\x20\x01(\x0b2\x13.clarifai.api.VideoR\x05video\x121\
    \n\x08concepts\x18\x03\x20\x03(\x0b2\x15.clarifai.api.ConceptR\x08concep\
    ts\x123\n\x08metadata\x18\x05\x20\x01(\x0b2\x17.google.protobuf.StructR\
    \x08metadata\x12#\n\x03geo\x18\x06\x20\x01(\x0b2\x11.clarifai.api.GeoR\
    \x03geo\x12+\n\x06colors\x18\x07\x20\x03(\x0b2\x13.clarifai.api.ColorR\
    \x06colors\x121\n\x08clusters\x18\x08\x20\x03(\x0b2\x15.clarifai.api.Clu\
    sterR\x08clusters\x127\n\nembeddings\x18\t\x20\x03(\x0b2\x17.clarifai.ap\
    i.EmbeddingR\nembeddings\x12.\n\x07regions\x18\x0b\x20\x03(\x0b2\x14.cla\
    rifai.api.RegionR\x07regions\x12+\n\x06frames\x18\x0c\x20\x03(\x0b2\x13.\
    clarifai.api.FrameR\x06frames\x12&\n\x04text\x18\r\x20\x01(\x0b2\x12.cla\
    rifai.api.TextR\x04text\x12)\n\x05audio\x18\x0e\x20\x01(\x0b2\x13.clarif\
    ai.api.AudioR\x05audio\x12+\n\x06tracks\x18\x0f\x20\x03(\x0b2\x13.clarif\
    ai.api.TrackR\x06tracks\x12>\n\rtime_segments\x18\x10\x20\x03(\x0b2\x19.\
    clarifai.api.TimeSegmentR\x0ctimeSegmentsJ\x04\x08\x04\x10\x05J\x04\x08\
    \n\x10\x0b\"\xac\x01\n\x06Region\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02\
    id\x129\n\x0bregion_info\x18\x02\x20\x01(\x0b2\x18.clarifai.api.RegionIn\
    foR\nregionInfo\x12&\n\x04data\x18\x03\x20\x01(\x0b2\x12.clarifai.api.Da\
    taR\x04data\x12\x14\n\x05value\x18\x04\x20\x01(\x02R\x05value\x12\x19\n\
    \x08track_id\x18\x05\x20\x01(\tR\x07trackId\"\xda\x01\n\nRegionInfo\x12<\
    \n\x0cbounding_box\x18\x01\x20\x01(\x0b2\x19.clarifai.api.BoundingBoxR\
    \x0bboundingBox\x12&\n\x04mask\x18\x04\x20\x01(\x0b2\x12.clarifai.api.Ma\
    skR\x04mask\x12/\n\x07polygon\x18\x05\x20\x01(\x0b2\x15.clarifai.api.Pol\
    ygonR\x07polygon\x12)\n\x05point\x18\x06\x20\x01(\x0b2\x13.clarifai.api.\
    PointR\x05pointJ\x04\x08\x02\x10\x03J\x04\x08\x03\x10\x04\"\x95\x01\n\
    \x0bBoundingBox\x12\x1d\n\x07top_row\x18\x01\x20\x01(\x02R\x06topRowB\
    \x04\x80\xb5\x18\x01\x12\x1f\n\x08left_col\x18\x02\x20\x01(\x02R\x07left\
    ColB\x04\x80\xb5\x18\x01\x12#\n\nbottom_row\x18\x03\x20\x01(\x02R\tbotto\
    mRowB\x04\x80\xb5\x18\x01\x12!\n\tright_col\x18\x04\x20\x01(\x02R\x08rig\
    htColB\x04\x80\xb5\x18\x01\"A\n\tFrameInfo\x12\x1a\n\x05index\x18\x01\
    \x20\x01(\rR\x05indexB\x04\x80\xb5\x18\x01\x12\x18\n\x04time\x18\x02\x20\
    \x01(\rR\x04timeB\x04\x80\xb5\x18\x01\"w\n\x05Frame\x126\n\nframe_info\
    \x18\x01\x20\x01(\x0b2\x17.clarifai.api.FrameInfoR\tframeInfo\x12&\n\x04\
    data\x18\x02\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\x12\x0e\n\x02i\
    d\x18\x03\x20\x01(\tR\x02id\"7\n\x04Mask\x12)\n\x05image\x18\x02\x20\x01\
    (\x0b2\x13.clarifai.api.ImageR\x05imageJ\x04\x08\x01\x10\x02\"6\n\x07Pol\
    ygon\x12+\n\x06points\x18\x01\x20\x03(\x0b2\x13.clarifai.api.PointR\x06p\
    oints\"E\n\x05Point\x12\x16\n\x03row\x18\x01\x20\x01(\x02R\x03rowB\x04\
    \x80\xb5\x18\x01\x12\x16\n\x03col\x18\x02\x20\x01(\x02R\x03colB\x04\x80\
    \xb5\x18\x01\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\x01z\"N\n\tEmbedding\
    \x12\x1a\n\x06vector\x18\x01\x20\x03(\x02R\x06vectorB\x02\x10\x01\x12%\n\
    \x0enum_dimensions\x18\x02\x20\x01(\rR\rnumDimensions\"P\n\x08GeoPoint\
    \x12\"\n\tlongitude\x18\x01\x20\x01(\x02R\tlongitudeB\x04\x80\xb5\x18\
    \x01\x12\x20\n\x08latitude\x18\x02\x20\x01(\x02R\x08latitudeB\x04\x80\
    \xb5\x18\x01\":\n\x08GeoLimit\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04t\
    ype\x12\x1a\n\x05value\x18\x02\x20\x01(\x02R\x05valueB\x04\x80\xb5\x18\
    \x01\"D\n\rGeoBoxedPoint\x123\n\tgeo_point\x18\x01\x20\x01(\x0b2\x16.cla\
    rifai.api.GeoPointR\x08geoPoint\"\xa5\x01\n\x03Geo\x123\n\tgeo_point\x18\
    \x01\x20\x01(\x0b2\x16.clarifai.api.GeoPointR\x08geoPoint\x123\n\tgeo_li\
    mit\x18\x02\x20\x01(\x0b2\x16.clarifai.api.GeoLimitR\x08geoLimit\x124\n\
    \x07geo_box\x18\x03\x20\x03(\x0b2\x1b.clarifai.api.GeoBoxedPointR\x06geo\
    Box\"\xd0\x01\n\x05Image\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\
    \x16\n\x06base64\x18\x02\x20\x01(\x0cR\x06base64\x12.\n\x13allow_duplica\
    te_url\x18\x04\x20\x01(\x08R\x11allowDuplicateUrl\x12/\n\x06hosted\x18\
    \x05\x20\x01(\x0b2\x17.clarifai.api.HostedURLR\x06hosted\x126\n\nimage_i\
    nfo\x18\x06\x20\x01(\x0b2\x17.clarifai.api.ImageInfoR\timageInfoJ\x04\
    \x08\x03\x10\x04\"p\n\tImageInfo\x12\x14\n\x05width\x18\x01\x20\x01(\x05\
    R\x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\x12\x16\n\
    \x06format\x18\x03\x20\x01(\tR\x06format\x12\x1d\n\ncolor_mode\x18\x04\
    \x20\x01(\tR\tcolorMode\"s\n\tHostedURL\x12\x16\n\x06prefix\x18\x01\x20\
    \x01(\tR\x06prefix\x12\x16\n\x06suffix\x18\x02\x20\x01(\tR\x06suffix\x12\
    \x14\n\x05sizes\x18\x03\x20\x03(\tR\x05sizes\x12\x20\n\x0bcrossorigin\
    \x18\x04\x20\x01(\tR\x0bcrossorigin\"\x93\x02\n\x05Input\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12&\n\x04data\x18\x02\x20\x01(\x0b2\x12.clar\
    ifai.api.DataR\x04data\x129\n\ncreated_at\x18\x04\x20\x01(\x0b2\x1a.goog\
    le.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x05\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x123\n\x06status\x18\
    \x06\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1f\n\
    \x0bdataset_ids\x18\x07\x20\x03(\tR\ndatasetIdsJ\x04\x08\x03\x10\x04\"\
    \xb5\x02\n\nInputCount\x12\"\n\tprocessed\x18\x01\x20\x01(\rR\tprocessed\
    B\x04\x80\xb5\x18\x01\x12#\n\nto_process\x18\x02\x20\x01(\rR\ttoProcessB\
    \x04\x80\xb5\x18\x01\x12\x1c\n\x06errors\x18\x03\x20\x01(\rR\x06errorsB\
    \x04\x80\xb5\x18\x01\x12$\n\nprocessing\x18\x04\x20\x01(\rR\nprocessingB\
    \x04\x80\xb5\x18\x01\x12\"\n\treindexed\x18\x05\x20\x01(\rR\treindexedB\
    \x04\x80\xb5\x18\x01\x12#\n\nto_reindex\x18\x06\x20\x01(\rR\ttoReindexB\
    \x04\x80\xb5\x18\x01\x12+\n\x0ereindex_errors\x18\x07\x20\x01(\rR\rreind\
    exErrorsB\x04\x80\xb5\x18\x01\x12$\n\nreindexing\x18\x08\x20\x01(\rR\nre\
    indexingB\x04\x80\xb5\x18\x01\"\xa5\x02\n\rDatasetFilter\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x129\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x03\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x12\x17\n\x07user_\
    id\x18\x04\x20\x01(\tR\x06userId\x12\x15\n\x06app_id\x18\x05\x20\x01(\tR\
    \x05appId\x12\x1d\n\ndataset_id\x18\x06\x20\x01(\tR\tdatasetId\x127\n\
    \x0csaved_search\x18\x08\x20\x01(\x0b2\x14.clarifai.api.SearchR\x0bsaved\
    SearchJ\x04\x08\x07\x10\x08\"\x9f\x05\n\x0eDatasetVersion\x12\x0e\n\x02i\
    d\x18\x01\x20\x01(\tR\x02id\x129\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x03\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x12\x15\n\x06app_i\
    d\x18\x04\x20\x01(\tR\x05appId\x12\x17\n\x07user_id\x18\x05\x20\x01(\tR\
    \x06userId\x12\x1d\n\ndataset_id\x18\x06\x20\x01(\tR\tdatasetId\x12e\n\
    \x15dataset_filter_config\x18\x07\x20\x01(\x0b2/.clarifai.api.DatasetVer\
    sionDatasetFilterConfigH\0R\x13datasetFilterConfig\x123\n\x06status\x18\
    \x08\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x20\n\
    \x0bdescription\x18\n\x20\x01(\tR\x0bdescription\x12=\n\x07summary\x18\
    \x0b\x20\x01(\x0b2#.clarifai.api.DatasetVersionSummaryR\x07summary\x123\
    \n\x08metadata\x18\x0c\x20\x01(\x0b2\x17.google.protobuf.StructR\x08meta\
    data\x128\n\nvisibility\x18\r\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\
    \nvisibility\x125\n\x17embed_model_version_ids\x18\x0e\x20\x03(\tR\x14em\
    bedModelVersionIdsB\r\n\x0bdata_configJ\x04\x08\t\x10\n\"g\n!DatasetVers\
    ionDatasetFilterConfig\x12B\n\x0edataset_filter\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.DatasetFilterR\rdatasetFilter\"\xb0\x01\n\x15DatasetVe\
    rsionSummary\x12W\n\x0cinput_counts\x18\x01\x20\x03(\x0b24.clarifai.api.\
    DatasetVersionSummary.InputCountsEntryR\x0binputCounts\x1a>\n\x10InputCo\
    untsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x04R\x05value:\x028\x01\"\x87\x01\n\x19WorkflowResults\
    Similarity\x124\n\x0bprobe_input\x18\x01\x20\x01(\x0b2\x13.clarifai.api.\
    InputR\nprobeInput\x124\n\x0cpool_results\x18\x02\x20\x03(\x0b2\x11.clar\
    ifai.api.HitR\x0bpoolResults\"\xcc\x02\n\x03Key\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x12\n\x04type\x18\x08\x20\x01(\tR\x04type\x12\x20\
    \n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12\x16\n\x06scopes\
    \x18\x03\x20\x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\x07\x20\x03(\tR\
    \tendpoints\x12%\n\x04apps\x18\x04\x20\x03(\x0b2\x11.clarifai.api.AppR\
    \x04apps\x129\n\ncreated_at\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.Ti\
    mestampR\tcreatedAt\x129\n\nexpires_at\x18\x06\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampR\texpiresAt\x12,\n\x12authorized_idp_ids\x18\t\x20\
    \x03(\tR\x10authorizedIdpIds\"\xa7\x07\n\x05Model\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    9\n\ncreated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcr\
    eatedAt\x12;\n\x0bmodified_at\x18\x13\x20\x01(\x0b2\x1a.google.protobuf.\
    TimestampR\nmodifiedAt\x12\x1b\n\x06app_id\x18\x04\x20\x01(\tR\x05appIdB\
    \x04\x80\xb5\x18\x01\x129\n\x0boutput_info\x18\x05\x20\x01(\x0b2\x18.cla\
    rifai.api.OutputInfoR\noutputInfo\x12?\n\rmodel_version\x18\x06\x20\x01(\
    \x0b2\x1a.clarifai.api.ModelVersionR\x0cmodelVersion\x12!\n\x0cdisplay_n\
    ame\x18\x07\x20\x01(\tR\x0bdisplayName\x12\x17\n\x07user_id\x18\t\x20\
    \x01(\tR\x06userId\x126\n\ninput_info\x18\x0c\x20\x01(\x0b2\x17.clarifai\
    .api.InputInfoR\tinputInfo\x126\n\ntrain_info\x18\r\x20\x01(\x0b2\x17.cl\
    arifai.api.TrainInfoR\ttrainInfo\x12\"\n\rmodel_type_id\x18\x0e\x20\x01(\
    \tR\x0bmodelTypeId\x128\n\nvisibility\x18\x0f\x20\x01(\x0b2\x18.clarifai\
    .api.VisibilityR\nvisibility\x12\x20\n\x0bdescription\x18\x10\x20\x01(\t\
    R\x0bdescription\x123\n\x08metadata\x18\x11\x20\x01(\x0b2\x17.google.pro\
    tobuf.StructR\x08metadata\x12\x14\n\x05notes\x18\x12\x20\x01(\tR\x05note\
    s\x12\x20\n\x08toolkits\x18\x14\x20\x03(\tR\x08toolkitsB\x04\x80\xb5\x18\
    \x01\x12!\n\tuse_cases\x18\x15\x20\x03(\tR\x08useCasesB\x04\x80\xb5\x18\
    \x01\x12\"\n\tlanguages\x18\x19\x20\x03(\tR\tlanguagesB\x04\x80\xb5\x18\
    \x01\x12\x1d\n\nis_starred\x18\x16\x20\x01(\x08R\tisStarred\x12\x1d\n\ns\
    tar_count\x18\x17\x20\x01(\x05R\tstarCount\x129\n\x0bimport_info\x18\x18\
    \x20\x01(\x0b2\x18.clarifai.api.ImportInfoR\nimportInfoJ\x04\x08\x08\x10\
    \tJ\x04\x08\n\x10\x0bJ\x04\x08\x0b\x10\x0c\"\x96\x01\n\x0eModelReference\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\n\x08model_id\x18\x02\
    \x20\x01(\tR\x07modelId\x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03url\x12\
    \x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x123\n\x08metadata\x18\x05\
    \x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\"\xcd\x01\n\x18Mo\
    delVersionInputExample\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x19\
    \n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12(\n\x10model_version_id\
    \x18\x03\x20\x01(\tR\x0emodelVersionId\x12&\n\x04data\x18\x04\x20\x01(\
    \x0b2\x12.clarifai.api.DataR\x04data\x12\x12\n\x04name\x18\x05\x20\x01(\
    \tR\x04name\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\
    \"\xa7\x02\n\nOutputInfo\x12&\n\x04data\x18\x01\x20\x01(\x0b2\x12.clarif\
    ai.api.DataR\x04data\x12?\n\routput_config\x18\x02\x20\x01(\x0b2\x1a.cla\
    rifai.api.OutputConfigR\x0coutputConfig\x12\x18\n\x07message\x18\x03\x20\
    \x01(\tR\x07message\x12\x12\n\x04type\x18\x04\x20\x01(\tR\x04type\x12\
    \x19\n\x08type_ext\x18\x05\x20\x01(\tR\x07typeExt\x126\n\nfields_map\x18\
    \x06\x20\x01(\x0b2\x17.google.protobuf.StructR\tfieldsMap\x12/\n\x06para\
    ms\x18\x07\x20\x01(\x0b2\x17.google.protobuf.StructR\x06params\"t\n\tInp\
    utInfo\x126\n\nfields_map\x18\x01\x20\x01(\x0b2\x17.google.protobuf.Stru\
    ctR\tfieldsMap\x12/\n\x06params\x18\x02\x20\x01(\x0b2\x17.google.protobu\
    f.StructR\x06params\"<\n\tTrainInfo\x12/\n\x06params\x18\x01\x20\x01(\
    \x0b2\x17.google.protobuf.StructR\x06params\"=\n\nImportInfo\x12/\n\x06p\
    arams\x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\x06params\"\xef\
    \x05\n\x0cOutputConfig\x12D\n\x1bconcepts_mutually_exclusive\x18\x01\x20\
    \x01(\x08R\x19conceptsMutuallyExclusiveB\x04\x80\xb5\x18\x01\x123\n\x12c\
    losed_environment\x18\x02\x20\x01(\x08R\x11closedEnvironmentB\x04\x80\
    \xb5\x18\x01\x12.\n\x11existing_model_id\x18\x03\x20\x01(\tR\x0fexisting\
    ModelIdB\x02\x18\x01\x12\x1a\n\x08language\x18\x04\x20\x01(\tR\x08langua\
    ge\x12-\n\x10hyper_parameters\x18\x05\x20\x01(\tR\x0fhyperParametersB\
    \x02\x18\x01\x12'\n\x0cmax_concepts\x18\x06\x20\x01(\rR\x0bmaxConceptsB\
    \x04\x80\xb5\x18\x01\x12!\n\tmin_value\x18\x07\x20\x01(\x02R\x08minValue\
    B\x04\x80\xb5\x18\x01\x12>\n\x0fselect_concepts\x18\x08\x20\x03(\x0b2\
    \x15.clarifai.api.ConceptR\x0eselectConcepts\x12)\n\x10training_timeout\
    \x18\t\x20\x01(\rR\x0ftrainingTimeout\x12\x1b\n\tsample_ms\x18\n\x20\x01\
    (\rR\x08sampleMs\x12:\n\x0chyper_params\x18\r\x20\x01(\x0b2\x17.google.p\
    rotobuf.StructR\x0bhyperParams\x123\n\x16embed_model_version_id\x18\x0e\
    \x20\x01(\tR\x13embedModelVersionId\x12H\n!fail_on_missing_positive_exam\
    ples\x18\x0f\x20\x01(\x08R\x1dfailOnMissingPositiveExamples\x12B\n\x0emo\
    del_metadata\x18\x11\x20\x01(\x0b2\x17.google.protobuf.StructR\rmodelMet\
    adataB\x02\x18\x01J\x04\x08\x0b\x10\x0cJ\x04\x08\x0c\x10\rJ\x04\x08\x10\
    \x10\x11J\x04\x08\x12\x10\x13\"\x82\x05\n\tModelType\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\
    \x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\x12\n\
    \x04type\x18\x04\x20\x01(\tR\x04type\x12!\n\x0cinput_fields\x18\x05\x20\
    \x03(\tR\x0binputFields\x12#\n\routput_fields\x18\x06\x20\x03(\tR\x0cout\
    putFields\x12\x1c\n\ttrainable\x18\x08\x20\x01(\x08R\ttrainable\x12\x1c\
    \n\tcreatable\x18\t\x20\x01(\x08R\tcreatable\x12#\n\rinternal_only\x18\n\
    \x20\x01(\x08R\x0cinternalOnly\x12H\n\x11model_type_fields\x18\x0b\x20\
    \x03(\x0b2\x1c.clarifai.api.ModelTypeFieldR\x0fmodelTypeFields\x12<\n\
    \x1arequires_sequential_frames\x18\x0c\x20\x01(\x08R\x18requiresSequenti\
    alFrames\x12\x1c\n\tevaluable\x18\r\x20\x01(\x08R\tevaluable\x12`\n\x20e\
    xpected_pretrained_input_fields\x18\x0e\x20\x01(\x0b2\x17.google.protobu\
    f.StructR\x1dexpectedPretrainedInputFields\x12b\n!expected_pretrained_ou\
    tput_fields\x18\x0f\x20\x01(\x0b2\x17.google.protobuf.StructR\x1eexpecte\
    dPretrainedOutputFieldsJ\x04\x08\x07\x10\x08\"\x94\x06\n\x0eModelTypeFie\
    ld\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12N\n\nfield_type\x18\
    \x02\x20\x01(\x0e2/.clarifai.api.ModelTypeField.ModelTypeFieldTypeR\tfie\
    ldType\x12;\n\rdefault_value\x18\x03\x20\x01(\x0b2\x16.google.protobuf.V\
    alueR\x0cdefaultValue\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\x0bde\
    scription\x12\x20\n\x0bplaceholder\x18\x05\x20\x01(\tR\x0bplaceholder\
    \x12X\n\x17model_type_enum_options\x18\x06\x20\x03(\x0b2!.clarifai.api.M\
    odelTypeEnumOptionR\x14modelTypeEnumOptions\x12#\n\rinternal_only\x18\
    \x07\x20\x01(\x08R\x0cinternalOnly\x12\x1a\n\x08required\x18\x08\x20\x01\
    (\x08R\x08required\x12S\n\x15model_type_range_info\x18\t\x20\x01(\x0b2\
    \x20.clarifai.api.ModelTypeRangeInfoR\x12modelTypeRangeInfo\"\xac\x02\n\
    \x12ModelTypeFieldType\x12!\n\x1dINVALID_MODEL_TYPE_FIELD_TYPE\x10\0\x12\
    \x0b\n\x07BOOLEAN\x10\x01\x12\n\n\x06STRING\x10\x02\x12\n\n\x06NUMBER\
    \x10\x03\x12\x15\n\x11ARRAY_OF_CONCEPTS\x10\x04\x12$\n\x20ARRAY_OF_CONCE\
    PTS_WITH_THRESHOLD\x10\x05\x12\t\n\x05RANGE\x10\x07\x12\x08\n\x04ENUM\
    \x10\x08\x12\x11\n\rCOLLABORATORS\x10\t\x12\x08\n\x04JSON\x10\n\x12\x14\
    \n\x10ARRAY_OF_NUMBERS\x10\x0b\x12\x19\n\x15WORKFLOW_EMBED_MODELS\x10\
    \x0c\x12\x14\n\x10ARRAY_OF_STRINGS\x10\r\x12\x12\n\x0eRECURSIVE_ENUM\x10\
    \x0e\"\x04\x08\x06\x10\x06\"L\n\x12ModelTypeRangeInfo\x12\x10\n\x03min\
    \x18\x01\x20\x01(\x02R\x03min\x12\x10\n\x03max\x18\x02\x20\x01(\x02R\x03\
    max\x12\x12\n\x04step\x18\x03\x20\x01(\x02R\x04step\"\xb6\x01\n\x13Model\
    TypeEnumOption\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x20\n\x0bde\
    scription\x18\x02\x20\x01(\tR\x0bdescription\x12H\n\x11model_type_fields\
    \x18\x03\x20\x03(\x0b2\x1c.clarifai.api.ModelTypeFieldR\x0fmodelTypeFiel\
    ds\x12#\n\rinternal_only\x18\x04\x20\x01(\x08R\x0cinternalOnly\"\\\n\nMo\
    delQuery\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x04type\
    \x18\x02\x20\x01(\tR\x04typeB\x02\x18\x01\x12\"\n\rmodel_type_id\x18\x03\
    \x20\x01(\tR\x0bmodelTypeId\"\xfe\x04\n\x0cModelVersion\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x129\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\tcreatedAt\x123\n\x06status\x18\x03\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x120\n\x14active_concept\
    _count\x18\x04\x20\x01(\rR\x12activeConceptCount\x123\n\x07metrics\x18\
    \x05\x20\x01(\x0b2\x19.clarifai.api.EvalMetricsR\x07metrics\x12*\n\x11to\
    tal_input_count\x18\x06\x20\x01(\rR\x0ftotalInputCount\x12=\n\x0ccomplet\
    ed_at\x18\n\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0bcompletedAt\
    \x12\x20\n\x0bdescription\x18\x0b\x20\x01(\tR\x0bdescription\x128\n\nvis\
    ibility\x18\x0c\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibility\
    \x12\x15\n\x06app_id\x18\r\x20\x01(\tR\x05appId\x12\x17\n\x07user_id\x18\
    \x0e\x20\x01(\tR\x06userId\x12;\n\x0bmodified_at\x18\x0f\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\nmodifiedAt\x123\n\x08metadata\x18\x10\
    \x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\x12\x18\n\x07lice\
    nse\x18\x11\x20\x01(\tR\x07licenseJ\x04\x08\t\x10\n\"\xb7\x02\n\x15Pretr\
    ainedModelConfig\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04\
    type\x18\x02\x20\x01(\tR\x04type\x12A\n\x10input_fields_map\x18\x03\x20\
    \x01(\x0b2\x17.google.protobuf.StructR\x0einputFieldsMap\x12C\n\x11outpu\
    t_fields_map\x18\x04\x20\x01(\x0b2\x17.google.protobuf.StructR\x0foutput\
    FieldsMap\x120\n\x14data_provider_params\x18\x05\x20\x01(\tR\x12dataProv\
    iderParams\x12\"\n\rmodel_zip_url\x18\x06\x20\x01(\tR\x0bmodelZipUrl\x12\
    \x1c\n\toverwrite\x18\x07\x20\x01(\x08R\toverwrite\"I\n\nTrainStats\x12;\
    \n\nloss_curve\x18\x01\x20\x03(\x0b2\x1c.clarifai.api.LossCurveEntryR\tl\
    ossCurve\"[\n\x0eLossCurveEntry\x12\x14\n\x05epoch\x18\x01\x20\x01(\rR\
    \x05epoch\x12\x1f\n\x0bglobal_step\x18\x02\x20\x01(\rR\nglobalStep\x12\
    \x12\n\x04cost\x18\x03\x20\x01(\x02R\x04cost\"E\n\nLabelCount\x12!\n\x0c\
    concept_name\x18\x01\x20\x01(\tR\x0bconceptName\x12\x14\n\x05count\x18\
    \x02\x20\x01(\rR\x05count\"a\n\x11LabelDistribution\x12L\n\x15positive_l\
    abel_counts\x18\x01\x20\x03(\x0b2\x18.clarifai.api.LabelCountR\x13positi\
    veLabelCounts\"S\n\x17CooccurrenceMatrixEntry\x12\x10\n\x03row\x18\x01\
    \x20\x01(\tR\x03row\x12\x10\n\x03col\x18\x02\x20\x01(\tR\x03col\x12\x14\
    \n\x05count\x18\x03\x20\x01(\rR\x05count\"t\n\x12CooccurrenceMatrix\x12=\
    \n\x06matrix\x18\x01\x20\x03(\x0b2%.clarifai.api.CooccurrenceMatrixEntry\
    R\x06matrix\x12\x1f\n\x0bconcept_ids\x18\x02\x20\x03(\tR\nconceptIds\"h\
    \n\x14ConfusionMatrixEntry\x12\x1c\n\tpredicted\x18\x01\x20\x01(\tR\tpre\
    dicted\x12\x16\n\x06actual\x18\x02\x20\x01(\tR\x06actual\x12\x1a\n\x05va\
    lue\x18\x04\x20\x01(\x02R\x05valueB\x04\x80\xb5\x18\x01\"n\n\x0fConfusio\
    nMatrix\x12:\n\x06matrix\x18\x01\x20\x03(\x0b2\".clarifai.api.ConfusionM\
    atrixEntryR\x06matrix\x12\x1f\n\x0bconcept_ids\x18\x02\x20\x03(\tR\nconc\
    eptIds\"\xa5\x01\n\x03ROC\x12\x16\n\x03fpr\x18\x01\x20\x03(\x02R\x03fprB\
    \x04\x80\xb5\x18\x01\x12\x16\n\x03tpr\x18\x02\x20\x03(\x02R\x03tprB\x04\
    \x80\xb5\x18\x01\x12$\n\nthresholds\x18\x03\x20\x03(\x02R\nthresholdsB\
    \x04\x80\xb5\x18\x01\x12\"\n\rfpr_per_image\x18\x04\x20\x03(\x02R\x0bfpr\
    PerImage\x12$\n\x0efpr_per_object\x18\x05\x20\x03(\x02R\x0cfprPerObject\
    \"~\n\x14PrecisionRecallCurve\x12\x1c\n\x06recall\x18\x01\x20\x03(\x02R\
    \x06recallB\x04\x80\xb5\x18\x01\x12\"\n\tprecision\x18\x02\x20\x03(\x02R\
    \tprecisionB\x04\x80\xb5\x18\x01\x12$\n\nthresholds\x18\x03\x20\x03(\x02\
    R\nthresholdsB\x04\x80\xb5\x18\x01\"\xe6\x03\n\rBinaryMetrics\x12\x1d\n\
    \x07num_pos\x18\x01\x20\x01(\rR\x06numPosB\x04\x80\xb5\x18\x01\x12\x1d\n\
    \x07num_neg\x18\x02\x20\x01(\rR\x06numNegB\x04\x80\xb5\x18\x01\x12\x1d\n\
    \x07num_tot\x18\x03\x20\x01(\rR\x06numTotB\x04\x80\xb5\x18\x01\x12\x1d\n\
    \x07roc_auc\x18\x04\x20\x01(\x02R\x06rocAucB\x04\x80\xb5\x18\x01\x12\x14\
    \n\x02f1\x18\x05\x20\x01(\x02R\x02f1B\x04\x80\xb5\x18\x01\x12/\n\x07conc\
    ept\x18\x06\x20\x01(\x0b2\x15.clarifai.api.ConceptR\x07concept\x12.\n\tr\
    oc_curve\x18\x07\x20\x01(\x0b2\x11.clarifai.api.ROCR\x08rocCurve\x12X\n\
    \x16precision_recall_curve\x18\x08\x20\x01(\x0b2\".clarifai.api.Precisio\
    nRecallCurveR\x14precisionRecallCurve\x12#\n\ravg_precision\x18\t\x20\
    \x01(\x02R\x0cavgPrecision\x12\x1b\n\tarea_name\x18\n\x20\x01(\tR\x08are\
    aName\x12\x19\n\x08area_min\x18\x0b\x20\x01(\x01R\x07areaMin\x12\x19\n\
    \x08area_max\x18\x0c\x20\x01(\x01R\x07areaMax\x12\x10\n\x03iou\x18\r\x20\
    \x01(\x02R\x03iou\"\xdb\x01\n\x0eTrackerMetrics\x12\x19\n\x08mot_mota\
    \x18\x01\x20\x01(\x02R\x07motMota\x12(\n\x10mot_num_switches\x18\x02\x20\
    \x01(\x05R\x0emotNumSwitches\x12\x1d\n\nmorse_frag\x18\x03\x20\x01(\x02R\
    \tmorseFrag\x12#\n\ravg_precision\x18\x04\x20\x01(\x02R\x0cavgPrecision\
    \x12\x12\n\x04aiid\x18\x05\x20\x01(\tR\x04aiid\x12,\n\x12unique_switch_r\
    ate\x18\x06\x20\x01(\x02R\x10uniqueSwitchRate\"\xb2\x02\n\x10EvalTestSet\
    Entry\x12\x12\n\x02id\x18\x01\x20\x01(\tR\x02idB\x02\x18\x01\x12\x14\n\
    \x03url\x18\x02\x20\x01(\tR\x03urlB\x02\x18\x01\x12)\n\x05input\x18\x06\
    \x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\x12D\n\x12predicted_conc\
    epts\x18\x03\x20\x03(\x0b2\x15.clarifai.api.ConceptR\x11predictedConcept\
    s\x12I\n\x15ground_truth_concepts\x18\x04\x20\x03(\x0b2\x15.clarifai.api\
    .ConceptR\x13groundTruthConcepts\x128\n\nannotation\x18\x05\x20\x01(\x0b\
    2\x18.clarifai.api.AnnotationR\nannotation\"\xaf\x02\n\x0eLOPQEvalResult\
    \x12\x0c\n\x01k\x18\x01\x20\x01(\x05R\x01k\x127\n\x15recall_vs_brute_for\
    ce\x18\x02\x20\x01(\x02R\x12recallVsBruteForceB\x04\x80\xb5\x18\x01\x12@\
    \n\x1akendall_tau_vs_brute_force\x18\x03\x20\x01(\x02R\x16kendallTauVsBr\
    uteForceB\x04\x80\xb5\x18\x01\x12A\n\x1amost_frequent_code_percent\x18\
    \x04\x20\x01(\x02R\x17mostFrequentCodePercentB\x04\x80\xb5\x18\x01\x12!\
    \n\tlopq_ndcg\x18\x05\x20\x01(\x02R\x08lopqNdcgB\x04\x80\xb5\x18\x01\x12\
    .\n\x10brute_force_ndcg\x18\x06\x20\x01(\x02R\x0ebruteForceNdcgB\x04\x80\
    \xb5\x18\x01\"\xcb\x04\n\x0eMetricsSummary\x12'\n\rtop1_accuracy\x18\x01\
    \x20\x01(\x02R\x0ctop1AccuracyB\x02\x18\x01\x12'\n\rtop5_accuracy\x18\
    \x02\x20\x01(\x02R\x0ctop5AccuracyB\x02\x18\x01\x12/\n\x11macro_avg_roc_\
    auc\x18\x03\x20\x01(\x02R\x0emacroAvgRocAucB\x04\x80\xb5\x18\x01\x12/\n\
    \x11macro_std_roc_auc\x18\x04\x20\x01(\x02R\x0emacroStdRocAucB\x04\x80\
    \xb5\x18\x01\x121\n\x12macro_avg_f1_score\x18\x05\x20\x01(\x02R\x0fmacro\
    AvgF1ScoreB\x04\x80\xb5\x18\x01\x121\n\x12macro_std_f1_score\x18\x06\x20\
    \x01(\x02R\x0fmacroStdF1ScoreB\x04\x80\xb5\x18\x01\x124\n\x13macro_avg_p\
    recision\x18\x07\x20\x01(\x02R\x11macroAvgPrecisionB\x04\x80\xb5\x18\x01\
    \x12.\n\x10macro_avg_recall\x18\x08\x20\x01(\x02R\x0emacroAvgRecallB\x04\
    \x80\xb5\x18\x01\x128\n\x19mean_avg_precision_iou_50\x18\n\x20\x01(\x02R\
    \x15meanAvgPrecisionIou50\x12>\n\x1cmean_avg_precision_iou_range\x18\x0b\
    \x20\x01(\x02R\x18meanAvgPrecisionIouRange\x12?\n\x0clopq_metrics\x18\t\
    \x20\x03(\x0b2\x1c.clarifai.api.LOPQEvalResultR\x0blopqMetrics\"\xbd\x05\
    \n\x0bEvalMetrics\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x12\x0e\n\x02id\x18\n\x20\x01(\tR\x02id\x126\
    \n\x07summary\x18\x02\x20\x01(\x0b2\x1c.clarifai.api.MetricsSummaryR\x07\
    summary\x12H\n\x10confusion_matrix\x18\x03\x20\x01(\x0b2\x1d.clarifai.ap\
    i.ConfusionMatrixR\x0fconfusionMatrix\x12Q\n\x13cooccurrence_matrix\x18\
    \x04\x20\x01(\x0b2\x20.clarifai.api.CooccurrenceMatrixR\x12cooccurrenceM\
    atrix\x12B\n\x0clabel_counts\x18\x05\x20\x01(\x0b2\x1f.clarifai.api.Labe\
    lDistributionR\x0blabelCounts\x12B\n\x0ebinary_metrics\x18\x06\x20\x03(\
    \x0b2\x1b.clarifai.api.BinaryMetricsR\rbinaryMetrics\x129\n\x08test_set\
    \x18\x07\x20\x03(\x0b2\x1e.clarifai.api.EvalTestSetEntryR\x07testSet\x12\
    C\n\x0fmetrics_by_area\x18\x08\x20\x03(\x0b2\x1b.clarifai.api.BinaryMetr\
    icsR\rmetricsByArea\x12E\n\x10metrics_by_class\x18\t\x20\x03(\x0b2\x1b.c\
    larifai.api.BinaryMetricsR\x0emetricsByClass\x12E\n\x0ftracker_metrics\
    \x18\x0b\x20\x03(\x0b2\x1c.clarifai.api.TrackerMetricsR\x0etrackerMetric\
    s\"\xa0\x02\n\x0bFieldsValue\x12)\n\x10confusion_matrix\x18\x01\x20\x01(\
    \x08R\x0fconfusionMatrix\x12/\n\x13cooccurrence_matrix\x18\x02\x20\x01(\
    \x08R\x12cooccurrenceMatrix\x12!\n\x0clabel_counts\x18\x03\x20\x01(\x08R\
    \x0blabelCounts\x12%\n\x0ebinary_metrics\x18\x04\x20\x01(\x08R\rbinaryMe\
    trics\x12\x19\n\x08test_set\x18\x05\x20\x01(\x08R\x07testSet\x12&\n\x0fm\
    etrics_by_area\x18\x06\x20\x01(\x08R\rmetricsByArea\x12(\n\x10metrics_by\
    _class\x18\x07\x20\x01(\x08R\x0emetricsByClass\"\x86\x02\n\x06Output\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x123\n\x06status\x18\x02\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x129\n\ncreated_at\x18\
    \x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12)\n\x05m\
    odel\x18\x04\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05model\x12)\n\x05in\
    put\x18\x05\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\x12&\n\x04dat\
    a\x18\x06\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\"L\n\tScopeDeps\
    \x12\x14\n\x05scope\x18\x01\x20\x01(\tR\x05scope\x12)\n\x10depending_sco\
    pes\x18\x02\x20\x03(\tR\x0fdependingScopes\"U\n\x0cEndpointDeps\x12\x1a\
    \n\x08endpoint\x18\x01\x20\x01(\tR\x08endpoint\x12)\n\x10depending_scope\
    s\x18\x02\x20\x03(\tR\x0fdependingScopes\"\x86\x01\n\x03Hit\x12\x1a\n\
    \x05score\x18\x01\x20\x01(\x02R\x05scoreB\x04\x80\xb5\x18\x01\x12)\n\x05\
    input\x18\x02\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\x128\n\nann\
    otation\x18\x03\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\nannotation\"\
    \xb0\x01\n\x03And\x12)\n\x05input\x18\x01\x20\x01(\x0b2\x13.clarifai.api\
    .InputR\x05input\x12,\n\x06output\x18\x02\x20\x01(\x0b2\x14.clarifai.api\
    .OutputR\x06output\x12\x16\n\x06negate\x18\x03\x20\x01(\x08R\x06negate\
    \x128\n\nannotation\x18\x04\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\n\
    annotation\"\xa4\x01\n\x05Query\x12%\n\x04ands\x18\x01\x20\x03(\x0b2\x11\
    .clarifai.api.AndR\x04ands\x12\x1a\n\x08language\x18\x02\x20\x01(\tR\x08\
    language\x12.\n\x07filters\x18\x03\x20\x03(\x0b2\x14.clarifai.api.Filter\
    R\x07filters\x12(\n\x05ranks\x18\x04\x20\x03(\x0b2\x12.clarifai.api.Rank\
    R\x05ranks\"\xcb\x03\n\x06Search\x12)\n\x05query\x18\x01\x20\x01(\x0b2\
    \x13.clarifai.api.QueryR\x05query\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\
    \x02id\x12%\n\x0eapplication_id\x18\x03\x20\x01(\tR\rapplicationId\x12\
    \x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12/\n\x05as_of\x18\x05\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x04asOf\x12\x19\n\x08git_hash\
    \x18\x06\x20\x01(\tR\x07gitHash\x129\n\ncreated_at\x18\x07\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x08\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmodifiedAt\x12\x1c\n\talg\
    orithm\x18\t\x20\x01(\tR\talgorithm\x12\x12\n\x04save\x18\n\x20\x01(\x08\
    R\x04save\x12\x1b\n\tmin_value\x18\x0b\x20\x01(\x02R\x08minValue\x128\n\
    \nvisibility\x18\x0c\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\nvisibil\
    ity\"\xd5\x01\n\x06Filter\x12\x16\n\x06negate\x18\x03\x20\x01(\x08R\x06n\
    egate\x128\n\nannotation\x18\x04\x20\x01(\x0b2\x18.clarifai.api.Annotati\
    onR\nannotation\x12)\n\x05input\x18\x05\x20\x01(\x0b2\x13.clarifai.api.I\
    nputR\x05input\x12N\n\x17last_updated_time_range\x18\x06\x20\x01(\x0b2\
    \x17.clarifai.api.TimeRangeR\x14lastUpdatedTimeRange\"}\n\tTimeRange\x12\
    9\n\nstart_time\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tst\
    artTime\x125\n\x08end_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Tim\
    estampR\x07endTime\"X\n\x04Rank\x12\x16\n\x06negate\x18\x03\x20\x01(\x08\
    R\x06negate\x128\n\nannotation\x18\x04\x20\x01(\x0b2\x18.clarifai.api.An\
    notationR\nannotation\"\xd7\x02\n\x17AnnotationSearchMetrics\x127\n\x0cg\
    round_truth\x18\x01\x20\x01(\x0b2\x14.clarifai.api.SearchR\x0bgroundTrut\
    h\x12:\n\x0esearch_to_eval\x18\x02\x20\x01(\x0b2\x14.clarifai.api.Search\
    R\x0csearchToEval\x123\n\x07metrics\x18\x03\x20\x01(\x0b2\x19.clarifai.a\
    pi.EvalMetricsR\x07metrics\x12&\n\x04data\x18\x04\x20\x01(\x0b2\x12.clar\
    ifai.api.DataR\x04data\x120\n\x14active_concept_count\x18\x05\x20\x01(\r\
    R\x12activeConceptCount\x128\n\nvisibility\x18\x06\x20\x01(\x0b2\x18.cla\
    rifai.api.VisibilityR\nvisibility\"\xc0\x01\n\x04Text\x12\x10\n\x03raw\
    \x18\x01\x20\x01(\tR\x03raw\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\
    \x12.\n\x13allow_duplicate_url\x18\x03\x20\x01(\x08R\x11allowDuplicateUr\
    l\x12/\n\x06hosted\x18\x04\x20\x01(\x0b2\x17.clarifai.api.HostedURLR\x06\
    hosted\x123\n\ttext_info\x18\x05\x20\x01(\x0b2\x16.clarifai.api.TextInfo\
    R\x08textInfo\"E\n\x08TextInfo\x12\x1d\n\nchar_count\x18\x01\x20\x01(\
    \x05R\tcharCount\x12\x1a\n\x08encoding\x18\x02\x20\x01(\tR\x08encoding\"\
    \xdf\x07\n\x04User\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12'\n\rpri\
    mary_email\x18\x02\x20\x01(\tR\x0cprimaryEmailB\x02\x18\x01\x12\x1d\n\nf\
    irst_name\x18\x03\x20\x01(\tR\tfirstName\x12\x1b\n\tlast_name\x18\x04\
    \x20\x01(\tR\x08lastName\x12!\n\x0ccompany_name\x18\x05\x20\x01(\tR\x0bc\
    ompanyName\x12\x1b\n\tjob_title\x18\x13\x20\x01(\tR\x08jobTitle\x12\x19\
    \n\x08job_role\x18\x14\x20\x01(\tR\x07jobRole\x12\x1f\n\tbill_type\x18\
    \x07\x20\x01(\tR\x08billTypeB\x02\x18\x01\x129\n\ncreated_at\x18\x06\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12J\n\x11date_gdpr\
    _consent\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0fdateGdp\
    rConsentB\x02\x18\x01\x12H\n\x10date_tos_consent\x18\t\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\x0edateTosConsentB\x02\x18\x01\x12T\n\x16dat\
    e_marketing_consent\x18\n\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x14dateMarketingConsentB\x02\x18\x01\x127\n\x08metadata\x18\x0b\x20\x01\
    (\x0b2\x17.google.protobuf.StructR\x08metadataB\x02\x18\x01\x12G\n\x0fem\
    ail_addresses\x18\x0c\x20\x03(\x0b2\x1a.clarifai.api.EmailAddressR\x0eem\
    ailAddressesB\x02\x18\x01\x12$\n\x0cis_org_admin\x18\x0e\x20\x01(\x08R\n\
    isOrgAdminB\x02\x18\x01\x129\n\x17two_factor_auth_enabled\x18\x0f\x20\
    \x01(\x08R\x14twoFactorAuthEnabledB\x02\x18\x01\x12#\n\x0bteams_count\
    \x18\x10\x20\x01(\rR\nteamsCountB\x02\x18\x01\x12\x1d\n\nis_starred\x18\
    \x15\x20\x01(\x08R\tisStarred\x12\x1d\n\nstar_count\x18\x16\x20\x01(\x05\
    R\tstarCount\x128\n\nvisibility\x18\x11\x20\x01(\x0b2\x18.clarifai.api.V\
    isibilityR\nvisibility\x129\n\x0buser_detail\x18\x12\x20\x01(\x0b2\x18.c\
    larifai.api.UserDetailR\nuserDetailJ\x04\x08\r\x10\x0e\"\xd2\x04\n\nUser\
    Detail\x12#\n\rprimary_email\x18\x01\x20\x01(\tR\x0cprimaryEmail\x12\x1b\
    \n\tbill_type\x18\x02\x20\x01(\tR\x08billType\x12F\n\x11date_gdpr_consen\
    t\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0fdateGdprConsen\
    t\x12D\n\x10date_tos_consent\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.T\
    imestampR\x0edateTosConsent\x12P\n\x16date_marketing_consent\x18\x05\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x14dateMarketingConsent\x123\n\
    \x08metadata\x18\x06\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metada\
    ta\x12C\n\x0femail_addresses\x18\x07\x20\x03(\x0b2\x1a.clarifai.api.Emai\
    lAddressR\x0eemailAddresses\x12\x20\n\x0cis_org_admin\x18\x08\x20\x01(\
    \x08R\nisOrgAdmin\x125\n\x17two_factor_auth_enabled\x18\t\x20\x01(\x08R\
    \x14twoFactorAuthEnabled\x12\x1f\n\x0bteams_count\x18\n\x20\x01(\rR\ntea\
    msCount\x12\x18\n\x07country\x18\x0b\x20\x01(\tR\x07country\x12\x14\n\
    \x05state\x18\x0c\x20\x01(\tR\x05state\"l\n\x0cEmailAddress\x12\x1a\n\
    \x05email\x18\x01\x20\x01(\tR\x05emailB\x04\x80\xb5\x18\x01\x12\x1e\n\
    \x07primary\x18\x02\x20\x01(\x08R\x07primaryB\x04\x80\xb5\x18\x01\x12\
    \x20\n\x08verified\x18\x03\x20\x01(\x08R\x08verifiedB\x04\x80\xb5\x18\
    \x01\"(\n\x08Password\x12\x1c\n\tplaintext\x18\x01\x20\x01(\tR\tplaintex\
    t\"\xf2\x04\n\x12PasswordViolations\x12%\n\x0eminimum_length\x18\x01\x20\
    \x01(\x08R\rminimumLength\x12%\n\x0emaximum_length\x18\x02\x20\x01(\x08R\
    \rmaximumLength\x12*\n\x11upper_case_needed\x18\x03\x20\x01(\x08R\x0fupp\
    erCaseNeeded\x12*\n\x11lower_case_needed\x18\x04\x20\x01(\x08R\x0flowerC\
    aseNeeded\x12%\n\x0enumeric_needed\x18\x05\x20\x01(\x08R\rnumericNeeded\
    \x126\n\x17non_alphanumeric_needed\x18\x06\x20\x01(\x08R\x15nonAlphanume\
    ricNeeded\x12%\n\x0epassword_reuse\x18\x07\x20\x01(\x08R\rpasswordReuse\
    \x12#\n\rexclude_names\x18\x08\x20\x01(\x08R\x0cexcludeNames\x12#\n\rexc\
    lude_email\x18\t\x20\x01(\x08R\x0cexcludeEmail\x120\n\x14no_confusing_le\
    tters\x18\n\x20\x01(\x08R\x12noConfusingLetters\x12.\n\x13no_simple_pass\
    words\x18\x0b\x20\x01(\x08R\x11noSimplePasswords\x12(\n\x10no_common_voc\
    abs\x18\x0c\x20\x01(\x08R\x0enoCommonVocabs\x12-\n\x13no_overlap_with_ol\
    d\x18\r\x20\x01(\x08R\x10noOverlapWithOld\x12+\n\x11password_lifespan\
    \x18\x0e\x20\x01(\x08R\x10passwordLifespan\"\xef\x01\n\x05Video\x12\x10\
    \n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x16\n\x06base64\x18\x02\x20\x01\
    (\x0cR\x06base64\x12.\n\x13allow_duplicate_url\x18\x04\x20\x01(\x08R\x11\
    allowDuplicateUrl\x12#\n\rthumbnail_url\x18\x05\x20\x01(\tR\x0cthumbnail\
    Url\x12/\n\x06hosted\x18\x06\x20\x01(\x0b2\x17.clarifai.api.HostedURLR\
    \x06hosted\x126\n\nvideo_info\x18\x07\x20\x01(\x0b2\x17.clarifai.api.Vid\
    eoInfoR\tvideoInfo\"\xd5\x01\n\tVideoInfo\x12\x14\n\x05width\x18\x01\x20\
    \x01(\x05R\x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\
    \x12\x10\n\x03fps\x18\x03\x20\x01(\x02R\x03fps\x12!\n\x0cvideo_format\
    \x18\x04\x20\x01(\tR\x0bvideoFormat\x12\x19\n\x08bit_rate\x18\x05\x20\
    \x01(\x05R\x07bitRate\x12\x1f\n\x0bframe_count\x18\x06\x20\x01(\x05R\nfr\
    ameCount\x12)\n\x10duration_seconds\x18\x07\x20\x01(\x02R\x0fdurationSec\
    onds\"\xb5\x04\n\x08Workflow\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x15\n\x06app_id\x18\x02\x20\x01(\tR\x05appId\x129\n\ncreated_at\x18\
    \x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x120\n\x05n\
    odes\x18\x04\x20\x03(\x0b2\x1a.clarifai.api.WorkflowNodeR\x05nodes\x123\
    \n\x08metadata\x18\x05\x20\x01(\x0b2\x17.google.protobuf.StructR\x08meta\
    data\x128\n\nvisibility\x18\x06\x20\x01(\x0b2\x18.clarifai.api.Visibilit\
    yR\nvisibility\x12\x17\n\x07user_id\x18\x07\x20\x01(\tR\x06userId\x12;\n\
    \x0bmodified_at\x18\x08\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nmo\
    difiedAt\x127\n\x07version\x18\t\x20\x01(\x0b2\x1d.clarifai.api.Workflow\
    VersionR\x07version\x12\x1d\n\nis_starred\x18\n\x20\x01(\x08R\tisStarred\
    \x12\x1d\n\nstar_count\x18\x0b\x20\x01(\x05R\tstarCount\x12\x20\n\x0bdes\
    cription\x18\x0c\x20\x01(\tR\x0bdescription\x12\x14\n\x05notes\x18\r\x20\
    \x01(\tR\x05notes\x12!\n\tuse_cases\x18\x0e\x20\x03(\tR\x08useCasesB\x04\
    \x80\xb5\x18\x01\"\xc7\x03\n\x0fWorkflowVersion\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflo\
    wId\x129\n\ncreated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.Timesta\
    mpR\tcreatedAt\x12;\n\x0bmodified_at\x18\x04\x20\x01(\x0b2\x1a.google.pr\
    otobuf.TimestampR\nmodifiedAt\x128\n\nvisibility\x18\x05\x20\x01(\x0b2\
    \x18.clarifai.api.VisibilityR\nvisibility\x120\n\x05nodes\x18\x06\x20\
    \x03(\x0b2\x1a.clarifai.api.WorkflowNodeR\x05nodes\x123\n\x08metadata\
    \x18\x07\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\x12\x15\n\
    \x06app_id\x18\x08\x20\x01(\tR\x05appId\x12\x17\n\x07user_id\x18\t\x20\
    \x01(\tR\x06userId\x12\x20\n\x0bdescription\x18\n\x20\x01(\tR\x0bdescrip\
    tion\x12\x18\n\x07license\x18\x0b\x20\x01(\tR\x07license\"\xac\x01\n\x0c\
    WorkflowNode\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12)\n\x05model\
    \x18\x02\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05model\x128\n\x0bnode_i\
    nputs\x18\x03\x20\x03(\x0b2\x17.clarifai.api.NodeInputR\nnodeInputs\x12'\
    \n\x0fsuppress_output\x18\x04\x20\x01(\x08R\x0esuppressOutput\"$\n\tNode\
    Input\x12\x17\n\x07node_id\x18\x01\x20\x01(\tR\x06nodeId\"\xbf\x02\n\x0e\
    WorkflowResult\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x123\n\x06statu\
    s\x18\x02\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x129\n\
    \ncreated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreat\
    edAt\x12)\n\x05model\x18\x04\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05mo\
    del\x12)\n\x05input\x18\x05\x20\x01(\x0b2\x13.clarifai.api.InputR\x05inp\
    ut\x12.\n\x07outputs\x18\x06\x20\x03(\x0b2\x14.clarifai.api.OutputR\x07o\
    utputs\x12'\n\x0fsuppress_output\x18\x07\x20\x01(\x08R\x0esuppressOutput\
    \"\x1f\n\rWorkflowState\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\xd3\
    \x02\n\x0eAppDuplication\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x1c\n\nnew_app_id\x18\x02\x20\x01(\tR\x08newAppId\x12\x20\n\x0cnew_app_\
    name\x18\x03\x20\x01(\tR\nnewAppName\x123\n\x06status\x18\x04\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x129\n\ncreated_at\x18\
    \x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12D\n\x10l\
    ast_modified_at\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0e\
    lastModifiedAt\x12;\n\x06filter\x18\x07\x20\x01(\x0b2#.clarifai.api.AppD\
    uplicationFiltersR\x06filter\"\xd0\x01\n\x15AppDuplicationFilters\x12\
    \x1f\n\x0bcopy_inputs\x18\x01\x20\x01(\x08R\ncopyInputs\x12#\n\rcopy_con\
    cepts\x18\x02\x20\x01(\x08R\x0ccopyConcepts\x12)\n\x10copy_annotations\
    \x18\x03\x20\x01(\x08R\x0fcopyAnnotations\x12\x1f\n\x0bcopy_models\x18\
    \x04\x20\x01(\x08R\ncopyModels\x12%\n\x0ecopy_workflows\x18\x05\x20\x01(\
    \x08R\rcopyWorkflows\"\xf4\x06\n\x04Task\x12\x0e\n\x02id\x18\x01\x20\x01\
    (\tR\x02id\x129\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.\
    TimestampR\tcreatedAt\x12;\n\x0bmodified_at\x18\x03\x20\x01(\x0b2\x1a.go\
    ogle.protobuf.TimestampR\nmodifiedAt\x12/\n\x04type\x18\x04\x20\x01(\x0e\
    2\x1b.clarifai.api.Task.TaskTypeR\x04type\x12\x20\n\x0bdescription\x18\
    \x05\x20\x01(\tR\x0bdescription\x120\n\x06worker\x18\x06\x20\x01(\x0b2\
    \x18.clarifai.api.TaskWorkerR\x06worker\x12\x1f\n\x0bconcept_ids\x18\x07\
    \x20\x03(\tR\nconceptIds\x12@\n\x0cinput_source\x18\x08\x20\x01(\x0b2\
    \x1d.clarifai.api.TaskInputSourceR\x0binputSource\x12\x1b\n\tsample_ms\
    \x18\t\x20\x01(\rR\x08sampleMs\x12@\n\x0cai_assistant\x18\n\x20\x01(\x0b\
    2\x1d.clarifai.api.TaskAIAssistantR\x0baiAssistant\x120\n\x06review\x18\
    \x0b\x20\x01(\x0b2\x18.clarifai.api.TaskReviewR\x06review\x123\n\x06stat\
    us\x18\x0c\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    \x12\n\x04name\x18\r\x20\x01(\tR\x04name\x12J\n\x10ai_assist_params\x18\
    \x0e\x20\x01(\x0b2\x20.clarifai.api.AiAssistParametersR\x0eaiAssistParam\
    s\x128\n\nvisibility\x18\x0f\x20\x01(\x0b2\x18.clarifai.api.VisibilityR\
    \nvisibility\x12\x15\n\x06app_id\x18\x10\x20\x01(\tR\x05appId\x12\x17\n\
    \x07user_id\x18\x11\x20\x01(\tR\x06userId\"l\n\x08TaskType\x12\x10\n\x0c\
    TYPE_NOT_SET\x10\0\x12\x1b\n\x17CONCEPTS_CLASSIFICATION\x10\x01\x12\x1a\
    \n\x16BOUNDING_BOX_DETECTION\x10\x02\x12\x15\n\x11POLYGON_DETECTION\x10\
    \x03\"\x90\x01\n\x12AiAssistParameters\x12#\n\rmin_threshold\x18\x01\x20\
    \x01(\x02R\x0cminThreshold\x12#\n\rmax_threshold\x18\x02\x20\x01(\x02R\
    \x0cmaxThreshold\x120\n\x14concept_relation_ids\x18\x03\x20\x03(\tR\x12c\
    onceptRelationIds\"\xc4\x02\n\nTaskWorker\x12G\n\x08strategy\x18\x01\x20\
    \x01(\x0e2+.clarifai.api.TaskWorker.TaskWorkerStrategyR\x08strategy\x12\
    \x19\n\x08user_ids\x18\x02\x20\x03(\tR\x07userIds\x12m\n\x19partitioned_\
    strategy_info\x18\x03\x20\x01(\x0b2/.clarifai.api.TaskWorkerPartitionedS\
    trategyInfoH\0R\x17partitionedStrategyInfo\"R\n\x12TaskWorkerStrategy\
    \x12\x1b\n\x17WORKER_STRATEGY_NOT_SET\x10\0\x12\x0f\n\x0bPARTITIONED\x10\
    \x02\x12\x08\n\x04FULL\x10\x03\"\x04\x08\x01\x10\x01B\x0f\n\rstrategy_in\
    fo\"\xc9\x02\n!TaskWorkerPartitionedStrategyInfo\x12a\n\x04type\x18\x01\
    \x20\x01(\x0e2M.clarifai.api.TaskWorkerPartitionedStrategyInfo.TaskWorke\
    rPartitionedStrategyR\x04type\x12*\n\x11workers_per_input\x18\x02\x20\
    \x01(\x05R\x0fworkersPerInput\x121\n\x07weights\x18\x03\x20\x01(\x0b2\
    \x17.google.protobuf.StructR\x07weights\"b\n\x1dTaskWorkerPartitionedStr\
    ategy\x12'\n#PARTITIONED_WORKER_STRATEGY_NOT_SET\x10\0\x12\n\n\x06EVENLY\
    \x10\x01\x12\x0c\n\x08WEIGHTED\x10\x02\"\xc0\x01\n\x0fTaskInputSource\
    \x12E\n\x04type\x18\x01\x20\x01(\x0e21.clarifai.api.TaskInputSource.Task\
    InputSourceTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"V\n\
    \x13TaskInputSourceType\x12\x1d\n\x19INPUT_SOURCE_TYPE_NOT_SET\x10\0\x12\
    \x0e\n\nALL_INPUTS\x10\x01\x12\x10\n\x0cSAVED_SEARCH\x10\x02\"\xa7\x03\n\
    \nTaskReview\x12G\n\x08strategy\x18\x01\x20\x01(\x0e2+.clarifai.api.Task\
    Review.TaskReviewStrategyR\x08strategy\x12\x19\n\x08user_ids\x18\x02\x20\
    \x03(\tR\x07userIds\x12^\n\x14manual_strategy_info\x18\x03\x20\x01(\x0b2\
    *.clarifai.api.TaskReviewManualStrategyInfoH\0R\x12manualStrategyInfo\
    \x12g\n\x17consensus_strategy_info\x18\x04\x20\x01(\x0b2-.clarifai.api.T\
    askReviewConsensusStrategyInfoH\0R\x15consensusStrategyInfo\"[\n\x12Task\
    ReviewStrategy\x12\x20\n\x1cTASK_REVIEW_STRATEGY_NOT_SET\x10\0\x12\x08\n\
    \x04NONE\x10\x01\x12\n\n\x06MANUAL\x10\x02\x12\r\n\tCONSENSUS\x10\x03B\
    \x0f\n\rstrategy_info\"K\n\x1cTaskReviewManualStrategyInfo\x12+\n\x11sam\
    ple_percentage\x18\x01\x20\x01(\x02R\x10samplePercentage\"V\n\x1fTaskRev\
    iewConsensusStrategyInfo\x12-\n\x12approval_threshold\x18\x02\x20\x01(\r\
    R\x11approvalThresholdJ\x04\x08\x01\x10\x02\"2\n\x0fTaskAIAssistant\x12\
    \x1f\n\x0bworkflow_id\x18\x01\x20\x01(\tR\nworkflowId\"\x8d\x02\n\x16Tas\
    kStatusCountPerUser\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\x06userId\
    \x12\x1e\n\x07pending\x18\x02\x20\x01(\rR\x07pendingB\x04\x80\xb5\x18\
    \x01\x12-\n\x0fawaiting_review\x18\x03\x20\x01(\rR\x0eawaitingReviewB\
    \x04\x80\xb5\x18\x01\x12\x1e\n\x07success\x18\x04\x20\x01(\rR\x07success\
    B\x04\x80\xb5\x18\x01\x12)\n\rreview_denied\x18\x05\x20\x01(\rR\x0crevie\
    wDeniedB\x04\x80\xb5\x18\x01\x12@\n\x19awaiting_consensus_review\x18\x06\
    \x20\x01(\rR\x17awaitingConsensusReviewB\x04\x80\xb5\x18\x01\"\xdf\x02\n\
    \tCollector\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x20\n\x0bdescr\
    iption\x18\x02\x20\x01(\tR\x0bdescription\x129\n\ncreated_at\x18\x03\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x121\n\x15pre_queue\
    _workflow_id\x18\x04\x20\x01(\tR\x12preQueueWorkflowId\x123\n\x16post_qu\
    eue_workflow_id\x18\x05\x20\x01(\tR\x13postQueueWorkflowId\x12H\n\x10col\
    lector_source\x18\x06\x20\x01(\x0b2\x1d.clarifai.api.CollectorSourceR\
    \x0fcollectorSource\x123\n\x06status\x18\x07\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\"\x99\x01\n\x0fCollectorSource\x12\x85\x01\
    \n'api_post_model_outputs_collector_source\x18\x02\x20\x01(\x0b20.clarif\
    ai.api.APIPostModelOutputsCollectorSourceR\"apiPostModelOutputsCollector\
    Source\"\xdc\x01\n\"APIPostModelOutputsCollectorSource\x12\"\n\rmodel_us\
    er_id\x18\x01\x20\x01(\tR\x0bmodelUserId\x12\x20\n\x0cmodel_app_id\x18\
    \x02\x20\x01(\tR\nmodelAppId\x12\x19\n\x08model_id\x18\x03\x20\x01(\tR\
    \x07modelId\x12(\n\x10model_version_id\x18\x04\x20\x01(\tR\x0emodelVersi\
    onId\x12+\n\x12post_inputs_key_id\x18\x05\x20\x01(\tR\x0fpostInputsKeyId\
    \"e\n\tStatValue\x12.\n\x04time\x18\x01\x20\x01(\x0b2\x1a.google.protobu\
    f.TimestampR\x04time\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value\
    \x12\x12\n\x04tags\x18\x03\x20\x03(\tR\x04tags\"\xd4\x01\n\x18StatValueA\
    ggregateResult\x12T\n\x15stat_value_aggregates\x18\x01\x20\x03(\x0b2\x20\
    .clarifai.api.StatValueAggregateR\x13statValueAggregates\x12b\n\x1astat_\
    value_aggregate_query\x18\x02\x20\x01(\x0b2%.clarifai.api.StatValueAggre\
    gateQueryR\x17statValueAggregateQuery\"\x97\x01\n\x12StatValueAggregate\
    \x12.\n\x04time\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x04\
    time\x12'\n\x0faggregate_value\x18\x02\x20\x01(\x02R\x0eaggregateValue\
    \x12\x14\n\x05count\x18\x03\x20\x01(\x04R\x05count\x12\x12\n\x04tags\x18\
    \x04\x20\x03(\tR\x04tags\"\xd9\x02\n\x17StatValueAggregateQuery\x12\x12\
    \n\x04tags\x18\x01\x20\x03(\tR\x04tags\x12\x1d\n\ntag_groups\x18\x02\x20\
    \x03(\tR\ttagGroups\x12M\n\x13stat_value_agg_type\x18\x03\x20\x01(\x0e2\
    \x1e.clarifai.api.StatValueAggTypeR\x10statValueAggType\x12J\n\x12stat_t\
    ime_agg_type\x18\x04\x20\x01(\x0e2\x1d.clarifai.api.StatTimeAggTypeR\x0f\
    statTimeAggType\x129\n\nstart_time\x18\x05\x20\x01(\x0b2\x1a.google.prot\
    obuf.TimestampR\tstartTime\x125\n\x08end_time\x18\x06\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\x07endTime\"\x91\x01\n\nVisibility\x12=\n\x08\
    gettable\x18\x01\x20\x01(\x0e2!.clarifai.api.Visibility.GettableR\x08get\
    table\"D\n\x08Gettable\x12\x16\n\x12UNKNOWN_VISIBILITY\x10\0\x12\x0b\n\
    \x07PRIVATE\x10\n\x12\x07\n\x03ORG\x10\x1e\x12\n\n\x06PUBLIC\x102\"|\n\
    \x0eTrendingMetric\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\x06userId\
    \x12\x15\n\x06app_id\x18\x02\x20\x01(\tR\x05appId\x12\x1b\n\tobject_id\
    \x18\x03\x20\x01(\tR\x08objectId\x12\x1d\n\nview_count\x18\x04\x20\x01(\
    \x04R\tviewCount\"z\n\x0bTimeSegment\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12&\n\x04data\x18\x02\x20\x01(\x0b2\x12.clarifai.api.DataR\x04da\
    ta\x123\n\ttime_info\x18\x03\x20\x01(\x0b2\x16.clarifai.api.TimeInfoR\
    \x08timeInfo\"c\n\x08TimeInfo\x12\x1d\n\nnum_frames\x18\x01\x20\x01(\rR\
    \tnumFrames\x12\x1d\n\nbegin_time\x18\x02\x20\x01(\rR\tbeginTime\x12\x19\
    \n\x08end_time\x18\x03\x20\x01(\rR\x07endTime*H\n\x10ExpirationAction\
    \x12\x1d\n\x19EXPIRATION_ACTION_NOT_SET\x10\0\x12\t\n\x05DELAY\x10\x01\
    \x12\n\n\x06EXPIRY\x10\x02*M\n\x0cLicenseScope\x12\x19\n\x15LICENSE_SCOP\
    E_NOT_SET\x10\0\x12\x0b\n\x07PREDICT\x10\x01\x12\t\n\x05TRAIN\x10\x02\
    \x12\n\n\x06SEARCH\x10\x03*\x8f\x01\n\x0fValueComparator\x12\x1d\n\x19CO\
    NCEPT_THRESHOLD_NOT_SET\x10\0\x12\x10\n\x0cGREATER_THAN\x10\x01\x12\x19\
    \n\x15GREATER_THAN_OR_EQUAL\x10\x02\x12\r\n\tLESS_THAN\x10\x03\x12\x16\n\
    \x12LESS_THAN_OR_EQUAL\x10\x04\x12\t\n\x05EQUAL\x10\x05*3\n\x0eEvaluatio\
    nType\x12\x12\n\x0eClassification\x10\0\x12\r\n\tDetection\x10\x01*f\n\
    \x0cAPIEventType\x12\x1a\n\x16API_EVENT_TYPE_NOT_SET\x10\0\x12\x13\n\x0f\
    ON_PREM_PREDICT\x10\x01\x12\x11\n\rON_PREM_TRAIN\x10\x02\x12\x12\n\x0eON\
    _PREM_SEARCH\x10\x03*<\n\x11UsageIntervalType\x12\t\n\x05undef\x10\0\x12\
    \x07\n\x03day\x10\x01\x12\t\n\x05month\x10\x02\x12\x08\n\x04year\x10\x03\
    *\x1d\n\x08RoleType\x12\x08\n\x04TEAM\x10\0\x12\x07\n\x03ORG\x10\x01*$\n\
    \x10StatValueAggType\x12\x07\n\x03SUM\x10\0\x12\x07\n\x03AVG\x10\x01*`\n\
    \x0fStatTimeAggType\x12\x0f\n\x0bNO_TIME_AGG\x10\0\x12\x08\n\x04YEAR\x10\
    \x01\x12\t\n\x05MONTH\x10\x02\x12\x08\n\x04WEEK\x10\x03\x12\x07\n\x03DAY\
    \x10\x04\x12\x08\n\x04HOUR\x10\x05\x12\n\n\x06MINUTE\x10\x06*b\n\x13Vali\
    dationErrorType\x12!\n\x1dVALIDATION_ERROR_TYPE_NOT_SET\x10\0\x12\x0e\n\
    \nRESTRICTED\x10\x01\x12\x0c\n\x08DATABASE\x10\x02\x12\n\n\x06FORMAT\x10\
    \x03B]\n\x15com.clarifai.grpc.apiP\x01Z;github.com/Clarifai/clarifai-go-\
    grpc/proto/clarifai/api/api\xa2\x02\x04CAIPJ\x82\xc5\x07\n\x07\x12\x05\0\
    \0\xff\x16\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\x02\x03\0\x12\x03\
    \x02\00\n\t\n\x02\x03\x01\x12\x03\x03\03\n\t\n\x02\x03\x02\x12\x03\x04\0\
    2\n\t\n\x02\x03\x03\x12\x03\x06\0&\n\t\n\x02\x03\x04\x12\x03\x07\0)\n\
    \x08\n\x01\x02\x12\x03\t\0\x15\n\x08\n\x01\x08\x12\x03\x0b\0R\n\t\n\x02\
    \x08\x0b\x12\x03\x0b\0R\n\x08\n\x01\x08\x12\x03\x0c\0\"\n\t\n\x02\x08\n\
    \x12\x03\x0c\0\"\n\x08\n\x01\x08\x12\x03\r\0.\n\t\n\x02\x08\x01\x12\x03\
    \r\0.\n\x08\n\x01\x08\x12\x03\x0e\0\"\n\t\n\x02\x08$\x12\x03\x0e\0\"\n\
    \xdf\x01\n\x02\x04\0\x12\x04\x18\0I\x01\x1a\xd2\x01/////////////////////\
    /////////////////////////////////////////////////////////\n\x20Messages\
    \x20from\x20/proto/clarifai/api/annotation.proto\n//////////////////////\
    ////////////////////////////////////////////////////////\n\n\n\n\x03\x04\
    \0\x01\x12\x03\x18\x08\x12\n\n\n\x03\x04\0\t\x12\x03\x19\x02\x1b\n\x0b\n\
    \x04\x04\0\t\0\x12\x03\x19\x0b\x0c\n\x0c\n\x05\x04\0\t\0\x01\x12\x03\x19\
    \x0b\x0c\n\x0c\n\x05\x04\0\t\0\x02\x12\x03\x19\x0b\x0c\n\x0b\n\x04\x04\0\
    \t\x01\x12\x03\x19\x0e\x0f\n\x0c\n\x05\x04\0\t\x01\x01\x12\x03\x19\x0e\
    \x0f\n\x0c\n\x05\x04\0\t\x01\x02\x12\x03\x19\x0e\x0f\n\x0b\n\x04\x04\0\t\
    \x02\x12\x03\x19\x11\x12\n\x0c\n\x05\x04\0\t\x02\x01\x12\x03\x19\x11\x12\
    \n\x0c\n\x05\x04\0\t\x02\x02\x12\x03\x19\x11\x12\n\x0b\n\x04\x04\0\t\x03\
    \x12\x03\x19\x14\x16\n\x0c\n\x05\x04\0\t\x03\x01\x12\x03\x19\x14\x16\n\
    \x0c\n\x05\x04\0\t\x03\x02\x12\x03\x19\x14\x16\n\x0b\n\x04\x04\0\t\x04\
    \x12\x03\x19\x18\x1a\n\x0c\n\x05\x04\0\t\x04\x01\x12\x03\x19\x18\x1a\n\
    \x0c\n\x05\x04\0\t\x04\x02\x12\x03\x19\x18\x1a\n(\n\x04\x04\0\x02\0\x12\
    \x03\x1c\x02\x10\x1a\x1b\x20The\x20ID\x20for\x20the\x20annotation\n\n\
    \x0c\n\x05\x04\0\x02\0\x05\x12\x03\x1c\x02\x08\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03\x1c\t\x0b\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1c\x0e\x0f\n\
    9\n\x04\x04\0\x02\x01\x12\x03\x1f\x02\x16\x1a,\x20ID\x20of\x20the\x20inp\
    ut\x20this\x20annotation\x20is\x20tied\x20to\n\n\x0c\n\x05\x04\0\x02\x01\
    \x05\x12\x03\x1f\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x1f\t\x11\
    \n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1f\x14\x15\n8\n\x04\x04\0\x02\
    \x02\x12\x03\"\x02\x10\x1a+\x20The\x20data\x20passed\x20along\x20in\x20t\
    his\x20annotation.\n\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\"\x02\x06\n\
    \x0c\n\x05\x04\0\x02\x02\x01\x12\x03\"\x07\x0b\n\x0c\n\x05\x04\0\x02\x02\
    \x03\x12\x03\"\x0e\x0f\nD\n\x04\x04\0\x02\x03\x12\x03%\x02.\x1a7\x20task\
    _id\x20is\x20deprecated\x20in\x20annotation_info.\x20Use\x20task_id\n\n\
    \x0c\n\x05\x04\0\x02\x03\x06\x12\x03%\x02\x18\n\x0c\n\x05\x04\0\x02\x03\
    \x01\x12\x03%\x19(\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03%+-\n;\n\x04\x04\
    \0\x02\x04\x12\x03(\x02\x16\x1a.\x20ID\x20of\x20the\x20user\x20this\x20a\
    nnotation\x20is\x20created\x20by\n\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\
    (\x02\x08\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03(\t\x10\n\x0c\n\x05\x04\0\
    \x02\x04\x03\x12\x03(\x13\x15\nD\n\x04\x04\0\x02\x05\x12\x03*\x02\x1f\
    \x1a7\x20ID\x20of\x20the\x20model\x20version\x20this\x20annotation\x20is\
    \x20created\x20by\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03*\x02\x08\n\x0c\
    \n\x05\x04\0\x02\x05\x01\x12\x03*\t\x19\n\x0c\n\x05\x04\0\x02\x05\x03\
    \x12\x03*\x1c\x1e\n\x1a\n\x04\x04\0\x02\x06\x12\x03-\x027\x1a\r\x20DEPRE\
    CATED.\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03-\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x06\x01\x12\x03-\t\x1f\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03-\"$\
    \n\x0c\n\x05\x04\0\x02\x06\x08\x12\x03-%6\n\r\n\x06\x04\0\x02\x06\x08\
    \x03\x12\x03-&5\n\x20\n\x04\x04\0\x02\x07\x12\x030\x02(\x1a\x13\x20Annot\
    ation\x20Status\n\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x030\x02\x1c\n\x0c\n\
    \x05\x04\0\x02\x07\x01\x12\x030\x1d#\n\x0c\n\x05\x04\0\x02\x07\x03\x12\
    \x030&'\n\x84\x02\n\x04\x04\0\x02\x08\x12\x037\x02+\x1a\xf6\x01\x20When\
    \x20the\x20annotation\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\
    \x20timestamp\n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3\
    339.txt\x20format:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20\
    can\x20expect\x20results\x20like\n\x20the\x20following\x20from\x20the\
    \x20API:\n\x20\"2017-04-11T21:50:50.223962Z\"\n\n\x0c\n\x05\x04\0\x02\
    \x08\x06\x12\x037\x02\x1b\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x037\x1c&\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x037)*\n0\n\x04\x04\0\x02\t\x12\x03:\
    \x02,\x1a#\x20When\x20the\x20annotation\x20was\x20modified.\n\n\x0c\n\
    \x05\x04\0\x02\t\x06\x12\x03:\x02\x1b\n\x0c\n\x05\x04\0\x02\t\x01\x12\
    \x03:\x1c'\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03:*+\nL\n\x04\x04\0\x02\n\
    \x12\x03>\x02%\x1a?\x20Whether\x20or\x20not\x20this\x20annotation\x20is\
    \x20trusted\n\x20Will\x20be\x20deprecated\n\n\x0c\n\x05\x04\0\x02\n\x05\
    \x12\x03>\x02\x06\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03>\x07\x0e\n\x0c\n\
    \x05\x04\0\x02\n\x03\x12\x03>\x11\x13\n\x0c\n\x05\x04\0\x02\n\x08\x12\
    \x03>\x13$\n\r\n\x06\x04\0\x02\n\x08\x03\x12\x03>\x14#\n2\n\x04\x04\0\
    \x02\x0b\x12\x03A\x02\x18\x1a%\x20Is\x20this\x20the\x20input\x20level\
    \x20annotation.\n\n\x0c\n\x05\x04\0\x02\x0b\x05\x12\x03A\x02\x06\n\x0c\n\
    \x05\x04\0\x02\x0b\x01\x12\x03A\x07\x12\n\x0c\n\x05\x04\0\x02\x0b\x03\
    \x12\x03A\x15\x17\n\xa3\x01\n\x04\x04\0\x02\x0c\x12\x03F\x02-\x1a\x95\
    \x01\x20Consensus\x20review\x20related\x20information,\x20e.g.\n\x20*\
    \x20annotation\x20group\n\x20*\x20id\x20of\x20annotation\x20parent,\x20i\
    n\x20case\x20the\x20annotation\x20was\x20split\x20from\x20another\x20ann\
    otation\n\n\x0c\n\x05\x04\0\x02\x0c\x06\x12\x03F\x02\x18\n\x0c\n\x05\x04\
    \0\x02\x0c\x01\x12\x03F\x19'\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03F*,\n7\
    \n\x04\x04\0\x02\r\x12\x03H\x02\x16\x1a*\x20The\x20id\x20of\x20the\x20ta\
    sk\x20annotation\x20belongs\x20to\n\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03H\
    \x02\x08\n\x0c\n\x05\x04\0\x02\r\x01\x12\x03H\t\x10\n\x0c\n\x05\x04\0\
    \x02\r\x03\x12\x03H\x13\x15\n\xaa\x02\n\x02\x04\x01\x12\x05U\0\x81\x01\
    \x01\x1a\xcb\x01////////////////////////////////////////////////////////\
    //////////////////////\n\x20Messages\x20from\x20/proto/clarifai/api/app.\
    proto\n/////////////////////////////////////////////////////////////////\
    /////////////\n2O///////////////////////////////////////////////////////\
    ///////////////////////\n\n\n\n\x03\x04\x01\x01\x12\x03U\x08\x0b\n\n\n\
    \x03\x04\x01\t\x12\x03V\x02\x16\n\x0b\n\x04\x04\x01\t\0\x12\x03V\x0b\r\n\
    \x0c\n\x05\x04\x01\t\0\x01\x12\x03V\x0b\r\n\x0c\n\x05\x04\x01\t\0\x02\
    \x12\x03V\x0b\r\n\x0b\n\x04\x04\x01\t\x01\x12\x03V\x0f\x11\n\x0c\n\x05\
    \x04\x01\t\x01\x01\x12\x03V\x0f\x11\n\x0c\n\x05\x04\x01\t\x01\x02\x12\
    \x03V\x0f\x11\n\x0b\n\x04\x04\x01\t\x02\x12\x03V\x13\x15\n\x0c\n\x05\x04\
    \x01\t\x02\x01\x12\x03V\x13\x15\n\x0c\n\x05\x04\x01\t\x02\x02\x12\x03V\
    \x13\x15\n\x0b\n\x04\x04\x01\x02\0\x12\x03W\x02\x10\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03W\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03W\t\x0b\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03W\x0e\x0f\n\x0b\n\x04\x04\x01\x02\
    \x01\x12\x03X\x02\x12\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03X\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\x01\x01\x12\x03X\t\r\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03X\x10\x11\n\x0b\n\x04\x04\x01\x02\x02\x12\x03Y\x02\x1e\n\x0c\
    \n\x05\x04\x01\x02\x02\x05\x12\x03Y\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x03Y\t\x19\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03Y\x1c\x1d\n\
    \x0b\n\x04\x04\x01\x02\x03\x12\x03Z\x02!\n\x0c\n\x05\x04\x01\x02\x03\x05\
    \x12\x03Z\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03Z\t\x1c\n\x0c\n\
    \x05\x04\x01\x02\x03\x03\x12\x03Z\x1f\x20\n\x9a\x03\n\x04\x04\x01\x02\
    \x04\x12\x03]\x02\x15\x1a\x8c\x03why\x20is\x20user_id\x20present\x20here\
    \x20when\x20this\x20message\x20type\x20is\x20used\x20in\x20PostApps\x20b\
    ut\x20completely\x20ignored\x20there?\x20PostApp\x20already\x20specifies\
    \x20the\x20userid\x20in\x20path\x20but\x20doesn't\x20even\x20actually\
    \x20use\x20neither\x20of\x20userids,\x20it\x20instead\x20used\x20the\x20\
    id\x20from\x20auth\x20context.\nThis\x20creates\x20a\x20lot\x20of\x20amb\
    iguity,\x20should\x20always\x20have\x20different\x20message\x20types\x20\
    for\x20Post/Get\x20endpoints\x20so\x20that\x20the\x20minimum\x20interfac\
    e\x20for\x20each\x20op\x20can\x20be\x20described\n\n\x0c\n\x05\x04\x01\
    \x02\x04\x05\x12\x03]\x02\x08\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03]\t\
    \x10\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03]\x13\x14\n\xfd\x01\n\x04\
    \x04\x01\x02\x05\x12\x03c\x02+\x1a\xef\x01\x20When\x20the\x20app\x20was\
    \x20created.\x20We\x20follow\x20the\x20XXXX\x20timestamp\n\x20format.\
    \x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"\
    2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20expect\x20results\
    \x20like\n\x20the\x20following\x20from\x20the\x20API:\n\x20\"2017-04-11T\
    21:50:50.223962Z\"\n\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\x03c\x02\x1b\n\
    \x0c\n\x05\x04\x01\x02\x05\x01\x12\x03c\x1c&\n\x0c\n\x05\x04\x01\x02\x05\
    \x03\x12\x03c)*\n-\n\x04\x04\x01\x02\x06\x12\x03e\x02,\x1a\x20\x20When\
    \x20the\x20app\x20was\x20last\x20modified\n\n\x0c\n\x05\x04\x01\x02\x06\
    \x06\x12\x03e\x02\x1b\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03e\x1c'\n\
    \x0c\n\x05\x04\x01\x02\x06\x03\x12\x03e)+\n@\n\x04\x04\x01\x02\x07\x12\
    \x03g\x02\"\x1a3\x20if\x20user\x20accept\x20legal\x20consent\x20for\x20f\
    ace\x20recognition\n\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\x03g\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\x07\x01\x12\x03g\t\x1d\n\x0c\n\x05\x04\x01\x02\
    \x07\x03\x12\x03g\x20!\n\x9e\x01\n\x04\x04\x01\x02\x08\x12\x03k\x02'\x1a\
    \x90\x01\x20To\x20handle\x20arbitrary\x20json\x20metadata\x20you\x20can\
    \x20use\x20a\x20struct\x20field:\n\x20https://github.com/google/protobuf\
    /blob/master/src/google/protobuf/struct.proto\n\n\x0c\n\x05\x04\x01\x02\
    \x08\x06\x12\x03k\x02\x18\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03k\x19!\
    \n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03k$&\n/\n\x04\x04\x01\x02\t\x12\
    \x03n\x02\x1a\x1a\"\x20short\x20description\x20about\x20the\x20app.\n\n\
    \x0c\n\x05\x04\x01\x02\t\x05\x12\x03n\x02\x08\n\x0c\n\x05\x04\x01\x02\t\
    \x01\x12\x03n\t\x14\n\x0c\n\x05\x04\x01\x02\t\x03\x12\x03n\x17\x19\n{\n\
    \x04\x04\x01\x02\n\x12\x03q\x02\x18\x1an\x20Default\x20value\x20for\x20m\
    odel\x20predictions\x20on\x20video:\x20Sample\x20delay\x20for\x20video\
    \x20predicting\x20(1\x20frame\x20per\x20N\x20milliseconds)\n\n\x0c\n\x05\
    \x04\x01\x02\n\x05\x12\x03q\x02\x08\n\x0c\n\x05\x04\x01\x02\n\x01\x12\
    \x03q\t\x12\n\x0c\n\x05\x04\x01\x02\n\x03\x12\x03q\x15\x17\n\xdc\x01\n\
    \x04\x04\x01\x02\x0b\x12\x03v\x02\x1d\x1a\xce\x01\x20The\x20visibility\
    \x20field\x20represents\x20whether\x20this\x20message\x20is\x20privately\
    /publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20public\
    \x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20User\x20that\
    \x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20visibl\
    e.\n\n\x0c\n\x05\x04\x01\x02\x0b\x06\x12\x03v\x02\x0c\n\x0c\n\x05\x04\
    \x01\x02\x0b\x01\x12\x03v\r\x17\n\x0c\n\x05\x04\x01\x02\x0b\x03\x12\x03v\
    \x1a\x1c\n.\n\x04\x04\x01\x02\x0c\x12\x03y\x02\x1b\x1a!\x20data\x20tier\
    \x20id\x20this\x20app\x20is\x20using.\n\n\x0c\n\x05\x04\x01\x02\x0c\x05\
    \x12\x03y\x02\x08\n\x0c\n\x05\x04\x01\x02\x0c\x01\x12\x03y\t\x15\n\x0c\n\
    \x05\x04\x01\x02\x0c\x03\x12\x03y\x18\x1a\n\x9c\x01\n\x04\x04\x01\x02\r\
    \x12\x03}\x02\x17\x1a\x8e\x01\x20Is\x20starred\x20by\x20the\x20requestin\
    g\x20user\x20(only\x20showed\x20on\x20get/list\x20requests)\n\x20Please\
    \x20use\x20PostAppStars/DeleteAppStars\x20endpoints\x20to\x20star/unstar\
    \x20an\x20app\n\n\x0c\n\x05\x04\x01\x02\r\x05\x12\x03}\x02\x06\n\x0c\n\
    \x05\x04\x01\x02\r\x01\x12\x03}\x07\x11\n\x0c\n\x05\x04\x01\x02\r\x03\
    \x12\x03}\x14\x16\nt\n\x04\x04\x01\x02\x0e\x12\x04\x80\x01\x02\x18\x1af\
    \x20How\x20many\x20users\x20have\x20starred\x20the\x20app\x20(only\x20sh\
    owed\x20on\x20get/list\x20requests)\n\x20Computed\x20value,\x20not\x20ed\
    itable\n\n\r\n\x05\x04\x01\x02\x0e\x05\x12\x04\x80\x01\x02\x07\n\r\n\x05\
    \x04\x01\x02\x0e\x01\x12\x04\x80\x01\x08\x12\n\r\n\x05\x04\x01\x02\x0e\
    \x03\x12\x04\x80\x01\x15\x17\n\x0c\n\x02\x04\x02\x12\x06\x83\x01\0\x86\
    \x01\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\x83\x01\x08\x10\nw\n\x04\x04\
    \x02\x02\0\x12\x04\x85\x01\x02\x12\x1ai\x20Query\x20by\x20application\
    \x20name.\x20This\x20supports\x20wildcard\x20queries\x20like\x20\"gen*\"\
    \x20to\x20match\x20\"general\"\x20as\x20an\x20example.\n\n\r\n\x05\x04\
    \x02\x02\0\x05\x12\x04\x85\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\
    \x04\x85\x01\t\r\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x85\x01\x10\x11\n\
    \xb3\x02\n\x02\x04\x03\x12\x06\x92\x01\0\xaa\x01\x01\x1a\xd3\x01////////\
    //////////////////////////////////////////////////////////////////////\n\
    \x20Messages\x20from\x20/proto/clarifai/api/app_sharing.proto\n/////////\
    /////////////////////////////////////////////////////////////////////\n2\
    O///////////////////////////////////////////////////////////////////////\
    ///////\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x92\x01\x08\x14\n&\n\x04\x04\
    \x03\x02\0\x12\x04\x94\x01\x02\x10\x1a\x18id\x20of\x20this\x20collaborat\
    or\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x94\x01\x02\x08\n\r\n\x05\x04\
    \x03\x02\0\x01\x12\x04\x94\x01\t\x0b\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\
    \x94\x01\x0e\x0f\n\x8a\x01\n\x04\x04\x03\x02\x01\x12\x04\x97\x01\x02\x1b\
    \x1a|the\x20app\x20this\x20collaborator\x20has\x20access\x20to\n\x20FIXM\
    E(zeiler):\x20this\x20should\x20be\x20in\x20the\x20user_app_id.app_id\
    \x20already\x20from\x20the\x20endpoint.\n\n\r\n\x05\x04\x03\x02\x01\x06\
    \x12\x04\x97\x01\x02\x12\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x97\x01\
    \x13\x16\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\x97\x01\x19\x1a\n'\n\x04\
    \x04\x03\x02\x02\x12\x04\x99\x01\x02\x1d\x1a\x19who\x20is\x20this\x20col\
    laborator\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\x99\x01\x02\x13\n\r\n\
    \x05\x04\x03\x02\x02\x01\x12\x04\x99\x01\x14\x18\n\r\n\x05\x04\x03\x02\
    \x02\x03\x12\x04\x99\x01\x1b\x1c\n/\n\x04\x04\x03\x02\x03\x12\x04\x9b\
    \x01\x02\x1d\x1a!the\x20permission\x20this\x20collaborator\n\n\r\n\x05\
    \x04\x03\x02\x03\x04\x12\x04\x9b\x01\x02\n\n\r\n\x05\x04\x03\x02\x03\x05\
    \x12\x04\x9b\x01\x0b\x11\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\x9b\x01\
    \x12\x18\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\x9b\x01\x1b\x1c\n\x0c\n\
    \x04\x04\x03\x02\x04\x12\x04\x9c\x01\x02\x20\n\r\n\x05\x04\x03\x02\x04\
    \x04\x12\x04\x9c\x01\x02\n\n\r\n\x05\x04\x03\x02\x04\x05\x12\x04\x9c\x01\
    \x0b\x11\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\x9c\x01\x12\x1b\n\r\n\x05\
    \x04\x03\x02\x04\x03\x12\x04\x9c\x01\x1e\x1f\n\x82\x02\n\x04\x04\x03\x02\
    \x05\x12\x04\xa3\x01\x02+\x1a\xf3\x01\x20When\x20the\x20app\x20was\x20sh\
    ared\x20with.\x20We\x20follow\x20the\x20XXXX\x20timestamp\n\x20format.\
    \x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"\
    2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20expect\x20results\
    \x20like\n\x20the\x20following\x20from\x20the\x20API:\n\x20\"2017-04-11T\
    21:50:50.223962Z\"\n\n\r\n\x05\x04\x03\x02\x05\x06\x12\x04\xa3\x01\x02\
    \x1b\n\r\n\x05\x04\x03\x02\x05\x01\x12\x04\xa3\x01\x1c&\n\r\n\x05\x04\
    \x03\x02\x05\x03\x12\x04\xa3\x01)*\n2\n\x04\x04\x03\x02\x06\x12\x04\xa6\
    \x01\x02,\x1a$\x20When\x20the\x20collaborator\x20was\x20updated.\n\n\r\n\
    \x05\x04\x03\x02\x06\x06\x12\x04\xa6\x01\x02\x1b\n\r\n\x05\x04\x03\x02\
    \x06\x01\x12\x04\xa6\x01\x1c'\n\r\n\x05\x04\x03\x02\x06\x03\x12\x04\xa6\
    \x01*+\n;\n\x04\x04\x03\x02\x07\x12\x04\xa9\x01\x02+\x1a-\x20When\x20the\
    \x20collaborator\x20was\x20removed\x20from\x20app.\n\n\r\n\x05\x04\x03\
    \x02\x07\x06\x12\x04\xa9\x01\x02\x1b\n\r\n\x05\x04\x03\x02\x07\x01\x12\
    \x04\xa9\x01\x1c&\n\r\n\x05\x04\x03\x02\x07\x03\x12\x04\xa9\x01)*\nG\n\
    \x02\x04\x04\x12\x06\xad\x01\0\xb8\x01\x01\x1a9collaboration\x20includes\
    \x20an\x20app\x20you're\x20invited\x20to\x20work\x20on.\n\n\x0b\n\x03\
    \x04\x04\x01\x12\x04\xad\x01\x08\x15\n\x1e\n\x04\x04\x04\x02\0\x12\x04\
    \xaf\x01\x02\x0e\x1a\x10the\x20application\n\n\r\n\x05\x04\x04\x02\0\x06\
    \x12\x04\xaf\x01\x02\x05\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xaf\x01\x06\
    \t\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xaf\x01\x0c\r\nc\n\x04\x04\x04\
    \x02\x01\x12\x04\xb1\x01\x02\x15\x1aUthe\x20app\x20owner's\x20info(inclu\
    ding\x20user_unique_id,\x20first_name,\x20last_name,\x20primary_email)\n\
    \n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\xb1\x01\x02\x06\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\xb1\x01\x07\x10\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\xb1\x01\x13\x14\nO\n\x04\x04\x04\x02\x02\x12\x04\xb3\x01\x02\x1d\
    \x1aAthe\x20low-level\x20scope\x20users\x20are\x20shared\x20with\x20for\
    \x20this\x20collaboration\n\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xb3\
    \x01\x02\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xb3\x01\x0b\x11\n\r\n\
    \x05\x04\x04\x02\x02\x01\x12\x04\xb3\x01\x12\x18\n\r\n\x05\x04\x04\x02\
    \x02\x03\x12\x04\xb3\x01\x1b\x1c\nU\n\x04\x04\x04\x02\x03\x12\x04\xb5\
    \x01\x02\x20\x1aGthe\x20endpoint-level\x20scopes\x20users\x20are\x20shar\
    ed\x20with\x20for\x20this\x20collaboration\n\n\r\n\x05\x04\x04\x02\x03\
    \x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x04\x02\x03\x05\x12\x04\xb5\x01\
    \x0b\x11\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xb5\x01\x12\x1b\n\r\n\x05\
    \x04\x04\x02\x03\x03\x12\x04\xb5\x01\x1e\x1f\n0\n\x04\x04\x04\x02\x04\
    \x12\x04\xb7\x01\x02+\x1a\"when\x20is\x20the\x20collaboration\x20created\
    \n\n\r\n\x05\x04\x04\x02\x04\x06\x12\x04\xb7\x01\x02\x1b\n\r\n\x05\x04\
    \x04\x02\x04\x01\x12\x04\xb7\x01\x1c&\n\r\n\x05\x04\x04\x02\x04\x03\x12\
    \x04\xb7\x01)*\n\xad\x02\n\x02\x04\x05\x12\x06\xc4\x01\0\xd6\x01\x01\x1a\
    \xcd\x01////////////////////////////////////////////////////////////////\
    //////////////\n\x20Messages\x20from\x20/proto/clarifai/api/audio.proto\
    \n//////////////////////////////////////////////////////////////////////\
    ////////\n2O////////////////////////////////////////////////////////////\
    //////////////////\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xc4\x01\x08\r\n\x86\
    \x01\n\x04\x04\x05\x02\0\x12\x04\xc7\x01\x02\x11\x1ax\x20This\x20is\x20a\
    \x20URL\x20to\x20a\x20publicly\x20accessible\x20image\x20file.\x20The\
    \x20platform\x20will\x20download\x20this\x20file\x20server\n\x20side\x20\
    and\x20then\x20process.\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xc7\x01\
    \x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xc7\x01\t\x0c\n\r\n\x05\x04\
    \x05\x02\0\x03\x12\x04\xc7\x01\x0f\x10\n\x90\x03\n\x04\x04\x05\x02\x01\
    \x12\x04\xce\x01\x02\x13\x1a\x81\x03\x20The\x20base64\x20field\x20is\x20\
    using\x20image\x20file\x20bytes\x20directly\x20in\x20the\x20request.\n\
    \x20NOTE:\x20if\x20you're\x20sending\x20a\x20json\x20request,\x20then\
    \x20this\x20MUST\x20be\x20base64\x20encoded\x20before\x20sending\x20(hen\
    ce\n\x20the\x20name\x20here).\n\x20When\x20using\x20our\x20grpc\x20clien\
    ts,\x20you\x20DO\x20NOT\x20need\x20to\x20base64\x20encode\n\x20it\x20you\
    rself\x20since\x20the\x20clients\x20know\x20how\x20to\x20do\x20this\x20f\
    or\x20you\x20automatically\x20and\x20will\x20avoid\x20the\n\x20base64\
    \x20encoding\x20if\x20they\x20send\x20a\x20binary\x20request.\n\n\r\n\
    \x05\x04\x05\x02\x01\x05\x12\x04\xce\x01\x02\x07\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\xce\x01\x08\x0e\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\
    \xce\x01\x11\x12\nG\n\x04\x04\x05\x02\x02\x12\x04\xd0\x01\x02\x1f\x1a9\
    \x20If\x20True\x20then\x20you\x20will\x20be\x20allowed\x20to\x20have\x20\
    multiple\x20urls.\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xd0\x01\x02\
    \x06\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xd0\x01\x07\x1a\n\r\n\x05\x04\
    \x05\x02\x02\x03\x12\x04\xd0\x01\x1d\x1e\n\x81\x01\n\x04\x04\x05\x02\x03\
    \x12\x04\xd3\x01\x02\x17\x1as\x20The\x20hosted\x20field\x20lists\x20orig\
    inal\x20audio\x20hosted\x20in\x20Clarifai\x20storage.\x20This\x20field\
    \x20is\x20currently\x20used\n\x20only\x20in\x20response.\n\n\r\n\x05\x04\
    \x05\x02\x03\x06\x12\x04\xd3\x01\x02\x0b\n\r\n\x05\x04\x05\x02\x03\x01\
    \x12\x04\xd3\x01\x0c\x12\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\xd3\x01\
    \x15\x16\n\x1a\n\x04\x04\x05\x02\x04\x12\x04\xd5\x01\x02\x1b\x1a\x0c\x20\
    audio\x20info\n\n\r\n\x05\x04\x05\x02\x04\x06\x12\x04\xd5\x01\x02\x0b\n\
    \r\n\x05\x04\x05\x02\x04\x01\x12\x04\xd5\x01\x0c\x16\n\r\n\x05\x04\x05\
    \x02\x04\x03\x12\x04\xd5\x01\x19\x1a\n\x0c\n\x02\x04\x06\x12\x06\xd8\x01\
    \0\xe1\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xd8\x01\x08\x11\n\x1c\n\
    \x04\x04\x06\x02\0\x12\x04\xda\x01\x02\x1a\x1a\x0e\x20audio\x20format\n\
    \n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xda\x01\x02\x08\n\r\n\x05\x04\x06\
    \x02\0\x01\x12\x04\xda\x01\t\x15\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xda\
    \x01\x18\x19\n\x1b\n\x04\x04\x06\x02\x01\x12\x04\xdc\x01\x02\x18\x1a\r\
    \x20sample\x20rate\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xdc\x01\x02\
    \x07\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xdc\x01\x08\x13\n\r\n\x05\x04\
    \x06\x02\x01\x03\x12\x04\xdc\x01\x16\x17\n/\n\x04\x04\x06\x02\x02\x12\
    \x04\xde\x01\x02\x1d\x1a!\x20audio\x20track\x20duration\x20in\x20seconds\
    \n\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xde\x01\x02\x07\n\r\n\x05\x04\
    \x06\x02\x02\x01\x12\x04\xde\x01\x08\x18\n\r\n\x05\x04\x06\x02\x02\x03\
    \x12\x04\xde\x01\x1b\x1c\n$\n\x04\x04\x06\x02\x03\x12\x04\xe0\x01\x02\
    \x15\x1a\x16\x20audio\x20track\x20bit\x20rate\n\n\r\n\x05\x04\x06\x02\
    \x03\x05\x12\x04\xe0\x01\x02\x07\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\
    \xe0\x01\x08\x10\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xe0\x01\x13\x14\n\
    R\n\x02\x04\x07\x12\x06\xe4\x01\0\xf0\x01\x01\x1aD\x20Track\x20proto\x20\
    encodes\x20information\x20of\x20a\x20track\x20over\x20a\x20number\x20of\
    \x20frames\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xe4\x01\x08\r\n\x0b\n\x03\
    \x04\x07\t\x12\x04\xe5\x01\x02\r\n\x0c\n\x04\x04\x07\t\0\x12\x04\xe5\x01\
    \x0b\x0c\n\r\n\x05\x04\x07\t\0\x01\x12\x04\xe5\x01\x0b\x0c\n\r\n\x05\x04\
    \x07\t\0\x02\x12\x04\xe5\x01\x0b\x0c\n\x18\n\x04\x04\x07\x02\0\x12\x04\
    \xe7\x01\x02\x10\x1a\n\x20track\x20id\n\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\xe7\x01\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xe7\x01\t\x0b\n\
    \r\n\x05\x04\x07\x02\0\x03\x12\x04\xe7\x01\x0e\x0f\n\x89\x01\n\x04\x04\
    \x07\x02\x01\x12\x04\xeb\x01\x02\x10\x1a{\x20This\x20is\x20a\x20recursiv\
    e\x20definition\x20which\x20can\x20contain\x20all\x20the\x20concepts,\n\
    \x20embeddings,\x20etc.\x20that\x20are\x20computed\x20within\x20this\x20\
    track.\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xeb\x01\x02\x06\n\r\n\x05\
    \x04\x07\x02\x01\x01\x12\x04\xeb\x01\x07\x0b\n\r\n\x05\x04\x07\x02\x01\
    \x03\x12\x04\xeb\x01\x0e\x0f\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xed\x01\
    \x02\x19\n\r\n\x05\x04\x07\x02\x02\x06\x12\x04\xed\x01\x02\n\n\r\n\x05\
    \x04\x07\x02\x02\x01\x12\x04\xed\x01\x0b\x14\n\r\n\x05\x04\x07\x02\x02\
    \x03\x12\x04\xed\x01\x17\x18\n\x0c\n\x04\x04\x07\x02\x03\x12\x04\xef\x01\
    \x02\x14\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\xef\x01\x02\x07\n\r\n\x05\
    \x04\x07\x02\x03\x01\x12\x04\xef\x01\x08\x0f\n\r\n\x05\x04\x07\x02\x03\
    \x03\x12\x04\xef\x01\x12\x13\n\xaf\x02\n\x02\x04\x08\x12\x06\x82\x02\0\
    \x8f\x02\x01\x1a\xcf\x01////////////////////////////////////////////////\
    //////////////////////////////\n\x20Messages\x20from\x20/proto/clarifai/\
    api/cluster.proto\n/////////////////////////////////////////////////////\
    /////////////////////////\n2O///////////////////////////////////////////\
    ///////////////////////////////////\n\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \x82\x02\x08\x0f\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x83\x02\x02\x10\n\r\n\
    \x05\x04\x08\x02\0\x05\x12\x04\x83\x02\x02\x08\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\x83\x02\t\x0b\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x83\x02\
    \x0e\x0f\nD\n\x04\x04\x08\x02\x01\x12\x04\x86\x02\x02\x13\x1a6\x20Number\
    \x20of\x20annotations\x20tied\x20to\x20the\x20cluster\x20in\x20the\x20ap\
    p\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x86\x02\x02\x08\n\r\n\x05\x04\
    \x08\x02\x01\x01\x12\x04\x86\x02\t\x0e\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\x86\x02\x11\x12\n2\n\x04\x04\x08\x02\x02\x12\x04\x89\x02\x02\x12\
    \x1a$\x20The\x20score\x20assigned\x20to\x20this\x20cluster\n\n\r\n\x05\
    \x04\x08\x02\x02\x05\x12\x04\x89\x02\x02\x07\n\r\n\x05\x04\x08\x02\x02\
    \x01\x12\x04\x89\x02\x08\r\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x89\x02\
    \x10\x11\nJ\n\x04\x04\x08\x02\x03\x12\x04\x8c\x02\x02\x18\x1a<\x20Repres\
    entative\x20hits\x20for\x20cluster\x20(for\x20now\x20we\x20only\x20retur\
    n\x201)\n\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\x8c\x02\x02\n\n\r\n\x05\
    \x04\x08\x02\x03\x06\x12\x04\x8c\x02\x0b\x0e\n\r\n\x05\x04\x08\x02\x03\
    \x01\x12\x04\x8c\x02\x0f\x13\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\x8c\
    \x02\x16\x17\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\x8e\x02\x02\x20\n\r\n\
    \x05\x04\x08\x02\x04\x04\x12\x04\x8e\x02\x02\n\n\r\n\x05\x04\x08\x02\x04\
    \x05\x12\x04\x8e\x02\x0b\x10\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\x8e\
    \x02\x11\x1b\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\x8e\x02\x1e\x1f\n\xcb\
    \x04\n\x02\x04\t\x12\x06\xa5\x02\0\xa9\x02\x01\x1a\xcd\x01//////////////\
    ////////////////////////////////////////////////////////////////\n\x20Me\
    ssages\x20from\x20/proto/clarifai/api/color.proto\n/////////////////////\
    /////////////////////////////////////////////////////////\n2O///////////\
    ///////////////////////////////////////////////////////////////////\n2\
    \x9b\x02////////////////////////////////////////////////////////////////\
    //////////////\n\x20Messages\x20from\x20/proto/clarifai/api/code.proto\n\
    ////////////////////////////////////////////////////////////////////////\
    //////\n////////////////////////////////////////////////////////////////\
    //////////////\n\n\x0b\n\x03\x04\t\x01\x12\x04\xa5\x02\x08\r\n\x0c\n\x04\
    \x04\t\x02\0\x12\x04\xa6\x02\x02\x15\n\r\n\x05\x04\t\x02\0\x05\x12\x04\
    \xa6\x02\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xa6\x02\t\x10\n\r\n\
    \x05\x04\t\x02\0\x03\x12\x04\xa6\x02\x13\x14\n\x0c\n\x04\x04\t\x02\x01\
    \x12\x04\xa7\x02\x02\x0e\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xa7\x02\x02\
    \x05\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xa7\x02\x06\t\n\r\n\x05\x04\t\
    \x02\x01\x03\x12\x04\xa7\x02\x0c\r\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xa8\
    \x02\x02A\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xa8\x02\x02\x07\n\r\n\x05\
    \x04\t\x02\x02\x01\x12\x04\xa8\x02\x08\r\n\r\n\x05\x04\t\x02\x02\x03\x12\
    \x04\xa8\x02\x10\x11\n\r\n\x05\x04\t\x02\x02\x08\x12\x04\xa8\x02\x12@\n\
    \x10\n\x08\x04\t\x02\x02\x08\xd0\x86\x03\x12\x04\xa8\x02\x13?\n\x0c\n\
    \x02\x04\n\x12\x06\xab\x02\0\xae\x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\
    \xab\x02\x08\x0b\n\x0c\n\x04\x04\n\x02\0\x12\x04\xac\x02\x02\x11\n\r\n\
    \x05\x04\n\x02\0\x05\x12\x04\xac\x02\x02\x08\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\xac\x02\t\x0c\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xac\x02\x0f\x10\
    \n\x0c\n\x04\x04\n\x02\x01\x12\x04\xad\x02\x02\x12\n\r\n\x05\x04\n\x02\
    \x01\x05\x12\x04\xad\x02\x02\x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xad\
    \x02\t\r\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xad\x02\x10\x11\n\xe5\x02\n\
    \x02\x04\x0b\x12\x06\xbb\x02\0\xbf\x02\x01\x1a\x85\x02//////////////////\
    ////////////////////////////////////////////////////////////\n\x20Messag\
    es\x20from\x20/proto/clarifai/api/common.proto\n////////////////////////\
    //////////////////////////////////////////////////////\n\x20Common\x20me\
    ssage\x20to\x20identify\x20the\x20app\x20in\x20a\x20url\x20endpoint.\n2O\
    ////////////////////////////////////////////////////////////////////////\
    //////\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xbb\x02\x08\x14\n]\n\x04\x04\
    \x0b\x02\0\x12\x04\xbd\x02\x02\x15\x1aO\x20Note\x20user_id\x20'me'\x20is\
    \x20reserved\x20-\x20it\x20is\x20the\x20alias\x20for\x20the\x20id\x20of\
    \x20authorized\x20user\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xbd\x02\x02\
    \x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xbd\x02\t\x10\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\xbd\x02\x13\x14\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\
    \xbe\x02\x02\x14\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xbe\x02\x02\x08\n\
    \r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xbe\x02\t\x0f\n\r\n\x05\x04\x0b\x02\
    \x01\x03\x12\x04\xbe\x02\x12\x13\n\x0c\n\x02\x04\x0c\x12\x06\xc1\x02\0\
    \x8b\x03\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xc1\x02\x08\x13\n\x96\x01\n\
    \x04\x04\x0c\x02\0\x12\x04\xc4\x02\x02\x10\x1a\x87\x01\x20The\x20operati\
    on\x20to\x20perform\x20on\x20the\x20patched\x20metadata\x20given\x20a\
    \x20path\n\x20For\x20now\x20only\x20operations\x20'overwrite',\x20'delet\
    e,\x20and\x20'merge'\x20is\x20supported\n\n\r\n\x05\x04\x0c\x02\0\x05\
    \x12\x04\xc4\x02\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xc4\x02\t\
    \x0b\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xc4\x02\x0e\x0f\n\x97\t\n\x04\
    \x04\x0c\x02\x01\x12\x04\x86\x03\x02'\x1a\x88\t\x20If\x20the\x20action\
    \x20is\x20'merge'\x20and\x20there\x20is\x20a\x20conflict,\x20how\x20to\
    \x20resolve\x20it.\n\x20The\x20options\x20are\n\x20'overwrite_by_id',\
    \x20'remove_by_id',\x20'merge_by_id','overwrite',\x20'append'\x20and\x20\
    'do_nothing'\n\x20Note\x20that\x20for\x20conflict\x20resolutions\x20'*_b\
    y_id'\x20to\x20work\x20on\x20a\x20list,\x20the\x20list\x20should\x20cont\
    ain\n\x20objects\x20with\x20an\x20'id'\x20field\x20which\x20will\x20be\
    \x20used\x20to\x20uniquely\x20identify\x20each\x20field.\x20For\x20examp\
    le\n\x20Patching\x20existing\x20json\n\x20{\n\x20\x20\x20\"tag\":\x20[\n\
    \x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"id\":\x20\"1\",\n\
    \x20\x20\x20\x20\x20\x20\x20\"data\":\x201\n\x20\x20\x20\x20\x20},\n\x20\
    \x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"id\":\x20\"2\",\n\x20\
    \x20\x20\x20\x20\x20\x20\"data\":\x202\n\x20\x20\x20\x20\x20}\n\x20\x20\
    \x20]\n\x20}\n\x20with\x20op\x20'merge'\x20and\x20merge_conflict_resolut\
    ion\x20'overwrite_by_id'\n\x20{\n\x20\x20\x20\"tag\":\x20[\n\x20\x20\x20\
    \x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"id\":\x20\"2\",\n\x20\x20\x20\
    \x20\x20\x20\x20\"data\":\x203\n\x20\x20\x20\x20\x20}\n\x20\x20\x20]\n\
    \x20}\n\x20would\x20produce\n\x20{\n\x20\x20\x20\"tag\":\x20[\n\x20\x20\
    \x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"id\":\x20\"1\",\n\x20\x20\
    \x20\x20\x20\x20\x20\"data\":\x201\n\x20\x20\x20\x20\x20},\n\x20\x20\x20\
    \x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"id\":\x20\"2\",\n\x20\x20\x20\
    \x20\x20\x20\x20\"data\":\x203\n\x20\x20\x20\x20\x20}\n\x20\x20\x20]\n\
    \x20}\n\x20while\x20with\x20merge_conflict_resolution\x20'remove_by_id'\
    \x20it\x20would\x20produce\n\x20{\n\x20\x20\x20\"tag\":\x20[\n\x20\x20\
    \x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"id\":\x20\"1\",\n\x20\x20\
    \x20\x20\x20\x20\x20\"data\":\x201\n\x20\x20\x20\x20\x20}\n\x20\x20\x20]\
    \n\x20}\n\n\x20Option\x20'append'\x20will\x20simply\x20create\x20a\x20li\
    st\x20on\x20conflicts.\x20For\x20example\x20in\x20above\x20example\n\x20\
    the\x20final\x20result\x20would\x20be\n\x20{\n\x20\x20\x20\"tag\":\x20[\
    \n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"id\":\x20\"1\",\n\
    \x20\x20\x20\x20\x20\x20\x20\"data\":\x201\n\x20\x20\x20\x20\x20},\n\x20\
    \x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"id\":\x20\"2\",\n\x20\
    \x20\x20\x20\x20\x20\x20\"data\":\x20[2,\x203]\n\x20\x20\x20\x20\x20}\n\
    \x20\x20\x20]\n\x20}\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x86\x03\x02\
    \x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x86\x03\t\"\n\r\n\x05\x04\x0c\
    \x02\x01\x03\x12\x04\x86\x03%&\n\x85\x01\n\x04\x04\x0c\x02\x02\x12\x04\
    \x8a\x03\x02\x12\x1aw\x20Path\x20for\x20the\x20change.\x20For\x20example\
    \x20'tag[1].data'\x20is\x20a\x20valid\x20path\x20in\x20above\x20example.\
    \n\x20Default\x20path\x20is\x20root\x20level\x20i.e.\x20''.\n\n\r\n\x05\
    \x04\x0c\x02\x02\x05\x12\x04\x8a\x03\x02\x08\n\r\n\x05\x04\x0c\x02\x02\
    \x01\x12\x04\x8a\x03\t\r\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x8a\x03\
    \x10\x11\n\xaf\x02\n\x02\x04\r\x12\x06\x95\x03\0\xb8\x03\x01\x1a\xcf\x01\
    ////////////////////////////////////////////////////////////////////////\
    //////\n\x20Messages\x20from\x20/proto/clarifai/api/concept.proto\n/////\
    ////////////////////////////////////////////////////////////////////////\
    /\n2O///////////////////////////////////////////////////////////////////\
    ///////////\n\n\x0b\n\x03\x04\r\x01\x12\x04\x95\x03\x08\x0f\n(\n\x04\x04\
    \r\x02\0\x12\x04\x97\x03\x02\x10\x1a\x1a\x20The\x20concept's\x20unique\
    \x20id.\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x97\x03\x02\x08\n\r\n\x05\
    \x04\r\x02\0\x01\x12\x04\x97\x03\t\x0b\n\r\n\x05\x04\r\x02\0\x03\x12\x04\
    \x97\x03\x0e\x0f\n>\n\x04\x04\r\x02\x01\x12\x04\x99\x03\x02\x12\x1a0\x20\
    The\x20name\x20of\x20the\x20concept\x20in\x20the\x20given\x20language.\n\
    \n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x99\x03\x02\x08\n\r\n\x05\x04\r\x02\
    \x01\x01\x12\x04\x99\x03\t\r\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x99\x03\
    \x10\x11\n\xe6\x02\n\x04\x04\r\x02\x02\x12\x04\x9e\x03\x02n\x1a\xd7\x02\
    \x20Used\x20to\x20indicate\x20presence\x20(1.0)\x20or\x20not\x20(0.0)\
    \x20of\x20this\x20concept\x20when\x20making\x20a\x20request.\n\x20This\
    \x20is\x20also\x20the\x20prediction\x20probability\x20when\x20returning\
    \x20predictions\x20from\x20our\x20API.\n\x20For\x20convenience\x20we\x20\
    use\x20the\x20default\x20of\x201.0\x20when\x20making\x20requests\x20so\
    \x20the\x20concept\x20you\x20provide\x20is\n\x20is\x20treated\x20as\x20a\
    \x20positive\x20(1.0)\x20and\x20not\x20a\x20negative\x20(which\x20would\
    \x20be\x20value\x20==\x200.0).\n\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\x9e\
    \x03\x02\x07\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\x9e\x03\x08\r\n\r\n\x05\
    \x04\r\x02\x02\x03\x12\x04\x9e\x03\x10\x11\n\r\n\x05\x04\r\x02\x02\x08\
    \x12\x04\x9e\x03\x12m\n\x10\n\x08\x04\r\x02\x02\x08\xda\x86\x03\x12\x04\
    \x9e\x03\x13>\n\x10\n\x08\x04\r\x02\x02\x08\xd0\x86\x03\x12\x04\x9e\x03@\
    l\n\xb3\x01\n\x04\x04\r\x02\x03\x12\x04\xa1\x03\x02+\x1a\xa4\x01\x20When\
    \x20the\x20concept\x20was\x20created.\x20The\x20format\x20is\x20https://\
    www.ietf.org/rfc/rfc3339.txt\x20.\n\x20Example:\x20\"2006-01-02T15:04:05\
    .999999Z\".\x20This\x20field\x20is\x20used\x20only\x20in\x20a\x20respons\
    e.\n\n\r\n\x05\x04\r\x02\x03\x06\x12\x04\xa1\x03\x02\x1b\n\r\n\x05\x04\r\
    \x02\x03\x01\x12\x04\xa1\x03\x1c&\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\
    \xa1\x03)*\n\xc8\x02\n\x04\x04\r\x02\x04\x12\x04\xa7\x03\x02\x16\x1a\xb9\
    \x02\x20The\x20language\x20in\x20which\x20the\x20concept\x20name\x20is\
    \x20in.\x20This\x20is\x20*ONLY*\x20used\x20in\x20the\x20response\x20and\
    \x20setting\n\x20it\x20in\x20a\x20request\x20is\x20ignored\x20since\x20t\
    he\x20default\x20language\x20of\x20your\x20app\x20is\x20used\x20when\x20\
    creating\n\x20or\x20patching\x20a\x20Concept.\x20To\x20set\x20other\x20l\
    anguages\x20for\x20your\x20concept\x20use\x20the\x20ConceptLanguage\x20o\
    bject\n\x20and\x20its\x20corresponding\x20endpoints.\n\n\r\n\x05\x04\r\
    \x02\x04\x05\x12\x04\xa7\x03\x02\x08\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\
    \xa7\x03\t\x11\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xa7\x03\x14\x15\nb\n\
    \x04\x04\r\x02\x05\x12\x04\xa9\x03\x02\x14\x1aT\x20The\x20application\
    \x20id\x20that\x20this\x20concept\x20is\x20within.\x20This\x20can\x20be\
    \x20ignored\x20by\x20most\x20users.\n\n\r\n\x05\x04\r\x02\x05\x05\x12\
    \x04\xa9\x03\x02\x08\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xa9\x03\t\x0f\n\
    \r\n\x05\x04\r\x02\x05\x03\x12\x04\xa9\x03\x12\x13\nc\n\x04\x04\r\x02\
    \x06\x12\x04\xab\x03\x02\x18\x1aU\x20The\x20definition\x20for\x20the\x20\
    concept.\x20Similar\x20to\x20name.\x20This\x20can\x20be\x20ignored\x20by\
    \x20most\x20users.\n\n\r\n\x05\x04\r\x02\x06\x05\x12\x04\xab\x03\x02\x08\
    \n\r\n\x05\x04\r\x02\x06\x01\x12\x04\xab\x03\t\x13\n\r\n\x05\x04\r\x02\
    \x06\x03\x12\x04\xab\x03\x16\x17\n\x9a\x02\n\x04\x04\r\x02\x07\x12\x04\
    \xaf\x03\x02\x16\x1a\x8b\x02\x20The\x20vocabulary\x20that\x20this\x20con\
    cept\x20belongs\x20to.\x20This\x20is\x20useful\x20if\x20you\x20have\x20d\
    ifferent\x20unique\x20sets\n\x20of\x20concepts\x20that\x20you\x20can\x20\
    separate\x20out\x20based\x20on\x20this\x20field.\x20For\x20example\x20\"\
    age_appearance\"\x20vs\n\x20\"gender_appearance\"\x20in\x20a\x20list\x20\
    of\x20concept\x20returned\x20from\x20the\x20demographics\x20model.\n\n\r\
    \n\x05\x04\r\x02\x07\x05\x12\x04\xaf\x03\x02\x08\n\r\n\x05\x04\r\x02\x07\
    \x01\x12\x04\xaf\x03\t\x11\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\xaf\x03\
    \x14\x15\n\xdd\x01\n\x04\x04\r\x02\x08\x12\x04\xb4\x03\x02\x1c\x1a\xce\
    \x01\x20The\x20visibility\x20field\x20represents\x20whether\x20this\x20m\
    essage\x20is\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\
    \x20to\x20the\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\
    \x20the\x20User\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20b\
    e\x20publicly\x20visible.\n\n\r\n\x05\x04\r\x02\x08\x06\x12\x04\xb4\x03\
    \x02\x0c\n\r\n\x05\x04\r\x02\x08\x01\x12\x04\xb4\x03\r\x17\n\r\n\x05\x04\
    \r\x02\x08\x03\x12\x04\xb4\x03\x1a\x1b\n0\n\x04\x04\r\x02\t\x12\x04\xb7\
    \x03\x02\x16\x1a\"\x20The\x20user\x20the\x20concept\x20belongs\x20to.\n\
    \n\r\n\x05\x04\r\x02\t\x05\x12\x04\xb7\x03\x02\x08\n\r\n\x05\x04\r\x02\t\
    \x01\x12\x04\xb7\x03\t\x10\n\r\n\x05\x04\r\x02\t\x03\x12\x04\xb7\x03\x13\
    \x15\n\x0c\n\x02\x04\x0e\x12\x06\xba\x03\0\xc3\x03\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xba\x03\x08\x14\n(\n\x04\x04\x0e\x02\0\x12\x04\xbc\x03\
    \x02\x10\x1a\x1a\x20The\x20concept's\x20unique\x20id.\n\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\xbc\x03\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\xbc\x03\t\x0b\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xbc\x03\x0e\x0f\n\
    (\n\x04\x04\x0e\x02\x01\x12\x04\xbe\x03\x02\x12\x1a\x1a\x20The\x20name\
    \x20of\x20the\x20concept.\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xbe\
    \x03\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xbe\x03\t\r\n\r\n\x05\
    \x04\x0e\x02\x01\x03\x12\x04\xbe\x03\x10\x11\nu\n\x04\x04\x0e\x02\x02\
    \x12\x04\xc0\x03\x02*\x1ag\x20The\x20total\x20count\x20for\x20concepts\
    \x20labeled\x20for\x20all\x20asset\x20statues\x20(processing,\x20to_proc\
    ess,\x20processed,\x20error)\n\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\xc0\
    \x03\x02\x12\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xc0\x03\x13%\n\r\n\
    \x05\x04\x0e\x02\x02\x03\x12\x04\xc0\x03()\n<\n\x04\x04\x0e\x02\x03\x12\
    \x04\xc2\x03\x02.\x1a.\x20The\x20detail\x20count\x20for\x20different\x20\
    assets\x20status\n\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\xc2\x03\x02\x14\
    \n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xc2\x03\x15)\n\r\n\x05\x04\x0e\
    \x02\x03\x03\x12\x04\xc2\x03,-\n\x0c\n\x02\x04\x0f\x12\x06\xc5\x03\0\xcc\
    \x03\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xc5\x03\x08\x18\n\x7f\n\x04\x04\
    \x0f\x02\0\x12\x04\xc8\x03\x02E\x1aq\x20The\x20number\x20of\x20inputs\
    \x20that\x20have\x20a\x20concept\x20with\x20a\x20value\x20of\x201.0\x20(\
    indicating\x20presence\x20of\x20the\n\x20concept\x20in\x20an\x20input).\
    \n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xc8\x03\x02\x08\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\xc8\x03\t\x11\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xc8\
    \x03\x14\x15\n\r\n\x05\x04\x0f\x02\0\x08\x12\x04\xc8\x03\x16D\n\x10\n\
    \x08\x04\x0f\x02\0\x08\xd0\x86\x03\x12\x04\xc8\x03\x17C\n~\n\x04\x04\x0f\
    \x02\x01\x12\x04\xcb\x03\x02E\x1ap\x20The\x20number\x20of\x20inputs\x20t\
    hat\x20have\x20a\x20concept\x20with\x20a\x20value\x20of\x200.0\x20(indic\
    ating\x20absence\x20of\x20the\n\x20concept\x20in\x20an\x20input).\n\n\r\
    \n\x05\x04\x0f\x02\x01\x05\x12\x04\xcb\x03\x02\x08\n\r\n\x05\x04\x0f\x02\
    \x01\x01\x12\x04\xcb\x03\t\x11\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xcb\
    \x03\x14\x15\n\r\n\x05\x04\x0f\x02\x01\x08\x12\x04\xcb\x03\x16D\n\x10\n\
    \x08\x04\x0f\x02\x01\x08\xd0\x86\x03\x12\x04\xcb\x03\x17C\n\x0c\n\x02\
    \x04\x10\x12\x06\xce\x03\0\xd7\x03\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\
    \xce\x03\x08\x1a\n6\n\x04\x04\x10\x02\0\x12\x04\xd0\x03\x02!\x1a(\x20The\
    \x20concept\x20count\x20for\x20processed\x20assets\n\n\r\n\x05\x04\x10\
    \x02\0\x06\x12\x04\xd0\x03\x02\x12\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xd0\x03\x13\x1c\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xd0\x03\x1f\x20\n7\
    \n\x04\x04\x10\x02\x01\x12\x04\xd2\x03\x02\"\x1a)\x20The\x20concept\x20c\
    ount\x20for\x20to\x20process\x20assets\n\n\r\n\x05\x04\x10\x02\x01\x06\
    \x12\x04\xd2\x03\x02\x12\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xd2\x03\
    \x13\x1d\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xd2\x03\x20!\n>\n\x04\x04\
    \x10\x02\x02\x12\x04\xd4\x03\x02\x1e\x1a0\x20The\x20concept\x20count\x20\
    for\x20assets\x20with\x20status\x20error\n\n\r\n\x05\x04\x10\x02\x02\x06\
    \x12\x04\xd4\x03\x02\x12\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xd4\x03\
    \x13\x19\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xd4\x03\x1c\x1d\n7\n\x04\
    \x04\x10\x02\x03\x12\x04\xd6\x03\x02\"\x1a)\x20The\x20concept\x20count\
    \x20for\x20processing\x20assets\n\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\
    \xd6\x03\x02\x12\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xd6\x03\x13\x1d\n\
    \r\n\x05\x04\x10\x02\x03\x03\x12\x04\xd6\x03\x20!\n\x0c\n\x02\x04\x11\
    \x12\x06\xd9\x03\0\xe0\x03\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xd9\x03\
    \x08\x14\n2\n\x04\x04\x11\x02\0\x12\x04\xdb\x03\x02\x12\x1a$\x20The\x20n\
    ame\x20of\x20the\x20concept\x20to\x20search.\n\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\xdb\x03\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xdb\x03\
    \t\r\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xdb\x03\x10\x11\n]\n\x04\x04\
    \x11\x02\x01\x12\x04\xdd\x03\x02\x16\x1aO\x20(optional)\x20The\x20langua\
    ge\x20of\x20the\x20concept\x20name\x20in\x20a\x20search.\x20Defaults\x20\
    to\x20English.\n\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xdd\x03\x02\x08\n\
    \r\n\x05\x04\x11\x02\x01\x01\x12\x04\xdd\x03\t\x11\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xdd\x03\x14\x15\nl\n\x04\x04\x11\x02\x02\x12\x04\xdf\
    \x03\x02\x19\x1a^\x20(optional)\x20The\x20id\x20of\x20workflow.\x20If\
    \x20no\x20id\x20is\x20provided,\x20then\x20application\x20base\x20workfl\
    ow\x20is\x20used.\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xdf\x03\x02\
    \x08\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xdf\x03\t\x14\n\r\n\x05\x04\
    \x11\x02\x02\x03\x12\x04\xdf\x03\x17\x18\n\x90\x03\n\x02\x04\x12\x12\x06\
    \xed\x03\0\x9f\x04\x01\x1a\xb0\x02//////////////////////////////////////\
    ////////////////////////////////////////\n\x20Messages\x20from\x20/proto\
    /clarifai/api/concept_graph.proto\n/////////////////////////////////////\
    /////////////////////////////////////////\n\x20This\x20represents\x20a\
    \x20relation\x20(i.e.\x20edge)\x20between\x20the\x20subject\x20concept\
    \x20and\x20the\x20object\x20concept\n2O/////////////////////////////////\
    /////////////////////////////////////////////\n\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xed\x03\x08\x17\n*\n\x04\x04\x12\x02\0\x12\x04\xef\x03\x02\x10\
    \x1a\x1c\x20ID\x20of\x20the\x20concept\x20relation\n\n\r\n\x05\x04\x12\
    \x02\0\x05\x12\x04\xef\x03\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xef\x03\t\x0b\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xef\x03\x0e\x0f\nI\n\
    \x04\x04\x12\x02\x01\x12\x04\xf2\x03\x02\x1e\x1a;\x20The\x20subject\x20c\
    oncept\x20(i.e.\x20source)\x20of\x20the\x20concept\x20relation\n\n\r\n\
    \x05\x04\x12\x02\x01\x06\x12\x04\xf2\x03\x02\t\n\r\n\x05\x04\x12\x02\x01\
    \x01\x12\x04\xf2\x03\n\x19\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xf2\x03\
    \x1c\x1d\nN\n\x04\x04\x12\x02\x02\x12\x04\xf5\x03\x02\x1d\x1a@\x20The\
    \x20subject\x20concept\x20(i.e.\x20destination)\x20of\x20the\x20concept\
    \x20relation\n\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xf5\x03\x02\t\n\r\n\
    \x05\x04\x12\x02\x02\x01\x12\x04\xf5\x03\n\x18\n\r\n\x05\x04\x12\x02\x02\
    \x03\x12\x04\xf5\x03\x1b\x1c\n\x9b\t\n\x04\x04\x12\x02\x03\x12\x04\x95\
    \x04\x02\x17\x1a\x8c\t\x20The\x20predicate\x20(i.e.\x20edge)\x20linking\
    \x20the\x20subject\x20and\x20the\x20object\n\x20Both\x20subject_concept\
    \x20and\x20object_concept\x20are\x20concepts.\n\x20The\x20predicate\x20i\
    s\x20the\x20type\x20of\x20relationship.\n\x20That\x20predicate\x20acts\
    \x20on\x20the\x20subject.\n\n\x20There\x20are\x20three\x20current\x20typ\
    es\x20of\x20predicates:\n\x201)\x20\"hyponym\"\n\x202)\x20\"hypernym\"\n\
    \x203)\x20\"synonym\"\n\n\x201)\x20For\x20example,\x20'hyponym'\x20is\
    \x20a\x20type\x20of\x20predicate\x20which\x20represents\x20'is_a_kind_of\
    '\x20relation\x20so\n\x20the\x20following\x20relationship:\n\x20'honey'\
    \x20(subject),\x20'hyponym'\x20(predicate),\x20'food'\x20(object)\n\x20C\
    an\x20more\x20easily\x20be\x20read\x20as:\n\x20'honey'\x20'is\x20a\x20ki\
    nd\x20of'\x20'food'\n\n\n\x202)\x20The\x20'hypernym'\x20relation\x20is\
    \x20the\x20opposite\x20of\x20'hyponym'\x20and\x20when\x20you\x20add\x20o\
    ne\x20of\x20the\n\x20relationships\x20the\x20opposite\x20will\x20automat\
    ically\x20appear\x20for\x20you\x20in\x20queries.\n\n\x20The\x20'hypernym\
    '\x20can\x20be\x20read\x20as\x20'is\x20a\x20parent\x20of'\x20so:\n\x20'f\
    ood'\x20(subject),\x20'hypernym'\x20(predicate),\x20'honey'\x20(object)\
    \n\x20Can\x20more\x20easily\x20be\x20read\x20as:\n\x20'food'\x20is\x20a\
    \x20parent\x20of\x20'honey'\n\n\x203)\x20The\x20'synonym'\x20relation\
    \x20defines\x20two\x20concepts\x20that\x20essential\x20mean\x20the\x20sa\
    me\x20thing.\x20This\n\x20is\x20more\x20like\x20a\x20\"is\"\x20relations\
    hip.\x20So\x20for\x20example\x20a\x20'synonym'\x20relationship\x20could\
    \x20be:\n\x20\"puppy\"\x20is\x20\"pup\"\n\x20The\x20reverse\x20is\x20als\
    o\x20true\x20once\x20the\x20former\x20is\x20added\x20so:\n\x20\"pup\"\
    \x20is\x20\"puppy\"\n\x20will\x20appear\x20in\x20queries\x20as\x20well.\
    \n\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\x95\x04\x02\x08\n\r\n\x05\x04\
    \x12\x02\x03\x01\x12\x04\x95\x04\t\x12\n\r\n\x05\x04\x12\x02\x03\x03\x12\
    \x04\x95\x04\x15\x16\n\xad\x01\n\x04\x04\x12\x02\x04\x12\x04\x99\x04\x02\
    \x20\x1a\x9e\x01\x20The\x20knowledge\x20graph\x20id\x20that\x20this\x20e\
    dge\x20belongs\x20to.\x20If\x20using\x20the\x20app's\x20global\x20knowle\
    dge\x20graph\n\x20and\x20not\x20a\x20specific\x20one\x20then\x20this\x20\
    should\x20be\x20the\x20empty\x20string\x20\"\".\n\n\r\n\x05\x04\x12\x02\
    \x04\x05\x12\x04\x99\x04\x02\x08\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\
    \x99\x04\t\x1b\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\x99\x04\x1e\x1f\n\
    \xdd\x01\n\x04\x04\x12\x02\x05\x12\x04\x9e\x04\x02\x1c\x1a\xce\x01\x20Th\
    e\x20visibility\x20field\x20represents\x20whether\x20this\x20message\x20\
    is\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20t\
    he\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20Us\
    er\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\
    \x20visible.\n\n\r\n\x05\x04\x12\x02\x05\x06\x12\x04\x9e\x04\x02\x0c\n\r\
    \n\x05\x04\x12\x02\x05\x01\x12\x04\x9e\x04\r\x17\n\r\n\x05\x04\x12\x02\
    \x05\x03\x12\x04\x9e\x04\x1a\x1b\n\\\n\x02\x04\x13\x12\x06\xa2\x04\0\xad\
    \x04\x01\x1aN\x20A\x20Knowledge\x20Graph\x20is\x20a\x20logical\x20subset\
    s\x20of\x20edges\x20in\x20the\x20overall\x20Concept\x20Graph\n\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xa2\x04\x08\x16\n)\n\x04\x04\x13\x02\0\x12\x04\
    \xa4\x04\x02\x10\x1a\x1b\x20ID\x20of\x20the\x20knowledge\x20graph\n\n\r\
    \n\x05\x04\x13\x02\0\x05\x12\x04\xa4\x04\x02\x08\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xa4\x04\t\x0b\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xa4\x04\
    \x0e\x0f\n+\n\x04\x04\x13\x02\x01\x12\x04\xa6\x04\x02\x12\x1a\x1d\x20Nam\
    e\x20of\x20the\x20knowledge\x20graph\n\n\r\n\x05\x04\x13\x02\x01\x05\x12\
    \x04\xa6\x04\x02\x08\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xa6\x04\t\r\n\
    \r\n\x05\x04\x13\x02\x01\x03\x12\x04\xa6\x04\x10\x11\nA\n\x04\x04\x13\
    \x02\x02\x12\x04\xa8\x04\x02\x19\x1a3\x20Human\x20readable\x20descriptio\
    n\x20of\x20the\x20knowledge\x20graph\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\
    \x04\xa8\x04\x02\x08\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xa8\x04\t\x14\
    \n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xa8\x04\x17\x18\ng\n\x04\x04\x13\
    \x02\x03\x12\x04\xaa\x04\x02\x1d\x1aY\x20The\x20app\x20that\x20contains\
    \x20the\x20images\x20that\x20correspond\x20to\x20the\x20concepts\x20in\
    \x20the\x20knowledge\x20graph\n\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\
    \xaa\x04\x02\x08\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xaa\x04\t\x18\n\r\
    \n\x05\x04\x13\x02\x03\x03\x12\x04\xaa\x04\x1b\x1c\n\x81\x01\n\x04\x04\
    \x13\x02\x04\x12\x04\xac\x04\x02%\x1as\x20The\x20app\x20that\x20contains\
    \x20the\x20sample\x20images\x20that\x20we\x20want\x20to\x20show\x20the\
    \x20customer\x20for\x20the\x20concepts\x20in\x20the\x20knowledge\x20grap\
    h\n\n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\xac\x04\x02\x08\n\r\n\x05\x04\
    \x13\x02\x04\x01\x12\x04\xac\x04\t\x20\n\r\n\x05\x04\x13\x02\x04\x03\x12\
    \x04\xac\x04#$\n\x0c\n\x02\x04\x14\x12\x06\xb0\x04\0\xb5\x04\x01\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\xb0\x04\x08\x19\nU\n\x04\x04\x14\x02\0\x12\x04\
    \xb2\x04\x02\x20\x1aG\x20The\x20id\x20of\x20the\x20knowledge\x20graph\
    \x20being\x20used\x20for\x20this\x20concept\x20mapping\x20job\n\n\r\n\
    \x05\x04\x14\x02\0\x05\x12\x04\xb2\x04\x02\x08\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\xb2\x04\t\x1b\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xb2\x04\
    \x1e\x1f\n4\n\x04\x04\x14\x02\x01\x12\x04\xb4\x04\x02\"\x1a&\x20The\x20i\
    ds\x20of\x20the\x20concepts\x20being\x20mapped\n\n\r\n\x05\x04\x14\x02\
    \x01\x04\x12\x04\xb4\x04\x02\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xb4\
    \x04\x0b\x11\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xb4\x04\x12\x1d\n\r\n\
    \x05\x04\x14\x02\x01\x03\x12\x04\xb4\x04\x20!\n\xf0\x04\n\x02\x04\x15\
    \x12\x06\xc5\x04\0\xcc\x04\x01\x1a\x90\x04//////////////////////////////\
    ////////////////////////////////////////////////\n\x20Messages\x20from\
    \x20/proto/clarifai/api/concept_language.proto\n////////////////////////\
    //////////////////////////////////////////////////////\n\x20This\x20repr\
    esents\x20a\x20link\x20to\x20an\x20outside\x20source\x20for\x20the\x20gi\
    ven\x20concept.\n\x20The\x20values\x20from\x20here\x20are\x20sticked\x20\
    into\x20Concept\x20message\x20into\x20the\x20name\x20and\x20definition\
    \x20fields\x20when\n\x20returning\x20from\x20the\x20API\x20in\x20your\
    \x20default\x20language.\x20The\x20\"id\"\x20field\x20here\x20becomes\
    \x20the\x20\"language\"\n\x20field\x20of\x20the\x20Concept\x20message\
    \x20which\x20is\x20a\x20little\x20weird.\n2O////////////////////////////\
    //////////////////////////////////////////////////\n\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\xc5\x04\x08\x17\nH\n\x04\x04\x15\x02\0\x12\x04\xc7\x04\x02\
    \x10\x1a:\x20This\x20is\x20the\x20language\x20code\x20for\x20the\x20lang\
    uage\x20such\x20as\x20\"en\".\n\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xc7\
    \x04\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xc7\x04\t\x0b\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\xc7\x04\x0e\x0f\n/\n\x04\x04\x15\x02\x01\x12\
    \x04\xc9\x04\x02\x12\x1a!\x20The\x20type\x20of\x20the\x20outside\x20sour\
    ce.\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xc9\x04\x02\x08\n\r\n\x05\
    \x04\x15\x02\x01\x01\x12\x04\xc9\x04\t\r\n\r\n\x05\x04\x15\x02\x01\x03\
    \x12\x04\xc9\x04\x10\x11\n8\n\x04\x04\x15\x02\x02\x12\x04\xcb\x04\x02\
    \x18\x1a*\x20The\x20ID\x20that\x20is\x20referenced\x20in\x20the\x20sourc\
    e.\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xcb\x04\x02\x08\n\r\n\x05\x04\
    \x15\x02\x02\x01\x12\x04\xcb\x04\t\x13\n\r\n\x05\x04\x15\x02\x02\x03\x12\
    \x04\xcb\x04\x16\x17\n\xac\x02\n\x02\x04\x16\x12\x06\xdc\x04\0\xfd\x04\
    \x01\x1a\xcc\x01////////////////////////////////////////////////////////\
    //////////////////////\n\x20Messages\x20from\x20/proto/clarifai/api/data\
    .proto\n////////////////////////////////////////////////////////////////\
    //////////////\n2O//////////////////////////////////////////////////////\
    ////////////////////////\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xdc\x04\x08\
    \x0c\n\x0b\n\x03\x04\x16\t\x12\x04\xdd\x04\x02\x11\n\x0c\n\x04\x04\x16\t\
    \0\x12\x04\xdd\x04\x0b\x0c\n\r\n\x05\x04\x16\t\0\x01\x12\x04\xdd\x04\x0b\
    \x0c\n\r\n\x05\x04\x16\t\0\x02\x12\x04\xdd\x04\x0b\x0c\n\x0c\n\x04\x04\
    \x16\t\x01\x12\x04\xdd\x04\x0e\x10\n\r\n\x05\x04\x16\t\x01\x01\x12\x04\
    \xdd\x04\x0e\x10\n\r\n\x05\x04\x16\t\x01\x02\x12\x04\xdd\x04\x0e\x10\n(\
    \n\x04\x04\x16\x02\0\x12\x04\xdf\x04\x02\x12\x1a\x1a\x20Input\x20and\x20\
    output\x20images.\n\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xdf\x04\x02\x07\
    \n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xdf\x04\x08\r\n\r\n\x05\x04\x16\x02\
    \0\x03\x12\x04\xdf\x04\x10\x11\n(\n\x04\x04\x16\x02\x01\x12\x04\xe1\x04\
    \x02\x12\x1a\x1a\x20Input\x20and\x20output\x20videos.\n\n\r\n\x05\x04\
    \x16\x02\x01\x06\x12\x04\xe1\x04\x02\x07\n\r\n\x05\x04\x16\x02\x01\x01\
    \x12\x04\xe1\x04\x08\r\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xe1\x04\x10\
    \x11\n#\n\x04\x04\x16\x02\x02\x12\x04\xe3\x04\x02\x20\x1a\x15\x20A\x20li\
    st\x20of\x20concepts.\n\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xe3\x04\
    \x02\n\n\r\n\x05\x04\x16\x02\x02\x06\x12\x04\xe3\x04\x0b\x12\n\r\n\x05\
    \x04\x16\x02\x02\x01\x12\x04\xe3\x04\x13\x1b\n\r\n\x05\x04\x16\x02\x02\
    \x03\x12\x04\xe3\x04\x1e\x1f\n\x9f\x01\n\x04\x04\x16\x02\x03\x12\x04\xe7\
    \x04\x02&\x1a\x90\x01\x20To\x20handle\x20arbitrary\x20json\x20metadata\
    \x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20https://github.com/g\
    oogle/protobuf/blob/master/src/google/protobuf/struct.proto\n\n\r\n\x05\
    \x04\x16\x02\x03\x06\x12\x04\xe7\x04\x02\x18\n\r\n\x05\x04\x16\x02\x03\
    \x01\x12\x04\xe7\x04\x19!\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\xe7\x04$\
    %\n&\n\x04\x04\x16\x02\x04\x12\x04\xe9\x04\x02\x0e\x1a\x18\x20Geography\
    \x20information.\n\n\r\n\x05\x04\x16\x02\x04\x06\x12\x04\xe9\x04\x02\x05\
    \n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\xe9\x04\x06\t\n\r\n\x05\x04\x16\
    \x02\x04\x03\x12\x04\xe9\x04\x0c\r\n4\n\x04\x04\x16\x02\x05\x12\x04\xec\
    \x04\x02\x1c\x1a&\x20The\x20dominant\x20colors\x20within\x20an\x20image.\
    \n\n\r\n\x05\x04\x16\x02\x05\x04\x12\x04\xec\x04\x02\n\n\r\n\x05\x04\x16\
    \x02\x05\x06\x12\x04\xec\x04\x0b\x10\n\r\n\x05\x04\x16\x02\x05\x01\x12\
    \x04\xec\x04\x11\x17\n\r\n\x05\x04\x16\x02\x05\x03\x12\x04\xec\x04\x1a\
    \x1b\n0\n\x04\x04\x16\x02\x06\x12\x04\xee\x04\x02\x20\x1a\"\x20Clusterin\
    g\x20centroids\x20for\x20inputs.\n\n\r\n\x05\x04\x16\x02\x06\x04\x12\x04\
    \xee\x04\x02\n\n\r\n\x05\x04\x16\x02\x06\x06\x12\x04\xee\x04\x0b\x12\n\r\
    \n\x05\x04\x16\x02\x06\x01\x12\x04\xee\x04\x13\x1b\n\r\n\x05\x04\x16\x02\
    \x06\x03\x12\x04\xee\x04\x1e\x1f\n:\n\x04\x04\x16\x02\x07\x12\x04\xf0\
    \x04\x02$\x1a,\x20Embedding\x20vectors\x20representing\x20each\x20input.\
    \n\n\r\n\x05\x04\x16\x02\x07\x04\x12\x04\xf0\x04\x02\n\n\r\n\x05\x04\x16\
    \x02\x07\x06\x12\x04\xf0\x04\x0b\x14\n\r\n\x05\x04\x16\x02\x07\x01\x12\
    \x04\xf0\x04\x15\x1f\n\r\n\x05\x04\x16\x02\x07\x03\x12\x04\xf0\x04\"#\nA\
    \n\x04\x04\x16\x02\x08\x12\x04\xf2\x04\x02\x1f\x1a3\x20For\x20recursing\
    \x20into\x20localized\x20regions\x20of\x20an\x20input.\n\n\r\n\x05\x04\
    \x16\x02\x08\x04\x12\x04\xf2\x04\x02\n\n\r\n\x05\x04\x16\x02\x08\x06\x12\
    \x04\xf2\x04\x0b\x11\n\r\n\x05\x04\x16\x02\x08\x01\x12\x04\xf2\x04\x12\
    \x19\n\r\n\x05\x04\x16\x02\x08\x03\x12\x04\xf2\x04\x1c\x1e\n0\n\x04\x04\
    \x16\x02\t\x12\x04\xf4\x04\x02\x1d\x1a\"\x20For\x20temporal\x20content\
    \x20like\x20video.\n\n\r\n\x05\x04\x16\x02\t\x04\x12\x04\xf4\x04\x02\n\n\
    \r\n\x05\x04\x16\x02\t\x06\x12\x04\xf4\x04\x0b\x10\n\r\n\x05\x04\x16\x02\
    \t\x01\x12\x04\xf4\x04\x11\x17\n\r\n\x05\x04\x16\x02\t\x03\x12\x04\xf4\
    \x04\x1a\x1c\n&\n\x04\x04\x16\x02\n\x12\x04\xf6\x04\x02\x11\x1a\x18\x20I\
    nput\x20and\x20output\x20text.\n\n\r\n\x05\x04\x16\x02\n\x06\x12\x04\xf6\
    \x04\x02\x06\n\r\n\x05\x04\x16\x02\n\x01\x12\x04\xf6\x04\x07\x0b\n\r\n\
    \x05\x04\x16\x02\n\x03\x12\x04\xf6\x04\x0e\x10\n'\n\x04\x04\x16\x02\x0b\
    \x12\x04\xf8\x04\x02\x13\x1a\x19\x20Input\x20and\x20output\x20audio.\n\n\
    \r\n\x05\x04\x16\x02\x0b\x06\x12\x04\xf8\x04\x02\x07\n\r\n\x05\x04\x16\
    \x02\x0b\x01\x12\x04\xf8\x04\x08\r\n\r\n\x05\x04\x16\x02\x0b\x03\x12\x04\
    \xf8\x04\x10\x12\n\"\n\x04\x04\x16\x02\x0c\x12\x04\xfa\x04\x02\x1d\x1a\
    \x14\x20Track\x20information.\n\n\r\n\x05\x04\x16\x02\x0c\x04\x12\x04\
    \xfa\x04\x02\n\n\r\n\x05\x04\x16\x02\x0c\x06\x12\x04\xfa\x04\x0b\x10\n\r\
    \n\x05\x04\x16\x02\x0c\x01\x12\x04\xfa\x04\x11\x17\n\r\n\x05\x04\x16\x02\
    \x0c\x03\x12\x04\xfa\x04\x1a\x1c\n*\n\x04\x04\x16\x02\r\x12\x04\xfc\x04\
    \x02*\x1a\x1c\x20Time\x20segments\x20information.\n\n\r\n\x05\x04\x16\
    \x02\r\x04\x12\x04\xfc\x04\x02\n\n\r\n\x05\x04\x16\x02\r\x06\x12\x04\xfc\
    \x04\x0b\x16\n\r\n\x05\x04\x16\x02\r\x01\x12\x04\xfc\x04\x17$\n\r\n\x05\
    \x04\x16\x02\r\x03\x12\x04\xfc\x04')\n)\n\x02\x04\x17\x12\x06\x80\x05\0\
    \x8c\x05\x01\x1a\x1b\x20A\x20region\x20within\x20the\x20data.\n\n\x0b\n\
    \x03\x04\x17\x01\x12\x04\x80\x05\x08\x0e\n+\n\x04\x04\x17\x02\0\x12\x04\
    \x82\x05\x02\x10\x1a\x1d\x20A\x20unique\x20id\x20for\x20the\x20region.\n\
    \n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x82\x05\x02\x08\n\r\n\x05\x04\x17\
    \x02\0\x01\x12\x04\x82\x05\t\x0b\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x82\
    \x05\x0e\x0f\n=\n\x04\x04\x17\x02\x01\x12\x04\x84\x05\x02\x1d\x1a/\x20Th\
    e\x20details\x20about\x20the\x20location\x20of\x20the\x20region.\n\n\r\n\
    \x05\x04\x17\x02\x01\x06\x12\x04\x84\x05\x02\x0c\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\x84\x05\r\x18\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x84\
    \x05\x1b\x1c\n\xbd\x01\n\x04\x04\x17\x02\x02\x12\x04\x87\x05\x02\x10\x1a\
    \xae\x01\x20A\x20recursive\x20definition\x20of\x20the\x20data\x20within\
    \x20the\x20Region.\x20For\x20example,\x20this\x20will\x20contain\n\x20da\
    ta.concepts\x20if\x20the\x20region\x20also\x20has\x20annotations\x20or\
    \x20predictions\x20of\x20concepts\x20within\x20it.\n\n\r\n\x05\x04\x17\
    \x02\x02\x06\x12\x04\x87\x05\x02\x06\n\r\n\x05\x04\x17\x02\x02\x01\x12\
    \x04\x87\x05\x07\x0b\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\x87\x05\x0e\
    \x0f\nC\n\x04\x04\x17\x02\x03\x12\x04\x89\x05\x02\x12\x1a5\x20This\x20is\
    \x20the\x20confidence\x20score\x20of\x20the\x20overall\x20Region.\n\n\r\
    \n\x05\x04\x17\x02\x03\x05\x12\x04\x89\x05\x02\x07\n\r\n\x05\x04\x17\x02\
    \x03\x01\x12\x04\x89\x05\x08\r\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x89\
    \x05\x10\x11\nc\n\x04\x04\x17\x02\x04\x12\x04\x8b\x05\x02\x16\x1aU\x20Fo\
    r\x20tracking\x20algorithsm\x20and\x20annotations\x20we\x20tie\x20region\
    s\x20together\x20with\x20this\x20track\x20id.\n\n\r\n\x05\x04\x17\x02\
    \x04\x05\x12\x04\x8b\x05\x02\x08\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\
    \x8b\x05\t\x11\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\x8b\x05\x14\x15\n>\
    \n\x02\x04\x18\x12\x06\x8f\x05\0\x9a\x05\x01\x1a0\x20The\x20information\
    \x20of\x20the\x20location\x20of\x20the\x20Region.\n\n\x0b\n\x03\x04\x18\
    \x01\x12\x04\x8f\x05\x08\x12\n\x0b\n\x03\x04\x18\t\x12\x04\x90\x05\x02\
    \x10\n\x0c\n\x04\x04\x18\t\0\x12\x04\x90\x05\x0b\x0c\n\r\n\x05\x04\x18\t\
    \0\x01\x12\x04\x90\x05\x0b\x0c\n\r\n\x05\x04\x18\t\0\x02\x12\x04\x90\x05\
    \x0b\x0c\n\x0c\n\x04\x04\x18\t\x01\x12\x04\x90\x05\x0e\x0f\n\r\n\x05\x04\
    \x18\t\x01\x01\x12\x04\x90\x05\x0e\x0f\n\r\n\x05\x04\x18\t\x01\x02\x12\
    \x04\x90\x05\x0e\x0f\nA\n\x04\x04\x18\x02\0\x12\x04\x93\x05\x02\x1f\x1a3\
    \x20Details\x20of\x20the\x20region's\x20rectangular\x20bounding\x20box.\
    \n\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\x93\x05\x02\r\n\r\n\x05\x04\x18\
    \x02\0\x01\x12\x04\x93\x05\x0e\x1a\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\
    \x93\x05\x1d\x1e\n:\n\x04\x04\x18\x02\x01\x12\x04\x95\x05\x02\x10\x1a,\
    \x20Details\x20of\x20the\x20region's\x20segmentation\x20mask.\n\n\r\n\
    \x05\x04\x18\x02\x01\x06\x12\x04\x95\x05\x02\x06\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\x95\x05\x07\x0b\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\
    \x95\x05\x0e\x0f\n$\n\x04\x04\x18\x02\x02\x12\x04\x97\x05\x02\x16\x1a\
    \x16\x20A\x20polygon\x20of\x20points.\n\n\r\n\x05\x04\x18\x02\x02\x06\
    \x12\x04\x97\x05\x02\t\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\x97\x05\n\
    \x11\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\x97\x05\x14\x15\n*\n\x04\x04\
    \x18\x02\x03\x12\x04\x99\x05\x02\x12\x1a\x1c\x20A\x20landmark\x20point\
    \x20location.\n\n\r\n\x05\x04\x18\x02\x03\x06\x12\x04\x99\x05\x02\x07\n\
    \r\n\x05\x04\x18\x02\x03\x01\x12\x04\x99\x05\x08\r\n\r\n\x05\x04\x18\x02\
    \x03\x03\x12\x04\x99\x05\x10\x11\n6\n\x02\x04\x19\x12\x06\x9d\x05\0\xa6\
    \x05\x01\x1a(\x20Rectangular\x20bounding\x20box\x20for\x20a\x20region.\n\
    \n\x0b\n\x03\x04\x19\x01\x12\x04\x9d\x05\x08\x13\nf\n\x04\x04\x19\x02\0\
    \x12\x04\x9f\x05\x02C\x1aX\x20The\x20top\x20left\x20of\x20the\x20boundin\
    g\x20box\x20normalized\x20to\x20the\x20data\x20dimension\x20to\x20be\x20\
    within\x20[0-1.0]\n\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\x9f\x05\x02\x07\
    \n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x9f\x05\x08\x0f\n\r\n\x05\x04\x19\
    \x02\0\x03\x12\x04\x9f\x05\x12\x13\n\r\n\x05\x04\x19\x02\0\x08\x12\x04\
    \x9f\x05\x14B\n\x10\n\x08\x04\x19\x02\0\x08\xd0\x86\x03\x12\x04\x9f\x05\
    \x15A\ni\n\x04\x04\x19\x02\x01\x12\x04\xa1\x05\x02D\x1a[\x20The\x20left\
    \x20column\x20of\x20the\x20bounding\x20box\x20normalized\x20to\x20the\
    \x20data\x20dimension\x20to\x20be\x20within\x20[0-1.0]\n\n\r\n\x05\x04\
    \x19\x02\x01\x05\x12\x04\xa1\x05\x02\x07\n\r\n\x05\x04\x19\x02\x01\x01\
    \x12\x04\xa1\x05\x08\x10\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xa1\x05\
    \x13\x14\n\r\n\x05\x04\x19\x02\x01\x08\x12\x04\xa1\x05\x15C\n\x10\n\x08\
    \x04\x19\x02\x01\x08\xd0\x86\x03\x12\x04\xa1\x05\x16B\nh\n\x04\x04\x19\
    \x02\x02\x12\x04\xa3\x05\x02F\x1aZ\x20The\x20bottom\x20row\x20of\x20the\
    \x20bounding\x20box\x20normalized\x20to\x20the\x20data\x20dimension\x20t\
    o\x20be\x20within\x20[0-1.0]\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xa3\
    \x05\x02\x07\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xa3\x05\x08\x12\n\r\n\
    \x05\x04\x19\x02\x02\x03\x12\x04\xa3\x05\x15\x16\n\r\n\x05\x04\x19\x02\
    \x02\x08\x12\x04\xa3\x05\x17E\n\x10\n\x08\x04\x19\x02\x02\x08\xd0\x86\
    \x03\x12\x04\xa3\x05\x18D\ng\n\x04\x04\x19\x02\x03\x12\x04\xa5\x05\x02E\
    \x1aY\x20The\x20right\x20col\x20of\x20the\x20bounding\x20box\x20normaliz\
    ed\x20to\x20the\x20data\x20dimension\x20to\x20be\x20within\x20[0-1.0]\n\
    \n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xa5\x05\x02\x07\n\r\n\x05\x04\x19\
    \x02\x03\x01\x12\x04\xa5\x05\x08\x11\n\r\n\x05\x04\x19\x02\x03\x03\x12\
    \x04\xa5\x05\x14\x15\n\r\n\x05\x04\x19\x02\x03\x08\x12\x04\xa5\x05\x16D\
    \n\x10\n\x08\x04\x19\x02\x03\x08\xd0\x86\x03\x12\x04\xa5\x05\x17C\n=\n\
    \x02\x04\x1a\x12\x06\xa9\x05\0\xb0\x05\x01\x1a/\x20The\x20information\
    \x20of\x20the\x20location\x20of\x20the\x20Frame.\n\n\x0b\n\x03\x04\x1a\
    \x01\x12\x04\xa9\x05\x08\x11\nt\n\x04\x04\x1a\x02\0\x12\x04\xac\x05\x02B\
    \x1af\x20The\x20index\x20of\x20the\x20frame.\x20Keep\x20in\x20mind\x20th\
    at\x20this\x20depends\x20on\x20the\x20sampling\x20rate\x20used\x20during\
    \n\x20processing.\n\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xac\x05\x02\x08\
    \n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xac\x05\t\x0e\n\r\n\x05\x04\x1a\x02\
    \0\x03\x12\x04\xac\x05\x11\x12\n\r\n\x05\x04\x1a\x02\0\x08\x12\x04\xac\
    \x05\x13A\n\x10\n\x08\x04\x1a\x02\0\x08\xd0\x86\x03\x12\x04\xac\x05\x14@\
    \nu\n\x04\x04\x1a\x02\x01\x12\x04\xaf\x05\x02A\x1ag\x20time\x20in\x20the\
    \x20video\x20in\x20milliseconds.\x20This\x20is\x20independent\x20of\x20t\
    he\x20sampling\x20rates\x20used\x20during\n\x20processing.\n\n\r\n\x05\
    \x04\x1a\x02\x01\x05\x12\x04\xaf\x05\x02\x08\n\r\n\x05\x04\x1a\x02\x01\
    \x01\x12\x04\xaf\x05\t\r\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xaf\x05\
    \x10\x11\n\r\n\x05\x04\x1a\x02\x01\x08\x12\x04\xaf\x05\x12@\n\x10\n\x08\
    \x04\x1a\x02\x01\x08\xd0\x86\x03\x12\x04\xaf\x05\x13?\n<\n\x02\x04\x1b\
    \x12\x06\xb3\x05\0\xbd\x05\x01\x1a.\x20A\x20Frame\x20of\x20time-series\
    \x20Data\x20such\x20as\x20a\x20Video.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\
    \xb3\x05\x08\r\n@\n\x04\x04\x1b\x02\0\x12\x04\xb5\x05\x02\x1b\x1a2\x20In\
    formation\x20aboue\x20frame\x20such\x20as\x20number\x20and\x20time.\n\n\
    \r\n\x05\x04\x1b\x02\0\x06\x12\x04\xb5\x05\x02\x0b\n\r\n\x05\x04\x1b\x02\
    \0\x01\x12\x04\xb5\x05\x0c\x16\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xb5\
    \x05\x19\x1a\n\xd5\x02\n\x04\x04\x1b\x02\x01\x12\x04\xba\x05\x02\x10\x1a\
    \xc6\x02\x20A\x20recursive\x20definition\x20of\x20the\x20data\x20within\
    \x20the\x20Frame.\x20For\x20example,\x20this\x20will\x20contain\n\x20dat\
    a.concepts\x20if\x20the\x20Frame\x20also\x20has\x20annotations\x20or\x20\
    predictions\x20of\x20concepts\x20within\x20it.\n\x20This\x20can\x20also\
    \x20have\x20data.regions\x20for\x20annotation\x20or\x20predictions\x20of\
    \x20detection\x20regions,\x20which\x20can\n\x20then\x20recursively\x20ha\
    ve\x20their\x20data\x20field\x20filled\x20in\x20as\x20well.\n\n\r\n\x05\
    \x04\x1b\x02\x01\x06\x12\x04\xba\x05\x02\x06\n\r\n\x05\x04\x1b\x02\x01\
    \x01\x12\x04\xba\x05\x07\x0b\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xba\
    \x05\x0e\x0f\n$\n\x04\x04\x1b\x02\x02\x12\x04\xbc\x05\x02\x10\x1a\x16\
    \x20An\x20ID\x20for\x20the\x20frame.\n\n\r\n\x05\x04\x1b\x02\x02\x05\x12\
    \x04\xbc\x05\x02\x08\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xbc\x05\t\x0b\
    \n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xbc\x05\x0e\x0f\n\"\n\x02\x04\x1c\
    \x12\x06\xc0\x05\0\xc5\x05\x01\x1a\x14\x20Segmentation\x20mask.\n\n\x0b\
    \n\x03\x04\x1c\x01\x12\x04\xc0\x05\x08\x0c\n\x0b\n\x03\x04\x1c\t\x12\x04\
    \xc1\x05\x02\r\n\x0c\n\x04\x04\x1c\t\0\x12\x04\xc1\x05\x0b\x0c\n\r\n\x05\
    \x04\x1c\t\0\x01\x12\x04\xc1\x05\x0b\x0c\n\r\n\x05\x04\x1c\t\0\x02\x12\
    \x04\xc1\x05\x0b\x0c\n=\n\x04\x04\x1c\x02\0\x12\x04\xc4\x05\x02\x12\x1a/\
    \x20The\x20image\x20of\x20the\x20mask\x20in\x20a\x20non-raster\x20format\
    .\n\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xc4\x05\x02\x07\n\r\n\x05\x04\
    \x1c\x02\0\x01\x12\x04\xc4\x05\x08\r\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\
    \xc4\x05\x10\x11\n\x0c\n\x02\x04\x1d\x12\x06\xc7\x05\0\xca\x05\x01\n\x0b\
    \n\x03\x04\x1d\x01\x12\x04\xc7\x05\x08\x0f\nH\n\x04\x04\x1d\x02\0\x12\
    \x04\xc9\x05\x02\x1c\x1a:\x20A\x20list\x20of\x20points\x20connected\x20t\
    ogether\x20to\x20form\x20the\x20polygon.\n\n\r\n\x05\x04\x1d\x02\0\x04\
    \x12\x04\xc9\x05\x02\n\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xc9\x05\x0b\
    \x10\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xc9\x05\x11\x17\n\r\n\x05\x04\
    \x1d\x02\0\x03\x12\x04\xc9\x05\x1a\x1b\n\x0c\n\x02\x04\x1e\x12\x06\xcc\
    \x05\0\xd5\x05\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xcc\x05\x08\r\n\x7f\n\
    \x04\x04\x1e\x02\0\x12\x04\xcf\x05\x02?\x1aq\x20The\x20row\x20location\
    \x20of\x20the\x20point.\x20This\x20has\x20a\x20[0.0-1.0]\x20range\x20wit\
    h\x200.0\x20being\x20top\x20row\x20and\x201.0\n\x20being\x20the\x20botto\
    m\x20row.\n\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xcf\x05\x02\x07\n\r\n\
    \x05\x04\x1e\x02\0\x01\x12\x04\xcf\x05\x08\x0b\n\r\n\x05\x04\x1e\x02\0\
    \x03\x12\x04\xcf\x05\x0e\x0f\n\r\n\x05\x04\x1e\x02\0\x08\x12\x04\xcf\x05\
    \x10>\n\x10\n\x08\x04\x1e\x02\0\x08\xd0\x86\x03\x12\x04\xcf\x05\x11=\n\
    \x82\x01\n\x04\x04\x1e\x02\x01\x12\x04\xd2\x05\x02?\x1at\x20The\x20colum\
    n\x20location\x20of\x20the\x20point.\x20This\x20has\x20a\x20[0.0-1.0]\
    \x20range\x20with\x200.0\x20being\x20left\x20col\x20and\x201.0\n\x20bein\
    g\x20the\x20right\x20col.\n\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xd2\
    \x05\x02\x07\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xd2\x05\x08\x0b\n\r\n\
    \x05\x04\x1e\x02\x01\x03\x12\x04\xd2\x05\x0e\x0f\n\r\n\x05\x04\x1e\x02\
    \x01\x08\x12\x04\xd2\x05\x10>\n\x10\n\x08\x04\x1e\x02\x01\x08\xd0\x86\
    \x03\x12\x04\xd2\x05\x11=\n2\n\x04\x04\x1e\x02\x02\x12\x04\xd4\x05\x02\
    \x0e\x1a$\x20Depth\x20if\x20applicable\x20for\x20the\x20point.\n\n\r\n\
    \x05\x04\x1e\x02\x02\x05\x12\x04\xd4\x05\x02\x07\n\r\n\x05\x04\x1e\x02\
    \x02\x01\x12\x04\xd4\x05\x08\t\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xd4\
    \x05\x0c\r\n\xb1\x02\n\x02\x04\x1f\x12\x06\xe1\x05\0\xe4\x05\x01\x1a\xd1\
    \x01////////////////////////////////////////////////////////////////////\
    //////////\n\x20Messages\x20from\x20/proto/clarifai/api/embedding.proto\
    \n//////////////////////////////////////////////////////////////////////\
    ////////\n2O////////////////////////////////////////////////////////////\
    //////////////////\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xe1\x05\x08\x11\n\
    \x0c\n\x04\x04\x1f\x02\0\x12\x04\xe2\x05\x02,\n\r\n\x05\x04\x1f\x02\0\
    \x04\x12\x04\xe2\x05\x02\n\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xe2\x05\
    \x0b\x10\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xe2\x05\x11\x17\n\r\n\x05\
    \x04\x1f\x02\0\x03\x12\x04\xe2\x05\x1a\x1b\n\r\n\x05\x04\x1f\x02\0\x08\
    \x12\x04\xe2\x05\x1c+\n\x0e\n\x06\x04\x1f\x02\0\x08\x02\x12\x04\xe2\x05\
    \x1d*\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xe3\x05\x02\x1c\n\r\n\x05\x04\
    \x1f\x02\x01\x05\x12\x04\xe3\x05\x02\x08\n\r\n\x05\x04\x1f\x02\x01\x01\
    \x12\x04\xe3\x05\t\x17\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xe3\x05\x1a\
    \x1b\n\xab\x02\n\x02\x04\x20\x12\x06\xf0\x05\0\xf3\x05\x01\x1a\xcb\x01//\
    ////////////////////////////////////////////////////////////////////////\
    ////\n\x20Messages\x20from\x20/proto/clarifai/api/geo.proto\n///////////\
    ///////////////////////////////////////////////////////////////////\n2O/\
    ////////////////////////////////////////////////////////////////////////\
    /////\n\n\x0b\n\x03\x04\x20\x01\x12\x04\xf0\x05\x08\x10\n\x0c\n\x04\x04\
    \x20\x02\0\x12\x04\xf1\x05\x02E\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xf1\
    \x05\x02\x07\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xf1\x05\x08\x11\n\r\n\
    \x05\x04\x20\x02\0\x03\x12\x04\xf1\x05\x14\x15\n\r\n\x05\x04\x20\x02\0\
    \x08\x12\x04\xf1\x05\x16D\n\x10\n\x08\x04\x20\x02\0\x08\xd0\x86\x03\x12\
    \x04\xf1\x05\x17C\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\xf2\x05\x02D\n\r\n\
    \x05\x04\x20\x02\x01\x05\x12\x04\xf2\x05\x02\x07\n\r\n\x05\x04\x20\x02\
    \x01\x01\x12\x04\xf2\x05\x08\x10\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\
    \xf2\x05\x13\x14\n\r\n\x05\x04\x20\x02\x01\x08\x12\x04\xf2\x05\x15C\n\
    \x10\n\x08\x04\x20\x02\x01\x08\xd0\x86\x03\x12\x04\xf2\x05\x16B\n\x0c\n\
    \x02\x04!\x12\x06\xf5\x05\0\xf8\x05\x01\n\x0b\n\x03\x04!\x01\x12\x04\xf5\
    \x05\x08\x10\n\x0c\n\x04\x04!\x02\0\x12\x04\xf6\x05\x02\x12\n\r\n\x05\
    \x04!\x02\0\x05\x12\x04\xf6\x05\x02\x08\n\r\n\x05\x04!\x02\0\x01\x12\x04\
    \xf6\x05\t\r\n\r\n\x05\x04!\x02\0\x03\x12\x04\xf6\x05\x10\x11\n\x0c\n\
    \x04\x04!\x02\x01\x12\x04\xf7\x05\x02A\n\r\n\x05\x04!\x02\x01\x05\x12\
    \x04\xf7\x05\x02\x07\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xf7\x05\x08\r\n\
    \r\n\x05\x04!\x02\x01\x03\x12\x04\xf7\x05\x10\x11\n\r\n\x05\x04!\x02\x01\
    \x08\x12\x04\xf7\x05\x12@\n\x10\n\x08\x04!\x02\x01\x08\xd0\x86\x03\x12\
    \x04\xf7\x05\x13?\n\x0c\n\x02\x04\"\x12\x06\xfa\x05\0\xfc\x05\x01\n\x0b\
    \n\x03\x04\"\x01\x12\x04\xfa\x05\x08\x15\n\x0c\n\x04\x04\"\x02\0\x12\x04\
    \xfb\x05\x02\x19\n\r\n\x05\x04\"\x02\0\x06\x12\x04\xfb\x05\x02\n\n\r\n\
    \x05\x04\"\x02\0\x01\x12\x04\xfb\x05\x0b\x14\n\r\n\x05\x04\"\x02\0\x03\
    \x12\x04\xfb\x05\x17\x18\n\x0c\n\x02\x04#\x12\x06\xfe\x05\0\x83\x06\x01\
    \n\x0b\n\x03\x04#\x01\x12\x04\xfe\x05\x08\x0b\n\x0c\n\x04\x04#\x02\0\x12\
    \x04\xff\x05\x02\x19\n\r\n\x05\x04#\x02\0\x06\x12\x04\xff\x05\x02\n\n\r\
    \n\x05\x04#\x02\0\x01\x12\x04\xff\x05\x0b\x14\n\r\n\x05\x04#\x02\0\x03\
    \x12\x04\xff\x05\x17\x18\n\x0c\n\x04\x04#\x02\x01\x12\x04\x80\x06\x02\
    \x19\n\r\n\x05\x04#\x02\x01\x06\x12\x04\x80\x06\x02\n\n\r\n\x05\x04#\x02\
    \x01\x01\x12\x04\x80\x06\x0b\x14\n\r\n\x05\x04#\x02\x01\x03\x12\x04\x80\
    \x06\x17\x18\nF\n\x04\x04#\x02\x02\x12\x04\x82\x06\x02%\x1a8\x20NOTE:\
    \x20inconsistency:\x20should\x20have\x20been\x20geo_boxed_points\n\n\r\n\
    \x05\x04#\x02\x02\x04\x12\x04\x82\x06\x02\n\n\r\n\x05\x04#\x02\x02\x06\
    \x12\x04\x82\x06\x0b\x18\n\r\n\x05\x04#\x02\x02\x01\x12\x04\x82\x06\x19\
    \x20\n\r\n\x05\x04#\x02\x02\x03\x12\x04\x82\x06#$\n\xce\x04\n\x02\x04$\
    \x12\x06\x99\x06\0\xac\x06\x01\x1a\xcd\x01//////////////////////////////\
    ////////////////////////////////////////////////\n\x20Messages\x20from\
    \x20/proto/clarifai/api/image.proto\n///////////////////////////////////\
    ///////////////////////////////////////////\n2O/////////////////////////\
    /////////////////////////////////////////////////////\n2\x9e\x02////////\
    //////////////////////////////////////////////////////////////////////\n\
    \x20Messages\x20from\x20/proto/clarifai/api/healthz.proto\n/////////////\
    /////////////////////////////////////////////////////////////////\n/////\
    ////////////////////////////////////////////////////////////////////////\
    /\n\n\x0b\n\x03\x04$\x01\x12\x04\x99\x06\x08\r\n\x0b\n\x03\x04$\t\x12\
    \x04\x9a\x06\x02\r\n\x0c\n\x04\x04$\t\0\x12\x04\x9a\x06\x0b\x0c\n\r\n\
    \x05\x04$\t\0\x01\x12\x04\x9a\x06\x0b\x0c\n\r\n\x05\x04$\t\0\x02\x12\x04\
    \x9a\x06\x0b\x0c\n\x86\x01\n\x04\x04$\x02\0\x12\x04\x9e\x06\x02\x11\x1ax\
    \x20This\x20is\x20a\x20URL\x20to\x20a\x20publicly\x20accessible\x20image\
    \x20file.\x20The\x20platform\x20will\x20download\x20this\x20file\x20serv\
    er\n\x20side\x20and\x20then\x20process.\n\n\r\n\x05\x04$\x02\0\x05\x12\
    \x04\x9e\x06\x02\x08\n\r\n\x05\x04$\x02\0\x01\x12\x04\x9e\x06\t\x0c\n\r\
    \n\x05\x04$\x02\0\x03\x12\x04\x9e\x06\x0f\x10\n\x90\x03\n\x04\x04$\x02\
    \x01\x12\x04\xa5\x06\x02\x13\x1a\x81\x03\x20The\x20base64\x20field\x20is\
    \x20using\x20image\x20file\x20bytes\x20directly\x20in\x20the\x20request.\
    \n\x20NOTE:\x20if\x20you're\x20sending\x20a\x20json\x20request,\x20then\
    \x20this\x20MUST\x20be\x20base64\x20encoded\x20before\x20sending\x20(hen\
    ce\n\x20the\x20name\x20here).\n\x20When\x20using\x20our\x20grpc\x20clien\
    ts,\x20you\x20DO\x20NOT\x20need\x20to\x20base64\x20encode\n\x20it\x20you\
    rself\x20since\x20the\x20clients\x20know\x20how\x20to\x20do\x20this\x20f\
    or\x20you\x20automatically\x20and\x20will\x20avoid\x20the\n\x20base64\
    \x20encoding\x20if\x20they\x20send\x20a\x20binary\x20request.\n\n\r\n\
    \x05\x04$\x02\x01\x05\x12\x04\xa5\x06\x02\x07\n\r\n\x05\x04$\x02\x01\x01\
    \x12\x04\xa5\x06\x08\x0e\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xa5\x06\x11\
    \x12\n\x0c\n\x04\x04$\x02\x02\x12\x04\xa7\x06\x02\x1f\n\r\n\x05\x04$\x02\
    \x02\x05\x12\x04\xa7\x06\x02\x06\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xa7\
    \x06\x07\x1a\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xa7\x06\x1d\x1e\n\\\n\
    \x04\x04$\x02\x03\x12\x04\xa9\x06\x02\x17\x1aN\x20The\x20hosted\x20field\
    \x20lists\x20images\x20in\x20different\x20sizes\x20hosted\x20in\x20Clari\
    fai\x20storage.\n\n\r\n\x05\x04$\x02\x03\x06\x12\x04\xa9\x06\x02\x0b\n\r\
    \n\x05\x04$\x02\x03\x01\x12\x04\xa9\x06\x0c\x12\n\r\n\x05\x04$\x02\x03\
    \x03\x12\x04\xa9\x06\x15\x16\n\x1a\n\x04\x04$\x02\x04\x12\x04\xab\x06\
    \x02\x1b\x1a\x0c\x20image\x20info\n\n\r\n\x05\x04$\x02\x04\x06\x12\x04\
    \xab\x06\x02\x0b\n\r\n\x05\x04$\x02\x04\x01\x12\x04\xab\x06\x0c\x16\n\r\
    \n\x05\x04$\x02\x04\x03\x12\x04\xab\x06\x19\x1a\n\x0c\n\x02\x04%\x12\x06\
    \xae\x06\0\xb7\x06\x01\n\x0b\n\x03\x04%\x01\x12\x04\xae\x06\x08\x11\n\
    \x15\n\x04\x04%\x02\0\x12\x04\xb0\x06\x02\x12\x1a\x07\x20width\n\n\r\n\
    \x05\x04%\x02\0\x05\x12\x04\xb0\x06\x02\x07\n\r\n\x05\x04%\x02\0\x01\x12\
    \x04\xb0\x06\x08\r\n\r\n\x05\x04%\x02\0\x03\x12\x04\xb0\x06\x10\x11\n\
    \x16\n\x04\x04%\x02\x01\x12\x04\xb2\x06\x02\x13\x1a\x08\x20height\n\n\r\
    \n\x05\x04%\x02\x01\x05\x12\x04\xb2\x06\x02\x07\n\r\n\x05\x04%\x02\x01\
    \x01\x12\x04\xb2\x06\x08\x0e\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xb2\x06\
    \x11\x12\n\x1c\n\x04\x04%\x02\x02\x12\x04\xb4\x06\x02\x14\x1a\x0e\x20ima\
    ge\x20format\n\n\r\n\x05\x04%\x02\x02\x05\x12\x04\xb4\x06\x02\x08\n\r\n\
    \x05\x04%\x02\x02\x01\x12\x04\xb4\x06\t\x0f\n\r\n\x05\x04%\x02\x02\x03\
    \x12\x04\xb4\x06\x12\x13\n\x20\n\x04\x04%\x02\x03\x12\x04\xb6\x06\x02\
    \x18\x1a\x12\x20image\x20color\x20mode\n\n\r\n\x05\x04%\x02\x03\x05\x12\
    \x04\xb6\x06\x02\x08\n\r\n\x05\x04%\x02\x03\x01\x12\x04\xb6\x06\t\x13\n\
    \r\n\x05\x04%\x02\x03\x03\x12\x04\xb6\x06\x16\x17\n\x0c\n\x02\x04&\x12\
    \x06\xb9\x06\0\xc4\x06\x01\n\x0b\n\x03\x04&\x01\x12\x04\xb9\x06\x08\x11\
    \n8\n\x04\x04&\x02\0\x12\x04\xbb\x06\x02\x14\x1a*\x20Prefix\x20of\x20the\
    \x20URL\x20of\x20every\x20hosted\x20image.\n\n\r\n\x05\x04&\x02\0\x05\
    \x12\x04\xbb\x06\x02\x08\n\r\n\x05\x04&\x02\0\x01\x12\x04\xbb\x06\t\x0f\
    \n\r\n\x05\x04&\x02\0\x03\x12\x04\xbb\x06\x12\x13\n=\n\x04\x04&\x02\x01\
    \x12\x04\xbd\x06\x02\x14\x1a/\x20Suffix\x20of\x20an\x20image\x20stored\
    \x20in\x20different\x20sizes.\n\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xbd\
    \x06\x02\x08\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xbd\x06\t\x0f\n\r\n\x05\
    \x04&\x02\x01\x03\x12\x04\xbd\x06\x12\x13\n\xc7\x01\n\x04\x04&\x02\x02\
    \x12\x04\xc0\x06\x02\x1c\x1a\xb8\x01\x20The\x20sizes\x20field\x20lists\
    \x20which\x20images\x20of\x20the\x20different\x20sizes\x20are\x20hosted\
    \x20in\x20our\x20storage.\x20The\x20URL\n\x20of\x20each\x20hosted\x20ima\
    ge\x20can\x20be\x20obtained\x20by\x20joining\x20the\x20prefix,\x20one\
    \x20of\x20the\x20sizes\x20and\x20suffix.\n\n\r\n\x05\x04&\x02\x02\x04\
    \x12\x04\xc0\x06\x02\n\n\r\n\x05\x04&\x02\x02\x05\x12\x04\xc0\x06\x0b\
    \x11\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xc0\x06\x12\x17\n\r\n\x05\x04&\
    \x02\x02\x03\x12\x04\xc0\x06\x1a\x1b\n}\n\x04\x04&\x02\x03\x12\x04\xc3\
    \x06\x02\x19\x1ao\x20The\x20crossorigin\x20property\x20of\x20html\x20med\
    ia\x20tag\n\x20For\x20Secure\x20Data\x20Hosting\x20this\x20needs\x20to\
    \x20be\x20set\x20to\x20'use-credentials'\n\n\r\n\x05\x04&\x02\x03\x05\
    \x12\x04\xc3\x06\x02\x08\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xc3\x06\t\
    \x14\n\r\n\x05\x04&\x02\x03\x03\x12\x04\xc3\x06\x17\x18\n\xad\x02\n\x02\
    \x04'\x12\x06\xd0\x06\0\xea\x06\x01\x1a\xcd\x01/////////////////////////\
    /////////////////////////////////////////////////////\n\x20Messages\x20f\
    rom\x20/proto/clarifai/api/input.proto\n////////////////////////////////\
    //////////////////////////////////////////////\n2O//////////////////////\
    ////////////////////////////////////////////////////////\n\n\x0b\n\x03\
    \x04'\x01\x12\x04\xd0\x06\x08\r\n\x0b\n\x03\x04'\t\x12\x04\xd1\x06\x02\r\
    \n\x0c\n\x04\x04'\t\0\x12\x04\xd1\x06\x0b\x0c\n\r\n\x05\x04'\t\0\x01\x12\
    \x04\xd1\x06\x0b\x0c\n\r\n\x05\x04'\t\0\x02\x12\x04\xd1\x06\x0b\x0c\n$\n\
    \x04\x04'\x02\0\x12\x04\xd4\x06\x02\x10\x1a\x16\x20The\x20ID\x20for\x20t\
    he\x20input\n\n\r\n\x05\x04'\x02\0\x05\x12\x04\xd4\x06\x02\x08\n\r\n\x05\
    \x04'\x02\0\x01\x12\x04\xd4\x06\t\x0b\n\r\n\x05\x04'\x02\0\x03\x12\x04\
    \xd4\x06\x0e\x0f\n4\n\x04\x04'\x02\x01\x12\x04\xd7\x06\x02\x10\x1a&\x20T\
    he\x20data\x20passed\x20along\x20in\x20this\x20input.\n\n\r\n\x05\x04'\
    \x02\x01\x06\x12\x04\xd7\x06\x02\x06\n\r\n\x05\x04'\x02\x01\x01\x12\x04\
    \xd7\x06\x07\x0b\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xd7\x06\x0e\x0f\n\
    \x80\x02\n\x04\x04'\x02\x02\x12\x04\xde\x06\x02+\x1a\xf1\x01\x20When\x20\
    the\x20input\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20timest\
    amp\n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\
    \x20format:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20\
    expect\x20results\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\
    \x20\"2017-04-11T21:50:50.223962Z\"\n\n\r\n\x05\x04'\x02\x02\x06\x12\x04\
    \xde\x06\x02\x1b\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xde\x06\x1c&\n\r\n\
    \x05\x04'\x02\x02\x03\x12\x04\xde\x06)*\n,\n\x04\x04'\x02\x03\x12\x04\
    \xe1\x06\x02,\x1a\x1e\x20When\x20the\x20input\x20was\x20modified.\n\n\r\
    \n\x05\x04'\x02\x03\x06\x12\x04\xe1\x06\x02\x1b\n\r\n\x05\x04'\x02\x03\
    \x01\x12\x04\xe1\x06\x1c'\n\r\n\x05\x04'\x02\x03\x03\x12\x04\xe1\x06*+\n\
    [\n\x04\x04'\x02\x04\x12\x04\xe5\x06\x02(\x1aM\x20This\x20is\x20the\x20s\
    tatus\x20at\x20a\x20per\x20Input\x20level\x20which\x20allows\x20for\n\
    \x20partial\x20failures.\n\n\r\n\x05\x04'\x02\x04\x06\x12\x04\xe5\x06\
    \x02\x1c\n\r\n\x05\x04'\x02\x04\x01\x12\x04\xe5\x06\x1d#\n\r\n\x05\x04'\
    \x02\x04\x03\x12\x04\xe5\x06&'\nm\n\x04\x04'\x02\x05\x12\x04\xe9\x06\x02\
    \"\x1a_\x20List\x20of\x20dataset\x20IDs\x20that\x20this\x20input\x20is\
    \x20part\x20of\n\x20Currently,\x20this\x20field\x20is\x20ONLY\x20used\
    \x20in\x20search.\n\n\r\n\x05\x04'\x02\x05\x04\x12\x04\xe9\x06\x02\n\n\r\
    \n\x05\x04'\x02\x05\x05\x12\x04\xe9\x06\x0b\x11\n\r\n\x05\x04'\x02\x05\
    \x01\x12\x04\xe9\x06\x12\x1d\n\r\n\x05\x04'\x02\x05\x03\x12\x04\xe9\x06\
    \x20!\nT\n\x02\x04(\x12\x06\xed\x06\0\xf6\x06\x01\x1aF\x20NOTE:\x20incon\
    sistency:\x20this\x20is\x20weird\x20mix\x20of\x20plural\x20and\x20singul\
    ar\x20words.\n\n\x0b\n\x03\x04(\x01\x12\x04\xed\x06\x08\x12\n\x0c\n\x04\
    \x04(\x02\0\x12\x04\xee\x06\x02F\n\r\n\x05\x04(\x02\0\x05\x12\x04\xee\
    \x06\x02\x08\n\r\n\x05\x04(\x02\0\x01\x12\x04\xee\x06\t\x12\n\r\n\x05\
    \x04(\x02\0\x03\x12\x04\xee\x06\x15\x16\n\r\n\x05\x04(\x02\0\x08\x12\x04\
    \xee\x06\x17E\n\x10\n\x08\x04(\x02\0\x08\xd0\x86\x03\x12\x04\xee\x06\x18\
    D\n\x0c\n\x04\x04(\x02\x01\x12\x04\xef\x06\x02G\n\r\n\x05\x04(\x02\x01\
    \x05\x12\x04\xef\x06\x02\x08\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xef\x06\
    \t\x13\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xef\x06\x16\x17\n\r\n\x05\x04(\
    \x02\x01\x08\x12\x04\xef\x06\x18F\n\x10\n\x08\x04(\x02\x01\x08\xd0\x86\
    \x03\x12\x04\xef\x06\x19E\n\x0c\n\x04\x04(\x02\x02\x12\x04\xf0\x06\x02C\
    \n\r\n\x05\x04(\x02\x02\x05\x12\x04\xf0\x06\x02\x08\n\r\n\x05\x04(\x02\
    \x02\x01\x12\x04\xf0\x06\t\x0f\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xf0\
    \x06\x12\x13\n\r\n\x05\x04(\x02\x02\x08\x12\x04\xf0\x06\x14B\n\x10\n\x08\
    \x04(\x02\x02\x08\xd0\x86\x03\x12\x04\xf0\x06\x15A\n\x0c\n\x04\x04(\x02\
    \x03\x12\x04\xf1\x06\x02G\n\r\n\x05\x04(\x02\x03\x05\x12\x04\xf1\x06\x02\
    \x08\n\r\n\x05\x04(\x02\x03\x01\x12\x04\xf1\x06\t\x13\n\r\n\x05\x04(\x02\
    \x03\x03\x12\x04\xf1\x06\x16\x17\n\r\n\x05\x04(\x02\x03\x08\x12\x04\xf1\
    \x06\x18F\n\x10\n\x08\x04(\x02\x03\x08\xd0\x86\x03\x12\x04\xf1\x06\x19E\
    \n\x0c\n\x04\x04(\x02\x04\x12\x04\xf2\x06\x02F\n\r\n\x05\x04(\x02\x04\
    \x05\x12\x04\xf2\x06\x02\x08\n\r\n\x05\x04(\x02\x04\x01\x12\x04\xf2\x06\
    \t\x12\n\r\n\x05\x04(\x02\x04\x03\x12\x04\xf2\x06\x15\x16\n\r\n\x05\x04(\
    \x02\x04\x08\x12\x04\xf2\x06\x17E\n\x10\n\x08\x04(\x02\x04\x08\xd0\x86\
    \x03\x12\x04\xf2\x06\x18D\n\x0c\n\x04\x04(\x02\x05\x12\x04\xf3\x06\x02G\
    \n\r\n\x05\x04(\x02\x05\x05\x12\x04\xf3\x06\x02\x08\n\r\n\x05\x04(\x02\
    \x05\x01\x12\x04\xf3\x06\t\x13\n\r\n\x05\x04(\x02\x05\x03\x12\x04\xf3\
    \x06\x16\x17\n\r\n\x05\x04(\x02\x05\x08\x12\x04\xf3\x06\x18F\n\x10\n\x08\
    \x04(\x02\x05\x08\xd0\x86\x03\x12\x04\xf3\x06\x19E\n\x0c\n\x04\x04(\x02\
    \x06\x12\x04\xf4\x06\x02K\n\r\n\x05\x04(\x02\x06\x05\x12\x04\xf4\x06\x02\
    \x08\n\r\n\x05\x04(\x02\x06\x01\x12\x04\xf4\x06\t\x17\n\r\n\x05\x04(\x02\
    \x06\x03\x12\x04\xf4\x06\x1a\x1b\n\r\n\x05\x04(\x02\x06\x08\x12\x04\xf4\
    \x06\x1cJ\n\x10\n\x08\x04(\x02\x06\x08\xd0\x86\x03\x12\x04\xf4\x06\x1dI\
    \n\x0c\n\x04\x04(\x02\x07\x12\x04\xf5\x06\x02G\n\r\n\x05\x04(\x02\x07\
    \x05\x12\x04\xf5\x06\x02\x08\n\r\n\x05\x04(\x02\x07\x01\x12\x04\xf5\x06\
    \t\x13\n\r\n\x05\x04(\x02\x07\x03\x12\x04\xf5\x06\x16\x17\n\r\n\x05\x04(\
    \x02\x07\x08\x12\x04\xf5\x06\x18F\n\x10\n\x08\x04(\x02\x07\x08\xd0\x86\
    \x03\x12\x04\xf5\x06\x19E\n\x0c\n\x02\x04)\x12\x06\xfc\x06\0\x97\x07\x01\
    \n\x0b\n\x03\x04)\x01\x12\x04\xfc\x06\x08\x15\n\x0b\n\x03\x04)\t\x12\x04\
    \xfd\x06\x02\r\n\x0c\n\x04\x04)\t\0\x12\x04\xfd\x06\x0b\x0c\n\r\n\x05\
    \x04)\t\0\x01\x12\x04\xfd\x06\x0b\x0c\n\r\n\x05\x04)\t\0\x02\x12\x04\xfd\
    \x06\x0b\x0c\n-\n\x04\x04)\x02\0\x12\x04\x80\x07\x02\x10\x1a\x1f\x20The\
    \x20ID\x20for\x20the\x20dataset\x20filter\n\n\r\n\x05\x04)\x02\0\x05\x12\
    \x04\x80\x07\x02\x08\n\r\n\x05\x04)\x02\0\x01\x12\x04\x80\x07\t\x0b\n\r\
    \n\x05\x04)\x02\0\x03\x12\x04\x80\x07\x0e\x0f\n\x93\x01\n\x04\x04)\x02\
    \x01\x12\x04\x85\x07\x02+\x1a\x84\x01\x20When\x20the\x20dataset\x20filte\
    r\x20was\x20created.\n\x20The\x20format\x20is\x20https://www.ietf.org/rf\
    c/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\r\n\
    \x05\x04)\x02\x01\x06\x12\x04\x85\x07\x02\x1b\n\r\n\x05\x04)\x02\x01\x01\
    \x12\x04\x85\x07\x1c&\n\r\n\x05\x04)\x02\x01\x03\x12\x04\x85\x07)*\n\x94\
    \x01\n\x04\x04)\x02\x02\x12\x04\x8a\x07\x02,\x1a\x85\x01\x20When\x20the\
    \x20dataset\x20filter\x20was\x20modified.\n\x20The\x20format\x20is\x20ht\
    tps://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:\
    05.999999Z\".\n\n\r\n\x05\x04)\x02\x02\x06\x12\x04\x8a\x07\x02\x1b\n\r\n\
    \x05\x04)\x02\x02\x01\x12\x04\x8a\x07\x1c'\n\r\n\x05\x04)\x02\x02\x03\
    \x12\x04\x8a\x07*+\n7\n\x04\x04)\x02\x03\x12\x04\x8d\x07\x02\x15\x1a)\
    \x20The\x20user\x20the\x20dataset\x20filter\x20belongs\x20to.\n\n\r\n\
    \x05\x04)\x02\x03\x05\x12\x04\x8d\x07\x02\x08\n\r\n\x05\x04)\x02\x03\x01\
    \x12\x04\x8d\x07\t\x10\n\r\n\x05\x04)\x02\x03\x03\x12\x04\x8d\x07\x13\
    \x14\n6\n\x04\x04)\x02\x04\x12\x04\x90\x07\x02\x14\x1a(\x20The\x20app\
    \x20the\x20dataset\x20filter\x20belongs\x20to.\n\n\r\n\x05\x04)\x02\x04\
    \x05\x12\x04\x90\x07\x02\x08\n\r\n\x05\x04)\x02\x04\x01\x12\x04\x90\x07\
    \t\x0f\n\r\n\x05\x04)\x02\x04\x03\x12\x04\x90\x07\x12\x13\n2\n\x04\x04)\
    \x02\x05\x12\x04\x93\x07\x02\x18\x1a$\x20The\x20dataset\x20the\x20filter\
    \x20belongs\x20to.\n\n\r\n\x05\x04)\x02\x05\x05\x12\x04\x93\x07\x02\x08\
    \n\r\n\x05\x04)\x02\x05\x01\x12\x04\x93\x07\t\x13\n\r\n\x05\x04)\x02\x05\
    \x03\x12\x04\x93\x07\x16\x17\n7\n\x04\x04)\x02\x06\x12\x04\x96\x07\x02\
    \x1a\x1a)\x20The\x20saved\x20search\x20that\x20this\x20filter\x20uses.\n\
    \n\r\n\x05\x04)\x02\x06\x06\x12\x04\x96\x07\x02\x08\n\r\n\x05\x04)\x02\
    \x06\x01\x12\x04\x96\x07\t\x15\n\r\n\x05\x04)\x02\x06\x03\x12\x04\x96\
    \x07\x18\x19\n\x0c\n\x02\x04*\x12\x06\x9a\x07\0\xcd\x07\x01\n\x0b\n\x03\
    \x04*\x01\x12\x04\x9a\x07\x08\x16\n\x0b\n\x03\x04*\t\x12\x04\x9b\x07\x02\
    \r\n\x0c\n\x04\x04*\t\0\x12\x04\x9b\x07\x0b\x0c\n\r\n\x05\x04*\t\0\x01\
    \x12\x04\x9b\x07\x0b\x0c\n\r\n\x05\x04*\t\0\x02\x12\x04\x9b\x07\x0b\x0c\
    \n.\n\x04\x04*\x02\0\x12\x04\x9e\x07\x02\x10\x1a\x20\x20The\x20ID\x20for\
    \x20the\x20dataset\x20version\n\n\r\n\x05\x04*\x02\0\x05\x12\x04\x9e\x07\
    \x02\x08\n\r\n\x05\x04*\x02\0\x01\x12\x04\x9e\x07\t\x0b\n\r\n\x05\x04*\
    \x02\0\x03\x12\x04\x9e\x07\x0e\x0f\n\x94\x01\n\x04\x04*\x02\x01\x12\x04\
    \xa3\x07\x02+\x1a\x85\x01\x20When\x20the\x20dataset\x20version\x20was\
    \x20created.\n\x20The\x20format\x20is\x20https://www.ietf.org/rfc/rfc333\
    9.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\r\n\x05\x04\
    *\x02\x01\x06\x12\x04\xa3\x07\x02\x1b\n\r\n\x05\x04*\x02\x01\x01\x12\x04\
    \xa3\x07\x1c&\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xa3\x07)*\n\x95\x01\n\
    \x04\x04*\x02\x02\x12\x04\xa8\x07\x02,\x1a\x86\x01\x20When\x20the\x20dat\
    aset\x20version\x20was\x20modified.\n\x20The\x20format\x20is\x20https://\
    www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999\
    999Z\".\n\n\r\n\x05\x04*\x02\x02\x06\x12\x04\xa8\x07\x02\x1b\n\r\n\x05\
    \x04*\x02\x02\x01\x12\x04\xa8\x07\x1c'\n\r\n\x05\x04*\x02\x02\x03\x12\
    \x04\xa8\x07*+\n7\n\x04\x04*\x02\x03\x12\x04\xab\x07\x02\x14\x1a)\x20The\
    \x20app\x20the\x20dataset\x20version\x20belongs\x20to.\n\n\r\n\x05\x04*\
    \x02\x03\x05\x12\x04\xab\x07\x02\x08\n\r\n\x05\x04*\x02\x03\x01\x12\x04\
    \xab\x07\t\x0f\n\r\n\x05\x04*\x02\x03\x03\x12\x04\xab\x07\x12\x13\n8\n\
    \x04\x04*\x02\x04\x12\x04\xae\x07\x02\x15\x1a*\x20The\x20user\x20the\x20\
    dataset\x20version\x20belongs\x20to.\n\n\r\n\x05\x04*\x02\x04\x05\x12\
    \x04\xae\x07\x02\x08\n\r\n\x05\x04*\x02\x04\x01\x12\x04\xae\x07\t\x10\n\
    \r\n\x05\x04*\x02\x04\x03\x12\x04\xae\x07\x13\x14\n;\n\x04\x04*\x02\x05\
    \x12\x04\xb1\x07\x02\x18\x1a-\x20The\x20dataset\x20the\x20dataset\x20ver\
    sion\x20belongs\x20to.\n\n\r\n\x05\x04*\x02\x05\x05\x12\x04\xb1\x07\x02\
    \x08\n\r\n\x05\x04*\x02\x05\x01\x12\x04\xb1\x07\t\x13\n\r\n\x05\x04*\x02\
    \x05\x03\x12\x04\xb1\x07\x16\x17\nK\n\x04\x04*\x08\0\x12\x06\xb4\x07\x02\
    \xb7\x07\x03\x1a;\x20Data\x20config\x20reveals\x20how\x20the\x20dataset\
    \x20version\x20is\x20generated.\n\n\r\n\x05\x04*\x08\0\x01\x12\x04\xb4\
    \x07\x08\x13\nW\n\x04\x04*\x02\x06\x12\x04\xb6\x07\x04@\x1aI\x20The\x20d\
    ataset\x20version\x20will\x20be\x20generated\x20based\x20on\x20a\x20sing\
    le\x20dataset\x20filter.\n\n\r\n\x05\x04*\x02\x06\x06\x12\x04\xb6\x07\
    \x04%\n\r\n\x05\x04*\x02\x06\x01\x12\x04\xb6\x07&;\n\r\n\x05\x04*\x02\
    \x06\x03\x12\x04\xb6\x07>?\n0\n\x04\x04*\x02\x07\x12\x04\xba\x07\x02(\
    \x1a\"\x20Status\x20for\x20this\x20dataset\x20version.\n\n\r\n\x05\x04*\
    \x02\x07\x06\x12\x04\xba\x07\x02\x1c\n\r\n\x05\x04*\x02\x07\x01\x12\x04\
    \xba\x07\x1d#\n\r\n\x05\x04*\x02\x07\x03\x12\x04\xba\x07&'\n2\n\x04\x04*\
    \x02\x08\x12\x04\xbd\x07\x02\x1a\x1a$\x20Description\x20of\x20the\x20dat\
    aset\x20version\n\n\r\n\x05\x04*\x02\x08\x05\x12\x04\xbd\x07\x02\x08\n\r\
    \n\x05\x04*\x02\x08\x01\x12\x04\xbd\x07\t\x14\n\r\n\x05\x04*\x02\x08\x03\
    \x12\x04\xbd\x07\x17\x19\n'\n\x04\x04*\x02\t\x12\x04\xc0\x07\x02%\x1a\
    \x19\x20Dataset\x20version\x20summary\n\n\r\n\x05\x04*\x02\t\x06\x12\x04\
    \xc0\x07\x02\x17\n\r\n\x05\x04*\x02\t\x01\x12\x04\xc0\x07\x18\x1f\n\r\n\
    \x05\x04*\x02\t\x03\x12\x04\xc0\x07\"$\n\x9f\x01\n\x04\x04*\x02\n\x12\
    \x04\xc4\x07\x02'\x1a\x90\x01\x20To\x20handle\x20arbitrary\x20json\x20me\
    tadata\x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20https://github\
    .com/google/protobuf/blob/master/src/google/protobuf/struct.proto\n\n\r\
    \n\x05\x04*\x02\n\x06\x12\x04\xc4\x07\x02\x18\n\r\n\x05\x04*\x02\n\x01\
    \x12\x04\xc4\x07\x19!\n\r\n\x05\x04*\x02\n\x03\x12\x04\xc4\x07$&\n\xdd\
    \x01\n\x04\x04*\x02\x0b\x12\x04\xc9\x07\x02\x1d\x1a\xce\x01\x20The\x20vi\
    sibility\x20field\x20represents\x20whether\x20this\x20message\x20is\x20p\
    rivately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20p\
    ublic\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20User\x20t\
    hat\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20vis\
    ible.\n\n\r\n\x05\x04*\x02\x0b\x06\x12\x04\xc9\x07\x02\x0c\n\r\n\x05\x04\
    *\x02\x0b\x01\x12\x04\xc9\x07\r\x17\n\r\n\x05\x04*\x02\x0b\x03\x12\x04\
    \xc9\x07\x1a\x1c\nd\n\x04\x04*\x02\x0c\x12\x04\xcc\x07\x02/\x1aV\x20The\
    \x20embedding\x20models\x20to\x20return\x20embeddings\x20for.\x20If\x20e\
    mpty,\x20no\x20embeddings\x20are\x20returned.\n\n\r\n\x05\x04*\x02\x0c\
    \x04\x12\x04\xcc\x07\x02\n\n\r\n\x05\x04*\x02\x0c\x05\x12\x04\xcc\x07\
    \x0b\x11\n\r\n\x05\x04*\x02\x0c\x01\x12\x04\xcc\x07\x12)\n\r\n\x05\x04*\
    \x02\x0c\x03\x12\x04\xcc\x07,.\n\x0c\n\x02\x04+\x12\x06\xcf\x07\0\xd1\
    \x07\x01\n\x0b\n\x03\x04+\x01\x12\x04\xcf\x07\x08)\n\x0c\n\x04\x04+\x02\
    \0\x12\x04\xd0\x07\x02#\n\r\n\x05\x04+\x02\0\x06\x12\x04\xd0\x07\x02\x0f\
    \n\r\n\x05\x04+\x02\0\x01\x12\x04\xd0\x07\x10\x1e\n\r\n\x05\x04+\x02\0\
    \x03\x12\x04\xd0\x07!\"\n\x0c\n\x02\x04,\x12\x06\xd3\x07\0\xd7\x07\x01\n\
    \x0b\n\x03\x04,\x01\x12\x04\xd3\x07\x08\x1d\n\x9b\x01\n\x04\x04,\x02\0\
    \x12\x04\xd6\x07\x02'\x1a\x8c\x01\x20Counts\x20by\x20different\x20filter\
    s.\x20Each\x20key\x20is\x20the\x20filter\x20key,\n\x20e.g.\x20total_imag\
    e,\x20train_image,\x20test_image,\x20total_video,\x20train_video,\x20tes\
    t_video.\n\n\r\n\x05\x04,\x02\0\x06\x12\x04\xd6\x07\x02\x15\n\r\n\x05\
    \x04,\x02\0\x01\x12\x04\xd6\x07\x16\"\n\r\n\x05\x04,\x02\0\x03\x12\x04\
    \xd6\x07%&\n\x0c\n\x02\x04-\x12\x06\xd9\x07\0\xdd\x07\x01\n\x0b\n\x03\
    \x04-\x01\x12\x04\xd9\x07\x08!\nQ\n\x04\x04-\x02\0\x12\x04\xdb\x07\x02\
    \x18\x1aC\x20The\x20input\x20with\x20the\x20specific\x20data\x20compare\
    \x20against\x20all\x20pool\x20results\n\n\r\n\x05\x04-\x02\0\x06\x12\x04\
    \xdb\x07\x02\x07\n\r\n\x05\x04-\x02\0\x01\x12\x04\xdb\x07\x08\x13\n\r\n\
    \x05\x04-\x02\0\x03\x12\x04\xdb\x07\x16\x17\n\x0c\n\x04\x04-\x02\x01\x12\
    \x04\xdc\x07\x02\x20\n\r\n\x05\x04-\x02\x01\x04\x12\x04\xdc\x07\x02\n\n\
    \r\n\x05\x04-\x02\x01\x06\x12\x04\xdc\x07\x0b\x0e\n\r\n\x05\x04-\x02\x01\
    \x01\x12\x04\xdc\x07\x0f\x1b\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xdc\x07\
    \x1e\x1f\n\xda\x01\n\x02\x04.\x12\x06\xe2\x07\0\xfd\x07\x01\x1a\xcb\x01/\
    ////////////////////////////////////////////////////////////////////////\
    /////\n\x20Messages\x20from\x20/proto/clarifai/api/key.proto\n//////////\
    ////////////////////////////////////////////////////////////////////\n\n\
    \x0b\n\x03\x04.\x01\x12\x04\xe2\x07\x08\x0b\nA\n\x04\x04.\x02\0\x12\x04\
    \xe4\x07\x02\x10\x1a3\x20The\x20id\x20of\x20this\x20key,\x20it\x20is\x20\
    used\x20for\x20authorization.\n\n\r\n\x05\x04.\x02\0\x05\x12\x04\xe4\x07\
    \x02\x08\n\r\n\x05\x04.\x02\0\x01\x12\x04\xe4\x07\t\x0b\n\r\n\x05\x04.\
    \x02\0\x03\x12\x04\xe4\x07\x0e\x0f\ni\n\x04\x04.\x02\x01\x12\x04\xe6\x07\
    \x02\x12\x1a[\x20The\x20type\x20of\x20key,\x20it\x20can\x20be\x20api_key\
    \x20or\x20personal_access_token,\x20the\x20default\x20value\x20is\x20api\
    _key\n\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xe6\x07\x02\x08\n\r\n\x05\x04.\
    \x02\x01\x01\x12\x04\xe6\x07\t\r\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xe6\
    \x07\x10\x11\n\x1f\n\x04\x04.\x02\x02\x12\x04\xe8\x07\x02\x19\x1a\x11\
    \x20The\x20description\n\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xe8\x07\x02\
    \x08\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xe8\x07\t\x14\n\r\n\x05\x04.\x02\
    \x02\x03\x12\x04\xe8\x07\x17\x18\n1\n\x04\x04.\x02\x03\x12\x04\xea\x07\
    \x02\x1d\x1a#\x20The\x20low-level\x20scopes\x20this\x20key\x20has\n\n\r\
    \n\x05\x04.\x02\x03\x04\x12\x04\xea\x07\x02\n\n\r\n\x05\x04.\x02\x03\x05\
    \x12\x04\xea\x07\x0b\x11\n\r\n\x05\x04.\x02\x03\x01\x12\x04\xea\x07\x12\
    \x18\n\r\n\x05\x04.\x02\x03\x03\x12\x04\xea\x07\x1b\x1c\n6\n\x04\x04.\
    \x02\x04\x12\x04\xec\x07\x02\x20\x1a(\x20The\x20endpoint-level\x20scopes\
    \x20this\x20key\x20has\n\n\r\n\x05\x04.\x02\x04\x04\x12\x04\xec\x07\x02\
    \n\n\r\n\x05\x04.\x02\x04\x05\x12\x04\xec\x07\x0b\x11\n\r\n\x05\x04.\x02\
    \x04\x01\x12\x04\xec\x07\x12\x1b\n\r\n\x05\x04.\x02\x04\x03\x12\x04\xec\
    \x07\x1e\x1f\n\x9f\x01\n\x04\x04.\x02\x05\x12\x04\xef\x07\x02\x18\x1a\
    \x90\x01\x20The\x20apps\x20that\x20this\x20key\x20give\x20you\x20access\
    \x20to,\x20it\x20is\x20empty\x20if\x20this\x20key\x20is\x20personal_acce\
    ss_token\n\x20API\x20key\x20can\x20only\x20give\x20you\x20access\x20to\
    \x20a\x20single\x20app.\n\n\r\n\x05\x04.\x02\x05\x04\x12\x04\xef\x07\x02\
    \n\n\r\n\x05\x04.\x02\x05\x06\x12\x04\xef\x07\x0b\x0e\n\r\n\x05\x04.\x02\
    \x05\x01\x12\x04\xef\x07\x0f\x13\n\r\n\x05\x04.\x02\x05\x03\x12\x04\xef\
    \x07\x16\x17\n\xfe\x01\n\x04\x04.\x02\x06\x12\x04\xf6\x07\x02+\x1a\xef\
    \x01\x20When\x20the\x20key\x20was\x20created.\x20We\x20follow\x20the\x20\
    XXXX\x20timestamp\n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/\
    rfc3339.txt\x20format:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\
    \x20can\x20expect\x20results\x20like\n\x20the\x20following\x20from\x20th\
    e\x20API:\n\x20\"2017-04-11T21:50:50.223962Z\"\n\n\r\n\x05\x04.\x02\x06\
    \x06\x12\x04\xf6\x07\x02\x1b\n\r\n\x05\x04.\x02\x06\x01\x12\x04\xf6\x07\
    \x1c&\n\r\n\x05\x04.\x02\x06\x03\x12\x04\xf6\x07)*\nP\n\x04\x04.\x02\x07\
    \x12\x04\xf9\x07\x02+\x1aB\x20When\x20does\x20the\x20key\x20expires,\x20\
    the\x20key\x20won't\x20expire\x20if\x20this\x20is\x20empty\n\n\r\n\x05\
    \x04.\x02\x07\x06\x12\x04\xf9\x07\x02\x1b\n\r\n\x05\x04.\x02\x07\x01\x12\
    \x04\xf9\x07\x1c&\n\r\n\x05\x04.\x02\x07\x03\x12\x04\xf9\x07)*\nD\n\x04\
    \x04.\x02\x08\x12\x04\xfc\x07\x02)\x1a6\x20list\x20of\x20idp\x20ids\x20a\
    t\x20which\x20key\x20is\x20currently\x20authorized\n\n\r\n\x05\x04.\x02\
    \x08\x04\x12\x04\xfc\x07\x02\n\n\r\n\x05\x04.\x02\x08\x05\x12\x04\xfc\
    \x07\x0b\x11\n\r\n\x05\x04.\x02\x08\x01\x12\x04\xfc\x07\x12$\n\r\n\x05\
    \x04.\x02\x08\x03\x12\x04\xfc\x07'(\n\x0c\n\x02\x05\0\x12\x06\x83\x08\0\
    \x88\x08\x01\n\x0b\n\x03\x05\0\x01\x12\x04\x83\x08\x05\x15\n\x0c\n\x04\
    \x05\0\x02\0\x12\x04\x84\x08\x02\x20\n\r\n\x05\x05\0\x02\0\x01\x12\x04\
    \x84\x08\x02\x1b\n\r\n\x05\x05\0\x02\0\x02\x12\x04\x84\x08\x1e\x1f\n?\n\
    \x04\x05\0\x02\x01\x12\x04\x86\x08\x02\x0c\"1\x20Progressively\x20delay\
    \x20the\x20execution\x20of\x20operations\n\n\r\n\x05\x05\0\x02\x01\x01\
    \x12\x04\x86\x08\x02\x07\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x86\x08\n\
    \x0b\n!\n\x04\x05\0\x02\x02\x12\x04\x87\x08\x02\r\"\x13\x20Cease\x20func\
    tioning\n\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\x87\x08\x02\x08\n\r\n\x05\
    \x05\0\x02\x02\x02\x12\x04\x87\x08\x0b\x0c\n\x0c\n\x02\x05\x01\x12\x06\
    \x8a\x08\0\x90\x08\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\x8a\x08\x05\x11\n\
    \x0c\n\x04\x05\x01\x02\0\x12\x04\x8b\x08\x02\x1c\n\r\n\x05\x05\x01\x02\0\
    \x01\x12\x04\x8b\x08\x02\x17\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\x8b\x08\
    \x1a\x1b\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\x8d\x08\x02\x0e\n\r\n\x05\
    \x05\x01\x02\x01\x01\x12\x04\x8d\x08\x02\t\n\r\n\x05\x05\x01\x02\x01\x02\
    \x12\x04\x8d\x08\x0c\r\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\x8e\x08\x02\
    \x0c\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\x8e\x08\x02\x07\n\r\n\x05\x05\
    \x01\x02\x02\x02\x12\x04\x8e\x08\n\x0b\n\x0c\n\x04\x05\x01\x02\x03\x12\
    \x04\x8f\x08\x02\r\n\r\n\x05\x05\x01\x02\x03\x01\x12\x04\x8f\x08\x02\x08\
    \n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\x8f\x08\x0b\x0c\n\xfb\x08\n\x02\
    \x04/\x12\x06\xaa\x08\0\xec\x08\x01\x1a\x9b\x08/////////////////////////\
    /////////////////////////////////////////////////////\n\x20Messages\x20f\
    rom\x20/proto/clarifai/api/model.proto\n////////////////////////////////\
    //////////////////////////////////////////////\n\x20This\x20is\x20the\
    \x20Model\x20object\x20which\x20represents\x20a\x20created\x20model\x20i\
    n\x20the\x20platform.\n\x20Each\x20model\x20has\x20a\x20particular\x20ty\
    pe\x20denoted\x20by\x20the\x20model_type_id.\n\x20When\x20creating\x20a\
    \x20Model\x20with\x20PostModels\x20the\x20following\x20happens:\n\x20\
    \x20-\x20if\x20the\x20ModelType\x20is\x20trainable,\x20then\x20a\x20new\
    \x20ModelVersion\x20is\x20created\x20that\x20is\n\x20\x20\x20\x20-\x20UN\
    TRAINED\x20status\x20by\x20default\n\x20\x20\x20\x20-\x20TRAINED\x20stat\
    us\x20if\x20a\x20ModelVersion\x20was\x20included\x20with\x20PretrainedMo\
    delConfig\x20in\x20PostModels\n\x20\x20-\x20if\x20the\x20ModelType\x20is\
    \x20not\x20trainable,\x20then\x20a\x20new\x20ModelVersion\x20is\x20creat\
    ed\x20with\x20TRAINED\x20status.\n\x20To\x20modify\x20config\x20settings\
    \x20like\x20OutputInfo\x20for\x20the\x20Model\x20you\x20an\x20use\x20Pat\
    chModels.\x20This\x20will\n\x20also\x20create\x20a\x20new\x20ModelVersio\
    n,\x20potentially\x20UNTRAINED\x20following\x20the\x20same\x20rules\x20a\
    s\x20above.\n\x20The\x20fields\x20that\x20are\x20patchable\x20include\
    \x20Model.name,\x20Model.display_name\x20and\x20Model.output_info\n\x20(\
    except\x20the\x20Model.output_info.type\x20and\x20Model.output_info.type\
    _ext).\n\n\n2O//////////////////////////////////////////////////////////\
    ////////////////////\n\n\x0b\n\x03\x04/\x01\x12\x04\xaa\x08\x08\r\n\x0b\
    \n\x03\x04/\t\x12\x04\xab\x08\x02\x14\n\x0c\n\x04\x04/\t\0\x12\x04\xab\
    \x08\x0b\x0c\n\r\n\x05\x04/\t\0\x01\x12\x04\xab\x08\x0b\x0c\n\r\n\x05\
    \x04/\t\0\x02\x12\x04\xab\x08\x0b\x0c\n\x0c\n\x04\x04/\t\x01\x12\x04\xab\
    \x08\x0e\x10\n\r\n\x05\x04/\t\x01\x01\x12\x04\xab\x08\x0e\x10\n\r\n\x05\
    \x04/\t\x01\x02\x12\x04\xab\x08\x0e\x10\n\x0c\n\x04\x04/\t\x02\x12\x04\
    \xab\x08\x11\x13\n\r\n\x05\x04/\t\x02\x01\x12\x04\xab\x08\x11\x13\n\r\n\
    \x05\x04/\t\x02\x02\x12\x04\xab\x08\x11\x13\nX\n\x04\x04/\x02\0\x12\x04\
    \xae\x08\x02\x10\x1aJ\x20The\x20model's\x20ID.\x20Must\x20be\x20unique\
    \x20within\x20a\x20particular\x20app\x20and\x20URL-friendly.\n\n\r\n\x05\
    \x04/\x02\0\x05\x12\x04\xae\x08\x02\x08\n\r\n\x05\x04/\x02\0\x01\x12\x04\
    \xae\x08\t\x0b\n\r\n\x05\x04/\x02\0\x03\x12\x04\xae\x08\x0e\x0f\n[\n\x04\
    \x04/\x02\x01\x12\x04\xb0\x08\x02\x12\x1aM\x20A\x20nicer-to-read\x20name\
    \x20for\x20the\x20model.\x20Can\x20have\x20spaces\x20and\x20special\x20c\
    haracters.\n\n\r\n\x05\x04/\x02\x01\x05\x12\x04\xb0\x08\x02\x08\n\r\n\
    \x05\x04/\x02\x01\x01\x12\x04\xb0\x08\t\r\n\r\n\x05\x04/\x02\x01\x03\x12\
    \x04\xb0\x08\x10\x11\n\x82\x02\n\x04\x04/\x02\x02\x12\x04\xb6\x08\x02+\
    \x1a\xf3\x01\x20When\x20the\x20model\x20was\x20created.\x20We\x20follow\
    \x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\x20https://www.ie\
    tf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15:04:05.999999Z\"\
    \x20so\x20you\x20can\x20expect\x20results\x20like\n\x20\x20the\x20follow\
    ing\x20from\x20the\x20API:\n\x20\x20\"2017-04-11T21:50:50.223962Z\"\n\n\
    \r\n\x05\x04/\x02\x02\x06\x12\x04\xb6\x08\x02\x1b\n\r\n\x05\x04/\x02\x02\
    \x01\x12\x04\xb6\x08\x1c&\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xb6\x08)*\n\
    A\n\x04\x04/\x02\x03\x12\x04\xb8\x08\x02-\x1a3\x20When\x20was\x20the\x20\
    most\x20recent\x20model\x20version\x20created\x20at\n\n\r\n\x05\x04/\x02\
    \x03\x06\x12\x04\xb8\x08\x02\x1b\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xb8\
    \x08\x1c'\n\r\n\x05\x04/\x02\x03\x03\x12\x04\xb8\x08*,\n-\n\x04\x04/\x02\
    \x04\x12\x04\xba\x08\x02C\x1a\x1f\x20The\x20app\x20the\x20model\x20belon\
    gs\x20to.\n\n\r\n\x05\x04/\x02\x04\x05\x12\x04\xba\x08\x02\x08\n\r\n\x05\
    \x04/\x02\x04\x01\x12\x04\xba\x08\t\x0f\n\r\n\x05\x04/\x02\x04\x03\x12\
    \x04\xba\x08\x12\x13\n\r\n\x05\x04/\x02\x04\x08\x12\x04\xba\x08\x14B\n\
    \x10\n\x08\x04/\x02\x04\x08\xd0\x86\x03\x12\x04\xba\x08\x15A\n@\n\x04\
    \x04/\x02\x05\x12\x04\xbc\x08\x02\x1d\x1a2\x20Info\x20about\x20the\x20mo\
    del's\x20output\x20and\x20configuration.\n\n\r\n\x05\x04/\x02\x05\x06\
    \x12\x04\xbc\x08\x02\x0c\n\r\n\x05\x04/\x02\x05\x01\x12\x04\xbc\x08\r\
    \x18\n\r\n\x05\x04/\x02\x05\x03\x12\x04\xbc\x08\x1b\x1c\ni\n\x04\x04/\
    \x02\x06\x12\x04\xbe\x08\x02!\x1a[\x20A\x20particular\x20version\x20of\
    \x20the\x20model,\x20e.g.,\x20to\x20specify\x20the\x20version\x20when\
    \x20creating\x20a\x20workflow.\n\n\r\n\x05\x04/\x02\x06\x06\x12\x04\xbe\
    \x08\x02\x0e\n\r\n\x05\x04/\x02\x06\x01\x12\x04\xbe\x08\x0f\x1c\n\r\n\
    \x05\x04/\x02\x06\x03\x12\x04\xbe\x08\x1f\x20\n\xb7\x01\n\x04\x04/\x02\
    \x07\x12\x04\xc1\x08\x02\x1a\x1a\xa8\x01\x20An\x20even\x20nicer-to-read\
    \x20name\x20for\x20public\x20Clarifai\x20models\x20where\x20we're\x20not\
    \x20happy\x20with\x20the\x20name\x20but\n\x20need\x20a\x20temporary\x20w\
    orkaround\x20while\x20we\x20check\x20what\x20depends\x20on\x20these\x20n\
    ames.\n\n\r\n\x05\x04/\x02\x07\x05\x12\x04\xc1\x08\x02\x08\n\r\n\x05\x04\
    /\x02\x07\x01\x12\x04\xc1\x08\t\x15\n\r\n\x05\x04/\x02\x07\x03\x12\x04\
    \xc1\x08\x18\x19\n6\n\x04\x04/\x02\x08\x12\x04\xc3\x08\x02\x15\x1a(\x20T\
    he\x20user\x20id\x20that\x20the\x20model\x20belongs\x20to.\n\n\r\n\x05\
    \x04/\x02\x08\x05\x12\x04\xc3\x08\x02\x08\n\r\n\x05\x04/\x02\x08\x01\x12\
    \x04\xc3\x08\t\x10\n\r\n\x05\x04/\x02\x08\x03\x12\x04\xc3\x08\x13\x14\nG\
    \n\x04\x04/\x02\t\x12\x04\xc5\x08\x02\x1c\x1a9\x20Info\x20about\x20the\
    \x20models'\x20input\x20and\x20configuration\x20of\x20them.\n\n\r\n\x05\
    \x04/\x02\t\x06\x12\x04\xc5\x08\x02\x0b\n\r\n\x05\x04/\x02\t\x01\x12\x04\
    \xc5\x08\x0c\x16\n\r\n\x05\x04/\x02\t\x03\x12\x04\xc5\x08\x19\x1b\nE\n\
    \x04\x04/\x02\n\x12\x04\xc7\x08\x02\x1c\x1a7\x20Configuration\x20for\x20\
    the\x20training\x20process\x20of\x20this\x20model.\n\n\r\n\x05\x04/\x02\
    \n\x06\x12\x04\xc7\x08\x02\x0b\n\r\n\x05\x04/\x02\n\x01\x12\x04\xc7\x08\
    \x0c\x16\n\r\n\x05\x04/\x02\n\x03\x12\x04\xc7\x08\x19\x1b\n\xa5\x01\n\
    \x04\x04/\x02\x0b\x12\x04\xca\x08\x02\x1c\x1a\x96\x01\x20The\x20ModelTyp\
    e.Id\x20that\x20is\x20used\x20for\x20this\x20model.\x20This\x20is\x20use\
    d\x20for\x20all\x20versions\x20and\x20you\x20cannot\n\x20change\x20model\
    _type_id\x20between\x20versions\x20of\x20the\x20same\x20model.\n\n\r\n\
    \x05\x04/\x02\x0b\x05\x12\x04\xca\x08\x02\x08\n\r\n\x05\x04/\x02\x0b\x01\
    \x12\x04\xca\x08\t\x16\n\r\n\x05\x04/\x02\x0b\x03\x12\x04\xca\x08\x19\
    \x1b\n\xdd\x01\n\x04\x04/\x02\x0c\x12\x04\xcf\x08\x02\x1d\x1a\xce\x01\
    \x20The\x20visibility\x20field\x20represents\x20whether\x20this\x20messa\
    ge\x20is\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\x20t\
    o\x20the\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\
    \x20User\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20pu\
    blicly\x20visible.\n\n\r\n\x05\x04/\x02\x0c\x06\x12\x04\xcf\x08\x02\x0c\
    \n\r\n\x05\x04/\x02\x0c\x01\x12\x04\xcf\x08\r\x17\n\r\n\x05\x04/\x02\x0c\
    \x03\x12\x04\xcf\x08\x1a\x1c\n2\n\x04\x04/\x02\r\x12\x04\xd2\x08\x02\x1a\
    \x1a$\x20Short\x20description\x20about\x20this\x20model\n\n\r\n\x05\x04/\
    \x02\r\x05\x12\x04\xd2\x08\x02\x08\n\r\n\x05\x04/\x02\r\x01\x12\x04\xd2\
    \x08\t\x14\n\r\n\x05\x04/\x02\r\x03\x12\x04\xd2\x08\x17\x19\n\x9f\x01\n\
    \x04\x04/\x02\x0e\x12\x04\xd6\x08\x02'\x1a\x90\x01\x20To\x20handle\x20ar\
    bitrary\x20json\x20metadata\x20you\x20can\x20use\x20a\x20struct\x20field\
    :\n\x20https://github.com/google/protobuf/blob/master/src/google/protobu\
    f/struct.proto\n\n\r\n\x05\x04/\x02\x0e\x06\x12\x04\xd6\x08\x02\x18\n\r\
    \n\x05\x04/\x02\x0e\x01\x12\x04\xd6\x08\x19!\n\r\n\x05\x04/\x02\x0e\x03\
    \x12\x04\xd6\x08$&\nk\n\x04\x04/\x02\x0f\x12\x04\xda\x08\x02\x14\x1a]\
    \x20Notes\x20for\x20the\x20model\n\x20This\x20field\x20should\x20be\x20u\
    sed\x20for\x20in-depth\x20notes\x20and\x20supports\x20up\x20to\x2064Kbs.\
    \n\n\r\n\x05\x04/\x02\x0f\x05\x12\x04\xda\x08\x02\x08\n\r\n\x05\x04/\x02\
    \x0f\x01\x12\x04\xda\x08\t\x0e\n\r\n\x05\x04/\x02\x0f\x03\x12\x04\xda\
    \x08\x11\x13\n+\n\x04\x04/\x02\x10\x12\x04\xdd\x08\x02O\x1a\x1d\x20Tags\
    \x20from\x20toolkits\x20category\n\n\r\n\x05\x04/\x02\x10\x04\x12\x04\
    \xdd\x08\x02\n\n\r\n\x05\x04/\x02\x10\x05\x12\x04\xdd\x08\x0b\x11\n\r\n\
    \x05\x04/\x02\x10\x01\x12\x04\xdd\x08\x12\x1a\n\r\n\x05\x04/\x02\x10\x03\
    \x12\x04\xdd\x08\x1d\x1f\n\r\n\x05\x04/\x02\x10\x08\x12\x04\xdd\x08\x20N\
    \n\x10\n\x08\x04/\x02\x10\x08\xd0\x86\x03\x12\x04\xdd\x08!M\n,\n\x04\x04\
    /\x02\x11\x12\x04\xdf\x08\x02P\x1a\x1e\x20Tags\x20from\x20use_cases\x20c\
    ategory\n\n\r\n\x05\x04/\x02\x11\x04\x12\x04\xdf\x08\x02\n\n\r\n\x05\x04\
    /\x02\x11\x05\x12\x04\xdf\x08\x0b\x11\n\r\n\x05\x04/\x02\x11\x01\x12\x04\
    \xdf\x08\x12\x1b\n\r\n\x05\x04/\x02\x11\x03\x12\x04\xdf\x08\x1e\x20\n\r\
    \n\x05\x04/\x02\x11\x08\x12\x04\xdf\x08!O\n\x10\n\x08\x04/\x02\x11\x08\
    \xd0\x86\x03\x12\x04\xdf\x08\"N\n-\n\x04\x04/\x02\x12\x12\x04\xe1\x08\
    \x02P\x1a\x1f\x20Tags\x20from\x20languages\x20category.\n\n\r\n\x05\x04/\
    \x02\x12\x04\x12\x04\xe1\x08\x02\n\n\r\n\x05\x04/\x02\x12\x05\x12\x04\
    \xe1\x08\x0b\x11\n\r\n\x05\x04/\x02\x12\x01\x12\x04\xe1\x08\x12\x1b\n\r\
    \n\x05\x04/\x02\x12\x03\x12\x04\xe1\x08\x1e\x20\n\r\n\x05\x04/\x02\x12\
    \x08\x12\x04\xe1\x08!O\n\x10\n\x08\x04/\x02\x12\x08\xd0\x86\x03\x12\x04\
    \xe1\x08\"N\n\xa2\x01\n\x04\x04/\x02\x13\x12\x04\xe5\x08\x02\x17\x1a\x93\
    \x01\x20Is\x20starred\x20by\x20the\x20requesting\x20user\x20(only\x20sho\
    wed\x20on\x20get/list\x20requests)\n\x20Please\x20use\x20PostModelStars/\
    DeleteModelStars\x20endpoints\x20to\x20star/unstar\x20a\x20model\n\n\r\n\
    \x05\x04/\x02\x13\x05\x12\x04\xe5\x08\x02\x06\n\r\n\x05\x04/\x02\x13\x01\
    \x12\x04\xe5\x08\x07\x11\n\r\n\x05\x04/\x02\x13\x03\x12\x04\xe5\x08\x14\
    \x16\nv\n\x04\x04/\x02\x14\x12\x04\xe8\x08\x02\x18\x1ah\x20How\x20many\
    \x20users\x20have\x20starred\x20the\x20model\x20(only\x20showed\x20on\
    \x20get/list\x20requests)\n\x20Computed\x20value,\x20not\x20editable\n\n\
    \r\n\x05\x04/\x02\x14\x05\x12\x04\xe8\x08\x02\x07\n\r\n\x05\x04/\x02\x14\
    \x01\x12\x04\xe8\x08\x08\x12\n\r\n\x05\x04/\x02\x14\x03\x12\x04\xe8\x08\
    \x15\x17\nL\n\x04\x04/\x02\x15\x12\x04\xeb\x08\x02\x1e\x1a>\x20Configura\
    tion\x20used\x20to\x20import\x20model\x20from\x20third-party\x20toolkits\
    \n\n\r\n\x05\x04/\x02\x15\x06\x12\x04\xeb\x08\x02\x0c\n\r\n\x05\x04/\x02\
    \x15\x01\x12\x04\xeb\x08\r\x18\n\r\n\x05\x04/\x02\x15\x03\x12\x04\xeb\
    \x08\x1b\x1d\nd\n\x02\x040\x12\x06\xf0\x08\0\x80\t\x01\x1aV\x20A\x20link\
    \x20to\x20a\x20html/markdown/text\x20file\x20that\x20stores\x20reference\
    \x20material\n\x20tied\x20to\x20a\x20model.\n\n\x0b\n\x03\x040\x01\x12\
    \x04\xf0\x08\x08\x16\n#\n\x04\x040\x02\0\x12\x04\xf2\x08\x02\x10\x1a\x15\
    \x20Id\x20of\x20the\x20reference\n\n\r\n\x05\x040\x02\0\x05\x12\x04\xf2\
    \x08\x02\x08\n\r\n\x05\x040\x02\0\x01\x12\x04\xf2\x08\t\x0b\n\r\n\x05\
    \x040\x02\0\x03\x12\x04\xf2\x08\x0e\x0f\nD\n\x04\x040\x02\x01\x12\x04\
    \xf5\x08\x02\x16\x1a6\x20The\x20id\x20of\x20the\x20model\x20this\x20Mode\
    l\x20reference\x20is\x20tied\x20to.\n\n\r\n\x05\x040\x02\x01\x05\x12\x04\
    \xf5\x08\x02\x08\n\r\n\x05\x040\x02\x01\x01\x12\x04\xf5\x08\t\x11\n\r\n\
    \x05\x040\x02\x01\x03\x12\x04\xf5\x08\x14\x15\n#\n\x04\x040\x02\x02\x12\
    \x04\xf8\x08\x02\x11\x1a\x15\x20address\x20of\x20resource\n\n\r\n\x05\
    \x040\x02\x02\x05\x12\x04\xf8\x08\x02\x08\n\r\n\x05\x040\x02\x02\x01\x12\
    \x04\xf8\x08\t\x0c\n\r\n\x05\x040\x02\x02\x03\x12\x04\xf8\x08\x0f\x10\n\
    \x1c\n\x04\x040\x02\x03\x12\x04\xfb\x08\x02\x12\x1a\x0e\x20name\x20of\
    \x20link\n\n\r\n\x05\x040\x02\x03\x05\x12\x04\xfb\x08\x02\x08\n\r\n\x05\
    \x040\x02\x03\x01\x12\x04\xfb\x08\t\r\n\r\n\x05\x040\x02\x03\x03\x12\x04\
    \xfb\x08\x10\x11\n\x83\x01\n\x04\x040\x02\x04\x12\x04\xff\x08\x02&\x1au\
    \x20To\x20handle\x20arbitrary\x20json\x20metadata:\n\x20https://github.c\
    om/google/protobuf/blob/master/src/google/protobuf/struct.proto\n\n\r\n\
    \x05\x040\x02\x04\x06\x12\x04\xff\x08\x02\x18\n\r\n\x05\x040\x02\x04\x01\
    \x12\x04\xff\x08\x19!\n\r\n\x05\x040\x02\x04\x03\x12\x04\xff\x08$%\n\x0c\
    \n\x02\x041\x12\x06\x82\t\0\x8f\t\x01\n\x0b\n\x03\x041\x01\x12\x04\x82\t\
    \x08\x20\n\x1e\n\x04\x041\x02\0\x12\x04\x84\t\x02\x10\x1a\x10\x20user\
    \x20unique\x20id\n\n\r\n\x05\x041\x02\0\x05\x12\x04\x84\t\x02\x08\n\r\n\
    \x05\x041\x02\0\x01\x12\x04\x84\t\t\x0b\n\r\n\x05\x041\x02\0\x03\x12\x04\
    \x84\t\x0e\x0f\n$\n\x04\x041\x02\x01\x12\x04\x86\t\x02\x16\x1a\x16\x20ex\
    ternal\x20id\x20of\x20model\n\n\r\n\x05\x041\x02\x01\x05\x12\x04\x86\t\
    \x02\x08\n\r\n\x05\x041\x02\x01\x01\x12\x04\x86\t\t\x11\n\r\n\x05\x041\
    \x02\x01\x03\x12\x04\x86\t\x14\x15\n,\n\x04\x041\x02\x02\x12\x04\x88\t\
    \x02\x1e\x1a\x1e\x20external\x20id\x20of\x20model\x20version\n\n\r\n\x05\
    \x041\x02\x02\x05\x12\x04\x88\t\x02\x08\n\r\n\x05\x041\x02\x02\x01\x12\
    \x04\x88\t\t\x19\n\r\n\x05\x041\x02\x02\x03\x12\x04\x88\t\x1c\x1d\n8\n\
    \x04\x041\x02\x03\x12\x04\x8a\t\x02\x10\x1a*\x20data\x20to\x20store\x20a\
    s\x20example\x20input\x20for\x20model\n\n\r\n\x05\x041\x02\x03\x06\x12\
    \x04\x8a\t\x02\x06\n\r\n\x05\x041\x02\x03\x01\x12\x04\x8a\t\x07\x0b\n\r\
    \n\x05\x041\x02\x03\x03\x12\x04\x8a\t\x0e\x0f\n(\n\x04\x041\x02\x04\x12\
    \x04\x8c\t\x02\x12\x1a\x1a\x20name\x20of\x20link\x20for\x20display\n\n\r\
    \n\x05\x041\x02\x04\x05\x12\x04\x8c\t\x02\x08\n\r\n\x05\x041\x02\x04\x01\
    \x12\x04\x8c\t\t\r\n\r\n\x05\x041\x02\x04\x03\x12\x04\x8c\t\x10\x11\n,\n\
    \x04\x041\x02\x05\x12\x04\x8e\t\x02\x19\x1a\x1e\x20description\x20of\x20\
    link\x20contents\n\n\r\n\x05\x041\x02\x05\x05\x12\x04\x8e\t\x02\x08\n\r\
    \n\x05\x041\x02\x05\x01\x12\x04\x8e\t\t\x14\n\r\n\x05\x041\x02\x05\x03\
    \x12\x04\x8e\t\x17\x18\n\xb4\x05\n\x02\x042\x12\x06\x99\t\0\xb0\t\x01\
    \x1a\xa5\x05\x20OutputInfo\x20defines\x20some\x20of\x20the\x20settings\
    \x20for\x20each\x20model\x20version\x20that\x20PatchModels\x20can\x20eff\
    ect.\x20These\n\x20parameters\x20control\x20some\x20of\x20the\x20trainin\
    g\x20or\x20inference\x20operations\x20that\x20this\x20model\x20can\x20do\
    .\n\x20As\x20the\x20number\x20of\x20parameters\x20continued\x20to\x20gro\
    w\x20when\x20we\x20launched\x20more\x20ModelTypes\x20we\x20decided\x20to\
    \x20move\n\x20to\x20using\x20the\x20OutputInfo.params\x20field\x20which\
    \x20is\x20a\x20Struct\x20(or\x20JSON\x20object\x20if\x20you're\x20using\
    \n\x20our\x20JSON\x20REST\x20APIs).\x20This\x20allows\x20each\x20ModelTy\
    pe\x20to\x20define\x20the\x20set\x20of\x20fields,\x20their\x20default\
    \x20values\n\x20and\x20description\x20of\x20each\x20field\x20so\x20that\
    \x20we\x20can\x20display\x20those\x20in\x20Portal\x20and\x20make\x20the\
    \x20creation\x20of\n\x20Model's\x20very\x20extensible.\x20The\x20OutputC\
    onfig\x20object\x20will\x20eventually\x20go\x20away\x20in\x20favor\x20of\
    \n\x20infer_params\x20struct.\n\n\x0b\n\x03\x042\x01\x12\x04\x99\t\x08\
    \x12\nL\n\x04\x042\x02\0\x12\x04\x9b\t\x02\x10\x1a>\x20List\x20of\x20con\
    cepts\x20or\x20other\x20output\x20related\x20data\x20for\x20the\x20model\
    .\n\n\r\n\x05\x042\x02\0\x06\x12\x04\x9b\t\x02\x06\n\r\n\x05\x042\x02\0\
    \x01\x12\x04\x9b\t\x07\x0b\n\r\n\x05\x042\x02\0\x03\x12\x04\x9b\t\x0e\
    \x0f\nw\n\x04\x042\x02\x01\x12\x04\x9e\t\x02!\x1ai\x20Model\x20configura\
    tion...going\x20away\x20in\x20favor\x20of\x20infer_params\x20and\x20trai\
    n_params\x20over\x20time.\n\x20TO\x20BE\x20DEPRECATED\n\n\r\n\x05\x042\
    \x02\x01\x06\x12\x04\x9e\t\x02\x0e\n\r\n\x05\x042\x02\x01\x01\x12\x04\
    \x9e\t\x0f\x1c\n\r\n\x05\x042\x02\x01\x03\x12\x04\x9e\t\x1f\x20\nT\n\x04\
    \x042\x02\x02\x12\x04\xa0\t\x02\x15\x1aF\x20For\x20returning\x20where\
    \x20to\x20look\x20for\x20the\x20Output\x20info\x20if\x20not\x20returning\
    \x20it.\n\n\r\n\x05\x042\x02\x02\x05\x12\x04\xa0\t\x02\x08\n\r\n\x05\x04\
    2\x02\x02\x01\x12\x04\xa0\t\t\x10\n\r\n\x05\x042\x02\x02\x03\x12\x04\xa0\
    \t\x13\x14\nd\n\x04\x042\x02\x03\x12\x04\xa3\t\x02\x12\x1aV\x20To\x20hel\
    p\x20clients\x20know\x20what\x20type\x20of\x20Data\x20to\x20expect\x20ou\
    t\x20of\x20the\x20model.\n\x20TO\x20BE\x20DEPRECATED\n\n\r\n\x05\x042\
    \x02\x03\x05\x12\x04\xa3\t\x02\x08\n\r\n\x05\x042\x02\x03\x01\x12\x04\
    \xa3\t\t\r\n\r\n\x05\x042\x02\x03\x03\x12\x04\xa3\t\x10\x11\nE\n\x04\x04\
    2\x02\x04\x12\x04\xa6\t\x02\x16\x1a7\x20Extra\x20metadata\x20about\x20th\
    e\x20Type\x20data.\n\x20TO\x20BE\x20DEPRECATED\n\n\r\n\x05\x042\x02\x04\
    \x05\x12\x04\xa6\t\x02\x08\n\r\n\x05\x042\x02\x04\x01\x12\x04\xa6\t\t\
    \x11\n\r\n\x05\x042\x02\x04\x03\x12\x04\xa6\t\x14\x15\n\xca\x01\n\x04\
    \x042\x02\x05\x12\x04\xaa\t\x02(\x1a\xbb\x01\x20Map\x20from\x20the\x20ap\
    i.Data\x20field\x20names\x20to\x20the\x20underlying\x20model\x20graph's\
    \x20outputs.\x20When\x20using\x20a\n\x20PretrainedModelConfig\x20the\x20\
    values\x20in\x20this\x20map\x20need\x20to\x20match\x20the\x20Triton\x20c\
    onfig.pbtxt\x20output\x20names.\n\n\r\n\x05\x042\x02\x05\x06\x12\x04\xaa\
    \t\x02\x18\n\r\n\x05\x042\x02\x05\x01\x12\x04\xaa\t\x19#\n\r\n\x05\x042\
    \x02\x05\x03\x12\x04\xaa\t&'\n\x84\x02\n\x04\x042\x02\x06\x12\x04\xaf\t\
    \x02$\x1a\xf5\x01\x20For\x20predicting\x20with\x20the\x20various\x20Mode\
    lType's\x20we\x20accept\x20a\x20Struct\x20(JSON\x20object)\x20worth\x20o\
    f\x20args\n\x20that\x20the\x20ModelTypeField\x20defines.\x20During\x20in\
    ference,\x20the\x20settings\x20contained\x20within\x20are\x20sent\n\x20t\
    o\x20the\x20model\x20predictor\x20to\x20alter\x20predictions\x20from\x20\
    this\x20Model.\n\n\r\n\x05\x042\x02\x06\x06\x12\x04\xaf\t\x02\x18\n\r\n\
    \x05\x042\x02\x06\x01\x12\x04\xaf\t\x19\x1f\n\r\n\x05\x042\x02\x06\x03\
    \x12\x04\xaf\t\"#\n\x0c\n\x02\x043\x12\x06\xb4\t\0\xbd\t\x01\n\x0b\n\x03\
    \x043\x01\x12\x04\xb4\t\x08\x11\n\xc8\x01\n\x04\x043\x02\0\x12\x04\xb7\t\
    \x02(\x1a\xb9\x01\x20Map\x20from\x20the\x20api.Data\x20field\x20names\
    \x20to\x20the\x20underlying\x20model\x20graph's\x20inputs.\x20When\x20us\
    ing\x20a\n\x20PretrainedModelConfig\x20the\x20values\x20in\x20this\x20ma\
    p\x20need\x20to\x20match\x20the\x20Triton\x20config.pbtxt\x20input\x20na\
    mes.\n\n\r\n\x05\x043\x02\0\x06\x12\x04\xb7\t\x02\x18\n\r\n\x05\x043\x02\
    \0\x01\x12\x04\xb7\t\x19#\n\r\n\x05\x043\x02\0\x03\x12\x04\xb7\t&'\n\x92\
    \x02\n\x04\x043\x02\x01\x12\x04\xbc\t\x02$\x1a\x83\x02\x20To\x20control\
    \x20the\x20inputs\x20to\x20the\x20given\x20model\x20we\x20allow\x20a\x20\
    list\x20of\x20parameters\n\x20defined\x20for\x20each\x20ModelType\x20as\
    \x20a\x20Struct\x20(JSON\x20object)\x20here.\x20During\x20training\x20or\
    \x20inference,\x20the\n\x20settings\x20contained\x20within\x20are\x20sen\
    t\x20to\x20the\x20training\x20processor\x20to\x20alter\x20the\x20trainin\
    g\x20process.\n\n\r\n\x05\x043\x02\x01\x06\x12\x04\xbc\t\x02\x18\n\r\n\
    \x05\x043\x02\x01\x01\x12\x04\xbc\t\x19\x1f\n\r\n\x05\x043\x02\x01\x03\
    \x12\x04\xbc\t\"#\n\x0c\n\x02\x044\x12\x06\xbf\t\0\xc4\t\x01\n\x0b\n\x03\
    \x044\x01\x12\x04\xbf\t\x08\x11\n\x9b\x02\n\x04\x044\x02\0\x12\x04\xc3\t\
    \x02$\x1a\x8c\x02\x20To\x20control\x20the\x20training\x20process\x20when\
    \x20PostModelVersions\x20is\x20used\x20we\x20allow\x20a\x20list\x20of\
    \x20parameters\n\x20defined\x20for\x20each\x20ModelType\x20as\x20a\x20St\
    ruct\x20(JSON\x20object)\x20here.\x20During\x20training,\x20the\x20setti\
    ngs\n\x20contained\x20within\x20are\x20sent\x20to\x20the\x20training\x20\
    processor\x20to\x20alter\x20the\x20training\x20process.\n\n\r\n\x05\x044\
    \x02\0\x06\x12\x04\xc3\t\x02\x18\n\r\n\x05\x044\x02\0\x01\x12\x04\xc3\t\
    \x19\x1f\n\r\n\x05\x044\x02\0\x03\x12\x04\xc3\t\"#\n\x0c\n\x02\x045\x12\
    \x06\xc6\t\0\xc9\t\x01\n\x0b\n\x03\x045\x01\x12\x04\xc6\t\x08\x12\nJ\n\
    \x04\x045\x02\0\x12\x04\xc8\t\x02$\x1a<\x20Used\x20to\x20configure\x20mo\
    del\x20imports\x20from\x20third-party\x20toolkits.\n\n\r\n\x05\x045\x02\
    \0\x06\x12\x04\xc8\t\x02\x18\n\r\n\x05\x045\x02\0\x01\x12\x04\xc8\t\x19\
    \x1f\n\r\n\x05\x045\x02\0\x03\x12\x04\xc8\t\"#\n\xa1\x02\n\x02\x046\x12\
    \x06\xce\t\0\xfb\t\x01\x1a\x92\x02\x20OutputConfig\x20is\x20a\x20collect\
    ion\x20of\x20parameters\x20controlling\x20either\x20inference\x20or\x20t\
    raining\x20settings\x20for\n\x20the\x20given\x20Model.\x20This\x20messag\
    e\x20will\x20be\x20deprecated\x20over\x20time\x20in\x20favor\x20or\x20in\
    fer_params\x20and\n\x20train_params\x20in\x20OutputInfo\x20which\x20are\
    \x20cleaner\x20and\x20more\x20extensible\x20for\x20many\x20ModelTypes.\n\
    \n\x0b\n\x03\x046\x01\x12\x04\xce\t\x08\x14\n\x0b\n\x03\x046\t\x12\x04\
    \xcf\t\x02\x1a\n\x0c\n\x04\x046\t\0\x12\x04\xcf\t\x0b\r\n\r\n\x05\x046\t\
    \0\x01\x12\x04\xcf\t\x0b\r\n\r\n\x05\x046\t\0\x02\x12\x04\xcf\t\x0b\r\n\
    \x0c\n\x04\x046\t\x01\x12\x04\xcf\t\x0f\x11\n\r\n\x05\x046\t\x01\x01\x12\
    \x04\xcf\t\x0f\x11\n\r\n\x05\x046\t\x01\x02\x12\x04\xcf\t\x0f\x11\n\x0c\
    \n\x04\x046\t\x02\x12\x04\xcf\t\x13\x15\n\r\n\x05\x046\t\x02\x01\x12\x04\
    \xcf\t\x13\x15\n\r\n\x05\x046\t\x02\x02\x12\x04\xcf\t\x13\x15\n\x0c\n\
    \x04\x046\t\x03\x12\x04\xcf\t\x17\x19\n\r\n\x05\x046\t\x03\x01\x12\x04\
    \xcf\t\x17\x19\n\r\n\x05\x046\t\x03\x02\x12\x04\xcf\t\x17\x19\na\n\x04\
    \x046\x02\0\x12\x04\xd2\t\x02V\x1aS\x20For\x20custom\x20concept\x20model\
    \x20training:\x20whether\x20the\x20concept\x20predictions\x20must\x20sum\
    \x20to\x201.\n\n\r\n\x05\x046\x02\0\x05\x12\x04\xd2\t\x02\x06\n\r\n\x05\
    \x046\x02\0\x01\x12\x04\xd2\t\x07\"\n\r\n\x05\x046\x02\0\x03\x12\x04\xd2\
    \t%&\n\r\n\x05\x046\x02\0\x08\x12\x04\xd2\t'U\n\x10\n\x08\x046\x02\0\x08\
    \xd0\x86\x03\x12\x04\xd2\t(T\n\x95\x01\n\x04\x046\x02\x01\x12\x04\xd5\t\
    \x02M\x1a\x86\x01\x20For\x20custom\x20concept\x20model\x20training:\x20W\
    hether\x20negatives\x20should\x20only\x20be\x20sampled\x20from\x20within\
    \x20the\x20app\x20during\n\x20training,\x20for\x20custom\x20models.\n\n\
    \r\n\x05\x046\x02\x01\x05\x12\x04\xd5\t\x02\x06\n\r\n\x05\x046\x02\x01\
    \x01\x12\x04\xd5\t\x07\x19\n\r\n\x05\x046\x02\x01\x03\x12\x04\xd5\t\x1c\
    \x1d\n\r\n\x05\x046\x02\x01\x08\x12\x04\xd5\t\x1eL\n\x10\n\x08\x046\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xd5\t\x1fK\n}\n\x04\x046\x02\x02\x12\x04\
    \xd8\t\x023\x1ao\x20DEPRECATED:\x20For\x20custom\x20models,\x20this\x20i\
    s\x20the\x20base\x20model\x20to\x20use\x20for\x20image\x20embeddings.\n\
    \x20Default\x20is\x20general\x20model.\n\n\r\n\x05\x046\x02\x02\x05\x12\
    \x04\xd8\t\x02\x08\n\r\n\x05\x046\x02\x02\x01\x12\x04\xd8\t\t\x1a\n\r\n\
    \x05\x046\x02\x02\x03\x12\x04\xd8\t\x1d\x1e\n\r\n\x05\x046\x02\x02\x08\
    \x12\x04\xd8\t\x1f2\n\x0e\n\x06\x046\x02\x02\x08\x03\x12\x04\xd8\t\x201\
    \nl\n\x04\x046\x02\x03\x12\x04\xda\t\x02\x16\x1a^\x20For\x20concept\x20m\
    odel\x20predictions:\x20Overrides\x20the\x20default_language\x20for\x20t\
    he\x20app\x20in\x20a\x20predict\x20call.\n\n\r\n\x05\x046\x02\x03\x05\
    \x12\x04\xda\t\x02\x08\n\r\n\x05\x046\x02\x03\x01\x12\x04\xda\t\t\x11\n\
    \r\n\x05\x046\x02\x03\x03\x12\x04\xda\t\x14\x15\nf\n\x04\x046\x02\x04\
    \x12\x04\xdd\t\x022\x1aX\x20DEPRECATED:\x20Hyper-parameters\x20for\x20cu\
    stom\x20training.\n\x20Use\x20new\x20hyper_params\x20field\x20instead.\n\
    \n\r\n\x05\x046\x02\x04\x05\x12\x04\xdd\t\x02\x08\n\r\n\x05\x046\x02\x04\
    \x01\x12\x04\xdd\t\t\x19\n\r\n\x05\x046\x02\x04\x03\x12\x04\xdd\t\x1c\
    \x1d\n\r\n\x05\x046\x02\x04\x08\x12\x04\xdd\t\x1e1\n\x0e\n\x06\x046\x02\
    \x04\x08\x03\x12\x04\xdd\t\x1f0\n\xe2\x01\n\x04\x046\x02\x05\x12\x04\xe1\
    \t\x02I\x1a\xd3\x01\x20For\x20concept\x20model\x20predictions:\x20\x20Ma\
    ximum\x20number\x20of\x20concepts\x20in\x20result.\x20Defaults\x20to\x20\
    0\x20which\x20under\n\x20the\x20hood\x20will\x20return\x20default\x20of\
    \x2020.\x20We\x20do\x20a\x20server\x20side\x20default\x20in\x20order\x20\
    to\x20control\x20this\n\x20feature\x20in\x20the\x20future.\n\n\r\n\x05\
    \x046\x02\x05\x05\x12\x04\xe1\t\x02\x08\n\r\n\x05\x046\x02\x05\x01\x12\
    \x04\xe1\t\t\x15\n\r\n\x05\x046\x02\x05\x03\x12\x04\xe1\t\x18\x19\n\r\n\
    \x05\x046\x02\x05\x08\x12\x04\xe1\t\x1aH\n\x10\n\x08\x046\x02\x05\x08\
    \xd0\x86\x03\x12\x04\xe1\t\x1bG\n\xcd\x01\n\x04\x046\x02\x06\x12\x04\xe5\
    \t\x02E\x1a\xbe\x01\x20For\x20concept\x20model\x20predictions:\x20Minimu\
    m\x20value\x20of\x20concept's\x20probability\x20score\x20in\x20result.\n\
    \x20Defaults\x20to\x200.0\x20which\x20means\x20we\x20won't\x20do\x20any\
    \x20thresholding\x20as\x20all\x20probabilities\x20will\n\x20likely\x20be\
    \x20>\x200.0.\n\n\r\n\x05\x046\x02\x06\x05\x12\x04\xe5\t\x02\x07\n\r\n\
    \x05\x046\x02\x06\x01\x12\x04\xe5\t\x08\x11\n\r\n\x05\x046\x02\x06\x03\
    \x12\x04\xe5\t\x14\x15\n\r\n\x05\x046\x02\x06\x08\x12\x04\xe5\t\x16D\n\
    \x10\n\x08\x046\x02\x06\x08\xd0\x86\x03\x12\x04\xe5\t\x17C\nY\n\x04\x046\
    \x02\x07\x12\x04\xe7\t\x02'\x1aK\x20For\x20concept\x20model\x20predictio\
    ns:\x20Select\x20concepts\x20in\x20result\x20by\x20name\x20or\x20by\x20i\
    d\n\n\r\n\x05\x046\x02\x07\x04\x12\x04\xe7\t\x02\n\n\r\n\x05\x046\x02\
    \x07\x06\x12\x04\xe7\t\x0b\x12\n\r\n\x05\x046\x02\x07\x01\x12\x04\xe7\t\
    \x13\"\n\r\n\x05\x046\x02\x07\x03\x12\x04\xe7\t%&\n]\n\x04\x046\x02\x08\
    \x12\x04\xe9\t\x02\x1e\x1aO\x20For\x20custom\x20concept\x20model\x20trai\
    ning:\x20Training\x20timeout\x20of\x20the\x20model\x20(in\x20seconds)\n\
    \n\r\n\x05\x046\x02\x08\x05\x12\x04\xe9\t\x02\x08\n\r\n\x05\x046\x02\x08\
    \x01\x12\x04\xe9\t\t\x19\n\r\n\x05\x046\x02\x08\x03\x12\x04\xe9\t\x1c\
    \x1d\nn\n\x04\x046\x02\t\x12\x04\xeb\t\x02\x18\x1a`\x20For\x20model\x20p\
    redictions\x20on\x20video:\x20Sample\x20delay\x20for\x20video\x20predict\
    ing\x20(1\x20frame\x20per\x20N\x20milliseconds)\n\n\r\n\x05\x046\x02\t\
    \x05\x12\x04\xeb\t\x02\x08\n\r\n\x05\x046\x02\t\x01\x12\x04\xeb\t\t\x12\
    \n\r\n\x05\x046\x02\t\x03\x12\x04\xeb\t\x15\x17\nN\n\x04\x046\x02\n\x12\
    \x04\xed\t\x02+\x1a@\x20For\x20custom\x20model\x20training:\x20Hyperpara\
    meters\x20for\x20custom\x20training\n\n\r\n\x05\x046\x02\n\x06\x12\x04\
    \xed\t\x02\x18\n\r\n\x05\x046\x02\n\x01\x12\x04\xed\t\x19%\n\r\n\x05\x04\
    6\x02\n\x03\x12\x04\xed\t(*\n\xa4\x01\n\x04\x046\x02\x0b\x12\x04\xf0\t\
    \x02%\x1a\x95\x01\x20For\x20custom\x20model\x20training:\x20this\x20is\
    \x20the\x20base\x20model\x20version\x20to\x20use\x20for\x20image\x20embe\
    ddings.\n\x20This\x20has\x20to\x20be\x20one\x20of\x20the\x20embed\x20mod\
    els\x20in\x20the\x20app\x20workflow.\n\n\r\n\x05\x046\x02\x0b\x05\x12\
    \x04\xf0\t\x02\x08\n\r\n\x05\x046\x02\x0b\x01\x12\x04\xf0\t\t\x1f\n\r\n\
    \x05\x046\x02\x0b\x03\x12\x04\xf0\t\"$\n\x96\x01\n\x04\x046\x02\x0c\x12\
    \x04\xf3\t\x02.\x1a\x87\x01\x20For\x20custom\x20model\x20training:\x20Us\
    e\x20this\x20flag\x20to\x20fail\x20on\x20missing\x20positive\x20examples\
    \n\x20By\x20default\x20we\x20fill\x20in\x20the\x20missing\x20with\x20ran\
    dom\x20examples\n\n\r\n\x05\x046\x02\x0c\x05\x12\x04\xf3\t\x02\x06\n\r\n\
    \x05\x046\x02\x0c\x01\x12\x04\xf3\t\x07(\n\r\n\x05\x046\x02\x0c\x03\x12\
    \x04\xf3\t+-\n\xf0\x03\n\x04\x046\x02\r\x12\x04\xfa\t\x02?\x1a\xe1\x03\
    \x20For\x20custom\x20model\x20training:\x20This\x20is\x20any\x20addition\
    al\x20metadata\x20as\x20a\x20JSON\x20object\x20that\x20we\x20want\n\x20w\
    ant\x20to\x20persist\x20in\x20the\x20model's\x20output\x20config.\x20Thi\
    s\x20is\x20a\x20useful\x20quick\x20way\x20to\x20set\x20fields\x20for\n\
    \x20introducing\x20fields\x20for\x20new\x20model\x20types\x20so\x20we\
    \x20don't\x20have\x20to\x20add\x20a\x20new\x20proto\x20field\x20and\x20D\
    B\x20field\n\x20each\x20time.\x20Please\x20refer\x20to\x20the\x20documen\
    tation\x20or\x20model\x20implementation\x20internally\x20for\x20more\n\
    \x20details\x20on\x20what\x20fields\x20are\x20supported\x20for\x20which\
    \x20models.\n\x20TODO(zeiler):\x20remove\x20this\x20field\x20after\x20Po\
    rtal\x20is\x20updated.\n\n\r\n\x05\x046\x02\r\x06\x12\x04\xfa\t\x02\x18\
    \n\r\n\x05\x046\x02\r\x01\x12\x04\xfa\t\x19'\n\r\n\x05\x046\x02\r\x03\
    \x12\x04\xfa\t*,\n\r\n\x05\x046\x02\r\x08\x12\x04\xfa\t->\n\x0e\n\x06\
    \x046\x02\r\x08\x03\x12\x04\xfa\t.=\n\xe4\x01\n\x02\x047\x12\x06\x82\n\0\
    \xb0\n\x01\x1a\xd5\x01\x20ModelSpec\x20is\x20a\x20definition\x20of\x20a\
    \x20Model\x20type.\x20This\x20is\x20used\x20in\x20model\x20mode\x20of\
    \x20portal\n\x20to\x20list\x20out\x20the\x20possible\x20models\x20that\
    \x20can\x20be\x20created\x20and\x20can\x20be\x20used\x20to\x20understand\
    \x20more\x20about\n\x20the\x20possible\x20models\x20in\x20our\x20platfor\
    m.\n\n\x0b\n\x03\x047\x01\x12\x04\x82\n\x08\x11\n\x0b\n\x03\x047\t\x12\
    \x04\x83\n\x02\r\n\x0c\n\x04\x047\t\0\x12\x04\x83\n\x0b\x0c\n\r\n\x05\
    \x047\t\0\x01\x12\x04\x83\n\x0b\x0c\n\r\n\x05\x047\t\0\x02\x12\x04\x83\n\
    \x0b\x0c\n\xd5\x01\n\x04\x047\x02\0\x12\x04\x87\n\x02\x10\x1a\xc6\x01\
    \x20A\x20unique\x20identifies\x20for\x20this\x20model\x20type.\x20This\
    \x20is\x20differnt\x20than\x20the\x20'type'\x20field\x20below\x20because\
    \n\x20the\x20'type'\x20can\x20be\x20re-used\x20for\x20differnet\x20input\
    \x20and\x20output\x20combinations\x20whereas\x20'id'\x20is\x20always\n\
    \x20unique.\n\n\r\n\x05\x047\x02\0\x05\x12\x04\x87\n\x02\x08\n\r\n\x05\
    \x047\x02\0\x01\x12\x04\x87\n\t\x0b\n\r\n\x05\x047\x02\0\x03\x12\x04\x87\
    \n\x0e\x0f\n5\n\x04\x047\x02\x01\x12\x04\x89\n\x02\x13\x1a'\x20title\x20\
    for\x20this\x20model\x20in\x20model\x20gallery\n\n\r\n\x05\x047\x02\x01\
    \x05\x12\x04\x89\n\x02\x08\n\r\n\x05\x047\x02\x01\x01\x12\x04\x89\n\t\
    \x0e\n\r\n\x05\x047\x02\x01\x03\x12\x04\x89\n\x11\x12\n/\n\x04\x047\x02\
    \x02\x12\x04\x8b\n\x02\x19\x1a!\x20Description\x20of\x20this\x20model\
    \x20type.\n\n\r\n\x05\x047\x02\x02\x05\x12\x04\x8b\n\x02\x08\n\r\n\x05\
    \x047\x02\x02\x01\x12\x04\x8b\n\t\x14\n\r\n\x05\x047\x02\x02\x03\x12\x04\
    \x8b\n\x17\x18\n^\n\x04\x047\x02\x03\x12\x04\x8d\n\x02\x12\x1aP\x20The\
    \x20type\x20of\x20the\x20model\x20to\x20create.\x20This\x20is\x20current\
    ly\x20stored\x20in\x20output_info.type.\n\n\r\n\x05\x047\x02\x03\x05\x12\
    \x04\x8d\n\x02\x08\n\r\n\x05\x047\x02\x03\x01\x12\x04\x8d\n\t\r\n\r\n\
    \x05\x047\x02\x03\x03\x12\x04\x8d\n\x10\x11\ny\n\x04\x047\x02\x04\x12\
    \x04\x90\n\x02#\x1ak\x20The\x20list\x20of\x20input\x20fields\x20that\x20\
    this\x20model\x20accepts.\x20These\x20are\x20the\x20keys\x20of\x20the\
    \x20Model's\n\x20InputInfo.fields_map\n\n\r\n\x05\x047\x02\x04\x04\x12\
    \x04\x90\n\x02\n\n\r\n\x05\x047\x02\x04\x05\x12\x04\x90\n\x0b\x11\n\r\n\
    \x05\x047\x02\x04\x01\x12\x04\x90\n\x12\x1e\n\r\n\x05\x047\x02\x04\x03\
    \x12\x04\x90\n!\"\n{\n\x04\x047\x02\x05\x12\x04\x93\n\x02$\x1am\x20The\
    \x20list\x20of\x20output\x20fields\x20that\x20this\x20model\x20accepts.\
    \x20These\x20are\x20the\x20keys\x20of\x20the\x20Model's\n\x20OutputInfo.\
    fields_map\n\n\r\n\x05\x047\x02\x05\x04\x12\x04\x93\n\x02\n\n\r\n\x05\
    \x047\x02\x05\x05\x12\x04\x93\n\x0b\x11\n\r\n\x05\x047\x02\x05\x01\x12\
    \x04\x93\n\x12\x1f\n\r\n\x05\x047\x02\x05\x03\x12\x04\x93\n\"#\n8\n\x04\
    \x047\x02\x06\x12\x04\x95\n\x02\x15\x1a*\x20Is\x20this\x20model\x20train\
    able\x20in\x20our\x20platform.\n\n\r\n\x05\x047\x02\x06\x05\x12\x04\x95\
    \n\x02\x06\n\r\n\x05\x047\x02\x06\x01\x12\x04\x95\n\x07\x10\n\r\n\x05\
    \x047\x02\x06\x03\x12\x04\x95\n\x13\x14\nz\n\x04\x047\x02\x07\x12\x04\
    \x98\n\x02\x15\x1al\x20Is\x20this\x20model\x20creatable.\x20We\x20have\
    \x20some\x20pre-trained\x20model\x20types\x20that\x20users\x20cannot\x20\
    create\x20yet\x20in\n\x20model\x20mode.\n\n\r\n\x05\x047\x02\x07\x05\x12\
    \x04\x98\n\x02\x06\n\r\n\x05\x047\x02\x07\x01\x12\x04\x98\n\x07\x10\n\r\
    \n\x05\x047\x02\x07\x03\x12\x04\x98\n\x13\x14\nH\n\x04\x047\x02\x08\x12\
    \x04\x9a\n\x02\x1a\x1a:\x20Is\x20this\x20model\x20type\x20only\x20for\
    \x20internal\x20users\x20at\x20this\x20time.\n\n\r\n\x05\x047\x02\x08\
    \x05\x12\x04\x9a\n\x02\x06\n\r\n\x05\x047\x02\x08\x01\x12\x04\x9a\n\x07\
    \x14\n\r\n\x05\x047\x02\x08\x03\x12\x04\x9a\n\x17\x19\n\x8d\x03\n\x04\
    \x047\x02\t\x12\x04\xa1\n\x021\x1a\xfe\x02\x20The\x20remaining\x20fields\
    \x20are\x20definitions\x20of\x20the\x20configurable\x20fields\x20that\
    \x20exist.\n\x20Each\x20field\x20has\x20path\x20into\x20the\x20Model\x20\
    object\x20such\x20as\x20\"name\"\x20as\x20a\x20top\x20level\x20or\x20\"o\
    utput_info.data\"\n\x20if\x20it's\x20the\x20Data\x20object\x20within\x20\
    the\x20OutputInfo\x20object.\x20We\x20decided\x20to\x20not\x20break\x20t\
    hese\x20up\n\x20into\x20input_info,\x20train_info\x20and\x20output_info\
    \x20related\x20parameters\x20and\x20instead\x20use\x20the\x20path\n\x20s\
    o\x20that\x20they\x20are\x20most\x20flexible.\n\n\r\n\x05\x047\x02\t\x04\
    \x12\x04\xa1\n\x02\n\n\r\n\x05\x047\x02\t\x06\x12\x04\xa1\n\x0b\x19\n\r\
    \n\x05\x047\x02\t\x01\x12\x04\xa1\n\x1a+\n\r\n\x05\x047\x02\t\x03\x12\
    \x04\xa1\n.0\n\xc0\x01\n\x04\x047\x02\n\x12\x04\xa5\n\x02'\x1a\xb1\x01\
    \x20For\x20sequence\x20models\x20we\x20need\x20to\x20know\x20when\x20pro\
    cessing\x20that\x20they\x20require\x20temporal\x20time\x20frames\n\x20in\
    \x20sequential\x20order.\x20This\x20will\x20be\x20true\x20for\x20model\
    \x20types\x20like\x20trackers\x20as\x20an\x20example.\n\n\r\n\x05\x047\
    \x02\n\x05\x12\x04\xa5\n\x02\x06\n\r\n\x05\x047\x02\n\x01\x12\x04\xa5\n\
    \x07!\n\r\n\x05\x047\x02\n\x03\x12\x04\xa5\n$&\n,\n\x04\x047\x02\x0b\x12\
    \x04\xa8\n\x02\x16\x1a\x1e\x20Can\x20this\x20model\x20be\x20evaluated?\n\
    \n\r\n\x05\x047\x02\x0b\x05\x12\x04\xa8\n\x02\x06\n\r\n\x05\x047\x02\x0b\
    \x01\x12\x04\xa8\n\x07\x10\n\r\n\x05\x047\x02\x0b\x03\x12\x04\xa8\n\x13\
    \x15\ni\n\x04\x047\x02\x0c\x12\x04\xac\n\x02?\x1a[\x20Maps\x20input_fiel\
    ds\x20to\x20the\x20more\x20granular\x20data\x20fields\x20needed\x20to\
    \x20parse\x20a\x20triton\x20models\x20inputs\n\n\r\n\x05\x047\x02\x0c\
    \x06\x12\x04\xac\n\x02\x18\n\r\n\x05\x047\x02\x0c\x01\x12\x04\xac\n\x199\
    \n\r\n\x05\x047\x02\x0c\x03\x12\x04\xac\n<>\nk\n\x04\x047\x02\r\x12\x04\
    \xaf\n\x02@\x1a]\x20Maps\x20output_fields\x20to\x20the\x20more\x20granul\
    ar\x20data\x20fields\x20needed\x20to\x20parse\x20a\x20triton\x20models\
    \x20outputs\n\n\r\n\x05\x047\x02\r\x06\x12\x04\xaf\n\x02\x18\n\r\n\x05\
    \x047\x02\r\x01\x12\x04\xaf\n\x19:\n\r\n\x05\x047\x02\r\x03\x12\x04\xaf\
    \n=?\nK\n\x02\x048\x12\x06\xb3\n\0\xf1\n\x01\x1a=\x20ModelTypeField\x20s\
    tores\x20a\x20field\x20value\x20of\x20a\x20configurable\x20type.\n\n\x0b\
    \n\x03\x048\x01\x12\x04\xb3\n\x08\x16\n\xbb\x03\n\x04\x048\x02\0\x12\x04\
    \xbc\n\x02\x12\x1a\xac\x03\x20The\x20path\x20where\x20the\x20value\x20of\
    \x20the\x20field\x20will\x20be\x20stored.\n\x20Example:\n\x20\"output_in\
    fo.data\"\x20would\x20be\x20the\x20Data\x20message\x20in\x20the\x20Outpu\
    tInfo\x20message.\n\x20\"output_info.output_config.language\"\x20is\x20i\
    n\x20the\x20OutputConfig\x20message\x20within\x20OutputInfo\n\x20\"input\
    _info.params\"\x20is\x20in\x20the\x20params\x20struct\x20within\x20Input\
    Info.\n\x20\"output_info.params\"\x20is\x20in\x20the\x20params\x20struct\
    \x20within\x20OutputInfo.\n\x20\"train_info.params\"\x20is\x20in\x20the\
    \x20params\x20struct\x20within\x20TrainInfo.\n\x20and\x20so\x20on.\n\n\r\
    \n\x05\x048\x02\0\x05\x12\x04\xbc\n\x02\x08\n\r\n\x05\x048\x02\0\x01\x12\
    \x04\xbc\n\t\r\n\r\n\x05\x048\x02\0\x03\x12\x04\xbc\n\x10\x11\nI\n\x04\
    \x048\x04\0\x12\x06\xbe\n\x02\xdd\n\x03\x1a9\x20These\x20are\x20various\
    \x20types\x20of\x20fields\x20that\x20we\x20have\x20UIs\x20for.\n\n\r\n\
    \x05\x048\x04\0\x01\x12\x04\xbe\n\x07\x19\n\r\n\x05\x048\x04\0\t\x12\x04\
    \xbf\n\x04\x0f\n\x0e\n\x06\x048\x04\0\t\0\x12\x04\xbf\n\r\x0e\n\x0f\n\
    \x07\x048\x04\0\t\0\x01\x12\x04\xbf\n\r\x0e\n\x0f\n\x07\x048\x04\0\t\0\
    \x02\x12\x04\xbf\n\r\x0e\n\x0e\n\x06\x048\x04\0\x02\0\x12\x04\xc1\n\x04&\
    \n\x0f\n\x07\x048\x04\0\x02\0\x01\x12\x04\xc1\n\x04!\n\x0f\n\x07\x048\
    \x04\0\x02\0\x02\x12\x04\xc1\n$%\n\x0e\n\x06\x048\x04\0\x02\x01\x12\x04\
    \xc3\n\x04\x10\n\x0f\n\x07\x048\x04\0\x02\x01\x01\x12\x04\xc3\n\x04\x0b\
    \n\x0f\n\x07\x048\x04\0\x02\x01\x02\x12\x04\xc3\n\x0e\x0f\n\x0e\n\x06\
    \x048\x04\0\x02\x02\x12\x04\xc4\n\x04\x0f\n\x0f\n\x07\x048\x04\0\x02\x02\
    \x01\x12\x04\xc4\n\x04\n\n\x0f\n\x07\x048\x04\0\x02\x02\x02\x12\x04\xc4\
    \n\r\x0e\n\x0e\n\x06\x048\x04\0\x02\x03\x12\x04\xc5\n\x04\x0f\n\x0f\n\
    \x07\x048\x04\0\x02\x03\x01\x12\x04\xc5\n\x04\n\n\x0f\n\x07\x048\x04\0\
    \x02\x03\x02\x12\x04\xc5\n\r\x0e\nd\n\x06\x048\x04\0\x02\x04\x12\x04\xc7\
    \n\x04\x1a\x1aT\x20For\x20auto-completing\x20to\x20concepts\x20in\x20the\
    \x20app.\x20This\x20goes\x20into\x20an\x20data.concepts\x20field.\n\n\
    \x0f\n\x07\x048\x04\0\x02\x04\x01\x12\x04\xc7\n\x04\x15\n\x0f\n\x07\x048\
    \x04\0\x02\x04\x02\x12\x04\xc7\n\x18\x19\nd\n\x06\x048\x04\0\x02\x05\x12\
    \x04\xc9\n\x04)\x1aT\x20For\x20auto-completing\x20to\x20concepts\x20in\
    \x20the\x20app.\x20This\x20goes\x20into\x20an\x20data.concepts\x20field.\
    \n\n\x0f\n\x07\x048\x04\0\x02\x05\x01\x12\x04\xc9\n\x04$\n\x0f\n\x07\x04\
    8\x04\0\x02\x05\x02\x12\x04\xc9\n'(\n,\n\x06\x048\x04\0\x02\x06\x12\x04\
    \xcb\n\x04\x0e\x1a\x1c\x20A\x20range\x20for\x20a\x20float\x20value.\n\n\
    \x0f\n\x07\x048\x04\0\x02\x06\x01\x12\x04\xcb\n\x04\t\n\x0f\n\x07\x048\
    \x04\0\x02\x06\x02\x12\x04\xcb\n\x0c\r\n\xa1\x01\n\x06\x048\x04\0\x02\
    \x07\x12\x04\xce\n\x04\r\x1a\x90\x01\x20If\x20ENUM\x20is\x20used\x20then\
    \x20the\x20\"enum_options\"\x20field\x20should\x20also\x20be\x20filled\
    \x20in\x20with\x20the\x20respective\x20ID\x20and\x20description\n\x20for\
    \x20the\x20different\x20ENUM\x20options.\n\n\x0f\n\x07\x048\x04\0\x02\
    \x07\x01\x12\x04\xce\n\x04\x08\n\x0f\n\x07\x048\x04\0\x02\x07\x02\x12\
    \x04\xce\n\x0b\x0c\nl\n\x06\x048\x04\0\x02\x08\x12\x04\xd0\n\x04\x16\x1a\
    \\\x20For\x20listing\x20collaborators\x20of\x20the\x20app.\x20The\x20fie\
    ld\x20is\x20a\x20string\x20of\x20the\x20collaborator's\x20user_id.\n\n\
    \x0f\n\x07\x048\x04\0\x02\x08\x01\x12\x04\xd0\n\x04\x11\n\x0f\n\x07\x048\
    \x04\0\x02\x08\x02\x12\x04\xd0\n\x14\x15\n4\n\x06\x048\x04\0\x02\t\x12\
    \x04\xd2\n\x04\x0e\x1a$\x20For\x20arbitrary\x20json\x20object:\x20\"{...\
    }\"\n\n\x0f\n\x07\x048\x04\0\x02\t\x01\x12\x04\xd2\n\x04\x08\n\x0f\n\x07\
    \x048\x04\0\x02\t\x02\x12\x04\xd2\n\x0b\r\n)\n\x06\x048\x04\0\x02\n\x12\
    \x04\xd4\n\x04\x1a\x1a\x19\x20Such\x20as\x20[1.0,\x202.0,\x203.5]\n\n\
    \x0f\n\x07\x048\x04\0\x02\n\x01\x12\x04\xd4\n\x04\x14\n\x0f\n\x07\x048\
    \x04\0\x02\n\x02\x12\x04\xd4\n\x17\x19\n\x7f\n\x06\x048\x04\0\x02\x0b\
    \x12\x04\xd7\n\x04\x1f\x1ao\x20For\x20selecting\x20the\x20embed_model_ve\
    rsion_id\x20for\x20context\x20based\x20models.\n\x20This\x20is\x20a\x20s\
    tring\x20type\x20in\x20the\x20API\x20request.\n\n\x0f\n\x07\x048\x04\0\
    \x02\x0b\x01\x12\x04\xd7\n\x04\x19\n\x0f\n\x07\x048\x04\0\x02\x0b\x02\
    \x12\x04\xd7\n\x1c\x1e\n2\n\x06\x048\x04\0\x02\x0c\x12\x04\xd9\n\x04\x1a\
    \x1a\"\x20Such\x20as\x20['a',\x20'b',\x20'cantaloupe']\n\n\x0f\n\x07\x04\
    8\x04\0\x02\x0c\x01\x12\x04\xd9\n\x04\x14\n\x0f\n\x07\x048\x04\0\x02\x0c\
    \x02\x12\x04\xd9\n\x17\x19\n\xe8\x01\n\x06\x048\x04\0\x02\r\x12\x04\xdc\
    \n\x04\x18\x1a\xd7\x01\x20If\x20RECURSIVE_ENUM\x20is\x20used\x20then\x20\
    the\x20\"enum_options\"\x20field\x20should\x20also\x20be\x20filled\x20in\
    \x20with\x20the\x20respective\x20ID\x20and\x20description\n\x20for\x20th\
    e\x20different\x20RECURSIVE_ENUM\x20options,\x20as\x20well\x20as\x20mode\
    l_type_fields\x20for\x20each\x20enum\x20choice.\n\n\x0f\n\x07\x048\x04\0\
    \x02\r\x01\x12\x04\xdc\n\x04\x12\n\x0f\n\x07\x048\x04\0\x02\r\x02\x12\
    \x04\xdc\n\x15\x17\n)\n\x04\x048\x02\x01\x12\x04\xdf\n\x02$\x1a\x1b\x20T\
    he\x20field\x20for\x20this\x20field.\n\n\r\n\x05\x048\x02\x01\x06\x12\
    \x04\xdf\n\x02\x14\n\r\n\x05\x048\x02\x01\x01\x12\x04\xdf\n\x15\x1f\n\r\
    \n\x05\x048\x02\x01\x03\x12\x04\xdf\n\"#\n\xa5\x01\n\x04\x048\x02\x02\
    \x12\x04\xe2\n\x02*\x1a\x96\x01\x20A\x20default\x20value.\x20We\x20use\
    \x20the\x20Value\x20field\x20because\x20we\x20want\x20to\x20have\x20stru\
    ctured\x20data\x20(just\x20like\n\x20google.protobuf.Struct\x20but\x20th\
    is\x20is\x20just\x20a\x20single\x20value).\n\n\r\n\x05\x048\x02\x02\x06\
    \x12\x04\xe2\n\x02\x17\n\r\n\x05\x048\x02\x02\x01\x12\x04\xe2\n\x18%\n\r\
    \n\x05\x048\x02\x02\x03\x12\x04\xe2\n()\n+\n\x04\x048\x02\x03\x12\x04\
    \xe4\n\x02\x19\x1a\x1d\x20Description\x20for\x20this\x20field.\n\n\r\n\
    \x05\x048\x02\x03\x05\x12\x04\xe4\n\x02\x08\n\r\n\x05\x048\x02\x03\x01\
    \x12\x04\xe4\n\t\x14\n\r\n\x05\x048\x02\x03\x03\x12\x04\xe4\n\x17\x18\n4\
    \n\x04\x048\x02\x04\x12\x04\xe6\n\x02\x19\x1a&\x20Placeholder\x20text\
    \x20for\x20the\x20UI\x20element.\n\n\r\n\x05\x048\x02\x04\x05\x12\x04\
    \xe6\n\x02\x08\n\r\n\x05\x048\x02\x04\x01\x12\x04\xe6\n\t\x14\n\r\n\x05\
    \x048\x02\x04\x03\x12\x04\xe6\n\x17\x18\nh\n\x04\x048\x02\x05\x12\x04\
    \xe8\n\x02;\x1aZ\x20List\x20of\x20options\x20of\x20the\x20ENUM\x20type\
    \x20and\x20potentially\x20additional\x20fields\x20they\x20bring\x20with\
    \x20them.\n\n\r\n\x05\x048\x02\x05\x04\x12\x04\xe8\n\x02\n\n\r\n\x05\x04\
    8\x02\x05\x06\x12\x04\xe8\n\x0b\x1e\n\r\n\x05\x048\x02\x05\x01\x12\x04\
    \xe8\n\x1f6\n\r\n\x05\x048\x02\x05\x03\x12\x04\xe8\n9:\nD\n\x04\x048\x02\
    \x06\x12\x04\xea\n\x02\x19\x1a6\x20If\x20this\x20field\x20should\x20appe\
    ar\x20for\x20internal\x20users\x20only.\n\n\r\n\x05\x048\x02\x06\x05\x12\
    \x04\xea\n\x02\x06\n\r\n\x05\x048\x02\x06\x01\x12\x04\xea\n\x07\x14\n\r\
    \n\x05\x048\x02\x06\x03\x12\x04\xea\n\x17\x18\n\xf3\x01\n\x04\x048\x02\
    \x07\x12\x04\xee\n\x02\x14\x1a\xe4\x01\x20If\x20this\x20field\x20is\x20a\
    \x20required\x20field.\x20If\x20True\x20then\x20during\x20validation\x20\
    you\x20won't\x20be\x20able\x20to\x20create\n\x20a\x20model\x20of\x20this\
    \x20type\x20with\x20providing\x20a\x20value\x20for\x20this\x20field.\x20\
    When\x20False,\x20the\x20ModelType's\n\x20default_value\x20will\x20be\
    \x20used\x20for\x20this\x20field.\n\n\r\n\x05\x048\x02\x07\x05\x12\x04\
    \xee\n\x02\x06\n\r\n\x05\x048\x02\x07\x01\x12\x04\xee\n\x07\x0f\n\r\n\
    \x05\x048\x02\x07\x03\x12\x04\xee\n\x12\x13\nC\n\x04\x048\x02\x08\x12\
    \x04\xf0\n\x02/\x1a5\x20If\x20the\x20field_type\x20is\x20RANGE,\x20this\
    \x20must\x20be\x20filled\x20in.\n\n\r\n\x05\x048\x02\x08\x06\x12\x04\xf0\
    \n\x02\x14\n\r\n\x05\x048\x02\x08\x01\x12\x04\xf0\n\x15*\n\r\n\x05\x048\
    \x02\x08\x03\x12\x04\xf0\n-.\n\x0c\n\x02\x049\x12\x06\xf3\n\0\xfb\n\x01\
    \n\x0b\n\x03\x049\x01\x12\x04\xf3\n\x08\x1a\n2\n\x04\x049\x02\0\x12\x04\
    \xf5\n\x02\x10\x1a$\x20The\x20start\x20of\x20the\x20range\x20as\x20a\x20\
    float.\n\n\r\n\x05\x049\x02\0\x05\x12\x04\xf5\n\x02\x07\n\r\n\x05\x049\
    \x02\0\x01\x12\x04\xf5\n\x08\x0b\n\r\n\x05\x049\x02\0\x03\x12\x04\xf5\n\
    \x0e\x0f\n0\n\x04\x049\x02\x01\x12\x04\xf7\n\x02\x10\x1a\"\x20The\x20end\
    \x20of\x20the\x20range\x20as\x20a\x20float.\n\n\r\n\x05\x049\x02\x01\x05\
    \x12\x04\xf7\n\x02\x07\n\r\n\x05\x049\x02\x01\x01\x12\x04\xf7\n\x08\x0b\
    \n\r\n\x05\x049\x02\x01\x03\x12\x04\xf7\n\x0e\x0f\n\xb5\x01\n\x04\x049\
    \x02\x02\x12\x04\xfa\n\x02\x11\x1a\xa6\x01\x20An\x20optional\x20step\x20\
    size\x20for\x20the\x20range.\x20If\x20provided\x20then\x20only\x20values\
    \x20at\x20that\x20step\x20size\x20will\x20be\n\x20rounded\x20to.\x20For\
    \x20example\x20if\x20step\x20is\x200.02\x20then\x200.0245\x20will\x20rou\
    nd\x20to\x200.02.\n\n\r\n\x05\x049\x02\x02\x05\x12\x04\xfa\n\x02\x07\n\r\
    \n\x05\x049\x02\x02\x01\x12\x04\xfa\n\x08\x0c\n\r\n\x05\x049\x02\x02\x03\
    \x12\x04\xfa\n\x0f\x10\n\x0c\n\x02\x04:\x12\x06\xfd\n\0\x89\x0b\x01\n\
    \x0b\n\x03\x04:\x01\x12\x04\xfd\n\x08\x1b\n4\n\x04\x04:\x02\0\x12\x04\
    \xff\n\x02\x10\x1a&\x20The\x20unique\x20value\x20of\x20the\x20enum\x20op\
    tion.\n\n\r\n\x05\x04:\x02\0\x05\x12\x04\xff\n\x02\x08\n\r\n\x05\x04:\
    \x02\0\x01\x12\x04\xff\n\t\x0b\n\r\n\x05\x04:\x02\0\x03\x12\x04\xff\n\
    \x0e\x0f\n:\n\x04\x04:\x02\x01\x12\x04\x82\x0b\x02\x19\x1a,\x20Optional\
    \x20description\x20for\x20this\x20enum\x20option.\n\n\r\n\x05\x04:\x02\
    \x01\x05\x12\x04\x82\x0b\x02\x08\n\r\n\x05\x04:\x02\x01\x01\x12\x04\x82\
    \x0b\t\x14\n\r\n\x05\x04:\x02\x01\x03\x12\x04\x82\x0b\x17\x18\n\x9b\x01\
    \n\x04\x04:\x02\x02\x12\x04\x85\x0b\x020\x1a\x8c\x01\x20These\x20are\x20\
    additional\x20fields\x20that\x20are\x20specific\x20to\x20this\x20enum\
    \x20choice.\x20This\x20allows\n\x20us\x20to\x20use\x20enums\x20to\x20con\
    trol\x20configuration\x20settings\x20as\x20well.\n\n\r\n\x05\x04:\x02\
    \x02\x04\x12\x04\x85\x0b\x02\n\n\r\n\x05\x04:\x02\x02\x06\x12\x04\x85\
    \x0b\x0b\x19\n\r\n\x05\x04:\x02\x02\x01\x12\x04\x85\x0b\x1a+\n\r\n\x05\
    \x04:\x02\x02\x03\x12\x04\x85\x0b./\n<\n\x04\x04:\x02\x03\x12\x04\x88\
    \x0b\x02\x19\x1a.\x20If\x20this\x20enum\x20option\x20should\x20be\x20int\
    ernal\x20only.\n\n\r\n\x05\x04:\x02\x03\x05\x12\x04\x88\x0b\x02\x06\n\r\
    \n\x05\x04:\x02\x03\x01\x12\x04\x88\x0b\x07\x14\n\r\n\x05\x04:\x02\x03\
    \x03\x12\x04\x88\x0b\x17\x18\n\x0c\n\x02\x04;\x12\x06\x8b\x0b\0\x93\x0b\
    \x01\n\x0b\n\x03\x04;\x01\x12\x04\x8b\x0b\x08\x12\nq\n\x04\x04;\x02\0\
    \x12\x04\x8d\x0b\x02\x12\x1ac\x20The\x20name\x20ofthe\x20field.\x20This\
    \x20supports\x20wilcard\x20queries\x20like\x20\"gen*\"\x20to\x20match\
    \x20\"general\"\x20as\x20an\x20example.\n\n\r\n\x05\x04;\x02\0\x05\x12\
    \x04\x8d\x0b\x02\x08\n\r\n\x05\x04;\x02\0\x01\x12\x04\x8d\x0b\t\r\n\r\n\
    \x05\x04;\x02\0\x03\x12\x04\x8d\x0b\x10\x11\nd\n\x04\x04;\x02\x01\x12\
    \x04\x8f\x0b\x02&\x1aV\x20This\x20is\x20the\x20legacy\x20model\x20type.\
    \x20Do\x20not\x20use,\x20only\x20kept\x20for\x20support\x20in\x20old\x20\
    API\x20clients.\n\n\r\n\x05\x04;\x02\x01\x05\x12\x04\x8f\x0b\x02\x08\n\r\
    \n\x05\x04;\x02\x01\x01\x12\x04\x8f\x0b\t\r\n\r\n\x05\x04;\x02\x01\x03\
    \x12\x04\x8f\x0b\x10\x11\n\r\n\x05\x04;\x02\x01\x08\x12\x04\x8f\x0b\x12%\
    \n\x0e\n\x06\x04;\x02\x01\x08\x03\x12\x04\x8f\x0b\x13$\nz\n\x04\x04;\x02\
    \x02\x12\x04\x92\x0b\x02\x1b\x1al\x20Filter\x20models\x20by\x20the\x20sp\
    ecific\x20model_type_id.\x20See\x20ListModelTypes\x20for\x20the\x20list\
    \x20of\x20ModelType.Id's\n\x20supported.\n\n\r\n\x05\x04;\x02\x02\x05\
    \x12\x04\x92\x0b\x02\x08\n\r\n\x05\x04;\x02\x02\x01\x12\x04\x92\x0b\t\
    \x16\n\r\n\x05\x04;\x02\x02\x03\x12\x04\x92\x0b\x19\x1a\n\x0c\n\x02\x05\
    \x02\x12\x06\x94\x0b\0\xa1\x0b\x01\n\x0b\n\x03\x05\x02\x01\x12\x04\x94\
    \x0b\x05\x14\n\x0c\n\x04\x05\x02\x02\0\x12\x04\x95\x0b\x02\x20\n\r\n\x05\
    \x05\x02\x02\0\x01\x12\x04\x95\x0b\x02\x1b\n\r\n\x05\x05\x02\x02\0\x02\
    \x12\x04\x95\x0b\x1e\x1f\n\x1d\n\x04\x05\x02\x02\x01\x12\x04\x98\x0b\x02\
    \x13\x1a\x0f\x20input\x20>\x20value\n\n\r\n\x05\x05\x02\x02\x01\x01\x12\
    \x04\x98\x0b\x02\x0e\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\x98\x0b\x11\
    \x12\n\x1e\n\x04\x05\x02\x02\x02\x12\x04\x9a\x0b\x02\x1c\x1a\x10\x20inpu\
    t\x20>=\x20value\n\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\x9a\x0b\x02\x17\
    \n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\x9a\x0b\x1a\x1b\n\x1d\n\x04\x05\
    \x02\x02\x03\x12\x04\x9c\x0b\x02\x10\x1a\x0f\x20input\x20<\x20value\n\n\
    \r\n\x05\x05\x02\x02\x03\x01\x12\x04\x9c\x0b\x02\x0b\n\r\n\x05\x05\x02\
    \x02\x03\x02\x12\x04\x9c\x0b\x0e\x0f\n\x1e\n\x04\x05\x02\x02\x04\x12\x04\
    \x9e\x0b\x02\x19\x1a\x10\x20input\x20<=\x20value\n\n\r\n\x05\x05\x02\x02\
    \x04\x01\x12\x04\x9e\x0b\x02\x14\n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\
    \x9e\x0b\x17\x18\n\x1e\n\x04\x05\x02\x02\x05\x12\x04\xa0\x0b\x02\x0c\x1a\
    \x10\x20input\x20==\x20value\n\n\r\n\x05\x05\x02\x02\x05\x01\x12\x04\xa0\
    \x0b\x02\x07\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\xa0\x0b\n\x0b\n\x0c\n\
    \x02\x05\x03\x12\x06\xa5\x0b\0\xa8\x0b\x01\n\x0b\n\x03\x05\x03\x01\x12\
    \x04\xa5\x0b\x05\x13\n\x17\n\x04\x05\x03\x02\0\x12\x04\xa6\x0b\x02\x15\"\
    \t\x20default\n\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\xa6\x0b\x02\x10\n\r\
    \n\x05\x05\x03\x02\0\x02\x12\x04\xa6\x0b\x13\x14\n\x0c\n\x04\x05\x03\x02\
    \x01\x12\x04\xa7\x0b\x02\x10\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\xa7\
    \x0b\x02\x0b\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\xa7\x0b\x0e\x0f\n\xe4\
    \x01\n\x02\x04<\x12\x06\xb0\x0b\0\xdd\x0b\x01\x1a\xd5\x01///////////////\
    ///////////////////////////////////////////////////////////////\n\x20Mes\
    sages\x20from\x20/proto/clarifai/api/model_version.proto\n//////////////\
    ////////////////////////////////////////////////////////////////\n\n\x0b\
    \n\x03\x04<\x01\x12\x04\xb0\x0b\x08\x14\n\x0b\n\x03\x04<\t\x12\x04\xb1\
    \x0b\x02\r\n\x0c\n\x04\x04<\t\0\x12\x04\xb1\x0b\x0b\x0c\n\r\n\x05\x04<\t\
    \0\x01\x12\x04\xb1\x0b\x0b\x0c\n\r\n\x05\x04<\t\0\x02\x12\x04\xb1\x0b\
    \x0b\x0c\n\x0c\n\x04\x04<\x02\0\x12\x04\xb3\x0b\x02\x10\n\r\n\x05\x04<\
    \x02\0\x05\x12\x04\xb3\x0b\x02\x08\n\r\n\x05\x04<\x02\0\x01\x12\x04\xb3\
    \x0b\t\x0b\n\r\n\x05\x04<\x02\0\x03\x12\x04\xb3\x0b\x0e\x0f\n-\n\x04\x04\
    <\x02\x01\x12\x04\xb5\x0b\x02+\x1a\x1f\x20When\x20the\x20version\x20was\
    \x20created.\n\n\r\n\x05\x04<\x02\x01\x06\x12\x04\xb5\x0b\x02\x1b\n\r\n\
    \x05\x04<\x02\x01\x01\x12\x04\xb5\x0b\x1c&\n\r\n\x05\x04<\x02\x01\x03\
    \x12\x04\xb5\x0b)*\n\\\n\x04\x04<\x02\x02\x12\x04\xb7\x0b\x02(\x1aN\x20T\
    he\x20status\x20of\x20the\x20version\x20(whether\x20it's\x20untrained,\
    \x20training,\x20trained,\x20etc.).\n\n\r\n\x05\x04<\x02\x02\x06\x12\x04\
    \xb7\x0b\x02\x1c\n\r\n\x05\x04<\x02\x02\x01\x12\x04\xb7\x0b\x1d#\n\r\n\
    \x05\x04<\x02\x02\x03\x12\x04\xb7\x0b&'\n\x0c\n\x04\x04<\x02\x03\x12\x04\
    \xb9\x0b\x02\"\n\r\n\x05\x04<\x02\x03\x05\x12\x04\xb9\x0b\x02\x08\n\r\n\
    \x05\x04<\x02\x03\x01\x12\x04\xb9\x0b\t\x1d\n\r\n\x05\x04<\x02\x03\x03\
    \x12\x04\xb9\x0b\x20!\n\x0c\n\x04\x04<\x02\x04\x12\x04\xbb\x0b\x02\x1a\n\
    \r\n\x05\x04<\x02\x04\x06\x12\x04\xbb\x0b\x02\r\n\r\n\x05\x04<\x02\x04\
    \x01\x12\x04\xbb\x0b\x0e\x15\n\r\n\x05\x04<\x02\x04\x03\x12\x04\xbb\x0b\
    \x18\x19\n5\n\x04\x04<\x02\x05\x12\x04\xbe\x0b\x02\x1f\x1a'\x20number\
    \x20of\x20inputs\x20in\x20the\x20model\x20version\n\n\r\n\x05\x04<\x02\
    \x05\x05\x12\x04\xbe\x0b\x02\x08\n\r\n\x05\x04<\x02\x05\x01\x12\x04\xbe\
    \x0b\t\x1a\n\r\n\x05\x04<\x02\x05\x03\x12\x04\xbe\x0b\x1d\x1e\n\xfa\x01\
    \n\x04\x04<\x02\x06\x12\x04\xc6\x0b\x02.\x1a.\x20When\x20training\x20of\
    \x20this\x20version\x20was\x20completed.\n2\x9f\x01\x20This\x20is\x20the\
    \x20internal\x20name\x20for\x20the\x20ModelVersion\x20when\x20creating\
    \x20a\x20new\x20model\x20at\x20Clarifai.\x20If\x20you're\n\x20an\x20API\
    \x20user\x20you\x20should\x20not\x20need\x20to\x20interact\x20with\x20th\
    is\x20field.\n2\x1a\x20Detailed\x20training\x20stats.\n\n\r\n\x05\x04<\
    \x02\x06\x06\x12\x04\xc6\x0b\x02\x1b\n\r\n\x05\x04<\x02\x06\x01\x12\x04\
    \xc6\x0b\x1c(\n\r\n\x05\x04<\x02\x06\x03\x12\x04\xc6\x0b+-\n.\n\x04\x04<\
    \x02\x07\x12\x04\xc9\x0b\x02\x1a\x1a\x20\x20Description\x20about\x20this\
    \x20version\n\n\r\n\x05\x04<\x02\x07\x05\x12\x04\xc9\x0b\x02\x08\n\r\n\
    \x05\x04<\x02\x07\x01\x12\x04\xc9\x0b\t\x14\n\r\n\x05\x04<\x02\x07\x03\
    \x12\x04\xc9\x0b\x17\x19\n\xdd\x01\n\x04\x04<\x02\x08\x12\x04\xce\x0b\
    \x02\x1d\x1a\xce\x01\x20The\x20visibility\x20field\x20represents\x20whet\
    her\x20this\x20message\x20is\x20privately/publicly\x20visible.\n\x20To\
    \x20be\x20visible\x20to\x20the\x20public\x20the\x20App\x20that\x20contai\
    ns\x20it\x20AND\x20the\x20User\x20that\x20contains\x20the\x20App\x20must\
    \n\x20also\x20be\x20publicly\x20visible.\n\n\r\n\x05\x04<\x02\x08\x06\
    \x12\x04\xce\x0b\x02\x0c\n\r\n\x05\x04<\x02\x08\x01\x12\x04\xce\x0b\r\
    \x17\n\r\n\x05\x04<\x02\x08\x03\x12\x04\xce\x0b\x1a\x1c\n5\n\x04\x04<\
    \x02\t\x12\x04\xd1\x0b\x02\x15\x1a'\x20The\x20app\x20the\x20model\x20ver\
    sion\x20belongs\x20to.\n\n\r\n\x05\x04<\x02\t\x05\x12\x04\xd1\x0b\x02\
    \x08\n\r\n\x05\x04<\x02\t\x01\x12\x04\xd1\x0b\t\x0f\n\r\n\x05\x04<\x02\t\
    \x03\x12\x04\xd1\x0b\x12\x14\n6\n\x04\x04<\x02\n\x12\x04\xd3\x0b\x02\x16\
    \x1a(\x20The\x20user\x20the\x20model\x20version\x20belongs\x20to.\n\n\r\
    \n\x05\x04<\x02\n\x05\x12\x04\xd3\x0b\x02\x08\n\r\n\x05\x04<\x02\n\x01\
    \x12\x04\xd3\x0b\t\x10\n\r\n\x05\x04<\x02\n\x03\x12\x04\xd3\x0b\x13\x15\
    \n9\n\x04\x04<\x02\x0b\x12\x04\xd6\x0b\x02-\x1a+\x20When\x20this\x20mode\
    l\x20version\x20was\x20last\x20modified\n\n\r\n\x05\x04<\x02\x0b\x06\x12\
    \x04\xd6\x0b\x02\x1b\n\r\n\x05\x04<\x02\x0b\x01\x12\x04\xd6\x0b\x1c'\n\r\
    \n\x05\x04<\x02\x0b\x03\x12\x04\xd6\x0b*,\n\x9f\x01\n\x04\x04<\x02\x0c\
    \x12\x04\xda\x0b\x02'\x1a\x90\x01\x20To\x20handle\x20arbitrary\x20json\
    \x20metadata\x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20https://\
    github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto\
    \n\n\r\n\x05\x04<\x02\x0c\x06\x12\x04\xda\x0b\x02\x18\n\r\n\x05\x04<\x02\
    \x0c\x01\x12\x04\xda\x0b\x19!\n\r\n\x05\x04<\x02\x0c\x03\x12\x04\xda\x0b\
    $&\n\x0c\n\x04\x04<\x02\r\x12\x04\xdc\x0b\x02\x16\n\r\n\x05\x04<\x02\r\
    \x05\x12\x04\xdc\x0b\x02\x08\n\r\n\x05\x04<\x02\r\x01\x12\x04\xdc\x0b\t\
    \x10\n\r\n\x05\x04<\x02\r\x03\x12\x04\xdc\x0b\x13\x15\n\x0c\n\x02\x04=\
    \x12\x06\xdf\x0b\0\xee\x0b\x01\n\x0b\n\x03\x04=\x01\x12\x04\xdf\x0b\x08\
    \x1d\n@\n\x04\x04=\x02\0\x12\x04\xe1\x0b\x02\x10\x1a2\x20This\x20is\x20t\
    he\x20internal\x20id\x20of\x20the\x20pretrained\x20model.\n\n\r\n\x05\
    \x04=\x02\0\x05\x12\x04\xe1\x0b\x02\x08\n\r\n\x05\x04=\x02\0\x01\x12\x04\
    \xe1\x0b\t\x0b\n\r\n\x05\x04=\x02\0\x03\x12\x04\xe1\x0b\x0e\x0f\nB\n\x04\
    \x04=\x02\x01\x12\x04\xe3\x0b\x02\x12\x1a4\x20This\x20is\x20the\x20inter\
    nal\x20type\x20of\x20the\x20pretrained\x20model.\n\n\r\n\x05\x04=\x02\
    \x01\x05\x12\x04\xe3\x0b\x02\x08\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xe3\
    \x0b\t\r\n\r\n\x05\x04=\x02\x01\x03\x12\x04\xe3\x0b\x10\x11\nS\n\x04\x04\
    =\x02\x02\x12\x04\xe5\x0b\x02.\x1aE\x20Map\x20from\x20the\x20api.Data\
    \x20field\x20names\x20to\x20the\x20Triton\x20config.pbtxt\x20input.\n\n\
    \r\n\x05\x04=\x02\x02\x06\x12\x04\xe5\x0b\x02\x18\n\r\n\x05\x04=\x02\x02\
    \x01\x12\x04\xe5\x0b\x19)\n\r\n\x05\x04=\x02\x02\x03\x12\x04\xe5\x0b,-\n\
    T\n\x04\x04=\x02\x03\x12\x04\xe7\x0b\x02/\x1aF\x20Map\x20from\x20the\x20\
    api.Data\x20field\x20names\x20to\x20the\x20Triton\x20config.pbtxt\x20out\
    put.\n\n\r\n\x05\x04=\x02\x03\x06\x12\x04\xe7\x0b\x02\x18\n\r\n\x05\x04=\
    \x02\x03\x01\x12\x04\xe7\x0b\x19*\n\r\n\x05\x04=\x02\x03\x03\x12\x04\xe7\
    \x0b-.\nB\n\x04\x04=\x02\x04\x12\x04\xe9\x0b\x02\"\x1a4\x20Preprocessing\
    \x20steps\x20for\x20the\x20model\x20as\x20a\x20json\x20string\n\n\r\n\
    \x05\x04=\x02\x04\x05\x12\x04\xe9\x0b\x02\x08\n\r\n\x05\x04=\x02\x04\x01\
    \x12\x04\xe9\x0b\t\x1d\n\r\n\x05\x04=\x02\x04\x03\x12\x04\xe9\x0b\x20!\n\
    M\n\x04\x04=\x02\x05\x12\x04\xeb\x0b\x02\x1b\x1a?\x20Url\x20to\x20a\x20z\
    ipped\x20up\x20model\x20in\x20triton\x20format\x20with\x20only\x20versio\
    n\x201\n\n\r\n\x05\x04=\x02\x05\x05\x12\x04\xeb\x0b\x02\x08\n\r\n\x05\
    \x04=\x02\x05\x01\x12\x04\xeb\x0b\t\x16\n\r\n\x05\x04=\x02\x05\x03\x12\
    \x04\xeb\x0b\x19\x1a\nK\n\x04\x04=\x02\x06\x12\x04\xed\x0b\x02\x15\x1a=\
    \x20Whether\x20to\x20overwrite\x20the\x20model\x20for\x20the\x20existing\
    \x20internal\x20id\n\n\r\n\x05\x04=\x02\x06\x05\x12\x04\xed\x0b\x02\x06\
    \n\r\n\x05\x04=\x02\x06\x01\x12\x04\xed\x0b\x07\x10\n\r\n\x05\x04=\x02\
    \x06\x03\x12\x04\xed\x0b\x13\x14\n\x0c\n\x02\x04>\x12\x06\xf0\x0b\0\xf2\
    \x0b\x01\n\x0b\n\x03\x04>\x01\x12\x04\xf0\x0b\x08\x12\n\x0c\n\x04\x04>\
    \x02\0\x12\x04\xf1\x0b\x02)\n\r\n\x05\x04>\x02\0\x04\x12\x04\xf1\x0b\x02\
    \n\n\r\n\x05\x04>\x02\0\x06\x12\x04\xf1\x0b\x0b\x19\n\r\n\x05\x04>\x02\0\
    \x01\x12\x04\xf1\x0b\x1a$\n\r\n\x05\x04>\x02\0\x03\x12\x04\xf1\x0b'(\n\
    \x0c\n\x02\x04?\x12\x06\xf4\x0b\0\xfc\x0b\x01\n\x0b\n\x03\x04?\x01\x12\
    \x04\xf4\x0b\x08\x16\n\x1d\n\x04\x04?\x02\0\x12\x04\xf6\x0b\x02\x13\x1a\
    \x0f\x20current\x20epoch\n\n\r\n\x05\x04?\x02\0\x05\x12\x04\xf6\x0b\x02\
    \x08\n\r\n\x05\x04?\x02\0\x01\x12\x04\xf6\x0b\t\x0e\n\r\n\x05\x04?\x02\0\
    \x03\x12\x04\xf6\x0b\x11\x12\n#\n\x04\x04?\x02\x01\x12\x04\xf8\x0b\x02\
    \x19\x1a\x15\x20current\x20global\x20step\n\n\r\n\x05\x04?\x02\x01\x05\
    \x12\x04\xf8\x0b\x02\x08\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xf8\x0b\t\
    \x14\n\r\n\x05\x04?\x02\x01\x03\x12\x04\xf8\x0b\x17\x18\nP\n\x04\x04?\
    \x02\x02\x12\x04\xfb\x0b\x02\x11\x1aB\x20current\x20cost\n\x20FIXME(rige\
    l):\x20this\x20should\x20be\x20loss\x20instead\x20of\x20cost.\n\n\r\n\
    \x05\x04?\x02\x02\x05\x12\x04\xfb\x0b\x02\x07\n\r\n\x05\x04?\x02\x02\x01\
    \x12\x04\xfb\x0b\x08\x0c\n\r\n\x05\x04?\x02\x02\x03\x12\x04\xfb\x0b\x0f\
    \x10\n\x0c\n\x02\x04@\x12\x06\xfe\x0b\0\x83\x0c\x01\n\x0b\n\x03\x04@\x01\
    \x12\x04\xfe\x0b\x08\x12\n\xc6\x01\n\x04\x04@\x02\0\x12\x04\x81\x0c\x02\
    \x1a\x1a\xb7\x01\x20FIXME:\x20should\x20move\x20to\x20Concept\x20object\
    \x20and\x20return\x20the\x20whole\x20thing\x20(including\x20name\x20and\
    \x20id)\n\x20otherwise\x20if\x20two\x20concepts\x20have\x20same\x20name\
    \x20then\x20you\x20won't\x20tell\x20them\x20apart\x20in\x20confusion\x20\
    matrix.\n\n\r\n\x05\x04@\x02\0\x05\x12\x04\x81\x0c\x02\x08\n\r\n\x05\x04\
    @\x02\0\x01\x12\x04\x81\x0c\t\x15\n\r\n\x05\x04@\x02\0\x03\x12\x04\x81\
    \x0c\x18\x19\n\x0c\n\x04\x04@\x02\x01\x12\x04\x82\x0c\x02\x13\n\r\n\x05\
    \x04@\x02\x01\x05\x12\x04\x82\x0c\x02\x08\n\r\n\x05\x04@\x02\x01\x01\x12\
    \x04\x82\x0c\t\x0e\n\r\n\x05\x04@\x02\x01\x03\x12\x04\x82\x0c\x11\x12\n\
    \x0c\n\x02\x04A\x12\x06\x85\x0c\0\x87\x0c\x01\n\x0b\n\x03\x04A\x01\x12\
    \x04\x85\x0c\x08\x19\n\x0c\n\x04\x04A\x02\0\x12\x04\x86\x0c\x020\n\r\n\
    \x05\x04A\x02\0\x04\x12\x04\x86\x0c\x02\n\n\r\n\x05\x04A\x02\0\x06\x12\
    \x04\x86\x0c\x0b\x15\n\r\n\x05\x04A\x02\0\x01\x12\x04\x86\x0c\x16+\n\r\n\
    \x05\x04A\x02\0\x03\x12\x04\x86\x0c./\nV\n\x02\x04B\x12\x06\x8a\x0c\0\
    \x90\x0c\x01\x1aH\x20NOTE:\x20this\x20is\x20inefficient,\x20should\x20ju\
    st\x20have\x20the\x20order\x20of\x20the\x20rows/cols\n\n\x0b\n\x03\x04B\
    \x01\x12\x04\x8a\x0c\x08\x1f\n&\n\x04\x04B\x02\0\x12\x04\x8c\x0c\x02\x11\
    \x1a\x18\x20concept_id\x20for\x20the\x20row\n\n\r\n\x05\x04B\x02\0\x05\
    \x12\x04\x8c\x0c\x02\x08\n\r\n\x05\x04B\x02\0\x01\x12\x04\x8c\x0c\t\x0c\
    \n\r\n\x05\x04B\x02\0\x03\x12\x04\x8c\x0c\x0f\x10\n&\n\x04\x04B\x02\x01\
    \x12\x04\x8e\x0c\x02\x11\x1a\x18\x20concept_id\x20for\x20the\x20col\n\n\
    \r\n\x05\x04B\x02\x01\x05\x12\x04\x8e\x0c\x02\x08\n\r\n\x05\x04B\x02\x01\
    \x01\x12\x04\x8e\x0c\t\x0c\n\r\n\x05\x04B\x02\x01\x03\x12\x04\x8e\x0c\
    \x0f\x10\n\x0c\n\x04\x04B\x02\x02\x12\x04\x8f\x0c\x02\x13\n\r\n\x05\x04B\
    \x02\x02\x05\x12\x04\x8f\x0c\x02\x08\n\r\n\x05\x04B\x02\x02\x01\x12\x04\
    \x8f\x0c\t\x0e\n\r\n\x05\x04B\x02\x02\x03\x12\x04\x8f\x0c\x11\x12\n\x0c\
    \n\x02\x04C\x12\x06\x92\x0c\0\x96\x0c\x01\n\x0b\n\x03\x04C\x01\x12\x04\
    \x92\x0c\x08\x1a\n\x0c\n\x04\x04C\x02\0\x12\x04\x93\x0c\x02.\n\r\n\x05\
    \x04C\x02\0\x04\x12\x04\x93\x0c\x02\n\n\r\n\x05\x04C\x02\0\x06\x12\x04\
    \x93\x0c\x0b\"\n\r\n\x05\x04C\x02\0\x01\x12\x04\x93\x0c#)\n\r\n\x05\x04C\
    \x02\0\x03\x12\x04\x93\x0c,-\ne\n\x04\x04C\x02\x01\x12\x04\x95\x0c\x02\"\
    \x1aW\x20These\x20concept_ids\x20are\x20ordered\x20by\x20the\x20strength\
    \x20of\x20the\x20diagonal\x20in\x20the\x20ConfusionMatrix.\n\n\r\n\x05\
    \x04C\x02\x01\x04\x12\x04\x95\x0c\x02\n\n\r\n\x05\x04C\x02\x01\x05\x12\
    \x04\x95\x0c\x0b\x11\n\r\n\x05\x04C\x02\x01\x01\x12\x04\x95\x0c\x12\x1d\
    \n\r\n\x05\x04C\x02\x01\x03\x12\x04\x95\x0c\x20!\n\x0c\n\x02\x04D\x12\
    \x06\x98\x0c\0\x9c\x0c\x01\n\x0b\n\x03\x04D\x01\x12\x04\x98\x0c\x08\x1c\
    \n\x0c\n\x04\x04D\x02\0\x12\x04\x99\x0c\x02\x17\n\r\n\x05\x04D\x02\0\x05\
    \x12\x04\x99\x0c\x02\x08\n\r\n\x05\x04D\x02\0\x01\x12\x04\x99\x0c\t\x12\
    \n\r\n\x05\x04D\x02\0\x03\x12\x04\x99\x0c\x15\x16\n\x0c\n\x04\x04D\x02\
    \x01\x12\x04\x9a\x0c\x02\x14\n\r\n\x05\x04D\x02\x01\x05\x12\x04\x9a\x0c\
    \x02\x08\n\r\n\x05\x04D\x02\x01\x01\x12\x04\x9a\x0c\t\x0f\n\r\n\x05\x04D\
    \x02\x01\x03\x12\x04\x9a\x0c\x12\x13\n\x0c\n\x04\x04D\x02\x02\x12\x04\
    \x9b\x0c\x02A\n\r\n\x05\x04D\x02\x02\x05\x12\x04\x9b\x0c\x02\x07\n\r\n\
    \x05\x04D\x02\x02\x01\x12\x04\x9b\x0c\x08\r\n\r\n\x05\x04D\x02\x02\x03\
    \x12\x04\x9b\x0c\x10\x11\n\r\n\x05\x04D\x02\x02\x08\x12\x04\x9b\x0c\x12@\
    \n\x10\n\x08\x04D\x02\x02\x08\xd0\x86\x03\x12\x04\x9b\x0c\x13?\n\x0c\n\
    \x02\x04E\x12\x06\x9e\x0c\0\xa2\x0c\x01\n\x0b\n\x03\x04E\x01\x12\x04\x9e\
    \x0c\x08\x17\n\x0c\n\x04\x04E\x02\0\x12\x04\x9f\x0c\x02+\n\r\n\x05\x04E\
    \x02\0\x04\x12\x04\x9f\x0c\x02\n\n\r\n\x05\x04E\x02\0\x06\x12\x04\x9f\
    \x0c\x0b\x1f\n\r\n\x05\x04E\x02\0\x01\x12\x04\x9f\x0c\x20&\n\r\n\x05\x04\
    E\x02\0\x03\x12\x04\x9f\x0c)*\ne\n\x04\x04E\x02\x01\x12\x04\xa1\x0c\x02\
    \"\x1aW\x20These\x20concept_ids\x20are\x20ordered\x20by\x20the\x20streng\
    th\x20of\x20the\x20diagonal\x20in\x20the\x20ConfusionMatrix.\n\n\r\n\x05\
    \x04E\x02\x01\x04\x12\x04\xa1\x0c\x02\n\n\r\n\x05\x04E\x02\x01\x05\x12\
    \x04\xa1\x0c\x0b\x11\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xa1\x0c\x12\x1d\
    \n\r\n\x05\x04E\x02\x01\x03\x12\x04\xa1\x0c\x20!\n\x0c\n\x02\x04F\x12\
    \x06\xa4\x0c\0\xaa\x0c\x01\n\x0b\n\x03\x04F\x01\x12\x04\xa4\x0c\x08\x0b\
    \n\x0c\n\x04\x04F\x02\0\x12\x04\xa5\x0c\x02H\n\r\n\x05\x04F\x02\0\x04\
    \x12\x04\xa5\x0c\x02\n\n\r\n\x05\x04F\x02\0\x05\x12\x04\xa5\x0c\x0b\x10\
    \n\r\n\x05\x04F\x02\0\x01\x12\x04\xa5\x0c\x11\x14\n\r\n\x05\x04F\x02\0\
    \x03\x12\x04\xa5\x0c\x17\x18\n\r\n\x05\x04F\x02\0\x08\x12\x04\xa5\x0c\
    \x19G\n\x10\n\x08\x04F\x02\0\x08\xd0\x86\x03\x12\x04\xa5\x0c\x1aF\n\x0c\
    \n\x04\x04F\x02\x01\x12\x04\xa6\x0c\x02H\n\r\n\x05\x04F\x02\x01\x04\x12\
    \x04\xa6\x0c\x02\n\n\r\n\x05\x04F\x02\x01\x05\x12\x04\xa6\x0c\x0b\x10\n\
    \r\n\x05\x04F\x02\x01\x01\x12\x04\xa6\x0c\x11\x14\n\r\n\x05\x04F\x02\x01\
    \x03\x12\x04\xa6\x0c\x17\x18\n\r\n\x05\x04F\x02\x01\x08\x12\x04\xa6\x0c\
    \x19G\n\x10\n\x08\x04F\x02\x01\x08\xd0\x86\x03\x12\x04\xa6\x0c\x1aF\n\
    \x0c\n\x04\x04F\x02\x02\x12\x04\xa7\x0c\x02O\n\r\n\x05\x04F\x02\x02\x04\
    \x12\x04\xa7\x0c\x02\n\n\r\n\x05\x04F\x02\x02\x05\x12\x04\xa7\x0c\x0b\
    \x10\n\r\n\x05\x04F\x02\x02\x01\x12\x04\xa7\x0c\x11\x1b\n\r\n\x05\x04F\
    \x02\x02\x03\x12\x04\xa7\x0c\x1e\x1f\n\r\n\x05\x04F\x02\x02\x08\x12\x04\
    \xa7\x0c\x20N\n\x10\n\x08\x04F\x02\x02\x08\xd0\x86\x03\x12\x04\xa7\x0c!M\
    \n\x0c\n\x04\x04F\x02\x03\x12\x04\xa8\x0c\x02#\n\r\n\x05\x04F\x02\x03\
    \x04\x12\x04\xa8\x0c\x02\n\n\r\n\x05\x04F\x02\x03\x05\x12\x04\xa8\x0c\
    \x0b\x10\n\r\n\x05\x04F\x02\x03\x01\x12\x04\xa8\x0c\x11\x1e\n\r\n\x05\
    \x04F\x02\x03\x03\x12\x04\xa8\x0c!\"\n\x0c\n\x04\x04F\x02\x04\x12\x04\
    \xa9\x0c\x02$\n\r\n\x05\x04F\x02\x04\x04\x12\x04\xa9\x0c\x02\n\n\r\n\x05\
    \x04F\x02\x04\x05\x12\x04\xa9\x0c\x0b\x10\n\r\n\x05\x04F\x02\x04\x01\x12\
    \x04\xa9\x0c\x11\x1f\n\r\n\x05\x04F\x02\x04\x03\x12\x04\xa9\x0c\"#\n\x0c\
    \n\x02\x04G\x12\x06\xac\x0c\0\xb0\x0c\x01\n\x0b\n\x03\x04G\x01\x12\x04\
    \xac\x0c\x08\x1c\n\x0c\n\x04\x04G\x02\0\x12\x04\xad\x0c\x02K\n\r\n\x05\
    \x04G\x02\0\x04\x12\x04\xad\x0c\x02\n\n\r\n\x05\x04G\x02\0\x05\x12\x04\
    \xad\x0c\x0b\x10\n\r\n\x05\x04G\x02\0\x01\x12\x04\xad\x0c\x11\x17\n\r\n\
    \x05\x04G\x02\0\x03\x12\x04\xad\x0c\x1a\x1b\n\r\n\x05\x04G\x02\0\x08\x12\
    \x04\xad\x0c\x1cJ\n\x10\n\x08\x04G\x02\0\x08\xd0\x86\x03\x12\x04\xad\x0c\
    \x1dI\n\x0c\n\x04\x04G\x02\x01\x12\x04\xae\x0c\x02N\n\r\n\x05\x04G\x02\
    \x01\x04\x12\x04\xae\x0c\x02\n\n\r\n\x05\x04G\x02\x01\x05\x12\x04\xae\
    \x0c\x0b\x10\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xae\x0c\x11\x1a\n\r\n\
    \x05\x04G\x02\x01\x03\x12\x04\xae\x0c\x1d\x1e\n\r\n\x05\x04G\x02\x01\x08\
    \x12\x04\xae\x0c\x1fM\n\x10\n\x08\x04G\x02\x01\x08\xd0\x86\x03\x12\x04\
    \xae\x0c\x20L\n\x0c\n\x04\x04G\x02\x02\x12\x04\xaf\x0c\x02O\n\r\n\x05\
    \x04G\x02\x02\x04\x12\x04\xaf\x0c\x02\n\n\r\n\x05\x04G\x02\x02\x05\x12\
    \x04\xaf\x0c\x0b\x10\n\r\n\x05\x04G\x02\x02\x01\x12\x04\xaf\x0c\x11\x1b\
    \n\r\n\x05\x04G\x02\x02\x03\x12\x04\xaf\x0c\x1e\x1f\n\r\n\x05\x04G\x02\
    \x02\x08\x12\x04\xaf\x0c\x20N\n\x10\n\x08\x04G\x02\x02\x08\xd0\x86\x03\
    \x12\x04\xaf\x0c!M\n\x0c\n\x02\x04H\x12\x06\xb2\x0c\0\xc1\x0c\x01\n\x0b\
    \n\x03\x04H\x01\x12\x04\xb2\x0c\x08\x15\n\x0c\n\x04\x04H\x02\0\x12\x04\
    \xb3\x0c\x02D\n\r\n\x05\x04H\x02\0\x05\x12\x04\xb3\x0c\x02\x08\n\r\n\x05\
    \x04H\x02\0\x01\x12\x04\xb3\x0c\t\x10\n\r\n\x05\x04H\x02\0\x03\x12\x04\
    \xb3\x0c\x13\x14\n\r\n\x05\x04H\x02\0\x08\x12\x04\xb3\x0c\x15C\n\x10\n\
    \x08\x04H\x02\0\x08\xd0\x86\x03\x12\x04\xb3\x0c\x16B\n\x0c\n\x04\x04H\
    \x02\x01\x12\x04\xb4\x0c\x02D\n\r\n\x05\x04H\x02\x01\x05\x12\x04\xb4\x0c\
    \x02\x08\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xb4\x0c\t\x10\n\r\n\x05\x04H\
    \x02\x01\x03\x12\x04\xb4\x0c\x13\x14\n\r\n\x05\x04H\x02\x01\x08\x12\x04\
    \xb4\x0c\x15C\n\x10\n\x08\x04H\x02\x01\x08\xd0\x86\x03\x12\x04\xb4\x0c\
    \x16B\n\x0c\n\x04\x04H\x02\x02\x12\x04\xb5\x0c\x02D\n\r\n\x05\x04H\x02\
    \x02\x05\x12\x04\xb5\x0c\x02\x08\n\r\n\x05\x04H\x02\x02\x01\x12\x04\xb5\
    \x0c\t\x10\n\r\n\x05\x04H\x02\x02\x03\x12\x04\xb5\x0c\x13\x14\n\r\n\x05\
    \x04H\x02\x02\x08\x12\x04\xb5\x0c\x15C\n\x10\n\x08\x04H\x02\x02\x08\xd0\
    \x86\x03\x12\x04\xb5\x0c\x16B\n\x0c\n\x04\x04H\x02\x03\x12\x04\xb6\x0c\
    \x02C\n\r\n\x05\x04H\x02\x03\x05\x12\x04\xb6\x0c\x02\x07\n\r\n\x05\x04H\
    \x02\x03\x01\x12\x04\xb6\x0c\x08\x0f\n\r\n\x05\x04H\x02\x03\x03\x12\x04\
    \xb6\x0c\x12\x13\n\r\n\x05\x04H\x02\x03\x08\x12\x04\xb6\x0c\x14B\n\x10\n\
    \x08\x04H\x02\x03\x08\xd0\x86\x03\x12\x04\xb6\x0c\x15A\n\x0c\n\x04\x04H\
    \x02\x04\x12\x04\xb7\x0c\x02>\n\r\n\x05\x04H\x02\x04\x05\x12\x04\xb7\x0c\
    \x02\x07\n\r\n\x05\x04H\x02\x04\x01\x12\x04\xb7\x0c\x08\n\n\r\n\x05\x04H\
    \x02\x04\x03\x12\x04\xb7\x0c\r\x0e\n\r\n\x05\x04H\x02\x04\x08\x12\x04\
    \xb7\x0c\x0f=\n\x10\n\x08\x04H\x02\x04\x08\xd0\x86\x03\x12\x04\xb7\x0c\
    \x10<\n\x0c\n\x04\x04H\x02\x05\x12\x04\xb8\x0c\x02\x16\n\r\n\x05\x04H\
    \x02\x05\x06\x12\x04\xb8\x0c\x02\t\n\r\n\x05\x04H\x02\x05\x01\x12\x04\
    \xb8\x0c\n\x11\n\r\n\x05\x04H\x02\x05\x03\x12\x04\xb8\x0c\x14\x15\n\x0c\
    \n\x04\x04H\x02\x06\x12\x04\xb9\x0c\x02\x14\n\r\n\x05\x04H\x02\x06\x06\
    \x12\x04\xb9\x0c\x02\x05\n\r\n\x05\x04H\x02\x06\x01\x12\x04\xb9\x0c\x06\
    \x0f\n\r\n\x05\x04H\x02\x06\x03\x12\x04\xb9\x0c\x12\x13\n\x0c\n\x04\x04H\
    \x02\x07\x12\x04\xba\x0c\x022\n\r\n\x05\x04H\x02\x07\x06\x12\x04\xba\x0c\
    \x02\x16\n\r\n\x05\x04H\x02\x07\x01\x12\x04\xba\x0c\x17-\n\r\n\x05\x04H\
    \x02\x07\x03\x12\x04\xba\x0c01\n\x0c\n\x04\x04H\x02\x08\x12\x04\xbb\x0c\
    \x02\x1a\n\r\n\x05\x04H\x02\x08\x05\x12\x04\xbb\x0c\x02\x07\n\r\n\x05\
    \x04H\x02\x08\x01\x12\x04\xbb\x0c\x08\x15\n\r\n\x05\x04H\x02\x08\x03\x12\
    \x04\xbb\x0c\x18\x19\n\x0c\n\x04\x04H\x02\t\x12\x04\xbc\x0c\x02\x18\n\r\
    \n\x05\x04H\x02\t\x05\x12\x04\xbc\x0c\x02\x08\n\r\n\x05\x04H\x02\t\x01\
    \x12\x04\xbc\x0c\t\x12\n\r\n\x05\x04H\x02\t\x03\x12\x04\xbc\x0c\x15\x17\
    \n\x0c\n\x04\x04H\x02\n\x12\x04\xbd\x0c\x02\x17\n\r\n\x05\x04H\x02\n\x05\
    \x12\x04\xbd\x0c\x02\x08\n\r\n\x05\x04H\x02\n\x01\x12\x04\xbd\x0c\t\x11\
    \n\r\n\x05\x04H\x02\n\x03\x12\x04\xbd\x0c\x14\x16\n\x0c\n\x04\x04H\x02\
    \x0b\x12\x04\xbe\x0c\x02\x17\n\r\n\x05\x04H\x02\x0b\x05\x12\x04\xbe\x0c\
    \x02\x08\n\r\n\x05\x04H\x02\x0b\x01\x12\x04\xbe\x0c\t\x11\n\r\n\x05\x04H\
    \x02\x0b\x03\x12\x04\xbe\x0c\x14\x16\n\x0c\n\x04\x04H\x02\x0c\x12\x04\
    \xbf\x0c\x02\x11\n\r\n\x05\x04H\x02\x0c\x05\x12\x04\xbf\x0c\x02\x07\n\r\
    \n\x05\x04H\x02\x0c\x01\x12\x04\xbf\x0c\x08\x0b\n\r\n\x05\x04H\x02\x0c\
    \x03\x12\x04\xbf\x0c\x0e\x10\n\x0c\n\x02\x04I\x12\x06\xc3\x0c\0\xd0\x0c\
    \x01\n\x0b\n\x03\x04I\x01\x12\x04\xc3\x0c\x08\x16\n1\n\x04\x04I\x02\0\
    \x12\x04\xc5\x0c\x02\x15\x1a#\x20Multiple\x20object\x20tracking\x20accur\
    acy\n\n\r\n\x05\x04I\x02\0\x05\x12\x04\xc5\x0c\x02\x07\n\r\n\x05\x04I\
    \x02\0\x01\x12\x04\xc5\x0c\x08\x10\n\r\n\x05\x04I\x02\0\x03\x12\x04\xc5\
    \x0c\x13\x14\n1\n\x04\x04I\x02\x01\x12\x04\xc7\x0c\x02\x1d\x1a#\x20Numbe\
    r\x20of\x20switches\x20between\x20tracks\n\n\r\n\x05\x04I\x02\x01\x05\
    \x12\x04\xc7\x0c\x02\x07\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xc7\x0c\x08\
    \x18\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xc7\x0c\x1b\x1c\ne\n\x04\x04I\
    \x02\x02\x12\x04\xc9\x0c\x02\x17\x1aW\x20MORSE\x20fragmentation\x20rate\
    \x20(a.k.a\x20unique\x20switch\x20rate,\x20only\x20calculated\x20in\x20p\
    ublic\x20sector)\n\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xc9\x0c\x02\x07\n\
    \r\n\x05\x04I\x02\x02\x01\x12\x04\xc9\x0c\x08\x12\n\r\n\x05\x04I\x02\x02\
    \x03\x12\x04\xc9\x0c\x15\x16\nF\n\x04\x04I\x02\x03\x12\x04\xcb\x0c\x02\
    \x1a\x1a8\x20Average\x20precision\x20calculated\x20from\x20all\x20proces\
    sed\x20frames\n\n\r\n\x05\x04I\x02\x03\x05\x12\x04\xcb\x0c\x02\x07\n\r\n\
    \x05\x04I\x02\x03\x01\x12\x04\xcb\x0c\x08\x15\n\r\n\x05\x04I\x02\x03\x03\
    \x12\x04\xcb\x0c\x18\x19\n>\n\x04\x04I\x02\x04\x12\x04\xcd\x0c\x02\x12\
    \x1a0\x20The\x20concept\x20that\x20we\x20are\x20evaluating\x20the\x20tra\
    cker\n\n\r\n\x05\x04I\x02\x04\x05\x12\x04\xcd\x0c\x02\x08\n\r\n\x05\x04I\
    \x02\x04\x01\x12\x04\xcd\x0c\t\r\n\r\n\x05\x04I\x02\x04\x03\x12\x04\xcd\
    \x0c\x10\x11\nK\n\x04\x04I\x02\x05\x12\x04\xcf\x0c\x02\x1f\x1a=\x20Same\
    \x20as\x20morse_frag\x20but\x20calculated\x20using\x20MOT\x20mapping/met\
    rics\n\n\r\n\x05\x04I\x02\x05\x05\x12\x04\xcf\x0c\x02\x07\n\r\n\x05\x04I\
    \x02\x05\x01\x12\x04\xcf\x0c\x08\x1a\n\r\n\x05\x04I\x02\x05\x03\x12\x04\
    \xcf\x0c\x1d\x1e\n\x0c\n\x02\x04J\x12\x06\xd2\x0c\0\xe0\x0c\x01\n\x0b\n\
    \x03\x04J\x01\x12\x04\xd2\x0c\x08\x18\n\x1a\n\x04\x04J\x02\0\x12\x04\xd4\
    \x0c\x02$\x1a\x0c\x20Input\x20CFID\n\n\r\n\x05\x04J\x02\0\x05\x12\x04\
    \xd4\x0c\x02\x08\n\r\n\x05\x04J\x02\0\x01\x12\x04\xd4\x0c\t\x0b\n\r\n\
    \x05\x04J\x02\0\x03\x12\x04\xd4\x0c\x0e\x0f\n\r\n\x05\x04J\x02\0\x08\x12\
    \x04\xd4\x0c\x10#\n\x0e\n\x06\x04J\x02\0\x08\x03\x12\x04\xd4\x0c\x11\"\n\
    \x0c\n\x04\x04J\x02\x01\x12\x04\xd5\x0c\x02%\n\r\n\x05\x04J\x02\x01\x05\
    \x12\x04\xd5\x0c\x02\x08\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xd5\x0c\t\
    \x0c\n\r\n\x05\x04J\x02\x01\x03\x12\x04\xd5\x0c\x0f\x10\n\r\n\x05\x04J\
    \x02\x01\x08\x12\x04\xd5\x0c\x11$\n\x0e\n\x06\x04J\x02\x01\x08\x03\x12\
    \x04\xd5\x0c\x12#\n%\n\x04\x04J\x02\x02\x12\x04\xd6\x0c\x02\x12\"\x17\
    \x20the\x20input\x20information\n\n\r\n\x05\x04J\x02\x02\x06\x12\x04\xd6\
    \x0c\x02\x07\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xd6\x0c\x08\r\n\r\n\x05\
    \x04J\x02\x02\x03\x12\x04\xd6\x0c\x10\x11\n\x0c\n\x04\x04J\x02\x03\x12\
    \x04\xd8\x0c\x02*\n\r\n\x05\x04J\x02\x03\x04\x12\x04\xd8\x0c\x02\n\n\r\n\
    \x05\x04J\x02\x03\x06\x12\x04\xd8\x0c\x0b\x12\n\r\n\x05\x04J\x02\x03\x01\
    \x12\x04\xd8\x0c\x13%\n\r\n\x05\x04J\x02\x03\x03\x12\x04\xd8\x0c()\nK\n\
    \x04\x04J\x02\x04\x12\x04\xda\x0c\x02-\x1a=\x20All\x20the\x20ground\x20t\
    ruth\x20concepts\x20will\x20be\x20show\x20on\x20the\x20top\x20level\n\n\
    \r\n\x05\x04J\x02\x04\x04\x12\x04\xda\x0c\x02\n\n\r\n\x05\x04J\x02\x04\
    \x06\x12\x04\xda\x0c\x0b\x12\n\r\n\x05\x04J\x02\x04\x01\x12\x04\xda\x0c\
    \x13(\n\r\n\x05\x04J\x02\x04\x03\x12\x04\xda\x0c+,\n\xbe\x01\n\x04\x04J\
    \x02\x05\x12\x04\xde\x0c\x02\x1c\x1a\xaf\x01\x20Only\x20region-based/fra\
    me-based\x20app\x20contains\x20this\x20annotation\n\x20Each\x20annotatio\
    n\x20only\x20contains\x20one\x20region\n\x20And\x20the\x20concepts\x20is\
    \x20in\x20ground_truth_concepts\x20instead\x20of\x20this\x20annotation\n\
    \n\r\n\x05\x04J\x02\x05\x06\x12\x04\xde\x0c\x02\x0c\n\r\n\x05\x04J\x02\
    \x05\x01\x12\x04\xde\x0c\r\x17\n\r\n\x05\x04J\x02\x05\x03\x12\x04\xde\
    \x0c\x1a\x1b\n\xa8\x01\n\x02\x04K\x12\x06\xe4\x0c\0\x86\r\x01\x1a\x99\
    \x01\x20NOTE(Janvier):\x20We\x20copy\x20this\x20from\x20proto/utils/lopq\
    _service.proto\x20instead\x20of\x20importing\x20it\x20because\n\x20we\
    \x20should\x20not\x20import\x20internal\x20protos\x20in\x20public\x20pro\
    tos.\n\n\x0b\n\x03\x04K\x01\x12\x04\xe4\x0c\x08\x16\n:\n\x04\x04K\x02\0\
    \x12\x04\xe6\x0c\x02\x0e\x1a,\x20Rank\x20k\x20for\x20which\x20all\x20met\
    rics\x20are\x20reported.\n\n\r\n\x05\x04K\x02\0\x05\x12\x04\xe6\x0c\x02\
    \x07\n\r\n\x05\x04K\x02\0\x01\x12\x04\xe6\x0c\x08\t\n\r\n\x05\x04K\x02\0\
    \x03\x12\x04\xe6\x0c\x0c\r\nO\n\x04\x04K\x02\x01\x12\x04\xe9\x0c\x02Q\
    \x1aA\x20Recall\x20@\x20k\x20assuming\x20the\x20brute\x20force\x20search\
    \x20is\x20the\x20ground\x20truth.\n\n\r\n\x05\x04K\x02\x01\x05\x12\x04\
    \xe9\x0c\x02\x07\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xe9\x0c\x08\x1d\n\r\
    \n\x05\x04K\x02\x01\x03\x12\x04\xe9\x0c\x20!\n\r\n\x05\x04K\x02\x01\x08\
    \x12\x04\xe9\x0c\"P\n\x10\n\x08\x04K\x02\x01\x08\xd0\x86\x03\x12\x04\xe9\
    \x0c#O\nb\n\x04\x04K\x02\x02\x12\x04\xeb\x0c\x02V\x1aT\x20Kendall's\x20t\
    au\x20correlation\x20@\x20k\x20assuming\x20the\x20brute\x20force\x20sear\
    ch\x20is\x20the\x20ground\x20truth.\n\n\r\n\x05\x04K\x02\x02\x05\x12\x04\
    \xeb\x0c\x02\x07\n\r\n\x05\x04K\x02\x02\x01\x12\x04\xeb\x0c\x08\"\n\r\n\
    \x05\x04K\x02\x02\x03\x12\x04\xeb\x0c%&\n\r\n\x05\x04K\x02\x02\x08\x12\
    \x04\xeb\x0c'U\n\x10\n\x08\x04K\x02\x02\x08\xd0\x86\x03\x12\x04\xeb\x0c(\
    T\n`\n\x04\x04K\x02\x03\x12\x04\xed\x0c\x02V\x1aR\x20The\x20percentage\
    \x20of\x20the\x20most\x20frequent\x20code\x20in\x20the\x20indexed\x20par\
    t\x20of\x20evaluation\x20data.\n\n\r\n\x05\x04K\x02\x03\x05\x12\x04\xed\
    \x0c\x02\x07\n\r\n\x05\x04K\x02\x03\x01\x12\x04\xed\x0c\x08\"\n\r\n\x05\
    \x04K\x02\x03\x03\x12\x04\xed\x0c%&\n\r\n\x05\x04K\x02\x03\x08\x12\x04\
    \xed\x0c'U\n\x10\n\x08\x04K\x02\x03\x08\xd0\x86\x03\x12\x04\xed\x0c(T\n\
    \xa5\x0b\n\x04\x04K\x02\x04\x12\x04\x82\r\x02E\x1a\x96\x0b\x20Normalized\
    \x20Discounted\x20Cumulative\x20Gain\x20(NDCG)\x20@\x20k\x20with\x20a\
    \x20ground\x20truth\x20inferred\x20from\x20annotations\n\x20and/or\x20pr\
    ediction\x20for\x20this\x20evaluation\x20LOPQ\x20model.\n\x20NDCG\x20use\
    s\x20individual\x20relevance\x20scores\x20of\x20each\x20returned\x20imag\
    e\x20to\x20evaluate\x20the\x20usefulness,\x20or\n\x20gain,\x20of\x20a\
    \x20document\x20based\x20on\x20its\x20position\x20in\x20the\x20result\
    \x20list.\x20The\x20premise\x20of\x20DCG\x20is\x20that\n\x20highly\x20re\
    levant\x20documents\x20appearing\x20lower\x20in\x20a\x20search\x20result\
    \x20list\x20should\x20be\x20penalized\x20as\x20the\n\x20graded\x20releva\
    nce\x20value\x20is\x20reduced\x20logarithmically\x20proportional\x20to\
    \x20the\x20position\x20of\x20the\x20result.\n\x20See:\x20https://en.wiki\
    pedia.org/wiki/Information_retrieval#Discounted_cumulative_gain\n\n\x20T\
    o\x20compute\x20the\x20relevance\x20score\x20between\x20two\x20images\
    \x20we\x20consider\x20two\x20cases:\n\x201)\x20Only\x20one\x20label\x20f\
    or\x20each\x20image\n\x20An\x20image\x20is\x20relevant\x20to\x20an\x20im\
    age\x20query\x20iff\x20they\x20are\x20labeled\x20the\x20same\x20(score\
    \x201),\x20and\n\x20not\x20relevant\x20otherwise\x20(score\x200)\n\x202)\
    \x20Multiple\x20labels\x20for\x20each\x20image\n\x20Here\x20an\x20image\
    \x20relevancy\x20with\x20respect\x20to\x20a\x20single\x20image\x20query\
    \x20is\x20measured\x20by\x20f-beta\x20score\n\x20assuming\x20the\x20quer\
    y\x20image\x20list\x20of\x20labels\x20as\x20ground\x20truth\x20and\x20co\
    mparing\x20them\x20with\x20that\x20of\n\x20the\x20search\x20result.\x20T\
    hese\x20labels\x20can\x20come\x20from\x20image\x20annotations\x20or\x20i\
    f\x20substitute_annotation_misses\n\x20is\x20set,\x20predictions\x20of\
    \x20base\x20classifier\x20where\x20any\x20prediction\x20with\x20prob\x20\
    <\x20prob_threshold\x20are\n\x20discarded.\x20To\x20quantify\x20the\x20r\
    elevancy\x20score\x20of\x20a\x20single\x20search\x20result\x20we\x20opt\
    \x20to\x20compute\x20precision\n\x20and\x20recall\x20@\x20k\x20for\x20si\
    mplicity,\x20and\x20combine\x20them\x20with\x20f-beta\x20score\x20to\x20\
    obtain\x20a\x20single\x20number.\n\n\r\n\x05\x04K\x02\x04\x05\x12\x04\
    \x82\r\x02\x07\n\r\n\x05\x04K\x02\x04\x01\x12\x04\x82\r\x08\x11\n\r\n\
    \x05\x04K\x02\x04\x03\x12\x04\x82\r\x14\x15\n\r\n\x05\x04K\x02\x04\x08\
    \x12\x04\x82\r\x16D\n\x10\n\x08\x04K\x02\x04\x08\xd0\x86\x03\x12\x04\x82\
    \r\x17C\nw\n\x04\x04K\x02\x05\x12\x04\x85\r\x02L\x1ai\x20Brute\x20force\
    \x20NDCG\x20which\x20gives\x20a\x20baseline\x20to\x20compare\x20to\x20an\
    d\x20is\x20a\x20measure\x20of\x20how\x20good\n\x20the\x20embeddings\x20a\
    re.\n\n\r\n\x05\x04K\x02\x05\x05\x12\x04\x85\r\x02\x07\n\r\n\x05\x04K\
    \x02\x05\x01\x12\x04\x85\r\x08\x18\n\r\n\x05\x04K\x02\x05\x03\x12\x04\
    \x85\r\x1b\x1c\n\r\n\x05\x04K\x02\x05\x08\x12\x04\x85\r\x1dK\n\x10\n\x08\
    \x04K\x02\x05\x08\xd0\x86\x03\x12\x04\x85\r\x1eJ\nn\n\x02\x04L\x12\x06\
    \x89\r\0\x96\r\x01\x1a`\x20FIXME:\x20copy\x20this\x20into\x20an\x20inter\
    nal\x20proto\x20since\x20it\x20is\x20stored\x20in\x20DB\x20and\x20field\
    \x20names\x20can't\x20change.\n\n\x0b\n\x03\x04L\x01\x12\x04\x89\r\x08\
    \x16\n\x0c\n\x04\x04L\x02\0\x12\x04\x8a\r\x02.\n\r\n\x05\x04L\x02\0\x05\
    \x12\x04\x8a\r\x02\x07\n\r\n\x05\x04L\x02\0\x01\x12\x04\x8a\r\x08\x15\n\
    \r\n\x05\x04L\x02\0\x03\x12\x04\x8a\r\x18\x19\n\r\n\x05\x04L\x02\0\x08\
    \x12\x04\x8a\r\x1a-\n\x0e\n\x06\x04L\x02\0\x08\x03\x12\x04\x8a\r\x1b,\n\
    \x0c\n\x04\x04L\x02\x01\x12\x04\x8b\r\x02.\n\r\n\x05\x04L\x02\x01\x05\
    \x12\x04\x8b\r\x02\x07\n\r\n\x05\x04L\x02\x01\x01\x12\x04\x8b\r\x08\x15\
    \n\r\n\x05\x04L\x02\x01\x03\x12\x04\x8b\r\x18\x19\n\r\n\x05\x04L\x02\x01\
    \x08\x12\x04\x8b\r\x1a-\n\x0e\n\x06\x04L\x02\x01\x08\x03\x12\x04\x8b\r\
    \x1b,\n\x0c\n\x04\x04L\x02\x02\x12\x04\x8c\r\x02M\n\r\n\x05\x04L\x02\x02\
    \x05\x12\x04\x8c\r\x02\x07\n\r\n\x05\x04L\x02\x02\x01\x12\x04\x8c\r\x08\
    \x19\n\r\n\x05\x04L\x02\x02\x03\x12\x04\x8c\r\x1c\x1d\n\r\n\x05\x04L\x02\
    \x02\x08\x12\x04\x8c\r\x1eL\n\x10\n\x08\x04L\x02\x02\x08\xd0\x86\x03\x12\
    \x04\x8c\r\x1fK\n\x0c\n\x04\x04L\x02\x03\x12\x04\x8d\r\x02M\n\r\n\x05\
    \x04L\x02\x03\x05\x12\x04\x8d\r\x02\x07\n\r\n\x05\x04L\x02\x03\x01\x12\
    \x04\x8d\r\x08\x19\n\r\n\x05\x04L\x02\x03\x03\x12\x04\x8d\r\x1c\x1d\n\r\
    \n\x05\x04L\x02\x03\x08\x12\x04\x8d\r\x1eL\n\x10\n\x08\x04L\x02\x03\x08\
    \xd0\x86\x03\x12\x04\x8d\r\x1fK\n\x0c\n\x04\x04L\x02\x04\x12\x04\x8e\r\
    \x02N\n\r\n\x05\x04L\x02\x04\x05\x12\x04\x8e\r\x02\x07\n\r\n\x05\x04L\
    \x02\x04\x01\x12\x04\x8e\r\x08\x1a\n\r\n\x05\x04L\x02\x04\x03\x12\x04\
    \x8e\r\x1d\x1e\n\r\n\x05\x04L\x02\x04\x08\x12\x04\x8e\r\x1fM\n\x10\n\x08\
    \x04L\x02\x04\x08\xd0\x86\x03\x12\x04\x8e\r\x20L\n\x0c\n\x04\x04L\x02\
    \x05\x12\x04\x8f\r\x02N\n\r\n\x05\x04L\x02\x05\x05\x12\x04\x8f\r\x02\x07\
    \n\r\n\x05\x04L\x02\x05\x01\x12\x04\x8f\r\x08\x1a\n\r\n\x05\x04L\x02\x05\
    \x03\x12\x04\x8f\r\x1d\x1e\n\r\n\x05\x04L\x02\x05\x08\x12\x04\x8f\r\x1fM\
    \n\x10\n\x08\x04L\x02\x05\x08\xd0\x86\x03\x12\x04\x8f\r\x20L\n\x0c\n\x04\
    \x04L\x02\x06\x12\x04\x90\r\x02O\n\r\n\x05\x04L\x02\x06\x05\x12\x04\x90\
    \r\x02\x07\n\r\n\x05\x04L\x02\x06\x01\x12\x04\x90\r\x08\x1b\n\r\n\x05\
    \x04L\x02\x06\x03\x12\x04\x90\r\x1e\x1f\n\r\n\x05\x04L\x02\x06\x08\x12\
    \x04\x90\r\x20N\n\x10\n\x08\x04L\x02\x06\x08\xd0\x86\x03\x12\x04\x90\r!M\
    \n\x0c\n\x04\x04L\x02\x07\x12\x04\x91\r\x02L\n\r\n\x05\x04L\x02\x07\x05\
    \x12\x04\x91\r\x02\x07\n\r\n\x05\x04L\x02\x07\x01\x12\x04\x91\r\x08\x18\
    \n\r\n\x05\x04L\x02\x07\x03\x12\x04\x91\r\x1b\x1c\n\r\n\x05\x04L\x02\x07\
    \x08\x12\x04\x91\r\x1dK\n\x10\n\x08\x04L\x02\x07\x08\xd0\x86\x03\x12\x04\
    \x91\r\x1eJ\n\x0c\n\x04\x04L\x02\x08\x12\x04\x92\r\x02'\n\r\n\x05\x04L\
    \x02\x08\x05\x12\x04\x92\r\x02\x07\n\r\n\x05\x04L\x02\x08\x01\x12\x04\
    \x92\r\x08!\n\r\n\x05\x04L\x02\x08\x03\x12\x04\x92\r$&\n\x0c\n\x04\x04L\
    \x02\t\x12\x04\x93\r\x02*\n\r\n\x05\x04L\x02\t\x05\x12\x04\x93\r\x02\x07\
    \n\r\n\x05\x04L\x02\t\x01\x12\x04\x93\r\x08$\n\r\n\x05\x04L\x02\t\x03\
    \x12\x04\x93\r')\n\x0c\n\x04\x04L\x02\n\x12\x04\x95\r\x02+\n\r\n\x05\x04\
    L\x02\n\x04\x12\x04\x95\r\x02\n\n\r\n\x05\x04L\x02\n\x06\x12\x04\x95\r\
    \x0b\x19\n\r\n\x05\x04L\x02\n\x01\x12\x04\x95\r\x1a&\n\r\n\x05\x04L\x02\
    \n\x03\x12\x04\x95\r)*\n\x0c\n\x02\x04M\x12\x06\x98\r\0\xa4\r\x01\n\x0b\
    \n\x03\x04M\x01\x12\x04\x98\r\x08\x13\n\x0c\n\x04\x04M\x02\0\x12\x04\x99\
    \r\x02(\n\r\n\x05\x04M\x02\0\x06\x12\x04\x99\r\x02\x1c\n\r\n\x05\x04M\
    \x02\0\x01\x12\x04\x99\r\x1d#\n\r\n\x05\x04M\x02\0\x03\x12\x04\x99\r&'\n\
    \x0c\n\x04\x04M\x02\x01\x12\x04\x9a\r\x02\x11\n\r\n\x05\x04M\x02\x01\x05\
    \x12\x04\x9a\r\x02\x08\n\r\n\x05\x04M\x02\x01\x01\x12\x04\x9a\r\t\x0b\n\
    \r\n\x05\x04M\x02\x01\x03\x12\x04\x9a\r\x0e\x10\n\x0c\n\x04\x04M\x02\x02\
    \x12\x04\x9b\r\x02\x1d\n\r\n\x05\x04M\x02\x02\x06\x12\x04\x9b\r\x02\x10\
    \n\r\n\x05\x04M\x02\x02\x01\x12\x04\x9b\r\x11\x18\n\r\n\x05\x04M\x02\x02\
    \x03\x12\x04\x9b\r\x1b\x1c\n\x0c\n\x04\x04M\x02\x03\x12\x04\x9c\r\x02'\n\
    \r\n\x05\x04M\x02\x03\x06\x12\x04\x9c\r\x02\x11\n\r\n\x05\x04M\x02\x03\
    \x01\x12\x04\x9c\r\x12\"\n\r\n\x05\x04M\x02\x03\x03\x12\x04\x9c\r%&\n\
    \x0c\n\x04\x04M\x02\x04\x12\x04\x9d\r\x02-\n\r\n\x05\x04M\x02\x04\x06\
    \x12\x04\x9d\r\x02\x14\n\r\n\x05\x04M\x02\x04\x01\x12\x04\x9d\r\x15(\n\r\
    \n\x05\x04M\x02\x04\x03\x12\x04\x9d\r+,\n\x0c\n\x04\x04M\x02\x05\x12\x04\
    \x9e\r\x02%\n\r\n\x05\x04M\x02\x05\x06\x12\x04\x9e\r\x02\x13\n\r\n\x05\
    \x04M\x02\x05\x01\x12\x04\x9e\r\x14\x20\n\r\n\x05\x04M\x02\x05\x03\x12\
    \x04\x9e\r#$\n\x0c\n\x04\x04M\x02\x06\x12\x04\x9f\r\x02,\n\r\n\x05\x04M\
    \x02\x06\x04\x12\x04\x9f\r\x02\n\n\r\n\x05\x04M\x02\x06\x06\x12\x04\x9f\
    \r\x0b\x18\n\r\n\x05\x04M\x02\x06\x01\x12\x04\x9f\r\x19'\n\r\n\x05\x04M\
    \x02\x06\x03\x12\x04\x9f\r*+\n\x0c\n\x04\x04M\x02\x07\x12\x04\xa0\r\x02)\
    \n\r\n\x05\x04M\x02\x07\x04\x12\x04\xa0\r\x02\n\n\r\n\x05\x04M\x02\x07\
    \x06\x12\x04\xa0\r\x0b\x1b\n\r\n\x05\x04M\x02\x07\x01\x12\x04\xa0\r\x1c$\
    \n\r\n\x05\x04M\x02\x07\x03\x12\x04\xa0\r'(\n\x0c\n\x04\x04M\x02\x08\x12\
    \x04\xa1\r\x02-\n\r\n\x05\x04M\x02\x08\x04\x12\x04\xa1\r\x02\n\n\r\n\x05\
    \x04M\x02\x08\x06\x12\x04\xa1\r\x0b\x18\n\r\n\x05\x04M\x02\x08\x01\x12\
    \x04\xa1\r\x19(\n\r\n\x05\x04M\x02\x08\x03\x12\x04\xa1\r+,\n\x0c\n\x04\
    \x04M\x02\t\x12\x04\xa2\r\x02.\n\r\n\x05\x04M\x02\t\x04\x12\x04\xa2\r\
    \x02\n\n\r\n\x05\x04M\x02\t\x06\x12\x04\xa2\r\x0b\x18\n\r\n\x05\x04M\x02\
    \t\x01\x12\x04\xa2\r\x19)\n\r\n\x05\x04M\x02\t\x03\x12\x04\xa2\r,-\n\x0c\
    \n\x04\x04M\x02\n\x12\x04\xa3\r\x02/\n\r\n\x05\x04M\x02\n\x04\x12\x04\
    \xa3\r\x02\n\n\r\n\x05\x04M\x02\n\x06\x12\x04\xa3\r\x0b\x19\n\r\n\x05\
    \x04M\x02\n\x01\x12\x04\xa3\r\x1a)\n\r\n\x05\x04M\x02\n\x03\x12\x04\xa3\
    \r,.\n\x0c\n\x02\x04N\x12\x06\xa8\r\0\xb0\r\x01\n\x0b\n\x03\x04N\x01\x12\
    \x04\xa8\r\x08\x13\n\x0c\n\x04\x04N\x02\0\x12\x04\xa9\r\x02\x1c\n\r\n\
    \x05\x04N\x02\0\x05\x12\x04\xa9\r\x02\x06\n\r\n\x05\x04N\x02\0\x01\x12\
    \x04\xa9\r\x07\x17\n\r\n\x05\x04N\x02\0\x03\x12\x04\xa9\r\x1a\x1b\n\x0c\
    \n\x04\x04N\x02\x01\x12\x04\xaa\r\x02\x1f\n\r\n\x05\x04N\x02\x01\x05\x12\
    \x04\xaa\r\x02\x06\n\r\n\x05\x04N\x02\x01\x01\x12\x04\xaa\r\x07\x1a\n\r\
    \n\x05\x04N\x02\x01\x03\x12\x04\xaa\r\x1d\x1e\n\x0c\n\x04\x04N\x02\x02\
    \x12\x04\xab\r\x02\x18\n\r\n\x05\x04N\x02\x02\x05\x12\x04\xab\r\x02\x06\
    \n\r\n\x05\x04N\x02\x02\x01\x12\x04\xab\r\x07\x13\n\r\n\x05\x04N\x02\x02\
    \x03\x12\x04\xab\r\x16\x17\n\x0c\n\x04\x04N\x02\x03\x12\x04\xac\r\x02\
    \x1a\n\r\n\x05\x04N\x02\x03\x05\x12\x04\xac\r\x02\x06\n\r\n\x05\x04N\x02\
    \x03\x01\x12\x04\xac\r\x07\x15\n\r\n\x05\x04N\x02\x03\x03\x12\x04\xac\r\
    \x18\x19\n\x0c\n\x04\x04N\x02\x04\x12\x04\xad\r\x02\x14\n\r\n\x05\x04N\
    \x02\x04\x05\x12\x04\xad\r\x02\x06\n\r\n\x05\x04N\x02\x04\x01\x12\x04\
    \xad\r\x07\x0f\n\r\n\x05\x04N\x02\x04\x03\x12\x04\xad\r\x12\x13\n\x0c\n\
    \x04\x04N\x02\x05\x12\x04\xae\r\x02\x1b\n\r\n\x05\x04N\x02\x05\x05\x12\
    \x04\xae\r\x02\x06\n\r\n\x05\x04N\x02\x05\x01\x12\x04\xae\r\x07\x16\n\r\
    \n\x05\x04N\x02\x05\x03\x12\x04\xae\r\x19\x1a\n\x0c\n\x04\x04N\x02\x06\
    \x12\x04\xaf\r\x02\x1c\n\r\n\x05\x04N\x02\x06\x05\x12\x04\xaf\r\x02\x06\
    \n\r\n\x05\x04N\x02\x06\x01\x12\x04\xaf\r\x07\x17\n\r\n\x05\x04N\x02\x06\
    \x03\x12\x04\xaf\r\x1a\x1b\n\xae\x02\n\x02\x04O\x12\x06\xba\r\0\xce\r\
    \x01\x1a\xce\x01////////////////////////////////////////////////////////\
    //////////////////////\n\x20Messages\x20from\x20/proto/clarifai/api/outp\
    ut.proto\n//////////////////////////////////////////////////////////////\
    ////////////////\n2O////////////////////////////////////////////////////\
    //////////////////////////\n\n\x0b\n\x03\x04O\x01\x12\x04\xba\r\x08\x0e\
    \n.\n\x04\x04O\x02\0\x12\x04\xbc\r\x02\x10\x1a\x20\x20One\x20of\x20these\
    \x20outputs\x20per\x20Input\n\n\r\n\x05\x04O\x02\0\x05\x12\x04\xbc\r\x02\
    \x08\n\r\n\x05\x04O\x02\0\x01\x12\x04\xbc\r\t\x0b\n\r\n\x05\x04O\x02\0\
    \x03\x12\x04\xbc\r\x0e\x0f\n\x0c\n\x04\x04O\x02\x01\x12\x04\xbd\r\x02(\n\
    \r\n\x05\x04O\x02\x01\x06\x12\x04\xbd\r\x02\x1c\n\r\n\x05\x04O\x02\x01\
    \x01\x12\x04\xbd\r\x1d#\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xbd\r&'\n\x81\
    \x02\n\x04\x04O\x02\x02\x12\x04\xc4\r\x02+\x1a\xf2\x01\x20When\x20the\
    \x20object\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20timestam\
    p\n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\x20f\
    ormat:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20expec\
    t\x20results\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\x20\
    \"2017-04-11T21:50:50.223962Z\"\n\n\r\n\x05\x04O\x02\x02\x06\x12\x04\xc4\
    \r\x02\x1b\n\r\n\x05\x04O\x02\x02\x01\x12\x04\xc4\r\x1c&\n\r\n\x05\x04O\
    \x02\x02\x03\x12\x04\xc4\r)*\n3\n\x04\x04O\x02\x03\x12\x04\xc7\r\x02\x12\
    \x1a%\x20The\x20model\x20that\x20created\x20this\x20Output.\n\n\r\n\x05\
    \x04O\x02\x03\x06\x12\x04\xc7\r\x02\x07\n\r\n\x05\x04O\x02\x03\x01\x12\
    \x04\xc7\r\x08\r\n\r\n\x05\x04O\x02\x03\x03\x12\x04\xc7\r\x10\x11\n\xbb\
    \x01\n\x04\x04O\x02\x04\x12\x04\xca\r\x02\x12\x1a\xac\x01\x20The\x20inpu\
    t\x20that\x20was\x20passed\x20to\x20the\x20model\x20to\x20create\x20this\
    \x20Output.\x20For\x20example\x20if\x20we\x20have\x20an\x20image\n\x20mo\
    del\x20then\x20it\x20will\x20take\x20as\x20input\x20here\x20an\x20Input\
    \x20object\x20with\x20Image\x20filled\x20in.\n\n\r\n\x05\x04O\x02\x04\
    \x06\x12\x04\xca\r\x02\x07\n\r\n\x05\x04O\x02\x04\x01\x12\x04\xca\r\x08\
    \r\n\r\n\x05\x04O\x02\x04\x03\x12\x04\xca\r\x10\x11\n\x86\x01\n\x04\x04O\
    \x02\x05\x12\x04\xcd\r\x02\x10\x1ax\x20The\x20output\x20data\x20for\x20t\
    his\x20Output.\x20For\x20example\x20if\x20we\x20have\x20a\x20concept\x20\
    model\x20then\x20the\x20predicted\n\x20concepts\x20will\x20appear\x20her\
    e.\n\n\r\n\x05\x04O\x02\x05\x06\x12\x04\xcd\r\x02\x06\n\r\n\x05\x04O\x02\
    \x05\x01\x12\x04\xcd\r\x07\x0b\n\r\n\x05\x04O\x02\x05\x03\x12\x04\xcd\r\
    \x0e\x0f\n\xad\x02\n\x02\x04P\x12\x06\xda\r\0\xdf\r\x01\x1a\xcd\x01/////\
    ////////////////////////////////////////////////////////////////////////\
    /\n\x20Messages\x20from\x20/proto/clarifai/api/scope.proto\n////////////\
    //////////////////////////////////////////////////////////////////\n2O//\
    ////////////////////////////////////////////////////////////////////////\
    ////\n\n\x0b\n\x03\x04P\x01\x12\x04\xda\r\x08\x11\n\x19\n\x04\x04P\x02\0\
    \x12\x04\xdc\r\x02\x13\x1a\x0b\x20The\x20scope\n\n\r\n\x05\x04P\x02\0\
    \x05\x12\x04\xdc\r\x02\x08\n\r\n\x05\x04P\x02\0\x01\x12\x04\xdc\r\t\x0e\
    \n\r\n\x05\x04P\x02\0\x03\x12\x04\xdc\r\x11\x12\n/\n\x04\x04P\x02\x01\
    \x12\x04\xde\r\x02'\x1a!\x20Other\x20scopes\x20that\x20are\x20required.\
    \n\n\r\n\x05\x04P\x02\x01\x04\x12\x04\xde\r\x02\n\n\r\n\x05\x04P\x02\x01\
    \x05\x12\x04\xde\r\x0b\x11\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xde\r\x12\
    \"\n\r\n\x05\x04P\x02\x01\x03\x12\x04\xde\r%&\n\x0c\n\x02\x04Q\x12\x06\
    \xe1\r\0\xe6\r\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xe1\r\x08\x14\n/\n\x04\
    \x04Q\x02\0\x12\x04\xe3\r\x02\x16\x1a!\x20The\x20fully\x20qualified\x20e\
    ndpoint\x20to\n\n\r\n\x05\x04Q\x02\0\x05\x12\x04\xe3\r\x02\x08\n\r\n\x05\
    \x04Q\x02\0\x01\x12\x04\xe3\r\t\x11\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xe3\
    \r\x14\x15\n/\n\x04\x04Q\x02\x01\x12\x04\xe5\r\x02'\x1a!\x20Other\x20sco\
    pes\x20that\x20are\x20required.\n\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xe5\
    \r\x02\n\n\r\n\x05\x04Q\x02\x01\x05\x12\x04\xe5\r\x0b\x11\n\r\n\x05\x04Q\
    \x02\x01\x01\x12\x04\xe5\r\x12\"\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xe5\
    \r%&\n\xae\x02\n\x02\x04R\x12\x06\xf2\r\0\x87\x0e\x01\x1a\xce\x01///////\
    ///////////////////////////////////////////////////////////////////////\
    \n\x20Messages\x20from\x20/proto/clarifai/api/search.proto\n////////////\
    //////////////////////////////////////////////////////////////////\n2O//\
    ////////////////////////////////////////////////////////////////////////\
    ////\n\n\x0b\n\x03\x04R\x01\x12\x04\xf2\r\x08\x0b\n\xcf\x05\n\x04\x04R\
    \x02\0\x12\x04\xfc\r\x02A\x1a\xc0\x05\x20This\x20is\x20the\x20score\x20f\
    or\x20the\x20ranked\x20Hit\x20results\x20of\x20the\x20search\x20query.\
    \x20This\x20score\x20is\x20a\x20number\n\x20between\x200.0\x20and\x201.0\
    \x20as\x20it\x20represents\x20a\x20confidence\x20in\x20the\x20search\x20\
    Hit.\x20For\x20example,\x20if\x20you\x20search\n\x20for\x20\"car\"\x20an\
    d\x20get\x20a\x20close\x20matching\x20Hit,\x20the\x20score\x20should\x20\
    be\x20close\x20to\x201.0.\x20If\x20you\x20get\x20a\x20score\n\x20of\x20c\
    lose\x20to\x200.0\x20that\x20means\x20it's\x20very\x20disimilar\x20to\
    \x20your\x20query,\x20in\x20this\x20case\x20NOT\x20a\x20\"car\".\x20Ther\
    e\n\x20is\x20a\x20special\x20intermediate\x20score\x20of\x200.5\x20that\
    \x20means\x20that\x20the\x20Hit\x20is\x20not\x20really\x20correlated\x20\
    with\n\x20your\x20search\x20query\x20(ie.\x20not\x20similar\x20or\x20dis\
    simlar\x20to\x20the\x20query)\x20which\x20is\x20a\x20common\x20occurrenc\
    e\n\x20when\x20using\x20negate\x20queries.\n\x20Note:\x20some\x20queries\
    \x20that\x20are\x20just\x20filtering\x20down\x20your\x20app\x20of\x20inp\
    uts\x20may\x20just\x20return\x20a\x20score\x20of\n\x201.0\x20for\x20all\
    \x20Hits.\n\n\r\n\x05\x04R\x02\0\x05\x12\x04\xfc\r\x02\x07\n\r\n\x05\x04\
    R\x02\0\x01\x12\x04\xfc\r\x08\r\n\r\n\x05\x04R\x02\0\x03\x12\x04\xfc\r\
    \x10\x11\n\r\n\x05\x04R\x02\0\x08\x12\x04\xfc\r\x12@\n\x10\n\x08\x04R\
    \x02\0\x08\xd0\x86\x03\x12\x04\xfc\r\x13?\n\x96\x02\n\x04\x04R\x02\x01\
    \x12\x04\x80\x0e\x02\x12\x1a\x87\x02\x20This\x20is\x20the\x20matched\x20\
    input\x20returned\x20from\x20the\x20search\x20query.\x20This\x20will\x20\
    contain\x20information\x20about\n\x20the\x20Input\x20such\x20as\x20the\
    \x20url,\x20created_at\x20time\x20and\x20trusted\x20annotation\x20inform\
    ation\x20(for\x20backwards\n\x20compatibility\x20with\x20apps\x20that\
    \x20existed\x20before\x20Annotations\x20were\x20introduced.\n\n\r\n\x05\
    \x04R\x02\x01\x06\x12\x04\x80\x0e\x02\x07\n\r\n\x05\x04R\x02\x01\x01\x12\
    \x04\x80\x0e\x08\r\n\r\n\x05\x04R\x02\x01\x03\x12\x04\x80\x0e\x10\x11\n\
    \xc1\x03\n\x04\x04R\x02\x02\x12\x04\x86\x0e\x02\x1c\x1a\xb2\x03\x20We\
    \x20also\x20provide\x20back\x20the\x20specific\x20matched\x20annotation\
    \x20for\x20the\x20above\x20input.\x20We\x20do\x20this\x20in\x20order\n\
    \x20to\x20support\x20more\x20complex\x20Annotation\x20queries\x20in\x20t\
    he\x20And\x20message\x20below.\x20For\x20example\x20if\x20we\x20match\n\
    \x20the\x20search\x20results\x20to\x20a\x20region\x20in\x20your\x20input\
    ,\x20or\x20a\x20frame\x20in\x20a\x20video\x20input,\x20this\x20annotatio\
    n\n\x20field\x20will\x20be\x20that\x20matched\x20annotation\x20info\x20a\
    nd\x20the\x20input\x20will\x20be\x20the\x20image/video\x20that\x20the\
    \x20user\n\x20originally\x20added\x20which\x20contains\x20those\x20regio\
    ns\x20/\x20frames.\n\n\r\n\x05\x04R\x02\x02\x06\x12\x04\x86\x0e\x02\x0c\
    \n\r\n\x05\x04R\x02\x02\x01\x12\x04\x86\x0e\r\x17\n\r\n\x05\x04R\x02\x02\
    \x03\x12\x04\x86\x0e\x1a\x1b\n\xd5\x03\n\x02\x04S\x12\x06\x8e\x0e\0\xaf\
    \x0e\x01\x1a\xc6\x03\x20This\x20is\x20the\x20common\x20building\x20block\
    \x20of\x20a\x20query\x20which\x20is\x20a\x20sequence\x20of\x20And\x20mes\
    sages\x20ANDed\x20together.\n\x20Note\x20that\x20some\x20fields\x20are\
    \x20used\x20too\x20RANK\x20results\x20(affect\x20the\x20scores)\x20and\
    \x20some\x20are\x20used\x20to\x20FILTER\n\x20results\x20(unordered\x20su\
    bset\x20of\x20your\x20app's\x20contents).\x20In\x20general,\x20FILTER\
    \x20operations\x20are\x20more\n\x20efficient\x20queries\x20at\x20scale\
    \x20and\x20when\x20combined\x20with\x20RANK\x20operations\x20can\x20spee\
    d\x20up\x20search\x20performance\n\x20as\x20you\x20effectively\x20operat\
    e\x20on\x20a\x20smaller\x20sub-set\x20of\x20your\x20entire\x20app.\n\n\
    \x0b\n\x03\x04S\x01\x12\x04\x8e\x0e\x08\x0b\n\xb2\x02\n\x04\x04S\x02\0\
    \x12\x04\x93\x0e\x02\x12\x1a\xa3\x02\x20FILTER\x20by\x20input.data...\
    \x20information.\n\x20This\x20can\x20include\x20human\x20provided\x20con\
    cepts,\x20geo\x20location\x20info,\x20metadata,\x20etc.\n\x20This\x20is\
    \x20effectively\x20searching\x20over\x20only\x20the\x20trusted\x20annota\
    tion\x20attached\x20to\x20an\x20input\x20in\x20your\n\x20app.\x20To\x20s\
    earch\x20by\x20more\x20specific\x20annotation\x20fields\x20use\x20the\
    \x20Annotation\x20object\x20here.\n\n\r\n\x05\x04S\x02\0\x06\x12\x04\x93\
    \x0e\x02\x07\n\r\n\x05\x04S\x02\0\x01\x12\x04\x93\x0e\x08\r\n\r\n\x05\
    \x04S\x02\0\x03\x12\x04\x93\x0e\x10\x11\n\xee\x07\n\x04\x04S\x02\x01\x12\
    \x04\x9f\x0e\x02\x14\x1a\xdf\x07\x20RANK\x20based\x20predicted\x20output\
    s\x20from\x20models\x20such\x20as\x20custom\x20trained\x20models,\x20pre\
    -trained\x20models,\n\x20etc.\x20This\x20is\x20also\x20where\x20you\x20e\
    nter\x20the\x20image\x20url\x20for\x20a\x20visual\x20search\x20because\
    \x20what\x20we're\x20asking\n\x20the\x20system\x20to\x20do\x20is\x20find\
    \x20output\x20embedding\x20most\x20visually\x20similar\x20to\x20the\x20p\
    rovided\x20input\x20(that\n\x20input\x20being\x20in\x20And.output.input.\
    data.image.url\x20for\x20example).\x20This\x20will\x20return\x20the\x20H\
    its\n\x20sorted\x20by\x20visual\x20similarity\x20(1.0\x20being\x20very\
    \x20similar\x20or\x20exact\x20match\x20and\x200.0\x20being\x20very\n\x20\
    dissimlar).\x20For\x20a\x20search\x20by\x20Output\x20concept,\x20this\
    \x20means\x20we're\x20asking\x20the\x20system\x20to\x20rank\n\x20the\x20\
    Hits\x20by\x20confidence\x20of\x20our\x20model's\x20predicted\x20Outputs\
    .\x20So\x20for\x20example\x20if\x20the\x20model\n\x20predicts\x20an\x20i\
    mage\x20is\x200.95\x20likely\x20there\x20is\x20a\x20\"dog\"\x20present,\
    \x20that\x20should\x20related\x20directly\n\x20to\x20the\x20score\x20ret\
    urned\x20if\x20you\x20search\x20for\x20Output\x20concept\x20\"dog\"\x20i\
    n\x20your\x20query.\x20This\x20provides\n\x20a\x20natural\x20ranking\x20\
    to\x20search\x20results\x20based\x20on\x20confidence\x20of\x20prediction\
    s\x20from\x20the\x20models\x20and\n\x20is\x20used\x20when\x20ANDing\x20m\
    ultiple\x20of\x20these\x20types\x20of\x20RANK\x20by\x20Output\x20queries\
    \x20together\x20as\x20well.\n\n\r\n\x05\x04S\x02\x01\x06\x12\x04\x9f\x0e\
    \x02\x08\n\r\n\x05\x04S\x02\x01\x01\x12\x04\x9f\x0e\t\x0f\n\r\n\x05\x04S\
    \x02\x01\x03\x12\x04\x9f\x0e\x12\x13\n\x98\x01\n\x04\x04S\x02\x02\x12\
    \x04\xa2\x0e\x02\x12\x1a\x89\x01\x20If\x20True\x20then\x20this\x20will\
    \x20flip\x20the\x20meaning\x20of\x20this\x20part\x20of\x20the\n\x20query\
    .\x20This\x20allow\x20for\x20queries\x20such\x20as\x20dog\x20AND\x20!\
    \x20metadata=={\"blah\":\"value\"}\n\n\r\n\x05\x04S\x02\x02\x05\x12\x04\
    \xa2\x0e\x02\x06\n\r\n\x05\x04S\x02\x02\x01\x12\x04\xa2\x0e\x07\r\n\r\n\
    \x05\x04S\x02\x02\x03\x12\x04\xa2\x0e\x10\x11\n\xa4\x05\n\x04\x04S\x02\
    \x03\x12\x04\xae\x0e\x02\x1c\x1a\x95\x05\x20FILTER\x20by\x20annotation\
    \x20information.\x20This\x20is\x20more\x20flexible\x20than\x20just\x20fi\
    ltering\x20by\n\x20Input\x20information\x20because\x20in\x20the\x20gener\
    al\x20case\x20each\x20input\x20can\x20have\x20several\x20annotations.\n\
    \x20Some\x20example\x20use\x20cases\x20for\x20filtering\x20by\x20annotat\
    ions:\n\x201)\x20find\x20all\x20the\x20inputs\x20annotated\x20\"dog\"\
    \x20by\x20worker_id\x20=\x20\"XYZ\"\n\x202)\x20find\x20all\x20the\x20ann\
    otations\x20associated\x20with\x20embed_model_version_id\x20=\x20\"123\"\
    \n\x203)\x20find\x20all\x20the\x20annotations\x20that\x20are\x20trusted,\
    \x20etc.\n\n\x20Since\x20all\x20the\x20annotations\x20under\x20the\x20ho\
    od\x20are\x20joined\x20to\x20the\x20embedding\x20model's\x20annotation\n\
    \x20using\x20worker_id's\x20of\x20other\x20models\x20like\x20cluster\x20\
    models\x20or\x20concept\x20models\x20should\x20be\n\x20combinable\x20wit\
    h\x20queries\x20like\x20visual\x20search\x20(a\x20query\x20with\x20Outpu\
    t\x20filled\x20in).\n\n\r\n\x05\x04S\x02\x03\x06\x12\x04\xae\x0e\x02\x0c\
    \n\r\n\x05\x04S\x02\x03\x01\x12\x04\xae\x0e\r\x17\n\r\n\x05\x04S\x02\x03\
    \x03\x12\x04\xae\x0e\x1a\x1b\nl\n\x02\x04T\x12\x06\xb5\x0e\0\xc6\x0e\x01\
    \x1a^\x20This\x20is\x20the\x20search\x20query\x20used\x20in\x20/searches\
    ,\x20model\x20training\x20requests,\x20bulk\x20data\x20exports,\x20etc.\
    \n\n\x0b\n\x03\x04T\x01\x12\x04\xb5\x0e\x08\r\n\xa2\x01\n\x04\x04T\x02\0\
    \x12\x04\xb8\x0e\x02\x18\x1a\x93\x01\x20The\x20query\x20syntax\x20is\x20\
    simply\x20a\x20list\x20of\x20And\x20operatiosn\x20that\x20will\x20be\x20\
    ANDed\x20together\x20to\x20fetch\n\x20results\x20which\x20are\x20returne\
    d\x20to\x20the\x20user\x20as\x20Hit\x20messages.\n\n\r\n\x05\x04T\x02\0\
    \x04\x12\x04\xb8\x0e\x02\n\n\r\n\x05\x04T\x02\0\x06\x12\x04\xb8\x0e\x0b\
    \x0e\n\r\n\x05\x04T\x02\0\x01\x12\x04\xb8\x0e\x0f\x13\n\r\n\x05\x04T\x02\
    \0\x03\x12\x04\xb8\x0e\x16\x17\n\xfa\x01\n\x04\x04T\x02\x01\x12\x04\xbd\
    \x0e\x02\x16\x1a\xeb\x01\x20This\x20allows\x20the\x20query\x20to\x20over\
    ride\x20any\x20default\x20language\x20the\x20app\x20was\x20setup\x20in\
    \x20when\x20doing\x20Concept\n\x20based\x20searches.\x20This\x20currentl\
    y\x20only\x20affects\x20public\x20Models\x20Output\x20searches\x20when\
    \x20those\x20public\n\x20Models\x20have\x20translations\x20for\x20their\
    \x20Concepts.\n\n\r\n\x05\x04T\x02\x01\x05\x12\x04\xbd\x0e\x02\x08\n\r\n\
    \x05\x04T\x02\x01\x01\x12\x04\xbd\x0e\t\x11\n\r\n\x05\x04T\x02\x01\x03\
    \x12\x04\xbd\x0e\x14\x15\n]\n\x04\x04T\x02\x02\x12\x04\xc1\x0e\x02\x1e\
    \x1aO\x20filters\x20in\x20this\x20query\n\x20e.q.\x20only\x20fetch\x20an\
    notations\x20that\x20have\x20certain\x20metadata\n\n\r\n\x05\x04T\x02\
    \x02\x04\x12\x04\xc1\x0e\x02\n\n\r\n\x05\x04T\x02\x02\x06\x12\x04\xc1\
    \x0e\x0b\x11\n\r\n\x05\x04T\x02\x02\x01\x12\x04\xc1\x0e\x12\x19\n\r\n\
    \x05\x04T\x02\x02\x03\x12\x04\xc1\x0e\x1c\x1d\nC\n\x04\x04T\x02\x03\x12\
    \x04\xc5\x0e\x02\x1a\x1a5\x20rankings\x20in\x20this\x20query\n\x20e.g.\
    \x20visual\x20search\x20by\x20a\x20url\n\n\r\n\x05\x04T\x02\x03\x04\x12\
    \x04\xc5\x0e\x02\n\n\r\n\x05\x04T\x02\x03\x06\x12\x04\xc5\x0e\x0b\x0f\n\
    \r\n\x05\x04T\x02\x03\x01\x12\x04\xc5\x0e\x10\x15\n\r\n\x05\x04T\x02\x03\
    \x03\x12\x04\xc5\x0e\x18\x19\nE\n\x02\x04U\x12\x06\xc9\x0e\0\xf8\x0e\x01\
    \x1a7\x20This\x20is\x20the\x20new\x20Search\x20object\x20used\x20in\x20s\
    aved\x20searches.\n\n\x0b\n\x03\x04U\x01\x12\x04\xc9\x0e\x08\x0e\n\x1d\n\
    \x04\x04U\x02\0\x12\x04\xcb\x0e\x02\x12\x1a\x0f\x20Search\x20query.\n\n\
    \r\n\x05\x04U\x02\0\x06\x12\x04\xcb\x0e\x02\x07\n\r\n\x05\x04U\x02\0\x01\
    \x12\x04\xcb\x0e\x08\r\n\r\n\x05\x04U\x02\0\x03\x12\x04\xcb\x0e\x10\x11\
    \n\x90\x01\n\x04\x04U\x02\x01\x12\x04\xcf\x0e\x02\x10\x1a\x81\x01\x20Cus\
    tomer\x20facing,\x20external\x20ID\x20for\x20search\x20to\x20be\x20saved\
    .\x20Provided\x20by\x20the\x20user,\x20e.g.\x20\"saved-search-1.\n\x20It\
    \x20is\x20unique\x20per\x20application.\n\n\r\n\x05\x04U\x02\x01\x05\x12\
    \x04\xcf\x0e\x02\x08\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xcf\x0e\t\x0b\n\
    \r\n\x05\x04U\x02\x01\x03\x12\x04\xcf\x0e\x0e\x0f\n8\n\x04\x04U\x02\x02\
    \x12\x04\xd2\x0e\x02\x1c\x1a*\x20Application\x20that\x20owns\x20this\x20\
    saved\x20search.\n\n\r\n\x05\x04U\x02\x02\x05\x12\x04\xd2\x0e\x02\x08\n\
    \r\n\x05\x04U\x02\x02\x01\x12\x04\xd2\x0e\t\x17\n\r\n\x05\x04U\x02\x02\
    \x03\x12\x04\xd2\x0e\x1a\x1b\n@\n\x04\x04U\x02\x03\x12\x04\xd5\x0e\x02\
    \x12\x1a2\x20Human\x20readable\x20display\x20name\x20of\x20the\x20saved\
    \x20search.\n\n\r\n\x05\x04U\x02\x03\x05\x12\x04\xd5\x0e\x02\x08\n\r\n\
    \x05\x04U\x02\x03\x01\x12\x04\xd5\x0e\t\r\n\r\n\x05\x04U\x02\x03\x03\x12\
    \x04\xd5\x0e\x10\x11\n\x87\x01\n\x04\x04U\x02\x04\x12\x04\xd9\x0e\x02&\
    \x1ay\x20\"As\x20of\"\x20timestamp,\x20indicating\x20a\x20time\x20in\x20\
    the\x20past\x20as\x20of\x20which\x20we\x20want\x20to\n\x20retrieve\x20th\
    e\x20annotations\x20satisfying\x20the\x20query.\n\n\r\n\x05\x04U\x02\x04\
    \x06\x12\x04\xd9\x0e\x02\x1b\n\r\n\x05\x04U\x02\x04\x01\x12\x04\xd9\x0e\
    \x1c!\n\r\n\x05\x04U\x02\x04\x03\x12\x04\xd9\x0e$%\n9\n\x04\x04U\x02\x05\
    \x12\x04\xdc\x0e\x02\x16\x1a+\x20Git\x20hash\x20of\x20the\x20code\x20tha\
    t\x20ran\x20the\x20filter.\n\n\r\n\x05\x04U\x02\x05\x05\x12\x04\xdc\x0e\
    \x02\x08\n\r\n\x05\x04U\x02\x05\x01\x12\x04\xdc\x0e\t\x11\n\r\n\x05\x04U\
    \x02\x05\x03\x12\x04\xdc\x0e\x14\x15\n2\n\x04\x04U\x02\x06\x12\x04\xdf\
    \x0e\x02+\x1a$\x20When\x20the\x20saved\x20search\x20was\x20created.\n\n\
    \r\n\x05\x04U\x02\x06\x06\x12\x04\xdf\x0e\x02\x1b\n\r\n\x05\x04U\x02\x06\
    \x01\x12\x04\xdf\x0e\x1c&\n\r\n\x05\x04U\x02\x06\x03\x12\x04\xdf\x0e)*\n\
    2\n\x04\x04U\x02\x07\x12\x04\xe2\x0e\x02,\x1a$\x20When\x20the\x20saved\
    \x20search\x20was\x20updated.\n\n\r\n\x05\x04U\x02\x07\x06\x12\x04\xe2\
    \x0e\x02\x1b\n\r\n\x05\x04U\x02\x07\x01\x12\x04\xe2\x0e\x1c'\n\r\n\x05\
    \x04U\x02\x07\x03\x12\x04\xe2\x0e*+\n\xd8\x02\n\x04\x04U\x02\x08\x12\x04\
    \xe9\x0e\x02\x17\x1a\xc9\x02\x20The\x20search\x20algorithm\x20to\x20be\
    \x20used.\n\x20Options\x20are\x20are\x20'nearest_neighbor',\x20'brute_fo\
    rce',\x20and\x20'avg_concept_brute_force'\n\x20The\x20last\x20two\x20per\
    form\x20a\x20brute\x20force\x20search\x20visual\x20search\x20instead\x20\
    of\x20a\x20more\x20scalable\x20distributed\n\x20nearest\x20neighbor\x20s\
    earch\x20and\x20should\x20be\x20used\x20by\x20advanced\x20users\x20only.\
    \n\x20If\x20not\x20specified\x20we\x20default\x20to\x20nearest\x20neighb\
    or\n\n\r\n\x05\x04U\x02\x08\x05\x12\x04\xe9\x0e\x02\x08\n\r\n\x05\x04U\
    \x02\x08\x01\x12\x04\xe9\x0e\t\x12\n\r\n\x05\x04U\x02\x08\x03\x12\x04\
    \xe9\x0e\x15\x16\nm\n\x04\x04U\x02\t\x12\x04\xed\x0e\x02\x11\x1a_\x20If\
    \x20true,\x20save\x20this\x20search,\x20and\x20exit\x20without\x20execut\
    ing\x20the\x20search.\n\x20If\x20false\x20execute\x20the\x20query\n\n\r\
    \n\x05\x04U\x02\t\x05\x12\x04\xed\x0e\x02\x06\n\r\n\x05\x04U\x02\t\x01\
    \x12\x04\xed\x0e\x07\x0b\n\r\n\x05\x04U\x02\t\x03\x12\x04\xed\x0e\x0e\
    \x10\n\xad\x01\n\x04\x04U\x02\n\x12\x04\xf2\x0e\x02\x17\x1a\x9e\x01\x20M\
    inimum\x20value\x20of\x20confidence\x20threshold\x20score\x20in\x20resul\
    t.\n\x20Defaults\x20to\x200.0\x20which\x20means\x20we\x20won't\x20do\x20\
    any\x20thresholding\x20as\x20all\x20probabilities\x20will\n\x20likely\
    \x20be\x20>\x200.0.\n\n\r\n\x05\x04U\x02\n\x05\x12\x04\xf2\x0e\x02\x07\n\
    \r\n\x05\x04U\x02\n\x01\x12\x04\xf2\x0e\x08\x11\n\r\n\x05\x04U\x02\n\x03\
    \x12\x04\xf2\x0e\x14\x16\n\xdd\x01\n\x04\x04U\x02\x0b\x12\x04\xf7\x0e\
    \x02\x1d\x1a\xce\x01\x20The\x20visibility\x20field\x20represents\x20whet\
    her\x20this\x20message\x20is\x20privately/publicly\x20visible.\n\x20To\
    \x20be\x20visible\x20to\x20the\x20public\x20the\x20App\x20that\x20contai\
    ns\x20it\x20AND\x20the\x20User\x20that\x20contains\x20the\x20App\x20must\
    \n\x20also\x20be\x20publicly\x20visible.\n\n\r\n\x05\x04U\x02\x0b\x06\
    \x12\x04\xf7\x0e\x02\x0c\n\r\n\x05\x04U\x02\x0b\x01\x12\x04\xf7\x0e\r\
    \x17\n\r\n\x05\x04U\x02\x0b\x03\x12\x04\xf7\x0e\x1a\x1c\n\x0c\n\x02\x04V\
    \x12\x06\xfa\x0e\0\x88\x0f\x01\n\x0b\n\x03\x04V\x01\x12\x04\xfa\x0e\x08\
    \x0e\n\x98\x01\n\x04\x04V\x02\0\x12\x04\xfd\x0e\x02\x12\x1a\x89\x01\x20I\
    f\x20True\x20then\x20this\x20will\x20flip\x20the\x20meaning\x20of\x20thi\
    s\x20part\x20of\x20the\n\x20query.\x20This\x20allow\x20for\x20queries\
    \x20such\x20as\x20dog\x20AND\x20!\x20metadata=={\"blah\":\"value\"}\n\n\
    \r\n\x05\x04V\x02\0\x05\x12\x04\xfd\x0e\x02\x06\n\r\n\x05\x04V\x02\0\x01\
    \x12\x04\xfd\x0e\x07\r\n\r\n\x05\x04V\x02\0\x03\x12\x04\xfd\x0e\x10\x11\
    \n1\n\x04\x04V\x02\x01\x12\x04\x80\x0f\x02\x1c\x1a#\x20FILTER\x20by\x20a\
    nnotation\x20information.\n\n\r\n\x05\x04V\x02\x01\x06\x12\x04\x80\x0f\
    \x02\x0c\n\r\n\x05\x04V\x02\x01\x01\x12\x04\x80\x0f\r\x17\n\r\n\x05\x04V\
    \x02\x01\x03\x12\x04\x80\x0f\x1a\x1b\nZ\n\x04\x04V\x02\x02\x12\x04\x84\
    \x0f\x02\x12\x1aL\x20FILTER\x20by\x20input\x20information.\n\x20For\x20e\
    xample\x20you\x20can\x20filter\x20inputs\x20by\x20status,\n\n\r\n\x05\
    \x04V\x02\x02\x06\x12\x04\x84\x0f\x02\x07\n\r\n\x05\x04V\x02\x02\x01\x12\
    \x04\x84\x0f\x08\r\n\r\n\x05\x04V\x02\x02\x03\x12\x04\x84\x0f\x10\x11\n=\
    \n\x04\x04V\x02\x03\x12\x04\x87\x0f\x02(\x1a/\x20Filter\x20by\x20annotat\
    ion\x20last\x20updated\x20time\x20range.\n\n\r\n\x05\x04V\x02\x03\x06\
    \x12\x04\x87\x0f\x02\x0b\n\r\n\x05\x04V\x02\x03\x01\x12\x04\x87\x0f\x0c#\
    \n\r\n\x05\x04V\x02\x03\x03\x12\x04\x87\x0f&'\n\x0c\n\x02\x04W\x12\x06\
    \x8a\x0f\0\x8d\x0f\x01\n\x0b\n\x03\x04W\x01\x12\x04\x8a\x0f\x08\x11\n=\n\
    \x04\x04W\x02\0\x12\x04\x8b\x0f\x02+\"/\x20Begin\x20of\x20the\x20time\
    \x20range,\x20optional,\x20inclusive.\n\n\r\n\x05\x04W\x02\0\x06\x12\x04\
    \x8b\x0f\x02\x1b\n\r\n\x05\x04W\x02\0\x01\x12\x04\x8b\x0f\x1c&\n\r\n\x05\
    \x04W\x02\0\x03\x12\x04\x8b\x0f)*\n;\n\x04\x04W\x02\x01\x12\x04\x8c\x0f\
    \x02)\"-\x20End\x20of\x20the\x20time\x20range,\x20optional,\x20inclusive\
    .\n\n\r\n\x05\x04W\x02\x01\x06\x12\x04\x8c\x0f\x02\x1b\n\r\n\x05\x04W\
    \x02\x01\x01\x12\x04\x8c\x0f\x1c$\n\r\n\x05\x04W\x02\x01\x03\x12\x04\x8c\
    \x0f'(\n\x0c\n\x02\x04X\x12\x06\x8f\x0f\0\x96\x0f\x01\n\x0b\n\x03\x04X\
    \x01\x12\x04\x8f\x0f\x08\x0c\nw\n\x04\x04X\x02\0\x12\x04\x92\x0f\x02\x12\
    \x1ai\x20If\x20True\x20then\x20this\x20will\x20flip\x20the\x20meaning\
    \x20of\x20this\x20part\x20of\x20the\n\x20query.\x20This\x20allow\x20for\
    \x20queries\x20such\x20as\x20!dog\n\n\r\n\x05\x04X\x02\0\x05\x12\x04\x92\
    \x0f\x02\x06\n\r\n\x05\x04X\x02\0\x01\x12\x04\x92\x0f\x07\r\n\r\n\x05\
    \x04X\x02\0\x03\x12\x04\x92\x0f\x10\x11\n/\n\x04\x04X\x02\x01\x12\x04\
    \x95\x0f\x02\x1c\x1a!\x20RANK\x20by\x20annotation\x20information.\n\n\r\
    \n\x05\x04X\x02\x01\x06\x12\x04\x95\x0f\x02\x0c\n\r\n\x05\x04X\x02\x01\
    \x01\x12\x04\x95\x0f\r\x17\n\r\n\x05\x04X\x02\x01\x03\x12\x04\x95\x0f\
    \x1a\x1b\n\x0c\n\x02\x04Y\x12\x06\x98\x0f\0\xad\x0f\x01\n\x0b\n\x03\x04Y\
    \x01\x12\x04\x98\x0f\x08\x1f\n:\n\x04\x04Y\x02\0\x12\x04\x9a\x0f\x02'\
    \x1a,\x20The\x20ground\x20truth\x20we\x20are\x20evaluating\x20against\n\
    \n\r\n\x05\x04Y\x02\0\x06\x12\x04\x9a\x0f\x02\x15\n\r\n\x05\x04Y\x02\0\
    \x01\x12\x04\x9a\x0f\x16\"\n\r\n\x05\x04Y\x02\0\x03\x12\x04\x9a\x0f%&\n)\
    \n\x04\x04Y\x02\x01\x12\x04\x9d\x0f\x02)\x1a\x1b\x20The\x20set\x20we\x20\
    are\x20evaluating\n\n\r\n\x05\x04Y\x02\x01\x06\x12\x04\x9d\x0f\x02\x15\n\
    \r\n\x05\x04Y\x02\x01\x01\x12\x04\x9d\x0f\x16$\n\r\n\x05\x04Y\x02\x01\
    \x03\x12\x04\x9d\x0f'(\n!\n\x04\x04Y\x02\x02\x12\x04\xa0\x0f\x02\x1a\x1a\
    \x13\x20The\x20metric\x20result\n\n\r\n\x05\x04Y\x02\x02\x06\x12\x04\xa0\
    \x0f\x02\r\n\r\n\x05\x04Y\x02\x02\x01\x12\x04\xa0\x0f\x0e\x15\n\r\n\x05\
    \x04Y\x02\x02\x03\x12\x04\xa0\x0f\x18\x19\nM\n\x04\x04Y\x02\x03\x12\x04\
    \xa3\x0f\x02\x10\x1a?\x20data\x20is\x20filled\x20out\x20with\x20the\x20c\
    oncepts\x20used\x20for\x20this\x20evaluation\n\n\r\n\x05\x04Y\x02\x03\
    \x06\x12\x04\xa3\x0f\x02\x06\n\r\n\x05\x04Y\x02\x03\x01\x12\x04\xa3\x0f\
    \x07\x0b\n\r\n\x05\x04Y\x02\x03\x03\x12\x04\xa3\x0f\x0e\x0f\nR\n\x04\x04\
    Y\x02\x04\x12\x04\xa6\x0f\x02\"\x1aD\x20active_concept_count\x20is\x20th\
    e\x20number\x20of\x20concepts\x20for\x20this\x20evaluation\n\n\r\n\x05\
    \x04Y\x02\x04\x05\x12\x04\xa6\x0f\x02\x08\n\r\n\x05\x04Y\x02\x04\x01\x12\
    \x04\xa6\x0f\t\x1d\n\r\n\x05\x04Y\x02\x04\x03\x12\x04\xa6\x0f\x20!\n\xdd\
    \x01\n\x04\x04Y\x02\x05\x12\x04\xac\x0f\x02\x1c\x1a\xce\x01\x20The\x20vi\
    sibility\x20field\x20represents\x20whether\x20this\x20message\x20is\x20p\
    rivately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20p\
    ublic\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20User\x20t\
    hat\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20vis\
    ible.\n\n\r\n\x05\x04Y\x02\x05\x06\x12\x04\xac\x0f\x02\x0c\n\r\n\x05\x04\
    Y\x02\x05\x01\x12\x04\xac\x0f\r\x17\n\r\n\x05\x04Y\x02\x05\x03\x12\x04\
    \xac\x0f\x1a\x1b\n\xac\x02\n\x02\x04Z\x12\x06\xbf\x0f\0\xca\x0f\x01\x1a\
    \xcc\x01////////////////////////////////////////////////////////////////\
    //////////////\n\x20Messages\x20from\x20/proto/clarifai/api/text.proto\n\
    ////////////////////////////////////////////////////////////////////////\
    //////\n2O//////////////////////////////////////////////////////////////\
    ////////////////\n\n\x0b\n\x03\x04Z\x01\x12\x04\xbf\x0f\x08\x0c\n*\n\x04\
    \x04Z\x02\0\x12\x04\xc1\x0f\x02\x11\x1a\x1c\x20This\x20is\x20a\x20raw\
    \x20text\x20string.\n\n\r\n\x05\x04Z\x02\0\x05\x12\x04\xc1\x0f\x02\x08\n\
    \r\n\x05\x04Z\x02\0\x01\x12\x04\xc1\x0f\t\x0c\n\r\n\x05\x04Z\x02\0\x03\
    \x12\x04\xc1\x0f\x0f\x10\n\"\n\x04\x04Z\x02\x01\x12\x04\xc3\x0f\x02\x11\
    \x1a\x14\x20Url\x20to\x20a\x20text\x20file\n\n\r\n\x05\x04Z\x02\x01\x05\
    \x12\x04\xc3\x0f\x02\x08\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\xc3\x0f\t\
    \x0c\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\xc3\x0f\x0f\x10\n\x0c\n\x04\x04Z\
    \x02\x02\x12\x04\xc4\x0f\x02\x1f\n\r\n\x05\x04Z\x02\x02\x05\x12\x04\xc4\
    \x0f\x02\x06\n\r\n\x05\x04Z\x02\x02\x01\x12\x04\xc4\x0f\x07\x1a\n\r\n\
    \x05\x04Z\x02\x02\x03\x12\x04\xc4\x0f\x1d\x1e\n\x80\x01\n\x04\x04Z\x02\
    \x03\x12\x04\xc7\x0f\x02\x17\x1ar\x20The\x20hosted\x20field\x20lists\x20\
    original\x20text\x20hosted\x20in\x20Clarifai\x20storage.\x20This\x20fiel\
    d\x20is\x20currently\x20used\n\x20only\x20in\x20response.\n\n\r\n\x05\
    \x04Z\x02\x03\x06\x12\x04\xc7\x0f\x02\x0b\n\r\n\x05\x04Z\x02\x03\x01\x12\
    \x04\xc7\x0f\x0c\x12\n\r\n\x05\x04Z\x02\x03\x03\x12\x04\xc7\x0f\x15\x16\
    \n\x19\n\x04\x04Z\x02\x04\x12\x04\xc9\x0f\x02\x19\x1a\x0b\x20text\x20inf\
    o\n\n\r\n\x05\x04Z\x02\x04\x06\x12\x04\xc9\x0f\x02\n\n\r\n\x05\x04Z\x02\
    \x04\x01\x12\x04\xc9\x0f\x0b\x14\n\r\n\x05\x04Z\x02\x04\x03\x12\x04\xc9\
    \x0f\x17\x18\n\x0c\n\x02\x04[\x12\x06\xcc\x0f\0\xd1\x0f\x01\n\x0b\n\x03\
    \x04[\x01\x12\x04\xcc\x0f\x08\x10\n+\n\x04\x04[\x02\0\x12\x04\xce\x0f\
    \x02\x17\x1a\x1d\x20count\x20of\x20characters\x20in\x20text\n\n\r\n\x05\
    \x04[\x02\0\x05\x12\x04\xce\x0f\x02\x07\n\r\n\x05\x04[\x02\0\x01\x12\x04\
    \xce\x0f\x08\x12\n\r\n\x05\x04[\x02\0\x03\x12\x04\xce\x0f\x15\x16\n\x1d\
    \n\x04\x04[\x02\x01\x12\x04\xd0\x0f\x02\x16\x1a\x0f\x20text\x20encoding\
    \n\n\r\n\x05\x04[\x02\x01\x05\x12\x04\xd0\x0f\x02\x08\n\r\n\x05\x04[\x02\
    \x01\x01\x12\x04\xd0\x0f\t\x11\n\r\n\x05\x04[\x02\x01\x03\x12\x04\xd0\
    \x0f\x14\x15\n\x0c\n\x02\x05\x04\x12\x06\xda\x0f\0\xe3\x0f\x01\n\x0b\n\
    \x03\x05\x04\x01\x12\x04\xda\x0f\x05\x11\n\x0c\n\x04\x05\x04\x02\0\x12\
    \x04\xdb\x0f\x02\x1d\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xdb\x0f\x02\x18\
    \n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xdb\x0f\x1b\x1c\n#\n\x04\x05\x04\
    \x02\x01\x12\x04\xde\x0f\x02\x16\x1a\x15\x20On\x20Prem\x20event\x20types\
    \n\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\xde\x0f\x02\x11\n\r\n\x05\x05\
    \x04\x02\x01\x02\x12\x04\xde\x0f\x14\x15\n\x0c\n\x04\x05\x04\x02\x02\x12\
    \x04\xdf\x0f\x02\x14\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xdf\x0f\x02\
    \x0f\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xdf\x0f\x12\x13\n\x0c\n\x04\
    \x05\x04\x02\x03\x12\x04\xe0\x0f\x02\x15\n\r\n\x05\x05\x04\x02\x03\x01\
    \x12\x04\xe0\x0f\x02\x10\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\xe0\x0f\
    \x13\x14\n\x0c\n\x02\x05\x05\x12\x06\xe8\x0f\0\xee\x0f\x01\n\x0b\n\x03\
    \x05\x05\x01\x12\x04\xe8\x0f\x05\x16\nb\n\x04\x05\x05\x02\0\x12\x04\xea\
    \x0f\x02\x0c\x1aT\x20undef\x20UsageIntervalType\x20is\x20so\x20that\x20t\
    he\x20interval\x20field\x20can\x20be\x20forced\x20to\x20be\x20included\n\
    \n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xea\x0f\x02\x07\n\r\n\x05\x05\x05\
    \x02\0\x02\x12\x04\xea\x0f\n\x0b\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\xeb\
    \x0f\x02\n\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xeb\x0f\x02\x05\n\r\n\
    \x05\x05\x05\x02\x01\x02\x12\x04\xeb\x0f\x08\t\n\x0c\n\x04\x05\x05\x02\
    \x02\x12\x04\xec\x0f\x02\x0c\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\xec\
    \x0f\x02\x07\n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xec\x0f\n\x0b\n\x0c\n\
    \x04\x05\x05\x02\x03\x12\x04\xed\x0f\x02\x0b\n\r\n\x05\x05\x05\x02\x03\
    \x01\x12\x04\xed\x0f\x02\x06\n\r\n\x05\x05\x05\x02\x03\x02\x12\x04\xed\
    \x0f\t\n\n\xac\x02\n\x02\x04\\\x12\x06\xfb\x0f\0\xac\x10\x01\x1a\xcc\x01\
    ////////////////////////////////////////////////////////////////////////\
    //////\n\x20Messages\x20from\x20/proto/clarifai/api/user.proto\n////////\
    //////////////////////////////////////////////////////////////////////\n\
    2O//////////////////////////////////////////////////////////////////////\
    ////////\n\n\x0b\n\x03\x04\\\x01\x12\x04\xfb\x0f\x08\x0c\n\x0b\n\x03\x04\
    \\\t\x12\x04\xfc\x0f\x02\x0e\n\x0c\n\x04\x04\\\t\0\x12\x04\xfc\x0f\x0b\r\
    \n\r\n\x05\x04\\\t\0\x01\x12\x04\xfc\x0f\x0b\r\n\r\n\x05\x04\\\t\0\x02\
    \x12\x04\xfc\x0f\x0b\r\n\x0c\n\x04\x04\\\x02\0\x12\x04\xfe\x0f\x02\x10\n\
    \r\n\x05\x04\\\x02\0\x05\x12\x04\xfe\x0f\x02\x08\n\r\n\x05\x04\\\x02\0\
    \x01\x12\x04\xfe\x0f\t\x0b\n\r\n\x05\x04\\\x02\0\x03\x12\x04\xfe\x0f\x0e\
    \x0f\n\x0c\n\x04\x04\\\x02\x01\x12\x04\x80\x10\x02/\n\r\n\x05\x04\\\x02\
    \x01\x05\x12\x04\x80\x10\x02\x08\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\x80\
    \x10\t\x16\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\x80\x10\x19\x1a\n\r\n\x05\
    \x04\\\x02\x01\x08\x12\x04\x80\x10\x1b.\n\x0e\n\x06\x04\\\x02\x01\x08\
    \x03\x12\x04\x80\x10\x1c-\n\x0c\n\x04\x04\\\x02\x02\x12\x04\x81\x10\x02\
    \x18\n\r\n\x05\x04\\\x02\x02\x05\x12\x04\x81\x10\x02\x08\n\r\n\x05\x04\\\
    \x02\x02\x01\x12\x04\x81\x10\t\x13\n\r\n\x05\x04\\\x02\x02\x03\x12\x04\
    \x81\x10\x16\x17\n\x0c\n\x04\x04\\\x02\x03\x12\x04\x82\x10\x02\x17\n\r\n\
    \x05\x04\\\x02\x03\x05\x12\x04\x82\x10\x02\x08\n\r\n\x05\x04\\\x02\x03\
    \x01\x12\x04\x82\x10\t\x12\n\r\n\x05\x04\\\x02\x03\x03\x12\x04\x82\x10\
    \x15\x16\n\x0c\n\x04\x04\\\x02\x04\x12\x04\x83\x10\x02\x1a\n\r\n\x05\x04\
    \\\x02\x04\x05\x12\x04\x83\x10\x02\x08\n\r\n\x05\x04\\\x02\x04\x01\x12\
    \x04\x83\x10\t\x15\n\r\n\x05\x04\\\x02\x04\x03\x12\x04\x83\x10\x18\x19\n\
    \x0c\n\x04\x04\\\x02\x05\x12\x04\x84\x10\x02\x18\n\r\n\x05\x04\\\x02\x05\
    \x05\x12\x04\x84\x10\x02\x08\n\r\n\x05\x04\\\x02\x05\x01\x12\x04\x84\x10\
    \t\x12\n\r\n\x05\x04\\\x02\x05\x03\x12\x04\x84\x10\x15\x17\n\x0c\n\x04\
    \x04\\\x02\x06\x12\x04\x85\x10\x02\x17\n\r\n\x05\x04\\\x02\x06\x05\x12\
    \x04\x85\x10\x02\x08\n\r\n\x05\x04\\\x02\x06\x01\x12\x04\x85\x10\t\x11\n\
    \r\n\x05\x04\\\x02\x06\x03\x12\x04\x85\x10\x14\x16\n\x0c\n\x04\x04\\\x02\
    \x07\x12\x04\x87\x10\x02+\n\r\n\x05\x04\\\x02\x07\x05\x12\x04\x87\x10\
    \x02\x08\n\r\n\x05\x04\\\x02\x07\x01\x12\x04\x87\x10\t\x12\n\r\n\x05\x04\
    \\\x02\x07\x03\x12\x04\x87\x10\x15\x16\n\r\n\x05\x04\\\x02\x07\x08\x12\
    \x04\x87\x10\x17*\n\x0e\n\x06\x04\\\x02\x07\x08\x03\x12\x04\x87\x10\x18)\
    \n\xff\x01\n\x04\x04\\\x02\x08\x12\x04\x8e\x10\x02+\x1a\xf0\x01\x20When\
    \x20the\x20user\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20tim\
    estamp\n\x20format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\
    \x20format:\n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20\
    expect\x20results\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\
    \x20\"2017-04-11T21:50:50.223962Z\"\n\n\r\n\x05\x04\\\x02\x08\x06\x12\
    \x04\x8e\x10\x02\x1b\n\r\n\x05\x04\\\x02\x08\x01\x12\x04\x8e\x10\x1c&\n\
    \r\n\x05\x04\\\x02\x08\x03\x12\x04\x8e\x10)*\n\x0c\n\x04\x04\\\x02\t\x12\
    \x04\x8f\x10\x02F\n\r\n\x05\x04\\\x02\t\x06\x12\x04\x8f\x10\x02\x1b\n\r\
    \n\x05\x04\\\x02\t\x01\x12\x04\x8f\x10\x1c-\n\r\n\x05\x04\\\x02\t\x03\
    \x12\x04\x8f\x1001\n\r\n\x05\x04\\\x02\t\x08\x12\x04\x8f\x102E\n\x0e\n\
    \x06\x04\\\x02\t\x08\x03\x12\x04\x8f\x103D\n\x0c\n\x04\x04\\\x02\n\x12\
    \x04\x90\x10\x02E\n\r\n\x05\x04\\\x02\n\x06\x12\x04\x90\x10\x02\x1b\n\r\
    \n\x05\x04\\\x02\n\x01\x12\x04\x90\x10\x1c,\n\r\n\x05\x04\\\x02\n\x03\
    \x12\x04\x90\x10/0\n\r\n\x05\x04\\\x02\n\x08\x12\x04\x90\x101D\n\x0e\n\
    \x06\x04\\\x02\n\x08\x03\x12\x04\x90\x102C\n\x0c\n\x04\x04\\\x02\x0b\x12\
    \x04\x91\x10\x02L\n\r\n\x05\x04\\\x02\x0b\x06\x12\x04\x91\x10\x02\x1b\n\
    \r\n\x05\x04\\\x02\x0b\x01\x12\x04\x91\x10\x1c2\n\r\n\x05\x04\\\x02\x0b\
    \x03\x12\x04\x91\x1057\n\r\n\x05\x04\\\x02\x0b\x08\x12\x04\x91\x108K\n\
    \x0e\n\x06\x04\\\x02\x0b\x08\x03\x12\x04\x91\x109J\n\x9f\x01\n\x04\x04\\\
    \x02\x0c\x12\x04\x95\x10\x02;\x1a\x90\x01\x20To\x20handle\x20arbitrary\
    \x20json\x20metadata\x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20\
    https://github.com/google/protobuf/blob/master/src/google/protobuf/struc\
    t.proto\n\n\r\n\x05\x04\\\x02\x0c\x06\x12\x04\x95\x10\x02\x18\n\r\n\x05\
    \x04\\\x02\x0c\x01\x12\x04\x95\x10\x19!\n\r\n\x05\x04\\\x02\x0c\x03\x12\
    \x04\x95\x10$&\n\r\n\x05\x04\\\x02\x0c\x08\x12\x04\x95\x10':\n\x0e\n\x06\
    \x04\\\x02\x0c\x08\x03\x12\x04\x95\x10(9\n\x0c\n\x04\x04\\\x02\r\x12\x04\
    \x96\x10\x02A\n\r\n\x05\x04\\\x02\r\x04\x12\x04\x96\x10\x02\n\n\r\n\x05\
    \x04\\\x02\r\x06\x12\x04\x96\x10\x0b\x17\n\r\n\x05\x04\\\x02\r\x01\x12\
    \x04\x96\x10\x18'\n\r\n\x05\x04\\\x02\r\x03\x12\x04\x96\x10*,\n\r\n\x05\
    \x04\\\x02\r\x08\x12\x04\x96\x10-@\n\x0e\n\x06\x04\\\x02\r\x08\x03\x12\
    \x04\x96\x10.?\n\x0c\n\x04\x04\\\x02\x0e\x12\x04\x97\x10\x02.\n\r\n\x05\
    \x04\\\x02\x0e\x05\x12\x04\x97\x10\x02\x06\n\r\n\x05\x04\\\x02\x0e\x01\
    \x12\x04\x97\x10\x07\x13\n\r\n\x05\x04\\\x02\x0e\x03\x12\x04\x97\x10\x17\
    \x19\n\r\n\x05\x04\\\x02\x0e\x08\x12\x04\x97\x10\x1a-\n\x0e\n\x06\x04\\\
    \x02\x0e\x08\x03\x12\x04\x97\x10\x1b,\n\x0c\n\x04\x04\\\x02\x0f\x12\x04\
    \x98\x10\x028\n\r\n\x05\x04\\\x02\x0f\x05\x12\x04\x98\x10\x02\x06\n\r\n\
    \x05\x04\\\x02\x0f\x01\x12\x04\x98\x10\x07\x1e\n\r\n\x05\x04\\\x02\x0f\
    \x03\x12\x04\x98\x10!#\n\r\n\x05\x04\\\x02\x0f\x08\x12\x04\x98\x10$7\n\
    \x0e\n\x06\x04\\\x02\x0f\x08\x03\x12\x04\x98\x10%6\n\x0c\n\x04\x04\\\x02\
    \x10\x12\x04\x99\x10\x02.\n\r\n\x05\x04\\\x02\x10\x05\x12\x04\x99\x10\
    \x02\x08\n\r\n\x05\x04\\\x02\x10\x01\x12\x04\x99\x10\t\x14\n\r\n\x05\x04\
    \\\x02\x10\x03\x12\x04\x99\x10\x17\x19\n\r\n\x05\x04\\\x02\x10\x08\x12\
    \x04\x99\x10\x1a-\n\x0e\n\x06\x04\\\x02\x10\x08\x03\x12\x04\x99\x10\x1b,\
    \n\xa0\x01\n\x04\x04\\\x02\x11\x12\x04\x9d\x10\x02\x17\x1a\x91\x01\x20Is\
    \x20starred\x20by\x20the\x20requesting\x20user\x20(only\x20showed\x20on\
    \x20get/list\x20requests)\n\x20Please\x20use\x20PostUserStars/DeleteUser\
    Stars\x20endpoints\x20to\x20star/unstar\x20an\x20user\n\n\r\n\x05\x04\\\
    \x02\x11\x05\x12\x04\x9d\x10\x02\x06\n\r\n\x05\x04\\\x02\x11\x01\x12\x04\
    \x9d\x10\x07\x11\n\r\n\x05\x04\\\x02\x11\x03\x12\x04\x9d\x10\x14\x16\nu\
    \n\x04\x04\\\x02\x12\x12\x04\xa0\x10\x02\x18\x1ag\x20How\x20many\x20user\
    s\x20have\x20starred\x20the\x20user\x20(only\x20showed\x20on\x20get/list\
    \x20requests)\n\x20Computed\x20value,\x20not\x20editable\n\n\r\n\x05\x04\
    \\\x02\x12\x05\x12\x04\xa0\x10\x02\x07\n\r\n\x05\x04\\\x02\x12\x01\x12\
    \x04\xa0\x10\x08\x12\n\r\n\x05\x04\\\x02\x12\x03\x12\x04\xa0\x10\x15\x17\
    \n\xdd\x01\n\x04\x04\\\x02\x13\x12\x04\xa6\x10\x02\x1d\x1a\xce\x01\x20Th\
    e\x20visibility\x20field\x20represents\x20whether\x20this\x20message\x20\
    is\x20privately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20t\
    he\x20public\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20Us\
    er\x20that\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\
    \x20visible.\n\n\r\n\x05\x04\\\x02\x13\x06\x12\x04\xa6\x10\x02\x0c\n\r\n\
    \x05\x04\\\x02\x13\x01\x12\x04\xa6\x10\r\x17\n\r\n\x05\x04\\\x02\x13\x03\
    \x12\x04\xa6\x10\x1a\x1c\n\xce\x01\n\x04\x04\\\x02\x14\x12\x04\xab\x10\
    \x02\x1e\x1a\xbf\x01\x20This\x20is\x20all\x20the\x20personal\x20informat\
    ion\x20of\x20a\x20user.\x20GetUser/ListUsers\x20will\x20not\x20return\
    \x20this\n\x20information\x20unless\x20the\x20caller\x20has\x20the\x20Us\
    erAccounts_Get\x20scope\x20on\x20their\x20key\x20or\x20is\x20the\x20user\
    \n\x20themselves.\n\n\r\n\x05\x04\\\x02\x14\x06\x12\x04\xab\x10\x02\x0c\
    \n\r\n\x05\x04\\\x02\x14\x01\x12\x04\xab\x10\r\x18\n\r\n\x05\x04\\\x02\
    \x14\x03\x12\x04\xab\x10\x1b\x1d\n\xd6\x01\n\x02\x04]\x12\x06\xb0\x10\0\
    \xbf\x10\x01\x1a\xc7\x01\x20This\x20message\x20holds\x20the\x20confident\
    ial\x20information\x20from\x20the\x20User\x20object\x20that\x20we\x20don\
    't\x20want\x20to\x20expose\n\x20to\x20other\x20users.\x20It\x20will\x20b\
    e\x20accessible\x20only\x20from\x20/users/{user_id}/account\x20and\x20wi\
    th\x20the\x20User\x20scopes.\n\n\x0b\n\x03\x04]\x01\x12\x04\xb0\x10\x08\
    \x12\n\x0c\n\x04\x04]\x02\0\x12\x04\xb1\x10\x02\x1c\n\r\n\x05\x04]\x02\0\
    \x05\x12\x04\xb1\x10\x02\x08\n\r\n\x05\x04]\x02\0\x01\x12\x04\xb1\x10\t\
    \x16\n\r\n\x05\x04]\x02\0\x03\x12\x04\xb1\x10\x1a\x1b\n\x0c\n\x04\x04]\
    \x02\x01\x12\x04\xb2\x10\x02\x17\n\r\n\x05\x04]\x02\x01\x05\x12\x04\xb2\
    \x10\x02\x08\n\r\n\x05\x04]\x02\x01\x01\x12\x04\xb2\x10\t\x12\n\r\n\x05\
    \x04]\x02\x01\x03\x12\x04\xb2\x10\x15\x16\n\x0c\n\x04\x04]\x02\x02\x12\
    \x04\xb3\x10\x022\n\r\n\x05\x04]\x02\x02\x06\x12\x04\xb3\x10\x02\x1b\n\r\
    \n\x05\x04]\x02\x02\x01\x12\x04\xb3\x10\x1c-\n\r\n\x05\x04]\x02\x02\x03\
    \x12\x04\xb3\x1001\n\x0c\n\x04\x04]\x02\x03\x12\x04\xb4\x10\x021\n\r\n\
    \x05\x04]\x02\x03\x06\x12\x04\xb4\x10\x02\x1b\n\r\n\x05\x04]\x02\x03\x01\
    \x12\x04\xb4\x10\x1c,\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xb4\x10/0\n\x0c\
    \n\x04\x04]\x02\x04\x12\x04\xb5\x10\x027\n\r\n\x05\x04]\x02\x04\x06\x12\
    \x04\xb5\x10\x02\x1b\n\r\n\x05\x04]\x02\x04\x01\x12\x04\xb5\x10\x1c2\n\r\
    \n\x05\x04]\x02\x04\x03\x12\x04\xb5\x1056\n\x9f\x01\n\x04\x04]\x02\x05\
    \x12\x04\xb8\x10\x02&\x1a\x90\x01\x20To\x20handle\x20arbitrary\x20json\
    \x20metadata\x20you\x20can\x20use\x20a\x20struct\x20field:\n\x20https://\
    github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto\
    \n\n\r\n\x05\x04]\x02\x05\x06\x12\x04\xb8\x10\x02\x18\n\r\n\x05\x04]\x02\
    \x05\x01\x12\x04\xb8\x10\x19!\n\r\n\x05\x04]\x02\x05\x03\x12\x04\xb8\x10\
    $%\n\x0c\n\x04\x04]\x02\x06\x12\x04\xb9\x10\x02,\n\r\n\x05\x04]\x02\x06\
    \x04\x12\x04\xb9\x10\x02\n\n\r\n\x05\x04]\x02\x06\x06\x12\x04\xb9\x10\
    \x0b\x17\n\r\n\x05\x04]\x02\x06\x01\x12\x04\xb9\x10\x18'\n\r\n\x05\x04]\
    \x02\x06\x03\x12\x04\xb9\x10*+\n\x0c\n\x04\x04]\x02\x07\x12\x04\xba\x10\
    \x02\x19\n\r\n\x05\x04]\x02\x07\x05\x12\x04\xba\x10\x02\x06\n\r\n\x05\
    \x04]\x02\x07\x01\x12\x04\xba\x10\x07\x13\n\r\n\x05\x04]\x02\x07\x03\x12\
    \x04\xba\x10\x17\x18\n\x0c\n\x04\x04]\x02\x08\x12\x04\xbb\x10\x02#\n\r\n\
    \x05\x04]\x02\x08\x05\x12\x04\xbb\x10\x02\x06\n\r\n\x05\x04]\x02\x08\x01\
    \x12\x04\xbb\x10\x07\x1e\n\r\n\x05\x04]\x02\x08\x03\x12\x04\xbb\x10!\"\n\
    \x0c\n\x04\x04]\x02\t\x12\x04\xbc\x10\x02\x1a\n\r\n\x05\x04]\x02\t\x05\
    \x12\x04\xbc\x10\x02\x08\n\r\n\x05\x04]\x02\t\x01\x12\x04\xbc\x10\t\x14\
    \n\r\n\x05\x04]\x02\t\x03\x12\x04\xbc\x10\x17\x19\n\x0c\n\x04\x04]\x02\n\
    \x12\x04\xbd\x10\x02\x16\n\r\n\x05\x04]\x02\n\x05\x12\x04\xbd\x10\x02\
    \x08\n\r\n\x05\x04]\x02\n\x01\x12\x04\xbd\x10\t\x10\n\r\n\x05\x04]\x02\n\
    \x03\x12\x04\xbd\x10\x13\x15\n\x0c\n\x04\x04]\x02\x0b\x12\x04\xbe\x10\
    \x02\x14\n\r\n\x05\x04]\x02\x0b\x05\x12\x04\xbe\x10\x02\x08\n\r\n\x05\
    \x04]\x02\x0b\x01\x12\x04\xbe\x10\t\x0e\n\r\n\x05\x04]\x02\x0b\x03\x12\
    \x04\xbe\x10\x11\x13\n\x0c\n\x02\x04^\x12\x06\xc1\x10\0\xc5\x10\x01\n\
    \x0b\n\x03\x04^\x01\x12\x04\xc1\x10\x08\x14\n\x0c\n\x04\x04^\x02\0\x12\
    \x04\xc2\x10\x02B\n\r\n\x05\x04^\x02\0\x05\x12\x04\xc2\x10\x02\x08\n\r\n\
    \x05\x04^\x02\0\x01\x12\x04\xc2\x10\t\x0e\n\r\n\x05\x04^\x02\0\x03\x12\
    \x04\xc2\x10\x11\x12\n\r\n\x05\x04^\x02\0\x08\x12\x04\xc2\x10\x13A\n\x10\
    \n\x08\x04^\x02\0\x08\xd0\x86\x03\x12\x04\xc2\x10\x14@\n\x0c\n\x04\x04^\
    \x02\x01\x12\x04\xc3\x10\x02B\n\r\n\x05\x04^\x02\x01\x05\x12\x04\xc3\x10\
    \x02\x06\n\r\n\x05\x04^\x02\x01\x01\x12\x04\xc3\x10\x07\x0e\n\r\n\x05\
    \x04^\x02\x01\x03\x12\x04\xc3\x10\x11\x12\n\r\n\x05\x04^\x02\x01\x08\x12\
    \x04\xc3\x10\x13A\n\x10\n\x08\x04^\x02\x01\x08\xd0\x86\x03\x12\x04\xc3\
    \x10\x14@\n\x0c\n\x04\x04^\x02\x02\x12\x04\xc4\x10\x02C\n\r\n\x05\x04^\
    \x02\x02\x05\x12\x04\xc4\x10\x02\x06\n\r\n\x05\x04^\x02\x02\x01\x12\x04\
    \xc4\x10\x07\x0f\n\r\n\x05\x04^\x02\x02\x03\x12\x04\xc4\x10\x12\x13\n\r\
    \n\x05\x04^\x02\x02\x08\x12\x04\xc4\x10\x14B\n\x10\n\x08\x04^\x02\x02\
    \x08\xd0\x86\x03\x12\x04\xc4\x10\x15A\n\x0c\n\x02\x04_\x12\x06\xc9\x10\0\
    \xcd\x10\x01\n\x0b\n\x03\x04_\x01\x12\x04\xc9\x10\x08\x10\ng\n\x04\x04_\
    \x02\0\x12\x04\xcc\x10\x02\x17\x1aY\x20TODO(lawrence):\x20merge\x20this\
    \x20with\x20message\x20UserPassword\x20above\n\x20unencrypted\x20passwor\
    d\x20string\n\n\r\n\x05\x04_\x02\0\x05\x12\x04\xcc\x10\x02\x08\n\r\n\x05\
    \x04_\x02\0\x01\x12\x04\xcc\x10\t\x12\n\r\n\x05\x04_\x02\0\x03\x12\x04\
    \xcc\x10\x15\x16\n\x0c\n\x02\x04`\x12\x06\xd3\x10\0\xf0\x10\x01\n\x0b\n\
    \x03\x04`\x01\x12\x04\xd3\x10\x08\x1a\nK\n\x04\x04`\x02\0\x12\x04\xd5\
    \x10\x02\x1a\x1a=\x20when\x20new\x20password\x20length\x20is\x20shorter\
    \x20than\x20minimum\x20length\x20set\n\n\r\n\x05\x04`\x02\0\x05\x12\x04\
    \xd5\x10\x02\x06\n\r\n\x05\x04`\x02\0\x01\x12\x04\xd5\x10\x07\x15\n\r\n\
    \x05\x04`\x02\0\x03\x12\x04\xd5\x10\x18\x19\nJ\n\x04\x04`\x02\x01\x12\
    \x04\xd7\x10\x02\x1a\x1a<\x20when\x20new\x20password\x20length\x20is\x20\
    longer\x20than\x20maximum\x20length\x20set\n\n\r\n\x05\x04`\x02\x01\x05\
    \x12\x04\xd7\x10\x02\x06\n\r\n\x05\x04`\x02\x01\x01\x12\x04\xd7\x10\x07\
    \x15\n\r\n\x05\x04`\x02\x01\x03\x12\x04\xd7\x10\x18\x19\nc\n\x04\x04`\
    \x02\x02\x12\x04\xd9\x10\x02\x1d\x1aU\x20there\x20is\x20no\x20upper\x20c\
    ase\x20letter\x20in\x20the\x20new\x20password\x20when\x20there\x20should\
    \x20be\x20at\x20least\x20one\n\n\r\n\x05\x04`\x02\x02\x05\x12\x04\xd9\
    \x10\x02\x06\n\r\n\x05\x04`\x02\x02\x01\x12\x04\xd9\x10\x07\x18\n\r\n\
    \x05\x04`\x02\x02\x03\x12\x04\xd9\x10\x1b\x1c\nc\n\x04\x04`\x02\x03\x12\
    \x04\xdb\x10\x02\x1d\x1aU\x20there\x20is\x20no\x20lower\x20case\x20lette\
    r\x20in\x20the\x20new\x20password\x20when\x20there\x20should\x20be\x20at\
    \x20least\x20one\n\n\r\n\x05\x04`\x02\x03\x05\x12\x04\xdb\x10\x02\x06\n\
    \r\n\x05\x04`\x02\x03\x01\x12\x04\xdb\x10\x07\x18\n\r\n\x05\x04`\x02\x03\
    \x03\x12\x04\xdb\x10\x1b\x1c\nZ\n\x04\x04`\x02\x04\x12\x04\xdd\x10\x02\
    \x1a\x1aL\x20there\x20is\x20no\x20numerics\x20in\x20the\x20new\x20passwo\
    rd\x20when\x20there\x20should\x20be\x20at\x20least\x20one\n\n\r\n\x05\
    \x04`\x02\x04\x05\x12\x04\xdd\x10\x02\x06\n\r\n\x05\x04`\x02\x04\x01\x12\
    \x04\xdd\x10\x07\x15\n\r\n\x05\x04`\x02\x04\x03\x12\x04\xdd\x10\x18\x19\
    \nc\n\x04\x04`\x02\x05\x12\x04\xdf\x10\x02#\x1aU\x20there\x20is\x20no\
    \x20special\x20character\x20in\x20the\x20new\x20password\x20when\x20ther\
    e\x20should\x20be\x20at\x20least\x20one\n\n\r\n\x05\x04`\x02\x05\x05\x12\
    \x04\xdf\x10\x02\x06\n\r\n\x05\x04`\x02\x05\x01\x12\x04\xdf\x10\x07\x1e\
    \n\r\n\x05\x04`\x02\x05\x03\x12\x04\xdf\x10!\"\n\x84\x01\n\x04\x04`\x02\
    \x06\x12\x04\xe1\x10\x02\x1a\x1av\x20when\x20one\x20of\x20the\x20N\x20mo\
    st\x20recent\x20old\x20password\x20is\x20reused,\x20N\x20is\x20specified\
    \x20by\x20password_reuse_epoch\x20in\x20db.password_policies\n\n\r\n\x05\
    \x04`\x02\x06\x05\x12\x04\xe1\x10\x02\x06\n\r\n\x05\x04`\x02\x06\x01\x12\
    \x04\xe1\x10\x07\x15\n\r\n\x05\x04`\x02\x06\x03\x12\x04\xe1\x10\x18\x19\
    \nY\n\x04\x04`\x02\x07\x12\x04\xe3\x10\x02\x19\x1aK\x20when\x20either\
    \x20user's\x20first,\x20middle\x20or\x20last\x20name\x20is\x20used\x20in\
    \x20the\x20new\x20password\n\n\r\n\x05\x04`\x02\x07\x05\x12\x04\xe3\x10\
    \x02\x06\n\r\n\x05\x04`\x02\x07\x01\x12\x04\xe3\x10\x07\x14\n\r\n\x05\
    \x04`\x02\x07\x03\x12\x04\xe3\x10\x17\x18\n\x7f\n\x04\x04`\x02\x08\x12\
    \x04\xe5\x10\x02\x19\x1aq\x20when\x20first\x20part\x20of\x20user's\x20em\
    ail\x20(exact\x20string\x20or\x20after\x20removing\x20special\x20charact\
    ers)\x20is\x20used\x20in\x20the\x20new\x20password\n\n\r\n\x05\x04`\x02\
    \x08\x05\x12\x04\xe5\x10\x02\x06\n\r\n\x05\x04`\x02\x08\x01\x12\x04\xe5\
    \x10\x07\x14\n\r\n\x05\x04`\x02\x08\x03\x12\x04\xe5\x10\x17\x18\nx\n\x04\
    \x04`\x02\t\x12\x04\xe7\x10\x02!\x1aj\x20when\x20there\x20are\x20confusi\
    ng\x20letters\x20in\x20the\x20new\x20password,\x20such\x20as\x20o\x20(fi\
    rst\x20character\x20of\x20'omega')\x20vs\x200\x20(zero)\n\n\r\n\x05\x04`\
    \x02\t\x05\x12\x04\xe7\x10\x02\x06\n\r\n\x05\x04`\x02\t\x01\x12\x04\xe7\
    \x10\x07\x1b\n\r\n\x05\x04`\x02\t\x03\x12\x04\xe7\x10\x1e\x20\nZ\n\x04\
    \x04`\x02\n\x12\x04\xe9\x10\x02\x20\x1aL\x20when\x20there\x20are\x20simp\
    le\x20password\x20patterns\x20used,\x20such\x20as\x2012345678\x20or\x20a\
    aaaaaa1\n\n\r\n\x05\x04`\x02\n\x05\x12\x04\xe9\x10\x02\x06\n\r\n\x05\x04\
    `\x02\n\x01\x12\x04\xe9\x10\x07\x1a\n\r\n\x05\x04`\x02\n\x03\x12\x04\xe9\
    \x10\x1d\x1f\nL\n\x04\x04`\x02\x0b\x12\x04\xeb\x10\x02\x1d\x1a>\x20when\
    \x20there\x20are\x20common\x20vocabs\x20from\x20the\x20common\x20vocab\
    \x20list\x20used\n\n\r\n\x05\x04`\x02\x0b\x05\x12\x04\xeb\x10\x02\x06\n\
    \r\n\x05\x04`\x02\x0b\x01\x12\x04\xeb\x10\x07\x17\n\r\n\x05\x04`\x02\x0b\
    \x03\x12\x04\xeb\x10\x1a\x1c\nX\n\x04\x04`\x02\x0c\x12\x04\xed\x10\x02\
    \x20\x1aJ\x20when\x20the\x20current\x20password\x20is\x20contained\x20in\
    \x20the\x20new\x20password\x20or\x20vice\x20versa\n\n\r\n\x05\x04`\x02\
    \x0c\x05\x12\x04\xed\x10\x02\x06\n\r\n\x05\x04`\x02\x0c\x01\x12\x04\xed\
    \x10\x07\x1a\n\r\n\x05\x04`\x02\x0c\x03\x12\x04\xed\x10\x1d\x1f\nE\n\x04\
    \x04`\x02\r\x12\x04\xef\x10\x02\x1e\x1a7\x20when\x20password\x20has\x20t\
    o\x20be\x20changed\x20becauase\x20it's\x20too\x20old\n\n\r\n\x05\x04`\
    \x02\r\x05\x12\x04\xef\x10\x02\x06\n\r\n\x05\x04`\x02\r\x01\x12\x04\xef\
    \x10\x07\x18\n\r\n\x05\x04`\x02\r\x03\x12\x04\xef\x10\x1b\x1d\n\xad\x02\
    \n\x02\x04a\x12\x06\xfa\x10\0\x90\x11\x01\x1a\xcd\x01///////////////////\
    ///////////////////////////////////////////////////////////\n\x20Message\
    s\x20from\x20/proto/clarifai/api/video.proto\n//////////////////////////\
    ////////////////////////////////////////////////////\n2O////////////////\
    //////////////////////////////////////////////////////////////\n\n\x0b\n\
    \x03\x04a\x01\x12\x04\xfa\x10\x08\r\n\x86\x01\n\x04\x04a\x02\0\x12\x04\
    \xfd\x10\x02\x11\x1ax\x20This\x20is\x20a\x20URL\x20to\x20a\x20publicly\
    \x20accessible\x20video\x20file.\x20The\x20platform\x20will\x20download\
    \x20this\x20file\x20server\n\x20side\x20and\x20then\x20process.\n\n\r\n\
    \x05\x04a\x02\0\x05\x12\x04\xfd\x10\x02\x08\n\r\n\x05\x04a\x02\0\x01\x12\
    \x04\xfd\x10\t\x0c\n\r\n\x05\x04a\x02\0\x03\x12\x04\xfd\x10\x0f\x10\n\
    \x90\x03\n\x04\x04a\x02\x01\x12\x04\x84\x11\x02\x13\x1a\x81\x03\x20The\
    \x20base64\x20field\x20is\x20using\x20video\x20file\x20bytes\x20directly\
    \x20in\x20the\x20request.\n\x20NOTE:\x20if\x20you're\x20sending\x20a\x20\
    json\x20request,\x20then\x20this\x20MUST\x20be\x20base64\x20encoded\x20b\
    efore\x20sending\x20(hence\n\x20the\x20name\x20here).\n\x20When\x20using\
    \x20our\x20grpc\x20clients,\x20you\x20DO\x20NOT\x20need\x20to\x20base64\
    \x20encode\n\x20it\x20yourself\x20since\x20the\x20clients\x20know\x20how\
    \x20to\x20do\x20this\x20for\x20you\x20automatically\x20and\x20will\x20av\
    oid\x20the\n\x20base64\x20encoding\x20if\x20they\x20send\x20a\x20binary\
    \x20request.\n\n\r\n\x05\x04a\x02\x01\x05\x12\x04\x84\x11\x02\x07\n\r\n\
    \x05\x04a\x02\x01\x01\x12\x04\x84\x11\x08\x0e\n\r\n\x05\x04a\x02\x01\x03\
    \x12\x04\x84\x11\x11\x12\n\x0c\n\x04\x04a\x02\x02\x12\x04\x85\x11\x02\
    \x1f\n\r\n\x05\x04a\x02\x02\x05\x12\x04\x85\x11\x02\x06\n\r\n\x05\x04a\
    \x02\x02\x01\x12\x04\x85\x11\x07\x1a\n\r\n\x05\x04a\x02\x02\x03\x12\x04\
    \x85\x11\x1d\x1e\n\x83\x01\n\x04\x04a\x02\x03\x12\x04\x89\x11\x02\x1b\
    \x1au\x20URL\x20of\x20thumbnail\x20image,\x20which\x20is\x20currently\
    \x20frame\x20at\x20position\x20of\x201s.\x20This\x20field\x20is\x20curre\
    ntly\n\x20used\x20only\x20in\x20response.\n\n\r\n\x05\x04a\x02\x03\x05\
    \x12\x04\x89\x11\x02\x08\n\r\n\x05\x04a\x02\x03\x01\x12\x04\x89\x11\t\
    \x16\n\r\n\x05\x04a\x02\x03\x03\x12\x04\x89\x11\x19\x1a\n\x81\x01\n\x04\
    \x04a\x02\x04\x12\x04\x8c\x11\x02\x17\x1as\x20The\x20hosted\x20field\x20\
    lists\x20original\x20video\x20hosted\x20in\x20Clarifai\x20storage.\x20Th\
    is\x20field\x20is\x20currently\x20used\n\x20only\x20in\x20response.\n\n\
    \r\n\x05\x04a\x02\x04\x06\x12\x04\x8c\x11\x02\x0b\n\r\n\x05\x04a\x02\x04\
    \x01\x12\x04\x8c\x11\x0c\x12\n\r\n\x05\x04a\x02\x04\x03\x12\x04\x8c\x11\
    \x15\x16\n\x1a\n\x04\x04a\x02\x05\x12\x04\x8e\x11\x02\x1b\x1a\x0c\x20vid\
    eo\x20info\n\n\r\n\x05\x04a\x02\x05\x06\x12\x04\x8e\x11\x02\x0b\n\r\n\
    \x05\x04a\x02\x05\x01\x12\x04\x8e\x11\x0c\x16\n\r\n\x05\x04a\x02\x05\x03\
    \x12\x04\x8e\x11\x19\x1a\n\x0c\n\x02\x04b\x12\x06\x92\x11\0\xa1\x11\x01\
    \n\x0b\n\x03\x04b\x01\x12\x04\x92\x11\x08\x11\n\x15\n\x04\x04b\x02\0\x12\
    \x04\x94\x11\x02\x12\x1a\x07\x20width\n\n\r\n\x05\x04b\x02\0\x05\x12\x04\
    \x94\x11\x02\x07\n\r\n\x05\x04b\x02\0\x01\x12\x04\x94\x11\x08\r\n\r\n\
    \x05\x04b\x02\0\x03\x12\x04\x94\x11\x10\x11\n\x16\n\x04\x04b\x02\x01\x12\
    \x04\x96\x11\x02\x13\x1a\x08\x20height\n\n\r\n\x05\x04b\x02\x01\x05\x12\
    \x04\x96\x11\x02\x07\n\r\n\x05\x04b\x02\x01\x01\x12\x04\x96\x11\x08\x0e\
    \n\r\n\x05\x04b\x02\x01\x03\x12\x04\x96\x11\x11\x12\n/\n\x04\x04b\x02\
    \x02\x12\x04\x98\x11\x02\x10\x1a!\x20Frames\x20per\x20second\x20of\x20th\
    e\x20video.\n\n\r\n\x05\x04b\x02\x02\x05\x12\x04\x98\x11\x02\x07\n\r\n\
    \x05\x04b\x02\x02\x01\x12\x04\x98\x11\x08\x0b\n\r\n\x05\x04b\x02\x02\x03\
    \x12\x04\x98\x11\x0e\x0f\n\x1c\n\x04\x04b\x02\x03\x12\x04\x9a\x11\x02\
    \x1a\x1a\x0e\x20video\x20format\n\n\r\n\x05\x04b\x02\x03\x05\x12\x04\x9a\
    \x11\x02\x08\n\r\n\x05\x04b\x02\x03\x01\x12\x04\x9a\x11\t\x15\n\r\n\x05\
    \x04b\x02\x03\x03\x12\x04\x9a\x11\x18\x19\n$\n\x04\x04b\x02\x04\x12\x04\
    \x9c\x11\x02\x15\x1a\x16\x20video\x20track\x20bit\x20rate\n\n\r\n\x05\
    \x04b\x02\x04\x05\x12\x04\x9c\x11\x02\x07\n\r\n\x05\x04b\x02\x04\x01\x12\
    \x04\x9c\x11\x08\x10\n\r\n\x05\x04b\x02\x04\x03\x12\x04\x9c\x11\x13\x14\
    \n!\n\x04\x04b\x02\x05\x12\x04\x9e\x11\x02\x18\x1a\x13\x20video\x20frame\
    \x20count\n\n\r\n\x05\x04b\x02\x05\x05\x12\x04\x9e\x11\x02\x07\n\r\n\x05\
    \x04b\x02\x05\x01\x12\x04\x9e\x11\x08\x13\n\r\n\x05\x04b\x02\x05\x03\x12\
    \x04\x9e\x11\x16\x17\n)\n\x04\x04b\x02\x06\x12\x04\xa0\x11\x02\x1d\x1a\
    \x1b\x20video\x20duration\x20in\x20seconds\n\n\r\n\x05\x04b\x02\x06\x05\
    \x12\x04\xa0\x11\x02\x07\n\r\n\x05\x04b\x02\x06\x01\x12\x04\xa0\x11\x08\
    \x18\n\r\n\x05\x04b\x02\x06\x03\x12\x04\xa0\x11\x1b\x1c\n\xb0\x02\n\x02\
    \x04c\x12\x06\xb1\x11\0\xe4\x11\x01\x1a\xd0\x01/////////////////////////\
    /////////////////////////////////////////////////////\n\x20Messages\x20f\
    rom\x20/proto/clarifai/api/workflow.proto\n/////////////////////////////\
    /////////////////////////////////////////////////\n2O///////////////////\
    ///////////////////////////////////////////////////////////\n\n\x0b\n\
    \x03\x04c\x01\x12\x04\xb1\x11\x08\x10\n*\n\x04\x04c\x02\0\x12\x04\xb3\
    \x11\x02\x10\x1a\x1c\x20The\x20workflows's\x20unique\x20id.\n\n\r\n\x05\
    \x04c\x02\0\x05\x12\x04\xb3\x11\x02\x08\n\r\n\x05\x04c\x02\0\x01\x12\x04\
    \xb3\x11\t\x0b\n\r\n\x05\x04c\x02\0\x03\x12\x04\xb3\x11\x0e\x0f\n/\n\x04\
    \x04c\x02\x01\x12\x04\xb5\x11\x02\x14\x1a!\x20The\x20app\x20the\x20workf\
    low\x20belongs\x20to\n\n\r\n\x05\x04c\x02\x01\x05\x12\x04\xb5\x11\x02\
    \x08\n\r\n\x05\x04c\x02\x01\x01\x12\x04\xb5\x11\t\x0f\n\r\n\x05\x04c\x02\
    \x01\x03\x12\x04\xb5\x11\x12\x13\n\x83\x02\n\x04\x04c\x02\x02\x12\x04\
    \xbc\x11\x02+\x1a\xf4\x01\x20When\x20the\x20workflow\x20was\x20created.\
    \x20We\x20follow\x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\
    \x20https://www.ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15\
    :04:05.999999Z\"\x20so\x20you\x20can\x20expect\x20results\x20like\n\x20t\
    he\x20following\x20from\x20the\x20API:\n\x20\"2017-04-11T21:50:50.223962\
    Z\"\n\n\r\n\x05\x04c\x02\x02\x06\x12\x04\xbc\x11\x02\x1b\n\r\n\x05\x04c\
    \x02\x02\x01\x12\x04\xbc\x11\x1c&\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xbc\
    \x11)*\n\xa1\x01\n\x04\x04c\x02\x03\x12\x04\xc0\x11\x02\"\x1a\x92\x01\
    \x20The\x20list\x20of\x20nodes\x20retrieved\x20from\x20latest\x20workflo\
    w\x20version.\n\x20Each\x20node\x20can\x20specify\x20an\x20input\x20node\
    \x20that\x20it\x20connects\x20to\x20in\x20order\x20to\x20define\x20the\
    \x20graph.\n\n\r\n\x05\x04c\x02\x03\x04\x12\x04\xc0\x11\x02\n\n\r\n\x05\
    \x04c\x02\x03\x06\x12\x04\xc0\x11\x0b\x17\n\r\n\x05\x04c\x02\x03\x01\x12\
    \x04\xc0\x11\x18\x1d\n\r\n\x05\x04c\x02\x03\x03\x12\x04\xc0\x11\x20!\n\
    \x9f\x01\n\x04\x04c\x02\x04\x12\x04\xc4\x11\x02&\x1a\x90\x01\x20To\x20ha\
    ndle\x20arbitrary\x20json\x20metadata\x20you\x20can\x20use\x20a\x20struc\
    t\x20field:\n\x20https://github.com/google/protobuf/blob/master/src/goog\
    le/protobuf/struct.proto\n\n\r\n\x05\x04c\x02\x04\x06\x12\x04\xc4\x11\
    \x02\x18\n\r\n\x05\x04c\x02\x04\x01\x12\x04\xc4\x11\x19!\n\r\n\x05\x04c\
    \x02\x04\x03\x12\x04\xc4\x11$%\n\xdd\x01\n\x04\x04c\x02\x05\x12\x04\xc9\
    \x11\x02\x1c\x1a\xce\x01\x20The\x20visibility\x20field\x20represents\x20\
    whether\x20this\x20message\x20is\x20privately/publicly\x20visible.\n\x20\
    To\x20be\x20visible\x20to\x20the\x20public\x20the\x20App\x20that\x20cont\
    ains\x20it\x20AND\x20the\x20User\x20that\x20contains\x20the\x20App\x20mu\
    st\n\x20also\x20be\x20publicly\x20visible.\n\n\r\n\x05\x04c\x02\x05\x06\
    \x12\x04\xc9\x11\x02\x0c\n\r\n\x05\x04c\x02\x05\x01\x12\x04\xc9\x11\r\
    \x17\n\r\n\x05\x04c\x02\x05\x03\x12\x04\xc9\x11\x1a\x1b\n0\n\x04\x04c\
    \x02\x06\x12\x04\xcc\x11\x02\x15\x1a\"\x20The\x20user\x20the\x20workflow\
    \x20belongs\x20to\n\n\r\n\x05\x04c\x02\x06\x05\x12\x04\xcc\x11\x02\x08\n\
    \r\n\x05\x04c\x02\x06\x01\x12\x04\xcc\x11\t\x10\n\r\n\x05\x04c\x02\x06\
    \x03\x12\x04\xcc\x11\x13\x14\n3\n\x04\x04c\x02\x07\x12\x04\xcf\x11\x02,\
    \x1a%\x20When\x20the\x20workflow\x20was\x20last\x20modified\n\n\r\n\x05\
    \x04c\x02\x07\x06\x12\x04\xcf\x11\x02\x1b\n\r\n\x05\x04c\x02\x07\x01\x12\
    \x04\xcf\x11\x1c'\n\r\n\x05\x04c\x02\x07\x03\x12\x04\xcf\x11*+\n/\n\x04\
    \x04c\x02\x08\x12\x04\xd2\x11\x02\x1e\x1a!\x20Info\x20about\x20the\x20wo\
    rkflow\x20version\n\n\r\n\x05\x04c\x02\x08\x06\x12\x04\xd2\x11\x02\x11\n\
    \r\n\x05\x04c\x02\x08\x01\x12\x04\xd2\x11\x12\x19\n\r\n\x05\x04c\x02\x08\
    \x03\x12\x04\xd2\x11\x1c\x1d\n\xab\x01\n\x04\x04c\x02\t\x12\x04\xd6\x11\
    \x02\x17\x1a\x9c\x01\x20Is\x20starred\x20by\x20the\x20requesting\x20user\
    \x20(only\x20showed\x20on\x20get/list\x20requests)\n\x20Please\x20use\
    \x20PostWorkflowStars/DeleteWorkflowStars\x20endpoints\x20to\x20star/uns\
    tar\x20a\x20workflow\n\n\r\n\x05\x04c\x02\t\x05\x12\x04\xd6\x11\x02\x06\
    \n\r\n\x05\x04c\x02\t\x01\x12\x04\xd6\x11\x07\x11\n\r\n\x05\x04c\x02\t\
    \x03\x12\x04\xd6\x11\x14\x16\ny\n\x04\x04c\x02\n\x12\x04\xd9\x11\x02\x18\
    \x1ak\x20How\x20many\x20users\x20have\x20starred\x20the\x20workflow\x20(\
    only\x20showed\x20on\x20get/list\x20requests)\n\x20Computed\x20value,\
    \x20not\x20editable\n\n\r\n\x05\x04c\x02\n\x05\x12\x04\xd9\x11\x02\x07\n\
    \r\n\x05\x04c\x02\n\x01\x12\x04\xd9\x11\x08\x12\n\r\n\x05\x04c\x02\n\x03\
    \x12\x04\xd9\x11\x15\x17\n5\n\x04\x04c\x02\x0b\x12\x04\xdc\x11\x02\x1a\
    \x1a'\x20Short\x20description\x20about\x20this\x20workflow\n\n\r\n\x05\
    \x04c\x02\x0b\x05\x12\x04\xdc\x11\x02\x08\n\r\n\x05\x04c\x02\x0b\x01\x12\
    \x04\xdc\x11\t\x14\n\r\n\x05\x04c\x02\x0b\x03\x12\x04\xdc\x11\x17\x19\nn\
    \n\x04\x04c\x02\x0c\x12\x04\xe0\x11\x02\x14\x1a`\x20Notes\x20for\x20the\
    \x20workflow\n\x20This\x20field\x20should\x20be\x20used\x20for\x20in-dep\
    th\x20notes\x20and\x20supports\x20up\x20to\x2064Kbs.\n\n\r\n\x05\x04c\
    \x02\x0c\x05\x12\x04\xe0\x11\x02\x08\n\r\n\x05\x04c\x02\x0c\x01\x12\x04\
    \xe0\x11\t\x0e\n\r\n\x05\x04c\x02\x0c\x03\x12\x04\xe0\x11\x11\x13\n,\n\
    \x04\x04c\x02\r\x12\x04\xe3\x11\x02P\x1a\x1e\x20Tags\x20from\x20use_case\
    s\x20category\n\n\r\n\x05\x04c\x02\r\x04\x12\x04\xe3\x11\x02\n\n\r\n\x05\
    \x04c\x02\r\x05\x12\x04\xe3\x11\x0b\x11\n\r\n\x05\x04c\x02\r\x01\x12\x04\
    \xe3\x11\x12\x1b\n\r\n\x05\x04c\x02\r\x03\x12\x04\xe3\x11\x1e\x20\n\r\n\
    \x05\x04c\x02\r\x08\x12\x04\xe3\x11!O\n\x10\n\x08\x04c\x02\r\x08\xd0\x86\
    \x03\x12\x04\xe3\x11\"N\n\x0c\n\x02\x04d\x12\x06\xe6\x11\0\x8e\x12\x01\n\
    \x0b\n\x03\x04d\x01\x12\x04\xe6\x11\x08\x17\n#\n\x04\x04d\x02\0\x12\x04\
    \xe8\x11\x02\x10\x1a\x15\x20Id\x20of\x20this\x20version.\n\n\r\n\x05\x04\
    d\x02\0\x05\x12\x04\xe8\x11\x02\x08\n\r\n\x05\x04d\x02\0\x01\x12\x04\xe8\
    \x11\t\x0b\n\r\n\x05\x04d\x02\0\x03\x12\x04\xe8\x11\x0e\x0f\n-\n\x04\x04\
    d\x02\x01\x12\x04\xeb\x11\x02\x19\x1a\x1f\x20Workflow\x20id\x20for\x20th\
    is\x20version.\n\n\r\n\x05\x04d\x02\x01\x05\x12\x04\xeb\x11\x02\x08\n\r\
    \n\x05\x04d\x02\x01\x01\x12\x04\xeb\x11\t\x14\n\r\n\x05\x04d\x02\x01\x03\
    \x12\x04\xeb\x11\x17\x18\n\x8b\x01\n\x04\x04d\x02\x02\x12\x04\xf0\x11\
    \x02+\x1a}\x20When\x20the\x20version\x20was\x20created.\n\x20The\x20form\
    at\x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"200\
    6-01-02T15:04:05.999999Z\".\n\n\r\n\x05\x04d\x02\x02\x06\x12\x04\xf0\x11\
    \x02\x1b\n\r\n\x05\x04d\x02\x02\x01\x12\x04\xf0\x11\x1c&\n\r\n\x05\x04d\
    \x02\x02\x03\x12\x04\xf0\x11)*\n\x9d\x01\n\x04\x04d\x02\x03\x12\x04\xf5\
    \x11\x02,\x1a\x8e\x01\x20Most\x20recent\x20time\x20when\x20the\x20versio\
    n\x20was\x20updated.\n\x20The\x20format\x20is\x20https://www.ietf.org/rf\
    c/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\".\n\n\r\n\
    \x05\x04d\x02\x03\x06\x12\x04\xf5\x11\x02\x1b\n\r\n\x05\x04d\x02\x03\x01\
    \x12\x04\xf5\x11\x1c'\n\r\n\x05\x04d\x02\x03\x03\x12\x04\xf5\x11*+\n\xdd\
    \x01\n\x04\x04d\x02\x04\x12\x04\xfa\x11\x02\x1c\x1a\xce\x01\x20The\x20vi\
    sibility\x20field\x20represents\x20whether\x20this\x20message\x20is\x20p\
    rivately/publicly\x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20p\
    ublic\x20the\x20App\x20that\x20contains\x20it\x20AND\x20the\x20User\x20t\
    hat\x20contains\x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20vis\
    ible.\n\n\r\n\x05\x04d\x02\x04\x06\x12\x04\xfa\x11\x02\x0c\n\r\n\x05\x04\
    d\x02\x04\x01\x12\x04\xfa\x11\r\x17\n\r\n\x05\x04d\x02\x04\x03\x12\x04\
    \xfa\x11\x1a\x1b\n\x9c\x01\n\x04\x04d\x02\x05\x12\x04\xfe\x11\x02\"\x1a\
    \x8d\x01\x20The\x20list\x20of\x20nodes\x20that\x20make\x20up\x20the\x20w\
    orkflow\x20version.\x20Each\x20node\x20can\x20specify\x20an\x20input\x20\
    node\n\x20that\x20it\x20connects\x20to\x20in\x20order\x20to\x20define\
    \x20the\x20graph.\n\n\r\n\x05\x04d\x02\x05\x04\x12\x04\xfe\x11\x02\n\n\r\
    \n\x05\x04d\x02\x05\x06\x12\x04\xfe\x11\x0b\x17\n\r\n\x05\x04d\x02\x05\
    \x01\x12\x04\xfe\x11\x18\x1d\n\r\n\x05\x04d\x02\x05\x03\x12\x04\xfe\x11\
    \x20!\n\x9f\x01\n\x04\x04d\x02\x06\x12\x04\x82\x12\x02&\x1a\x90\x01\x20T\
    o\x20handle\x20arbitrary\x20json\x20metadata\x20you\x20can\x20use\x20a\
    \x20struct\x20field:\n\x20https://github.com/google/protobuf/blob/master\
    /src/google/protobuf/struct.proto\n\n\r\n\x05\x04d\x02\x06\x06\x12\x04\
    \x82\x12\x02\x18\n\r\n\x05\x04d\x02\x06\x01\x12\x04\x82\x12\x19!\n\r\n\
    \x05\x04d\x02\x06\x03\x12\x04\x82\x12$%\n8\n\x04\x04d\x02\x07\x12\x04\
    \x85\x12\x02\x14\x1a*\x20The\x20app\x20the\x20workflow\x20version\x20bel\
    ongs\x20to.\n\n\r\n\x05\x04d\x02\x07\x05\x12\x04\x85\x12\x02\x08\n\r\n\
    \x05\x04d\x02\x07\x01\x12\x04\x85\x12\t\x0f\n\r\n\x05\x04d\x02\x07\x03\
    \x12\x04\x85\x12\x12\x13\n9\n\x04\x04d\x02\x08\x12\x04\x87\x12\x02\x15\
    \x1a+\x20The\x20user\x20the\x20workflow\x20version\x20belongs\x20to.\n\n\
    \r\n\x05\x04d\x02\x08\x05\x12\x04\x87\x12\x02\x08\n\r\n\x05\x04d\x02\x08\
    \x01\x12\x04\x87\x12\t\x10\n\r\n\x05\x04d\x02\x08\x03\x12\x04\x87\x12\
    \x13\x14\n=\n\x04\x04d\x02\t\x12\x04\x8a\x12\x02\x1a\x1a/\x20Short\x20de\
    scription\x20about\x20this\x20workflow\x20version\n\n\r\n\x05\x04d\x02\t\
    \x05\x12\x04\x8a\x12\x02\x08\n\r\n\x05\x04d\x02\t\x01\x12\x04\x8a\x12\t\
    \x14\n\r\n\x05\x04d\x02\t\x03\x12\x04\x8a\x12\x17\x19\n;\n\x04\x04d\x02\
    \n\x12\x04\x8d\x12\x02\x16\x1a-\x20License\x20associated\x20to\x20this\
    \x20workflow\x20version\n\n\r\n\x05\x04d\x02\n\x05\x12\x04\x8d\x12\x02\
    \x08\n\r\n\x05\x04d\x02\n\x01\x12\x04\x8d\x12\t\x10\n\r\n\x05\x04d\x02\n\
    \x03\x12\x04\x8d\x12\x13\x15\n\x0c\n\x02\x04e\x12\x06\x90\x12\0\x9e\x12\
    \x01\n\x0b\n\x03\x04e\x01\x12\x04\x90\x12\x08\x14\nl\n\x04\x04e\x02\0\
    \x12\x04\x93\x12\x02\x10\x1a^\x20An\x20identifier\x20for\x20this\x20node\
    \x20in\x20the\x20graph.\x20This\x20is\x20used\x20when\x20connecting\x20N\
    odeInputs\n\x20together.\n\n\r\n\x05\x04e\x02\0\x05\x12\x04\x93\x12\x02\
    \x08\n\r\n\x05\x04e\x02\0\x01\x12\x04\x93\x12\t\x0b\n\r\n\x05\x04e\x02\0\
    \x03\x12\x04\x93\x12\x0e\x0f\n\x84\x01\n\x04\x04e\x02\x01\x12\x04\x97\
    \x12\x02\x12\x1av\x20The\x20model\x20that\x20will\x20do\x20the\x20proces\
    sing\x20at\x20this\x20node.\x20We\x20only\x20vlidate\x20the\x20model.id\
    \x20and\n\x20model.model_version.id\x20fields.\n\n\r\n\x05\x04e\x02\x01\
    \x06\x12\x04\x97\x12\x02\x07\n\r\n\x05\x04e\x02\x01\x01\x12\x04\x97\x12\
    \x08\r\n\r\n\x05\x04e\x02\x01\x03\x12\x04\x97\x12\x10\x11\n\x94\x01\n\
    \x04\x04e\x02\x02\x12\x04\x9b\x12\x02%\x1a\x85\x01\x20Each\x20WorkflowNo\
    de\x20can\x20connect\x20to\x20multiple\x20input\x20nodes\x20so\x20that\
    \x20we\x20can\x20handle\x20multi-model\x20data\n\x20and\x20more\x20compl\
    ex\x20workflow\x20operations.\n\n\r\n\x05\x04e\x02\x02\x04\x12\x04\x9b\
    \x12\x02\n\n\r\n\x05\x04e\x02\x02\x06\x12\x04\x9b\x12\x0b\x14\n\r\n\x05\
    \x04e\x02\x02\x01\x12\x04\x9b\x12\x15\x20\n\r\n\x05\x04e\x02\x02\x03\x12\
    \x04\x9b\x12#$\n;\n\x04\x04e\x02\x03\x12\x04\x9d\x12\x02\x1b\x1a-\x20sup\
    press\x20the\x20output\x20for\x20workflow\x20prediction\n\n\r\n\x05\x04e\
    \x02\x03\x05\x12\x04\x9d\x12\x02\x06\n\r\n\x05\x04e\x02\x03\x01\x12\x04\
    \x9d\x12\x07\x16\n\r\n\x05\x04e\x02\x03\x03\x12\x04\x9d\x12\x19\x1a\nC\n\
    \x02\x04f\x12\x06\xa1\x12\0\xa4\x12\x01\x1a5\x20NodeInput\x20represents\
    \x20inputs\x20to\x20a\x20node\x20of\x20the\x20graph.\n\n\x0b\n\x03\x04f\
    \x01\x12\x04\xa1\x12\x08\x11\nk\n\x04\x04f\x02\0\x12\x04\xa3\x12\x02\x15\
    \x1a]\x20The\x20id\x20to\x20a\x20connected\x20WorkflowNode\x20which\x20w\
    ill\x20be\x20used\x20as\x20an\x20input\x20for\x20current\x20WorkflowNode\
    .\n\n\r\n\x05\x04f\x02\0\x05\x12\x04\xa3\x12\x02\x08\n\r\n\x05\x04f\x02\
    \0\x01\x12\x04\xa3\x12\t\x10\n\r\n\x05\x04f\x02\0\x03\x12\x04\xa3\x12\
    \x13\x14\n\x0c\n\x02\x04g\x12\x06\xa6\x12\0\xb4\x12\x01\n\x0b\n\x03\x04g\
    \x01\x12\x04\xa6\x12\x08\x16\n\x0c\n\x04\x04g\x02\0\x12\x04\xa7\x12\x02\
    \x10\n\r\n\x05\x04g\x02\0\x05\x12\x04\xa7\x12\x02\x08\n\r\n\x05\x04g\x02\
    \0\x01\x12\x04\xa7\x12\t\x0b\n\r\n\x05\x04g\x02\0\x03\x12\x04\xa7\x12\
    \x0e\x0f\n\x0c\n\x04\x04g\x02\x01\x12\x04\xa8\x12\x02(\n\r\n\x05\x04g\
    \x02\x01\x06\x12\x04\xa8\x12\x02\x1c\n\r\n\x05\x04g\x02\x01\x01\x12\x04\
    \xa8\x12\x1d#\n\r\n\x05\x04g\x02\x01\x03\x12\x04\xa8\x12&'\n\x81\x02\n\
    \x04\x04g\x02\x02\x12\x04\xae\x12\x02+\x1a\xf2\x01\x20When\x20the\x20obj\
    ect\x20was\x20created.\x20We\x20follow\x20the\x20XXXX\x20timestamp\n\x20\
    format.\x20We\x20use\x20https://www.ietf.org/rfc/rfc3339.txt\x20format:\
    \n\x20\"2006-01-02T15:04:05.999999Z\"\x20so\x20you\x20can\x20expect\x20r\
    esults\x20like\n\x20the\x20following\x20from\x20the\x20API:\n\x20\"2017-\
    04-11T21:50:50.223962Z\"\n\n\r\n\x05\x04g\x02\x02\x06\x12\x04\xae\x12\
    \x02\x1b\n\r\n\x05\x04g\x02\x02\x01\x12\x04\xae\x12\x1c&\n\r\n\x05\x04g\
    \x02\x02\x03\x12\x04\xae\x12)*\n\x0c\n\x04\x04g\x02\x03\x12\x04\xaf\x12\
    \x02\x12\n\r\n\x05\x04g\x02\x03\x06\x12\x04\xaf\x12\x02\x07\n\r\n\x05\
    \x04g\x02\x03\x01\x12\x04\xaf\x12\x08\r\n\r\n\x05\x04g\x02\x03\x03\x12\
    \x04\xaf\x12\x10\x11\n\x0c\n\x04\x04g\x02\x04\x12\x04\xb0\x12\x02\x12\n\
    \r\n\x05\x04g\x02\x04\x06\x12\x04\xb0\x12\x02\x07\n\r\n\x05\x04g\x02\x04\
    \x01\x12\x04\xb0\x12\x08\r\n\r\n\x05\x04g\x02\x04\x03\x12\x04\xb0\x12\
    \x10\x11\n\x0c\n\x04\x04g\x02\x05\x12\x04\xb1\x12\x02\x1e\n\r\n\x05\x04g\
    \x02\x05\x04\x12\x04\xb1\x12\x02\n\n\r\n\x05\x04g\x02\x05\x06\x12\x04\
    \xb1\x12\x0b\x11\n\r\n\x05\x04g\x02\x05\x01\x12\x04\xb1\x12\x12\x19\n\r\
    \n\x05\x04g\x02\x05\x03\x12\x04\xb1\x12\x1c\x1d\nC\n\x04\x04g\x02\x06\
    \x12\x04\xb3\x12\x02\x1b\x1a5\x20Indicate\x20if\x20the\x20output\x20of\
    \x20this\x20model\x20is\x20suppressed.\n\n\r\n\x05\x04g\x02\x06\x05\x12\
    \x04\xb3\x12\x02\x06\n\r\n\x05\x04g\x02\x06\x01\x12\x04\xb3\x12\x07\x16\
    \n\r\n\x05\x04g\x02\x06\x03\x12\x04\xb3\x12\x19\x1a\n\x0c\n\x02\x04h\x12\
    \x06\xb7\x12\0\xbd\x12\x01\n\x0b\n\x03\x04h\x01\x12\x04\xb7\x12\x08\x15\
    \n\xad\x02\n\x04\x04h\x02\0\x12\x04\xbc\x12\x02\x10\x1a\x9e\x02\x20A\x20\
    unique\x20ID\x20for\x20the\x20workflow\x20state.\n\x20To\x20start\x20sav\
    ing\x20a\x20state\x20in\x20a\x20PostWorkflowResults\x20request\x20set\
    \x20this\x20ID\x20to\x20\"init\"\n\x20and\x20it\x20will\x20return\x20a\
    \x20newly\x20generated\x20unique\x20state\x20id\x20that\x20you\x20can\
    \x20then\x20pass\x20in\x20subsequent\n\x20PostWorkflowResults\x20calls.\
    \x20These\x20state\x20expire\x20after\x205\x20minutes\x20between\x20call\
    s.\n\n\r\n\x05\x04h\x02\0\x05\x12\x04\xbc\x12\x02\x08\n\r\n\x05\x04h\x02\
    \0\x01\x12\x04\xbc\x12\t\x0b\n\r\n\x05\x04h\x02\0\x03\x12\x04\xbc\x12\
    \x0e\x0f\n\x8f\x02\n\x02\x04i\x12\x06\xc9\x12\0\xd8\x12\x012O///////////\
    ///////////////////////////////////////////////////////////////////\n2\
    \xaf\x01////////////////////////////////////////////////////////////////\
    //////////////\n\x20App\x20Duplication\n////////////////////////////////\
    //////////////////////////////////////////////\n\n\x0b\n\x03\x04i\x01\
    \x12\x04\xc9\x12\x08\x16\n(\n\x04\x04i\x02\0\x12\x04\xcb\x12\x02\x10\x1a\
    \x1athe\x20id\x20of\x20app\x20duplication\n\n\r\n\x05\x04i\x02\0\x05\x12\
    \x04\xcb\x12\x02\x08\n\r\n\x05\x04i\x02\0\x01\x12\x04\xcb\x12\t\x0b\n\r\
    \n\x05\x04i\x02\0\x03\x12\x04\xcb\x12\x0e\x0f\n\x20\n\x04\x04i\x02\x01\
    \x12\x04\xcd\x12\x02\x18\x1a\x12the\x20id\x20of\x20new\x20app\n\n\r\n\
    \x05\x04i\x02\x01\x05\x12\x04\xcd\x12\x02\x08\n\r\n\x05\x04i\x02\x01\x01\
    \x12\x04\xcd\x12\t\x13\n\r\n\x05\x04i\x02\x01\x03\x12\x04\xcd\x12\x16\
    \x17\n\"\n\x04\x04i\x02\x02\x12\x04\xcf\x12\x02\x1a\x1a\x14the\x20name\
    \x20of\x20new\x20app\n\n\r\n\x05\x04i\x02\x02\x05\x12\x04\xcf\x12\x02\
    \x08\n\r\n\x05\x04i\x02\x02\x01\x12\x04\xcf\x12\t\x15\n\r\n\x05\x04i\x02\
    \x02\x03\x12\x04\xcf\x12\x18\x19\n,\n\x04\x04i\x02\x03\x12\x04\xd1\x12\
    \x02(\x1a\x1ethe\x20status\x20of\x20app\x20duplication\n\n\r\n\x05\x04i\
    \x02\x03\x06\x12\x04\xd1\x12\x02\x1c\n\r\n\x05\x04i\x02\x03\x01\x12\x04\
    \xd1\x12\x1d#\n\r\n\x05\x04i\x02\x03\x03\x12\x04\xd1\x12&'\n4\n\x04\x04i\
    \x02\x04\x12\x04\xd3\x12\x02+\x1a&when\x20is\x20the\x20app\x20duplicatio\
    n\x20triggered\n\n\r\n\x05\x04i\x02\x04\x06\x12\x04\xd3\x12\x02\x1b\n\r\
    \n\x05\x04i\x02\x04\x01\x12\x04\xd3\x12\x1c&\n\r\n\x05\x04i\x02\x04\x03\
    \x12\x04\xd3\x12)*\n;\n\x04\x04i\x02\x05\x12\x04\xd5\x12\x021\x1a-The\
    \x20last\x20time\x20when\x20is\x20the\x20status\x20got\x20updated\n\n\r\
    \n\x05\x04i\x02\x05\x06\x12\x04\xd5\x12\x02\x1b\n\r\n\x05\x04i\x02\x05\
    \x01\x12\x04\xd5\x12\x1c,\n\r\n\x05\x04i\x02\x05\x03\x12\x04\xd5\x12/0\n\
    <\n\x04\x04i\x02\x06\x12\x04\xd7\x12\x02#\x1a.\x20Only\x20copy\x20resour\
    ces\x20depending\x20on\x20the\x20filters\n\n\r\n\x05\x04i\x02\x06\x06\
    \x12\x04\xd7\x12\x02\x17\n\r\n\x05\x04i\x02\x06\x01\x12\x04\xd7\x12\x18\
    \x1e\n\r\n\x05\x04i\x02\x06\x03\x12\x04\xd7\x12!\"\n\x0c\n\x02\x04j\x12\
    \x06\xda\x12\0\xe5\x12\x01\n\x0b\n\x03\x04j\x01\x12\x04\xda\x12\x08\x1d\
    \n8\n\x04\x04j\x02\0\x12\x04\xdc\x12\x02\x17\x1a*\x20Copy\x20only\x20inp\
    uts\x20and\x20default\x20annotations\n\n\r\n\x05\x04j\x02\0\x05\x12\x04\
    \xdc\x12\x02\x06\n\r\n\x05\x04j\x02\0\x01\x12\x04\xdc\x12\x07\x12\n\r\n\
    \x05\x04j\x02\0\x03\x12\x04\xdc\x12\x15\x16\n\"\n\x04\x04j\x02\x01\x12\
    \x04\xde\x12\x02\x19\x1a\x14\x20Copy\x20only\x20concepts\n\n\r\n\x05\x04\
    j\x02\x01\x05\x12\x04\xde\x12\x02\x06\n\r\n\x05\x04j\x02\x01\x01\x12\x04\
    \xde\x12\x07\x14\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xde\x12\x17\x18\nL\n\
    \x04\x04j\x02\x02\x12\x04\xe0\x12\x02\x1c\x1a>\x20Copy\x20annotations\
    \x20and\x20what\x20it\x20depends\x20on:\x20inputs\x20and\x20concepts\n\n\
    \r\n\x05\x04j\x02\x02\x05\x12\x04\xe0\x12\x02\x06\n\r\n\x05\x04j\x02\x02\
    \x01\x12\x04\xe0\x12\x07\x17\n\r\n\x05\x04j\x02\x02\x03\x12\x04\xe0\x12\
    \x1a\x1b\n<\n\x04\x04j\x02\x03\x12\x04\xe2\x12\x02\x17\x1a.\x20Copy\x20m\
    odels\x20and\x20what\x20it\x20depends\x20on:\x20concepts\n\n\r\n\x05\x04\
    j\x02\x03\x05\x12\x04\xe2\x12\x02\x06\n\r\n\x05\x04j\x02\x03\x01\x12\x04\
    \xe2\x12\x07\x12\n\r\n\x05\x04j\x02\x03\x03\x12\x04\xe2\x12\x15\x16\nJ\n\
    \x04\x04j\x02\x04\x12\x04\xe4\x12\x02\x1a\x1a<\x20Copy\x20workflows\x20a\
    nd\x20what\x20it\x20depends\x20on:\x20models\x20and\x20concepts\n\n\r\n\
    \x05\x04j\x02\x04\x05\x12\x04\xe4\x12\x02\x06\n\r\n\x05\x04j\x02\x04\x01\
    \x12\x04\xe4\x12\x07\x15\n\r\n\x05\x04j\x02\x04\x03\x12\x04\xe4\x12\x18\
    \x19\n\x81\x02\n\x02\x04k\x12\x06\xf1\x12\0\xb3\x13\x01\x1aK\x20Task\x20\
    is\x20the\x20work\x20that\x20needs\x20to\x20be\x20done\x20for\x20labelin\
    g\x20the\x20inputs\x20in\x20an\x20app.\n2\xa5\x01///////////////////////\
    ///////////////////////////////////////////////////////\n\x20Tasks\n////\
    ////////////////////////////////////////////////////////////////////////\
    //\n\n\x0b\n\x03\x04k\x01\x12\x04\xf1\x12\x08\x0c\n'\n\x04\x04k\x02\0\
    \x12\x04\xf3\x12\x02\x10\x1a\x19\x20Unique\x20ID\x20for\x20the\x20task.\
    \n\n\r\n\x05\x04k\x02\0\x05\x12\x04\xf3\x12\x02\x08\n\r\n\x05\x04k\x02\0\
    \x01\x12\x04\xf3\x12\t\x0b\n\r\n\x05\x04k\x02\0\x03\x12\x04\xf3\x12\x0e\
    \x0f\n\x88\x01\n\x04\x04k\x02\x01\x12\x04\xf8\x12\x02+\x1az\x20When\x20t\
    he\x20task\x20was\x20created.\n\x20The\x20format\x20is\x20https://www.ie\
    tf.org/rfc/rfc3339.txt.\n\x20Example:\x20\"2006-01-02T15:04:05.999999Z\"\
    .\n\n\r\n\x05\x04k\x02\x01\x06\x12\x04\xf8\x12\x02\x1b\n\r\n\x05\x04k\
    \x02\x01\x01\x12\x04\xf8\x12\x1c&\n\r\n\x05\x04k\x02\x01\x03\x12\x04\xf8\
    \x12)*\n\x9a\x01\n\x04\x04k\x02\x02\x12\x04\xfd\x12\x02,\x1a\x8b\x01\x20\
    Most\x20recent\x20time\x20when\x20the\x20task\x20was\x20updated.\n\x20Th\
    e\x20format\x20is\x20https://www.ietf.org/rfc/rfc3339.txt.\n\x20Example:\
    \x20\"2006-01-02T15:04:05.999999Z\".\n\n\r\n\x05\x04k\x02\x02\x06\x12\
    \x04\xfd\x12\x02\x1b\n\r\n\x05\x04k\x02\x02\x01\x12\x04\xfd\x12\x1c'\n\r\
    \n\x05\x04k\x02\x02\x03\x12\x04\xfd\x12*+\n\x1a\n\x04\x04k\x02\x03\x12\
    \x04\x80\x13\x02\x14\x1a\x0c\x20Task\x20type.\n\n\r\n\x05\x04k\x02\x03\
    \x06\x12\x04\x80\x13\x02\n\n\r\n\x05\x04k\x02\x03\x01\x12\x04\x80\x13\
    \x0b\x0f\n\r\n\x05\x04k\x02\x03\x03\x12\x04\x80\x13\x12\x13\n(\n\x04\x04\
    k\x02\x04\x12\x04\x83\x13\x02\x19\x1a\x1a\x20Description\x20of\x20the\
    \x20task.\n\n\r\n\x05\x04k\x02\x04\x05\x12\x04\x83\x13\x02\x08\n\r\n\x05\
    \x04k\x02\x04\x01\x12\x04\x83\x13\t\x14\n\r\n\x05\x04k\x02\x04\x03\x12\
    \x04\x83\x13\x17\x18\n\x1f\n\x04\x04k\x02\x05\x12\x04\x86\x13\x02\x18\
    \x1a\x11\x20Worker\x20details.\n\n\r\n\x05\x04k\x02\x05\x06\x12\x04\x86\
    \x13\x02\x0c\n\r\n\x05\x04k\x02\x05\x01\x12\x04\x86\x13\r\x13\n\r\n\x05\
    \x04k\x02\x05\x03\x12\x04\x86\x13\x16\x17\nb\n\x04\x04k\x02\x06\x12\x04\
    \x89\x13\x02\"\x1aT\x20List\x20of\x20concept\x20ids\x20used\x20in\x20the\
    \x20work\x20of\x20this\x20task\x20if\x20label\x20type\x20is\x20classific\
    ation.\n\n\r\n\x05\x04k\x02\x06\x04\x12\x04\x89\x13\x02\n\n\r\n\x05\x04k\
    \x02\x06\x05\x12\x04\x89\x13\x0b\x11\n\r\n\x05\x04k\x02\x06\x01\x12\x04\
    \x89\x13\x12\x1d\n\r\n\x05\x04k\x02\x06\x03\x12\x04\x89\x13\x20!\nP\n\
    \x04\x04k\x02\x07\x12\x04\x8c\x13\x02#\x1aB\x20List\x20of\x20inputs\x20u\
    sed\x20in\x20this\x20task\x20will\x20be\x20taken\x20from\x20this\x20sour\
    ce.\n\n\r\n\x05\x04k\x02\x07\x06\x12\x04\x8c\x13\x02\x11\n\r\n\x05\x04k\
    \x02\x07\x01\x12\x04\x8c\x13\x12\x1e\n\r\n\x05\x04k\x02\x07\x03\x12\x04\
    \x8c\x13!\"\nn\n\x04\x04k\x02\x08\x12\x04\x8f\x13\x02\x17\x1a`\x20For\
    \x20model\x20predictions\x20on\x20video:\x20Sample\x20delay\x20for\x20vi\
    deo\x20predicting\x20(1\x20frame\x20per\x20N\x20milliseconds)\n\n\r\n\
    \x05\x04k\x02\x08\x05\x12\x04\x8f\x13\x02\x08\n\r\n\x05\x04k\x02\x08\x01\
    \x12\x04\x8f\x13\t\x12\n\r\n\x05\x04k\x02\x08\x03\x12\x04\x8f\x13\x15\
    \x16\n%\n\x04\x04k\x02\t\x12\x04\x92\x13\x02$\x1a\x17\x20AI\x20assistant\
    \x20details.\n\n\r\n\x05\x04k\x02\t\x06\x12\x04\x92\x13\x02\x11\n\r\n\
    \x05\x04k\x02\t\x01\x12\x04\x92\x13\x12\x1e\n\r\n\x05\x04k\x02\t\x03\x12\
    \x04\x92\x13!#\n\x1f\n\x04\x04k\x02\n\x12\x04\x95\x13\x02\x19\x1a\x11\
    \x20Review\x20details.\n\n\r\n\x05\x04k\x02\n\x06\x12\x04\x95\x13\x02\
    \x0c\n\r\n\x05\x04k\x02\n\x01\x12\x04\x95\x13\r\x13\n\r\n\x05\x04k\x02\n\
    \x03\x12\x04\x95\x13\x16\x18\n$\n\x04\x04k\x02\x0b\x12\x04\x98\x13\x02)\
    \x1a\x16\x20Status\x20of\x20this\x20task.\n\n\r\n\x05\x04k\x02\x0b\x06\
    \x12\x04\x98\x13\x02\x1c\n\r\n\x05\x04k\x02\x0b\x01\x12\x04\x98\x13\x1d#\
    \n\r\n\x05\x04k\x02\x0b\x03\x12\x04\x98\x13&(\nU\n\x04\x04k\x02\x0c\x12\
    \x04\x9b\x13\x02\x13\x1aG\x20Add\x20a\x20title\x20for\x20this\x20task\
    \x20to\x20quickly\x20recognise\x20it\x20in\x20a\x20list\x20of\x20tasks.\
    \n\n\r\n\x05\x04k\x02\x0c\x05\x12\x04\x9b\x13\x02\x08\n\r\n\x05\x04k\x02\
    \x0c\x01\x12\x04\x9b\x13\t\r\n\r\n\x05\x04k\x02\x0c\x03\x12\x04\x9b\x13\
    \x10\x12\n\x0c\n\x04\x04k\x02\r\x12\x04\x9d\x13\x02+\n\r\n\x05\x04k\x02\
    \r\x06\x12\x04\x9d\x13\x02\x14\n\r\n\x05\x04k\x02\r\x01\x12\x04\x9d\x13\
    \x15%\n\r\n\x05\x04k\x02\r\x03\x12\x04\x9d\x13(*\n\x0e\n\x04\x04k\x04\0\
    \x12\x06\x9f\x13\x02\xa8\x13\x03\n\r\n\x05\x04k\x04\0\x01\x12\x04\x9f\
    \x13\x07\x0f\n\x0e\n\x06\x04k\x04\0\x02\0\x12\x04\xa0\x13\x04\x15\n\x0f\
    \n\x07\x04k\x04\0\x02\0\x01\x12\x04\xa0\x13\x04\x10\n\x0f\n\x07\x04k\x04\
    \0\x02\0\x02\x12\x04\xa0\x13\x13\x14\n{\n\x06\x04k\x04\0\x02\x01\x12\x04\
    \xa3\x13\x04\x20\x1ak\x20Concepts\x20classification\x20tasks\x20annotate\
    \x20concepts\x20for\x20the\x20overall\x20image,\x20frame\x20of\x20video\
    \x20or\x20section\x20of\x20text.\n\n\x0f\n\x07\x04k\x04\0\x02\x01\x01\
    \x12\x04\xa3\x13\x04\x1b\n\x0f\n\x07\x04k\x04\0\x02\x01\x02\x12\x04\xa3\
    \x13\x1e\x1f\n\x9d\x01\n\x06\x04k\x04\0\x02\x02\x12\x04\xa5\x13\x04\x1f\
    \x1a\x8c\x01\x20Bounding\x20box\x20detection\x20tasks\x20annotate\x20rec\
    tangular\x20bounding\x20box\x20regions\x20around\x20each\x20concept\x20i\
    n\x20an\x20image,\x20frame\x20of\x20video\x20or\x20section\x20of\x20text\
    .\n\n\x0f\n\x07\x04k\x04\0\x02\x02\x01\x12\x04\xa5\x13\x04\x1a\n\x0f\n\
    \x07\x04k\x04\0\x02\x02\x02\x12\x04\xa5\x13\x1d\x1e\n\x84\x01\n\x06\x04k\
    \x04\0\x02\x03\x12\x04\xa7\x13\x04\x1a\x1at\x20Polygon\x20detection\x20t\
    asks\x20annotate\x20free-form\x20regions\x20around\x20concepts\x20in\x20\
    an\x20image,\x20frame\x20of\x20video\x20or\x20section\x20of\x20text.\n\n\
    \x0f\n\x07\x04k\x04\0\x02\x03\x01\x12\x04\xa7\x13\x04\x15\n\x0f\n\x07\
    \x04k\x04\0\x02\x03\x02\x12\x04\xa7\x13\x18\x19\n\xdd\x01\n\x04\x04k\x02\
    \x0e\x12\x04\xad\x13\x02\x1d\x1a\xce\x01\x20The\x20visibility\x20field\
    \x20represents\x20whether\x20this\x20message\x20is\x20privately/publicly\
    \x20visible.\n\x20To\x20be\x20visible\x20to\x20the\x20public\x20the\x20A\
    pp\x20that\x20contains\x20it\x20AND\x20the\x20User\x20that\x20contains\
    \x20the\x20App\x20must\n\x20also\x20be\x20publicly\x20visible.\n\n\r\n\
    \x05\x04k\x02\x0e\x06\x12\x04\xad\x13\x02\x0c\n\r\n\x05\x04k\x02\x0e\x01\
    \x12\x04\xad\x13\r\x17\n\r\n\x05\x04k\x02\x0e\x03\x12\x04\xad\x13\x1a\
    \x1c\n,\n\x04\x04k\x02\x0f\x12\x04\xb0\x13\x02\x15\x1a\x1e\x20The\x20app\
    \x20the\x20task\x20belongs\x20to.\n\n\r\n\x05\x04k\x02\x0f\x05\x12\x04\
    \xb0\x13\x02\x08\n\r\n\x05\x04k\x02\x0f\x01\x12\x04\xb0\x13\t\x0f\n\r\n\
    \x05\x04k\x02\x0f\x03\x12\x04\xb0\x13\x12\x14\n-\n\x04\x04k\x02\x10\x12\
    \x04\xb2\x13\x02\x16\x1a\x1f\x20The\x20user\x20the\x20task\x20belongs\
    \x20to.\n\n\r\n\x05\x04k\x02\x10\x05\x12\x04\xb2\x13\x02\x08\n\r\n\x05\
    \x04k\x02\x10\x01\x12\x04\xb2\x13\t\x10\n\r\n\x05\x04k\x02\x10\x03\x12\
    \x04\xb2\x13\x13\x15\n\x0c\n\x02\x04l\x12\x06\xb5\x13\0\xbb\x13\x01\n\
    \x0b\n\x03\x04l\x01\x12\x04\xb5\x13\x08\x1a\nk\n\x04\x04l\x02\0\x12\x04\
    \xb7\x13\x02\x1a\x1a]\x20Min\x20and\x20max\x20threshold\x20values\x20for\
    \x20approving\x20annotations\x20by\x20default\x20based\x20on\x20predicti\
    on\x20score\n\n\r\n\x05\x04l\x02\0\x05\x12\x04\xb7\x13\x02\x07\n\r\n\x05\
    \x04l\x02\0\x01\x12\x04\xb7\x13\x08\x15\n\r\n\x05\x04l\x02\0\x03\x12\x04\
    \xb7\x13\x18\x19\n\x0c\n\x04\x04l\x02\x01\x12\x04\xb8\x13\x02\x1a\n\r\n\
    \x05\x04l\x02\x01\x05\x12\x04\xb8\x13\x02\x07\n\r\n\x05\x04l\x02\x01\x01\
    \x12\x04\xb8\x13\x08\x15\n\r\n\x05\x04l\x02\x01\x03\x12\x04\xb8\x13\x18\
    \x19\nD\n\x04\x04l\x02\x02\x12\x04\xba\x13\x02+\x1a6\x20ids\x20of\x20con\
    cept\x20relations.\x20Used\x20in\x20AI\x20assist\x20workflow\n\n\r\n\x05\
    \x04l\x02\x02\x04\x12\x04\xba\x13\x02\n\n\r\n\x05\x04l\x02\x02\x05\x12\
    \x04\xba\x13\x0b\x11\n\r\n\x05\x04l\x02\x02\x01\x12\x04\xba\x13\x12&\n\r\
    \n\x05\x04l\x02\x02\x03\x12\x04\xba\x13)*\n\x0c\n\x02\x04m\x12\x06\xbd\
    \x13\0\xd5\x13\x01\n\x0b\n\x03\x04m\x01\x12\x04\xbd\x13\x08\x12\n\x20\n\
    \x04\x04m\x02\0\x12\x04\xbf\x13\x02\"\x1a\x12\x20Worker\x20strategy.\n\n\
    \r\n\x05\x04m\x02\0\x06\x12\x04\xbf\x13\x02\x14\n\r\n\x05\x04m\x02\0\x01\
    \x12\x04\xbf\x13\x15\x1d\n\r\n\x05\x04m\x02\0\x03\x12\x04\xbf\x13\x20!\n\
    +\n\x04\x04m\x02\x01\x12\x04\xc2\x13\x02\x1f\x1a\x1d\x20Who\x20will\x20w\
    ork\x20on\x20this\x20task.\n\n\r\n\x05\x04m\x02\x01\x04\x12\x04\xc2\x13\
    \x02\n\n\r\n\x05\x04m\x02\x01\x05\x12\x04\xc2\x13\x0b\x11\n\r\n\x05\x04m\
    \x02\x01\x01\x12\x04\xc2\x13\x12\x1a\n\r\n\x05\x04m\x02\x01\x03\x12\x04\
    \xc2\x13\x1d\x1e\n4\n\x04\x04m\x08\0\x12\x06\xc5\x13\x02\xc7\x13\x03\x1a\
    $\x20Info\x20based\x20on\x20the\x20worker\x20strategy,\n\n\r\n\x05\x04m\
    \x08\0\x01\x12\x04\xc5\x13\x08\x15\n\x0c\n\x04\x04m\x02\x02\x12\x04\xc6\
    \x13\x04D\n\r\n\x05\x04m\x02\x02\x06\x12\x04\xc6\x13\x04%\n\r\n\x05\x04m\
    \x02\x02\x01\x12\x04\xc6\x13&?\n\r\n\x05\x04m\x02\x02\x03\x12\x04\xc6\
    \x13BC\n\x0e\n\x04\x04m\x04\0\x12\x06\xc9\x13\x02\xd4\x13\x03\n\r\n\x05\
    \x04m\x04\0\x01\x12\x04\xc9\x13\x07\x19\n\r\n\x05\x04m\x04\0\t\x12\x04\
    \xca\x13\x04\x0f\n\x0e\n\x06\x04m\x04\0\t\0\x12\x04\xca\x13\r\x0e\n\x0f\
    \n\x07\x04m\x04\0\t\0\x01\x12\x04\xca\x13\r\x0e\n\x0f\n\x07\x04m\x04\0\t\
    \0\x02\x12\x04\xca\x13\r\x0e\n\x0e\n\x06\x04m\x04\0\x02\0\x12\x04\xcc\
    \x13\x04\x20\n\x0f\n\x07\x04m\x04\0\x02\0\x01\x12\x04\xcc\x13\x04\x1b\n\
    \x0f\n\x07\x04m\x04\0\x02\0\x02\x12\x04\xcc\x13\x1e\x1f\n}\n\x06\x04m\
    \x04\0\x02\x01\x12\x04\xd0\x13\x04\x14\x1am\x20The\x20inputs\x20will\x20\
    be\x20partitioned\x20in\x20several\x20partitions.\n\x20Each\x20worker\
    \x20will\x20label\x20one\x20or\x20more\x20input\x20partitions.\n\n\x0f\n\
    \x07\x04m\x04\0\x02\x01\x01\x12\x04\xd0\x13\x04\x0f\n\x0f\n\x07\x04m\x04\
    \0\x02\x01\x02\x12\x04\xd0\x13\x12\x13\nF\n\x06\x04m\x04\0\x02\x02\x12\
    \x04\xd3\x13\x04\r\x1a6\x20Each\x20worker\x20will\x20label\x20all\x20inp\
    uts\x20from\x20input\x20source.\n\n\x0f\n\x07\x04m\x04\0\x02\x02\x01\x12\
    \x04\xd3\x13\x04\x08\n\x0f\n\x07\x04m\x04\0\x02\x02\x02\x12\x04\xd3\x13\
    \x0b\x0c\n\x0c\n\x02\x04n\x12\x06\xd7\x13\0\x80\x14\x01\n\x0b\n\x03\x04n\
    \x01\x12\x04\xd7\x13\x08)\n8\n\x04\x04n\x02\0\x12\x04\xd9\x13\x02)\x1a*\
    \x20Define\x20how\x20the\x20partitioning\x20should\x20work.\n\n\r\n\x05\
    \x04n\x02\0\x06\x12\x04\xd9\x13\x02\x1f\n\r\n\x05\x04n\x02\0\x01\x12\x04\
    \xd9\x13\x20$\n\r\n\x05\x04n\x02\0\x03\x12\x04\xd9\x13'(\n7\n\x04\x04n\
    \x02\x01\x12\x04\xdc\x13\x02\x1e\x1a)\x20How\x20many\x20workers\x20will\
    \x20label\x20each\x20input.\n\n\r\n\x05\x04n\x02\x01\x05\x12\x04\xdc\x13\
    \x02\x07\n\r\n\x05\x04n\x02\x01\x01\x12\x04\xdc\x13\x08\x19\n\r\n\x05\
    \x04n\x02\x01\x03\x12\x04\xdc\x13\x1c\x1d\n\xf6\x0b\n\x04\x04n\x02\x02\
    \x12\x04\xf4\x13\x02%\x1a\xe7\x0b\x20In\x20case\x20of\x20weighted\x20par\
    titioning,\x20map\x20user\x20ids\x20to\x20weights.\n\x20Each\x20labeler\
    \x20will\x20be\x20assigned\x20work\x20proportional\x20to\x20its\x20own\
    \x20weight\x20as\x20compared\x20to\x20the\x20sum\x20of\x20total\x20weigh\
    t.\n\n\x20EXAMPLE:\n\x20If\x20we\x20have\x203\x20workers,\x20and\x20weig\
    hts\x20=\x20{1:\x2030,\x202:\x2030,\x203:\x2040},\n\x20then\x20first\x20\
    worker\x20will\x20have\x20assigned\x2030%\x20of\x20the\x20work,\n\x20sec\
    ond\x20worker\x20will\x20have\x20assigned\x2030%\x20of\x20the\x20work,\n\
    \x20and\x20third\x20worker\x20will\x20have\x20assigned\x2040%\x20of\x20t\
    he\x20work.\n\x20You\x20may\x20use\x20weights\x20which\x20add\x20up\x20t\
    o\x20100,\x20but\x20it's\x20not\x20necessary.\n\x20For\x20example,\x20we\
    ights\x20{1:\x2030,\x202:\x2030,\x203:\x2040}\x20are\x20equivalent\x20wi\
    th\x20{1:\x203,\x202:\x203,\x203:\x204}\n\x20because\x20they\x20represen\
    t\x20the\x20same\x20percentages:\x20{1:\x2030%,\x202:\x2030%,\x203:\x204\
    0%}.\n\n\x20NOTE:\n\x20Note\x20that\x20no\x20worker\x20should\x20be\x20a\
    ssigned\x20a\x20weight\x20percentage\x20greater\x20than\x201/workers_per\
    _input.\n\x20It\x20is\x20mathematically\x20impossible\x20to\x20partition\
    \x20the\x20work\x20in\x20such\x20a\x20case.\n\x20Why?\x20Say,\x20we\x20h\
    ave\x203\x20workers.\x20And\x20workers_per_input\x20=\x202,\x20i.e.\x20e\
    ach\x20input\x20must\x20be\x20labeled\x20by\x202\x20workers.\n\x20Let's\
    \x20assign\x20weights\x20{1:\x2051%,\x202:\x2025%,\x203:\x2024%}.\n\x20N\
    ote\x20that\x20first\x20worker\x20has\x20a\x20weight\x20percentage\x20hi\
    gher\x20than\x201/workers_per_input\x20=\x201/2\x20=\x2050%.\n\x20If\x20\
    we\x20have\x20100\x20inputs,\x20then\x20a\x20total\x20of\x20100\x20*\x20\
    workers_per_input\x20=\x20200\x20cumulative\x20inputs\x20will\x20be\x20l\
    abeled\x20by\x20these\x203\x20workers.\n\x20Worker\x201\x20should\x20lab\
    el\x20102\x20cumulative\x20inputs,\x20while\x20worker\x202\x20and\x20wor\
    ker\x203\x20will\x20label\x2098\x20cumulative\x20inputs\x20together.\n\
    \x20No\x20matter\x20how\x20we\x20assign\x20the\x2098\x20cumulative\x20in\
    puts,\x20the\x202\x20workers\x20will\x20be\x20able\x20to\x20label\x20up\
    \x20to\x2098\x20actual\x20inputs.\n\x20This\x20means\x20the\x20remaining\
    \x202\x20inputs\x20will\x20be\x20labeled\x20only\x20by\x20worker\x201.\
    \x20This\x20contradicts\x20the\x20worker_per_input\x20=\x202\x20requirem\
    ent.\n\n\r\n\x05\x04n\x02\x02\x06\x12\x04\xf4\x13\x02\x18\n\r\n\x05\x04n\
    \x02\x02\x01\x12\x04\xf4\x13\x19\x20\n\r\n\x05\x04n\x02\x02\x03\x12\x04\
    \xf4\x13#$\n\x0e\n\x04\x04n\x04\0\x12\x06\xf6\x13\x02\xff\x13\x03\n\r\n\
    \x05\x04n\x04\0\x01\x12\x04\xf6\x13\x07$\n\x0e\n\x06\x04n\x04\0\x02\0\
    \x12\x04\xf7\x13\x04,\n\x0f\n\x07\x04n\x04\0\x02\0\x01\x12\x04\xf7\x13\
    \x04'\n\x0f\n\x07\x04n\x04\0\x02\0\x02\x12\x04\xf7\x13*+\nS\n\x06\x04n\
    \x04\0\x02\x01\x12\x04\xfa\x13\x04\x0f\x1aC\x20Each\x20worker\x20will\
    \x20label\x20(approximately)\x20the\x20same\x20number\x20of\x20inputs.\n\
    \n\x0f\n\x07\x04n\x04\0\x02\x01\x01\x12\x04\xfa\x13\x04\n\n\x0f\n\x07\
    \x04n\x04\0\x02\x01\x02\x12\x04\xfa\x13\r\x0e\n`\n\x06\x04n\x04\0\x02\
    \x02\x12\x04\xfe\x13\x04\x11\x1aP\x20Each\x20worker\x20will\x20have\x20a\
    n\x20assigned\x20weight.\n\x20See\x20weights\x20field\x20for\x20more\x20\
    details.\n\n\x0f\n\x07\x04n\x04\0\x02\x02\x01\x12\x04\xfe\x13\x04\x0c\n\
    \x0f\n\x07\x04n\x04\0\x02\x02\x02\x12\x04\xfe\x13\x0f\x10\n\x0c\n\x02\
    \x04o\x12\x06\x82\x14\0\x91\x14\x01\n\x0b\n\x03\x04o\x01\x12\x04\x82\x14\
    \x08\x17\n%\n\x04\x04o\x02\0\x12\x04\x84\x14\x02\x1f\x1a\x17\x20Type\x20\
    of\x20input\x20source.\n\n\r\n\x05\x04o\x02\0\x06\x12\x04\x84\x14\x02\
    \x15\n\r\n\x05\x04o\x02\0\x01\x12\x04\x84\x14\x16\x1a\n\r\n\x05\x04o\x02\
    \0\x03\x12\x04\x84\x14\x1d\x1e\nJ\n\x04\x04o\x02\x01\x12\x04\x87\x14\x02\
    \x10\x1a<\x20If\x20type\x20is\x20SAVED_SEARCH,\x20then\x20this\x20is\x20\
    the\x20saved\x20search\x20id.\n\n\r\n\x05\x04o\x02\x01\x05\x12\x04\x87\
    \x14\x02\x08\n\r\n\x05\x04o\x02\x01\x01\x12\x04\x87\x14\t\x0b\n\r\n\x05\
    \x04o\x02\x01\x03\x12\x04\x87\x14\x0e\x0f\n\x0e\n\x04\x04o\x04\0\x12\x06\
    \x89\x14\x02\x90\x14\x03\n\r\n\x05\x04o\x04\0\x01\x12\x04\x89\x14\x07\
    \x1a\n\x0e\n\x06\x04o\x04\0\x02\0\x12\x04\x8a\x14\x04\"\n\x0f\n\x07\x04o\
    \x04\0\x02\0\x01\x12\x04\x8a\x14\x04\x1d\n\x0f\n\x07\x04o\x04\0\x02\0\
    \x02\x12\x04\x8a\x14\x20!\n,\n\x06\x04o\x04\0\x02\x01\x12\x04\x8d\x14\
    \x04\x13\x1a\x1c\x20Use\x20all\x20inputs\x20in\x20the\x20app.\n\n\x0f\n\
    \x07\x04o\x04\0\x02\x01\x01\x12\x04\x8d\x14\x04\x0e\n\x0f\n\x07\x04o\x04\
    \0\x02\x01\x02\x12\x04\x8d\x14\x11\x12\n5\n\x06\x04o\x04\0\x02\x02\x12\
    \x04\x8f\x14\x04\x15\x1a%\x20Use\x20the\x20inputs\x20from\x20a\x20saved\
    \x20search.\n\n\x0f\n\x07\x04o\x04\0\x02\x02\x01\x12\x04\x8f\x14\x04\x10\
    \n\x0f\n\x07\x04o\x04\0\x02\x02\x02\x12\x04\x8f\x14\x13\x14\n\x0c\n\x02\
    \x04p\x12\x06\x93\x14\0\xac\x14\x01\n\x0b\n\x03\x04p\x01\x12\x04\x93\x14\
    \x08\x12\n%\n\x04\x04p\x02\0\x12\x04\x95\x14\x02\"\x1a\x17\x20Task\x20re\
    view\x20strategy.\n\n\r\n\x05\x04p\x02\0\x06\x12\x04\x95\x14\x02\x14\n\r\
    \n\x05\x04p\x02\0\x01\x12\x04\x95\x14\x15\x1d\n\r\n\x05\x04p\x02\0\x03\
    \x12\x04\x95\x14\x20!\n*\n\x04\x04p\x02\x01\x12\x04\x98\x14\x02\x1f\x1a\
    \x1c\x20Who\x20will\x20review\x20this\x20task.\n\n\r\n\x05\x04p\x02\x01\
    \x04\x12\x04\x98\x14\x02\n\n\r\n\x05\x04p\x02\x01\x05\x12\x04\x98\x14\
    \x0b\x11\n\r\n\x05\x04p\x02\x01\x01\x12\x04\x98\x14\x12\x1a\n\r\n\x05\
    \x04p\x02\x01\x03\x12\x04\x98\x14\x1d\x1e\n4\n\x04\x04p\x08\0\x12\x06\
    \x9b\x14\x02\x9e\x14\x03\x1a$\x20Info\x20based\x20on\x20the\x20review\
    \x20strategy,\n\n\r\n\x05\x04p\x08\0\x01\x12\x04\x9b\x14\x08\x15\n\x0c\n\
    \x04\x04p\x02\x02\x12\x04\x9c\x14\x04:\n\r\n\x05\x04p\x02\x02\x06\x12\
    \x04\x9c\x14\x04\x20\n\r\n\x05\x04p\x02\x02\x01\x12\x04\x9c\x14!5\n\r\n\
    \x05\x04p\x02\x02\x03\x12\x04\x9c\x1489\n\x0c\n\x04\x04p\x02\x03\x12\x04\
    \x9d\x14\x04@\n\r\n\x05\x04p\x02\x03\x06\x12\x04\x9d\x14\x04#\n\r\n\x05\
    \x04p\x02\x03\x01\x12\x04\x9d\x14$;\n\r\n\x05\x04p\x02\x03\x03\x12\x04\
    \x9d\x14>?\n\x0e\n\x04\x04p\x04\0\x12\x06\xa0\x14\x02\xab\x14\x03\n\r\n\
    \x05\x04p\x04\0\x01\x12\x04\xa0\x14\x07\x19\n\x0e\n\x06\x04p\x04\0\x02\0\
    \x12\x04\xa1\x14\x04%\n\x0f\n\x07\x04p\x04\0\x02\0\x01\x12\x04\xa1\x14\
    \x04\x20\n\x0f\n\x07\x04p\x04\0\x02\0\x02\x12\x04\xa1\x14#$\n&\n\x06\x04\
    p\x04\0\x02\x01\x12\x04\xa4\x14\x04\r\x1a\x16\x20No\x20review\x20is\x20n\
    eeded.\n\n\x0f\n\x07\x04p\x04\0\x02\x01\x01\x12\x04\xa4\x14\x04\x08\n\
    \x0f\n\x07\x04p\x04\0\x02\x01\x02\x12\x04\xa4\x14\x0b\x0c\n)\n\x06\x04p\
    \x04\0\x02\x02\x12\x04\xa7\x14\x04\x0f\x1a\x19\x20Manual\x20review\x20st\
    rategy.\n\n\x0f\n\x07\x04p\x04\0\x02\x02\x01\x12\x04\xa7\x14\x04\n\n\x0f\
    \n\x07\x04p\x04\0\x02\x02\x02\x12\x04\xa7\x14\r\x0e\n,\n\x06\x04p\x04\0\
    \x02\x03\x12\x04\xaa\x14\x04\x12\x1a\x1c\x20Consensus\x20review\x20strat\
    egy.\n\n\x0f\n\x07\x04p\x04\0\x02\x03\x01\x12\x04\xaa\x14\x04\r\n\x0f\n\
    \x07\x04p\x04\0\x02\x03\x02\x12\x04\xaa\x14\x10\x11\n\x0c\n\x02\x04q\x12\
    \x06\xae\x14\0\xb1\x14\x01\n\x0b\n\x03\x04q\x01\x12\x04\xae\x14\x08$\n\
    \x81\x01\n\x04\x04q\x02\0\x12\x04\xb0\x14\x02\x1e\x1as\x20This\x20field\
    \x20represents\x20the\x20percentage\x20of\x20inputs\x20that\x20will\x20b\
    e\x20reviewed\x20by\x20reviewers.\x20It\x20is\x20a\x20value\x20between\
    \x200\x20and\x201.\n\n\r\n\x05\x04q\x02\0\x05\x12\x04\xb0\x14\x02\x07\n\
    \r\n\x05\x04q\x02\0\x01\x12\x04\xb0\x14\x08\x19\n\r\n\x05\x04q\x02\0\x03\
    \x12\x04\xb0\x14\x1c\x1d\n\x0c\n\x02\x04r\x12\x06\xb3\x14\0\xb8\x14\x01\
    \n\x0b\n\x03\x04r\x01\x12\x04\xb3\x14\x08'\n\x0b\n\x03\x04r\t\x12\x04\
    \xb4\x14\x02\r\n\x0c\n\x04\x04r\t\0\x12\x04\xb4\x14\x0b\x0c\n\r\n\x05\
    \x04r\t\0\x01\x12\x04\xb4\x14\x0b\x0c\n\r\n\x05\x04r\t\0\x02\x12\x04\xb4\
    \x14\x0b\x0c\nj\n\x04\x04r\x02\0\x12\x04\xb7\x14\x02\x20\x1a\\\x20The\
    \x20number\x20of\x20labelers\x20that\x20need\x20to\x20agree\x20in\x20ord\
    er\x20to\x20automatically\x20approve\x20an\x20annotation.\n\n\r\n\x05\
    \x04r\x02\0\x05\x12\x04\xb7\x14\x02\x08\n\r\n\x05\x04r\x02\0\x01\x12\x04\
    \xb7\x14\t\x1b\n\r\n\x05\x04r\x02\0\x03\x12\x04\xb7\x14\x1e\x1f\n\x0c\n\
    \x02\x04s\x12\x06\xba\x14\0\xbf\x14\x01\n\x0b\n\x03\x04s\x01\x12\x04\xba\
    \x14\x08\x17\n\xb7\x01\n\x04\x04s\x02\0\x12\x04\xbe\x14\x02\x19\x1a\xa8\
    \x01\x20The\x20worker\x20is\x20helped\x20by\x20an\x20AI\x20assistant.\n\
    \x20This\x20field\x20is\x20the\x20workflow\x20id\x20which\x20is\x20used\
    \x20to\x20assist\x20the\x20worker\x20with\x20predictions.\n\x20If\x20emp\
    ty,\x20then\x20AI\x20assistant\x20is\x20disabled.\n\n\r\n\x05\x04s\x02\0\
    \x05\x12\x04\xbe\x14\x02\x08\n\r\n\x05\x04s\x02\0\x01\x12\x04\xbe\x14\t\
    \x14\n\r\n\x05\x04s\x02\0\x03\x12\x04\xbe\x14\x17\x18\n\xce\x01\n\x02\
    \x04t\x12\x06\xc8\x14\0\xcf\x14\x012\xbf\x01\x20TaskStatusCountPerUser\
    \x20can\x20represent\x20-\n\x20\x20\x20\x201.\x20count\x20of\x20human\
    \x20created\x20annotations\x20for\x20a\x20user\x20for\x20each\x20valid\
    \x20status\n\x20\x20\x20\x202.\x20count\x20of\x20inputs\x20(anchor\x20an\
    notation)\x20for\x20a\x20user\x20for\x20each\x20valid\x20status\n\n\x0b\
    \n\x03\x04t\x01\x12\x04\xc8\x14\x08\x1e\n\x0c\n\x04\x04t\x02\0\x12\x04\
    \xc9\x14\x02\x15\n\r\n\x05\x04t\x02\0\x05\x12\x04\xc9\x14\x02\x08\n\r\n\
    \x05\x04t\x02\0\x01\x12\x04\xc9\x14\t\x10\n\r\n\x05\x04t\x02\0\x03\x12\
    \x04\xc9\x14\x13\x14\n\x0c\n\x04\x04t\x02\x01\x12\x04\xca\x14\x02D\n\r\n\
    \x05\x04t\x02\x01\x05\x12\x04\xca\x14\x02\x08\n\r\n\x05\x04t\x02\x01\x01\
    \x12\x04\xca\x14\t\x10\n\r\n\x05\x04t\x02\x01\x03\x12\x04\xca\x14\x13\
    \x14\n\r\n\x05\x04t\x02\x01\x08\x12\x04\xca\x14\x15C\n\x10\n\x08\x04t\
    \x02\x01\x08\xd0\x86\x03\x12\x04\xca\x14\x16B\n\x0c\n\x04\x04t\x02\x02\
    \x12\x04\xcb\x14\x02L\n\r\n\x05\x04t\x02\x02\x05\x12\x04\xcb\x14\x02\x08\
    \n\r\n\x05\x04t\x02\x02\x01\x12\x04\xcb\x14\t\x18\n\r\n\x05\x04t\x02\x02\
    \x03\x12\x04\xcb\x14\x1b\x1c\n\r\n\x05\x04t\x02\x02\x08\x12\x04\xcb\x14\
    \x1dK\n\x10\n\x08\x04t\x02\x02\x08\xd0\x86\x03\x12\x04\xcb\x14\x1eJ\n\
    \x0c\n\x04\x04t\x02\x03\x12\x04\xcc\x14\x02D\n\r\n\x05\x04t\x02\x03\x05\
    \x12\x04\xcc\x14\x02\x08\n\r\n\x05\x04t\x02\x03\x01\x12\x04\xcc\x14\t\
    \x10\n\r\n\x05\x04t\x02\x03\x03\x12\x04\xcc\x14\x13\x14\n\r\n\x05\x04t\
    \x02\x03\x08\x12\x04\xcc\x14\x15C\n\x10\n\x08\x04t\x02\x03\x08\xd0\x86\
    \x03\x12\x04\xcc\x14\x16B\n\x0c\n\x04\x04t\x02\x04\x12\x04\xcd\x14\x02J\
    \n\r\n\x05\x04t\x02\x04\x05\x12\x04\xcd\x14\x02\x08\n\r\n\x05\x04t\x02\
    \x04\x01\x12\x04\xcd\x14\t\x16\n\r\n\x05\x04t\x02\x04\x03\x12\x04\xcd\
    \x14\x19\x1a\n\r\n\x05\x04t\x02\x04\x08\x12\x04\xcd\x14\x1bI\n\x10\n\x08\
    \x04t\x02\x04\x08\xd0\x86\x03\x12\x04\xcd\x14\x1cH\n\x0c\n\x04\x04t\x02\
    \x05\x12\x04\xce\x14\x02V\n\r\n\x05\x04t\x02\x05\x05\x12\x04\xce\x14\x02\
    \x08\n\r\n\x05\x04t\x02\x05\x01\x12\x04\xce\x14\t\"\n\r\n\x05\x04t\x02\
    \x05\x03\x12\x04\xce\x14%&\n\r\n\x05\x04t\x02\x05\x08\x12\x04\xce\x14'U\
    \n\x10\n\x08\x04t\x02\x05\x08\xd0\x86\x03\x12\x04\xce\x14(T\n\x0c\n\x02\
    \x05\x06\x12\x06\xd1\x14\0\xd4\x14\x01\n\x0b\n\x03\x05\x06\x01\x12\x04\
    \xd1\x14\x05\r\n\x0c\n\x04\x05\x06\x02\0\x12\x04\xd2\x14\x02\x0b\n\r\n\
    \x05\x05\x06\x02\0\x01\x12\x04\xd2\x14\x02\x06\n\r\n\x05\x05\x06\x02\0\
    \x02\x12\x04\xd2\x14\t\n\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\xd3\x14\x02\
    \n\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\xd3\x14\x02\x05\n\r\n\x05\x05\
    \x06\x02\x01\x02\x12\x04\xd3\x14\x08\t\n\xb8\x02\n\x02\x04u\x12\x06\xe5\
    \x14\0\x96\x15\x01\x1a}\x20Collector\x20is\x20a\x20data\x20pathway\x20fr\
    om\x20a\x20CollectorSource\x20to\x20an\x20app\x20to\x20collect\x20data\
    \x20automatically.\n\x20For\x20example,\x20a\x20CollectorSource\n2\xaa\
    \x01////////////////////////////////////////////////////////////////////\
    //////////\n\x20Collectors\n////////////////////////////////////////////\
    //////////////////////////////////\n\n\x0b\n\x03\x04u\x01\x12\x04\xe5\
    \x14\x08\x11\n,\n\x04\x04u\x02\0\x12\x04\xe7\x14\x02\x10\x1a\x1e\x20Uniq\
    ue\x20ID\x20for\x20the\x20collector.\n\n\r\n\x05\x04u\x02\0\x05\x12\x04\
    \xe7\x14\x02\x08\n\r\n\x05\x04u\x02\0\x01\x12\x04\xe7\x14\t\x0b\n\r\n\
    \x05\x04u\x02\0\x03\x12\x04\xe7\x14\x0e\x0f\n=\n\x04\x04u\x02\x01\x12\
    \x04\xea\x14\x02\x19\x1a/\x20Human\x20readable\x20description\x20for\x20\
    the\x20collector.\n\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xea\x14\x02\x08\n\
    \r\n\x05\x04u\x02\x01\x01\x12\x04\xea\x14\t\x14\n\r\n\x05\x04u\x02\x01\
    \x03\x12\x04\xea\x14\x17\x18\n\x83\x02\n\x04\x04u\x02\x02\x12\x04\xf1\
    \x14\x02+\x1a\xf4\x01\x20When\x20the\x20collector\x20is\x20created.\x20W\
    e\x20follow\x20the\x20XXXX\x20timestamp\n\x20format.\x20We\x20use\x20htt\
    ps://www.ietf.org/rfc/rfc3339.txt\x20format:\n\x20\"2006-01-02T15:04:05.\
    999999Z\"\x20so\x20you\x20can\x20expect\x20results\x20like\n\x20the\x20f\
    ollowing\x20from\x20the\x20API:\n\x20\"2017-04-11T21:50:50.223962Z\"\n\n\
    \r\n\x05\x04u\x02\x02\x06\x12\x04\xf1\x14\x02\x1b\n\r\n\x05\x04u\x02\x02\
    \x01\x12\x04\xf1\x14\x1c&\n\r\n\x05\x04u\x02\x02\x03\x12\x04\xf1\x14)*\n\
    \xb7\x05\n\x04\x04u\x02\x03\x12\x04\xfb\x14\x02#\x1a\xa8\x05\x20This\x20\
    is\x20a\x20workflow\x20to\x20run\x20inline\x20in\x20model\x20predict\x20\
    calls.\x20It\x20should\x20ONLY\x20have\x20very\x20fast\x20and\n\x20light\
    -weight\x20models\x20in\x20it\x20as\x20it\x20will\x20effect\x20the\x20sp\
    eed\x20of\x20the\x20predictions\x20being\x20made.\n\x20This\x20workflow'\
    s\x20purpose\x20is\x20to\x20filter\x20down\x20the\x20inputs\x20to\x20que\
    ue\x20for\x20the\x20collector\x20to\x20process.\n\x20The\x20input\x20to\
    \x20this\x20workflow\x20is\x20going\x20to\x20be\x20the\x20OUTPUT\x20of\
    \x20the\x20model,\x20not\x20the\x20input\x20to\x20the\x20model\n\x20sinc\
    e\x20we\x20want\x20to\x20encourage\x20having\x20fast\x20workflows\x20tha\
    t\x20can\x20also\x20take\x20advantage\x20of\x20the\x20model\n\x20outputs\
    \x20to\x20make\x20deciions\x20(for\x20example:\x20thresholding\x20based\
    \x20on\x20concepts).\x20If\x20the\x20workflow\n\x20output\x20has\x20any\
    \x20field\x20that\x20is\x20non-empty\x20then\x20the\x20input\x20will\x20\
    be\x20queued\x20for\x20the\x20collector\n\x20to\x20process\x20with\x20th\
    e\x20post_queue_workflow_id.\n\n\r\n\x05\x04u\x02\x03\x05\x12\x04\xfb\
    \x14\x02\x08\n\r\n\x05\x04u\x02\x03\x01\x12\x04\xfb\x14\t\x1e\n\r\n\x05\
    \x04u\x02\x03\x03\x12\x04\xfb\x14!\"\n\x8b\x03\n\x04\x04u\x02\x04\x12\
    \x04\x82\x15\x02$\x1a\xfc\x02\x20A\x20workflow\x20to\x20run\x20to\x20aft\
    er\x20the\x20collector\x20is\x20processing\x20the\x20queued\x20input.\
    \x20This\x20workflow\n\x20uses\x20the\x20original\x20input\x20to\x20the\
    \x20model\x20as\x20input\x20to\x20the\x20workflow\x20so\x20that\x20you\
    \x20can\x20run\x20additional\n\x20models\x20as\x20well\x20on\x20that\x20\
    input\x20to\x20decide\x20whether\x20to\x20queue\x20the\x20model\x20or\
    \x20not.\x20If\x20the\x20workflow\n\x20output\x20has\x20any\x20field\x20\
    that\x20is\x20non-empty\x20then\x20it\x20will\x20be\x20passed\x20on\x20t\
    o\x20POST\x20/inputs\x20to\n\x20the\x20destination\x20app.\n\n\r\n\x05\
    \x04u\x02\x04\x05\x12\x04\x82\x15\x02\x08\n\r\n\x05\x04u\x02\x04\x01\x12\
    \x04\x82\x15\t\x1f\n\r\n\x05\x04u\x02\x04\x03\x12\x04\x82\x15\"#\n\xeb\
    \x02\n\x04\x04u\x02\x05\x12\x04\x89\x15\x02'\x1a\xdc\x02\x20The\x20sourc\
    e\x20of\x20the\x20collector\x20to\x20feed\x20data\x20into\x20this\x20app\
    .\n\x20Note(zeiler):\x20if\x20we\x20wanted\x20more\x20than\x20one\x20sou\
    rce\x20per\x20collector\x20we\x20could\x20make\x20this\x20it's\x20own\n\
    \x20object\x20and\x20introduce\x20/collectors/{collector_id}/sources\n\
    \x20We\x20will\x20keep\x20it\x20simple\x20for\x20now\x20and\x20have\x20j\
    ust\x20one\x20source\x20per\x20collector\x20since\x20a\x20user\x20can\
    \x20make\n\x20more\x20than\x20one\x20collector\x20in\x20the\x20same\x20a\
    pp\x20anyways.\n\n\r\n\x05\x04u\x02\x05\x06\x12\x04\x89\x15\x02\x11\n\r\
    \n\x05\x04u\x02\x05\x01\x12\x04\x89\x15\x12\"\n\r\n\x05\x04u\x02\x05\x03\
    \x12\x04\x89\x15%&\n\xd7\x03\n\x04\x04u\x02\x06\x12\x04\x94\x15\x02(\x1a\
    l\x20Status\x20for\x20the\x20collector.\x20This\x20allows\x20you\x20to\
    \x20pause\x20a\x20collector\x20without\x20having\x20to\x20delete\x20it\
    \x20as\n\x20an\x20example.\n2\xda\x02\x20This\x20is\x20the\x20workflow\
    \x20ID\x20to\x20do\x20POST\x20/inputs\x20with\x20the\x20collected\x20dat\
    a\x20using.\n\x20This\x20needs\x20to\x20be\x20present\x20at\x20all\x20ti\
    mes\x20in\x20this\x20app\x20for\x20the\x20collector\x20to\x20work.\n\x20\
    If\x20this\x20is\x20not\x20specified\x20then\x20it\x20will\x20use\x20the\
    \x20default_workflow_id\x20of\x20the\x20app.\n\x20Note(zeiler):\x20not\
    \x20yet\x20available,\x20uses\x20only\x20the\x20default\x20workflow\x20t\
    hat\x20POST\x20/inputs\x20uses.\n\x20string\x20workflow_id\x20=\x207;\n\
    \n\r\n\x05\x04u\x02\x06\x06\x12\x04\x94\x15\x02\x1c\n\r\n\x05\x04u\x02\
    \x06\x01\x12\x04\x94\x15\x1d#\n\r\n\x05\x04u\x02\x06\x03\x12\x04\x94\x15\
    &'\n\xdb\x01\n\x02\x04v\x12\x06\x9a\x15\0\xa1\x15\x01\x1af\x20Configurat\
    ion\x20for\x20the\x20source\x20to\x20collect\x20data\x20from.\n\x20Only\
    \x20one\x20of\x20the\x20fields\x20can\x20be\x20present\x20at\x20a\x20tim\
    e.\n\"e\x20The\x20ID\x20of\x20the\x20source\x20in\x20case\x20we\x20want\
    \x20to\x20implment\x20/collectors/{collector_id}/sources\n\x20string\x20\
    id\x20=\x201;\n\n\x0b\n\x03\x04v\x01\x12\x04\x9a\x15\x08\x17\n\xbb\x01\n\
    \x04\x04v\x02\0\x12\x04\xa0\x15\x02Q\x1a\xac\x01\x20Collect\x20from\x20t\
    he\x20inputs\x20passed\x20in\x20for\x20PostModelOutputs\x20predictions\
    \x20of\x20a\x20specific\x20model.\n\x20This\x20does\x20not\x20apply\x20t\
    o\x20models\x20used\x20within\x20workflows,\x20only\x20PostModelOutputs\
    \x20calls.\n\n\r\n\x05\x04v\x02\0\x06\x12\x04\xa0\x15\x02$\n\r\n\x05\x04\
    v\x02\0\x01\x12\x04\xa0\x15%L\n\r\n\x05\x04v\x02\0\x03\x12\x04\xa0\x15OP\
    \n{\n\x02\x04w\x12\x06\xa7\x15\0\xc4\x15\x01\x1am\x20This\x20is\x20confi\
    guration\x20for\x20using\x20the\x20inputs\x20send\x20for\x20model\x20pre\
    diction\x20in\x20our\x20API\x20as\n\x20as\x20the\x20source\x20for\x20dat\
    a.\n\n\x0b\n\x03\x04w\x01\x12\x04\xa7\x15\x08*\n\xbb\x01\n\x04\x04w\x02\
    \0\x12\x04\xab\x15\x02\x1b\x1a\xac\x01\x20To\x20define\x20the\x20model\
    \x20that\x20we\x20should\x20collect\x20from\x20we\x20need\x20to\x20speci\
    fy\x20the\x20following\x204\x20IDs:\n\x20The\x20User\x20ID\x20of\x20the\
    \x20model\x20we\x20want\x20to\x20collect\x20from.\n\x20This\x20is\x20Use\
    r\x20B\x20in\x20the\x20example.\n\n\r\n\x05\x04w\x02\0\x05\x12\x04\xab\
    \x15\x02\x08\n\r\n\x05\x04w\x02\0\x01\x12\x04\xab\x15\t\x16\n\r\n\x05\
    \x04w\x02\0\x03\x12\x04\xab\x15\x19\x1a\n@\n\x04\x04w\x02\x01\x12\x04\
    \xad\x15\x02\x1a\x1a2\x20The\x20App\x20ID\x20of\x20the\x20model\x20we\
    \x20want\x20to\x20collect\x20from.\n\n\r\n\x05\x04w\x02\x01\x05\x12\x04\
    \xad\x15\x02\x08\n\r\n\x05\x04w\x02\x01\x01\x12\x04\xad\x15\t\x15\n\r\n\
    \x05\x04w\x02\x01\x03\x12\x04\xad\x15\x18\x19\nB\n\x04\x04w\x02\x02\x12\
    \x04\xaf\x15\x02\x16\x1a4\x20The\x20Model\x20ID\x20of\x20the\x20model\
    \x20we\x20want\x20to\x20collect\x20from.\n\n\r\n\x05\x04w\x02\x02\x05\
    \x12\x04\xaf\x15\x02\x08\n\r\n\x05\x04w\x02\x02\x01\x12\x04\xaf\x15\t\
    \x11\n\r\n\x05\x04w\x02\x02\x03\x12\x04\xaf\x15\x14\x15\nD\n\x04\x04w\
    \x02\x03\x12\x04\xb1\x15\x02\x1e\x1a6\x20The\x20Version\x20ID\x20of\x20t\
    he\x20model\x20we\x20want\x20to\x20collect\x20from.\n\n\r\n\x05\x04w\x02\
    \x03\x05\x12\x04\xb1\x15\x02\x08\n\r\n\x05\x04w\x02\x03\x01\x12\x04\xb1\
    \x15\t\x19\n\r\n\x05\x04w\x02\x03\x03\x12\x04\xb1\x15\x1c\x1d\n\xdb\x01\
    \n\x04\x04w\x02\x04\x12\x04\xb6\x15\x02\x20\x1a\xcc\x01\x20This\x20key\
    \x20is\x20used\x20to\x20POST\x20/inputs\x20into\x20your\x20app\x20by\x20\
    the\x20collector.\x20It\x20can\x20be\x20an\x20API\x20key\x20or\x20a\n\
    \x20PAT.\x20This\x20needs\x20the\x20permissions\x20that\x20are\x20needed\
    \x20for\x20POST\x20/inputs\x20for\x20the\x20app_id\x20this\n\x20Collecto\
    r\x20is\x20defined\x20in.\n\n\r\n\x05\x04w\x02\x04\x05\x12\x04\xb6\x15\
    \x02\x08\n\r\n\x05\x04w\x02\x04\x01\x12\x04\xb6\x15\t\x1b\n\r\n\x05\x04w\
    \x02\x04\x03\x12\x04\xb6\x15\x1e\x1f\n\xc8\x01\n\x02\x04x\x12\x06\xcd\
    \x15\0\xd9\x15\x01\x1a\xb9\x01//////////////////////////////////////////\
    ////////////////////////////////////\n\x20Stats\x20Collection\x20Objects\
    .\n/////////////////////////////////////////////////////////////////////\
    /////////\n\n\x0b\n\x03\x04x\x01\x12\x04\xcd\x15\x08\x11\n9\n\x04\x04x\
    \x02\0\x12\x04\xcf\x15\x02%\x1a+\x20The\x20time\x20of\x20the\x20event.\
    \x20Defaults\x20to\x20now().\n\n\r\n\x05\x04x\x02\0\x06\x12\x04\xcf\x15\
    \x02\x1b\n\r\n\x05\x04x\x02\0\x01\x12\x04\xcf\x15\x1c\x20\n\r\n\x05\x04x\
    \x02\0\x03\x12\x04\xcf\x15#$\n8\n\x04\x04x\x02\x01\x12\x04\xd2\x15\x02\
    \x12\x1a*\x20A\x20value\x20for\x20the\x20metric\x20you're\x20recording.\
    \n\n\r\n\x05\x04x\x02\x01\x05\x12\x04\xd2\x15\x02\x07\n\r\n\x05\x04x\x02\
    \x01\x01\x12\x04\xd2\x15\x08\r\n\r\n\x05\x04x\x02\x01\x03\x12\x04\xd2\
    \x15\x10\x11\n\xcf\x02\n\x04\x04x\x02\x02\x12\x04\xd8\x15\x02\x1b\x1a\
    \xc0\x02\x20List\x20of\x20tags\x20to\x20attach\x20to\x20this\x20stat.\
    \x20Each\x20should\x20contain\x20one\x20colon\x20so\x20that\x20the\x20fi\
    rst\x20part\x20will\n\x20be\x20used\x20as\x20a\x20tag\x20group\x20while\
    \x20the\x20second\x20being\x20the\x20tag\x20itself.\x20For\x20example:\
    \x20[\"task_id:a\",\n\x20\"worker_id:1\"].\x20These\x20tag\x20groups\x20\
    like\x20\"task_id\"\x20or\x20\"worker_id\"\x20are\x20important\x20for\
    \x20aggregating\n\x20values\x20in\x20the\x20StatValueAggregateQuery.\n\n\
    \r\n\x05\x04x\x02\x02\x04\x12\x04\xd8\x15\x02\n\n\r\n\x05\x04x\x02\x02\
    \x05\x12\x04\xd8\x15\x0b\x11\n\r\n\x05\x04x\x02\x02\x01\x12\x04\xd8\x15\
    \x12\x16\n\r\n\x05\x04x\x02\x02\x03\x12\x04\xd8\x15\x19\x1a\n\x0c\n\x02\
    \x04y\x12\x06\xdd\x15\0\xe3\x15\x01\n\x0b\n\x03\x04y\x01\x12\x04\xdd\x15\
    \x08\x20\nG\n\x04\x04y\x02\0\x12\x04\xdf\x15\x028\x1a9\x20The\x20list\
    \x20of\x20repeated\x20aggregate\x20values\x20and\x20their\x20counts.\n\n\
    \r\n\x05\x04y\x02\0\x04\x12\x04\xdf\x15\x02\n\n\r\n\x05\x04y\x02\0\x06\
    \x12\x04\xdf\x15\x0b\x1d\n\r\n\x05\x04y\x02\0\x01\x12\x04\xdf\x15\x1e3\n\
    \r\n\x05\x04y\x02\0\x03\x12\x04\xdf\x1567\n5\n\x04\x04y\x02\x01\x12\x04\
    \xe2\x15\x029\x1a'\x20The\x20query\x20that\x20created\x20these\x20result\
    s.\n\n\r\n\x05\x04y\x02\x01\x06\x12\x04\xe2\x15\x02\x19\n\r\n\x05\x04y\
    \x02\x01\x01\x12\x04\xe2\x15\x1a4\n\r\n\x05\x04y\x02\x01\x03\x12\x04\xe2\
    \x1578\n\x0c\n\x02\x04z\x12\x06\xe7\x15\0\xf3\x15\x01\n\x0b\n\x03\x04z\
    \x01\x12\x04\xe7\x15\x08\x1a\n\x87\x02\n\x04\x04z\x02\0\x12\x04\xeb\x15\
    \x02%\x1a\xf8\x01\x20The\x20time\x20of\x20the\x20aggregation.\x20For\x20\
    example,\x20if\x20you\x20aggregate\x20over\x20\"HOUR\"\x20buckets\x20the\
    n\x20you\x20can\n\x20expect\x20each\x20hour\x20that\x20has\x20atleast\
    \x20one\x20value\x20(matching\x20the\x20rest\x20of\x20your\x20query\x20f\
    ields)\x20will\x20have\n\x20a\x20StatValueAggregate\x20with\x20the\x20ti\
    me\x20filled\x20into\x20that\x20hour.\n\n\r\n\x05\x04z\x02\0\x06\x12\x04\
    \xeb\x15\x02\x1b\n\r\n\x05\x04z\x02\0\x01\x12\x04\xeb\x15\x1c\x20\n\r\n\
    \x05\x04z\x02\0\x03\x12\x04\xeb\x15#$\nI\n\x04\x04z\x02\x01\x12\x04\xed\
    \x15\x02\x1c\x1a;\x20The\x20value\x20aggregated\x20according\x20to\x20th\
    e\x20stat_value_agg_type\n\n\r\n\x05\x04z\x02\x01\x05\x12\x04\xed\x15\
    \x02\x07\n\r\n\x05\x04z\x02\x01\x01\x12\x04\xed\x15\x08\x17\n\r\n\x05\
    \x04z\x02\x01\x03\x12\x04\xed\x15\x1a\x1b\nP\n\x04\x04z\x02\x02\x12\x04\
    \xef\x15\x02\x13\x1aB\x20The\x20count\x20of\x20the\x20stat\x20values\x20\
    that\x20were\x20used\x20in\x20this\x20aggregation.\n\n\r\n\x05\x04z\x02\
    \x02\x05\x12\x04\xef\x15\x02\x08\n\r\n\x05\x04z\x02\x02\x01\x12\x04\xef\
    \x15\t\x0e\n\r\n\x05\x04z\x02\x02\x03\x12\x04\xef\x15\x11\x12\n\x92\x01\
    \n\x04\x04z\x02\x03\x12\x04\xf2\x15\x02\x1b\x1a\x83\x01\x20The\x20tags\
    \x20for\x20this\x20aggregated_value\x20and\x20count.\x20This\x20will\x20\
    be\x20filled\x20in\x20if\x20tag\x20groups\x20were\x20used\x20in\n\x20the\
    \x20query\x20to\x20group\x20aggregations.\n\n\r\n\x05\x04z\x02\x03\x04\
    \x12\x04\xf2\x15\x02\n\n\r\n\x05\x04z\x02\x03\x05\x12\x04\xf2\x15\x0b\
    \x11\n\r\n\x05\x04z\x02\x03\x01\x12\x04\xf2\x15\x12\x16\n\r\n\x05\x04z\
    \x02\x03\x03\x12\x04\xf2\x15\x19\x1a\n\x0c\n\x02\x04{\x12\x06\xf7\x15\0\
    \x99\x16\x01\n\x0b\n\x03\x04{\x01\x12\x04\xf7\x15\x08\x1f\n\xbe\x01\n\
    \x04\x04{\x02\0\x12\x04\xfa\x15\x02\x1b\x1a\xaf\x01\x20These\x20tags\x20\
    are\x20used\x20to\x20filter\x20down\x20the\x20values\x20before\x20they\
    \x20are\x20aggregated.\x20For\x20example,\n\x20if\x20you\x20want\x20to\
    \x20aggregate\x20values\x20for\x20\"task_id:a\"\x20you\x20could\x20speci\
    fy\x20that\x20as\x20a\x20tag\x20here.\n\n\r\n\x05\x04{\x02\0\x04\x12\x04\
    \xfa\x15\x02\n\n\r\n\x05\x04{\x02\0\x05\x12\x04\xfa\x15\x0b\x11\n\r\n\
    \x05\x04{\x02\0\x01\x12\x04\xfa\x15\x12\x16\n\r\n\x05\x04{\x02\0\x03\x12\
    \x04\xfa\x15\x19\x1a\n\xdb\x04\n\x04\x04{\x02\x01\x12\x04\x87\x16\x02!\
    \x1a\xcc\x04\x20These\x20are\x20tag\x20groups\x20to\x20aggregate\x20over\
    .\x20So\x20for\x20example\x20if\x20you\x20added\x20stat\x20values\x20wit\
    h\x20tags\n\x20\"task_id:a\"\x20and\x20others\x20with\x20\"task_id:b\",\
    \x20then\x20added\x20[\"task_id\"]\x20to\x20the\x20task\x20group,\x20it\
    \x20the\n\x20aggregation\x20would\x20return\x20StatValueAggregate\x20val\
    ues\x20for\x20each\x20task_id.\x20If\x20you\x20provide\x20more\x20than\n\
    \x20one\x20tag_group\x20the\x20response\x20will\x20return\x20all\x20roll\
    ed\x20up\x20combinations\x20of\x20them.\x20For\x20example\n\x20[\"task_i\
    d\",\x20\"something\"]\x20where\x20\"something:1\"\x20and\x20\"something\
    :2\"\x20were\x20used\x20as\x20tags\x20for\x20some\n\x20values\x20then\
    \x20you'd\x20get\x20StatValueAggregate\x20values\x20back\x20for:\n\x20ta\
    sk_id\x20|\x20something\n\x20a\x20\x20\x20\x20\x20\x20\x20|\x201\n\x20a\
    \x20\x20\x20\x20\x20\x20\x20|\x202\n\x20b\x20\x20\x20\x20\x20\x20\x20|\
    \x201\n\x20b\x20\x20\x20\x20\x20\x20\x20|\x201\n\n\r\n\x05\x04{\x02\x01\
    \x04\x12\x04\x87\x16\x02\n\n\r\n\x05\x04{\x02\x01\x05\x12\x04\x87\x16\
    \x0b\x11\n\r\n\x05\x04{\x02\x01\x01\x12\x04\x87\x16\x12\x1c\n\r\n\x05\
    \x04{\x02\x01\x03\x12\x04\x87\x16\x1f\x20\n\x85\x01\n\x04\x04{\x02\x02\
    \x12\x04\x8b\x16\x02+\x1aw\x20Aggregation\x20function\x20to\x20use\x20ov\
    er\x20the\x20values.\x20Count(value)\x20is\x20also\x20always\x20returns.\
    \n\x20Defaults\x20to\x20'sum'\x20if\x20not\x20provided.\n\n\r\n\x05\x04{\
    \x02\x02\x06\x12\x04\x8b\x16\x02\x12\n\r\n\x05\x04{\x02\x02\x01\x12\x04\
    \x8b\x16\x13&\n\r\n\x05\x04{\x02\x02\x03\x12\x04\x8b\x16)*\n\xf7\x01\n\
    \x04\x04{\x02\x03\x12\x04\x90\x16\x02)\x1a\xe8\x01\x20Aggregation\x20bin\
    s\x20for\x20time\x20where\x20the\x20values\x20will\x20be\x20aggregated\
    \x20at\x20this\x20bin\x20granualarity.\n\x20And\x20the\x20\"time\"\x20fi\
    eld\x20will\x20be\x20returned\x20in\x20StatValueAggregate\x20object.\n\
    \x20If\x20not\x20provided\x20then\x20bins\x20are\x20not\x20used,\x20and\
    \x20all\x20time\x20is\x20aggregated\x20over.\n\n\r\n\x05\x04{\x02\x03\
    \x06\x12\x04\x90\x16\x02\x11\n\r\n\x05\x04{\x02\x03\x01\x12\x04\x90\x16\
    \x12$\n\r\n\x05\x04{\x02\x03\x03\x12\x04\x90\x16'(\n\x98\x01\n\x04\x04{\
    \x02\x04\x12\x04\x94\x16\x02+\x1a\x89\x01\x20If\x20provided\x20the\x20ti\
    me\x20range\x20over\x20which\x20values\x20will\x20be\x20>=\x20this\x20ti\
    me.\x20If\x20not\x20provided\x20then\n\x20all\x20values\x20will\x20be\
    \x20used\x20back\x20to\x20start\x20of\x20time.\n\n\r\n\x05\x04{\x02\x04\
    \x06\x12\x04\x94\x16\x02\x1b\n\r\n\x05\x04{\x02\x04\x01\x12\x04\x94\x16\
    \x1c&\n\r\n\x05\x04{\x02\x04\x03\x12\x04\x94\x16)*\n\x91\x01\n\x04\x04{\
    \x02\x05\x12\x04\x98\x16\x02)\x1a\x82\x01\x20If\x20provided\x20the\x20ti\
    me\x20range\x20over\x20which\x20values\x20will\x20be\x20<=\x20this\x20ti\
    me.\x20If\x20not\x20provided\x20then\x20all\n\x20values\x20will\x20be\
    \x20used\x20up\x20until\x20now().\n\n\r\n\x05\x04{\x02\x05\x06\x12\x04\
    \x98\x16\x02\x1b\n\r\n\x05\x04{\x02\x05\x01\x12\x04\x98\x16\x1c$\n\r\n\
    \x05\x04{\x02\x05\x03\x12\x04\x98\x16'(\n\x0c\n\x02\x05\x07\x12\x06\x9a\
    \x16\0\x9d\x16\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\x9a\x16\x05\x15\n\x0c\
    \n\x04\x05\x07\x02\0\x12\x04\x9b\x16\x02\n\n\r\n\x05\x05\x07\x02\0\x01\
    \x12\x04\x9b\x16\x02\x05\n\r\n\x05\x05\x07\x02\0\x02\x12\x04\x9b\x16\x08\
    \t\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\x9c\x16\x02\n\n\r\n\x05\x05\x07\
    \x02\x01\x01\x12\x04\x9c\x16\x02\x05\n\r\n\x05\x05\x07\x02\x01\x02\x12\
    \x04\x9c\x16\x08\t\n\x0c\n\x02\x05\x08\x12\x06\x9f\x16\0\xa7\x16\x01\n\
    \x0b\n\x03\x05\x08\x01\x12\x04\x9f\x16\x05\x14\n\x0c\n\x04\x05\x08\x02\0\
    \x12\x04\xa0\x16\x02\x12\n\r\n\x05\x05\x08\x02\0\x01\x12\x04\xa0\x16\x02\
    \r\n\r\n\x05\x05\x08\x02\0\x02\x12\x04\xa0\x16\x10\x11\n\x0c\n\x04\x05\
    \x08\x02\x01\x12\x04\xa1\x16\x02\x0b\n\r\n\x05\x05\x08\x02\x01\x01\x12\
    \x04\xa1\x16\x02\x06\n\r\n\x05\x05\x08\x02\x01\x02\x12\x04\xa1\x16\t\n\n\
    \x0c\n\x04\x05\x08\x02\x02\x12\x04\xa2\x16\x02\x0c\n\r\n\x05\x05\x08\x02\
    \x02\x01\x12\x04\xa2\x16\x02\x07\n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\
    \xa2\x16\n\x0b\n\x0c\n\x04\x05\x08\x02\x03\x12\x04\xa3\x16\x02\x0b\n\r\n\
    \x05\x05\x08\x02\x03\x01\x12\x04\xa3\x16\x02\x06\n\r\n\x05\x05\x08\x02\
    \x03\x02\x12\x04\xa3\x16\t\n\n\x0c\n\x04\x05\x08\x02\x04\x12\x04\xa4\x16\
    \x02\n\n\r\n\x05\x05\x08\x02\x04\x01\x12\x04\xa4\x16\x02\x05\n\r\n\x05\
    \x05\x08\x02\x04\x02\x12\x04\xa4\x16\x08\t\n\x0c\n\x04\x05\x08\x02\x05\
    \x12\x04\xa5\x16\x02\x0b\n\r\n\x05\x05\x08\x02\x05\x01\x12\x04\xa5\x16\
    \x02\x06\n\r\n\x05\x05\x08\x02\x05\x02\x12\x04\xa5\x16\t\n\n\x0c\n\x04\
    \x05\x08\x02\x06\x12\x04\xa6\x16\x02\r\n\r\n\x05\x05\x08\x02\x06\x01\x12\
    \x04\xa6\x16\x02\x08\n\r\n\x05\x05\x08\x02\x06\x02\x12\x04\xa6\x16\x0b\
    \x0c\n\xb0\x05\n\x02\x04|\x12\x06\xc8\x16\0\xd7\x16\x01\x1a\xcb\x04/////\
    //////////////////////\n\x20Visibilty\x20of\x20the\x20resource.\n///////\
    ////////////////////\n\x20Visibility\x20represents\x20how\x20visible\x20\
    the\x20given\x20resource\x20is\x20to\x20other\x20users.\n\x20When\x20aut\
    henticating\x20a\x20request\x20we\x20can\x20tell\x20if\x20a\x20user\x20i\
    s\x20a\x20collaborator\x20or\x20a\x20teammate\x20for\x20the\n\x20the\x20\
    app\x20that\x20contains\x20the\x20resource\x20and\x20set\x20their\x20all\
    owed\x20visibility.\x20We\x20use\x20that\x20to\x20restrict\n\x20what\x20\
    they\x20are\x20allowed\x20to\x20see:\n\x20If\x20AllowedVisibility\x20is\
    \x20PRIVATE\x20then\x20we\x20allow\x20PRIVATE\x20(10),\x20ORG\x20(30),\
    \x20PUBLIC\x20(50)\n\x20If\x20AllowedVisibility\x20is\x20ORG\x20then\x20\
    we\x20allow\x20ORG\x20(30),\x20PUBLIC\x20(50)\n\x20If\x20AllowedVisibili\
    ty\x20is\x20PUBLIC\x20then\x20we\x20allow\x20PUBLIC\x20(50)\x20only.\n2T\
    \nSDK\x20Billing\x20Cycle\x20defines\x20which\x20year\x20and\x20month\
    \x20is\x20associated\x20with\x20the\x20billing\x20data\n\n\x0b\n\x03\x04\
    |\x01\x12\x04\xc8\x16\x08\x12\n\\\n\x04\x04|\x04\0\x12\x06\xca\x16\x02\
    \xd5\x16\x03\x1aL\x20Gettable\x20defined\x20the\x20level\x20of\x20access\
    \x20for\x20GET\x20operations\x20for\x20this\x20resource.\n\n\r\n\x05\x04\
    |\x04\0\x01\x12\x04\xca\x16\x07\x0f\n,\n\x06\x04|\x04\0\x02\0\x12\x04\
    \xcc\x16\x04\x1b\x1a\x1c\x20Default\x20value\x20not\x20allowed.\n\n\x0f\
    \n\x07\x04|\x04\0\x02\0\x01\x12\x04\xcc\x16\x04\x16\n\x0f\n\x07\x04|\x04\
    \0\x02\0\x02\x12\x04\xcc\x16\x19\x1a\nb\n\x06\x04|\x04\0\x02\x01\x12\x04\
    \xce\x16\x04\x11\x1aR\x20PRIVATE\x20requires\x20collaborator\x20or\x20te\
    am\x20permissions\x20in\x20order\x20to\x20GET\x20this\x20resource.\n\n\
    \x0f\n\x07\x04|\x04\0\x02\x01\x01\x12\x04\xce\x16\x04\x0b\n\x0f\n\x07\
    \x04|\x04\0\x02\x01\x02\x12\x04\xce\x16\x0e\x10\n\x89\x01\n\x06\x04|\x04\
    \0\x02\x02\x12\x04\xd1\x16\x04\r\x1ay\x20ORG\x20requires\x20you\x20to\
    \x20be\x20in\x20the\x20same\x20org\x20in\x20order\x20to\x20GET\x20this\
    \x20resource,\x20but\x20don't\x20have\x20to\x20be\x20a\n\x20teammate\x20\
    or\x20collaborator.\n\n\x0f\n\x07\x04|\x04\0\x02\x02\x01\x12\x04\xd1\x16\
    \x04\x07\n\x0f\n\x07\x04|\x04\0\x02\x02\x02\x12\x04\xd1\x16\n\x0c\n\x8a\
    \x01\n\x06\x04|\x04\0\x02\x03\x12\x04\xd4\x16\x04\x10\x1az\x20PUBLIC\x20\
    opens\x20up\x20GET\x20access\x20to\x20the\x20resource\x20to\x20any\x20us\
    er\x20on\x20the\x20platform\x20even\x20if\x20they\x20are\x20not\n\x20a\
    \x20teammate\x20or\x20collaborator.\n\n\x0f\n\x07\x04|\x04\0\x02\x03\x01\
    \x12\x04\xd4\x16\x04\n\n\x0f\n\x07\x04|\x04\0\x02\x03\x02\x12\x04\xd4\
    \x16\r\x0f\n\x0c\n\x04\x04|\x02\0\x12\x04\xd6\x16\x02\x18\n\r\n\x05\x04|\
    \x02\0\x06\x12\x04\xd6\x16\x02\n\n\r\n\x05\x04|\x02\0\x01\x12\x04\xd6\
    \x16\x0b\x13\n\r\n\x05\x04|\x02\0\x03\x12\x04\xd6\x16\x16\x17\n\x0c\n\
    \x02\x04}\x12\x06\xd9\x16\0\xde\x16\x01\n\x0b\n\x03\x04}\x01\x12\x04\xd9\
    \x16\x08\x16\n\x0c\n\x04\x04}\x02\0\x12\x04\xda\x16\x02\x15\n\r\n\x05\
    \x04}\x02\0\x05\x12\x04\xda\x16\x02\x08\n\r\n\x05\x04}\x02\0\x01\x12\x04\
    \xda\x16\t\x10\n\r\n\x05\x04}\x02\0\x03\x12\x04\xda\x16\x13\x14\n\x0c\n\
    \x04\x04}\x02\x01\x12\x04\xdb\x16\x02\x14\n\r\n\x05\x04}\x02\x01\x05\x12\
    \x04\xdb\x16\x02\x08\n\r\n\x05\x04}\x02\x01\x01\x12\x04\xdb\x16\t\x0f\n\
    \r\n\x05\x04}\x02\x01\x03\x12\x04\xdb\x16\x12\x13\n\x0c\n\x04\x04}\x02\
    \x02\x12\x04\xdc\x16\x02\x17\n\r\n\x05\x04}\x02\x02\x05\x12\x04\xdc\x16\
    \x02\x08\n\r\n\x05\x04}\x02\x02\x01\x12\x04\xdc\x16\t\x12\n\r\n\x05\x04}\
    \x02\x02\x03\x12\x04\xdc\x16\x15\x16\n\x0c\n\x04\x04}\x02\x03\x12\x04\
    \xdd\x16\x02\x18\n\r\n\x05\x04}\x02\x03\x05\x12\x04\xdd\x16\x02\x08\n\r\
    \n\x05\x04}\x02\x03\x01\x12\x04\xdd\x16\t\x13\n\r\n\x05\x04}\x02\x03\x03\
    \x12\x04\xdd\x16\x16\x17\n\x0c\n\x02\x05\t\x12\x06\xe2\x16\0\xe8\x16\x01\
    \n\x0b\n\x03\x05\t\x01\x12\x04\xe2\x16\x05\x18\n\x0c\n\x04\x05\t\x02\0\
    \x12\x04\xe3\x16\x02$\n\r\n\x05\x05\t\x02\0\x01\x12\x04\xe3\x16\x02\x1f\
    \n\r\n\x05\x05\t\x02\0\x02\x12\x04\xe3\x16\"#\n\x0c\n\x04\x05\t\x02\x01\
    \x12\x04\xe5\x16\x02\x11\n\r\n\x05\x05\t\x02\x01\x01\x12\x04\xe5\x16\x02\
    \x0c\n\r\n\x05\x05\t\x02\x01\x02\x12\x04\xe5\x16\x0f\x10\n\x0c\n\x04\x05\
    \t\x02\x02\x12\x04\xe6\x16\x02\x0f\n\r\n\x05\x05\t\x02\x02\x01\x12\x04\
    \xe6\x16\x02\n\n\r\n\x05\x05\t\x02\x02\x02\x12\x04\xe6\x16\r\x0e\n\x0c\n\
    \x04\x05\t\x02\x03\x12\x04\xe7\x16\x02\r\n\r\n\x05\x05\t\x02\x03\x01\x12\
    \x04\xe7\x16\x02\x08\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\xe7\x16\x0b\x0c\
    \n\x0c\n\x02\x04~\x12\x06\xef\x16\0\xf6\x16\x01\n\x0b\n\x03\x04~\x01\x12\
    \x04\xef\x16\x08\x13\n1\n\x04\x04~\x02\0\x12\x04\xf1\x16\x02\x10\x1a#\
    \x20A\x20unique\x20id\x20for\x20the\x20time\x20segment.\n\n\r\n\x05\x04~\
    \x02\0\x05\x12\x04\xf1\x16\x02\x08\n\r\n\x05\x04~\x02\0\x01\x12\x04\xf1\
    \x16\t\x0b\n\r\n\x05\x04~\x02\0\x03\x12\x04\xf1\x16\x0e\x0f\n\x0c\n\x04\
    \x04~\x02\x01\x12\x04\xf3\x16\x02\x10\n\r\n\x05\x04~\x02\x01\x06\x12\x04\
    \xf3\x16\x02\x06\n\r\n\x05\x04~\x02\x01\x01\x12\x04\xf3\x16\x07\x0b\n\r\
    \n\x05\x04~\x02\x01\x03\x12\x04\xf3\x16\x0e\x0f\n\x0c\n\x04\x04~\x02\x02\
    \x12\x04\xf5\x16\x02\x19\n\r\n\x05\x04~\x02\x02\x06\x12\x04\xf5\x16\x02\
    \n\n\r\n\x05\x04~\x02\x02\x01\x12\x04\xf5\x16\x0b\x14\n\r\n\x05\x04~\x02\
    \x02\x03\x12\x04\xf5\x16\x17\x18\n\x0c\n\x02\x04\x7f\x12\x06\xf8\x16\0\
    \xff\x16\x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\xf8\x16\x08\x10\n\x20\n\x04\
    \x04\x7f\x02\0\x12\x04\xfa\x16\x02\x18\x1a\x12\x20Number\x20of\x20frames\
    \n\n\r\n\x05\x04\x7f\x02\0\x05\x12\x04\xfa\x16\x02\x08\n\r\n\x05\x04\x7f\
    \x02\0\x01\x12\x04\xfa\x16\t\x13\n\r\n\x05\x04\x7f\x02\0\x03\x12\x04\xfa\
    \x16\x16\x17\n-\n\x04\x04\x7f\x02\x01\x12\x04\xfc\x16\x02\x18\x1a\x1f\
    \x20Timestamp\x20where\x20track\x20begins.\n\n\r\n\x05\x04\x7f\x02\x01\
    \x05\x12\x04\xfc\x16\x02\x08\n\r\n\x05\x04\x7f\x02\x01\x01\x12\x04\xfc\
    \x16\t\x13\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\xfc\x16\x16\x17\n+\n\
    \x04\x04\x7f\x02\x02\x12\x04\xfe\x16\x02\x16\x1a\x1d\x20Timestamp\x20whe\
    re\x20track\x20ends.\n\n\r\n\x05\x04\x7f\x02\x02\x05\x12\x04\xfe\x16\x02\
    \x08\n\r\n\x05\x04\x7f\x02\x02\x01\x12\x04\xfe\x16\t\x11\n\r\n\x05\x04\
    \x7f\x02\x02\x03\x12\x04\xfe\x16\x14\x15b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
