// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `proto/clarifai/api/service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

///  Split the results into pages.
// @@protoc_insertion_point(message:clarifai.api.Pagination)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pagination {
    // message fields
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.Pagination.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults to 128.
    // @@protoc_insertion_point(field:clarifai.api.Pagination.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.Pagination.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &Pagination| { &m.page },
            |m: &mut Pagination| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &Pagination| { &m.per_page },
            |m: &mut Pagination| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pagination>(
            "Pagination",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pagination {
    const NAME: &'static str = "Pagination";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page = is.read_uint32()?;
                },
                16 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.page != 0 {
            os.write_uint32(1, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn clear(&mut self) {
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pagination {
        static instance: Pagination = Pagination {
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pagination {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pagination").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationRequest
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAnnotationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.annotation_id)
    pub annotation_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationRequest {
    fn default() -> &'a GetAnnotationRequest {
        <GetAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationRequest {
    pub fn new() -> GetAnnotationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationRequest| { &m.user_app_id },
            |m: &mut GetAnnotationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_id",
            |m: &GetAnnotationRequest| { &m.annotation_id },
            |m: &mut GetAnnotationRequest| { &mut m.annotation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetAnnotationRequest| { &m.input_id },
            |m: &mut GetAnnotationRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationRequest>(
            "GetAnnotationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationRequest {
    const NAME: &'static str = "GetAnnotationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.annotation_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(2, &self.annotation_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationRequest {
        GetAnnotationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationRequest {
        static instance: GetAnnotationRequest = GetAnnotationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationsRequest
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List annotations for these IDs
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    ///  List annotations for these Input IDs
    ///  Note that 'ids' are optional but if the are provided the number and order in
    ///  'ids' and 'input_ids' should match
    ///  If you do not specify 'ids' all the annotations for 'input_ids' are returned
    ///  If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return the annotations that has one of these user IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If model_version_ids or workflow_version_ids are also provided, these user_ids are OR'd with them as well because
    ///  we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
    ///  Setting user_ids does also set list_all_annotations=True.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return the annotations that has one of these model version IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If user_ids or workflow_version_ids are also provided, these model_version_ids are OR'd with them as well because
    ///  we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
    ///  Setting model_version_ids does also set list_all_annotations=True.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.model_version_ids)
    pub model_version_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return the annotations that has one of these workflow version IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If user_ids or model_version_ids are also provided, these workflow_version_ids are OR'd with them as well because
    ///  we want the union of all worker (user, model or workflow) annotations in the results of ListAnnotations request.
    ///  Setting workflow_version_ids does also set list_all_annotations=True.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.workflow_version_ids)
    pub workflow_version_ids: ::std::vec::Vec<::std::string::String>,
    ///  Set status to filter by a list of statuses
    ///  If not statuses are provided then annotations with any status will be returned.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.statuses)
    pub statuses: ::std::vec::Vec<super::status::Status>,
    ///  Set this flag to list both trusted and not trusted annotations
    ///  by default it's listing only trusted annotations
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.list_all_annotations)
    pub list_all_annotations: bool,
    ///  Set this flag to return the model output for model annotations in the response.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.return_model_output)
    pub return_model_output: bool,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.per_page)
    pub per_page: u32,
    ///  Flag to filter annotations by task_id
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationsRequest.task_id)
    pub task_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationsRequest {
    fn default() -> &'a ListAnnotationsRequest {
        <ListAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationsRequest {
    pub fn new() -> ListAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationsRequest| { &m.user_app_id },
            |m: &mut ListAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &ListAnnotationsRequest| { &m.ids },
            |m: &mut ListAnnotationsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &ListAnnotationsRequest| { &m.input_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.input_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &ListAnnotationsRequest| { &m.user_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_version_ids",
            |m: &ListAnnotationsRequest| { &m.model_version_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.model_version_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_version_ids",
            |m: &ListAnnotationsRequest| { &m.workflow_version_ids },
            |m: &mut ListAnnotationsRequest| { &mut m.workflow_version_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statuses",
            |m: &ListAnnotationsRequest| { &m.statuses },
            |m: &mut ListAnnotationsRequest| { &mut m.statuses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "list_all_annotations",
            |m: &ListAnnotationsRequest| { &m.list_all_annotations },
            |m: &mut ListAnnotationsRequest| { &mut m.list_all_annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "return_model_output",
            |m: &ListAnnotationsRequest| { &m.return_model_output },
            |m: &mut ListAnnotationsRequest| { &mut m.return_model_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAnnotationsRequest| { &m.page },
            |m: &mut ListAnnotationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAnnotationsRequest| { &m.per_page },
            |m: &mut ListAnnotationsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &ListAnnotationsRequest| { &m.task_id },
            |m: &mut ListAnnotationsRequest| { &mut m.task_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationsRequest>(
            "ListAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationsRequest {
    const NAME: &'static str = "ListAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                74 => {
                    self.user_ids.push(is.read_string()?);
                },
                82 => {
                    self.model_version_ids.push(is.read_string()?);
                },
                106 => {
                    self.workflow_version_ids.push(is.read_string()?);
                },
                42 => {
                    self.statuses.push(is.read_message()?);
                },
                48 => {
                    self.list_all_annotations = is.read_bool()?;
                },
                96 => {
                    self.return_model_output = is.read_bool()?;
                },
                56 => {
                    self.page = is.read_uint32()?;
                },
                64 => {
                    self.per_page = is.read_uint32()?;
                },
                90 => {
                    self.task_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.model_version_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.workflow_version_ids {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.list_all_annotations != false {
            my_size += 1 + 1;
        }
        if self.return_model_output != false {
            my_size += 1 + 1;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.per_page);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.user_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.model_version_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.workflow_version_ids {
            os.write_string(13, &v)?;
        };
        for v in &self.statuses {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.list_all_annotations != false {
            os.write_bool(6, self.list_all_annotations)?;
        }
        if self.return_model_output != false {
            os.write_bool(12, self.return_model_output)?;
        }
        if self.page != 0 {
            os.write_uint32(7, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(8, self.per_page)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(11, &self.task_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationsRequest {
        ListAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.user_ids.clear();
        self.model_version_ids.clear();
        self.workflow_version_ids.clear();
        self.statuses.clear();
        self.list_all_annotations = false;
        self.return_model_output = false;
        self.page = 0;
        self.per_page = 0;
        self.task_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationsRequest {
        static instance: ListAnnotationsRequest = ListAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            input_ids: ::std::vec::Vec::new(),
            user_ids: ::std::vec::Vec::new(),
            model_version_ids: ::std::vec::Vec::new(),
            workflow_version_ids: ::std::vec::Vec::new(),
            statuses: ::std::vec::Vec::new(),
            list_all_annotations: false,
            return_model_output: false,
            page: 0,
            per_page: 0,
            task_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostAnnotationsRequest
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsRequest.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsRequest {
    fn default() -> &'a PostAnnotationsRequest {
        <PostAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsRequest {
    pub fn new() -> PostAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationsRequest| { &m.user_app_id },
            |m: &mut PostAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &PostAnnotationsRequest| { &m.annotations },
            |m: &mut PostAnnotationsRequest| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationsRequest>(
            "PostAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationsRequest {
    const NAME: &'static str = "PostAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationsRequest {
        PostAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationsRequest {
        static instance: PostAnnotationsRequest = PostAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.action)
    pub action: ::std::string::String,
    ///  If the request is a "remove" action and the annotation is left with empty data,
    ///  then setting delete_if_empty_data to true will delete the annotation,
    ///  if possible (for example, will not delete an input-level annotation).
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsRequest.delete_if_empty_data)
    pub delete_if_empty_data: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsRequest {
    fn default() -> &'a PatchAnnotationsRequest {
        <PatchAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsRequest {
    pub fn new() -> PatchAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &PatchAnnotationsRequest| { &m.annotations },
            |m: &mut PatchAnnotationsRequest| { &mut m.annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsRequest| { &m.action },
            |m: &mut PatchAnnotationsRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_if_empty_data",
            |m: &PatchAnnotationsRequest| { &m.delete_if_empty_data },
            |m: &mut PatchAnnotationsRequest| { &mut m.delete_if_empty_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsRequest>(
            "PatchAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsRequest {
    const NAME: &'static str = "PatchAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                32 => {
                    self.delete_if_empty_data = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if self.delete_if_empty_data != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if self.delete_if_empty_data != false {
            os.write_bool(4, self.delete_if_empty_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsRequest {
        PatchAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.action.clear();
        self.delete_if_empty_data = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsRequest {
        static instance: PatchAnnotationsRequest = PatchAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            delete_if_empty_data: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsStatusRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsStatusRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationsStatusRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Filter by user IDs
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Filter by task ID
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.task_id)
    pub task_id: ::std::string::String,
    ///  Filter by Status codes
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.status_codes)
    pub status_codes: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::status_code::StatusCode>>,
    ///  'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.action)
    pub action: ::std::string::String,
    ///  Update filtered annotations to this status
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusRequest.status_code)
    pub status_code: ::protobuf::EnumOrUnknown<super::status_code::StatusCode>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusRequest {
    fn default() -> &'a PatchAnnotationsStatusRequest {
        <PatchAnnotationsStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusRequest {
    pub fn new() -> PatchAnnotationsStatusRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsStatusRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &PatchAnnotationsStatusRequest| { &m.user_ids },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &PatchAnnotationsStatusRequest| { &m.task_id },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "status_codes",
            |m: &PatchAnnotationsStatusRequest| { &m.status_codes },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.status_codes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsStatusRequest| { &m.action },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_code",
            |m: &PatchAnnotationsStatusRequest| { &m.status_code },
            |m: &mut PatchAnnotationsStatusRequest| { &mut m.status_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsStatusRequest>(
            "PatchAnnotationsStatusRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusRequest {
    const NAME: &'static str = "PatchAnnotationsStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                34 => {
                    self.task_id = is.read_string()?;
                },
                48 => {
                    self.status_codes.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.status_codes)?
                },
                42 => {
                    self.action = is.read_string()?;
                },
                16 => {
                    self.status_code = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.task_id);
        }
        for value in &self.status_codes {
            my_size += ::protobuf::rt::int32_size(6, value.value());
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.action);
        }
        if self.status_code != ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO) {
            my_size += ::protobuf::rt::int32_size(2, self.status_code.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        if !self.task_id.is_empty() {
            os.write_string(4, &self.task_id)?;
        }
        for v in &self.status_codes {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if !self.action.is_empty() {
            os.write_string(5, &self.action)?;
        }
        if self.status_code != ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status_code))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsStatusRequest {
        PatchAnnotationsStatusRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.user_ids.clear();
        self.task_id.clear();
        self.status_codes.clear();
        self.action.clear();
        self.status_code = ::protobuf::EnumOrUnknown::new(super::status_code::StatusCode::ZERO);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsStatusRequest {
        static instance: PatchAnnotationsStatusRequest = PatchAnnotationsStatusRequest {
            user_app_id: ::protobuf::MessageField::none(),
            user_ids: ::std::vec::Vec::new(),
            task_id: ::std::string::String::new(),
            status_codes: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            status_code: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsStatusRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsStatusRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAnnotationsStatusResponse
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsStatusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationsStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsStatusResponse.updated_count)
    pub updated_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusResponse {
    fn default() -> &'a PatchAnnotationsStatusResponse {
        <PatchAnnotationsStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusResponse {
    pub fn new() -> PatchAnnotationsStatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PatchAnnotationsStatusResponse| { &m.status },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &PatchAnnotationsStatusResponse| { &m.user_ids },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updated_count",
            |m: &PatchAnnotationsStatusResponse| { &m.updated_count },
            |m: &mut PatchAnnotationsStatusResponse| { &mut m.updated_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsStatusResponse>(
            "PatchAnnotationsStatusResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusResponse {
    const NAME: &'static str = "PatchAnnotationsStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.user_ids.push(is.read_string()?);
                },
                24 => {
                    self.updated_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.updated_count != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.updated_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        if self.updated_count != 0 {
            os.write_uint32(3, self.updated_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsStatusResponse {
        PatchAnnotationsStatusResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.user_ids.clear();
        self.updated_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsStatusResponse {
        static instance: PatchAnnotationsStatusResponse = PatchAnnotationsStatusResponse {
            status: ::protobuf::MessageField::none(),
            user_ids: ::std::vec::Vec::new(),
            updated_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsStatusResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsStatusResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAnnotationRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAnnotationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.input_id)
    pub input_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationRequest.annotation_id)
    pub annotation_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationRequest {
    fn default() -> &'a DeleteAnnotationRequest {
        <DeleteAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationRequest {
    pub fn new() -> DeleteAnnotationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &DeleteAnnotationRequest| { &m.input_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.input_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_id",
            |m: &DeleteAnnotationRequest| { &m.annotation_id },
            |m: &mut DeleteAnnotationRequest| { &mut m.annotation_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationRequest>(
            "DeleteAnnotationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationRequest {
    const NAME: &'static str = "DeleteAnnotationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                26 => {
                    self.annotation_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.annotation_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(3, &self.annotation_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationRequest {
        DeleteAnnotationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.annotation_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationRequest {
        static instance: DeleteAnnotationRequest = DeleteAnnotationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            annotation_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAnnotationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Delete annotations with IDs
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    ///  Delete annotations for these Input IDs
    ///  Note that 'ids' are optional but if the are provided the number and order in
    ///  'ids' and 'input_ids' should match
    ///  If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
    ///  However you need to specify at least one value for 'input_ids'
    ///  i.e. this API does not support deleting all annotations
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationsRequest {
    fn default() -> &'a DeleteAnnotationsRequest {
        <DeleteAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationsRequest {
    pub fn new() -> DeleteAnnotationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationsRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteAnnotationsRequest| { &m.ids },
            |m: &mut DeleteAnnotationsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &DeleteAnnotationsRequest| { &m.input_ids },
            |m: &mut DeleteAnnotationsRequest| { &mut m.input_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationsRequest>(
            "DeleteAnnotationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationsRequest {
    const NAME: &'static str = "DeleteAnnotationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationsRequest {
        DeleteAnnotationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationsRequest {
        static instance: DeleteAnnotationsRequest = DeleteAnnotationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            input_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAnnotationResponse
// @@protoc_insertion_point(message:clarifai.api.SingleAnnotationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationResponse.annotation)
    pub annotation: ::protobuf::MessageField<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAnnotationResponse {
    fn default() -> &'a SingleAnnotationResponse {
        <SingleAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAnnotationResponse {
    pub fn new() -> SingleAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAnnotationResponse| { &m.status },
            |m: &mut SingleAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Annotation>(
            "annotation",
            |m: &SingleAnnotationResponse| { &m.annotation },
            |m: &mut SingleAnnotationResponse| { &mut m.annotation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAnnotationResponse>(
            "SingleAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAnnotationResponse {
    const NAME: &'static str = "SingleAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.annotation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAnnotationResponse {
        SingleAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAnnotationResponse {
        static instance: SingleAnnotationResponse = SingleAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            annotation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationResponse.annotations)
    pub annotations: ::std::vec::Vec<super::resources::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationResponse {
    fn default() -> &'a MultiAnnotationResponse {
        <MultiAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationResponse {
    pub fn new() -> MultiAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationResponse| { &m.status },
            |m: &mut MultiAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &MultiAnnotationResponse| { &m.annotations },
            |m: &mut MultiAnnotationResponse| { &mut m.annotations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationResponse>(
            "MultiAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationResponse {
    const NAME: &'static str = "MultiAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationResponse {
        MultiAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationResponse {
        static instance: MultiAnnotationResponse = MultiAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            annotations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationWorkersRequest
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationWorkersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAnnotationWorkersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) List of additional fields to be included in the response.
    ///  Currently supported: all, names
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  (optional URL parameter) Only list workers that have created trusted annotations.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationWorkersRequest.trusted_only)
    pub trusted_only: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationWorkersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationWorkersRequest {
    fn default() -> &'a ListAnnotationWorkersRequest {
        <ListAnnotationWorkersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationWorkersRequest {
    pub fn new() -> ListAnnotationWorkersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationWorkersRequest| { &m.user_app_id },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAnnotationWorkersRequest| { &m.page },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAnnotationWorkersRequest| { &m.per_page },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListAnnotationWorkersRequest| { &m.additional_fields },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trusted_only",
            |m: &ListAnnotationWorkersRequest| { &m.trusted_only },
            |m: &mut ListAnnotationWorkersRequest| { &mut m.trusted_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationWorkersRequest>(
            "ListAnnotationWorkersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationWorkersRequest {
    const NAME: &'static str = "ListAnnotationWorkersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                34 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.trusted_only = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.trusted_only != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(4, &v)?;
        };
        if self.trusted_only != false {
            os.write_bool(5, self.trusted_only)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationWorkersRequest {
        ListAnnotationWorkersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.trusted_only = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationWorkersRequest {
        static instance: ListAnnotationWorkersRequest = ListAnnotationWorkersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            trusted_only: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationWorkersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationWorkersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationWorkersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationWorkersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiWorkerResponse
// @@protoc_insertion_point(message:clarifai.api.MultiWorkerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiWorkerResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkerResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkerResponse.workers)
    pub workers: ::std::vec::Vec<super::resources::Worker>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiWorkerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiWorkerResponse {
    fn default() -> &'a MultiWorkerResponse {
        <MultiWorkerResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkerResponse {
    pub fn new() -> MultiWorkerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiWorkerResponse| { &m.status },
            |m: &mut MultiWorkerResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workers",
            |m: &MultiWorkerResponse| { &m.workers },
            |m: &mut MultiWorkerResponse| { &mut m.workers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiWorkerResponse>(
            "MultiWorkerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiWorkerResponse {
    const NAME: &'static str = "MultiWorkerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.workers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiWorkerResponse {
        MultiWorkerResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiWorkerResponse {
        static instance: MultiWorkerResponse = MultiWorkerResponse {
            status: ::protobuf::MessageField::none(),
            workers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiWorkerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiWorkerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiWorkerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAppRequest
// @@protoc_insertion_point(message:clarifai.api.GetAppRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, counts
    // @@protoc_insertion_point(field:clarifai.api.GetAppRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAppRequest {
    fn default() -> &'a GetAppRequest {
        <GetAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppRequest {
    pub fn new() -> GetAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAppRequest| { &m.user_app_id },
            |m: &mut GetAppRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetAppRequest| { &m.additional_fields },
            |m: &mut GetAppRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAppRequest>(
            "GetAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAppRequest {
    const NAME: &'static str = "GetAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.additional_fields {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAppRequest {
        GetAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAppRequest {
        static instance: GetAppRequest = GetAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAppsRequest
// @@protoc_insertion_point(message:clarifai.api.ListAppsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, counts
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    ///  If true, we only return apps that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return apps that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.starred_only)
    pub starred_only: bool,
    ///  If true, we only return apps that are marked as a template by the app owner.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.template_only)
    pub template_only: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the application:
    ///    - id
    ///    - name
    ///    - description
    ///    - notes
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.search)
    pub search: ::std::string::String,
    ///  Query various text fields (id, name, description, and notes) that can contain the words in the query string
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the id, name and notes of the app. This supports wilcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.name)
    pub name: ::std::string::String,
    ///  Filter by the user-unique-id of the app. This supports wilcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListAppsRequest.id)
    pub id: ::std::string::String,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_apps_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppsRequest {
    fn default() -> &'a ListAppsRequest {
        <ListAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppsRequest {
    pub fn new() -> ListAppsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_name = 6;

    pub fn sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_name(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_name(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(v))
    }

    // bool sort_by_modified_at = 7;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 12;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 13;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppsRequest| { &m.user_app_id },
            |m: &mut ListAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppsRequest| { &m.page },
            |m: &mut ListAppsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppsRequest| { &m.per_page },
            |m: &mut ListAppsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListAppsRequest| { &m.additional_fields },
            |m: &mut ListAppsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListAppsRequest| { &m.sort_ascending },
            |m: &mut ListAppsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_name",
            ListAppsRequest::has_sort_by_name,
            ListAppsRequest::sort_by_name,
            ListAppsRequest::set_sort_by_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListAppsRequest::has_sort_by_modified_at,
            ListAppsRequest::sort_by_modified_at,
            ListAppsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListAppsRequest::has_sort_by_created_at,
            ListAppsRequest::sort_by_created_at,
            ListAppsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListAppsRequest::has_sort_by_star_count,
            ListAppsRequest::sort_by_star_count,
            ListAppsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListAppsRequest| { &m.featured_only },
            |m: &mut ListAppsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListAppsRequest| { &m.starred_only },
            |m: &mut ListAppsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "template_only",
            |m: &ListAppsRequest| { &m.template_only },
            |m: &mut ListAppsRequest| { &mut m.template_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListAppsRequest| { &m.search },
            |m: &mut ListAppsRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListAppsRequest| { &m.query },
            |m: &mut ListAppsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListAppsRequest| { &m.name },
            |m: &mut ListAppsRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListAppsRequest| { &m.id },
            |m: &mut ListAppsRequest| { &mut m.id },
        ));
        oneofs.push(list_apps_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppsRequest>(
            "ListAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppsRequest {
    const NAME: &'static str = "ListAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                82 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.sort_ascending = is.read_bool()?;
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByName(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                96 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_apps_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.featured_only = is.read_bool()?;
                },
                88 => {
                    self.starred_only = is.read_bool()?;
                },
                128 => {
                    self.template_only = is.read_bool()?;
                },
                122 => {
                    self.search = is.read_string()?;
                },
                66 => {
                    self.query = is.read_string()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                114 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.featured_only != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        if self.template_only != false {
            my_size += 2 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.search);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.query);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.id);
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_apps_request::Sort_by::SortByName(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_apps_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(10, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(5, self.sort_ascending)?;
        }
        if self.featured_only != false {
            os.write_bool(9, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(11, self.starred_only)?;
        }
        if self.template_only != false {
            os.write_bool(16, self.template_only)?;
        }
        if !self.search.is_empty() {
            os.write_string(15, &self.search)?;
        }
        if !self.query.is_empty() {
            os.write_string(8, &self.query)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.id.is_empty() {
            os.write_string(14, &self.id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_apps_request::Sort_by::SortByName(v) => {
                    os.write_bool(6, v)?;
                },
                &list_apps_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_apps_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(12, v)?;
                },
                &list_apps_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(13, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppsRequest {
        ListAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.featured_only = false;
        self.starred_only = false;
        self.template_only = false;
        self.search.clear();
        self.query.clear();
        self.name.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppsRequest {
        static instance: ListAppsRequest = ListAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            featured_only: false,
            starred_only: false,
            template_only: false,
            search: ::std::string::String::new(),
            query: ::std::string::String::new(),
            name: ::std::string::String::new(),
            id: ::std::string::String::new(),
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListAppsRequest`
pub mod list_apps_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListAppsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_name)
        SortByName(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListAppsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListAppsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostAppsRequest
// @@protoc_insertion_point(message:clarifai.api.PostAppsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAppsRequest.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppsRequest {
    fn default() -> &'a PostAppsRequest {
        <PostAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsRequest {
    pub fn new() -> PostAppsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppsRequest| { &m.user_app_id },
            |m: &mut PostAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &PostAppsRequest| { &m.apps },
            |m: &mut PostAppsRequest| { &mut m.apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppsRequest>(
            "PostAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppsRequest {
    const NAME: &'static str = "PostAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppsRequest {
        PostAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppsRequest {
        static instance: PostAppsRequest = PostAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAppRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteAppRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAppRequest {
    fn default() -> &'a DeleteAppRequest {
        <DeleteAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAppRequest {
    pub fn new() -> DeleteAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAppRequest| { &m.user_app_id },
            |m: &mut DeleteAppRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAppRequest>(
            "DeleteAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAppRequest {
    const NAME: &'static str = "DeleteAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAppRequest {
        DeleteAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAppRequest {
        static instance: DeleteAppRequest = DeleteAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAppsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAppsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    ///  The action to perform on the patched App objects except App.Metadata
    ///  Supported values: 'overwrite' and 'remove'.
    ///
    ///  Note that 'remove' can only be used to remove the app image by setting
    ///  'image.url' in the request to the current value returned for that app.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.action)
    pub action: ::std::string::String,
    ///  The action to perform on the patched App.Metadata
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.metadata_action)
    pub metadata_action: ::protobuf::MessageField<super::resources::PatchAction>,
    ///  If set, the app will be automatically reindexed upon change of its base workflow.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsRequest.reindex)
    pub reindex: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppsRequest {
    fn default() -> &'a PatchAppsRequest {
        <PatchAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppsRequest {
    pub fn new() -> PatchAppsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppsRequest| { &m.user_app_id },
            |m: &mut PatchAppsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &PatchAppsRequest| { &m.apps },
            |m: &mut PatchAppsRequest| { &mut m.apps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppsRequest| { &m.action },
            |m: &mut PatchAppsRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PatchAction>(
            "metadata_action",
            |m: &PatchAppsRequest| { &m.metadata_action },
            |m: &mut PatchAppsRequest| { &mut m.metadata_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindex",
            |m: &PatchAppsRequest| { &m.reindex },
            |m: &mut PatchAppsRequest| { &mut m.reindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppsRequest>(
            "PatchAppsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppsRequest {
    const NAME: &'static str = "PatchAppsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata_action)?;
                },
                40 => {
                    self.reindex = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if let Some(v) = self.metadata_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reindex != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if let Some(v) = self.metadata_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.reindex != false {
            os.write_bool(5, self.reindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppsRequest {
        PatchAppsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.action.clear();
        self.metadata_action.clear();
        self.reindex = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppsRequest {
        static instance: PatchAppsRequest = PatchAppsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            metadata_action: ::protobuf::MessageField::none(),
            reindex: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAppRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAppRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    ///  The action to perform on the patched App object except App.Metadata
    ///  Supported values: 'overwrite' and 'remove'.
    ///
    ///  Note that 'remove' can only be used to remove the app image by setting
    ///  'image.url' in the request to the current value returned for the app.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.action)
    pub action: ::std::string::String,
    ///  The action to perform on the patched App.Metadata
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.metadata_action)
    pub metadata_action: ::protobuf::MessageField<super::resources::PatchAction>,
    ///  If set, the app will be automatically reindexed upon change of its base workflow.
    // @@protoc_insertion_point(field:clarifai.api.PatchAppRequest.reindex)
    pub reindex: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppRequest {
    fn default() -> &'a PatchAppRequest {
        <PatchAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppRequest {
    pub fn new() -> PatchAppRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppRequest| { &m.user_app_id },
            |m: &mut PatchAppRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &PatchAppRequest| { &m.app },
            |m: &mut PatchAppRequest| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppRequest| { &m.action },
            |m: &mut PatchAppRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PatchAction>(
            "metadata_action",
            |m: &PatchAppRequest| { &m.metadata_action },
            |m: &mut PatchAppRequest| { &mut m.metadata_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reindex",
            |m: &PatchAppRequest| { &m.reindex },
            |m: &mut PatchAppRequest| { &mut m.reindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppRequest>(
            "PatchAppRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppRequest {
    const NAME: &'static str = "PatchAppRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                26 => {
                    self.action = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata_action)?;
                },
                40 => {
                    self.reindex = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if let Some(v) = self.metadata_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.reindex != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if let Some(v) = self.metadata_action.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.reindex != false {
            os.write_bool(5, self.reindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppRequest {
        PatchAppRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app.clear();
        self.action.clear();
        self.metadata_action.clear();
        self.reindex = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppRequest {
        static instance: PatchAppRequest = PatchAppRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app: ::protobuf::MessageField::none(),
            action: ::std::string::String::new(),
            metadata_action: ::protobuf::MessageField::none(),
            reindex: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchAppsIdsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchAppsIdsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAppsIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAppsIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAppsIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAppsIdsRequest {
    fn default() -> &'a PatchAppsIdsRequest {
        <PatchAppsIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppsIdsRequest {
    pub fn new() -> PatchAppsIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAppsIdsRequest| { &m.user_app_id },
            |m: &mut PatchAppsIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchAppsIdsRequest| { &m.ids },
            |m: &mut PatchAppsIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAppsIdsRequest| { &m.action },
            |m: &mut PatchAppsIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAppsIdsRequest>(
            "PatchAppsIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAppsIdsRequest {
    const NAME: &'static str = "PatchAppsIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAppsIdsRequest {
        PatchAppsIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAppsIdsRequest {
        static instance: PatchAppsIdsRequest = PatchAppsIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAppsIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAppsIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAppsIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppsIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Search over the available applications.
// @@protoc_insertion_point(message:clarifai.api.PostAppsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAppsSearchesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.app_query)
    pub app_query: ::protobuf::MessageField<super::resources::AppQuery>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostAppsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppsSearchesRequest {
    fn default() -> &'a PostAppsSearchesRequest {
        <PostAppsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsSearchesRequest {
    pub fn new() -> PostAppsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppsSearchesRequest| { &m.user_app_id },
            |m: &mut PostAppsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AppQuery>(
            "app_query",
            |m: &PostAppsSearchesRequest| { &m.app_query },
            |m: &mut PostAppsSearchesRequest| { &mut m.app_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostAppsSearchesRequest| { &m.pagination },
            |m: &mut PostAppsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppsSearchesRequest>(
            "PostAppsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppsSearchesRequest {
    const NAME: &'static str = "PostAppsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_query)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppsSearchesRequest {
        PostAppsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_query.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppsSearchesRequest {
        static instance: PostAppsSearchesRequest = PostAppsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_query: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAppResponse
// @@protoc_insertion_point(message:clarifai.api.SingleAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleAppResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAppResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAppResponse.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAppResponse {
    fn default() -> &'a SingleAppResponse {
        <SingleAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppResponse {
    pub fn new() -> SingleAppResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAppResponse| { &m.status },
            |m: &mut SingleAppResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &SingleAppResponse| { &m.app },
            |m: &mut SingleAppResponse| { &mut m.app },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAppResponse>(
            "SingleAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAppResponse {
    const NAME: &'static str = "SingleAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAppResponse {
        SingleAppResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAppResponse {
        static instance: SingleAppResponse = SingleAppResponse {
            status: ::protobuf::MessageField::none(),
            app: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAppResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAppResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAppResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAppResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAppResponse.apps)
    pub apps: ::std::vec::Vec<super::resources::App>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAppResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAppResponse {
    fn default() -> &'a MultiAppResponse {
        <MultiAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppResponse {
    pub fn new() -> MultiAppResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAppResponse| { &m.status },
            |m: &mut MultiAppResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "apps",
            |m: &MultiAppResponse| { &m.apps },
            |m: &mut MultiAppResponse| { &mut m.apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAppResponse>(
            "MultiAppResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAppResponse {
    const NAME: &'static str = "MultiAppResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAppResponse {
        MultiAppResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAppResponse {
        static instance: MultiAppResponse = MultiAppResponse {
            status: ::protobuf::MessageField::none(),
            apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAppResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAppResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListCollaboratorsRequest
// @@protoc_insertion_point(message:clarifai.api.ListCollaboratorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Set this flag to list both deleted and not deleted collaborators
    ///  by default it's listing only not deleted collaborators
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.list_all_collaborators)
    pub list_all_collaborators: bool,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaboratorsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollaboratorsRequest {
    fn default() -> &'a ListCollaboratorsRequest {
        <ListCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaboratorsRequest {
    pub fn new() -> ListCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollaboratorsRequest| { &m.user_app_id },
            |m: &mut ListCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "list_all_collaborators",
            |m: &ListCollaboratorsRequest| { &m.list_all_collaborators },
            |m: &mut ListCollaboratorsRequest| { &mut m.list_all_collaborators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollaboratorsRequest| { &m.page },
            |m: &mut ListCollaboratorsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollaboratorsRequest| { &m.per_page },
            |m: &mut ListCollaboratorsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollaboratorsRequest>(
            "ListCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollaboratorsRequest {
    const NAME: &'static str = "ListCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.list_all_collaborators = is.read_bool()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.list_all_collaborators != false {
            my_size += 1 + 1;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.list_all_collaborators != false {
            os.write_bool(2, self.list_all_collaborators)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollaboratorsRequest {
        ListCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.list_all_collaborators = false;
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollaboratorsRequest {
        static instance: ListCollaboratorsRequest = ListCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            list_all_collaborators: false,
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostCollaboratorsRequest
// @@protoc_insertion_point(message:clarifai.api.PostCollaboratorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostCollaboratorsRequest.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostCollaboratorsRequest {
    fn default() -> &'a PostCollaboratorsRequest {
        <PostCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollaboratorsRequest {
    pub fn new() -> PostCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostCollaboratorsRequest| { &m.user_app_id },
            |m: &mut PostCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &PostCollaboratorsRequest| { &m.collaborators },
            |m: &mut PostCollaboratorsRequest| { &mut m.collaborators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostCollaboratorsRequest>(
            "PostCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostCollaboratorsRequest {
    const NAME: &'static str = "PostCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostCollaboratorsRequest {
        PostCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostCollaboratorsRequest {
        static instance: PostCollaboratorsRequest = PostCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchCollaboratorsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchCollaboratorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    ///  The action to perform on the patched objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchCollaboratorsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchCollaboratorsRequest {
    fn default() -> &'a PatchCollaboratorsRequest {
        <PatchCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollaboratorsRequest {
    pub fn new() -> PatchCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchCollaboratorsRequest| { &m.user_app_id },
            |m: &mut PatchCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &PatchCollaboratorsRequest| { &m.collaborators },
            |m: &mut PatchCollaboratorsRequest| { &mut m.collaborators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchCollaboratorsRequest| { &m.action },
            |m: &mut PatchCollaboratorsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchCollaboratorsRequest>(
            "PatchCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchCollaboratorsRequest {
    const NAME: &'static str = "PatchCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchCollaboratorsRequest {
        PatchCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchCollaboratorsRequest {
        static instance: PatchCollaboratorsRequest = PatchCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteCollaboratorsRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteCollaboratorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteCollaboratorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.collaborator_ids)
    pub collaborator_ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollaboratorsRequest.user_emails)
    pub user_emails: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteCollaboratorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteCollaboratorsRequest {
    fn default() -> &'a DeleteCollaboratorsRequest {
        <DeleteCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollaboratorsRequest {
    pub fn new() -> DeleteCollaboratorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteCollaboratorsRequest| { &m.user_app_id },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborator_ids",
            |m: &DeleteCollaboratorsRequest| { &m.collaborator_ids },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.collaborator_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_emails",
            |m: &DeleteCollaboratorsRequest| { &m.user_emails },
            |m: &mut DeleteCollaboratorsRequest| { &mut m.user_emails },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteCollaboratorsRequest>(
            "DeleteCollaboratorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteCollaboratorsRequest {
    const NAME: &'static str = "DeleteCollaboratorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collaborator_ids.push(is.read_string()?);
                },
                26 => {
                    self.user_emails.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborator_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.user_emails {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborator_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.user_emails {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteCollaboratorsRequest {
        DeleteCollaboratorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborator_ids.clear();
        self.user_emails.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteCollaboratorsRequest {
        static instance: DeleteCollaboratorsRequest = DeleteCollaboratorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collaborator_ids: ::std::vec::Vec::new(),
            user_emails: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteCollaboratorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteCollaboratorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollaboratorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiCollaboratorsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiCollaboratorsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiCollaboratorsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaboratorsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaboratorsResponse.collaborators)
    pub collaborators: ::std::vec::Vec<super::resources::Collaborator>,
    ///  The owner of the application.
    ///
    ///  When listing users that have access to the application, i.e. collaborators,
    ///  it is often relevant to also include the application owner, so return
    ///  their information here for convenience.
    ///
    ///  Note: app_owner is only returned by ListCollaborators and only if the
    ///  owner is a regular user, not an organization.
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaboratorsResponse.app_owner)
    pub app_owner: ::protobuf::MessageField<super::resources::User>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollaboratorsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollaboratorsResponse {
    fn default() -> &'a MultiCollaboratorsResponse {
        <MultiCollaboratorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaboratorsResponse {
    pub fn new() -> MultiCollaboratorsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollaboratorsResponse| { &m.status },
            |m: &mut MultiCollaboratorsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborators",
            |m: &MultiCollaboratorsResponse| { &m.collaborators },
            |m: &mut MultiCollaboratorsResponse| { &mut m.collaborators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::User>(
            "app_owner",
            |m: &MultiCollaboratorsResponse| { &m.app_owner },
            |m: &mut MultiCollaboratorsResponse| { &mut m.app_owner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollaboratorsResponse>(
            "MultiCollaboratorsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollaboratorsResponse {
    const NAME: &'static str = "MultiCollaboratorsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collaborators.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_owner)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.app_owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborators {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.app_owner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollaboratorsResponse {
        MultiCollaboratorsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collaborators.clear();
        self.app_owner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollaboratorsResponse {
        static instance: MultiCollaboratorsResponse = MultiCollaboratorsResponse {
            status: ::protobuf::MessageField::none(),
            collaborators: ::std::vec::Vec::new(),
            app_owner: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollaboratorsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollaboratorsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollaboratorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaboratorsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListCollaborationsRequest
// @@protoc_insertion_point(message:clarifai.api.ListCollaborationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListCollaborationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.per_page)
    pub per_page: u32,
    ///  Filtering options:
    ///  If true, we only return collaborations on apps that are marked as a template by the app owner.
    // @@protoc_insertion_point(field:clarifai.api.ListCollaborationsRequest.template_only)
    pub template_only: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollaborationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollaborationsRequest {
    fn default() -> &'a ListCollaborationsRequest {
        <ListCollaborationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaborationsRequest {
    pub fn new() -> ListCollaborationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollaborationsRequest| { &m.user_app_id },
            |m: &mut ListCollaborationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollaborationsRequest| { &m.page },
            |m: &mut ListCollaborationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollaborationsRequest| { &m.per_page },
            |m: &mut ListCollaborationsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "template_only",
            |m: &ListCollaborationsRequest| { &m.template_only },
            |m: &mut ListCollaborationsRequest| { &mut m.template_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollaborationsRequest>(
            "ListCollaborationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollaborationsRequest {
    const NAME: &'static str = "ListCollaborationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.template_only = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.template_only != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.template_only != false {
            os.write_bool(4, self.template_only)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollaborationsRequest {
        ListCollaborationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.template_only = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollaborationsRequest {
        static instance: ListCollaborationsRequest = ListCollaborationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            template_only: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollaborationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollaborationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollaborationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaborationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiCollaborationsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiCollaborationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiCollaborationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaborationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollaborationsResponse.collaborations)
    pub collaborations: ::std::vec::Vec<super::resources::Collaboration>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollaborationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollaborationsResponse {
    fn default() -> &'a MultiCollaborationsResponse {
        <MultiCollaborationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaborationsResponse {
    pub fn new() -> MultiCollaborationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollaborationsResponse| { &m.status },
            |m: &mut MultiCollaborationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collaborations",
            |m: &MultiCollaborationsResponse| { &m.collaborations },
            |m: &mut MultiCollaborationsResponse| { &mut m.collaborations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollaborationsResponse>(
            "MultiCollaborationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollaborationsResponse {
    const NAME: &'static str = "MultiCollaborationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collaborations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collaborations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collaborations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollaborationsResponse {
        MultiCollaborationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collaborations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollaborationsResponse {
        static instance: MultiCollaborationsResponse = MultiCollaborationsResponse {
            status: ::protobuf::MessageField::none(),
            collaborations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollaborationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollaborationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollaborationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaborationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetStatusCodeRequest
// @@protoc_insertion_point(message:clarifai.api.GetStatusCodeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetStatusCodeRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetStatusCodeRequest.status_code_id)
    pub status_code_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetStatusCodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetStatusCodeRequest {
    fn default() -> &'a GetStatusCodeRequest {
        <GetStatusCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusCodeRequest {
    pub fn new() -> GetStatusCodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status_code_id",
            |m: &GetStatusCodeRequest| { &m.status_code_id },
            |m: &mut GetStatusCodeRequest| { &mut m.status_code_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStatusCodeRequest>(
            "GetStatusCodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetStatusCodeRequest {
    const NAME: &'static str = "GetStatusCodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.status_code_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.status_code_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status_code_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.status_code_id.is_empty() {
            os.write_string(1, &self.status_code_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetStatusCodeRequest {
        GetStatusCodeRequest::new()
    }

    fn clear(&mut self) {
        self.status_code_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetStatusCodeRequest {
        static instance: GetStatusCodeRequest = GetStatusCodeRequest {
            status_code_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetStatusCodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetStatusCodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetStatusCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusCodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListStatusCodesRequest
// @@protoc_insertion_point(message:clarifai.api.ListStatusCodesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListStatusCodesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListStatusCodesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListStatusCodesRequest {
    fn default() -> &'a ListStatusCodesRequest {
        <ListStatusCodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListStatusCodesRequest {
    pub fn new() -> ListStatusCodesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListStatusCodesRequest>(
            "ListStatusCodesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListStatusCodesRequest {
    const NAME: &'static str = "ListStatusCodesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListStatusCodesRequest {
        ListStatusCodesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListStatusCodesRequest {
        static instance: ListStatusCodesRequest = ListStatusCodesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListStatusCodesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListStatusCodesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListStatusCodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatusCodesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleStatusCodeResponse
// @@protoc_insertion_point(message:clarifai.api.SingleStatusCodeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleStatusCodeResponse {
    // message fields
    ///  Status of this request.
    // @@protoc_insertion_point(field:clarifai.api.SingleStatusCodeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleStatusCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleStatusCodeResponse {
    fn default() -> &'a SingleStatusCodeResponse {
        <SingleStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleStatusCodeResponse {
    pub fn new() -> SingleStatusCodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleStatusCodeResponse| { &m.status },
            |m: &mut SingleStatusCodeResponse| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleStatusCodeResponse>(
            "SingleStatusCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleStatusCodeResponse {
    const NAME: &'static str = "SingleStatusCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleStatusCodeResponse {
        SingleStatusCodeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleStatusCodeResponse {
        static instance: SingleStatusCodeResponse = SingleStatusCodeResponse {
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleStatusCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleStatusCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleStatusCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatusCodeResponse
// @@protoc_insertion_point(message:clarifai.api.MultiStatusCodeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiStatusCodeResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiStatusCodeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiStatusCodeResponse.statuses)
    pub statuses: ::std::vec::Vec<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatusCodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatusCodeResponse {
    fn default() -> &'a MultiStatusCodeResponse {
        <MultiStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatusCodeResponse {
    pub fn new() -> MultiStatusCodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatusCodeResponse| { &m.status },
            |m: &mut MultiStatusCodeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statuses",
            |m: &MultiStatusCodeResponse| { &m.statuses },
            |m: &mut MultiStatusCodeResponse| { &mut m.statuses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatusCodeResponse>(
            "MultiStatusCodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatusCodeResponse {
    const NAME: &'static str = "MultiStatusCodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.statuses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.statuses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatusCodeResponse {
        MultiStatusCodeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.statuses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatusCodeResponse {
        static instance: MultiStatusCodeResponse = MultiStatusCodeResponse {
            status: ::protobuf::MessageField::none(),
            statuses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatusCodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatusCodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatusCodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetConceptRequest
// @@protoc_insertion_point(message:clarifai.api.GetConceptRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetConceptRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept's id.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptRequest.concept_id)
    pub concept_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptRequest {
    fn default() -> &'a GetConceptRequest {
        <GetConceptRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptRequest {
    pub fn new() -> GetConceptRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptRequest| { &m.user_app_id },
            |m: &mut GetConceptRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &GetConceptRequest| { &m.concept_id },
            |m: &mut GetConceptRequest| { &mut m.concept_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptRequest>(
            "GetConceptRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptRequest {
    const NAME: &'static str = "GetConceptRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptRequest {
        GetConceptRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptRequest {
        static instance: GetConceptRequest = GetConceptRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListConceptsRequest
// @@protoc_insertion_point(message:clarifai.api.ListConceptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.per_page)
    pub per_page: u32,
    ///  Fuzzy match on concept ID
    // @@protoc_insertion_point(field:clarifai.api.ListConceptsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptsRequest {
    fn default() -> &'a ListConceptsRequest {
        <ListConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptsRequest {
    pub fn new() -> ListConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptsRequest| { &m.user_app_id },
            |m: &mut ListConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptsRequest| { &m.page },
            |m: &mut ListConceptsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptsRequest| { &m.per_page },
            |m: &mut ListConceptsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListConceptsRequest| { &m.id },
            |m: &mut ListConceptsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptsRequest>(
            "ListConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptsRequest {
    const NAME: &'static str = "ListConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                34 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if !self.id.is_empty() {
            os.write_string(4, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptsRequest {
        ListConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptsRequest {
        static instance: ListConceptsRequest = ListConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelConceptsRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelConceptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Model id
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  Model version Id. Optional, if not provided latest model version is used.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.per_page)
    pub per_page: u32,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the concept:
    ///    - id
    ///    - name
    ///
    ///  Keywords are used for partial prefix-matching (so searching for "larif" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListModelConceptsRequest.search)
    pub search: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelConceptsRequest {
    fn default() -> &'a ListModelConceptsRequest {
        <ListModelConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelConceptsRequest {
    pub fn new() -> ListModelConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelConceptsRequest| { &m.user_app_id },
            |m: &mut ListModelConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelConceptsRequest| { &m.model_id },
            |m: &mut ListModelConceptsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ListModelConceptsRequest| { &m.version_id },
            |m: &mut ListModelConceptsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelConceptsRequest| { &m.page },
            |m: &mut ListModelConceptsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelConceptsRequest| { &m.per_page },
            |m: &mut ListModelConceptsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListModelConceptsRequest| { &m.search },
            |m: &mut ListModelConceptsRequest| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelConceptsRequest>(
            "ListModelConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelConceptsRequest {
    const NAME: &'static str = "ListModelConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                50 => {
                    self.search = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.search);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        if !self.search.is_empty() {
            os.write_string(6, &self.search)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelConceptsRequest {
        ListModelConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelConceptsRequest {
        static instance: ListModelConceptsRequest = ListModelConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            search: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostConceptsSearchesRequest
// @@protoc_insertion_point(message:clarifai.api.PostConceptsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptsSearchesRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.concept_query)
    pub concept_query: ::protobuf::MessageField<super::resources::ConceptQuery>,
    ///  Request additional info to be retrieved for each concept in the response.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.extra_info)
    pub extra_info: ::protobuf::MessageField<ConceptExtraInfoRequest>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptsSearchesRequest {
    fn default() -> &'a PostConceptsSearchesRequest {
        <PostConceptsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsSearchesRequest {
    pub fn new() -> PostConceptsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptsSearchesRequest| { &m.user_app_id },
            |m: &mut PostConceptsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ConceptQuery>(
            "concept_query",
            |m: &PostConceptsSearchesRequest| { &m.concept_query },
            |m: &mut PostConceptsSearchesRequest| { &mut m.concept_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConceptExtraInfoRequest>(
            "extra_info",
            |m: &PostConceptsSearchesRequest| { &m.extra_info },
            |m: &mut PostConceptsSearchesRequest| { &mut m.extra_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostConceptsSearchesRequest| { &m.pagination },
            |m: &mut PostConceptsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptsSearchesRequest>(
            "PostConceptsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptsSearchesRequest {
    const NAME: &'static str = "PostConceptsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept_query)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extra_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.extra_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.extra_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptsSearchesRequest {
        PostConceptsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_query.clear();
        self.extra_info.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptsSearchesRequest {
        static instance: PostConceptsSearchesRequest = PostConceptsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_query: ::protobuf::MessageField::none(),
            extra_info: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ConceptExtraInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConceptExtraInfoRequest {
    // message fields
    ///  Determine if the concept is searchable by rank using this model.
    ///  Currently, only embedder models are supported.
    ///  ########## Supported fields ##########
    ///  - app_id
    ///  - id
    ///  - model_version.id
    ///  - user_id
    // @@protoc_insertion_point(field:clarifai.api.ConceptExtraInfoRequest.rankable_model)
    pub rankable_model: ::protobuf::MessageField<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ConceptExtraInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConceptExtraInfoRequest {
    fn default() -> &'a ConceptExtraInfoRequest {
        <ConceptExtraInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConceptExtraInfoRequest {
    pub fn new() -> ConceptExtraInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "rankable_model",
            |m: &ConceptExtraInfoRequest| { &m.rankable_model },
            |m: &mut ConceptExtraInfoRequest| { &mut m.rankable_model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptExtraInfoRequest>(
            "ConceptExtraInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConceptExtraInfoRequest {
    const NAME: &'static str = "ConceptExtraInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rankable_model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rankable_model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rankable_model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConceptExtraInfoRequest {
        ConceptExtraInfoRequest::new()
    }

    fn clear(&mut self) {
        self.rankable_model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConceptExtraInfoRequest {
        static instance: ConceptExtraInfoRequest = ConceptExtraInfoRequest {
            rankable_model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConceptExtraInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConceptExtraInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConceptExtraInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptExtraInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostConceptsRequest
// @@protoc_insertion_point(message:clarifai.api.PostConceptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concepts to add.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptsRequest.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptsRequest {
    fn default() -> &'a PostConceptsRequest {
        <PostConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsRequest {
    pub fn new() -> PostConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptsRequest| { &m.user_app_id },
            |m: &mut PostConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &PostConceptsRequest| { &m.concepts },
            |m: &mut PostConceptsRequest| { &mut m.concepts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptsRequest>(
            "PostConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptsRequest {
    const NAME: &'static str = "PostConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptsRequest {
        PostConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptsRequest {
        static instance: PostConceptsRequest = PostConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchConceptsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchConceptsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchConceptsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concepts to patch.
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    ///  The action to perform on the patched objects
    ///  For now ony action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchConceptsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchConceptsRequest {
    fn default() -> &'a PatchConceptsRequest {
        <PatchConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptsRequest {
    pub fn new() -> PatchConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchConceptsRequest| { &m.user_app_id },
            |m: &mut PatchConceptsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &PatchConceptsRequest| { &m.concepts },
            |m: &mut PatchConceptsRequest| { &mut m.concepts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchConceptsRequest| { &m.action },
            |m: &mut PatchConceptsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchConceptsRequest>(
            "PatchConceptsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchConceptsRequest {
    const NAME: &'static str = "PatchConceptsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchConceptsRequest {
        PatchConceptsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchConceptsRequest {
        static instance: PatchConceptsRequest = PatchConceptsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchConceptsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchConceptsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetConceptCountsRequest
// @@protoc_insertion_point(message:clarifai.api.GetConceptCountsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetConceptCountsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptCountsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptCountsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptCountsRequest {
    fn default() -> &'a GetConceptCountsRequest {
        <GetConceptCountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptCountsRequest {
    pub fn new() -> GetConceptCountsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptCountsRequest| { &m.user_app_id },
            |m: &mut GetConceptCountsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &GetConceptCountsRequest| { &m.page },
            |m: &mut GetConceptCountsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &GetConceptCountsRequest| { &m.per_page },
            |m: &mut GetConceptCountsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptCountsRequest>(
            "GetConceptCountsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptCountsRequest {
    const NAME: &'static str = "GetConceptCountsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptCountsRequest {
        GetConceptCountsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptCountsRequest {
        static instance: GetConceptCountsRequest = GetConceptCountsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptCountsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptCountsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptCountsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleConceptResponse
// @@protoc_insertion_point(message:clarifai.api.SingleConceptResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleConceptResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept.
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptResponse.concept)
    pub concept: ::protobuf::MessageField<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleConceptResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleConceptResponse {
    fn default() -> &'a SingleConceptResponse {
        <SingleConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptResponse {
    pub fn new() -> SingleConceptResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleConceptResponse| { &m.status },
            |m: &mut SingleConceptResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Concept>(
            "concept",
            |m: &SingleConceptResponse| { &m.concept },
            |m: &mut SingleConceptResponse| { &mut m.concept },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleConceptResponse>(
            "SingleConceptResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleConceptResponse {
    const NAME: &'static str = "SingleConceptResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleConceptResponse {
        SingleConceptResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleConceptResponse {
        static instance: SingleConceptResponse = SingleConceptResponse {
            status: ::protobuf::MessageField::none(),
            concept: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleConceptResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleConceptResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concepts.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptResponse.concepts)
    pub concepts: ::std::vec::Vec<super::resources::Concept>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptResponse {
    fn default() -> &'a MultiConceptResponse {
        <MultiConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptResponse {
    pub fn new() -> MultiConceptResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptResponse| { &m.status },
            |m: &mut MultiConceptResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &MultiConceptResponse| { &m.concepts },
            |m: &mut MultiConceptResponse| { &mut m.concepts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptResponse>(
            "MultiConceptResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptResponse {
    const NAME: &'static str = "MultiConceptResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concepts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptResponse {
        MultiConceptResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concepts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptResponse {
        static instance: MultiConceptResponse = MultiConceptResponse {
            status: ::protobuf::MessageField::none(),
            concepts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptCountResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptCountResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept counts.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptCountResponse.concept_counts)
    pub concept_counts: ::std::vec::Vec<super::resources::ConceptCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptCountResponse {
    fn default() -> &'a MultiConceptCountResponse {
        <MultiConceptCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptCountResponse {
    pub fn new() -> MultiConceptCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptCountResponse| { &m.status },
            |m: &mut MultiConceptCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_counts",
            |m: &MultiConceptCountResponse| { &m.concept_counts },
            |m: &mut MultiConceptCountResponse| { &mut m.concept_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptCountResponse>(
            "MultiConceptCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptCountResponse {
    const NAME: &'static str = "MultiConceptCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_counts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptCountResponse {
        MultiConceptCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptCountResponse {
        static instance: MultiConceptCountResponse = MultiConceptCountResponse {
            status: ::protobuf::MessageField::none(),
            concept_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET all relations such that the concept_id refers to the subject of the relation
// @@protoc_insertion_point(message:clarifai.api.ListConceptRelationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The subject concept id in your app to get all the relationships for.
    ///  Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
    ///
    ///  When listing all the relations it will only return one direction of the relationship
    ///  with the predicate acting on the subject and not the inverse like is done when providing a
    ///  concept_id so that we can return a reliable page size always.
    ///
    ///  When providing a concept_id, if a hyponym is present in the DB such as:
    ///  'honey' (subject), 'hyponym' (predicate for "is a kind of"), 'food' (object)
    ///  then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
    ///  object.
    ///  But you can also list the concept relations for 'food' and it will return the same hyponym
    ///  relationship with 'honey' as object and 'hypernym' as predicate.
    ///  Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
    ///  when listing the relations.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  If predicate is provided then only list relations with that predicate.
    ///
    ///  Note that if no subject is set in concept_id and predicate is set to
    ///  'hypernym', then it will return any stored hyponyms as hypernyms with
    ///  just the subject and object swapped since they are reversed relations.
    ///
    ///  Valid predicates are:
    ///  - 'hypernym'
    ///  - 'hyponym'
    ///  - 'synonym'
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.predicate)
    pub predicate: ::std::string::String,
    ///  If knowledge_graph_id is provided then just list relations from that knowledge graph.
    ///  If not provided then list relations from all knowledge graphs including the global one for this
    ///  app one (ie. knowledge_graph "") and any specific ones in the app.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.knowledge_graph_id)
    pub knowledge_graph_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptRelationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptRelationsRequest {
    fn default() -> &'a ListConceptRelationsRequest {
        <ListConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptRelationsRequest {
    pub fn new() -> ListConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptRelationsRequest| { &m.user_app_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &ListConceptRelationsRequest| { &m.concept_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "predicate",
            |m: &ListConceptRelationsRequest| { &m.predicate },
            |m: &mut ListConceptRelationsRequest| { &mut m.predicate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "knowledge_graph_id",
            |m: &ListConceptRelationsRequest| { &m.knowledge_graph_id },
            |m: &mut ListConceptRelationsRequest| { &mut m.knowledge_graph_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptRelationsRequest| { &m.page },
            |m: &mut ListConceptRelationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptRelationsRequest| { &m.per_page },
            |m: &mut ListConceptRelationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptRelationsRequest>(
            "ListConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptRelationsRequest {
    const NAME: &'static str = "ListConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.predicate = is.read_string()?;
                },
                34 => {
                    self.knowledge_graph_id = is.read_string()?;
                },
                40 => {
                    self.page = is.read_uint32()?;
                },
                48 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.predicate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.predicate);
        }
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.knowledge_graph_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.predicate.is_empty() {
            os.write_string(3, &self.predicate)?;
        }
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(4, &self.knowledge_graph_id)?;
        }
        if self.page != 0 {
            os.write_uint32(5, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(6, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptRelationsRequest {
        ListConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.predicate.clear();
        self.knowledge_graph_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptRelationsRequest {
        static instance: ListConceptRelationsRequest = ListConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            predicate: ::std::string::String::new(),
            knowledge_graph_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST new concept relations
// @@protoc_insertion_point(message:clarifai.api.PostConceptRelationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The subject concept id you're going to add relations for.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  The relationships you're going to add.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptRelationsRequest.concept_relations)
    pub concept_relations: ::std::vec::Vec<super::resources::ConceptRelation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptRelationsRequest {
    fn default() -> &'a PostConceptRelationsRequest {
        <PostConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptRelationsRequest {
    pub fn new() -> PostConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptRelationsRequest| { &m.user_app_id },
            |m: &mut PostConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PostConceptRelationsRequest| { &m.concept_id },
            |m: &mut PostConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_relations",
            |m: &PostConceptRelationsRequest| { &m.concept_relations },
            |m: &mut PostConceptRelationsRequest| { &mut m.concept_relations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptRelationsRequest>(
            "PostConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptRelationsRequest {
    const NAME: &'static str = "PostConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_relations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_relations {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptRelationsRequest {
        PostConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_relations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptRelationsRequest {
        static instance: PostConceptRelationsRequest = PostConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_relations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DELETE concept relations
// @@protoc_insertion_point(message:clarifai.api.DeleteConceptRelationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteConceptRelationsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept to delete relationship for.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  The concept relationship ids to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteConceptRelationsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteConceptRelationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteConceptRelationsRequest {
    fn default() -> &'a DeleteConceptRelationsRequest {
        <DeleteConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteConceptRelationsRequest {
    pub fn new() -> DeleteConceptRelationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteConceptRelationsRequest| { &m.user_app_id },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &DeleteConceptRelationsRequest| { &m.concept_id },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteConceptRelationsRequest| { &m.ids },
            |m: &mut DeleteConceptRelationsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteConceptRelationsRequest>(
            "DeleteConceptRelationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteConceptRelationsRequest {
    const NAME: &'static str = "DeleteConceptRelationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteConceptRelationsRequest {
        DeleteConceptRelationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteConceptRelationsRequest {
        static instance: DeleteConceptRelationsRequest = DeleteConceptRelationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteConceptRelationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteConceptRelationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteConceptRelationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET all knowledge graphs
// @@protoc_insertion_point(message:clarifai.api.ListKnowledgeGraphsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListKnowledgeGraphsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListKnowledgeGraphsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListKnowledgeGraphsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListKnowledgeGraphsRequest {
    fn default() -> &'a ListKnowledgeGraphsRequest {
        <ListKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKnowledgeGraphsRequest {
    pub fn new() -> ListKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListKnowledgeGraphsRequest| { &m.user_app_id },
            |m: &mut ListKnowledgeGraphsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListKnowledgeGraphsRequest>(
            "ListKnowledgeGraphsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListKnowledgeGraphsRequest {
    const NAME: &'static str = "ListKnowledgeGraphsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListKnowledgeGraphsRequest {
        ListKnowledgeGraphsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListKnowledgeGraphsRequest {
        static instance: ListKnowledgeGraphsRequest = ListKnowledgeGraphsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListKnowledgeGraphsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListKnowledgeGraphsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKnowledgeGraphsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST new knowledge graphs
// @@protoc_insertion_point(message:clarifai.api.PostKnowledgeGraphsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostKnowledgeGraphsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostKnowledgeGraphsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostKnowledgeGraphsRequest.knowledge_graphs)
    pub knowledge_graphs: ::std::vec::Vec<super::resources::KnowledgeGraph>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostKnowledgeGraphsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostKnowledgeGraphsRequest {
    fn default() -> &'a PostKnowledgeGraphsRequest {
        <PostKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKnowledgeGraphsRequest {
    pub fn new() -> PostKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostKnowledgeGraphsRequest| { &m.user_app_id },
            |m: &mut PostKnowledgeGraphsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "knowledge_graphs",
            |m: &PostKnowledgeGraphsRequest| { &m.knowledge_graphs },
            |m: &mut PostKnowledgeGraphsRequest| { &mut m.knowledge_graphs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostKnowledgeGraphsRequest>(
            "PostKnowledgeGraphsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostKnowledgeGraphsRequest {
    const NAME: &'static str = "PostKnowledgeGraphsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.knowledge_graphs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.knowledge_graphs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostKnowledgeGraphsRequest {
        PostKnowledgeGraphsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.knowledge_graphs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostKnowledgeGraphsRequest {
        static instance: PostKnowledgeGraphsRequest = PostKnowledgeGraphsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            knowledge_graphs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostKnowledgeGraphsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostKnowledgeGraphsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKnowledgeGraphsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start concept mapping jobs
// @@protoc_insertion_point(message:clarifai.api.PostConceptMappingJobsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptMappingJobsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostConceptMappingJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The concept mapping jobs that are being started
    // @@protoc_insertion_point(field:clarifai.api.PostConceptMappingJobsRequest.concept_mapping_jobs)
    pub concept_mapping_jobs: ::std::vec::Vec<super::resources::ConceptMappingJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptMappingJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptMappingJobsRequest {
    fn default() -> &'a PostConceptMappingJobsRequest {
        <PostConceptMappingJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptMappingJobsRequest {
    pub fn new() -> PostConceptMappingJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptMappingJobsRequest| { &m.user_app_id },
            |m: &mut PostConceptMappingJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_mapping_jobs",
            |m: &PostConceptMappingJobsRequest| { &m.concept_mapping_jobs },
            |m: &mut PostConceptMappingJobsRequest| { &mut m.concept_mapping_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptMappingJobsRequest>(
            "PostConceptMappingJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptMappingJobsRequest {
    const NAME: &'static str = "PostConceptMappingJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_mapping_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_mapping_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_mapping_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptMappingJobsRequest {
        PostConceptMappingJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_mapping_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptMappingJobsRequest {
        static instance: PostConceptMappingJobsRequest = PostConceptMappingJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_mapping_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptMappingJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptMappingJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptMappingJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptMappingJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptRelationResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptRelationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptRelationResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptRelationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned concept relations.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptRelationResponse.concept_relations)
    pub concept_relations: ::std::vec::Vec<super::resources::ConceptRelation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptRelationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptRelationResponse {
    fn default() -> &'a MultiConceptRelationResponse {
        <MultiConceptRelationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptRelationResponse {
    pub fn new() -> MultiConceptRelationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptRelationResponse| { &m.status },
            |m: &mut MultiConceptRelationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_relations",
            |m: &MultiConceptRelationResponse| { &m.concept_relations },
            |m: &mut MultiConceptRelationResponse| { &mut m.concept_relations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptRelationResponse>(
            "MultiConceptRelationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptRelationResponse {
    const NAME: &'static str = "MultiConceptRelationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_relations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_relations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptRelationResponse {
        MultiConceptRelationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_relations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptRelationResponse {
        static instance: MultiConceptRelationResponse = MultiConceptRelationResponse {
            status: ::protobuf::MessageField::none(),
            concept_relations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptRelationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptRelationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptRelationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptRelationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiKnowledgeGraphResponse
// @@protoc_insertion_point(message:clarifai.api.MultiKnowledgeGraphResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiKnowledgeGraphResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiKnowledgeGraphResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned knowledge graphs.
    // @@protoc_insertion_point(field:clarifai.api.MultiKnowledgeGraphResponse.knowledge_graphs)
    pub knowledge_graphs: ::std::vec::Vec<super::resources::KnowledgeGraph>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiKnowledgeGraphResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiKnowledgeGraphResponse {
    fn default() -> &'a MultiKnowledgeGraphResponse {
        <MultiKnowledgeGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKnowledgeGraphResponse {
    pub fn new() -> MultiKnowledgeGraphResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiKnowledgeGraphResponse| { &m.status },
            |m: &mut MultiKnowledgeGraphResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "knowledge_graphs",
            |m: &MultiKnowledgeGraphResponse| { &m.knowledge_graphs },
            |m: &mut MultiKnowledgeGraphResponse| { &mut m.knowledge_graphs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiKnowledgeGraphResponse>(
            "MultiKnowledgeGraphResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiKnowledgeGraphResponse {
    const NAME: &'static str = "MultiKnowledgeGraphResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.knowledge_graphs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.knowledge_graphs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiKnowledgeGraphResponse {
        MultiKnowledgeGraphResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.knowledge_graphs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiKnowledgeGraphResponse {
        static instance: MultiKnowledgeGraphResponse = MultiKnowledgeGraphResponse {
            status: ::protobuf::MessageField::none(),
            knowledge_graphs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiKnowledgeGraphResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiKnowledgeGraphResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiKnowledgeGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKnowledgeGraphResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptMappingJobResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptMappingJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptMappingJobResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptMappingJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The ids of the concept mapping jobs underway.
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptMappingJobResponse.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptMappingJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptMappingJobResponse {
    fn default() -> &'a MultiConceptMappingJobResponse {
        <MultiConceptMappingJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptMappingJobResponse {
    pub fn new() -> MultiConceptMappingJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptMappingJobResponse| { &m.status },
            |m: &mut MultiConceptMappingJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &MultiConceptMappingJobResponse| { &m.ids },
            |m: &mut MultiConceptMappingJobResponse| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptMappingJobResponse>(
            "MultiConceptMappingJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptMappingJobResponse {
    const NAME: &'static str = "MultiConceptMappingJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptMappingJobResponse {
        MultiConceptMappingJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptMappingJobResponse {
        static instance: MultiConceptMappingJobResponse = MultiConceptMappingJobResponse {
            status: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptMappingJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptMappingJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptMappingJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptMappingJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GET single concept language for the given concept.
// @@protoc_insertion_point(message:clarifai.api.GetConceptLanguageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetConceptLanguageRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  This is the language identifier.
    // @@protoc_insertion_point(field:clarifai.api.GetConceptLanguageRequest.language)
    pub language: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetConceptLanguageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConceptLanguageRequest {
    fn default() -> &'a GetConceptLanguageRequest {
        <GetConceptLanguageRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptLanguageRequest {
    pub fn new() -> GetConceptLanguageRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetConceptLanguageRequest| { &m.user_app_id },
            |m: &mut GetConceptLanguageRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &GetConceptLanguageRequest| { &m.concept_id },
            |m: &mut GetConceptLanguageRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &GetConceptLanguageRequest| { &m.language },
            |m: &mut GetConceptLanguageRequest| { &mut m.language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConceptLanguageRequest>(
            "GetConceptLanguageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConceptLanguageRequest {
    const NAME: &'static str = "GetConceptLanguageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.language = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(3, &self.language)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConceptLanguageRequest {
        GetConceptLanguageRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.language.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConceptLanguageRequest {
        static instance: GetConceptLanguageRequest = GetConceptLanguageRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            language: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConceptLanguageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConceptLanguageRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConceptLanguageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptLanguageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  List multiple concept languages for the given concept.
// @@protoc_insertion_point(message:clarifai.api.ListConceptLanguagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListConceptLanguagesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListConceptLanguagesRequest {
    fn default() -> &'a ListConceptLanguagesRequest {
        <ListConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptLanguagesRequest {
    pub fn new() -> ListConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut ListConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &ListConceptLanguagesRequest| { &m.concept_id },
            |m: &mut ListConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListConceptLanguagesRequest| { &m.page },
            |m: &mut ListConceptLanguagesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListConceptLanguagesRequest| { &m.per_page },
            |m: &mut ListConceptLanguagesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListConceptLanguagesRequest>(
            "ListConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListConceptLanguagesRequest {
    const NAME: &'static str = "ListConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListConceptLanguagesRequest {
        ListConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListConceptLanguagesRequest {
        static instance: ListConceptLanguagesRequest = ListConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PATCH multiple concept languages for the given concept.
// @@protoc_insertion_point(message:clarifai.api.PatchConceptLanguagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    ///  The action to perform with the objects in the PATCH.
    // @@protoc_insertion_point(field:clarifai.api.PatchConceptLanguagesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchConceptLanguagesRequest {
    fn default() -> &'a PatchConceptLanguagesRequest {
        <PatchConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptLanguagesRequest {
    pub fn new() -> PatchConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PatchConceptLanguagesRequest| { &m.concept_id },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &PatchConceptLanguagesRequest| { &m.concept_languages },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchConceptLanguagesRequest| { &m.action },
            |m: &mut PatchConceptLanguagesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchConceptLanguagesRequest>(
            "PatchConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchConceptLanguagesRequest {
    const NAME: &'static str = "PatchConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_languages.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchConceptLanguagesRequest {
        PatchConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchConceptLanguagesRequest {
        static instance: PatchConceptLanguagesRequest = PatchConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_languages: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  POST multiple concept languages for the given concept.
// @@protoc_insertion_point(message:clarifai.api.PostConceptLanguagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostConceptLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.concept_id)
    pub concept_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostConceptLanguagesRequest.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostConceptLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostConceptLanguagesRequest {
    fn default() -> &'a PostConceptLanguagesRequest {
        <PostConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptLanguagesRequest {
    pub fn new() -> PostConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostConceptLanguagesRequest| { &m.user_app_id },
            |m: &mut PostConceptLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "concept_id",
            |m: &PostConceptLanguagesRequest| { &m.concept_id },
            |m: &mut PostConceptLanguagesRequest| { &mut m.concept_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &PostConceptLanguagesRequest| { &m.concept_languages },
            |m: &mut PostConceptLanguagesRequest| { &mut m.concept_languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostConceptLanguagesRequest>(
            "PostConceptLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostConceptLanguagesRequest {
    const NAME: &'static str = "PostConceptLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.concept_id = is.read_string()?;
                },
                26 => {
                    self.concept_languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostConceptLanguagesRequest {
        PostConceptLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostConceptLanguagesRequest {
        static instance: PostConceptLanguagesRequest = PostConceptLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            concept_id: ::std::string::String::new(),
            concept_languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostConceptLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostConceptLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleConceptLanguageResponse
// @@protoc_insertion_point(message:clarifai.api.SingleConceptLanguageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleConceptLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleConceptLanguageResponse.concept_language)
    pub concept_language: ::protobuf::MessageField<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleConceptLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleConceptLanguageResponse {
    fn default() -> &'a SingleConceptLanguageResponse {
        <SingleConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptLanguageResponse {
    pub fn new() -> SingleConceptLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleConceptLanguageResponse| { &m.status },
            |m: &mut SingleConceptLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ConceptLanguage>(
            "concept_language",
            |m: &SingleConceptLanguageResponse| { &m.concept_language },
            |m: &mut SingleConceptLanguageResponse| { &mut m.concept_language },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleConceptLanguageResponse>(
            "SingleConceptLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleConceptLanguageResponse {
    const NAME: &'static str = "SingleConceptLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.concept_language)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.concept_language.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.concept_language.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleConceptLanguageResponse {
        SingleConceptLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_language.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleConceptLanguageResponse {
        static instance: SingleConceptLanguageResponse = SingleConceptLanguageResponse {
            status: ::protobuf::MessageField::none(),
            concept_language: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleConceptLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleConceptLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiConceptLanguageResponse
// @@protoc_insertion_point(message:clarifai.api.MultiConceptLanguageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiConceptLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiConceptLanguageResponse.concept_languages)
    pub concept_languages: ::std::vec::Vec<super::resources::ConceptLanguage>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiConceptLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiConceptLanguageResponse {
    fn default() -> &'a MultiConceptLanguageResponse {
        <MultiConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptLanguageResponse {
    pub fn new() -> MultiConceptLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiConceptLanguageResponse| { &m.status },
            |m: &mut MultiConceptLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_languages",
            |m: &MultiConceptLanguageResponse| { &m.concept_languages },
            |m: &mut MultiConceptLanguageResponse| { &mut m.concept_languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiConceptLanguageResponse>(
            "MultiConceptLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiConceptLanguageResponse {
    const NAME: &'static str = "MultiConceptLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.concept_languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.concept_languages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiConceptLanguageResponse {
        MultiConceptLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.concept_languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiConceptLanguageResponse {
        static instance: MultiConceptLanguageResponse = MultiConceptLanguageResponse {
            status: ::protobuf::MessageField::none(),
            concept_languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiConceptLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiConceptLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputRequest
// @@protoc_insertion_point(message:clarifai.api.GetInputRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputRequest {
    fn default() -> &'a GetInputRequest {
        <GetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputRequest {
    pub fn new() -> GetInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputRequest| { &m.user_app_id },
            |m: &mut GetInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetInputRequest| { &m.input_id },
            |m: &mut GetInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputRequest>(
            "GetInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputRequest {
    const NAME: &'static str = "GetInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputRequest {
        GetInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputRequest {
        static instance: GetInputRequest = GetInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetVideoManifestRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetVideoManifestRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetVideoManifestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVideoManifestRequest {
    fn default() -> &'a GetVideoManifestRequest {
        <GetVideoManifestRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetVideoManifestRequest {
    pub fn new() -> GetVideoManifestRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetVideoManifestRequest| { &m.user_app_id },
            |m: &mut GetVideoManifestRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetVideoManifestRequest| { &m.input_id },
            |m: &mut GetVideoManifestRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVideoManifestRequest>(
            "GetVideoManifestRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVideoManifestRequest {
    const NAME: &'static str = "GetVideoManifestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVideoManifestRequest {
        GetVideoManifestRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVideoManifestRequest {
        static instance: GetVideoManifestRequest = GetVideoManifestRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVideoManifestRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVideoManifestRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVideoManifestRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVideoManifestRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputSamplesRequest
// @@protoc_insertion_point(message:clarifai.api.GetInputSamplesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputSamplesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.task_id)
    pub task_id: ::std::string::String,
    ///  URL param. If zero ids provided, returns for all task labelers
    // @@protoc_insertion_point(field:clarifai.api.GetInputSamplesRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputSamplesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputSamplesRequest {
    fn default() -> &'a GetInputSamplesRequest {
        <GetInputSamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputSamplesRequest {
    pub fn new() -> GetInputSamplesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputSamplesRequest| { &m.user_app_id },
            |m: &mut GetInputSamplesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetInputSamplesRequest| { &m.task_id },
            |m: &mut GetInputSamplesRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &GetInputSamplesRequest| { &m.user_ids },
            |m: &mut GetInputSamplesRequest| { &mut m.user_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputSamplesRequest>(
            "GetInputSamplesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputSamplesRequest {
    const NAME: &'static str = "GetInputSamplesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputSamplesRequest {
        GetInputSamplesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputSamplesRequest {
        static instance: GetInputSamplesRequest = GetInputSamplesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            user_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputSamplesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputSamplesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputSamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputSamplesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListInputsRequest
// @@protoc_insertion_point(message:clarifai.api.ListInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.per_page)
    pub per_page: u32,
    ///  Set status to filter by status
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.ListInputsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsRequest {
    fn default() -> &'a ListInputsRequest {
        <ListInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsRequest {
    pub fn new() -> ListInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsRequest| { &m.user_app_id },
            |m: &mut ListInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsRequest| { &m.page },
            |m: &mut ListInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsRequest| { &m.per_page },
            |m: &mut ListInputsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ListInputsRequest| { &m.status },
            |m: &mut ListInputsRequest| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &ListInputsRequest| { &m.ids },
            |m: &mut ListInputsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsRequest>(
            "ListInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsRequest {
    const NAME: &'static str = "ListInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                34 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsRequest {
        ListInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.status.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsRequest {
        static instance: ListInputsRequest = ListInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            status: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  StreamInputsRequest
// @@protoc_insertion_point(message:clarifai.api.StreamInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 20.
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.last_id)
    pub last_id: ::std::string::String,
    ///  By default, the endpoint return inputs by the time when it is added.
    ///  If this is set to true, we will return inputs by id.
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.order_by_id)
    pub order_by_id: bool,
    // @@protoc_insertion_point(field:clarifai.api.StreamInputsRequest.descending)
    pub descending: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.StreamInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamInputsRequest {
    fn default() -> &'a StreamInputsRequest {
        <StreamInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamInputsRequest {
    pub fn new() -> StreamInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &StreamInputsRequest| { &m.user_app_id },
            |m: &mut StreamInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &StreamInputsRequest| { &m.per_page },
            |m: &mut StreamInputsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_id",
            |m: &StreamInputsRequest| { &m.last_id },
            |m: &mut StreamInputsRequest| { &mut m.last_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_by_id",
            |m: &StreamInputsRequest| { &m.order_by_id },
            |m: &mut StreamInputsRequest| { &mut m.order_by_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "descending",
            |m: &StreamInputsRequest| { &m.descending },
            |m: &mut StreamInputsRequest| { &mut m.descending },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamInputsRequest>(
            "StreamInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamInputsRequest {
    const NAME: &'static str = "StreamInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.per_page = is.read_uint32()?;
                },
                26 => {
                    self.last_id = is.read_string()?;
                },
                40 => {
                    self.order_by_id = is.read_bool()?;
                },
                32 => {
                    self.descending = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.per_page);
        }
        if !self.last_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.last_id);
        }
        if self.order_by_id != false {
            my_size += 1 + 1;
        }
        if self.descending != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        if !self.last_id.is_empty() {
            os.write_string(3, &self.last_id)?;
        }
        if self.order_by_id != false {
            os.write_bool(5, self.order_by_id)?;
        }
        if self.descending != false {
            os.write_bool(4, self.descending)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamInputsRequest {
        StreamInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.per_page = 0;
        self.last_id.clear();
        self.order_by_id = false;
        self.descending = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamInputsRequest {
        static instance: StreamInputsRequest = StreamInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            per_page: 0,
            last_id: ::std::string::String::new(),
            order_by_id: false,
            descending: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInputsRequest
// @@protoc_insertion_point(message:clarifai.api.PostInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of inputs to post.
    ///  For each input, the following fields are used:
    ///  * id
    ///  * data
    ///  * dataset_ids
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Collect statistics about created inputs in job with given ID.
    ///  * If job ID is empty, then job is not created.
    ///  * If job ID is non-empty and doesn't already exist, then a new job will be created with given ID.
    ///  * If job ID does already exist, then new inputs statistics are merged with previous inputs statistics.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.inputs_add_job_id)
    pub inputs_add_job_id: ::std::string::String,
    ///  How to handle input ID conflicts.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsRequest.input_id_conflict_resolution)
    pub input_id_conflict_resolution: ::protobuf::EnumOrUnknown<super::resources::InputIDConflictResolution>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsRequest {
    fn default() -> &'a PostInputsRequest {
        <PostInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsRequest {
    pub fn new() -> PostInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsRequest| { &m.user_app_id },
            |m: &mut PostInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostInputsRequest| { &m.inputs },
            |m: &mut PostInputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_add_job_id",
            |m: &PostInputsRequest| { &m.inputs_add_job_id },
            |m: &mut PostInputsRequest| { &mut m.inputs_add_job_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id_conflict_resolution",
            |m: &PostInputsRequest| { &m.input_id_conflict_resolution },
            |m: &mut PostInputsRequest| { &mut m.input_id_conflict_resolution },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsRequest>(
            "PostInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsRequest {
    const NAME: &'static str = "PostInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    self.inputs_add_job_id = is.read_string()?;
                },
                32 => {
                    self.input_id_conflict_resolution = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.inputs_add_job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.inputs_add_job_id);
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(4, self.input_id_conflict_resolution.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.inputs_add_job_id.is_empty() {
            os.write_string(3, &self.inputs_add_job_id)?;
        }
        if self.input_id_conflict_resolution != ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.input_id_conflict_resolution))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsRequest {
        PostInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.inputs_add_job_id.clear();
        self.input_id_conflict_resolution = ::protobuf::EnumOrUnknown::new(super::resources::InputIDConflictResolution::INPUT_ID_CONFLICT_RESOLUTION_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsRequest {
        static instance: PostInputsRequest = PostInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            inputs_add_job_id: ::std::string::String::new(),
            input_id_conflict_resolution: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchInputsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of inputs to patch.
    ///  Inputs are identified by id field.
    ///  For each input, the following fields are patchable:
    ///  * data
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchInputsRequest {
    fn default() -> &'a PatchInputsRequest {
        <PatchInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsRequest {
    pub fn new() -> PatchInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchInputsRequest| { &m.user_app_id },
            |m: &mut PatchInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PatchInputsRequest| { &m.inputs },
            |m: &mut PatchInputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchInputsRequest| { &m.action },
            |m: &mut PatchInputsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchInputsRequest>(
            "PatchInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchInputsRequest {
    const NAME: &'static str = "PatchInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchInputsRequest {
        PatchInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchInputsRequest {
        static instance: PatchInputsRequest = PatchInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteInputRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteInputRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInputRequest {
    fn default() -> &'a DeleteInputRequest {
        <DeleteInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputRequest {
    pub fn new() -> DeleteInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInputRequest| { &m.user_app_id },
            |m: &mut DeleteInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &DeleteInputRequest| { &m.input_id },
            |m: &mut DeleteInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInputRequest>(
            "DeleteInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInputRequest {
    const NAME: &'static str = "DeleteInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInputRequest {
        DeleteInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInputRequest {
        static instance: DeleteInputRequest = DeleteInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInputsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInputsRequest {
    fn default() -> &'a DeleteInputsRequest {
        <DeleteInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputsRequest {
    pub fn new() -> DeleteInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInputsRequest| { &m.user_app_id },
            |m: &mut DeleteInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteInputsRequest| { &m.ids },
            |m: &mut DeleteInputsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInputsRequest>(
            "DeleteInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInputsRequest {
    const NAME: &'static str = "DeleteInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInputsRequest {
        DeleteInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInputsRequest {
        static instance: DeleteInputsRequest = DeleteInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputResponse
// @@protoc_insertion_point(message:clarifai.api.SingleInputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputResponse.input)
    pub input: ::protobuf::MessageField<super::resources::Input>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputResponse {
    fn default() -> &'a SingleInputResponse {
        <SingleInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputResponse {
    pub fn new() -> SingleInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputResponse| { &m.status },
            |m: &mut SingleInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Input>(
            "input",
            |m: &SingleInputResponse| { &m.input },
            |m: &mut SingleInputResponse| { &mut m.input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputResponse>(
            "SingleInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputResponse {
    const NAME: &'static str = "SingleInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputResponse {
        SingleInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputResponse {
        static instance: SingleInputResponse = SingleInputResponse {
            status: ::protobuf::MessageField::none(),
            input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetVideoManifestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetVideoManifestResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  MPEG-dash manifest as data-URI, base64-encoded
    ///  Can be empty if status is FAILED
    ///  Can be fallback manifest if status is MIXED_STATUS
    // @@protoc_insertion_point(field:clarifai.api.GetVideoManifestResponse.manifest_url)
    pub manifest_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetVideoManifestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetVideoManifestResponse {
    fn default() -> &'a GetVideoManifestResponse {
        <GetVideoManifestResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetVideoManifestResponse {
    pub fn new() -> GetVideoManifestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &GetVideoManifestResponse| { &m.status },
            |m: &mut GetVideoManifestResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "manifest_url",
            |m: &GetVideoManifestResponse| { &m.manifest_url },
            |m: &mut GetVideoManifestResponse| { &mut m.manifest_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetVideoManifestResponse>(
            "GetVideoManifestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetVideoManifestResponse {
    const NAME: &'static str = "GetVideoManifestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.manifest_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.manifest_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.manifest_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.manifest_url.is_empty() {
            os.write_string(2, &self.manifest_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetVideoManifestResponse {
        GetVideoManifestResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.manifest_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetVideoManifestResponse {
        static instance: GetVideoManifestResponse = GetVideoManifestResponse {
            status: ::protobuf::MessageField::none(),
            manifest_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetVideoManifestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetVideoManifestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetVideoManifestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVideoManifestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputResponse
// @@protoc_insertion_point(message:clarifai.api.MultiInputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputResponse.inputs_add_job)
    pub inputs_add_job: ::protobuf::MessageField<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputResponse {
    fn default() -> &'a MultiInputResponse {
        <MultiInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputResponse {
    pub fn new() -> MultiInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputResponse| { &m.status },
            |m: &mut MultiInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &MultiInputResponse| { &m.inputs },
            |m: &mut MultiInputResponse| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsAddJob>(
            "inputs_add_job",
            |m: &MultiInputResponse| { &m.inputs_add_job },
            |m: &mut MultiInputResponse| { &mut m.inputs_add_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputResponse>(
            "MultiInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputResponse {
    const NAME: &'static str = "MultiInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_add_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.inputs_add_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.inputs_add_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputResponse {
        MultiInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs.clear();
        self.inputs_add_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputResponse {
        static instance: MultiInputResponse = MultiInputResponse {
            status: ::protobuf::MessageField::none(),
            inputs: ::std::vec::Vec::new(),
            inputs_add_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputAnnotationResponse
// @@protoc_insertion_point(message:clarifai.api.MultiInputAnnotationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInputAnnotationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputAnnotationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputAnnotationResponse.hits)
    pub hits: ::std::vec::Vec<super::resources::Hit>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputAnnotationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputAnnotationResponse {
    fn default() -> &'a MultiInputAnnotationResponse {
        <MultiInputAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputAnnotationResponse {
    pub fn new() -> MultiInputAnnotationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputAnnotationResponse| { &m.status },
            |m: &mut MultiInputAnnotationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hits",
            |m: &MultiInputAnnotationResponse| { &m.hits },
            |m: &mut MultiInputAnnotationResponse| { &mut m.hits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputAnnotationResponse>(
            "MultiInputAnnotationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputAnnotationResponse {
    const NAME: &'static str = "MultiInputAnnotationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                26 => {
                    self.hits.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.hits {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputAnnotationResponse {
        MultiInputAnnotationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.hits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputAnnotationResponse {
        static instance: MultiInputAnnotationResponse = MultiInputAnnotationResponse {
            status: ::protobuf::MessageField::none(),
            hits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputAnnotationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputAnnotationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputAnnotationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputCountResponse
// @@protoc_insertion_point(message:clarifai.api.SingleInputCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInputCountResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputCountResponse.counts)
    pub counts: ::protobuf::MessageField<super::resources::InputCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputCountResponse {
    fn default() -> &'a SingleInputCountResponse {
        <SingleInputCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputCountResponse {
    pub fn new() -> SingleInputCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputCountResponse| { &m.status },
            |m: &mut SingleInputCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputCount>(
            "counts",
            |m: &SingleInputCountResponse| { &m.counts },
            |m: &mut SingleInputCountResponse| { &mut m.counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputCountResponse>(
            "SingleInputCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputCountResponse {
    const NAME: &'static str = "SingleInputCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.counts)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.counts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputCountResponse {
        SingleInputCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputCountResponse {
        static instance: SingleInputCountResponse = SingleInputCountResponse {
            status: ::protobuf::MessageField::none(),
            counts: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInputCountRequest
// @@protoc_insertion_point(message:clarifai.api.GetInputCountRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputCountRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputCountRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputCountRequest {
    fn default() -> &'a GetInputCountRequest {
        <GetInputCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputCountRequest {
    pub fn new() -> GetInputCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputCountRequest| { &m.user_app_id },
            |m: &mut GetInputCountRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputCountRequest>(
            "GetInputCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputCountRequest {
    const NAME: &'static str = "GetInputCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputCountRequest {
        GetInputCountRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputCountRequest {
        static instance: GetInputCountRequest = GetInputCountRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetsRequest
// @@protoc_insertion_point(message:clarifai.api.ListDatasetsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.starred_only)
    pub starred_only: bool,
    ///  Filter datasets by bookmark. If set, only return bookmarked datasets. Otherwise none bookmarked datasets only.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.bookmark)
    pub bookmark: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the dataset:
    ///    - id
    ///    - description
    ///    - notes
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.search)
    pub search: ::std::string::String,
    ///  Fuzzy filter on dataset ID
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetsRequest.id)
    pub id: ::std::string::String,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_datasets_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetsRequest {
    fn default() -> &'a ListDatasetsRequest {
        <ListDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetsRequest {
    pub fn new() -> ListDatasetsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_created_at = 7;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 8;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(v))
    }

    // bool sort_by_modified_at = 9;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_id = 11;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetsRequest| { &m.user_app_id },
            |m: &mut ListDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetsRequest| { &m.page },
            |m: &mut ListDatasetsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetsRequest| { &m.per_page },
            |m: &mut ListDatasetsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListDatasetsRequest| { &m.additional_fields },
            |m: &mut ListDatasetsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListDatasetsRequest| { &m.sort_ascending },
            |m: &mut ListDatasetsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListDatasetsRequest::has_sort_by_created_at,
            ListDatasetsRequest::sort_by_created_at,
            ListDatasetsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListDatasetsRequest::has_sort_by_star_count,
            ListDatasetsRequest::sort_by_star_count,
            ListDatasetsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListDatasetsRequest::has_sort_by_modified_at,
            ListDatasetsRequest::sort_by_modified_at,
            ListDatasetsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListDatasetsRequest::has_sort_by_id,
            ListDatasetsRequest::sort_by_id,
            ListDatasetsRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListDatasetsRequest| { &m.starred_only },
            |m: &mut ListDatasetsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListDatasetsRequest| { &m.bookmark },
            |m: &mut ListDatasetsRequest| { &mut m.bookmark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListDatasetsRequest| { &m.search },
            |m: &mut ListDatasetsRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListDatasetsRequest| { &m.id },
            |m: &mut ListDatasetsRequest| { &mut m.id },
        ));
        oneofs.push(list_datasets_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetsRequest>(
            "ListDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetsRequest {
    const NAME: &'static str = "ListDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    self.additional_fields.push(is.read_string()?);
                },
                48 => {
                    self.sort_ascending = is.read_bool()?;
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_datasets_request::Sort_by::SortById(is.read_bool()?));
                },
                32 => {
                    self.starred_only = is.read_bool()?;
                },
                80 => {
                    self.bookmark = is.read_bool()?;
                },
                106 => {
                    self.search = is.read_string()?;
                },
                98 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.search);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.id);
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_datasets_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_datasets_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(5, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(6, self.sort_ascending)?;
        }
        if self.starred_only != false {
            os.write_bool(4, self.starred_only)?;
        }
        if self.bookmark != false {
            os.write_bool(10, self.bookmark)?;
        }
        if !self.search.is_empty() {
            os.write_string(13, &self.search)?;
        }
        if !self.id.is_empty() {
            os.write_string(12, &self.id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_datasets_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_datasets_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(8, v)?;
                },
                &list_datasets_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(9, v)?;
                },
                &list_datasets_request::Sort_by::SortById(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetsRequest {
        ListDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.starred_only = false;
        self.bookmark = false;
        self.search.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetsRequest {
        static instance: ListDatasetsRequest = ListDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            starred_only: false,
            bookmark: false,
            search: ::std::string::String::new(),
            id: ::std::string::String::new(),
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListDatasetsRequest`
pub mod list_datasets_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListDatasetsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_star_count)
        SortByStarCount(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListDatasetsRequest.sort_by_id)
        SortById(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListDatasetsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  GetDatasetRequest
// @@protoc_insertion_point(message:clarifai.api.GetDatasetRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetDatasetRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetRequest {
    fn default() -> &'a GetDatasetRequest {
        <GetDatasetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetRequest {
    pub fn new() -> GetDatasetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetRequest| { &m.user_app_id },
            |m: &mut GetDatasetRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetRequest| { &m.dataset_id },
            |m: &mut GetDatasetRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetDatasetRequest| { &m.additional_fields },
            |m: &mut GetDatasetRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetRequest>(
            "GetDatasetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetRequest {
    const NAME: &'static str = "GetDatasetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetRequest {
        GetDatasetRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetRequest {
        static instance: GetDatasetRequest = GetDatasetRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more datasets.
// @@protoc_insertion_point(message:clarifai.api.PostDatasetsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of datasets that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetsRequest.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetsRequest {
    fn default() -> &'a PostDatasetsRequest {
        <PostDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetsRequest {
    pub fn new() -> PostDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetsRequest| { &m.user_app_id },
            |m: &mut PostDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &PostDatasetsRequest| { &m.datasets },
            |m: &mut PostDatasetsRequest| { &mut m.datasets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetsRequest>(
            "PostDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetsRequest {
    const NAME: &'static str = "PostDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetsRequest {
        PostDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.datasets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetsRequest {
        static instance: PostDatasetsRequest = PostDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several datasets.
// @@protoc_insertion_point(message:clarifai.api.PatchDatasetsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of datasets that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    ///  The action to perform on the patched objects
    ///  Supported values: 'overwrite', 'merge', and 'remove'.
    ///
    ///  Note that 'remove' can only be used to remove the dataset image by setting
    ///  'image.url' in the request to the current value returned for that dataset.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchDatasetsRequest {
    fn default() -> &'a PatchDatasetsRequest {
        <PatchDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchDatasetsRequest {
    pub fn new() -> PatchDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchDatasetsRequest| { &m.user_app_id },
            |m: &mut PatchDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &PatchDatasetsRequest| { &m.datasets },
            |m: &mut PatchDatasetsRequest| { &mut m.datasets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchDatasetsRequest| { &m.action },
            |m: &mut PatchDatasetsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchDatasetsRequest>(
            "PatchDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchDatasetsRequest {
    const NAME: &'static str = "PatchDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchDatasetsRequest {
        PatchDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.datasets.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchDatasetsRequest {
        static instance: PatchDatasetsRequest = PatchDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several datasets by list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteDatasetsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetsRequest.dataset_ids)
    pub dataset_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetsRequest {
    fn default() -> &'a DeleteDatasetsRequest {
        <DeleteDatasetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetsRequest {
    pub fn new() -> DeleteDatasetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_ids",
            |m: &DeleteDatasetsRequest| { &m.dataset_ids },
            |m: &mut DeleteDatasetsRequest| { &mut m.dataset_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetsRequest>(
            "DeleteDatasetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetsRequest {
    const NAME: &'static str = "DeleteDatasetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetsRequest {
        DeleteDatasetsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetsRequest {
        static instance: DeleteDatasetsRequest = DeleteDatasetsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiDatasetResponse
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetResponse.datasets)
    pub datasets: ::std::vec::Vec<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetResponse {
    fn default() -> &'a MultiDatasetResponse {
        <MultiDatasetResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetResponse {
    pub fn new() -> MultiDatasetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetResponse| { &m.status },
            |m: &mut MultiDatasetResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "datasets",
            |m: &MultiDatasetResponse| { &m.datasets },
            |m: &mut MultiDatasetResponse| { &mut m.datasets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetResponse>(
            "MultiDatasetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetResponse {
    const NAME: &'static str = "MultiDatasetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.datasets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.datasets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.datasets {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetResponse {
        MultiDatasetResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.datasets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetResponse {
        static instance: MultiDatasetResponse = MultiDatasetResponse {
            status: ::protobuf::MessageField::none(),
            datasets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleDatasetResponse
// @@protoc_insertion_point(message:clarifai.api.SingleDatasetResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleDatasetResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetResponse.dataset)
    pub dataset: ::protobuf::MessageField<super::resources::Dataset>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetResponse {
    fn default() -> &'a SingleDatasetResponse {
        <SingleDatasetResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetResponse {
    pub fn new() -> SingleDatasetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetResponse| { &m.status },
            |m: &mut SingleDatasetResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Dataset>(
            "dataset",
            |m: &SingleDatasetResponse| { &m.dataset },
            |m: &mut SingleDatasetResponse| { &mut m.dataset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetResponse>(
            "SingleDatasetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetResponse {
    const NAME: &'static str = "SingleDatasetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetResponse {
        SingleDatasetResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetResponse {
        static instance: SingleDatasetResponse = SingleDatasetResponse {
            status: ::protobuf::MessageField::none(),
            dataset: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetInputsRequest
// @@protoc_insertion_point(message:clarifai.api.ListDatasetInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetInputsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetInputsRequest {
    fn default() -> &'a ListDatasetInputsRequest {
        <ListDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetInputsRequest {
    pub fn new() -> ListDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetInputsRequest| { &m.user_app_id },
            |m: &mut ListDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetInputsRequest| { &m.dataset_id },
            |m: &mut ListDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetInputsRequest| { &m.page },
            |m: &mut ListDatasetInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetInputsRequest| { &m.per_page },
            |m: &mut ListDatasetInputsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetInputsRequest>(
            "ListDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetInputsRequest {
    const NAME: &'static str = "ListDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetInputsRequest {
        ListDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetInputsRequest {
        static instance: ListDatasetInputsRequest = ListDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetDatasetInputRequest
// @@protoc_insertion_point(message:clarifai.api.GetDatasetInputRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetDatasetInputRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset input by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetInputRequest.input_id)
    pub input_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetInputRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetInputRequest {
    fn default() -> &'a GetDatasetInputRequest {
        <GetDatasetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetInputRequest {
    pub fn new() -> GetDatasetInputRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetInputRequest| { &m.user_app_id },
            |m: &mut GetDatasetInputRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetInputRequest| { &m.dataset_id },
            |m: &mut GetDatasetInputRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &GetDatasetInputRequest| { &m.input_id },
            |m: &mut GetDatasetInputRequest| { &mut m.input_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetInputRequest>(
            "GetDatasetInputRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetInputRequest {
    const NAME: &'static str = "GetDatasetInputRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetInputRequest {
        GetDatasetInputRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.input_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetInputRequest {
        static instance: GetDatasetInputRequest = GetDatasetInputRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetInputRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetInputRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetInputRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more datasets.
// @@protoc_insertion_point(message:clarifai.api.PostDatasetInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of inputs that are requested to be added to this dataset.
    ///  Identify each input by id field. All other inputs fields are ignored.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.dataset_inputs)
    pub dataset_inputs: ::std::vec::Vec<super::resources::DatasetInput>,
    ///  Query to search inputs to be added to this dataset.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetInputsRequest.search)
    pub search: ::protobuf::MessageField<super::resources::Search>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetInputsRequest {
    fn default() -> &'a PostDatasetInputsRequest {
        <PostDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetInputsRequest {
    pub fn new() -> PostDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetInputsRequest| { &m.user_app_id },
            |m: &mut PostDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PostDatasetInputsRequest| { &m.dataset_id },
            |m: &mut PostDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_inputs",
            |m: &PostDatasetInputsRequest| { &m.dataset_inputs },
            |m: &mut PostDatasetInputsRequest| { &mut m.dataset_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search",
            |m: &PostDatasetInputsRequest| { &m.search },
            |m: &mut PostDatasetInputsRequest| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetInputsRequest>(
            "PostDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetInputsRequest {
    const NAME: &'static str = "PostDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_inputs.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetInputsRequest {
        PostDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_inputs.clear();
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetInputsRequest {
        static instance: PostDatasetInputsRequest = PostDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_inputs: ::std::vec::Vec::new(),
            search: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several dataset inputs by list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteDatasetInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Specify which inputs to delete from dataset.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetInputsRequest.input_ids)
    pub input_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetInputsRequest {
    fn default() -> &'a DeleteDatasetInputsRequest {
        <DeleteDatasetInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetInputsRequest {
    pub fn new() -> DeleteDatasetInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetInputsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DeleteDatasetInputsRequest| { &m.dataset_id },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_ids",
            |m: &DeleteDatasetInputsRequest| { &m.input_ids },
            |m: &mut DeleteDatasetInputsRequest| { &mut m.input_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetInputsRequest>(
            "DeleteDatasetInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetInputsRequest {
    const NAME: &'static str = "DeleteDatasetInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.input_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetInputsRequest {
        DeleteDatasetInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.input_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetInputsRequest {
        static instance: DeleteDatasetInputsRequest = DeleteDatasetInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            input_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiDatasetInputResponse
// @@protoc_insertion_point(message:clarifai.api.MultiDatasetInputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.dataset_inputs)
    pub dataset_inputs: ::std::vec::Vec<super::resources::DatasetInput>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetInputResponse.bulk_operation)
    pub bulk_operation: ::protobuf::MessageField<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetInputResponse {
    fn default() -> &'a MultiDatasetInputResponse {
        <MultiDatasetInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetInputResponse {
    pub fn new() -> MultiDatasetInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetInputResponse| { &m.status },
            |m: &mut MultiDatasetInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_inputs",
            |m: &MultiDatasetInputResponse| { &m.dataset_inputs },
            |m: &mut MultiDatasetInputResponse| { &mut m.dataset_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::BulkOperation>(
            "bulk_operation",
            |m: &MultiDatasetInputResponse| { &m.bulk_operation },
            |m: &mut MultiDatasetInputResponse| { &mut m.bulk_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetInputResponse>(
            "MultiDatasetInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetInputResponse {
    const NAME: &'static str = "MultiDatasetInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_inputs.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bulk_operation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.bulk_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.bulk_operation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetInputResponse {
        MultiDatasetInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_inputs.clear();
        self.bulk_operation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetInputResponse {
        static instance: MultiDatasetInputResponse = MultiDatasetInputResponse {
            status: ::protobuf::MessageField::none(),
            dataset_inputs: ::std::vec::Vec::new(),
            bulk_operation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleDatasetInputResponse
// @@protoc_insertion_point(message:clarifai.api.SingleDatasetInputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleDatasetInputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetInputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetInputResponse.dataset_input)
    pub dataset_input: ::protobuf::MessageField<super::resources::DatasetInput>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetInputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetInputResponse {
    fn default() -> &'a SingleDatasetInputResponse {
        <SingleDatasetInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetInputResponse {
    pub fn new() -> SingleDatasetInputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetInputResponse| { &m.status },
            |m: &mut SingleDatasetInputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::DatasetInput>(
            "dataset_input",
            |m: &SingleDatasetInputResponse| { &m.dataset_input },
            |m: &mut SingleDatasetInputResponse| { &mut m.dataset_input },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetInputResponse>(
            "SingleDatasetInputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetInputResponse {
    const NAME: &'static str = "SingleDatasetInputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset_input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset_input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetInputResponse {
        SingleDatasetInputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetInputResponse {
        static instance: SingleDatasetInputResponse = SingleDatasetInputResponse {
            status: ::protobuf::MessageField::none(),
            dataset_input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetInputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetInputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetInputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListDatasetVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) Filter by origin of dataset version
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionsRequest.request_origins)
    pub request_origins: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::resources::DatasetVersionRequestOrigin>>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetVersionsRequest {
    fn default() -> &'a ListDatasetVersionsRequest {
        <ListDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetVersionsRequest {
    pub fn new() -> ListDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut ListDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut ListDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetVersionsRequest| { &m.page },
            |m: &mut ListDatasetVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetVersionsRequest| { &m.per_page },
            |m: &mut ListDatasetVersionsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "request_origins",
            |m: &ListDatasetVersionsRequest| { &m.request_origins },
            |m: &mut ListDatasetVersionsRequest| { &mut m.request_origins },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetVersionsRequest>(
            "ListDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetVersionsRequest {
    const NAME: &'static str = "ListDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                40 => {
                    self.request_origins.push(is.read_enum_or_unknown()?);
                },
                42 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.request_origins)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        for value in &self.request_origins {
            my_size += ::protobuf::rt::int32_size(5, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        for v in &self.request_origins {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetVersionsRequest {
        ListDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.request_origins.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetVersionsRequest {
        static instance: ListDatasetVersionsRequest = ListDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            request_origins: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetDatasetVersionRequest
// @@protoc_insertion_point(message:clarifai.api.GetDatasetVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetDatasetVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.GetDatasetVersionRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetDatasetVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDatasetVersionRequest {
    fn default() -> &'a GetDatasetVersionRequest {
        <GetDatasetVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatasetVersionRequest {
    pub fn new() -> GetDatasetVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetDatasetVersionRequest| { &m.user_app_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &GetDatasetVersionRequest| { &m.dataset_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &GetDatasetVersionRequest| { &m.dataset_version_id },
            |m: &mut GetDatasetVersionRequest| { &mut m.dataset_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDatasetVersionRequest>(
            "GetDatasetVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDatasetVersionRequest {
    const NAME: &'static str = "GetDatasetVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDatasetVersionRequest {
        GetDatasetVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDatasetVersionRequest {
        static instance: GetDatasetVersionRequest = GetDatasetVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDatasetVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDatasetVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDatasetVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatasetVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListDatasetVersionMetricsGroupsRequest
// @@protoc_insertion_point(message:clarifai.api.ListDatasetVersionMetricsGroupsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListDatasetVersionMetricsGroupsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.per_page)
    pub per_page: u32,
    ///  Filter by parent path. Multiple parent paths are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.parent_paths)
    pub parent_paths: ::std::vec::Vec<::std::string::String>,
    ///  Filter by parent type. Multiple types are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::resources::DatasetVersionMetricsGroupType>>,
    ///  Filter by value. Multiple values are OR-ed. Empty list results in no filter.
    // @@protoc_insertion_point(field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.values)
    pub values: ::std::vec::Vec<::protobuf::well_known_types::struct_::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListDatasetVersionMetricsGroupsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListDatasetVersionMetricsGroupsRequest {
    fn default() -> &'a ListDatasetVersionMetricsGroupsRequest {
        <ListDatasetVersionMetricsGroupsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatasetVersionMetricsGroupsRequest {
    pub fn new() -> ListDatasetVersionMetricsGroupsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.user_app_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.dataset_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.dataset_version_id },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.dataset_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.page },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.per_page },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parent_paths",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.parent_paths },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.parent_paths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.types },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &ListDatasetVersionMetricsGroupsRequest| { &m.values },
            |m: &mut ListDatasetVersionMetricsGroupsRequest| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListDatasetVersionMetricsGroupsRequest>(
            "ListDatasetVersionMetricsGroupsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListDatasetVersionMetricsGroupsRequest {
    const NAME: &'static str = "ListDatasetVersionMetricsGroupsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                50 => {
                    self.parent_paths.push(is.read_string()?);
                },
                56 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                66 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        for value in &self.parent_paths {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.types {
            my_size += ::protobuf::rt::int32_size(7, value.value());
        };
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        for v in &self.parent_paths {
            os.write_string(6, &v)?;
        };
        for v in &self.types {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListDatasetVersionMetricsGroupsRequest {
        ListDatasetVersionMetricsGroupsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.parent_paths.clear();
        self.types.clear();
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListDatasetVersionMetricsGroupsRequest {
        static instance: ListDatasetVersionMetricsGroupsRequest = ListDatasetVersionMetricsGroupsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            parent_paths: ::std::vec::Vec::new(),
            types: ::std::vec::Vec::new(),
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListDatasetVersionMetricsGroupsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListDatasetVersionMetricsGroupsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListDatasetVersionMetricsGroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatasetVersionMetricsGroupsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more dataset versions.
// @@protoc_insertion_point(message:clarifai.api.PostDatasetVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of dataset versions that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostDatasetVersionsRequest.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostDatasetVersionsRequest {
    fn default() -> &'a PostDatasetVersionsRequest {
        <PostDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostDatasetVersionsRequest {
    pub fn new() -> PostDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut PostDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PostDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut PostDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &PostDatasetVersionsRequest| { &m.dataset_versions },
            |m: &mut PostDatasetVersionsRequest| { &mut m.dataset_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostDatasetVersionsRequest>(
            "PostDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostDatasetVersionsRequest {
    const NAME: &'static str = "PostDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostDatasetVersionsRequest {
        PostDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostDatasetVersionsRequest {
        static instance: PostDatasetVersionsRequest = PostDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several dataset versions.
// @@protoc_insertion_point(message:clarifai.api.PatchDatasetVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  List of dataset versions that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    ///  The action to perform on the patched objects
    ///  For now, only 'overwrite' action is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchDatasetVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchDatasetVersionsRequest {
    fn default() -> &'a PatchDatasetVersionsRequest {
        <PatchDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchDatasetVersionsRequest {
    pub fn new() -> PatchDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PatchDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &PatchDatasetVersionsRequest| { &m.dataset_versions },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.dataset_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchDatasetVersionsRequest| { &m.action },
            |m: &mut PatchDatasetVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchDatasetVersionsRequest>(
            "PatchDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchDatasetVersionsRequest {
    const NAME: &'static str = "PatchDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchDatasetVersionsRequest {
        PatchDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchDatasetVersionsRequest {
        static instance: PatchDatasetVersionsRequest = PatchDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several dataset versions by list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteDatasetVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteDatasetVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteDatasetVersionsRequest.dataset_version_ids)
    pub dataset_version_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteDatasetVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteDatasetVersionsRequest {
    fn default() -> &'a DeleteDatasetVersionsRequest {
        <DeleteDatasetVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDatasetVersionsRequest {
    pub fn new() -> DeleteDatasetVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteDatasetVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &DeleteDatasetVersionsRequest| { &m.dataset_id },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_version_ids",
            |m: &DeleteDatasetVersionsRequest| { &m.dataset_version_ids },
            |m: &mut DeleteDatasetVersionsRequest| { &mut m.dataset_version_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteDatasetVersionsRequest>(
            "DeleteDatasetVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteDatasetVersionsRequest {
    const NAME: &'static str = "DeleteDatasetVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        for value in &self.dataset_version_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        for v in &self.dataset_version_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteDatasetVersionsRequest {
        DeleteDatasetVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteDatasetVersionsRequest {
        static instance: DeleteDatasetVersionsRequest = DeleteDatasetVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteDatasetVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteDatasetVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteDatasetVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDatasetVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create exports of a dataset version.
// @@protoc_insertion_point(message:clarifai.api.PutDatasetVersionExportsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutDatasetVersionExportsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify dataset by id.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.dataset_id)
    pub dataset_id: ::std::string::String,
    ///  Identify dataset version by id.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.dataset_version_id)
    pub dataset_version_id: ::std::string::String,
    ///  exports is the list of requested dataset version exports.
    ///  Only setting the 'format' field of the export is supported.
    // @@protoc_insertion_point(field:clarifai.api.PutDatasetVersionExportsRequest.exports)
    pub exports: ::std::vec::Vec<super::resources::DatasetVersionExport>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutDatasetVersionExportsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutDatasetVersionExportsRequest {
    fn default() -> &'a PutDatasetVersionExportsRequest {
        <PutDatasetVersionExportsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutDatasetVersionExportsRequest {
    pub fn new() -> PutDatasetVersionExportsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutDatasetVersionExportsRequest| { &m.user_app_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_id",
            |m: &PutDatasetVersionExportsRequest| { &m.dataset_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.dataset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_version_id",
            |m: &PutDatasetVersionExportsRequest| { &m.dataset_version_id },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.dataset_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &PutDatasetVersionExportsRequest| { &m.exports },
            |m: &mut PutDatasetVersionExportsRequest| { &mut m.exports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutDatasetVersionExportsRequest>(
            "PutDatasetVersionExportsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutDatasetVersionExportsRequest {
    const NAME: &'static str = "PutDatasetVersionExportsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.dataset_id = is.read_string()?;
                },
                26 => {
                    self.dataset_version_id = is.read_string()?;
                },
                34 => {
                    self.exports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dataset_id);
        }
        if !self.dataset_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dataset_version_id);
        }
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.dataset_id.is_empty() {
            os.write_string(2, &self.dataset_id)?;
        }
        if !self.dataset_version_id.is_empty() {
            os.write_string(3, &self.dataset_version_id)?;
        }
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutDatasetVersionExportsRequest {
        PutDatasetVersionExportsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.dataset_id.clear();
        self.dataset_version_id.clear();
        self.exports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutDatasetVersionExportsRequest {
        static instance: PutDatasetVersionExportsRequest = PutDatasetVersionExportsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            dataset_id: ::std::string::String::new(),
            dataset_version_id: ::std::string::String::new(),
            exports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutDatasetVersionExportsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutDatasetVersionExportsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutDatasetVersionExportsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutDatasetVersionExportsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionResponse.dataset_versions)
    pub dataset_versions: ::std::vec::Vec<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionResponse {
    fn default() -> &'a MultiDatasetVersionResponse {
        <MultiDatasetVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionResponse {
    pub fn new() -> MultiDatasetVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionResponse| { &m.status },
            |m: &mut MultiDatasetVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_versions",
            |m: &MultiDatasetVersionResponse| { &m.dataset_versions },
            |m: &mut MultiDatasetVersionResponse| { &mut m.dataset_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionResponse>(
            "MultiDatasetVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionResponse {
    const NAME: &'static str = "MultiDatasetVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionResponse {
        MultiDatasetVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionResponse {
        static instance: MultiDatasetVersionResponse = MultiDatasetVersionResponse {
            status: ::protobuf::MessageField::none(),
            dataset_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionExportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetVersionExportResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionExportResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionExportResponse.exports)
    pub exports: ::std::vec::Vec<super::resources::DatasetVersionExport>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionExportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionExportResponse {
    fn default() -> &'a MultiDatasetVersionExportResponse {
        <MultiDatasetVersionExportResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionExportResponse {
    pub fn new() -> MultiDatasetVersionExportResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionExportResponse| { &m.status },
            |m: &mut MultiDatasetVersionExportResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &MultiDatasetVersionExportResponse| { &m.exports },
            |m: &mut MultiDatasetVersionExportResponse| { &mut m.exports },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionExportResponse>(
            "MultiDatasetVersionExportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionExportResponse {
    const NAME: &'static str = "MultiDatasetVersionExportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.exports.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.exports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.exports {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionExportResponse {
        MultiDatasetVersionExportResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.exports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionExportResponse {
        static instance: MultiDatasetVersionExportResponse = MultiDatasetVersionExportResponse {
            status: ::protobuf::MessageField::none(),
            exports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionExportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionExportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionExportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionExportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiDatasetVersionMetricsGroupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiDatasetVersionMetricsGroupResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.dataset_version_metrics_groups)
    pub dataset_version_metrics_groups: ::std::vec::Vec<super::resources::DatasetVersionMetricsGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiDatasetVersionMetricsGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiDatasetVersionMetricsGroupResponse {
    fn default() -> &'a MultiDatasetVersionMetricsGroupResponse {
        <MultiDatasetVersionMetricsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiDatasetVersionMetricsGroupResponse {
    pub fn new() -> MultiDatasetVersionMetricsGroupResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiDatasetVersionMetricsGroupResponse| { &m.status },
            |m: &mut MultiDatasetVersionMetricsGroupResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dataset_version_metrics_groups",
            |m: &MultiDatasetVersionMetricsGroupResponse| { &m.dataset_version_metrics_groups },
            |m: &mut MultiDatasetVersionMetricsGroupResponse| { &mut m.dataset_version_metrics_groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiDatasetVersionMetricsGroupResponse>(
            "MultiDatasetVersionMetricsGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiDatasetVersionMetricsGroupResponse {
    const NAME: &'static str = "MultiDatasetVersionMetricsGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.dataset_version_metrics_groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dataset_version_metrics_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.dataset_version_metrics_groups {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiDatasetVersionMetricsGroupResponse {
        MultiDatasetVersionMetricsGroupResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_version_metrics_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiDatasetVersionMetricsGroupResponse {
        static instance: MultiDatasetVersionMetricsGroupResponse = MultiDatasetVersionMetricsGroupResponse {
            status: ::protobuf::MessageField::none(),
            dataset_version_metrics_groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiDatasetVersionMetricsGroupResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiDatasetVersionMetricsGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiDatasetVersionMetricsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiDatasetVersionMetricsGroupResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SingleDatasetVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleDatasetVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleDatasetVersionResponse.dataset_version)
    pub dataset_version: ::protobuf::MessageField<super::resources::DatasetVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleDatasetVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleDatasetVersionResponse {
    fn default() -> &'a SingleDatasetVersionResponse {
        <SingleDatasetVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleDatasetVersionResponse {
    pub fn new() -> SingleDatasetVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleDatasetVersionResponse| { &m.status },
            |m: &mut SingleDatasetVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::DatasetVersion>(
            "dataset_version",
            |m: &SingleDatasetVersionResponse| { &m.dataset_version },
            |m: &mut SingleDatasetVersionResponse| { &mut m.dataset_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleDatasetVersionResponse>(
            "SingleDatasetVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleDatasetVersionResponse {
    const NAME: &'static str = "SingleDatasetVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dataset_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dataset_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dataset_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleDatasetVersionResponse {
        SingleDatasetVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.dataset_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleDatasetVersionResponse {
        static instance: SingleDatasetVersionResponse = SingleDatasetVersionResponse {
            status: ::protobuf::MessageField::none(),
            dataset_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleDatasetVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleDatasetVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleDatasetVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDatasetVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// //////////////////////////////////////////////////
///  Model prediction related stuff needs inputs and produces outputs.
/// //////////////////////////////////////////////////
///  Model prediction.
// @@protoc_insertion_point(message:clarifai.api.PostModelOutputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelOutputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  This allows you to specify config options for the model such as
    ///  the language which appear's in the model's output_info.
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    ///  Allow filtering of prediction requests down to specific Nodepools, Deploymetns or Runners
    // @@protoc_insertion_point(field:clarifai.api.PostModelOutputsRequest.runner_selector)
    pub runner_selector: ::protobuf::MessageField<super::resources::RunnerSelector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelOutputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelOutputsRequest {
    fn default() -> &'a PostModelOutputsRequest {
        <PostModelOutputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelOutputsRequest {
    pub fn new() -> PostModelOutputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelOutputsRequest| { &m.user_app_id },
            |m: &mut PostModelOutputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelOutputsRequest| { &m.model_id },
            |m: &mut PostModelOutputsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostModelOutputsRequest| { &m.version_id },
            |m: &mut PostModelOutputsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostModelOutputsRequest| { &m.inputs },
            |m: &mut PostModelOutputsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &PostModelOutputsRequest| { &m.model },
            |m: &mut PostModelOutputsRequest| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::RunnerSelector>(
            "runner_selector",
            |m: &PostModelOutputsRequest| { &m.runner_selector },
            |m: &mut PostModelOutputsRequest| { &mut m.runner_selector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelOutputsRequest>(
            "PostModelOutputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelOutputsRequest {
    const NAME: &'static str = "PostModelOutputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    self.inputs.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.runner_selector)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.runner_selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.runner_selector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelOutputsRequest {
        PostModelOutputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.model.clear();
        self.runner_selector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelOutputsRequest {
        static instance: PostModelOutputsRequest = PostModelOutputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            inputs: ::std::vec::Vec::new(),
            model: ::protobuf::MessageField::none(),
            runner_selector: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelOutputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelOutputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelOutputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelOutputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Listing the inputs that went into training this model.
// @@protoc_insertion_point(message:clarifai.api.ListModelInputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelInputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelInputsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelInputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelInputsRequest {
    fn default() -> &'a ListModelInputsRequest {
        <ListModelInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelInputsRequest {
    pub fn new() -> ListModelInputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelInputsRequest| { &m.user_app_id },
            |m: &mut ListModelInputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelInputsRequest| { &m.model_id },
            |m: &mut ListModelInputsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ListModelInputsRequest| { &m.version_id },
            |m: &mut ListModelInputsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelInputsRequest| { &m.page },
            |m: &mut ListModelInputsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelInputsRequest| { &m.per_page },
            |m: &mut ListModelInputsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelInputsRequest>(
            "ListModelInputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelInputsRequest {
    const NAME: &'static str = "ListModelInputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelInputsRequest {
        ListModelInputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelInputsRequest {
        static instance: ListModelInputsRequest = ListModelInputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelInputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelInputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelInputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetKeyRequest
// @@protoc_insertion_point(message:clarifai.api.GetKeyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetKeyRequest.key_id)
    pub key_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetKeyRequest {
    fn default() -> &'a GetKeyRequest {
        <GetKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetKeyRequest {
    pub fn new() -> GetKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetKeyRequest| { &m.user_app_id },
            |m: &mut GetKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &GetKeyRequest| { &m.key_id },
            |m: &mut GetKeyRequest| { &mut m.key_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetKeyRequest>(
            "GetKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetKeyRequest {
    const NAME: &'static str = "GetKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.key_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetKeyRequest {
        GetKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetKeyRequest {
        static instance: GetKeyRequest = GetKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            key_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListKeysRequest
// @@protoc_insertion_point(message:clarifai.api.ListKeysRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.not_expired)
    pub not_expired: bool,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.ListKeysRequest.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListKeysRequest {
    fn default() -> &'a ListKeysRequest {
        <ListKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysRequest {
    pub fn new() -> ListKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListKeysRequest| { &m.user_app_id },
            |m: &mut ListKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListKeysRequest| { &m.page },
            |m: &mut ListKeysRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListKeysRequest| { &m.per_page },
            |m: &mut ListKeysRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "not_expired",
            |m: &ListKeysRequest| { &m.not_expired },
            |m: &mut ListKeysRequest| { &mut m.not_expired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &ListKeysRequest| { &m.scopes },
            |m: &mut ListKeysRequest| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &ListKeysRequest| { &m.endpoints },
            |m: &mut ListKeysRequest| { &mut m.endpoints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListKeysRequest>(
            "ListKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListKeysRequest {
    const NAME: &'static str = "ListKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.not_expired = is.read_bool()?;
                },
                42 => {
                    self.scopes.push(is.read_string()?);
                },
                50 => {
                    self.endpoints.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.not_expired != false {
            my_size += 1 + 1;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.not_expired != false {
            os.write_bool(4, self.not_expired)?;
        }
        for v in &self.scopes {
            os.write_string(5, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListKeysRequest {
        ListKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.not_expired = false;
        self.scopes.clear();
        self.endpoints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListKeysRequest {
        static instance: ListKeysRequest = ListKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            not_expired: false,
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAppKeysRequest
// @@protoc_insertion_point(message:clarifai.api.ListAppKeysRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAppKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppKeysRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppKeysRequest {
    fn default() -> &'a ListAppKeysRequest {
        <ListAppKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppKeysRequest {
    pub fn new() -> ListAppKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppKeysRequest| { &m.user_app_id },
            |m: &mut ListAppKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppKeysRequest| { &m.page },
            |m: &mut ListAppKeysRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppKeysRequest| { &m.per_page },
            |m: &mut ListAppKeysRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppKeysRequest>(
            "ListAppKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppKeysRequest {
    const NAME: &'static str = "ListAppKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppKeysRequest {
        ListAppKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppKeysRequest {
        static instance: ListAppKeysRequest = ListAppKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostKeysRequest
// @@protoc_insertion_point(message:clarifai.api.PostKeysRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostKeysRequest.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostKeysRequest {
    fn default() -> &'a PostKeysRequest {
        <PostKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKeysRequest {
    pub fn new() -> PostKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostKeysRequest| { &m.user_app_id },
            |m: &mut PostKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &PostKeysRequest| { &m.keys },
            |m: &mut PostKeysRequest| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostKeysRequest>(
            "PostKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostKeysRequest {
    const NAME: &'static str = "PostKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostKeysRequest {
        PostKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostKeysRequest {
        static instance: PostKeysRequest = PostKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteKeyRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteKeyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteKeyRequest.key_id)
    pub key_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteKeyRequest {
    fn default() -> &'a DeleteKeyRequest {
        <DeleteKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteKeyRequest {
    pub fn new() -> DeleteKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteKeyRequest| { &m.user_app_id },
            |m: &mut DeleteKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &DeleteKeyRequest| { &m.key_id },
            |m: &mut DeleteKeyRequest| { &mut m.key_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteKeyRequest>(
            "DeleteKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteKeyRequest {
    const NAME: &'static str = "DeleteKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.key_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteKeyRequest {
        DeleteKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteKeyRequest {
        static instance: DeleteKeyRequest = DeleteKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            key_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchKeysRequest
// @@protoc_insertion_point(message:clarifai.api.PatchKeysRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    ///  The action to perform on the patched objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchKeysRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchKeysRequest {
    fn default() -> &'a PatchKeysRequest {
        <PatchKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchKeysRequest {
    pub fn new() -> PatchKeysRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchKeysRequest| { &m.user_app_id },
            |m: &mut PatchKeysRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &PatchKeysRequest| { &m.keys },
            |m: &mut PatchKeysRequest| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchKeysRequest| { &m.action },
            |m: &mut PatchKeysRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchKeysRequest>(
            "PatchKeysRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchKeysRequest {
    const NAME: &'static str = "PatchKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchKeysRequest {
        PatchKeysRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchKeysRequest {
        static instance: PatchKeysRequest = PatchKeysRequest {
            user_app_id: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchKeysRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchKeysRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchKeysRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleKeyResponse
// @@protoc_insertion_point(message:clarifai.api.SingleKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleKeyResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleKeyResponse.key)
    pub key: ::protobuf::MessageField<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleKeyResponse {
    fn default() -> &'a SingleKeyResponse {
        <SingleKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleKeyResponse {
    pub fn new() -> SingleKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleKeyResponse| { &m.status },
            |m: &mut SingleKeyResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Key>(
            "key",
            |m: &SingleKeyResponse| { &m.key },
            |m: &mut SingleKeyResponse| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleKeyResponse>(
            "SingleKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleKeyResponse {
    const NAME: &'static str = "SingleKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleKeyResponse {
        SingleKeyResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleKeyResponse {
        static instance: SingleKeyResponse = SingleKeyResponse {
            status: ::protobuf::MessageField::none(),
            key: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiKeyResponse
// @@protoc_insertion_point(message:clarifai.api.MultiKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiKeyResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiKeyResponse.keys)
    pub keys: ::std::vec::Vec<super::resources::Key>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiKeyResponse {
    fn default() -> &'a MultiKeyResponse {
        <MultiKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKeyResponse {
    pub fn new() -> MultiKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiKeyResponse| { &m.status },
            |m: &mut MultiKeyResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &MultiKeyResponse| { &m.keys },
            |m: &mut MultiKeyResponse| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiKeyResponse>(
            "MultiKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiKeyResponse {
    const NAME: &'static str = "MultiKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiKeyResponse {
        MultiKeyResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiKeyResponse {
        static instance: MultiKeyResponse = MultiKeyResponse {
            status: ::protobuf::MessageField::none(),
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelRequest
// @@protoc_insertion_point(message:clarifai.api.GetModelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.model_id)
    pub model_id: ::std::string::String,
    ///  This is included so that we can re-use this request for multiple
    ///  rpcs with and without the version_id.
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.language)
    pub language: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.trained_before)
    pub trained_before: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
    // @@protoc_insertion_point(field:clarifai.api.GetModelRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelRequest {
    fn default() -> &'a GetModelRequest {
        <GetModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelRequest {
    pub fn new() -> GetModelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelRequest| { &m.user_app_id },
            |m: &mut GetModelRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelRequest| { &m.model_id },
            |m: &mut GetModelRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelRequest| { &m.version_id },
            |m: &mut GetModelRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "language",
            |m: &GetModelRequest| { &m.language },
            |m: &mut GetModelRequest| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_before",
            |m: &GetModelRequest| { &m.trained_before },
            |m: &mut GetModelRequest| { &mut m.trained_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetModelRequest| { &m.additional_fields },
            |m: &mut GetModelRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelRequest>(
            "GetModelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelRequest {
    const NAME: &'static str = "GetModelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    self.language = is.read_string()?;
                },
                40 => {
                    self.trained_before = is.read_bool()?;
                },
                154 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language);
        }
        if self.trained_before != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(4, &self.language)?;
        }
        if self.trained_before != false {
            os.write_bool(5, self.trained_before)?;
        }
        for v in &self.additional_fields {
            os.write_string(19, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelRequest {
        GetModelRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.language.clear();
        self.trained_before = false;
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelRequest {
        static instance: GetModelRequest = GetModelRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            language: ::std::string::String::new(),
            trained_before: false,
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelsRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars, outputs, presets
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    ///  Filter models by the specific model_type_id. See ListModelTypes for the list of ModelType.Id's
    ///  supported.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    ///  If true, we only return models that have the status MODEL_TRAINED, which includes non-trainable model types.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.trained_only)
    pub trained_only: bool,
    ///  The list of input fields to the model.
    ///  For example, you can specify 'image', which will return models that make inferences on images like visual-classifier models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.input_fields)
    pub input_fields: ::std::vec::Vec<::std::string::String>,
    ///  The list of output fields to the model.
    ///  For example, you can specify 'regions[...].data.concepts', which will return visual-detector models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.output_fields)
    pub output_fields: ::std::vec::Vec<::std::string::String>,
    ///  Filter by the license of the model version
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.license)
    pub license: ::std::string::String,
    ///  If true, we only return models that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return models that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.starred_only)
    pub starred_only: bool,
    ///  List of toolkit tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    ///  List of use_case tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.use_cases)
    pub use_cases: ::std::vec::Vec<::std::string::String>,
    ///  List of language tags to filter by
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    ///  Old API behavior resulted in returning clarifai main models when calling ListModels while scoped to an app. While we transition
    ///  away from that, we can use this flag to not always fetch clarifai main models, unless that is the app we are explicitly listing for.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.dont_fetch_from_main)
    pub dont_fetch_from_main: bool,
    ///  Filter models by bookmark. If set, only return bookmarked models. Otherwise none bookmarked models only.
    ///  Note: you can not filter `trained_only` and bookmark at the same time.
    ///  When filter by bookmark, we will return trained and untrained models.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.bookmark)
    pub bookmark: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the model:
    ///    - id
    ///    - name
    ///    - description
    ///    - notes
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.search)
    pub search: ::std::string::String,
    ///  Query name, description and id fields, that can contain the words in the query string. Does NOT support wildcards - full words only. Supports operators "OR" and "-" as NOT.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the description and id of the model. This supports wildcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.name)
    pub name: ::std::string::String,
    ///  Extends the name filter to include the user_id of the application owner that the model belongs to.
    ///  Deprecated: use search instead of name.
    // @@protoc_insertion_point(field:clarifai.api.ListModelsRequest.filter_by_user_id)
    pub filter_by_user_id: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_models_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelsRequest {
    fn default() -> &'a ListModelsRequest {
        <ListModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelsRequest {
    pub fn new() -> ListModelsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_name = 11;

    pub fn sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByName(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_name(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByName(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_name(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByName(v))
    }

    // bool sort_by_num_inputs = 12;

    pub fn sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_num_inputs(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_num_inputs(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(v))
    }

    // bool sort_by_modified_at = 13;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 24;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 25;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelsRequest| { &m.user_app_id },
            |m: &mut ListModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelsRequest| { &m.page },
            |m: &mut ListModelsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelsRequest| { &m.per_page },
            |m: &mut ListModelsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListModelsRequest| { &m.additional_fields },
            |m: &mut ListModelsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModelsRequest| { &m.sort_ascending },
            |m: &mut ListModelsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_name",
            ListModelsRequest::has_sort_by_name,
            ListModelsRequest::sort_by_name,
            ListModelsRequest::set_sort_by_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_num_inputs",
            ListModelsRequest::has_sort_by_num_inputs,
            ListModelsRequest::sort_by_num_inputs,
            ListModelsRequest::set_sort_by_num_inputs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListModelsRequest::has_sort_by_modified_at,
            ListModelsRequest::sort_by_modified_at,
            ListModelsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModelsRequest::has_sort_by_created_at,
            ListModelsRequest::sort_by_created_at,
            ListModelsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListModelsRequest::has_sort_by_star_count,
            ListModelsRequest::sort_by_star_count,
            ListModelsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &ListModelsRequest| { &m.model_type_id },
            |m: &mut ListModelsRequest| { &mut m.model_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_only",
            |m: &ListModelsRequest| { &m.trained_only },
            |m: &mut ListModelsRequest| { &mut m.trained_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_fields",
            |m: &ListModelsRequest| { &m.input_fields },
            |m: &mut ListModelsRequest| { &mut m.input_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_fields",
            |m: &ListModelsRequest| { &m.output_fields },
            |m: &mut ListModelsRequest| { &mut m.output_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "license",
            |m: &ListModelsRequest| { &m.license },
            |m: &mut ListModelsRequest| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListModelsRequest| { &m.featured_only },
            |m: &mut ListModelsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListModelsRequest| { &m.starred_only },
            |m: &mut ListModelsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &ListModelsRequest| { &m.toolkits },
            |m: &mut ListModelsRequest| { &mut m.toolkits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "use_cases",
            |m: &ListModelsRequest| { &m.use_cases },
            |m: &mut ListModelsRequest| { &mut m.use_cases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &ListModelsRequest| { &m.languages },
            |m: &mut ListModelsRequest| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dont_fetch_from_main",
            |m: &ListModelsRequest| { &m.dont_fetch_from_main },
            |m: &mut ListModelsRequest| { &mut m.dont_fetch_from_main },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListModelsRequest| { &m.bookmark },
            |m: &mut ListModelsRequest| { &mut m.bookmark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListModelsRequest| { &m.search },
            |m: &mut ListModelsRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListModelsRequest| { &m.query },
            |m: &mut ListModelsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListModelsRequest| { &m.name },
            |m: &mut ListModelsRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filter_by_user_id",
            |m: &ListModelsRequest| { &m.filter_by_user_id },
            |m: &mut ListModelsRequest| { &mut m.filter_by_user_id },
        ));
        oneofs.push(list_models_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelsRequest>(
            "ListModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelsRequest {
    const NAME: &'static str = "ListModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                154 => {
                    self.additional_fields.push(is.read_string()?);
                },
                80 => {
                    self.sort_ascending = is.read_bool()?;
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByName(is.read_bool()?));
                },
                96 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByNumInputs(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                192 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                200 => {
                    self.sort_by = ::std::option::Option::Some(list_models_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                50 => {
                    self.model_type_id = is.read_string()?;
                },
                56 => {
                    self.trained_only = is.read_bool()?;
                },
                66 => {
                    self.input_fields.push(is.read_string()?);
                },
                74 => {
                    self.output_fields.push(is.read_string()?);
                },
                122 => {
                    self.license = is.read_string()?;
                },
                128 => {
                    self.featured_only = is.read_bool()?;
                },
                160 => {
                    self.starred_only = is.read_bool()?;
                },
                138 => {
                    self.toolkits.push(is.read_string()?);
                },
                146 => {
                    self.use_cases.push(is.read_string()?);
                },
                170 => {
                    self.languages.push(is.read_string()?);
                },
                184 => {
                    self.dont_fetch_from_main = is.read_bool()?;
                },
                208 => {
                    self.bookmark = is.read_bool()?;
                },
                218 => {
                    self.search = is.read_string()?;
                },
                114 => {
                    self.query = is.read_string()?;
                },
                42 => {
                    self.name = is.read_string()?;
                },
                176 => {
                    self.filter_by_user_id = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model_type_id);
        }
        if self.trained_only != false {
            my_size += 1 + 1;
        }
        for value in &self.input_fields {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.output_fields {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.license);
        }
        if self.featured_only != false {
            my_size += 2 + 1;
        }
        if self.starred_only != false {
            my_size += 2 + 1;
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.use_cases {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        if self.dont_fetch_from_main != false {
            my_size += 2 + 1;
        }
        if self.bookmark != false {
            my_size += 2 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.search);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.query);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if self.filter_by_user_id != false {
            my_size += 2 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_models_request::Sort_by::SortByName(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByNumInputs(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_models_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 2 + 1;
                },
                &list_models_request::Sort_by::SortByStarCount(v) => {
                    my_size += 2 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(19, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(10, self.sort_ascending)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(6, &self.model_type_id)?;
        }
        if self.trained_only != false {
            os.write_bool(7, self.trained_only)?;
        }
        for v in &self.input_fields {
            os.write_string(8, &v)?;
        };
        for v in &self.output_fields {
            os.write_string(9, &v)?;
        };
        if !self.license.is_empty() {
            os.write_string(15, &self.license)?;
        }
        if self.featured_only != false {
            os.write_bool(16, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(20, self.starred_only)?;
        }
        for v in &self.toolkits {
            os.write_string(17, &v)?;
        };
        for v in &self.use_cases {
            os.write_string(18, &v)?;
        };
        for v in &self.languages {
            os.write_string(21, &v)?;
        };
        if self.dont_fetch_from_main != false {
            os.write_bool(23, self.dont_fetch_from_main)?;
        }
        if self.bookmark != false {
            os.write_bool(26, self.bookmark)?;
        }
        if !self.search.is_empty() {
            os.write_string(27, &self.search)?;
        }
        if !self.query.is_empty() {
            os.write_string(14, &self.query)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if self.filter_by_user_id != false {
            os.write_bool(22, self.filter_by_user_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_models_request::Sort_by::SortByName(v) => {
                    os.write_bool(11, v)?;
                },
                &list_models_request::Sort_by::SortByNumInputs(v) => {
                    os.write_bool(12, v)?;
                },
                &list_models_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(13, v)?;
                },
                &list_models_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(24, v)?;
                },
                &list_models_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(25, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelsRequest {
        ListModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.model_type_id.clear();
        self.trained_only = false;
        self.input_fields.clear();
        self.output_fields.clear();
        self.license.clear();
        self.featured_only = false;
        self.starred_only = false;
        self.toolkits.clear();
        self.use_cases.clear();
        self.languages.clear();
        self.dont_fetch_from_main = false;
        self.bookmark = false;
        self.search.clear();
        self.query.clear();
        self.name.clear();
        self.filter_by_user_id = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelsRequest {
        static instance: ListModelsRequest = ListModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            model_type_id: ::std::string::String::new(),
            trained_only: false,
            input_fields: ::std::vec::Vec::new(),
            output_fields: ::std::vec::Vec::new(),
            license: ::std::string::String::new(),
            featured_only: false,
            starred_only: false,
            toolkits: ::std::vec::Vec::new(),
            use_cases: ::std::vec::Vec::new(),
            languages: ::std::vec::Vec::new(),
            dont_fetch_from_main: false,
            bookmark: false,
            search: ::std::string::String::new(),
            query: ::std::string::String::new(),
            name: ::std::string::String::new(),
            filter_by_user_id: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModelsRequest`
pub mod list_models_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModelsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_name)
        SortByName(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_num_inputs)
        SortByNumInputs(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModelsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  ResourceCountRequest
// @@protoc_insertion_point(message:clarifai.api.GetResourceCountsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetResourceCountsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetResourceCountsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetResourceCountsRequest {
    fn default() -> &'a GetResourceCountsRequest {
        <GetResourceCountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetResourceCountsRequest {
    pub fn new() -> GetResourceCountsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetResourceCountsRequest| { &m.user_app_id },
            |m: &mut GetResourceCountsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetResourceCountsRequest>(
            "GetResourceCountsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetResourceCountsRequest {
    const NAME: &'static str = "GetResourceCountsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetResourceCountsRequest {
        GetResourceCountsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetResourceCountsRequest {
        static instance: GetResourceCountsRequest = GetResourceCountsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetResourceCountsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetResourceCountsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetResourceCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResourceCountsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ResourceCountResponse
// @@protoc_insertion_point(message:clarifai.api.GetResourceCountsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetResourceCountsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.datasets)
    pub datasets: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.models)
    pub models: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.workflows)
    pub workflows: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.modules)
    pub modules: i64,
    // @@protoc_insertion_point(field:clarifai.api.GetResourceCountsResponse.inputs)
    pub inputs: i64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetResourceCountsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetResourceCountsResponse {
    fn default() -> &'a GetResourceCountsResponse {
        <GetResourceCountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetResourceCountsResponse {
    pub fn new() -> GetResourceCountsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &GetResourceCountsResponse| { &m.status },
            |m: &mut GetResourceCountsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "datasets",
            |m: &GetResourceCountsResponse| { &m.datasets },
            |m: &mut GetResourceCountsResponse| { &mut m.datasets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "models",
            |m: &GetResourceCountsResponse| { &m.models },
            |m: &mut GetResourceCountsResponse| { &mut m.models },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflows",
            |m: &GetResourceCountsResponse| { &m.workflows },
            |m: &mut GetResourceCountsResponse| { &mut m.workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "modules",
            |m: &GetResourceCountsResponse| { &m.modules },
            |m: &mut GetResourceCountsResponse| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs",
            |m: &GetResourceCountsResponse| { &m.inputs },
            |m: &mut GetResourceCountsResponse| { &mut m.inputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetResourceCountsResponse>(
            "GetResourceCountsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetResourceCountsResponse {
    const NAME: &'static str = "GetResourceCountsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                16 => {
                    self.datasets = is.read_int64()?;
                },
                24 => {
                    self.models = is.read_int64()?;
                },
                32 => {
                    self.workflows = is.read_int64()?;
                },
                40 => {
                    self.modules = is.read_int64()?;
                },
                48 => {
                    self.inputs = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.datasets != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.datasets);
        }
        if self.models != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.models);
        }
        if self.workflows != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.workflows);
        }
        if self.modules != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.modules);
        }
        if self.inputs != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.inputs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.datasets != 0 {
            os.write_int64(2, self.datasets)?;
        }
        if self.models != 0 {
            os.write_int64(3, self.models)?;
        }
        if self.workflows != 0 {
            os.write_int64(4, self.workflows)?;
        }
        if self.modules != 0 {
            os.write_int64(5, self.modules)?;
        }
        if self.inputs != 0 {
            os.write_int64(6, self.inputs)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetResourceCountsResponse {
        GetResourceCountsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.datasets = 0;
        self.models = 0;
        self.workflows = 0;
        self.modules = 0;
        self.inputs = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetResourceCountsResponse {
        static instance: GetResourceCountsResponse = GetResourceCountsResponse {
            status: ::protobuf::MessageField::none(),
            datasets: 0,
            models: 0,
            workflows: 0,
            modules: 0,
            inputs: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetResourceCountsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetResourceCountsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetResourceCountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResourceCountsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchModelToolkitsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelToolkitsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelToolkitsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelToolkitsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelToolkitsRequest {
    fn default() -> &'a PatchModelToolkitsRequest {
        <PatchModelToolkitsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelToolkitsRequest {
    pub fn new() -> PatchModelToolkitsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelToolkitsRequest| { &m.user_app_id },
            |m: &mut PatchModelToolkitsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelToolkitsRequest| { &m.model_id },
            |m: &mut PatchModelToolkitsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &PatchModelToolkitsRequest| { &m.toolkits },
            |m: &mut PatchModelToolkitsRequest| { &mut m.toolkits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelToolkitsRequest| { &m.action },
            |m: &mut PatchModelToolkitsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelToolkitsRequest>(
            "PatchModelToolkitsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelToolkitsRequest {
    const NAME: &'static str = "PatchModelToolkitsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.toolkits.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.toolkits {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelToolkitsRequest {
        PatchModelToolkitsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.toolkits.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelToolkitsRequest {
        static instance: PatchModelToolkitsRequest = PatchModelToolkitsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            toolkits: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelToolkitsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelToolkitsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelToolkitsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelToolkitsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelCheckConsentsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModelCheckConsentsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelCheckConsentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the model id
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  the consents
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.check_consents)
    pub check_consents: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelCheckConsentsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelCheckConsentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelCheckConsentsRequest {
    fn default() -> &'a PatchModelCheckConsentsRequest {
        <PatchModelCheckConsentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelCheckConsentsRequest {
    pub fn new() -> PatchModelCheckConsentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelCheckConsentsRequest| { &m.user_app_id },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelCheckConsentsRequest| { &m.model_id },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "check_consents",
            |m: &PatchModelCheckConsentsRequest| { &m.check_consents },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.check_consents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelCheckConsentsRequest| { &m.action },
            |m: &mut PatchModelCheckConsentsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelCheckConsentsRequest>(
            "PatchModelCheckConsentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelCheckConsentsRequest {
    const NAME: &'static str = "PatchModelCheckConsentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.check_consents.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.check_consents {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.check_consents {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelCheckConsentsRequest {
        PatchModelCheckConsentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.check_consents.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelCheckConsentsRequest {
        static instance: PatchModelCheckConsentsRequest = PatchModelCheckConsentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            check_consents: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelCheckConsentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelCheckConsentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelCheckConsentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelCheckConsentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchModelUseCasesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelUseCasesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.usecases)
    pub usecases: ::std::vec::Vec<::std::string::String>,
    /// overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelUseCasesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelUseCasesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelUseCasesRequest {
    fn default() -> &'a PatchModelUseCasesRequest {
        <PatchModelUseCasesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelUseCasesRequest {
    pub fn new() -> PatchModelUseCasesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelUseCasesRequest| { &m.user_app_id },
            |m: &mut PatchModelUseCasesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelUseCasesRequest| { &m.model_id },
            |m: &mut PatchModelUseCasesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "usecases",
            |m: &PatchModelUseCasesRequest| { &m.usecases },
            |m: &mut PatchModelUseCasesRequest| { &mut m.usecases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelUseCasesRequest| { &m.action },
            |m: &mut PatchModelUseCasesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelUseCasesRequest>(
            "PatchModelUseCasesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelUseCasesRequest {
    const NAME: &'static str = "PatchModelUseCasesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.usecases.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.usecases {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.usecases {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelUseCasesRequest {
        PatchModelUseCasesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.usecases.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelUseCasesRequest {
        static instance: PatchModelUseCasesRequest = PatchModelUseCasesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            usecases: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelUseCasesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelUseCasesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelUseCasesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelUseCasesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchModelLanguagesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelLanguagesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    ///  Only overwrite supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelLanguagesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelLanguagesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelLanguagesRequest {
    fn default() -> &'a PatchModelLanguagesRequest {
        <PatchModelLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelLanguagesRequest {
    pub fn new() -> PatchModelLanguagesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelLanguagesRequest| { &m.user_app_id },
            |m: &mut PatchModelLanguagesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelLanguagesRequest| { &m.model_id },
            |m: &mut PatchModelLanguagesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &PatchModelLanguagesRequest| { &m.languages },
            |m: &mut PatchModelLanguagesRequest| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelLanguagesRequest| { &m.action },
            |m: &mut PatchModelLanguagesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelLanguagesRequest>(
            "PatchModelLanguagesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelLanguagesRequest {
    const NAME: &'static str = "PatchModelLanguagesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.languages.push(is.read_string()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.languages {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelLanguagesRequest {
        PatchModelLanguagesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.languages.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelLanguagesRequest {
        static instance: PatchModelLanguagesRequest = PatchModelLanguagesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            languages: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelLanguagesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelLanguagesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelLanguagesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiModelToolkitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelToolkitResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelToolkitResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelToolkitResponse.toolkits)
    pub toolkits: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelToolkitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelToolkitResponse {
    fn default() -> &'a MultiModelToolkitResponse {
        <MultiModelToolkitResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelToolkitResponse {
    pub fn new() -> MultiModelToolkitResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelToolkitResponse| { &m.status },
            |m: &mut MultiModelToolkitResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "toolkits",
            |m: &MultiModelToolkitResponse| { &m.toolkits },
            |m: &mut MultiModelToolkitResponse| { &mut m.toolkits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelToolkitResponse>(
            "MultiModelToolkitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelToolkitResponse {
    const NAME: &'static str = "MultiModelToolkitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.toolkits.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.toolkits {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelToolkitResponse {
        MultiModelToolkitResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.toolkits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelToolkitResponse {
        static instance: MultiModelToolkitResponse = MultiModelToolkitResponse {
            status: ::protobuf::MessageField::none(),
            toolkits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelToolkitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelToolkitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelToolkitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelToolkitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiModelCheckConsentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelCheckConsentResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelCheckConsentResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelCheckConsentResponse.check_consents)
    pub check_consents: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelCheckConsentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelCheckConsentResponse {
    fn default() -> &'a MultiModelCheckConsentResponse {
        <MultiModelCheckConsentResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelCheckConsentResponse {
    pub fn new() -> MultiModelCheckConsentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelCheckConsentResponse| { &m.status },
            |m: &mut MultiModelCheckConsentResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "check_consents",
            |m: &MultiModelCheckConsentResponse| { &m.check_consents },
            |m: &mut MultiModelCheckConsentResponse| { &mut m.check_consents },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelCheckConsentResponse>(
            "MultiModelCheckConsentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelCheckConsentResponse {
    const NAME: &'static str = "MultiModelCheckConsentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.check_consents.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.check_consents {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.check_consents {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelCheckConsentResponse {
        MultiModelCheckConsentResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.check_consents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelCheckConsentResponse {
        static instance: MultiModelCheckConsentResponse = MultiModelCheckConsentResponse {
            status: ::protobuf::MessageField::none(),
            check_consents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelCheckConsentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelCheckConsentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelCheckConsentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelCheckConsentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiModelUseCaseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelUseCaseResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelUseCaseResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelUseCaseResponse.usecases)
    pub usecases: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelUseCaseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelUseCaseResponse {
    fn default() -> &'a MultiModelUseCaseResponse {
        <MultiModelUseCaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelUseCaseResponse {
    pub fn new() -> MultiModelUseCaseResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelUseCaseResponse| { &m.status },
            |m: &mut MultiModelUseCaseResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "usecases",
            |m: &MultiModelUseCaseResponse| { &m.usecases },
            |m: &mut MultiModelUseCaseResponse| { &mut m.usecases },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelUseCaseResponse>(
            "MultiModelUseCaseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelUseCaseResponse {
    const NAME: &'static str = "MultiModelUseCaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.usecases.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.usecases {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.usecases {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelUseCaseResponse {
        MultiModelUseCaseResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.usecases.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelUseCaseResponse {
        static instance: MultiModelUseCaseResponse = MultiModelUseCaseResponse {
            status: ::protobuf::MessageField::none(),
            usecases: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelUseCaseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelUseCaseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelUseCaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelUseCaseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiModelLanguageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelLanguageResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelLanguageResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelLanguageResponse.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelLanguageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelLanguageResponse {
    fn default() -> &'a MultiModelLanguageResponse {
        <MultiModelLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelLanguageResponse {
    pub fn new() -> MultiModelLanguageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelLanguageResponse| { &m.status },
            |m: &mut MultiModelLanguageResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &MultiModelLanguageResponse| { &m.languages },
            |m: &mut MultiModelLanguageResponse| { &mut m.languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelLanguageResponse>(
            "MultiModelLanguageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelLanguageResponse {
    const NAME: &'static str = "MultiModelLanguageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.languages.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.languages {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelLanguageResponse {
        MultiModelLanguageResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelLanguageResponse {
        static instance: MultiModelLanguageResponse = MultiModelLanguageResponse {
            status: ::protobuf::MessageField::none(),
            languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelLanguageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelLanguageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelLanguageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelsRequest
// @@protoc_insertion_point(message:clarifai.api.PostModelsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  NOTE: inconsistent since "model" is not plural, please use "models" below.
    ///  Previously you could only create one model at a time.
    ///  We still support this but you should pass it as models=[model] so
    ///  that this endpoint is consistent with the rest of our API.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    ///  This allows you to create one or more model by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsRequest.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelsRequest {
    fn default() -> &'a PostModelsRequest {
        <PostModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsRequest {
    pub fn new() -> PostModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelsRequest| { &m.user_app_id },
            |m: &mut PostModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &PostModelsRequest| { &m.model },
            |m: &mut PostModelsRequest| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &PostModelsRequest| { &m.models },
            |m: &mut PostModelsRequest| { &mut m.models },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelsRequest>(
            "PostModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelsRequest {
    const NAME: &'static str = "PostModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                26 => {
                    self.models.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelsRequest {
        PostModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model.clear();
        self.models.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelsRequest {
        static instance: PostModelsRequest = PostModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModelsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    ///
    ///  Note that 'remove' can be used to remove the model image by setting
    ///  'image.url' in the request to the current value returned for that model.
    ///  This cannot be used in a request that is patching other fields as well.
    // @@protoc_insertion_point(field:clarifai.api.PatchModelsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelsRequest {
    fn default() -> &'a PatchModelsRequest {
        <PatchModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelsRequest {
    pub fn new() -> PatchModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelsRequest| { &m.user_app_id },
            |m: &mut PatchModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &PatchModelsRequest| { &m.models },
            |m: &mut PatchModelsRequest| { &mut m.models },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelsRequest| { &m.action },
            |m: &mut PatchModelsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelsRequest>(
            "PatchModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelsRequest {
    const NAME: &'static str = "PatchModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.models.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelsRequest {
        PatchModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.models.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelsRequest {
        static instance: PatchModelsRequest = PatchModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.IdUpdateSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IdUpdateSource {
    // message fields
    /// old id
    // @@protoc_insertion_point(field:clarifai.api.IdUpdateSource.id)
    pub id: ::std::string::String,
    /// new id
    // @@protoc_insertion_point(field:clarifai.api.IdUpdateSource.new_id)
    pub new_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.IdUpdateSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IdUpdateSource {
    fn default() -> &'a IdUpdateSource {
        <IdUpdateSource as ::protobuf::Message>::default_instance()
    }
}

impl IdUpdateSource {
    pub fn new() -> IdUpdateSource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &IdUpdateSource| { &m.id },
            |m: &mut IdUpdateSource| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_id",
            |m: &IdUpdateSource| { &m.new_id },
            |m: &mut IdUpdateSource| { &mut m.new_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdUpdateSource>(
            "IdUpdateSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IdUpdateSource {
    const NAME: &'static str = "IdUpdateSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.new_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.new_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.new_id.is_empty() {
            os.write_string(2, &self.new_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IdUpdateSource {
        IdUpdateSource::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.new_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IdUpdateSource {
        static instance: IdUpdateSource = IdUpdateSource {
            id: ::std::string::String::new(),
            new_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IdUpdateSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IdUpdateSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IdUpdateSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdUpdateSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelIdsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModelIdsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelIdsRequest {
    fn default() -> &'a PatchModelIdsRequest {
        <PatchModelIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelIdsRequest {
    pub fn new() -> PatchModelIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelIdsRequest| { &m.user_app_id },
            |m: &mut PatchModelIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchModelIdsRequest| { &m.ids },
            |m: &mut PatchModelIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelIdsRequest| { &m.action },
            |m: &mut PatchModelIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelIdsRequest>(
            "PatchModelIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelIdsRequest {
    const NAME: &'static str = "PatchModelIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelIdsRequest {
        PatchModelIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelIdsRequest {
        static instance: PatchModelIdsRequest = PatchModelIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteModelRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteModelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModelRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelRequest.model_id)
    pub model_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelRequest {
    fn default() -> &'a DeleteModelRequest {
        <DeleteModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelRequest {
    pub fn new() -> DeleteModelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelRequest| { &m.user_app_id },
            |m: &mut DeleteModelRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &DeleteModelRequest| { &m.model_id },
            |m: &mut DeleteModelRequest| { &mut m.model_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelRequest>(
            "DeleteModelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelRequest {
    const NAME: &'static str = "DeleteModelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelRequest {
        DeleteModelRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelRequest {
        static instance: DeleteModelRequest = DeleteModelRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteModelsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModelsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelsRequest {
    fn default() -> &'a DeleteModelsRequest {
        <DeleteModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelsRequest {
    pub fn new() -> DeleteModelsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelsRequest| { &m.user_app_id },
            |m: &mut DeleteModelsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModelsRequest| { &m.ids },
            |m: &mut DeleteModelsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteModelsRequest| { &m.delete_all },
            |m: &mut DeleteModelsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelsRequest>(
            "DeleteModelsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelsRequest {
    const NAME: &'static str = "DeleteModelsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelsRequest {
        DeleteModelsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelsRequest {
        static instance: DeleteModelsRequest = DeleteModelsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Search over the available models.
// @@protoc_insertion_point(message:clarifai.api.PostModelsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelsSearchesRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The body of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.model_query)
    pub model_query: ::protobuf::MessageField<super::resources::ModelQuery>,
    ///  Pagination parameters here since there are no url args in this
    ///  POST request.
    // @@protoc_insertion_point(field:clarifai.api.PostModelsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelsSearchesRequest {
    fn default() -> &'a PostModelsSearchesRequest {
        <PostModelsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsSearchesRequest {
    pub fn new() -> PostModelsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelsSearchesRequest| { &m.user_app_id },
            |m: &mut PostModelsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelQuery>(
            "model_query",
            |m: &PostModelsSearchesRequest| { &m.model_query },
            |m: &mut PostModelsSearchesRequest| { &mut m.model_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostModelsSearchesRequest| { &m.pagination },
            |m: &mut PostModelsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelsSearchesRequest>(
            "PostModelsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelsSearchesRequest {
    const NAME: &'static str = "PostModelsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_query)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelsSearchesRequest {
        PostModelsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_query.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelsSearchesRequest {
        static instance: PostModelsSearchesRequest = PostModelsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_query: ::protobuf::MessageField::none(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModelResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModelResponse.model)
    pub model: ::protobuf::MessageField<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelResponse {
    fn default() -> &'a SingleModelResponse {
        <SingleModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelResponse {
    pub fn new() -> SingleModelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelResponse| { &m.status },
            |m: &mut SingleModelResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Model>(
            "model",
            |m: &SingleModelResponse| { &m.model },
            |m: &mut SingleModelResponse| { &mut m.model },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelResponse>(
            "SingleModelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelResponse {
    const NAME: &'static str = "SingleModelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelResponse {
        SingleModelResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelResponse {
        static instance: SingleModelResponse = SingleModelResponse {
            status: ::protobuf::MessageField::none(),
            model: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelResponse.models)
    pub models: ::std::vec::Vec<super::resources::Model>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelResponse {
    fn default() -> &'a MultiModelResponse {
        <MultiModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelResponse {
    pub fn new() -> MultiModelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelResponse| { &m.status },
            |m: &mut MultiModelResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "models",
            |m: &MultiModelResponse| { &m.models },
            |m: &mut MultiModelResponse| { &mut m.models },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelResponse>(
            "MultiModelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelResponse {
    const NAME: &'static str = "MultiModelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.models.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.models {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelResponse {
        MultiModelResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.models.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelResponse {
        static instance: MultiModelResponse = MultiModelResponse {
            status: ::protobuf::MessageField::none(),
            models: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModelVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModelVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModelVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModelVersionsRequest {
    fn default() -> &'a PatchModelVersionsRequest {
        <PatchModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelVersionsRequest {
    pub fn new() -> PatchModelVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModelVersionsRequest| { &m.user_app_id },
            |m: &mut PatchModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PatchModelVersionsRequest| { &m.model_id },
            |m: &mut PatchModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &PatchModelVersionsRequest| { &m.model_versions },
            |m: &mut PatchModelVersionsRequest| { &mut m.model_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModelVersionsRequest| { &m.action },
            |m: &mut PatchModelVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModelVersionsRequest>(
            "PatchModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModelVersionsRequest {
    const NAME: &'static str = "PatchModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModelVersionsRequest {
        PatchModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModelVersionsRequest {
        static instance: PatchModelVersionsRequest = PatchModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  request for different endpoints currently.
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionRequest {
    fn default() -> &'a GetModelVersionRequest {
        <GetModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionRequest {
    pub fn new() -> GetModelVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionRequest| { &m.user_app_id },
            |m: &mut GetModelVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionRequest| { &m.model_id },
            |m: &mut GetModelVersionRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelVersionRequest| { &m.version_id },
            |m: &mut GetModelVersionRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionRequest>(
            "GetModelVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionRequest {
    const NAME: &'static str = "GetModelVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionRequest {
        GetModelVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionRequest {
        static instance: GetModelVersionRequest = GetModelVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.per_page)
    pub per_page: u32,
    ///  Filtering options:
    ///  To list only the model versions that have these concept ids present in them.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    ///  To list only the model versions that have been trained.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.trained_only)
    pub trained_only: bool,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionsRequest.sort_ascending)
    pub sort_ascending: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_model_versions_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionsRequest {
    fn default() -> &'a ListModelVersionsRequest {
        <ListModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionsRequest {
    pub fn new() -> ListModelVersionsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_status_code = 8;

    pub fn sort_by_status_code(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_status_code(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_status_code(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_status_code(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(v))
    }

    // bool sort_by_num_inputs = 9;

    pub fn sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_num_inputs(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_num_inputs(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(v))
    }

    // bool sort_by_description = 10;

    pub fn sort_by_description(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_description(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_description(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_description(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(v))
    }

    // bool sort_by_created_at = 11;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionsRequest| { &m.user_app_id },
            |m: &mut ListModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionsRequest| { &m.model_id },
            |m: &mut ListModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionsRequest| { &m.page },
            |m: &mut ListModelVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionsRequest| { &m.per_page },
            |m: &mut ListModelVersionsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &ListModelVersionsRequest| { &m.concept_ids },
            |m: &mut ListModelVersionsRequest| { &mut m.concept_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trained_only",
            |m: &ListModelVersionsRequest| { &m.trained_only },
            |m: &mut ListModelVersionsRequest| { &mut m.trained_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModelVersionsRequest| { &m.sort_ascending },
            |m: &mut ListModelVersionsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_status_code",
            ListModelVersionsRequest::has_sort_by_status_code,
            ListModelVersionsRequest::sort_by_status_code,
            ListModelVersionsRequest::set_sort_by_status_code,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_num_inputs",
            ListModelVersionsRequest::has_sort_by_num_inputs,
            ListModelVersionsRequest::sort_by_num_inputs,
            ListModelVersionsRequest::set_sort_by_num_inputs,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_description",
            ListModelVersionsRequest::has_sort_by_description,
            ListModelVersionsRequest::sort_by_description,
            ListModelVersionsRequest::set_sort_by_description,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModelVersionsRequest::has_sort_by_created_at,
            ListModelVersionsRequest::sort_by_created_at,
            ListModelVersionsRequest::set_sort_by_created_at,
        ));
        oneofs.push(list_model_versions_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionsRequest>(
            "ListModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionsRequest {
    const NAME: &'static str = "ListModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    self.concept_ids.push(is.read_string()?);
                },
                48 => {
                    self.trained_only = is.read_bool()?;
                },
                56 => {
                    self.sort_ascending = is.read_bool()?;
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByStatusCode(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByNumInputs(is.read_bool()?));
                },
                80 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByDescription(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_model_versions_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.trained_only != false {
            my_size += 1 + 1;
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_model_versions_request::Sort_by::SortByStatusCode(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByNumInputs(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByDescription(v) => {
                    my_size += 1 + 1;
                },
                &list_model_versions_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        for v in &self.concept_ids {
            os.write_string(5, &v)?;
        };
        if self.trained_only != false {
            os.write_bool(6, self.trained_only)?;
        }
        if self.sort_ascending != false {
            os.write_bool(7, self.sort_ascending)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_model_versions_request::Sort_by::SortByStatusCode(v) => {
                    os.write_bool(8, v)?;
                },
                &list_model_versions_request::Sort_by::SortByNumInputs(v) => {
                    os.write_bool(9, v)?;
                },
                &list_model_versions_request::Sort_by::SortByDescription(v) => {
                    os.write_bool(10, v)?;
                },
                &list_model_versions_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionsRequest {
        ListModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.concept_ids.clear();
        self.trained_only = false;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionsRequest {
        static instance: ListModelVersionsRequest = ListModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            concept_ids: ::std::vec::Vec::new(),
            trained_only: false,
            sort_ascending: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModelVersionsRequest`
pub mod list_model_versions_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModelVersionsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_status_code)
        SortByStatusCode(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_num_inputs)
        SortByNumInputs(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_description)
        SortByDescription(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModelVersionsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModelVersionsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  DeleteModelVersionRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteModelVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModelVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModelVersionRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModelVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModelVersionRequest {
    fn default() -> &'a DeleteModelVersionRequest {
        <DeleteModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelVersionRequest {
    pub fn new() -> DeleteModelVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModelVersionRequest| { &m.user_app_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &DeleteModelVersionRequest| { &m.model_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &DeleteModelVersionRequest| { &m.version_id },
            |m: &mut DeleteModelVersionRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModelVersionRequest>(
            "DeleteModelVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModelVersionRequest {
    const NAME: &'static str = "DeleteModelVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.model_id = is.read_string()?;
                },
                34 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(3, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(4, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModelVersionRequest {
        DeleteModelVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModelVersionRequest {
        static instance: DeleteModelVersionRequest = DeleteModelVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModelVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModelVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelVersionResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionResponse.model_version)
    pub model_version: ::protobuf::MessageField<super::resources::ModelVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionResponse {
    fn default() -> &'a SingleModelVersionResponse {
        <SingleModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionResponse {
    pub fn new() -> SingleModelVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelVersionResponse| { &m.status },
            |m: &mut SingleModelVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelVersion>(
            "model_version",
            |m: &SingleModelVersionResponse| { &m.model_version },
            |m: &mut SingleModelVersionResponse| { &mut m.model_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelVersionResponse>(
            "SingleModelVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelVersionResponse {
    const NAME: &'static str = "SingleModelVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelVersionResponse {
        SingleModelVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelVersionResponse {
        static instance: SingleModelVersionResponse = SingleModelVersionResponse {
            status: ::protobuf::MessageField::none(),
            model_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelVersionResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionResponse.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionResponse {
    fn default() -> &'a MultiModelVersionResponse {
        <MultiModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionResponse {
    pub fn new() -> MultiModelVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelVersionResponse| { &m.status },
            |m: &mut MultiModelVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &MultiModelVersionResponse| { &m.model_versions },
            |m: &mut MultiModelVersionResponse| { &mut m.model_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelVersionResponse>(
            "MultiModelVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelVersionResponse {
    const NAME: &'static str = "MultiModelVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelVersionResponse {
        MultiModelVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelVersionResponse {
        static instance: MultiModelVersionResponse = MultiModelVersionResponse {
            status: ::protobuf::MessageField::none(),
            model_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Create (train) a new model version.
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    ///  Description about this training run
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.description)
    pub description: ::std::string::String,
    ///  When evaluate_after_training set to true, we will do evaluation immediately after training finishes.
    ///  We will merge this with default_eval_info.
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsRequest.eval_info)
    pub eval_info: ::protobuf::MessageField<super::resources::EvalInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsRequest {
    fn default() -> &'a PostModelVersionsRequest {
        <PostModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsRequest {
    pub fn new() -> PostModelVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsRequest| { &m.model_id },
            |m: &mut PostModelVersionsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &PostModelVersionsRequest| { &m.model_versions },
            |m: &mut PostModelVersionsRequest| { &mut m.model_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &PostModelVersionsRequest| { &m.description },
            |m: &mut PostModelVersionsRequest| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalInfo>(
            "eval_info",
            |m: &PostModelVersionsRequest| { &m.eval_info },
            |m: &mut PostModelVersionsRequest| { &mut m.eval_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsRequest>(
            "PostModelVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsRequest {
    const NAME: &'static str = "PostModelVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_versions.push(is.read_message()?);
                },
                66 => {
                    self.description = is.read_string()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.description);
        }
        if let Some(v) = self.eval_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.description.is_empty() {
            os.write_string(8, &self.description)?;
        }
        if let Some(v) = self.eval_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsRequest {
        PostModelVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.description.clear();
        self.eval_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsRequest {
        static instance: PostModelVersionsRequest = PostModelVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_versions: ::std::vec::Vec::new(),
            description: ::std::string::String::new(),
            eval_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsUploadRequest {
    // message oneof groups
    pub upload_data: ::std::option::Option<post_model_versions_upload_request::Upload_data>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsUploadRequest {
    fn default() -> &'a PostModelVersionsUploadRequest {
        <PostModelVersionsUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsUploadRequest {
    pub fn new() -> PostModelVersionsUploadRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.PostModelVersionsUploadConfig upload_config = 1;

    pub fn upload_config(&self) -> &PostModelVersionsUploadConfig {
        match self.upload_data {
            ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::UploadConfig(ref v)) => v,
            _ => <PostModelVersionsUploadConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_upload_config(&mut self) {
        self.upload_data = ::std::option::Option::None;
    }

    pub fn has_upload_config(&self) -> bool {
        match self.upload_data {
            ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::UploadConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_upload_config(&mut self, v: PostModelVersionsUploadConfig) {
        self.upload_data = ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::UploadConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_upload_config(&mut self) -> &mut PostModelVersionsUploadConfig {
        if let ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::UploadConfig(_)) = self.upload_data {
        } else {
            self.upload_data = ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::UploadConfig(PostModelVersionsUploadConfig::new()));
        }
        match self.upload_data {
            ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::UploadConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_upload_config(&mut self) -> PostModelVersionsUploadConfig {
        if self.has_upload_config() {
            match self.upload_data.take() {
                ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::UploadConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            PostModelVersionsUploadConfig::new()
        }
    }

    // .clarifai.api.UploadContentPart content_part = 2;

    pub fn content_part(&self) -> &super::resources::UploadContentPart {
        match self.upload_data {
            ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::ContentPart(ref v)) => v,
            _ => <super::resources::UploadContentPart as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_content_part(&mut self) {
        self.upload_data = ::std::option::Option::None;
    }

    pub fn has_content_part(&self) -> bool {
        match self.upload_data {
            ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::ContentPart(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_content_part(&mut self, v: super::resources::UploadContentPart) {
        self.upload_data = ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::ContentPart(v))
    }

    // Mutable pointer to the field.
    pub fn mut_content_part(&mut self) -> &mut super::resources::UploadContentPart {
        if let ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::ContentPart(_)) = self.upload_data {
        } else {
            self.upload_data = ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::ContentPart(super::resources::UploadContentPart::new()));
        }
        match self.upload_data {
            ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::ContentPart(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_content_part(&mut self) -> super::resources::UploadContentPart {
        if self.has_content_part() {
            match self.upload_data.take() {
                ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::ContentPart(v)) => v,
                _ => panic!(),
            }
        } else {
            super::resources::UploadContentPart::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PostModelVersionsUploadConfig>(
            "upload_config",
            PostModelVersionsUploadRequest::has_upload_config,
            PostModelVersionsUploadRequest::upload_config,
            PostModelVersionsUploadRequest::mut_upload_config,
            PostModelVersionsUploadRequest::set_upload_config,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::resources::UploadContentPart>(
            "content_part",
            PostModelVersionsUploadRequest::has_content_part,
            PostModelVersionsUploadRequest::content_part,
            PostModelVersionsUploadRequest::mut_content_part,
            PostModelVersionsUploadRequest::set_content_part,
        ));
        oneofs.push(post_model_versions_upload_request::Upload_data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsUploadRequest>(
            "PostModelVersionsUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsUploadRequest {
    const NAME: &'static str = "PostModelVersionsUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_data = ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::UploadConfig(is.read_message()?));
                },
                18 => {
                    self.upload_data = ::std::option::Option::Some(post_model_versions_upload_request::Upload_data::ContentPart(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.upload_data {
            match v {
                &post_model_versions_upload_request::Upload_data::UploadConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &post_model_versions_upload_request::Upload_data::ContentPart(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.upload_data {
            match v {
                &post_model_versions_upload_request::Upload_data::UploadConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &post_model_versions_upload_request::Upload_data::ContentPart(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsUploadRequest {
        PostModelVersionsUploadRequest::new()
    }

    fn clear(&mut self) {
        self.upload_data = ::std::option::Option::None;
        self.upload_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsUploadRequest {
        static instance: PostModelVersionsUploadRequest = PostModelVersionsUploadRequest {
            upload_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PostModelVersionsUploadRequest`
pub mod post_model_versions_upload_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.PostModelVersionsUploadRequest.upload_data)
    pub enum Upload_data {
        // @@protoc_insertion_point(oneof_field:clarifai.api.PostModelVersionsUploadRequest.upload_config)
        UploadConfig(super::PostModelVersionsUploadConfig),
        // @@protoc_insertion_point(oneof_field:clarifai.api.PostModelVersionsUploadRequest.content_part)
        ContentPart(super::super::resources::UploadContentPart),
    }

    impl ::protobuf::Oneof for Upload_data {
    }

    impl ::protobuf::OneofFull for Upload_data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PostModelVersionsUploadRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("upload_data").unwrap()).clone()
        }
    }

    impl Upload_data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Upload_data>("upload_data")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUploadResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUploadResponse.bytes_remaining)
    pub bytes_remaining: u64,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUploadResponse.model_version_id)
    pub model_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsUploadResponse {
    fn default() -> &'a PostModelVersionsUploadResponse {
        <PostModelVersionsUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsUploadResponse {
    pub fn new() -> PostModelVersionsUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PostModelVersionsUploadResponse| { &m.status },
            |m: &mut PostModelVersionsUploadResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bytes_remaining",
            |m: &PostModelVersionsUploadResponse| { &m.bytes_remaining },
            |m: &mut PostModelVersionsUploadResponse| { &mut m.bytes_remaining },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &PostModelVersionsUploadResponse| { &m.model_version_id },
            |m: &mut PostModelVersionsUploadResponse| { &mut m.model_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsUploadResponse>(
            "PostModelVersionsUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsUploadResponse {
    const NAME: &'static str = "PostModelVersionsUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                16 => {
                    self.bytes_remaining = is.read_uint64()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.bytes_remaining != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.bytes_remaining);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.bytes_remaining != 0 {
            os.write_uint64(2, self.bytes_remaining)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsUploadResponse {
        PostModelVersionsUploadResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.bytes_remaining = 0;
        self.model_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsUploadResponse {
        static instance: PostModelVersionsUploadResponse = PostModelVersionsUploadResponse {
            status: ::protobuf::MessageField::none(),
            bytes_remaining: 0,
            model_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsUploadConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsUploadConfig {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUploadConfig.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUploadConfig.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUploadConfig.model_version)
    pub model_version: ::protobuf::MessageField<super::resources::ModelVersion>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUploadConfig.total_size)
    pub total_size: u64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsUploadConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsUploadConfig {
    fn default() -> &'a PostModelVersionsUploadConfig {
        <PostModelVersionsUploadConfig as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsUploadConfig {
    pub fn new() -> PostModelVersionsUploadConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsUploadConfig| { &m.user_app_id },
            |m: &mut PostModelVersionsUploadConfig| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsUploadConfig| { &m.model_id },
            |m: &mut PostModelVersionsUploadConfig| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelVersion>(
            "model_version",
            |m: &PostModelVersionsUploadConfig| { &m.model_version },
            |m: &mut PostModelVersionsUploadConfig| { &mut m.model_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_size",
            |m: &PostModelVersionsUploadConfig| { &m.total_size },
            |m: &mut PostModelVersionsUploadConfig| { &mut m.total_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsUploadConfig>(
            "PostModelVersionsUploadConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsUploadConfig {
    const NAME: &'static str = "PostModelVersionsUploadConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_version)?;
                },
                32 => {
                    self.total_size = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if let Some(v) = self.model_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total_size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.total_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if let Some(v) = self.model_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.total_size != 0 {
            os.write_uint64(4, self.total_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsUploadConfig {
        PostModelVersionsUploadConfig::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version.clear();
        self.total_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsUploadConfig {
        static instance: PostModelVersionsUploadConfig = PostModelVersionsUploadConfig {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version: ::protobuf::MessageField::none(),
            total_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsUploadConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsUploadConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsUploadConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsUploadConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PutModelVersionExportsRequest
// @@protoc_insertion_point(message:clarifai.api.PutModelVersionExportsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutModelVersionExportsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutModelVersionExportsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PutModelVersionExportsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PutModelVersionExportsRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutModelVersionExportsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutModelVersionExportsRequest {
    fn default() -> &'a PutModelVersionExportsRequest {
        <PutModelVersionExportsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutModelVersionExportsRequest {
    pub fn new() -> PutModelVersionExportsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutModelVersionExportsRequest| { &m.user_app_id },
            |m: &mut PutModelVersionExportsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PutModelVersionExportsRequest| { &m.model_id },
            |m: &mut PutModelVersionExportsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PutModelVersionExportsRequest| { &m.version_id },
            |m: &mut PutModelVersionExportsRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutModelVersionExportsRequest>(
            "PutModelVersionExportsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutModelVersionExportsRequest {
    const NAME: &'static str = "PutModelVersionExportsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutModelVersionExportsRequest {
        PutModelVersionExportsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutModelVersionExportsRequest {
        static instance: PutModelVersionExportsRequest = PutModelVersionExportsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutModelVersionExportsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutModelVersionExportsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutModelVersionExportsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutModelVersionExportsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelVersionExportRequest
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionExportRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionExportRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionExportRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionExportRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionExportRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionExportRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionExportRequest {
    fn default() -> &'a GetModelVersionExportRequest {
        <GetModelVersionExportRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionExportRequest {
    pub fn new() -> GetModelVersionExportRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionExportRequest| { &m.user_app_id },
            |m: &mut GetModelVersionExportRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionExportRequest| { &m.model_id },
            |m: &mut GetModelVersionExportRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelVersionExportRequest| { &m.version_id },
            |m: &mut GetModelVersionExportRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionExportRequest>(
            "GetModelVersionExportRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionExportRequest {
    const NAME: &'static str = "GetModelVersionExportRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionExportRequest {
        GetModelVersionExportRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionExportRequest {
        static instance: GetModelVersionExportRequest = GetModelVersionExportRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionExportRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionExportRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionExportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionExportRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelVersionExportResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelVersionExportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelVersionExportResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionExportResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionExportResponse.export)
    pub export: ::protobuf::MessageField<super::resources::ModelVersionExport>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelVersionExportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionExportResponse {
    fn default() -> &'a SingleModelVersionExportResponse {
        <SingleModelVersionExportResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionExportResponse {
    pub fn new() -> SingleModelVersionExportResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelVersionExportResponse| { &m.status },
            |m: &mut SingleModelVersionExportResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelVersionExport>(
            "export",
            |m: &SingleModelVersionExportResponse| { &m.export },
            |m: &mut SingleModelVersionExportResponse| { &mut m.export },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelVersionExportResponse>(
            "SingleModelVersionExportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelVersionExportResponse {
    const NAME: &'static str = "SingleModelVersionExportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.export)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.export.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.export.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelVersionExportResponse {
        SingleModelVersionExportResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.export.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelVersionExportResponse {
        static instance: SingleModelVersionExportResponse = SingleModelVersionExportResponse {
            status: ::protobuf::MessageField::none(),
            export: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelVersionExportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelVersionExportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelVersionExportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionExportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PostWorkflowVersionsUnPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowVersionsUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsUnPublishRequest.publications)
    pub publications: ::std::vec::Vec<WorkflowVersionUnPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowVersionsUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowVersionsUnPublishRequest {
    fn default() -> &'a PostWorkflowVersionsUnPublishRequest {
        <PostWorkflowVersionsUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowVersionsUnPublishRequest {
    pub fn new() -> PostWorkflowVersionsUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.user_app_id },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.workflow_id },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostWorkflowVersionsUnPublishRequest| { &m.publications },
            |m: &mut PostWorkflowVersionsUnPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowVersionsUnPublishRequest>(
            "PostWorkflowVersionsUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowVersionsUnPublishRequest {
    const NAME: &'static str = "PostWorkflowVersionsUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowVersionsUnPublishRequest {
        PostWorkflowVersionsUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowVersionsUnPublishRequest {
        static instance: PostWorkflowVersionsUnPublishRequest = PostWorkflowVersionsUnPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowVersionsUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowVersionsUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowVersionsUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowVersionsUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PostWorkflowVersionsPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowVersionsPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowVersionsPublishRequest.publications)
    pub publications: ::std::vec::Vec<WorkflowVersionPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowVersionsPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowVersionsPublishRequest {
    fn default() -> &'a PostWorkflowVersionsPublishRequest {
        <PostWorkflowVersionsPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowVersionsPublishRequest {
    pub fn new() -> PostWorkflowVersionsPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowVersionsPublishRequest| { &m.user_app_id },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowVersionsPublishRequest| { &m.workflow_id },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostWorkflowVersionsPublishRequest| { &m.publications },
            |m: &mut PostWorkflowVersionsPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowVersionsPublishRequest>(
            "PostWorkflowVersionsPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowVersionsPublishRequest {
    const NAME: &'static str = "PostWorkflowVersionsPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowVersionsPublishRequest {
        PostWorkflowVersionsPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowVersionsPublishRequest {
        static instance: PostWorkflowVersionsPublishRequest = PostWorkflowVersionsPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowVersionsPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowVersionsPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowVersionsPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowVersionsPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.WorkflowVersionPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowVersionPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersionPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowVersionPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowVersionPublishRequest {
    fn default() -> &'a WorkflowVersionPublishRequest {
        <WorkflowVersionPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowVersionPublishRequest {
    pub fn new() -> WorkflowVersionPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &WorkflowVersionPublishRequest| { &m.version_id },
            |m: &mut WorkflowVersionPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowVersionPublishRequest>(
            "WorkflowVersionPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowVersionPublishRequest {
    const NAME: &'static str = "WorkflowVersionPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowVersionPublishRequest {
        WorkflowVersionPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowVersionPublishRequest {
        static instance: WorkflowVersionPublishRequest = WorkflowVersionPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowVersionPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowVersionPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowVersionPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowVersionPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.WorkflowVersionUnPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowVersionUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.WorkflowVersionUnPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.WorkflowVersionUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowVersionUnPublishRequest {
    fn default() -> &'a WorkflowVersionUnPublishRequest {
        <WorkflowVersionUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowVersionUnPublishRequest {
    pub fn new() -> WorkflowVersionUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &WorkflowVersionUnPublishRequest| { &m.version_id },
            |m: &mut WorkflowVersionUnPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowVersionUnPublishRequest>(
            "WorkflowVersionUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowVersionUnPublishRequest {
    const NAME: &'static str = "WorkflowVersionUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowVersionUnPublishRequest {
        WorkflowVersionUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowVersionUnPublishRequest {
        static instance: WorkflowVersionUnPublishRequest = WorkflowVersionUnPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowVersionUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowVersionUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowVersionUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowVersionUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersionPublishRequest
// @@protoc_insertion_point(message:clarifai.api.ModelVersionPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelVersionPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionPublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersionPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersionPublishRequest {
    fn default() -> &'a ModelVersionPublishRequest {
        <ModelVersionPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionPublishRequest {
    pub fn new() -> ModelVersionPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ModelVersionPublishRequest| { &m.version_id },
            |m: &mut ModelVersionPublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersionPublishRequest>(
            "ModelVersionPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersionPublishRequest {
    const NAME: &'static str = "ModelVersionPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersionPublishRequest {
        ModelVersionPublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersionPublishRequest {
        static instance: ModelVersionPublishRequest = ModelVersionPublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersionPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersionPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersionPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelVersionsPublishRequest
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsPublishRequest.publications)
    pub publications: ::std::vec::Vec<ModelVersionPublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsPublishRequest {
    fn default() -> &'a PostModelVersionsPublishRequest {
        <PostModelVersionsPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsPublishRequest {
    pub fn new() -> PostModelVersionsPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsPublishRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsPublishRequest| { &m.model_id },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostModelVersionsPublishRequest| { &m.publications },
            |m: &mut PostModelVersionsPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsPublishRequest>(
            "PostModelVersionsPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsPublishRequest {
    const NAME: &'static str = "PostModelVersionsPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsPublishRequest {
        PostModelVersionsPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsPublishRequest {
        static instance: PostModelVersionsPublishRequest = PostModelVersionsPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ModelVersionUnpublishRequest
// @@protoc_insertion_point(message:clarifai.api.ModelVersionUnpublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelVersionUnpublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ModelVersionUnpublishRequest.version_id)
    pub version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ModelVersionUnpublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelVersionUnpublishRequest {
    fn default() -> &'a ModelVersionUnpublishRequest {
        <ModelVersionUnpublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionUnpublishRequest {
    pub fn new() -> ModelVersionUnpublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &ModelVersionUnpublishRequest| { &m.version_id },
            |m: &mut ModelVersionUnpublishRequest| { &mut m.version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelVersionUnpublishRequest>(
            "ModelVersionUnpublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelVersionUnpublishRequest {
    const NAME: &'static str = "ModelVersionUnpublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelVersionUnpublishRequest {
        ModelVersionUnpublishRequest::new()
    }

    fn clear(&mut self) {
        self.version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelVersionUnpublishRequest {
        static instance: ModelVersionUnpublishRequest = ModelVersionUnpublishRequest {
            version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelVersionUnpublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelVersionUnpublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelVersionUnpublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionUnpublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModelVersionsUnPublishRequest
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsUnPublishRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsUnPublishRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsUnPublishRequest.publications)
    pub publications: ::std::vec::Vec<ModelVersionUnpublishRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsUnPublishRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsUnPublishRequest {
    fn default() -> &'a PostModelVersionsUnPublishRequest {
        <PostModelVersionsUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsUnPublishRequest {
    pub fn new() -> PostModelVersionsUnPublishRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsUnPublishRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsUnPublishRequest| { &m.model_id },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "publications",
            |m: &PostModelVersionsUnPublishRequest| { &m.publications },
            |m: &mut PostModelVersionsUnPublishRequest| { &mut m.publications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsUnPublishRequest>(
            "PostModelVersionsUnPublishRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsUnPublishRequest {
    const NAME: &'static str = "PostModelVersionsUnPublishRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.publications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.publications {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsUnPublishRequest {
        PostModelVersionsUnPublishRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.publications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsUnPublishRequest {
        static instance: PostModelVersionsUnPublishRequest = PostModelVersionsUnPublishRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            publications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsUnPublishRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsUnPublishRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsUnPublishRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model vesion
// @@protoc_insertion_point(message:clarifai.api.PostEvaluationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  eval_info, id, model, and ground_truth_dataset will be used when creating the evaluation
    ///  If no dataset is provided, all app data that is annotated with concepts from the model will be used.
    // @@protoc_insertion_point(field:clarifai.api.PostEvaluationsRequest.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostEvaluationsRequest {
    fn default() -> &'a PostEvaluationsRequest {
        <PostEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostEvaluationsRequest {
    pub fn new() -> PostEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostEvaluationsRequest| { &m.user_app_id },
            |m: &mut PostEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &PostEvaluationsRequest| { &m.eval_metrics },
            |m: &mut PostEvaluationsRequest| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostEvaluationsRequest>(
            "PostEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostEvaluationsRequest {
    const NAME: &'static str = "PostEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostEvaluationsRequest {
        PostEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostEvaluationsRequest {
        static instance: PostEvaluationsRequest = PostEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListEvaluationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.per_page)
    pub per_page: u32,
    ///  If true, sort in ascending order, otherwise sort in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filter on model type id
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    ///  Filter on dataset ID of the dataset version specified in the metric version
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.eval_dataset_ids)
    pub eval_dataset_ids: ::std::vec::Vec<::std::string::String>,
    ///  Filter on dataset ID of the dataset version specified by the model version
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.train_dataset_ids)
    pub train_dataset_ids: ::std::vec::Vec<::std::string::String>,
    ///  Filter on concept IDs specified in the modele version's output_info
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.concept_ids)
    pub concept_ids: ::std::vec::Vec<::std::string::String>,
    ///  Whether to show failed metrics, defaults to false
    // @@protoc_insertion_point(field:clarifai.api.ListEvaluationsRequest.show_failed_metrics)
    pub show_failed_metrics: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_evaluations_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEvaluationsRequest {
    fn default() -> &'a ListEvaluationsRequest {
        <ListEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListEvaluationsRequest {
    pub fn new() -> ListEvaluationsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_app_id = 5;

    pub fn sort_by_app_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_app_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_app_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_app_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(v))
    }

    // bool sort_by_roc_auc = 6;

    pub fn sort_by_roc_auc(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_roc_auc(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_roc_auc(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_roc_auc(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(v))
    }

    // bool sort_by_f1 = 7;

    pub fn sort_by_f1(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_f1(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_f1(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_f1(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(v))
    }

    // bool sort_by_created_at = 8;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_mean_avg_precision = 9;

    pub fn sort_by_mean_avg_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_mean_avg_precision(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_mean_avg_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_mean_avg_precision(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v))
    }

    // bool sort_by_precision = 10;

    pub fn sort_by_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_precision(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_precision(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_precision(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(v))
    }

    // bool sort_by_recall = 11;

    pub fn sort_by_recall(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_recall(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_recall(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_recall(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(v))
    }

    // bool sort_by_model_id = 16;

    pub fn sort_by_model_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_model_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_model_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_model_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(v))
    }

    // bool sort_by_eval_dataset_id = 17;

    pub fn sort_by_eval_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_eval_dataset_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_eval_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_eval_dataset_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(v))
    }

    // bool sort_by_train_dataset_id = 18;

    pub fn sort_by_train_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_train_dataset_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_train_dataset_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_train_dataset_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListEvaluationsRequest| { &m.user_app_id },
            |m: &mut ListEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListEvaluationsRequest| { &m.page },
            |m: &mut ListEvaluationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListEvaluationsRequest| { &m.per_page },
            |m: &mut ListEvaluationsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListEvaluationsRequest| { &m.sort_ascending },
            |m: &mut ListEvaluationsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_app_id",
            ListEvaluationsRequest::has_sort_by_app_id,
            ListEvaluationsRequest::sort_by_app_id,
            ListEvaluationsRequest::set_sort_by_app_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_roc_auc",
            ListEvaluationsRequest::has_sort_by_roc_auc,
            ListEvaluationsRequest::sort_by_roc_auc,
            ListEvaluationsRequest::set_sort_by_roc_auc,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_f1",
            ListEvaluationsRequest::has_sort_by_f1,
            ListEvaluationsRequest::sort_by_f1,
            ListEvaluationsRequest::set_sort_by_f1,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListEvaluationsRequest::has_sort_by_created_at,
            ListEvaluationsRequest::sort_by_created_at,
            ListEvaluationsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_mean_avg_precision",
            ListEvaluationsRequest::has_sort_by_mean_avg_precision,
            ListEvaluationsRequest::sort_by_mean_avg_precision,
            ListEvaluationsRequest::set_sort_by_mean_avg_precision,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_precision",
            ListEvaluationsRequest::has_sort_by_precision,
            ListEvaluationsRequest::sort_by_precision,
            ListEvaluationsRequest::set_sort_by_precision,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_recall",
            ListEvaluationsRequest::has_sort_by_recall,
            ListEvaluationsRequest::sort_by_recall,
            ListEvaluationsRequest::set_sort_by_recall,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_model_id",
            ListEvaluationsRequest::has_sort_by_model_id,
            ListEvaluationsRequest::sort_by_model_id,
            ListEvaluationsRequest::set_sort_by_model_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_eval_dataset_id",
            ListEvaluationsRequest::has_sort_by_eval_dataset_id,
            ListEvaluationsRequest::sort_by_eval_dataset_id,
            ListEvaluationsRequest::set_sort_by_eval_dataset_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_train_dataset_id",
            ListEvaluationsRequest::has_sort_by_train_dataset_id,
            ListEvaluationsRequest::sort_by_train_dataset_id,
            ListEvaluationsRequest::set_sort_by_train_dataset_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &ListEvaluationsRequest| { &m.model_type_id },
            |m: &mut ListEvaluationsRequest| { &mut m.model_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_dataset_ids",
            |m: &ListEvaluationsRequest| { &m.eval_dataset_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.eval_dataset_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "train_dataset_ids",
            |m: &ListEvaluationsRequest| { &m.train_dataset_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.train_dataset_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concept_ids",
            |m: &ListEvaluationsRequest| { &m.concept_ids },
            |m: &mut ListEvaluationsRequest| { &mut m.concept_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show_failed_metrics",
            |m: &ListEvaluationsRequest| { &m.show_failed_metrics },
            |m: &mut ListEvaluationsRequest| { &mut m.show_failed_metrics },
        ));
        oneofs.push(list_evaluations_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEvaluationsRequest>(
            "ListEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEvaluationsRequest {
    const NAME: &'static str = "ListEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                32 => {
                    self.sort_ascending = is.read_bool()?;
                },
                40 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByAppId(is.read_bool()?));
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRocAuc(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByF1(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByMeanAvgPrecision(is.read_bool()?));
                },
                80 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByPrecision(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByRecall(is.read_bool()?));
                },
                128 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByModelId(is.read_bool()?));
                },
                136 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByEvalDatasetId(is.read_bool()?));
                },
                144 => {
                    self.sort_by = ::std::option::Option::Some(list_evaluations_request::Sort_by::SortByTrainDatasetId(is.read_bool()?));
                },
                98 => {
                    self.model_type_id = is.read_string()?;
                },
                106 => {
                    self.eval_dataset_ids.push(is.read_string()?);
                },
                114 => {
                    self.train_dataset_ids.push(is.read_string()?);
                },
                122 => {
                    self.concept_ids.push(is.read_string()?);
                },
                152 => {
                    self.show_failed_metrics = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.model_type_id);
        }
        for value in &self.eval_dataset_ids {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.train_dataset_ids {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if self.show_failed_metrics != false {
            my_size += 2 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_evaluations_request::Sort_by::SortByAppId(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByRocAuc(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByF1(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByPrecision(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByRecall(v) => {
                    my_size += 1 + 1;
                },
                &list_evaluations_request::Sort_by::SortByModelId(v) => {
                    my_size += 2 + 1;
                },
                &list_evaluations_request::Sort_by::SortByEvalDatasetId(v) => {
                    my_size += 2 + 1;
                },
                &list_evaluations_request::Sort_by::SortByTrainDatasetId(v) => {
                    my_size += 2 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(4, self.sort_ascending)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(12, &self.model_type_id)?;
        }
        for v in &self.eval_dataset_ids {
            os.write_string(13, &v)?;
        };
        for v in &self.train_dataset_ids {
            os.write_string(14, &v)?;
        };
        for v in &self.concept_ids {
            os.write_string(15, &v)?;
        };
        if self.show_failed_metrics != false {
            os.write_bool(19, self.show_failed_metrics)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_evaluations_request::Sort_by::SortByAppId(v) => {
                    os.write_bool(5, v)?;
                },
                &list_evaluations_request::Sort_by::SortByRocAuc(v) => {
                    os.write_bool(6, v)?;
                },
                &list_evaluations_request::Sort_by::SortByF1(v) => {
                    os.write_bool(7, v)?;
                },
                &list_evaluations_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(8, v)?;
                },
                &list_evaluations_request::Sort_by::SortByMeanAvgPrecision(v) => {
                    os.write_bool(9, v)?;
                },
                &list_evaluations_request::Sort_by::SortByPrecision(v) => {
                    os.write_bool(10, v)?;
                },
                &list_evaluations_request::Sort_by::SortByRecall(v) => {
                    os.write_bool(11, v)?;
                },
                &list_evaluations_request::Sort_by::SortByModelId(v) => {
                    os.write_bool(16, v)?;
                },
                &list_evaluations_request::Sort_by::SortByEvalDatasetId(v) => {
                    os.write_bool(17, v)?;
                },
                &list_evaluations_request::Sort_by::SortByTrainDatasetId(v) => {
                    os.write_bool(18, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEvaluationsRequest {
        ListEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.model_type_id.clear();
        self.eval_dataset_ids.clear();
        self.train_dataset_ids.clear();
        self.concept_ids.clear();
        self.show_failed_metrics = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEvaluationsRequest {
        static instance: ListEvaluationsRequest = ListEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            sort_ascending: false,
            model_type_id: ::std::string::String::new(),
            eval_dataset_ids: ::std::vec::Vec::new(),
            train_dataset_ids: ::std::vec::Vec::new(),
            concept_ids: ::std::vec::Vec::new(),
            show_failed_metrics: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListEvaluationsRequest`
pub mod list_evaluations_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListEvaluationsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_app_id)
        SortByAppId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_roc_auc)
        SortByRocAuc(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_f1)
        SortByF1(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_mean_avg_precision)
        SortByMeanAvgPrecision(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_precision)
        SortByPrecision(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_recall)
        SortByRecall(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_model_id)
        SortByModelId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_eval_dataset_id)
        SortByEvalDatasetId(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListEvaluationsRequest.sort_by_train_dataset_id)
        SortByTrainDatasetId(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListEvaluationsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.GetEvaluationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetEvaluationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.evaluation_id)
    pub evaluation_id: ::std::string::String,
    ///  Any of the fields you wish to return in the metrics
    ///  By default, only the summary is returned.
    // @@protoc_insertion_point(field:clarifai.api.GetEvaluationRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetEvaluationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEvaluationRequest {
    fn default() -> &'a GetEvaluationRequest {
        <GetEvaluationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEvaluationRequest {
    pub fn new() -> GetEvaluationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetEvaluationRequest| { &m.user_app_id },
            |m: &mut GetEvaluationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_id",
            |m: &GetEvaluationRequest| { &m.evaluation_id },
            |m: &mut GetEvaluationRequest| { &mut m.evaluation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetEvaluationRequest| { &m.fields },
            |m: &mut GetEvaluationRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetEvaluationRequest>(
            "GetEvaluationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetEvaluationRequest {
    const NAME: &'static str = "GetEvaluationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.evaluation_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.evaluation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.evaluation_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.evaluation_id.is_empty() {
            os.write_string(2, &self.evaluation_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEvaluationRequest {
        GetEvaluationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.evaluation_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEvaluationRequest {
        static instance: GetEvaluationRequest = GetEvaluationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            evaluation_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetEvaluationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetEvaluationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetEvaluationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEvaluationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model vesion
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionEvaluationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  EvalInfo and ID will be used when creating the evaluation
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionEvaluationsRequest.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionEvaluationsRequest {
    fn default() -> &'a PostModelVersionEvaluationsRequest {
        <PostModelVersionEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionEvaluationsRequest {
    pub fn new() -> PostModelVersionEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.model_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &PostModelVersionEvaluationsRequest| { &m.model_version_id },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &PostModelVersionEvaluationsRequest| { &m.eval_metrics },
            |m: &mut PostModelVersionEvaluationsRequest| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionEvaluationsRequest>(
            "PostModelVersionEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionEvaluationsRequest {
    const NAME: &'static str = "PostModelVersionEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionEvaluationsRequest {
        PostModelVersionEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionEvaluationsRequest {
        static instance: PostModelVersionEvaluationsRequest = PostModelVersionEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListModelVersionEvaluationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelVersionEvaluationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionEvaluationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionEvaluationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionEvaluationsRequest {
    fn default() -> &'a ListModelVersionEvaluationsRequest {
        <ListModelVersionEvaluationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionEvaluationsRequest {
    pub fn new() -> ListModelVersionEvaluationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.user_app_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.model_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &ListModelVersionEvaluationsRequest| { &m.model_version_id },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionEvaluationsRequest| { &m.page },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionEvaluationsRequest| { &m.per_page },
            |m: &mut ListModelVersionEvaluationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionEvaluationsRequest>(
            "ListModelVersionEvaluationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionEvaluationsRequest {
    const NAME: &'static str = "ListModelVersionEvaluationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionEvaluationsRequest {
        ListModelVersionEvaluationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionEvaluationsRequest {
        static instance: ListModelVersionEvaluationsRequest = ListModelVersionEvaluationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionEvaluationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionEvaluationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionEvaluationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionEvaluationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetModelVersionEvaluationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionEvaluationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.evaluation_id)
    pub evaluation_id: ::std::string::String,
    ///  Any of the fields you wish to return from multiclass_metrics
    ///  By default, only the summary is returned.
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionEvaluationRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionEvaluationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionEvaluationRequest {
    fn default() -> &'a GetModelVersionEvaluationRequest {
        <GetModelVersionEvaluationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionEvaluationRequest {
    pub fn new() -> GetModelVersionEvaluationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionEvaluationRequest| { &m.user_app_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionEvaluationRequest| { &m.model_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &GetModelVersionEvaluationRequest| { &m.model_version_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_id",
            |m: &GetModelVersionEvaluationRequest| { &m.evaluation_id },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.evaluation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetModelVersionEvaluationRequest| { &m.fields },
            |m: &mut GetModelVersionEvaluationRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionEvaluationRequest>(
            "GetModelVersionEvaluationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionEvaluationRequest {
    const NAME: &'static str = "GetModelVersionEvaluationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.evaluation_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if !self.evaluation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.evaluation_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if !self.evaluation_id.is_empty() {
            os.write_string(4, &self.evaluation_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionEvaluationRequest {
        GetModelVersionEvaluationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.evaluation_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionEvaluationRequest {
        static instance: GetModelVersionEvaluationRequest = GetModelVersionEvaluationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            evaluation_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionEvaluationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionEvaluationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionEvaluationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionEvaluationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SingleEvalMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleEvalMetricsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleEvalMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleEvalMetricsResponse.eval_metrics)
    pub eval_metrics: ::protobuf::MessageField<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleEvalMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleEvalMetricsResponse {
    fn default() -> &'a SingleEvalMetricsResponse {
        <SingleEvalMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleEvalMetricsResponse {
    pub fn new() -> SingleEvalMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleEvalMetricsResponse| { &m.status },
            |m: &mut SingleEvalMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalMetrics>(
            "eval_metrics",
            |m: &SingleEvalMetricsResponse| { &m.eval_metrics },
            |m: &mut SingleEvalMetricsResponse| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleEvalMetricsResponse>(
            "SingleEvalMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleEvalMetricsResponse {
    const NAME: &'static str = "SingleEvalMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eval_metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.eval_metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleEvalMetricsResponse {
        SingleEvalMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleEvalMetricsResponse {
        static instance: SingleEvalMetricsResponse = SingleEvalMetricsResponse {
            status: ::protobuf::MessageField::none(),
            eval_metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleEvalMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleEvalMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleEvalMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleEvalMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiEvalMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiEvalMetricsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiEvalMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiEvalMetricsResponse.eval_metrics)
    pub eval_metrics: ::std::vec::Vec<super::resources::EvalMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiEvalMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiEvalMetricsResponse {
    fn default() -> &'a MultiEvalMetricsResponse {
        <MultiEvalMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiEvalMetricsResponse {
    pub fn new() -> MultiEvalMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiEvalMetricsResponse| { &m.status },
            |m: &mut MultiEvalMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eval_metrics",
            |m: &MultiEvalMetricsResponse| { &m.eval_metrics },
            |m: &mut MultiEvalMetricsResponse| { &mut m.eval_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiEvalMetricsResponse>(
            "MultiEvalMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiEvalMetricsResponse {
    const NAME: &'static str = "MultiEvalMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.eval_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.eval_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.eval_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiEvalMetricsResponse {
        MultiEvalMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.eval_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiEvalMetricsResponse {
        static instance: MultiEvalMetricsResponse = MultiEvalMetricsResponse {
            status: ::protobuf::MessageField::none(),
            eval_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiEvalMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiEvalMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiEvalMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiEvalMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Evaluate this model version.
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  Use this to filter inputs that are used in evaluation
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.test_search)
    pub test_search: ::protobuf::MessageField<super::resources::Search>,
    ///  evaluation info. Such as dataset used for evaluation.
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionMetricsRequest.eval_info)
    pub eval_info: ::protobuf::MessageField<super::resources::EvalInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionMetricsRequest {
    fn default() -> &'a PostModelVersionMetricsRequest {
        <PostModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionMetricsRequest {
    pub fn new() -> PostModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionMetricsRequest| { &m.user_app_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionMetricsRequest| { &m.model_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostModelVersionMetricsRequest| { &m.version_id },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "test_search",
            |m: &PostModelVersionMetricsRequest| { &m.test_search },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.test_search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::EvalInfo>(
            "eval_info",
            |m: &PostModelVersionMetricsRequest| { &m.eval_info },
            |m: &mut PostModelVersionMetricsRequest| { &mut m.eval_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionMetricsRequest>(
            "PostModelVersionMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionMetricsRequest {
    const NAME: &'static str = "PostModelVersionMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.test_search)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eval_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if let Some(v) = self.test_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eval_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if let Some(v) = self.test_search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.eval_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionMetricsRequest {
        PostModelVersionMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.test_search.clear();
        self.eval_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionMetricsRequest {
        static instance: PostModelVersionMetricsRequest = PostModelVersionMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            test_search: ::protobuf::MessageField::none(),
            eval_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Get the already computed evaluation metrics for this model
///  version.
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.version_id)
    pub version_id: ::std::string::String,
    ///  Any of the fields you wish to return from multiclass_metrics
    ///  By default, only the summary will be returned
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionMetricsRequest.fields)
    pub fields: ::protobuf::MessageField<super::resources::FieldsValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionMetricsRequest {
    fn default() -> &'a GetModelVersionMetricsRequest {
        <GetModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionMetricsRequest {
    pub fn new() -> GetModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionMetricsRequest| { &m.user_app_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionMetricsRequest| { &m.model_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &GetModelVersionMetricsRequest| { &m.version_id },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::FieldsValue>(
            "fields",
            |m: &GetModelVersionMetricsRequest| { &m.fields },
            |m: &mut GetModelVersionMetricsRequest| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionMetricsRequest>(
            "GetModelVersionMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionMetricsRequest {
    const NAME: &'static str = "GetModelVersionMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.version_id = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fields)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if let Some(v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if let Some(v) = self.fields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionMetricsRequest {
        GetModelVersionMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionMetricsRequest {
        static instance: GetModelVersionMetricsRequest = GetModelVersionMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            fields: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelTypeRequest
// @@protoc_insertion_point(message:clarifai.api.GetModelTypeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelTypeRequest {
    // message fields
    ///  use and app combo. Not really used for this endpoint at this time so may go away in future.
    // @@protoc_insertion_point(field:clarifai.api.GetModelTypeRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The specific ModelType.Id you want to retrieve.
    // @@protoc_insertion_point(field:clarifai.api.GetModelTypeRequest.model_type_id)
    pub model_type_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelTypeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelTypeRequest {
    fn default() -> &'a GetModelTypeRequest {
        <GetModelTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelTypeRequest {
    pub fn new() -> GetModelTypeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelTypeRequest| { &m.user_app_id },
            |m: &mut GetModelTypeRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type_id",
            |m: &GetModelTypeRequest| { &m.model_type_id },
            |m: &mut GetModelTypeRequest| { &mut m.model_type_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelTypeRequest>(
            "GetModelTypeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelTypeRequest {
    const NAME: &'static str = "GetModelTypeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_type_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_type_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(2, &self.model_type_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelTypeRequest {
        GetModelTypeRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_type_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelTypeRequest {
        static instance: GetModelTypeRequest = GetModelTypeRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_type_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelTypeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelTypeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelTypeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelTypesRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelTypesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelTypesRequest {
    // message fields
    ///  use and app combo. Not really used for this endpoint at this time so may go away in future.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModelTypesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelTypesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelTypesRequest {
    fn default() -> &'a ListModelTypesRequest {
        <ListModelTypesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelTypesRequest {
    pub fn new() -> ListModelTypesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelTypesRequest| { &m.user_app_id },
            |m: &mut ListModelTypesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelTypesRequest| { &m.page },
            |m: &mut ListModelTypesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelTypesRequest| { &m.per_page },
            |m: &mut ListModelTypesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelTypesRequest>(
            "ListModelTypesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelTypesRequest {
    const NAME: &'static str = "ListModelTypesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelTypesRequest {
        ListModelTypesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelTypesRequest {
        static instance: ListModelTypesRequest = ListModelTypesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelTypesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelTypesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelTypesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelTypesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListOpenSourceLicensesRequest
// @@protoc_insertion_point(message:clarifai.api.ListOpenSourceLicensesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListOpenSourceLicensesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListOpenSourceLicensesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOpenSourceLicensesRequest {
    fn default() -> &'a ListOpenSourceLicensesRequest {
        <ListOpenSourceLicensesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenSourceLicensesRequest {
    pub fn new() -> ListOpenSourceLicensesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOpenSourceLicensesRequest>(
            "ListOpenSourceLicensesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOpenSourceLicensesRequest {
    const NAME: &'static str = "ListOpenSourceLicensesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOpenSourceLicensesRequest {
        ListOpenSourceLicensesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOpenSourceLicensesRequest {
        static instance: ListOpenSourceLicensesRequest = ListOpenSourceLicensesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOpenSourceLicensesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOpenSourceLicensesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOpenSourceLicensesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenSourceLicensesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListOpenSourceLicensesResponse
// @@protoc_insertion_point(message:clarifai.api.ListOpenSourceLicensesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListOpenSourceLicensesResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListOpenSourceLicensesResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.ListOpenSourceLicensesResponse.licenses)
    pub licenses: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListOpenSourceLicensesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListOpenSourceLicensesResponse {
    fn default() -> &'a ListOpenSourceLicensesResponse {
        <ListOpenSourceLicensesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenSourceLicensesResponse {
    pub fn new() -> ListOpenSourceLicensesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &ListOpenSourceLicensesResponse| { &m.status },
            |m: &mut ListOpenSourceLicensesResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "licenses",
            |m: &ListOpenSourceLicensesResponse| { &m.licenses },
            |m: &mut ListOpenSourceLicensesResponse| { &mut m.licenses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListOpenSourceLicensesResponse>(
            "ListOpenSourceLicensesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListOpenSourceLicensesResponse {
    const NAME: &'static str = "ListOpenSourceLicensesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.licenses.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.licenses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.licenses {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListOpenSourceLicensesResponse {
        ListOpenSourceLicensesResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.licenses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListOpenSourceLicensesResponse {
        static instance: ListOpenSourceLicensesResponse = ListOpenSourceLicensesResponse {
            status: ::protobuf::MessageField::none(),
            licenses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListOpenSourceLicensesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListOpenSourceLicensesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListOpenSourceLicensesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenSourceLicensesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelTypeResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelTypeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelTypeResponse {
    // message fields
    ///  Status of the response.
    // @@protoc_insertion_point(field:clarifai.api.SingleModelTypeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The retrieved ModelType object. .
    // @@protoc_insertion_point(field:clarifai.api.SingleModelTypeResponse.model_type)
    pub model_type: ::protobuf::MessageField<super::resources::ModelType>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelTypeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelTypeResponse {
    fn default() -> &'a SingleModelTypeResponse {
        <SingleModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelTypeResponse {
    pub fn new() -> SingleModelTypeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelTypeResponse| { &m.status },
            |m: &mut SingleModelTypeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelType>(
            "model_type",
            |m: &SingleModelTypeResponse| { &m.model_type },
            |m: &mut SingleModelTypeResponse| { &mut m.model_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelTypeResponse>(
            "SingleModelTypeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelTypeResponse {
    const NAME: &'static str = "SingleModelTypeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_type)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelTypeResponse {
        SingleModelTypeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelTypeResponse {
        static instance: SingleModelTypeResponse = SingleModelTypeResponse {
            status: ::protobuf::MessageField::none(),
            model_type: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelTypeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelTypeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelTypeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelTypeResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelTypeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelTypeResponse {
    // message fields
    ///  Status of the response.
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  List of ModelType objects.
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.model_types)
    pub model_types: ::std::vec::Vec<super::resources::ModelType>,
    ///  List of model importers
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.model_importers)
    pub model_importers: ::protobuf::MessageField<super::resources::ModelTypeField>,
    ///  Triton model envs that can be used for model upload
    // @@protoc_insertion_point(field:clarifai.api.MultiModelTypeResponse.triton_conda_envs_info)
    pub triton_conda_envs_info: ::std::vec::Vec<super::resources::TritonCondaEnvInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelTypeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelTypeResponse {
    fn default() -> &'a MultiModelTypeResponse {
        <MultiModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelTypeResponse {
    pub fn new() -> MultiModelTypeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelTypeResponse| { &m.status },
            |m: &mut MultiModelTypeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_types",
            |m: &MultiModelTypeResponse| { &m.model_types },
            |m: &mut MultiModelTypeResponse| { &mut m.model_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelTypeField>(
            "model_importers",
            |m: &MultiModelTypeResponse| { &m.model_importers },
            |m: &mut MultiModelTypeResponse| { &mut m.model_importers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "triton_conda_envs_info",
            |m: &MultiModelTypeResponse| { &m.triton_conda_envs_info },
            |m: &mut MultiModelTypeResponse| { &mut m.triton_conda_envs_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelTypeResponse>(
            "MultiModelTypeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelTypeResponse {
    const NAME: &'static str = "MultiModelTypeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_types.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_importers)?;
                },
                34 => {
                    self.triton_conda_envs_info.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.model_importers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.triton_conda_envs_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_types {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.model_importers.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.triton_conda_envs_info {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelTypeResponse {
        MultiModelTypeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_types.clear();
        self.model_importers.clear();
        self.triton_conda_envs_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelTypeResponse {
        static instance: MultiModelTypeResponse = MultiModelTypeResponse {
            status: ::protobuf::MessageField::none(),
            model_types: ::std::vec::Vec::new(),
            model_importers: ::protobuf::MessageField::none(),
            triton_conda_envs_info: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelTypeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelTypeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelTypeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModelVersionInputExampleRequest
// @@protoc_insertion_point(message:clarifai.api.GetModelVersionInputExampleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModelVersionInputExampleRequest {
    // message fields
    ///  authorization field  (contains app/user id info)
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of model the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.model_id)
    pub model_id: ::std::string::String,
    ///  specific version the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Id of example to fetch
    // @@protoc_insertion_point(field:clarifai.api.GetModelVersionInputExampleRequest.example_id)
    pub example_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModelVersionInputExampleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModelVersionInputExampleRequest {
    fn default() -> &'a GetModelVersionInputExampleRequest {
        <GetModelVersionInputExampleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionInputExampleRequest {
    pub fn new() -> GetModelVersionInputExampleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModelVersionInputExampleRequest| { &m.user_app_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &GetModelVersionInputExampleRequest| { &m.model_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &GetModelVersionInputExampleRequest| { &m.model_version_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "example_id",
            |m: &GetModelVersionInputExampleRequest| { &m.example_id },
            |m: &mut GetModelVersionInputExampleRequest| { &mut m.example_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModelVersionInputExampleRequest>(
            "GetModelVersionInputExampleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModelVersionInputExampleRequest {
    const NAME: &'static str = "GetModelVersionInputExampleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.example_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if !self.example_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.example_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if !self.example_id.is_empty() {
            os.write_string(4, &self.example_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModelVersionInputExampleRequest {
        GetModelVersionInputExampleRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.example_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModelVersionInputExampleRequest {
        static instance: GetModelVersionInputExampleRequest = GetModelVersionInputExampleRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            example_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModelVersionInputExampleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModelVersionInputExampleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModelVersionInputExampleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionInputExampleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelVersionInputExamplesRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelVersionInputExamplesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelVersionInputExamplesRequest {
    // message fields
    ///  authorization field  (contains app/user id info)
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of model the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.model_id)
    pub model_id: ::std::string::String,
    ///  specific version the example belongs to
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Optional, defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.page)
    pub page: u32,
    ///  Optional, defaults to 128 references per page.
    // @@protoc_insertion_point(field:clarifai.api.ListModelVersionInputExamplesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelVersionInputExamplesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelVersionInputExamplesRequest {
    fn default() -> &'a ListModelVersionInputExamplesRequest {
        <ListModelVersionInputExamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionInputExamplesRequest {
    pub fn new() -> ListModelVersionInputExamplesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.user_app_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.model_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &ListModelVersionInputExamplesRequest| { &m.model_version_id },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelVersionInputExamplesRequest| { &m.page },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelVersionInputExamplesRequest| { &m.per_page },
            |m: &mut ListModelVersionInputExamplesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelVersionInputExamplesRequest>(
            "ListModelVersionInputExamplesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelVersionInputExamplesRequest {
    const NAME: &'static str = "ListModelVersionInputExamplesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                32 => {
                    self.page = is.read_uint32()?;
                },
                40 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelVersionInputExamplesRequest {
        ListModelVersionInputExamplesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelVersionInputExamplesRequest {
        static instance: ListModelVersionInputExamplesRequest = ListModelVersionInputExamplesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelVersionInputExamplesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelVersionInputExamplesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelVersionInputExamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionInputExamplesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModelVersionInputExampleResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModelVersionInputExampleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModelVersionInputExampleResponse {
    // message fields
    ///  status of response
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionInputExampleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  model input example message
    // @@protoc_insertion_point(field:clarifai.api.SingleModelVersionInputExampleResponse.model_version_input_example)
    pub model_version_input_example: ::protobuf::MessageField<super::resources::ModelVersionInputExample>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModelVersionInputExampleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionInputExampleResponse {
    fn default() -> &'a SingleModelVersionInputExampleResponse {
        <SingleModelVersionInputExampleResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionInputExampleResponse {
    pub fn new() -> SingleModelVersionInputExampleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModelVersionInputExampleResponse| { &m.status },
            |m: &mut SingleModelVersionInputExampleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModelVersionInputExample>(
            "model_version_input_example",
            |m: &SingleModelVersionInputExampleResponse| { &m.model_version_input_example },
            |m: &mut SingleModelVersionInputExampleResponse| { &mut m.model_version_input_example },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModelVersionInputExampleResponse>(
            "SingleModelVersionInputExampleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModelVersionInputExampleResponse {
    const NAME: &'static str = "SingleModelVersionInputExampleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.model_version_input_example)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.model_version_input_example.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.model_version_input_example.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModelVersionInputExampleResponse {
        SingleModelVersionInputExampleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version_input_example.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModelVersionInputExampleResponse {
        static instance: SingleModelVersionInputExampleResponse = SingleModelVersionInputExampleResponse {
            status: ::protobuf::MessageField::none(),
            model_version_input_example: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModelVersionInputExampleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModelVersionInputExampleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModelVersionInputExampleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionInputExampleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelVersionInputExampleResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelVersionInputExampleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelVersionInputExampleResponse {
    // message fields
    ///  status of response
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionInputExampleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  model input example messages
    // @@protoc_insertion_point(field:clarifai.api.MultiModelVersionInputExampleResponse.model_version_input_examples)
    pub model_version_input_examples: ::std::vec::Vec<super::resources::ModelVersionInputExample>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelVersionInputExampleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionInputExampleResponse {
    fn default() -> &'a MultiModelVersionInputExampleResponse {
        <MultiModelVersionInputExampleResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionInputExampleResponse {
    pub fn new() -> MultiModelVersionInputExampleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelVersionInputExampleResponse| { &m.status },
            |m: &mut MultiModelVersionInputExampleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_version_input_examples",
            |m: &MultiModelVersionInputExampleResponse| { &m.model_version_input_examples },
            |m: &mut MultiModelVersionInputExampleResponse| { &mut m.model_version_input_examples },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelVersionInputExampleResponse>(
            "MultiModelVersionInputExampleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelVersionInputExampleResponse {
    const NAME: &'static str = "MultiModelVersionInputExampleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_version_input_examples.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_version_input_examples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_version_input_examples {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelVersionInputExampleResponse {
        MultiModelVersionInputExampleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_version_input_examples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelVersionInputExampleResponse {
        static instance: MultiModelVersionInputExampleResponse = MultiModelVersionInputExampleResponse {
            status: ::protobuf::MessageField::none(),
            model_version_input_examples: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelVersionInputExampleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelVersionInputExampleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelVersionInputExampleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionInputExampleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModelReferencesRequest
// @@protoc_insertion_point(message:clarifai.api.ListModelReferencesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModelReferencesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.model_id)
    pub model_id: ::std::string::String,
    ///  Optional, defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.page)
    pub page: u32,
    ///  Optional, defaults to 128 references per page.
    // @@protoc_insertion_point(field:clarifai.api.ListModelReferencesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModelReferencesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModelReferencesRequest {
    fn default() -> &'a ListModelReferencesRequest {
        <ListModelReferencesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelReferencesRequest {
    pub fn new() -> ListModelReferencesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModelReferencesRequest| { &m.user_app_id },
            |m: &mut ListModelReferencesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ListModelReferencesRequest| { &m.model_id },
            |m: &mut ListModelReferencesRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModelReferencesRequest| { &m.page },
            |m: &mut ListModelReferencesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModelReferencesRequest| { &m.per_page },
            |m: &mut ListModelReferencesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModelReferencesRequest>(
            "ListModelReferencesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModelReferencesRequest {
    const NAME: &'static str = "ListModelReferencesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModelReferencesRequest {
        ListModelReferencesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModelReferencesRequest {
        static instance: ListModelReferencesRequest = ListModelReferencesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModelReferencesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModelReferencesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModelReferencesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelReferencesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModelReferenceResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModelReferenceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModelReferenceResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModelReferenceResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModelReferenceResponse.model_references)
    pub model_references: ::std::vec::Vec<super::resources::ModelReference>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModelReferenceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModelReferenceResponse {
    fn default() -> &'a MultiModelReferenceResponse {
        <MultiModelReferenceResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelReferenceResponse {
    pub fn new() -> MultiModelReferenceResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModelReferenceResponse| { &m.status },
            |m: &mut MultiModelReferenceResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_references",
            |m: &MultiModelReferenceResponse| { &m.model_references },
            |m: &mut MultiModelReferenceResponse| { &mut m.model_references },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModelReferenceResponse>(
            "MultiModelReferenceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModelReferenceResponse {
    const NAME: &'static str = "MultiModelReferenceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.model_references.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.model_references {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.model_references {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModelReferenceResponse {
        MultiModelReferenceResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.model_references.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModelReferenceResponse {
        static instance: MultiModelReferenceResponse = MultiModelReferenceResponse {
            status: ::protobuf::MessageField::none(),
            model_references: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModelReferenceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModelReferenceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModelReferenceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelReferenceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiOutputResponse
// @@protoc_insertion_point(message:clarifai.api.MultiOutputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiOutputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiOutputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  For each input processed during model prediction we create one output.
    // @@protoc_insertion_point(field:clarifai.api.MultiOutputResponse.outputs)
    pub outputs: ::std::vec::Vec<super::resources::Output>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiOutputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiOutputResponse {
    fn default() -> &'a MultiOutputResponse {
        <MultiOutputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiOutputResponse {
    pub fn new() -> MultiOutputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiOutputResponse| { &m.status },
            |m: &mut MultiOutputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &MultiOutputResponse| { &m.outputs },
            |m: &mut MultiOutputResponse| { &mut m.outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiOutputResponse>(
            "MultiOutputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiOutputResponse {
    const NAME: &'static str = "MultiOutputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiOutputResponse {
        MultiOutputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiOutputResponse {
        static instance: MultiOutputResponse = MultiOutputResponse {
            status: ::protobuf::MessageField::none(),
            outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiOutputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiOutputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiOutputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListScopesRequest
// @@protoc_insertion_point(message:clarifai.api.ListScopesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListScopesRequest {
    // message fields
    ///  If "personal_access_token" include scopes and endpoints available to personal access tokens.
    ///  If "app_specific_key" include scopes and endpoints available to app-specific keys. (default)
    // @@protoc_insertion_point(field:clarifai.api.ListScopesRequest.key_type)
    pub key_type: ::std::string::String,
    ///  For all user specific information we include user_app_id to get the user_id in a consistent way
    // @@protoc_insertion_point(field:clarifai.api.ListScopesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListScopesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListScopesRequest {
    fn default() -> &'a ListScopesRequest {
        <ListScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListScopesRequest {
    pub fn new() -> ListScopesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_type",
            |m: &ListScopesRequest| { &m.key_type },
            |m: &mut ListScopesRequest| { &mut m.key_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListScopesRequest| { &m.user_app_id },
            |m: &mut ListScopesRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListScopesRequest>(
            "ListScopesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListScopesRequest {
    const NAME: &'static str = "ListScopesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key_type = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key_type);
        }
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key_type.is_empty() {
            os.write_string(1, &self.key_type)?;
        }
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListScopesRequest {
        ListScopesRequest::new()
    }

    fn clear(&mut self) {
        self.key_type.clear();
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListScopesRequest {
        static instance: ListScopesRequest = ListScopesRequest {
            key_type: ::std::string::String::new(),
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListScopesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListScopesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListScopesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesRequest
// @@protoc_insertion_point(message:clarifai.api.MyScopesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MyScopesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MyScopesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesRequest {
    fn default() -> &'a MyScopesRequest {
        <MyScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRequest {
    pub fn new() -> MyScopesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &MyScopesRequest| { &m.user_app_id },
            |m: &mut MyScopesRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesRequest>(
            "MyScopesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesRequest {
    const NAME: &'static str = "MyScopesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesRequest {
        MyScopesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesRequest {
        static instance: MyScopesRequest = MyScopesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesUserRequest
// @@protoc_insertion_point(message:clarifai.api.MyScopesUserRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MyScopesUserRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MyScopesUserRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesUserRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesUserRequest {
    fn default() -> &'a MyScopesUserRequest {
        <MyScopesUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesUserRequest {
    pub fn new() -> MyScopesUserRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &MyScopesUserRequest| { &m.user_app_id },
            |m: &mut MyScopesUserRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesUserRequest>(
            "MyScopesUserRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesUserRequest {
    const NAME: &'static str = "MyScopesUserRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesUserRequest {
        MyScopesUserRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesUserRequest {
        static instance: MyScopesUserRequest = MyScopesUserRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesUserRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesUserRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesUserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesUserRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MyScopesRootRequest
// @@protoc_insertion_point(message:clarifai.api.MyScopesRootRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MyScopesRootRequest {
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MyScopesRootRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyScopesRootRequest {
    fn default() -> &'a MyScopesRootRequest {
        <MyScopesRootRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRootRequest {
    pub fn new() -> MyScopesRootRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MyScopesRootRequest>(
            "MyScopesRootRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MyScopesRootRequest {
    const NAME: &'static str = "MyScopesRootRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyScopesRootRequest {
        MyScopesRootRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyScopesRootRequest {
        static instance: MyScopesRootRequest = MyScopesRootRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MyScopesRootRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyScopesRootRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyScopesRootRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRootRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeDepsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiScopeDepsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiScopeDepsResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  scopes is a list of low-level scopes and their dependencies.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.scope_deps)
    pub scope_deps: ::std::vec::Vec<super::resources::ScopeDeps>,
    ///  endpoint_scopes is a listof all the publicly available endponts which can be
    ///  used as scopes as well. A call to each of those endpoint depends on a subset
    ///  of the above "scopes"
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeDepsResponse.endpoint_deps)
    pub endpoint_deps: ::std::vec::Vec<super::resources::EndpointDeps>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeDepsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeDepsResponse {
    fn default() -> &'a MultiScopeDepsResponse {
        <MultiScopeDepsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeDepsResponse {
    pub fn new() -> MultiScopeDepsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeDepsResponse| { &m.status },
            |m: &mut MultiScopeDepsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scope_deps",
            |m: &MultiScopeDepsResponse| { &m.scope_deps },
            |m: &mut MultiScopeDepsResponse| { &mut m.scope_deps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoint_deps",
            |m: &MultiScopeDepsResponse| { &m.endpoint_deps },
            |m: &mut MultiScopeDepsResponse| { &mut m.endpoint_deps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeDepsResponse>(
            "MultiScopeDepsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeDepsResponse {
    const NAME: &'static str = "MultiScopeDepsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scope_deps.push(is.read_message()?);
                },
                26 => {
                    self.endpoint_deps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scope_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.endpoint_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scope_deps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.endpoint_deps {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeDepsResponse {
        MultiScopeDepsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scope_deps.clear();
        self.endpoint_deps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeDepsResponse {
        static instance: MultiScopeDepsResponse = MultiScopeDepsResponse {
            status: ::protobuf::MessageField::none(),
            scope_deps: ::std::vec::Vec::new(),
            endpoint_deps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeDepsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeDepsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeDepsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeDepsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeResponse
// @@protoc_insertion_point(message:clarifai.api.MultiScopeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiScopeResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  The app that the key has access to.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.app)
    pub app: ::protobuf::MessageField<super::resources::App>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeResponse {
    fn default() -> &'a MultiScopeResponse {
        <MultiScopeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeResponse {
    pub fn new() -> MultiScopeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeResponse| { &m.status },
            |m: &mut MultiScopeResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeResponse| { &m.scopes },
            |m: &mut MultiScopeResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::App>(
            "app",
            |m: &MultiScopeResponse| { &m.app },
            |m: &mut MultiScopeResponse| { &mut m.app },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeResponse| { &m.endpoints },
            |m: &mut MultiScopeResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeResponse>(
            "MultiScopeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeResponse {
    const NAME: &'static str = "MultiScopeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app)?;
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.app.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeResponse {
        MultiScopeResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.app.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeResponse {
        static instance: MultiScopeResponse = MultiScopeResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            app: ::protobuf::MessageField::none(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeUserResponse
// @@protoc_insertion_point(message:clarifai.api.MultiScopeUserResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiScopeUserResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeUserResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeUserResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeUserResponse {
    fn default() -> &'a MultiScopeUserResponse {
        <MultiScopeUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeUserResponse {
    pub fn new() -> MultiScopeUserResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeUserResponse| { &m.status },
            |m: &mut MultiScopeUserResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeUserResponse| { &m.scopes },
            |m: &mut MultiScopeUserResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeUserResponse| { &m.endpoints },
            |m: &mut MultiScopeUserResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeUserResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeUserResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeUserResponse>(
            "MultiScopeUserResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeUserResponse {
    const NAME: &'static str = "MultiScopeUserResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeUserResponse {
        MultiScopeUserResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeUserResponse {
        static instance: MultiScopeUserResponse = MultiScopeUserResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeUserResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeUserResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeUserResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiScopeRootResponse
// @@protoc_insertion_point(message:clarifai.api.MultiScopeRootResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiScopeRootResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  This is a list of the scopes that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.scopes)
    pub scopes: ::std::vec::Vec<::std::string::String>,
    ///  This is a list of endpoint permissions that your key has.
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.endpoints)
    pub endpoints: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.MultiScopeRootResponse.user_feature_flags)
    pub user_feature_flags: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiScopeRootResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiScopeRootResponse {
    fn default() -> &'a MultiScopeRootResponse {
        <MultiScopeRootResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeRootResponse {
    pub fn new() -> MultiScopeRootResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiScopeRootResponse| { &m.status },
            |m: &mut MultiScopeRootResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scopes",
            |m: &MultiScopeRootResponse| { &m.scopes },
            |m: &mut MultiScopeRootResponse| { &mut m.scopes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpoints",
            |m: &MultiScopeRootResponse| { &m.endpoints },
            |m: &mut MultiScopeRootResponse| { &mut m.endpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_feature_flags",
            |m: &MultiScopeRootResponse| { &m.user_feature_flags },
            |m: &mut MultiScopeRootResponse| { &mut m.user_feature_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiScopeRootResponse>(
            "MultiScopeRootResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiScopeRootResponse {
    const NAME: &'static str = "MultiScopeRootResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.scopes.push(is.read_string()?);
                },
                34 => {
                    self.endpoints.push(is.read_string()?);
                },
                42 => {
                    self.user_feature_flags = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.user_feature_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_feature_flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        if !self.user_feature_flags.is_empty() {
            os.write_string(5, &self.user_feature_flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiScopeRootResponse {
        MultiScopeRootResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.user_feature_flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiScopeRootResponse {
        static instance: MultiScopeRootResponse = MultiScopeRootResponse {
            status: ::protobuf::MessageField::none(),
            scopes: ::std::vec::Vec::new(),
            endpoints: ::std::vec::Vec::new(),
            user_feature_flags: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiScopeRootResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiScopeRootResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiScopeRootResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeRootResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetSearchRequest
// @@protoc_insertion_point(message:clarifai.api.GetSearchRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSearchRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetSearchRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetSearchRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetSearchRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSearchRequest {
    fn default() -> &'a GetSearchRequest {
        <GetSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSearchRequest {
    pub fn new() -> GetSearchRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetSearchRequest| { &m.user_app_id },
            |m: &mut GetSearchRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetSearchRequest| { &m.id },
            |m: &mut GetSearchRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSearchRequest>(
            "GetSearchRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSearchRequest {
    const NAME: &'static str = "GetSearchRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSearchRequest {
        GetSearchRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSearchRequest {
        static instance: GetSearchRequest = GetSearchRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSearchRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSearchRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSearchRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListSearchesRequest
// @@protoc_insertion_point(message:clarifai.api.ListSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListSearchesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListSearchesRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListSearchesRequest {
    fn default() -> &'a ListSearchesRequest {
        <ListSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSearchesRequest {
    pub fn new() -> ListSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListSearchesRequest| { &m.user_app_id },
            |m: &mut ListSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListSearchesRequest| { &m.page },
            |m: &mut ListSearchesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListSearchesRequest| { &m.per_page },
            |m: &mut ListSearchesRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListSearchesRequest>(
            "ListSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListSearchesRequest {
    const NAME: &'static str = "ListSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListSearchesRequest {
        ListSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListSearchesRequest {
        static instance: ListSearchesRequest = ListSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostSearchesRequest
// @@protoc_insertion_point(message:clarifai.api.PostSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The query; this specifies how the data to be searched
    ///  this will be replaced by "Searches"
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.query)
    pub query: ::protobuf::MessageField<super::resources::Query>,
    ///  The searched to be executed or saved
    ///  Eventually the request level fields will be deprecated in favor of this object
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostSearchesRequest {
    fn default() -> &'a PostSearchesRequest {
        <PostSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesRequest {
    pub fn new() -> PostSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostSearchesRequest| { &m.user_app_id },
            |m: &mut PostSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Query>(
            "query",
            |m: &PostSearchesRequest| { &m.query },
            |m: &mut PostSearchesRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostSearchesRequest| { &m.searches },
            |m: &mut PostSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostSearchesRequest| { &m.pagination },
            |m: &mut PostSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostSearchesRequest>(
            "PostSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostSearchesRequest {
    const NAME: &'static str = "PostSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query)?;
                },
                26 => {
                    self.searches.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostSearchesRequest {
        PostSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.query.clear();
        self.searches.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostSearchesRequest {
        static instance: PostSearchesRequest = PostSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            query: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchInputsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchInputsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchInputsSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchInputsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchInputsSearchesRequest {
    fn default() -> &'a PatchInputsSearchesRequest {
        <PatchInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsSearchesRequest {
    pub fn new() -> PatchInputsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchInputsSearchesRequest| { &m.user_app_id },
            |m: &mut PatchInputsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchInputsSearchesRequest| { &m.searches },
            |m: &mut PatchInputsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchInputsSearchesRequest| { &m.action },
            |m: &mut PatchInputsSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchInputsSearchesRequest>(
            "PatchInputsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchInputsSearchesRequest {
    const NAME: &'static str = "PatchInputsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchInputsSearchesRequest {
        PatchInputsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchInputsSearchesRequest {
        static instance: PatchInputsSearchesRequest = PatchInputsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchInputsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchInputsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationsSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsSearchesRequest {
    fn default() -> &'a PatchAnnotationsSearchesRequest {
        <PatchAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsSearchesRequest {
    pub fn new() -> PatchAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationsSearchesRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchAnnotationsSearchesRequest| { &m.searches },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationsSearchesRequest| { &m.action },
            |m: &mut PatchAnnotationsSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationsSearchesRequest>(
            "PatchAnnotationsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationsSearchesRequest {
    const NAME: &'static str = "PatchAnnotationsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationsSearchesRequest {
        PatchAnnotationsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationsSearchesRequest {
        static instance: PatchAnnotationsSearchesRequest = PatchAnnotationsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchSearchesRequest
// @@protoc_insertion_point(message:clarifai.api.PatchSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searches to be patched
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The action to perform on the patched Search objects
    ///  For now only action 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchSearchesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchSearchesRequest {
    fn default() -> &'a PatchSearchesRequest {
        <PatchSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchSearchesRequest {
    pub fn new() -> PatchSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchSearchesRequest| { &m.user_app_id },
            |m: &mut PatchSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PatchSearchesRequest| { &m.searches },
            |m: &mut PatchSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchSearchesRequest| { &m.action },
            |m: &mut PatchSearchesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchSearchesRequest>(
            "PatchSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchSearchesRequest {
    const NAME: &'static str = "PatchSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchSearchesRequest {
        PatchSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchSearchesRequest {
        static instance: PatchSearchesRequest = PatchSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostSearchesByIDRequest performs returns results of a saved search given its ID
// @@protoc_insertion_point(message:clarifai.api.PostSearchesByIDRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostSearchesByIDRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  ID for saves search to be executed
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.id)
    pub id: ::std::string::String,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostSearchesByIDRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostSearchesByIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostSearchesByIDRequest {
    fn default() -> &'a PostSearchesByIDRequest {
        <PostSearchesByIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesByIDRequest {
    pub fn new() -> PostSearchesByIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostSearchesByIDRequest| { &m.user_app_id },
            |m: &mut PostSearchesByIDRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PostSearchesByIDRequest| { &m.id },
            |m: &mut PostSearchesByIDRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostSearchesByIDRequest| { &m.pagination },
            |m: &mut PostSearchesByIDRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostSearchesByIDRequest>(
            "PostSearchesByIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostSearchesByIDRequest {
    const NAME: &'static str = "PostSearchesByIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostSearchesByIDRequest {
        PostSearchesByIDRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostSearchesByIDRequest {
        static instance: PostSearchesByIDRequest = PostSearchesByIDRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostSearchesByIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostSearchesByIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostSearchesByIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesByIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteSearchRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteSearchRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteSearchRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteSearchRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteSearchRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteSearchRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSearchRequest {
    fn default() -> &'a DeleteSearchRequest {
        <DeleteSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSearchRequest {
    pub fn new() -> DeleteSearchRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteSearchRequest| { &m.user_app_id },
            |m: &mut DeleteSearchRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteSearchRequest| { &m.id },
            |m: &mut DeleteSearchRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSearchRequest>(
            "DeleteSearchRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSearchRequest {
    const NAME: &'static str = "DeleteSearchRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSearchRequest {
        DeleteSearchRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSearchRequest {
        static instance: DeleteSearchRequest = DeleteSearchRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSearchRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSearchRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSearchRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Execute a new annotation search and optionally save it
///  annotation search over annotations using rank and filter proto
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAnnotationsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searched to be executed or saved
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsSearchesRequest {
    fn default() -> &'a PostAnnotationsSearchesRequest {
        <PostAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsSearchesRequest {
    pub fn new() -> PostAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationsSearchesRequest| { &m.user_app_id },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostAnnotationsSearchesRequest| { &m.searches },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostAnnotationsSearchesRequest| { &m.pagination },
            |m: &mut PostAnnotationsSearchesRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationsSearchesRequest>(
            "PostAnnotationsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationsSearchesRequest {
    const NAME: &'static str = "PostAnnotationsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationsSearchesRequest {
        PostAnnotationsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationsSearchesRequest {
        static instance: PostAnnotationsSearchesRequest = PostAnnotationsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteAnnotationSearchMetricsRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationSearchMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationSearchMetricsRequest {
    fn default() -> &'a DeleteAnnotationSearchMetricsRequest {
        <DeleteAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationSearchMetricsRequest {
    pub fn new() -> DeleteAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationSearchMetricsRequest>(
            "DeleteAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationSearchMetricsRequest {
    const NAME: &'static str = "DeleteAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationSearchMetricsRequest {
        DeleteAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationSearchMetricsRequest {
        static instance: DeleteAnnotationSearchMetricsRequest = DeleteAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Execute a new input search and optionally save it
// @@protoc_insertion_point(message:clarifai.api.PostInputsSearchesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInputsSearchesRequest {
    // message fields
    ///  The user_id and app_id to query from.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The searched to be executed or saved
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  Pagination information to paginate through search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    ///  If only_count is set, then the response will not contain hits,
    ///  but hit_counts instead.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsSearchesRequest.only_count)
    pub only_count: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsSearchesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsSearchesRequest {
    fn default() -> &'a PostInputsSearchesRequest {
        <PostInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsSearchesRequest {
    pub fn new() -> PostInputsSearchesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsSearchesRequest| { &m.user_app_id },
            |m: &mut PostInputsSearchesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &PostInputsSearchesRequest| { &m.searches },
            |m: &mut PostInputsSearchesRequest| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &PostInputsSearchesRequest| { &m.pagination },
            |m: &mut PostInputsSearchesRequest| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "only_count",
            |m: &PostInputsSearchesRequest| { &m.only_count },
            |m: &mut PostInputsSearchesRequest| { &mut m.only_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsSearchesRequest>(
            "PostInputsSearchesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsSearchesRequest {
    const NAME: &'static str = "PostInputsSearchesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.searches.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                32 => {
                    self.only_count = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.only_count != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.only_count != false {
            os.write_bool(4, self.only_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsSearchesRequest {
        PostInputsSearchesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.only_count = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsSearchesRequest {
        static instance: PostInputsSearchesRequest = PostInputsSearchesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            only_count: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsSearchesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsSearchesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsSearchesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleSearchResponse returns saved search in response to GetSearchRequest
// @@protoc_insertion_point(message:clarifai.api.SingleSearchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleSearchResponse {
    // message fields
    ///  Status of whether the search was successful.
    // @@protoc_insertion_point(field:clarifai.api.SingleSearchResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleSearchResponse.search)
    pub search: ::protobuf::MessageField<super::resources::Search>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleSearchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleSearchResponse {
    fn default() -> &'a SingleSearchResponse {
        <SingleSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleSearchResponse {
    pub fn new() -> SingleSearchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleSearchResponse| { &m.status },
            |m: &mut SingleSearchResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search",
            |m: &SingleSearchResponse| { &m.search },
            |m: &mut SingleSearchResponse| { &mut m.search },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleSearchResponse>(
            "SingleSearchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleSearchResponse {
    const NAME: &'static str = "SingleSearchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.search.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleSearchResponse {
        SingleSearchResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.search.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleSearchResponse {
        static instance: SingleSearchResponse = SingleSearchResponse {
            status: ::protobuf::MessageField::none(),
            search: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleSearchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleSearchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleSearchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiSearchResponse
// @@protoc_insertion_point(message:clarifai.api.MultiSearchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiSearchResponse {
    // message fields
    ///  Status of whether the search was successful.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  A unique id which uniquely identifies a search
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.id)
    pub id: ::std::string::String,
    ///  The list of search result Hits.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.hits)
    pub hits: ::std::vec::Vec<super::resources::Hit>,
    ///  The original query provided in the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.query)
    pub query: ::protobuf::MessageField<super::resources::Query>,
    ///  The original Searches provided in the request.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.searches)
    pub searches: ::std::vec::Vec<super::resources::Search>,
    ///  The counts of hits for each search, in the same order as searches.
    ///  Only returned if the request set only_count.
    // @@protoc_insertion_point(field:clarifai.api.MultiSearchResponse.hit_counts)
    pub hit_counts: ::std::vec::Vec<super::resources::HitCount>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiSearchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiSearchResponse {
    fn default() -> &'a MultiSearchResponse {
        <MultiSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiSearchResponse {
    pub fn new() -> MultiSearchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiSearchResponse| { &m.status },
            |m: &mut MultiSearchResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &MultiSearchResponse| { &m.id },
            |m: &mut MultiSearchResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hits",
            |m: &MultiSearchResponse| { &m.hits },
            |m: &mut MultiSearchResponse| { &mut m.hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Query>(
            "query",
            |m: &MultiSearchResponse| { &m.query },
            |m: &mut MultiSearchResponse| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "searches",
            |m: &MultiSearchResponse| { &m.searches },
            |m: &mut MultiSearchResponse| { &mut m.searches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hit_counts",
            |m: &MultiSearchResponse| { &m.hit_counts },
            |m: &mut MultiSearchResponse| { &mut m.hit_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiSearchResponse>(
            "MultiSearchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiSearchResponse {
    const NAME: &'static str = "MultiSearchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    self.hits.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.query)?;
                },
                42 => {
                    self.searches.push(is.read_message()?);
                },
                50 => {
                    self.hit_counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.hit_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.hits {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.query.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.searches {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.hit_counts {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiSearchResponse {
        MultiSearchResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.id.clear();
        self.hits.clear();
        self.query.clear();
        self.searches.clear();
        self.hit_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiSearchResponse {
        static instance: MultiSearchResponse = MultiSearchResponse {
            status: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            hits: ::std::vec::Vec::new(),
            query: ::protobuf::MessageField::none(),
            searches: ::std::vec::Vec::new(),
            hit_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiSearchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiSearchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiSearchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostAnnotationSearchMetricsRequest
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationSearchMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  A unique customer facing id to identify this eval request
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    ///  The ground truth we are evaluating against
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.ground_truth)
    pub ground_truth: ::protobuf::MessageField<super::resources::Search>,
    ///  The set we are evaluating
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.search_to_eval)
    pub search_to_eval: ::protobuf::MessageField<super::resources::Search>,
    ///  List of concepts to evaluate are expected to be in data.concepts
    ///  If nil, then all app concepts are used
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.data)
    pub data: ::protobuf::MessageField<super::resources::Data>,
    ///  The type of evaluation to use
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationSearchMetricsRequest.evaluation_type)
    pub evaluation_type: ::protobuf::EnumOrUnknown<super::resources::EvaluationType>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationSearchMetricsRequest {
    fn default() -> &'a PostAnnotationSearchMetricsRequest {
        <PostAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationSearchMetricsRequest {
    pub fn new() -> PostAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PostAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "ground_truth",
            |m: &PostAnnotationSearchMetricsRequest| { &m.ground_truth },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.ground_truth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Search>(
            "search_to_eval",
            |m: &PostAnnotationSearchMetricsRequest| { &m.search_to_eval },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.search_to_eval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Data>(
            "data",
            |m: &PostAnnotationSearchMetricsRequest| { &m.data },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_type",
            |m: &PostAnnotationSearchMetricsRequest| { &m.evaluation_type },
            |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.evaluation_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationSearchMetricsRequest>(
            "PostAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationSearchMetricsRequest {
    const NAME: &'static str = "PostAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ground_truth)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.search_to_eval)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                48 => {
                    self.evaluation_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(v) = self.ground_truth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.search_to_eval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.evaluation_type != ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined) {
            my_size += ::protobuf::rt::int32_size(6, self.evaluation_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(v) = self.ground_truth.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.search_to_eval.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.evaluation_type != ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.evaluation_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationSearchMetricsRequest {
        PostAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.ground_truth.clear();
        self.search_to_eval.clear();
        self.data.clear();
        self.evaluation_type = ::protobuf::EnumOrUnknown::new(super::resources::EvaluationType::Undefined);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationSearchMetricsRequest {
        static instance: PostAnnotationSearchMetricsRequest = PostAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            ground_truth: ::protobuf::MessageField::none(),
            search_to_eval: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            evaluation_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationSearchMetricsRequest
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationSearchMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Unique custom facing id that identifies the eval to get
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationSearchMetricsRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationSearchMetricsRequest {
    fn default() -> &'a GetAnnotationSearchMetricsRequest {
        <GetAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationSearchMetricsRequest {
    pub fn new() -> GetAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetAnnotationSearchMetricsRequest| { &m.id },
            |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationSearchMetricsRequest>(
            "GetAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationSearchMetricsRequest {
    const NAME: &'static str = "GetAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationSearchMetricsRequest {
        GetAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationSearchMetricsRequest {
        static instance: GetAnnotationSearchMetricsRequest = GetAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationSearchMetricsRequest
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationSearchMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAnnotationSearchMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationSearchMetricsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationSearchMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationSearchMetricsRequest {
    fn default() -> &'a ListAnnotationSearchMetricsRequest {
        <ListAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationSearchMetricsRequest {
    pub fn new() -> ListAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationSearchMetricsRequest| { &m.user_app_id },
            |m: &mut ListAnnotationSearchMetricsRequest| { &mut m.user_app_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationSearchMetricsRequest>(
            "ListAnnotationSearchMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationSearchMetricsRequest {
    const NAME: &'static str = "ListAnnotationSearchMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationSearchMetricsRequest {
        ListAnnotationSearchMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationSearchMetricsRequest {
        static instance: ListAnnotationSearchMetricsRequest = ListAnnotationSearchMetricsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationSearchMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationSearchMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationSearchMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationSearchMetricsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationSearchMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAnnotationSearchMetricsResponse {
    // message fields
    ///  Status of the request
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationSearchMetricsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationSearchMetricsResponse.annotation_search_metrics)
    pub annotation_search_metrics: ::std::vec::Vec<super::resources::AnnotationSearchMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationSearchMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationSearchMetricsResponse {
    fn default() -> &'a MultiAnnotationSearchMetricsResponse {
        <MultiAnnotationSearchMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationSearchMetricsResponse {
    pub fn new() -> MultiAnnotationSearchMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationSearchMetricsResponse| { &m.status },
            |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_search_metrics",
            |m: &MultiAnnotationSearchMetricsResponse| { &m.annotation_search_metrics },
            |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.annotation_search_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationSearchMetricsResponse>(
            "MultiAnnotationSearchMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationSearchMetricsResponse {
    const NAME: &'static str = "MultiAnnotationSearchMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotation_search_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_search_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_search_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationSearchMetricsResponse {
        MultiAnnotationSearchMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_search_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationSearchMetricsResponse {
        static instance: MultiAnnotationSearchMetricsResponse = MultiAnnotationSearchMetricsResponse {
            status: ::protobuf::MessageField::none(),
            annotation_search_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationSearchMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationSearchMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationSearchMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationSearchMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListAnnotationFiltersRequest
// @@protoc_insertion_point(message:clarifai.api.ListAnnotationFiltersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAnnotationFiltersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAnnotationFiltersRequest {
    fn default() -> &'a ListAnnotationFiltersRequest {
        <ListAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationFiltersRequest {
    pub fn new() -> ListAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAnnotationFiltersRequest| { &m.page },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAnnotationFiltersRequest| { &m.per_page },
            |m: &mut ListAnnotationFiltersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAnnotationFiltersRequest>(
            "ListAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAnnotationFiltersRequest {
    const NAME: &'static str = "ListAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAnnotationFiltersRequest {
        ListAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAnnotationFiltersRequest {
        static instance: ListAnnotationFiltersRequest = ListAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetAnnotationFilterRequest
// @@protoc_insertion_point(message:clarifai.api.GetAnnotationFilterRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAnnotationFilterRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationFilterRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Identify annotation filter by id.
    // @@protoc_insertion_point(field:clarifai.api.GetAnnotationFilterRequest.annotation_filter_id)
    pub annotation_filter_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAnnotationFilterRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAnnotationFilterRequest {
    fn default() -> &'a GetAnnotationFilterRequest {
        <GetAnnotationFilterRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationFilterRequest {
    pub fn new() -> GetAnnotationFilterRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAnnotationFilterRequest| { &m.user_app_id },
            |m: &mut GetAnnotationFilterRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "annotation_filter_id",
            |m: &GetAnnotationFilterRequest| { &m.annotation_filter_id },
            |m: &mut GetAnnotationFilterRequest| { &mut m.annotation_filter_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAnnotationFilterRequest>(
            "GetAnnotationFilterRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAnnotationFilterRequest {
    const NAME: &'static str = "GetAnnotationFilterRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filter_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.annotation_filter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.annotation_filter_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.annotation_filter_id.is_empty() {
            os.write_string(2, &self.annotation_filter_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAnnotationFilterRequest {
        GetAnnotationFilterRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filter_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAnnotationFilterRequest {
        static instance: GetAnnotationFilterRequest = GetAnnotationFilterRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filter_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAnnotationFilterRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAnnotationFilterRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAnnotationFilterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationFilterRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to add one or more annotation filters.
// @@protoc_insertion_point(message:clarifai.api.PostAnnotationFiltersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of annotation filters that are requested to be added.
    // @@protoc_insertion_point(field:clarifai.api.PostAnnotationFiltersRequest.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAnnotationFiltersRequest {
    fn default() -> &'a PostAnnotationFiltersRequest {
        <PostAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationFiltersRequest {
    pub fn new() -> PostAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut PostAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &PostAnnotationFiltersRequest| { &m.annotation_filters },
            |m: &mut PostAnnotationFiltersRequest| { &mut m.annotation_filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAnnotationFiltersRequest>(
            "PostAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAnnotationFiltersRequest {
    const NAME: &'static str = "PostAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAnnotationFiltersRequest {
        PostAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAnnotationFiltersRequest {
        static instance: PostAnnotationFiltersRequest = PostAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch several annotation filters.
// @@protoc_insertion_point(message:clarifai.api.PatchAnnotationFiltersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of annotation filters that are requested to be updated.
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    ///  The action to perform on the patched objects
    ///  For now, only 'overwrite' action is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchAnnotationFiltersRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationFiltersRequest {
    fn default() -> &'a PatchAnnotationFiltersRequest {
        <PatchAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationFiltersRequest {
    pub fn new() -> PatchAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &PatchAnnotationFiltersRequest| { &m.annotation_filters },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.annotation_filters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchAnnotationFiltersRequest| { &m.action },
            |m: &mut PatchAnnotationFiltersRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchAnnotationFiltersRequest>(
            "PatchAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchAnnotationFiltersRequest {
    const NAME: &'static str = "PatchAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchAnnotationFiltersRequest {
        PatchAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filters.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchAnnotationFiltersRequest {
        static instance: PatchAnnotationFiltersRequest = PatchAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several annotation filters by list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteAnnotationFiltersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteAnnotationFiltersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationFiltersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Specify which filters to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteAnnotationFiltersRequest.annotation_filter_ids)
    pub annotation_filter_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteAnnotationFiltersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationFiltersRequest {
    fn default() -> &'a DeleteAnnotationFiltersRequest {
        <DeleteAnnotationFiltersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationFiltersRequest {
    pub fn new() -> DeleteAnnotationFiltersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteAnnotationFiltersRequest| { &m.user_app_id },
            |m: &mut DeleteAnnotationFiltersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filter_ids",
            |m: &DeleteAnnotationFiltersRequest| { &m.annotation_filter_ids },
            |m: &mut DeleteAnnotationFiltersRequest| { &mut m.annotation_filter_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteAnnotationFiltersRequest>(
            "DeleteAnnotationFiltersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteAnnotationFiltersRequest {
    const NAME: &'static str = "DeleteAnnotationFiltersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.annotation_filter_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filter_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filter_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteAnnotationFiltersRequest {
        DeleteAnnotationFiltersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_filter_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteAnnotationFiltersRequest {
        static instance: DeleteAnnotationFiltersRequest = DeleteAnnotationFiltersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            annotation_filter_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteAnnotationFiltersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteAnnotationFiltersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteAnnotationFiltersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationFiltersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAnnotationFilterResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAnnotationFilterResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAnnotationFilterResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationFilterResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAnnotationFilterResponse.annotation_filters)
    pub annotation_filters: ::std::vec::Vec<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAnnotationFilterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationFilterResponse {
    fn default() -> &'a MultiAnnotationFilterResponse {
        <MultiAnnotationFilterResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationFilterResponse {
    pub fn new() -> MultiAnnotationFilterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAnnotationFilterResponse| { &m.status },
            |m: &mut MultiAnnotationFilterResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation_filters",
            |m: &MultiAnnotationFilterResponse| { &m.annotation_filters },
            |m: &mut MultiAnnotationFilterResponse| { &mut m.annotation_filters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAnnotationFilterResponse>(
            "MultiAnnotationFilterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAnnotationFilterResponse {
    const NAME: &'static str = "MultiAnnotationFilterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.annotation_filters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.annotation_filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.annotation_filters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAnnotationFilterResponse {
        MultiAnnotationFilterResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_filters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAnnotationFilterResponse {
        static instance: MultiAnnotationFilterResponse = MultiAnnotationFilterResponse {
            status: ::protobuf::MessageField::none(),
            annotation_filters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAnnotationFilterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAnnotationFilterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAnnotationFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationFilterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAnnotationFilterResponse
// @@protoc_insertion_point(message:clarifai.api.SingleAnnotationFilterResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleAnnotationFilterResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationFilterResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAnnotationFilterResponse.annotation_filter)
    pub annotation_filter: ::protobuf::MessageField<super::resources::AnnotationFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAnnotationFilterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAnnotationFilterResponse {
    fn default() -> &'a SingleAnnotationFilterResponse {
        <SingleAnnotationFilterResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAnnotationFilterResponse {
    pub fn new() -> SingleAnnotationFilterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAnnotationFilterResponse| { &m.status },
            |m: &mut SingleAnnotationFilterResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AnnotationFilter>(
            "annotation_filter",
            |m: &SingleAnnotationFilterResponse| { &m.annotation_filter },
            |m: &mut SingleAnnotationFilterResponse| { &mut m.annotation_filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAnnotationFilterResponse>(
            "SingleAnnotationFilterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAnnotationFilterResponse {
    const NAME: &'static str = "SingleAnnotationFilterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.annotation_filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.annotation_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.annotation_filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAnnotationFilterResponse {
        SingleAnnotationFilterResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.annotation_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAnnotationFilterResponse {
        static instance: SingleAnnotationFilterResponse = SingleAnnotationFilterResponse {
            status: ::protobuf::MessageField::none(),
            annotation_filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAnnotationFilterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAnnotationFilterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAnnotationFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAnnotationFilterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetUserRequest
// @@protoc_insertion_point(message:clarifai.api.GetUserRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetUserRequest {
    // message fields
    ///  we used to have user_id but moved to the standard convention. Since this endpoint
    ///  hasn't been exposed and only used by portal as a url this won't effect anything external.
    // @@protoc_insertion_point(field:clarifai.api.GetUserRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.GetUserRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetUserRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserRequest {
    fn default() -> &'a GetUserRequest {
        <GetUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUserRequest {
    pub fn new() -> GetUserRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetUserRequest| { &m.user_app_id },
            |m: &mut GetUserRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetUserRequest| { &m.additional_fields },
            |m: &mut GetUserRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserRequest>(
            "GetUserRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserRequest {
    const NAME: &'static str = "GetUserRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.additional_fields {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserRequest {
        GetUserRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserRequest {
        static instance: GetUserRequest = GetUserRequest {
            user_app_id: ::protobuf::MessageField::none(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleUserResponse
// @@protoc_insertion_point(message:clarifai.api.SingleUserResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleUserResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleUserResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleUserResponse.user)
    pub user: ::protobuf::MessageField<super::resources::User>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleUserResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleUserResponse {
    fn default() -> &'a SingleUserResponse {
        <SingleUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleUserResponse {
    pub fn new() -> SingleUserResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleUserResponse| { &m.status },
            |m: &mut SingleUserResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::User>(
            "user",
            |m: &SingleUserResponse| { &m.user },
            |m: &mut SingleUserResponse| { &mut m.user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleUserResponse>(
            "SingleUserResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleUserResponse {
    const NAME: &'static str = "SingleUserResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleUserResponse {
        SingleUserResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.user.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleUserResponse {
        static instance: SingleUserResponse = SingleUserResponse {
            status: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleUserResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleUserResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleUserResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostValidatePasswordRequest
// @@protoc_insertion_point(message:clarifai.api.PostValidatePasswordRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostValidatePasswordRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostValidatePasswordRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  password to be validated
    // @@protoc_insertion_point(field:clarifai.api.PostValidatePasswordRequest.password)
    pub password: ::protobuf::MessageField<super::resources::Password>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostValidatePasswordRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostValidatePasswordRequest {
    fn default() -> &'a PostValidatePasswordRequest {
        <PostValidatePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostValidatePasswordRequest {
    pub fn new() -> PostValidatePasswordRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostValidatePasswordRequest| { &m.user_app_id },
            |m: &mut PostValidatePasswordRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Password>(
            "password",
            |m: &PostValidatePasswordRequest| { &m.password },
            |m: &mut PostValidatePasswordRequest| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostValidatePasswordRequest>(
            "PostValidatePasswordRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostValidatePasswordRequest {
    const NAME: &'static str = "PostValidatePasswordRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.password)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.password.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.password.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostValidatePasswordRequest {
        PostValidatePasswordRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostValidatePasswordRequest {
        static instance: PostValidatePasswordRequest = PostValidatePasswordRequest {
            user_app_id: ::protobuf::MessageField::none(),
            password: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostValidatePasswordRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostValidatePasswordRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostValidatePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostValidatePasswordRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SinglePasswordValidationResponse
// @@protoc_insertion_point(message:clarifai.api.SinglePasswordValidationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SinglePasswordValidationResponse {
    // message fields
    ///  Standard clarifai status code
    // @@protoc_insertion_point(field:clarifai.api.SinglePasswordValidationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SinglePasswordValidationResponse.password_violations)
    pub password_violations: ::protobuf::MessageField<super::resources::PasswordViolations>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SinglePasswordValidationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SinglePasswordValidationResponse {
    fn default() -> &'a SinglePasswordValidationResponse {
        <SinglePasswordValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SinglePasswordValidationResponse {
    pub fn new() -> SinglePasswordValidationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SinglePasswordValidationResponse| { &m.status },
            |m: &mut SinglePasswordValidationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::PasswordViolations>(
            "password_violations",
            |m: &SinglePasswordValidationResponse| { &m.password_violations },
            |m: &mut SinglePasswordValidationResponse| { &mut m.password_violations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SinglePasswordValidationResponse>(
            "SinglePasswordValidationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SinglePasswordValidationResponse {
    const NAME: &'static str = "SinglePasswordValidationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.password_violations)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.password_violations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.password_violations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SinglePasswordValidationResponse {
        SinglePasswordValidationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.password_violations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SinglePasswordValidationResponse {
        static instance: SinglePasswordValidationResponse = SinglePasswordValidationResponse {
            status: ::protobuf::MessageField::none(),
            password_violations: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SinglePasswordValidationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SinglePasswordValidationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SinglePasswordValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinglePasswordValidationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetWorkflowRequest
// @@protoc_insertion_point(message:clarifai.api.GetWorkflowRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWorkflowRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Workflow ID to retrieve
    ///  If no ID is specified we return default workflow of the application
    ///  If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  if true will not expand search to clarifai workflows
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowRequest.exclude_clarifai_workflows)
    pub exclude_clarifai_workflows: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetWorkflowRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWorkflowRequest {
    fn default() -> &'a GetWorkflowRequest {
        <GetWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowRequest {
    pub fn new() -> GetWorkflowRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetWorkflowRequest| { &m.user_app_id },
            |m: &mut GetWorkflowRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &GetWorkflowRequest| { &m.workflow_id },
            |m: &mut GetWorkflowRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &GetWorkflowRequest| { &m.favor_clarifai_workflows },
            |m: &mut GetWorkflowRequest| { &mut m.favor_clarifai_workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetWorkflowRequest| { &m.additional_fields },
            |m: &mut GetWorkflowRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "exclude_clarifai_workflows",
            |m: &GetWorkflowRequest| { &m.exclude_clarifai_workflows },
            |m: &mut GetWorkflowRequest| { &mut m.exclude_clarifai_workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetWorkflowRequest>(
            "GetWorkflowRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetWorkflowRequest {
    const NAME: &'static str = "GetWorkflowRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                24 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                34 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.exclude_clarifai_workflows = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.exclude_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(3, self.favor_clarifai_workflows)?;
        }
        for v in &self.additional_fields {
            os.write_string(4, &v)?;
        };
        if self.exclude_clarifai_workflows != false {
            os.write_bool(5, self.exclude_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWorkflowRequest {
        GetWorkflowRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.favor_clarifai_workflows = false;
        self.additional_fields.clear();
        self.exclude_clarifai_workflows = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWorkflowRequest {
        static instance: GetWorkflowRequest = GetWorkflowRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            favor_clarifai_workflows: false,
            additional_fields: ::std::vec::Vec::new(),
            exclude_clarifai_workflows: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetWorkflowRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetWorkflowRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListWorkflowsRequest
// @@protoc_insertion_point(message:clarifai.api.ListWorkflowsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.per_page)
    pub per_page: u32,
    ///  (optional URL parameter) List of additional fields to be included in the response. Currently supported: all, stars
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    ///  If true, we only return workflows that are handpicked by clarifai staff
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.featured_only)
    pub featured_only: bool,
    ///  If true, we only return workflows that are starred by the requesting user
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.starred_only)
    pub starred_only: bool,
    ///  Filter workflows by bookmark. If set, only return bookmarked workflows. Otherwise none bookmarked workflows only.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.bookmark)
    pub bookmark: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the workflow:
    ///    - id
    ///    - description
    ///    - notes
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.search)
    pub search: ::std::string::String,
    ///  Query various text fields (id, description and notes) that can contain the words in the query string.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.query)
    pub query: ::std::string::String,
    ///  Filter by the id of the workflow. This supports wilcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.id)
    pub id: ::std::string::String,
    ///  Full text and prefix matching on id, owner id, description and notes. Searchable fields may be added
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowsRequest.search_term)
    pub search_term: ::std::string::String,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_workflows_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListWorkflowsRequest {
    fn default() -> &'a ListWorkflowsRequest {
        <ListWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkflowsRequest {
    pub fn new() -> ListWorkflowsRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_id = 6;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(v))
    }

    // bool sort_by_modified_at = 7;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_created_at = 13;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 14;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListWorkflowsRequest| { &m.user_app_id },
            |m: &mut ListWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListWorkflowsRequest| { &m.page },
            |m: &mut ListWorkflowsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListWorkflowsRequest| { &m.per_page },
            |m: &mut ListWorkflowsRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListWorkflowsRequest| { &m.additional_fields },
            |m: &mut ListWorkflowsRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListWorkflowsRequest| { &m.sort_ascending },
            |m: &mut ListWorkflowsRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListWorkflowsRequest::has_sort_by_id,
            ListWorkflowsRequest::sort_by_id,
            ListWorkflowsRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListWorkflowsRequest::has_sort_by_modified_at,
            ListWorkflowsRequest::sort_by_modified_at,
            ListWorkflowsRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListWorkflowsRequest::has_sort_by_created_at,
            ListWorkflowsRequest::sort_by_created_at,
            ListWorkflowsRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListWorkflowsRequest::has_sort_by_star_count,
            ListWorkflowsRequest::sort_by_star_count,
            ListWorkflowsRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "featured_only",
            |m: &ListWorkflowsRequest| { &m.featured_only },
            |m: &mut ListWorkflowsRequest| { &mut m.featured_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListWorkflowsRequest| { &m.starred_only },
            |m: &mut ListWorkflowsRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListWorkflowsRequest| { &m.bookmark },
            |m: &mut ListWorkflowsRequest| { &mut m.bookmark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListWorkflowsRequest| { &m.search },
            |m: &mut ListWorkflowsRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &ListWorkflowsRequest| { &m.query },
            |m: &mut ListWorkflowsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListWorkflowsRequest| { &m.id },
            |m: &mut ListWorkflowsRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search_term",
            |m: &ListWorkflowsRequest| { &m.search_term },
            |m: &mut ListWorkflowsRequest| { &mut m.search_term },
        ));
        oneofs.push(list_workflows_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListWorkflowsRequest>(
            "ListWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListWorkflowsRequest {
    const NAME: &'static str = "ListWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                82 => {
                    self.additional_fields.push(is.read_string()?);
                },
                40 => {
                    self.sort_ascending = is.read_bool()?;
                },
                48 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortById(is.read_bool()?));
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                104 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                112 => {
                    self.sort_by = ::std::option::Option::Some(list_workflows_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.featured_only = is.read_bool()?;
                },
                88 => {
                    self.starred_only = is.read_bool()?;
                },
                120 => {
                    self.bookmark = is.read_bool()?;
                },
                130 => {
                    self.search = is.read_string()?;
                },
                66 => {
                    self.query = is.read_string()?;
                },
                34 => {
                    self.id = is.read_string()?;
                },
                98 => {
                    self.search_term = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.featured_only != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.search);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.query);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.id);
        }
        if !self.search_term.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.search_term);
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_workflows_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_workflows_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(10, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(5, self.sort_ascending)?;
        }
        if self.featured_only != false {
            os.write_bool(9, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(11, self.starred_only)?;
        }
        if self.bookmark != false {
            os.write_bool(15, self.bookmark)?;
        }
        if !self.search.is_empty() {
            os.write_string(16, &self.search)?;
        }
        if !self.query.is_empty() {
            os.write_string(8, &self.query)?;
        }
        if !self.id.is_empty() {
            os.write_string(4, &self.id)?;
        }
        if !self.search_term.is_empty() {
            os.write_string(12, &self.search_term)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_workflows_request::Sort_by::SortById(v) => {
                    os.write_bool(6, v)?;
                },
                &list_workflows_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_workflows_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(13, v)?;
                },
                &list_workflows_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(14, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListWorkflowsRequest {
        ListWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.featured_only = false;
        self.starred_only = false;
        self.bookmark = false;
        self.search.clear();
        self.query.clear();
        self.id.clear();
        self.search_term.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListWorkflowsRequest {
        static instance: ListWorkflowsRequest = ListWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            featured_only: false,
            starred_only: false,
            bookmark: false,
            search: ::std::string::String::new(),
            query: ::std::string::String::new(),
            id: ::std::string::String::new(),
            search_term: ::std::string::String::new(),
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListWorkflowsRequest`
pub mod list_workflows_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListWorkflowsRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_id)
        SortById(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListWorkflowsRequest.sort_by_star_count)
        SortByStarCount(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListWorkflowsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostWorkflowsRequest
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowsRequest.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowsRequest {
    fn default() -> &'a PostWorkflowsRequest {
        <PostWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowsRequest {
    pub fn new() -> PostWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowsRequest| { &m.user_app_id },
            |m: &mut PostWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &PostWorkflowsRequest| { &m.workflows },
            |m: &mut PostWorkflowsRequest| { &mut m.workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowsRequest>(
            "PostWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowsRequest {
    const NAME: &'static str = "PostWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowsRequest {
        PostWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowsRequest {
        static instance: PostWorkflowsRequest = PostWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    ///
    ///  Note that 'remove' can be used to remove the workflow image by setting
    ///  'image.url' in the request to the current value returned for that workflow.
    ///  This cannot be used in a request that is patching other fields as well.
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowsRequest {
    fn default() -> &'a PatchWorkflowsRequest {
        <PatchWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowsRequest {
    pub fn new() -> PatchWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &PatchWorkflowsRequest| { &m.workflows },
            |m: &mut PatchWorkflowsRequest| { &mut m.workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowsRequest| { &m.action },
            |m: &mut PatchWorkflowsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowsRequest>(
            "PatchWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowsRequest {
    const NAME: &'static str = "PatchWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowsRequest {
        PatchWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowsRequest {
        static instance: PatchWorkflowsRequest = PatchWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowIdsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowIdsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchWorkflowIdsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Array containing 1 entry
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.ids)
    pub ids: ::std::vec::Vec<IdUpdateSource>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowIdsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowIdsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowIdsRequest {
    fn default() -> &'a PatchWorkflowIdsRequest {
        <PatchWorkflowIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowIdsRequest {
    pub fn new() -> PatchWorkflowIdsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowIdsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &PatchWorkflowIdsRequest| { &m.ids },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowIdsRequest| { &m.action },
            |m: &mut PatchWorkflowIdsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowIdsRequest>(
            "PatchWorkflowIdsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowIdsRequest {
    const NAME: &'static str = "PatchWorkflowIdsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.ids.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowIdsRequest {
        PatchWorkflowIdsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowIdsRequest {
        static instance: PatchWorkflowIdsRequest = PatchWorkflowIdsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowIdsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowIdsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowIdsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteWorkflowRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteWorkflowRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowRequest {
    fn default() -> &'a DeleteWorkflowRequest {
        <DeleteWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowRequest {
    pub fn new() -> DeleteWorkflowRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &DeleteWorkflowRequest| { &m.workflow_id },
            |m: &mut DeleteWorkflowRequest| { &mut m.workflow_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowRequest>(
            "DeleteWorkflowRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowRequest {
    const NAME: &'static str = "DeleteWorkflowRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowRequest {
        DeleteWorkflowRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowRequest {
        static instance: DeleteWorkflowRequest = DeleteWorkflowRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteWorkflowsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowsRequest {
    fn default() -> &'a DeleteWorkflowsRequest {
        <DeleteWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowsRequest {
    pub fn new() -> DeleteWorkflowsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowsRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteWorkflowsRequest| { &m.ids },
            |m: &mut DeleteWorkflowsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteWorkflowsRequest| { &m.delete_all },
            |m: &mut DeleteWorkflowsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowsRequest>(
            "DeleteWorkflowsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowsRequest {
    const NAME: &'static str = "DeleteWorkflowsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowsRequest {
        DeleteWorkflowsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowsRequest {
        static instance: DeleteWorkflowsRequest = DeleteWorkflowsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleWorkflowResponse
// @@protoc_insertion_point(message:clarifai.api.SingleWorkflowResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleWorkflowResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowResponse.workflow)
    pub workflow: ::protobuf::MessageField<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleWorkflowResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowResponse {
    fn default() -> &'a SingleWorkflowResponse {
        <SingleWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowResponse {
    pub fn new() -> SingleWorkflowResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleWorkflowResponse| { &m.status },
            |m: &mut SingleWorkflowResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Workflow>(
            "workflow",
            |m: &SingleWorkflowResponse| { &m.workflow },
            |m: &mut SingleWorkflowResponse| { &mut m.workflow },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleWorkflowResponse>(
            "SingleWorkflowResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleWorkflowResponse {
    const NAME: &'static str = "SingleWorkflowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleWorkflowResponse {
        SingleWorkflowResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleWorkflowResponse {
        static instance: SingleWorkflowResponse = SingleWorkflowResponse {
            status: ::protobuf::MessageField::none(),
            workflow: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleWorkflowResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleWorkflowResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiWorkflowResponse
// @@protoc_insertion_point(message:clarifai.api.MultiWorkflowResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiWorkflowResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowResponse.workflows)
    pub workflows: ::std::vec::Vec<super::resources::Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiWorkflowResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowResponse {
    fn default() -> &'a MultiWorkflowResponse {
        <MultiWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowResponse {
    pub fn new() -> MultiWorkflowResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiWorkflowResponse| { &m.status },
            |m: &mut MultiWorkflowResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &MultiWorkflowResponse| { &m.workflows },
            |m: &mut MultiWorkflowResponse| { &mut m.workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiWorkflowResponse>(
            "MultiWorkflowResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiWorkflowResponse {
    const NAME: &'static str = "MultiWorkflowResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.workflows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiWorkflowResponse {
        MultiWorkflowResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiWorkflowResponse {
        static instance: MultiWorkflowResponse = MultiWorkflowResponse {
            status: ::protobuf::MessageField::none(),
            workflows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiWorkflowResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiWorkflowResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsRequest
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowResultsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Workflow ID to retrieve
    ///  If no ID is specified we return default workflow of the application
    ///  If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Workflow version ID to retrieve
    ///  If no ID is specified, latest workflow version is used
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.version_id)
    pub version_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.inputs)
    pub inputs: ::std::vec::Vec<super::resources::Input>,
    ///  FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
    ///  to be within models. This is not consistent with setting this on the request for post model
    ///  outputs where it is inside a model object. To make this consistent we would send in the
    ///  workflow object so that each model can have it's own output config. If nobody is setting
    ///  this OutputConfig it would probably be easier to just remove it for now to keep things simpler
    ///  and then it's more consistent we just don't support the OutputConfig on workflows.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.output_config)
    pub output_config: ::protobuf::MessageField<super::resources::OutputConfig>,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    ///  A workflow state to be maintained across PostWorkflowResults requests/responses.
    ///  If it is not sent in the initial request with workflow_state.id = "init" then no
    ///  state will be saved or returned in PostWorkflowResultsResponse.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsRequest.workflow_state)
    pub workflow_state: ::protobuf::MessageField<super::resources::WorkflowState>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsRequest {
    fn default() -> &'a PostWorkflowResultsRequest {
        <PostWorkflowResultsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsRequest {
    pub fn new() -> PostWorkflowResultsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowResultsRequest| { &m.user_app_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowResultsRequest| { &m.workflow_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostWorkflowResultsRequest| { &m.version_id },
            |m: &mut PostWorkflowResultsRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &PostWorkflowResultsRequest| { &m.inputs },
            |m: &mut PostWorkflowResultsRequest| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::OutputConfig>(
            "output_config",
            |m: &PostWorkflowResultsRequest| { &m.output_config },
            |m: &mut PostWorkflowResultsRequest| { &mut m.output_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &PostWorkflowResultsRequest| { &m.favor_clarifai_workflows },
            |m: &mut PostWorkflowResultsRequest| { &mut m.favor_clarifai_workflows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowState>(
            "workflow_state",
            |m: &PostWorkflowResultsRequest| { &m.workflow_state },
            |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsRequest>(
            "PostWorkflowResultsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsRequest {
    const NAME: &'static str = "PostWorkflowResultsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                58 => {
                    self.version_id = is.read_string()?;
                },
                26 => {
                    self.inputs.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output_config)?;
                },
                40 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        if let Some(v) = self.workflow_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(7, &self.version_id)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.output_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(5, self.favor_clarifai_workflows)?;
        }
        if let Some(v) = self.workflow_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsRequest {
        PostWorkflowResultsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.output_config.clear();
        self.favor_clarifai_workflows = false;
        self.workflow_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsRequest {
        static instance: PostWorkflowResultsRequest = PostWorkflowResultsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            inputs: ::std::vec::Vec::new(),
            output_config: ::protobuf::MessageField::none(),
            favor_clarifai_workflows: false,
            workflow_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsResponse
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowResultsResponse {
    // message fields
    ///  The status of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The workflow that was used in predictions with PostWorkflowResults
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.workflow)
    pub workflow: ::protobuf::MessageField<super::resources::Workflow>,
    ///  The resulting predictions of all models in the workflow.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.results)
    pub results: ::std::vec::Vec<super::resources::WorkflowResult>,
    ///  A workflow state to be maintained across PostWorkflowResults requests/responses.
    ///  This WorkflowState should be passed in to subsequent PostWorkflowResults calls
    ///  if you want to keep track of state across requests.
    ///  If no WorkflowState was initialized in a request then no WorkflowState will be returned in this
    ///  response.
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsResponse.workflow_state)
    pub workflow_state: ::protobuf::MessageField<super::resources::WorkflowState>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsResponse {
    fn default() -> &'a PostWorkflowResultsResponse {
        <PostWorkflowResultsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsResponse {
    pub fn new() -> PostWorkflowResultsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PostWorkflowResultsResponse| { &m.status },
            |m: &mut PostWorkflowResultsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Workflow>(
            "workflow",
            |m: &PostWorkflowResultsResponse| { &m.workflow },
            |m: &mut PostWorkflowResultsResponse| { &mut m.workflow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &PostWorkflowResultsResponse| { &m.results },
            |m: &mut PostWorkflowResultsResponse| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowState>(
            "workflow_state",
            |m: &PostWorkflowResultsResponse| { &m.workflow_state },
            |m: &mut PostWorkflowResultsResponse| { &mut m.workflow_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsResponse>(
            "PostWorkflowResultsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsResponse {
    const NAME: &'static str = "PostWorkflowResultsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow)?;
                },
                26 => {
                    self.results.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_state)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.workflow_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.workflow_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsResponse {
        PostWorkflowResultsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.results.clear();
        self.workflow_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsResponse {
        static instance: PostWorkflowResultsResponse = PostWorkflowResultsResponse {
            status: ::protobuf::MessageField::none(),
            workflow: ::protobuf::MessageField::none(),
            results: ::std::vec::Vec::new(),
            workflow_state: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsSimilarityRequest
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsSimilarityRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowResultsSimilarityRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Workflow version ID to retrieve
    ///  If no ID is specified, latest workflow version is used
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.version_id)
    pub version_id: ::std::string::String,
    ///  The specific model version whose outputs we are comparing
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.model_version_id)
    pub model_version_id: ::std::string::String,
    ///  Each probe is compared against every pool input
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.probe_inputs)
    pub probe_inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Each pool input is compared against ever probe input
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.pool_inputs)
    pub pool_inputs: ::std::vec::Vec<super::resources::Input>,
    ///  Use this flag to look into clarifai published workflows first for a Workflow ID
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityRequest.favor_clarifai_workflows)
    pub favor_clarifai_workflows: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsSimilarityRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityRequest {
    fn default() -> &'a PostWorkflowResultsSimilarityRequest {
        <PostWorkflowResultsSimilarityRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityRequest {
    pub fn new() -> PostWorkflowResultsSimilarityRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.user_app_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.workflow_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.version_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_version_id",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.model_version_id },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.model_version_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "probe_inputs",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.probe_inputs },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.probe_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pool_inputs",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.pool_inputs },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.pool_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "favor_clarifai_workflows",
            |m: &PostWorkflowResultsSimilarityRequest| { &m.favor_clarifai_workflows },
            |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.favor_clarifai_workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsSimilarityRequest>(
            "PostWorkflowResultsSimilarityRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityRequest {
    const NAME: &'static str = "PostWorkflowResultsSimilarityRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                58 => {
                    self.version_id = is.read_string()?;
                },
                26 => {
                    self.model_version_id = is.read_string()?;
                },
                34 => {
                    self.probe_inputs.push(is.read_message()?);
                },
                42 => {
                    self.pool_inputs.push(is.read_message()?);
                },
                48 => {
                    self.favor_clarifai_workflows = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        for value in &self.probe_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pool_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.favor_clarifai_workflows != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(7, &self.version_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        for v in &self.probe_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.pool_inputs {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.favor_clarifai_workflows != false {
            os.write_bool(6, self.favor_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsSimilarityRequest {
        PostWorkflowResultsSimilarityRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.version_id.clear();
        self.model_version_id.clear();
        self.probe_inputs.clear();
        self.pool_inputs.clear();
        self.favor_clarifai_workflows = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityRequest {
        static instance: PostWorkflowResultsSimilarityRequest = PostWorkflowResultsSimilarityRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            version_id: ::std::string::String::new(),
            model_version_id: ::std::string::String::new(),
            probe_inputs: ::std::vec::Vec::new(),
            pool_inputs: ::std::vec::Vec::new(),
            favor_clarifai_workflows: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsSimilarityRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsSimilarityRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsSimilarityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostWorkflowResultsSimilarityResponse
// @@protoc_insertion_point(message:clarifai.api.PostWorkflowResultsSimilarityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostWorkflowResultsSimilarityResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.PostWorkflowResultsSimilarityResponse.results)
    pub results: ::std::vec::Vec<super::resources::WorkflowResultsSimilarity>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostWorkflowResultsSimilarityResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityResponse {
    fn default() -> &'a PostWorkflowResultsSimilarityResponse {
        <PostWorkflowResultsSimilarityResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityResponse {
    pub fn new() -> PostWorkflowResultsSimilarityResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PostWorkflowResultsSimilarityResponse| { &m.status },
            |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &PostWorkflowResultsSimilarityResponse| { &m.results },
            |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostWorkflowResultsSimilarityResponse>(
            "PostWorkflowResultsSimilarityResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityResponse {
    const NAME: &'static str = "PostWorkflowResultsSimilarityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostWorkflowResultsSimilarityResponse {
        PostWorkflowResultsSimilarityResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityResponse {
        static instance: PostWorkflowResultsSimilarityResponse = PostWorkflowResultsSimilarityResponse {
            status: ::protobuf::MessageField::none(),
            results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostWorkflowResultsSimilarityResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostWorkflowResultsSimilarityResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostWorkflowResultsSimilarityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListWorkflowVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListWorkflowVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List versions for the workflow identified by this id
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListWorkflowVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListWorkflowVersionsRequest {
    fn default() -> &'a ListWorkflowVersionsRequest {
        <ListWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkflowVersionsRequest {
    pub fn new() -> ListWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &ListWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListWorkflowVersionsRequest| { &m.page },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListWorkflowVersionsRequest| { &m.per_page },
            |m: &mut ListWorkflowVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListWorkflowVersionsRequest>(
            "ListWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListWorkflowVersionsRequest {
    const NAME: &'static str = "ListWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListWorkflowVersionsRequest {
        ListWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListWorkflowVersionsRequest {
        static instance: ListWorkflowVersionsRequest = ListWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetWorkflowVersionRequest
// @@protoc_insertion_point(message:clarifai.api.GetWorkflowVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWorkflowVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested version.
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Get the identified by this id
    // @@protoc_insertion_point(field:clarifai.api.GetWorkflowVersionRequest.workflow_version_id)
    pub workflow_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetWorkflowVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWorkflowVersionRequest {
    fn default() -> &'a GetWorkflowVersionRequest {
        <GetWorkflowVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowVersionRequest {
    pub fn new() -> GetWorkflowVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetWorkflowVersionRequest| { &m.user_app_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &GetWorkflowVersionRequest| { &m.workflow_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_version_id",
            |m: &GetWorkflowVersionRequest| { &m.workflow_version_id },
            |m: &mut GetWorkflowVersionRequest| { &mut m.workflow_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetWorkflowVersionRequest>(
            "GetWorkflowVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetWorkflowVersionRequest {
    const NAME: &'static str = "GetWorkflowVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.workflow_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.workflow_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.workflow_version_id.is_empty() {
            os.write_string(3, &self.workflow_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWorkflowVersionRequest {
        GetWorkflowVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWorkflowVersionRequest {
        static instance: GetWorkflowVersionRequest = GetWorkflowVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetWorkflowVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetWorkflowVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetWorkflowVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DeleteWorkflowVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.DeleteWorkflowVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested versions to delete.
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Delete the versions identified by these ids
    // @@protoc_insertion_point(field:clarifai.api.DeleteWorkflowVersionsRequest.workflow_version_ids)
    pub workflow_version_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowVersionsRequest {
    fn default() -> &'a DeleteWorkflowVersionsRequest {
        <DeleteWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowVersionsRequest {
    pub fn new() -> DeleteWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &DeleteWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_version_ids",
            |m: &DeleteWorkflowVersionsRequest| { &m.workflow_version_ids },
            |m: &mut DeleteWorkflowVersionsRequest| { &mut m.workflow_version_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteWorkflowVersionsRequest>(
            "DeleteWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteWorkflowVersionsRequest {
    const NAME: &'static str = "DeleteWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_version_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.workflow_version_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.workflow_version_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteWorkflowVersionsRequest {
        DeleteWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_version_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteWorkflowVersionsRequest {
        static instance: DeleteWorkflowVersionsRequest = DeleteWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_version_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchWorkflowVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchWorkflowVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchWorkflowVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The id of the workflow that has the requested versions to patch.
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.workflow_id)
    pub workflow_id: ::std::string::String,
    ///  Patch these versions.
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.workflow_versions)
    pub workflow_versions: ::std::vec::Vec<super::resources::WorkflowVersion>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchWorkflowVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchWorkflowVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowVersionsRequest {
    fn default() -> &'a PatchWorkflowVersionsRequest {
        <PatchWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowVersionsRequest {
    pub fn new() -> PatchWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchWorkflowVersionsRequest| { &m.user_app_id },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "workflow_id",
            |m: &PatchWorkflowVersionsRequest| { &m.workflow_id },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.workflow_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_versions",
            |m: &PatchWorkflowVersionsRequest| { &m.workflow_versions },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.workflow_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchWorkflowVersionsRequest| { &m.action },
            |m: &mut PatchWorkflowVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchWorkflowVersionsRequest>(
            "PatchWorkflowVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchWorkflowVersionsRequest {
    const NAME: &'static str = "PatchWorkflowVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.workflow_id = is.read_string()?;
                },
                26 => {
                    self.workflow_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.workflow_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.workflow_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchWorkflowVersionsRequest {
        PatchWorkflowVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchWorkflowVersionsRequest {
        static instance: PatchWorkflowVersionsRequest = PatchWorkflowVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            workflow_id: ::std::string::String::new(),
            workflow_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchWorkflowVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchWorkflowVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiWorkflowVersionResponse
// @@protoc_insertion_point(message:clarifai.api.MultiWorkflowVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiWorkflowVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiWorkflowVersionResponse.workflow_versions)
    pub workflow_versions: ::std::vec::Vec<super::resources::WorkflowVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiWorkflowVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowVersionResponse {
    fn default() -> &'a MultiWorkflowVersionResponse {
        <MultiWorkflowVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowVersionResponse {
    pub fn new() -> MultiWorkflowVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiWorkflowVersionResponse| { &m.status },
            |m: &mut MultiWorkflowVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_versions",
            |m: &MultiWorkflowVersionResponse| { &m.workflow_versions },
            |m: &mut MultiWorkflowVersionResponse| { &mut m.workflow_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiWorkflowVersionResponse>(
            "MultiWorkflowVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiWorkflowVersionResponse {
    const NAME: &'static str = "MultiWorkflowVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.workflow_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.workflow_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.workflow_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiWorkflowVersionResponse {
        MultiWorkflowVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiWorkflowVersionResponse {
        static instance: MultiWorkflowVersionResponse = MultiWorkflowVersionResponse {
            status: ::protobuf::MessageField::none(),
            workflow_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiWorkflowVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiWorkflowVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiWorkflowVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleWorkflowVersionResponse
// @@protoc_insertion_point(message:clarifai.api.SingleWorkflowVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleWorkflowVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleWorkflowVersionResponse.workflow_version)
    pub workflow_version: ::protobuf::MessageField<super::resources::WorkflowVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleWorkflowVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowVersionResponse {
    fn default() -> &'a SingleWorkflowVersionResponse {
        <SingleWorkflowVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowVersionResponse {
    pub fn new() -> SingleWorkflowVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleWorkflowVersionResponse| { &m.status },
            |m: &mut SingleWorkflowVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::WorkflowVersion>(
            "workflow_version",
            |m: &SingleWorkflowVersionResponse| { &m.workflow_version },
            |m: &mut SingleWorkflowVersionResponse| { &mut m.workflow_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleWorkflowVersionResponse>(
            "SingleWorkflowVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleWorkflowVersionResponse {
    const NAME: &'static str = "SingleWorkflowVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflow_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.workflow_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.workflow_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleWorkflowVersionResponse {
        SingleWorkflowVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.workflow_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleWorkflowVersionResponse {
        static instance: SingleWorkflowVersionResponse = SingleWorkflowVersionResponse {
            status: ::protobuf::MessageField::none(),
            workflow_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleWorkflowVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleWorkflowVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleWorkflowVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to start app duplication jobs.
// @@protoc_insertion_point(message:clarifai.api.PostAppDuplicationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostAppDuplicationsRequest {
    // message fields
    ///  The user and application ID of the source application to duplicate.
    // @@protoc_insertion_point(field:clarifai.api.PostAppDuplicationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostAppDuplicationsRequest.app_duplications)
    pub app_duplications: ::std::vec::Vec<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostAppDuplicationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostAppDuplicationsRequest {
    fn default() -> &'a PostAppDuplicationsRequest {
        <PostAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppDuplicationsRequest {
    pub fn new() -> PostAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostAppDuplicationsRequest| { &m.user_app_id },
            |m: &mut PostAppDuplicationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_duplications",
            |m: &PostAppDuplicationsRequest| { &m.app_duplications },
            |m: &mut PostAppDuplicationsRequest| { &mut m.app_duplications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostAppDuplicationsRequest>(
            "PostAppDuplicationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostAppDuplicationsRequest {
    const NAME: &'static str = "PostAppDuplicationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.app_duplications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.app_duplications {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostAppDuplicationsRequest {
        PostAppDuplicationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostAppDuplicationsRequest {
        static instance: PostAppDuplicationsRequest = PostAppDuplicationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_duplications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostAppDuplicationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostAppDuplicationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppDuplicationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get an app duplication job.
// @@protoc_insertion_point(message:clarifai.api.GetAppDuplicationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAppDuplicationRequest {
    // message fields
    ///  The ID of the user that created the app duplication job.
    // @@protoc_insertion_point(field:clarifai.api.GetAppDuplicationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetAppDuplicationRequest.app_duplication_id)
    pub app_duplication_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetAppDuplicationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAppDuplicationRequest {
    fn default() -> &'a GetAppDuplicationRequest {
        <GetAppDuplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppDuplicationRequest {
    pub fn new() -> GetAppDuplicationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetAppDuplicationRequest| { &m.user_app_id },
            |m: &mut GetAppDuplicationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_duplication_id",
            |m: &GetAppDuplicationRequest| { &m.app_duplication_id },
            |m: &mut GetAppDuplicationRequest| { &mut m.app_duplication_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAppDuplicationRequest>(
            "GetAppDuplicationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAppDuplicationRequest {
    const NAME: &'static str = "GetAppDuplicationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.app_duplication_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_duplication_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_duplication_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.app_duplication_id.is_empty() {
            os.write_string(2, &self.app_duplication_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAppDuplicationRequest {
        GetAppDuplicationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplication_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAppDuplicationRequest {
        static instance: GetAppDuplicationRequest = GetAppDuplicationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            app_duplication_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAppDuplicationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAppDuplicationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAppDuplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppDuplicationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list all the app duplication jobs that a user created.
// @@protoc_insertion_point(message:clarifai.api.ListAppDuplicationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAppDuplicationsRequest {
    // message fields
    ///  The ID of the user whose app duplication jobs to list.
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListAppDuplicationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListAppDuplicationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAppDuplicationsRequest {
    fn default() -> &'a ListAppDuplicationsRequest {
        <ListAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppDuplicationsRequest {
    pub fn new() -> ListAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListAppDuplicationsRequest| { &m.user_app_id },
            |m: &mut ListAppDuplicationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListAppDuplicationsRequest| { &m.page },
            |m: &mut ListAppDuplicationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListAppDuplicationsRequest| { &m.per_page },
            |m: &mut ListAppDuplicationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListAppDuplicationsRequest>(
            "ListAppDuplicationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListAppDuplicationsRequest {
    const NAME: &'static str = "ListAppDuplicationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAppDuplicationsRequest {
        ListAppDuplicationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAppDuplicationsRequest {
        static instance: ListAppDuplicationsRequest = ListAppDuplicationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListAppDuplicationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListAppDuplicationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppDuplicationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiAppDuplicationsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiAppDuplicationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiAppDuplicationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiAppDuplicationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiAppDuplicationsResponse.app_duplications)
    pub app_duplications: ::std::vec::Vec<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiAppDuplicationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAppDuplicationsResponse {
    fn default() -> &'a MultiAppDuplicationsResponse {
        <MultiAppDuplicationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppDuplicationsResponse {
    pub fn new() -> MultiAppDuplicationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiAppDuplicationsResponse| { &m.status },
            |m: &mut MultiAppDuplicationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "app_duplications",
            |m: &MultiAppDuplicationsResponse| { &m.app_duplications },
            |m: &mut MultiAppDuplicationsResponse| { &mut m.app_duplications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAppDuplicationsResponse>(
            "MultiAppDuplicationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAppDuplicationsResponse {
    const NAME: &'static str = "MultiAppDuplicationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.app_duplications.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.app_duplications {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAppDuplicationsResponse {
        MultiAppDuplicationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_duplications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAppDuplicationsResponse {
        static instance: MultiAppDuplicationsResponse = MultiAppDuplicationsResponse {
            status: ::protobuf::MessageField::none(),
            app_duplications: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAppDuplicationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAppDuplicationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAppDuplicationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppDuplicationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleAppDuplicationResponse
// @@protoc_insertion_point(message:clarifai.api.SingleAppDuplicationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleAppDuplicationResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleAppDuplicationResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleAppDuplicationResponse.app_duplication)
    pub app_duplication: ::protobuf::MessageField<super::resources::AppDuplication>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleAppDuplicationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleAppDuplicationResponse {
    fn default() -> &'a SingleAppDuplicationResponse {
        <SingleAppDuplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppDuplicationResponse {
    pub fn new() -> SingleAppDuplicationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleAppDuplicationResponse| { &m.status },
            |m: &mut SingleAppDuplicationResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::AppDuplication>(
            "app_duplication",
            |m: &SingleAppDuplicationResponse| { &m.app_duplication },
            |m: &mut SingleAppDuplicationResponse| { &mut m.app_duplication },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleAppDuplicationResponse>(
            "SingleAppDuplicationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleAppDuplicationResponse {
    const NAME: &'static str = "SingleAppDuplicationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.app_duplication)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.app_duplication.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.app_duplication.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleAppDuplicationResponse {
        SingleAppDuplicationResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_duplication.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleAppDuplicationResponse {
        static instance: SingleAppDuplicationResponse = SingleAppDuplicationResponse {
            status: ::protobuf::MessageField::none(),
            app_duplication: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleAppDuplicationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleAppDuplicationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleAppDuplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppDuplicationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create Tasks.
// @@protoc_insertion_point(message:clarifai.api.PostTasksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostTasksRequest.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostTasksRequest {
    fn default() -> &'a PostTasksRequest {
        <PostTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTasksRequest {
    pub fn new() -> PostTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostTasksRequest| { &m.user_app_id },
            |m: &mut PostTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &PostTasksRequest| { &m.tasks },
            |m: &mut PostTasksRequest| { &mut m.tasks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostTasksRequest>(
            "PostTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostTasksRequest {
    const NAME: &'static str = "PostTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostTasksRequest {
        PostTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostTasksRequest {
        static instance: PostTasksRequest = PostTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get one task.
// @@protoc_insertion_point(message:clarifai.api.GetTaskRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTaskRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.task_id)
    pub task_id: ::std::string::String,
    ///  (optional URL parameter) List of additional fields to be included in the response.
    ///  Currently supported additional fields:
    ///  - all
    ///  - worker.users
    ///  - review.users
    ///  - metrics.work.inputs_count_estimated
    ///  - metrics.work.inputs_percent_estimated
    // @@protoc_insertion_point(field:clarifai.api.GetTaskRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetTaskRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTaskRequest {
    fn default() -> &'a GetTaskRequest {
        <GetTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskRequest {
    pub fn new() -> GetTaskRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetTaskRequest| { &m.user_app_id },
            |m: &mut GetTaskRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetTaskRequest| { &m.task_id },
            |m: &mut GetTaskRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetTaskRequest| { &m.additional_fields },
            |m: &mut GetTaskRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTaskRequest>(
            "GetTaskRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTaskRequest {
    const NAME: &'static str = "GetTaskRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTaskRequest {
        GetTaskRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTaskRequest {
        static instance: GetTaskRequest = GetTaskRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTaskRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTaskRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list multiple tasks.
// @@protoc_insertion_point(message:clarifai.api.ListTasksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.per_page)
    pub per_page: u32,
    ///  Get tasks that have ANY user from this list assigned as worker.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.worker_user_ids)
    pub worker_user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get tasks that have ANY user from this list assigned as reviewer.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.review_user_ids)
    pub review_user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get tasks that are associated to ANY label order from this list.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.label_order_ids)
    pub label_order_ids: ::std::vec::Vec<::std::string::String>,
    ///  Get label order tasks as well
    ///  It is automatically set to true if label_order_ids is set.
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.including_label_order_tasks)
    pub including_label_order_tasks: bool,
    ///  (optional URL parameter) List of additional fields to be included in the response.
    ///  Currently supported additional fields:
    ///  - all
    ///  - worker.users
    ///  - review.users
    ///  - metrics.work.inputs_count_estimated
    ///  - metrics.work.inputs_percent_estimated
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  (optional) task IDs to filter on
    // @@protoc_insertion_point(field:clarifai.api.ListTasksRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTasksRequest {
    fn default() -> &'a ListTasksRequest {
        <ListTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTasksRequest {
    pub fn new() -> ListTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListTasksRequest| { &m.user_app_id },
            |m: &mut ListTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListTasksRequest| { &m.page },
            |m: &mut ListTasksRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListTasksRequest| { &m.per_page },
            |m: &mut ListTasksRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "worker_user_ids",
            |m: &ListTasksRequest| { &m.worker_user_ids },
            |m: &mut ListTasksRequest| { &mut m.worker_user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "review_user_ids",
            |m: &ListTasksRequest| { &m.review_user_ids },
            |m: &mut ListTasksRequest| { &mut m.review_user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_order_ids",
            |m: &ListTasksRequest| { &m.label_order_ids },
            |m: &mut ListTasksRequest| { &mut m.label_order_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "including_label_order_tasks",
            |m: &ListTasksRequest| { &m.including_label_order_tasks },
            |m: &mut ListTasksRequest| { &mut m.including_label_order_tasks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListTasksRequest| { &m.additional_fields },
            |m: &mut ListTasksRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &ListTasksRequest| { &m.ids },
            |m: &mut ListTasksRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTasksRequest>(
            "ListTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTasksRequest {
    const NAME: &'static str = "ListTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                34 => {
                    self.worker_user_ids.push(is.read_string()?);
                },
                42 => {
                    self.review_user_ids.push(is.read_string()?);
                },
                66 => {
                    self.label_order_ids.push(is.read_string()?);
                },
                48 => {
                    self.including_label_order_tasks = is.read_bool()?;
                },
                58 => {
                    self.additional_fields.push(is.read_string()?);
                },
                74 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.worker_user_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.review_user_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.label_order_ids {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.including_label_order_tasks != false {
            my_size += 1 + 1;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.worker_user_ids {
            os.write_string(4, &v)?;
        };
        for v in &self.review_user_ids {
            os.write_string(5, &v)?;
        };
        for v in &self.label_order_ids {
            os.write_string(8, &v)?;
        };
        if self.including_label_order_tasks != false {
            os.write_bool(6, self.including_label_order_tasks)?;
        }
        for v in &self.additional_fields {
            os.write_string(7, &v)?;
        };
        for v in &self.ids {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTasksRequest {
        ListTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.worker_user_ids.clear();
        self.review_user_ids.clear();
        self.label_order_ids.clear();
        self.including_label_order_tasks = false;
        self.additional_fields.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTasksRequest {
        static instance: ListTasksRequest = ListTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            worker_user_ids: ::std::vec::Vec::new(),
            review_user_ids: ::std::vec::Vec::new(),
            label_order_ids: ::std::vec::Vec::new(),
            including_label_order_tasks: false,
            additional_fields: ::std::vec::Vec::new(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch a list of tasks.
// @@protoc_insertion_point(message:clarifai.api.PatchTasksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchTasksRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchTasksRequest {
    fn default() -> &'a PatchTasksRequest {
        <PatchTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchTasksRequest {
    pub fn new() -> PatchTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchTasksRequest| { &m.user_app_id },
            |m: &mut PatchTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &PatchTasksRequest| { &m.tasks },
            |m: &mut PatchTasksRequest| { &mut m.tasks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchTasksRequest| { &m.action },
            |m: &mut PatchTasksRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchTasksRequest>(
            "PatchTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchTasksRequest {
    const NAME: &'static str = "PatchTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchTasksRequest {
        PatchTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchTasksRequest {
        static instance: PatchTasksRequest = PatchTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete a list of tasks.
// @@protoc_insertion_point(message:clarifai.api.DeleteTasksRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteTasksRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteTasksRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteTasksRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteTasksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTasksRequest {
    fn default() -> &'a DeleteTasksRequest {
        <DeleteTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTasksRequest {
    pub fn new() -> DeleteTasksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteTasksRequest| { &m.user_app_id },
            |m: &mut DeleteTasksRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteTasksRequest| { &m.ids },
            |m: &mut DeleteTasksRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTasksRequest>(
            "DeleteTasksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTasksRequest {
    const NAME: &'static str = "DeleteTasksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTasksRequest {
        DeleteTasksRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTasksRequest {
        static instance: DeleteTasksRequest = DeleteTasksRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTasksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTasksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTasksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple Tasks.
// @@protoc_insertion_point(message:clarifai.api.MultiTaskResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiTaskResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTaskResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTaskResponse.tasks)
    pub tasks: ::std::vec::Vec<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTaskResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTaskResponse {
    fn default() -> &'a MultiTaskResponse {
        <MultiTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTaskResponse {
    pub fn new() -> MultiTaskResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTaskResponse| { &m.status },
            |m: &mut MultiTaskResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tasks",
            |m: &MultiTaskResponse| { &m.tasks },
            |m: &mut MultiTaskResponse| { &mut m.tasks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTaskResponse>(
            "MultiTaskResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTaskResponse {
    const NAME: &'static str = "MultiTaskResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.tasks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tasks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTaskResponse {
        MultiTaskResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.tasks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTaskResponse {
        static instance: MultiTaskResponse = MultiTaskResponse {
            status: ::protobuf::MessageField::none(),
            tasks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTaskResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTaskResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTaskResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a single Task.
// @@protoc_insertion_point(message:clarifai.api.SingleTaskResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleTaskResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskResponse.task)
    pub task: ::protobuf::MessageField<super::resources::Task>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleTaskResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleTaskResponse {
    fn default() -> &'a SingleTaskResponse {
        <SingleTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskResponse {
    pub fn new() -> SingleTaskResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleTaskResponse| { &m.status },
            |m: &mut SingleTaskResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Task>(
            "task",
            |m: &SingleTaskResponse| { &m.task },
            |m: &mut SingleTaskResponse| { &mut m.task },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleTaskResponse>(
            "SingleTaskResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleTaskResponse {
    const NAME: &'static str = "SingleTaskResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.task)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.task.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.task.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleTaskResponse {
        SingleTaskResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.task.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleTaskResponse {
        static instance: SingleTaskResponse = SingleTaskResponse {
            status: ::protobuf::MessageField::none(),
            task: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleTaskResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleTaskResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetTaskCountRequest can be used for fetching -
///  1. Task annotation count per user, per status
///  1. Task input count per user (i.e. task assignment count), per status
// @@protoc_insertion_point(message:clarifai.api.GetTaskCountRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTaskCountRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  task_id for which count per user per status is needed
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.task_id)
    pub task_id: ::std::string::String,
    ///  Only return counts for these user IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If model_version_ids or workflow_version_ids are also provided, these user_ids are OR'd with them as well because
    ///  we want the union of all worker (user, model or workflow) counts in the results.
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.user_ids)
    pub user_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return counts for these model version IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If user_ids or workflow_version_ids are also provided, these model_version_ids are OR'd with them as well because
    ///  we want the union of all worker (user, model or workflow) counts in the results.
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.model_version_ids)
    pub model_version_ids: ::std::vec::Vec<::std::string::String>,
    ///  Only return counts for these workflow version IDs, effectively operating as an
    ///  OR among them to filter down the results.
    ///  If user_ids or model_version_ids are also provided, these workflow_version_ids are OR'd with them as well because
    ///  we want the union of all worker (user, model or workflow) counts in the results.
    // @@protoc_insertion_point(field:clarifai.api.GetTaskCountRequest.workflow_version_ids)
    pub workflow_version_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetTaskCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTaskCountRequest {
    fn default() -> &'a GetTaskCountRequest {
        <GetTaskCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskCountRequest {
    pub fn new() -> GetTaskCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetTaskCountRequest| { &m.user_app_id },
            |m: &mut GetTaskCountRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &GetTaskCountRequest| { &m.task_id },
            |m: &mut GetTaskCountRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_ids",
            |m: &GetTaskCountRequest| { &m.user_ids },
            |m: &mut GetTaskCountRequest| { &mut m.user_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_version_ids",
            |m: &GetTaskCountRequest| { &m.model_version_ids },
            |m: &mut GetTaskCountRequest| { &mut m.model_version_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflow_version_ids",
            |m: &GetTaskCountRequest| { &m.workflow_version_ids },
            |m: &mut GetTaskCountRequest| { &mut m.workflow_version_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTaskCountRequest>(
            "GetTaskCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTaskCountRequest {
    const NAME: &'static str = "GetTaskCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.user_ids.push(is.read_string()?);
                },
                34 => {
                    self.model_version_ids.push(is.read_string()?);
                },
                42 => {
                    self.workflow_version_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.model_version_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.workflow_version_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.model_version_ids {
            os.write_string(4, &v)?;
        };
        for v in &self.workflow_version_ids {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTaskCountRequest {
        GetTaskCountRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.model_version_ids.clear();
        self.workflow_version_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTaskCountRequest {
        static instance: GetTaskCountRequest = GetTaskCountRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            user_ids: ::std::vec::Vec::new(),
            model_version_ids: ::std::vec::Vec::new(),
            workflow_version_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTaskCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTaskCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTaskCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleTaskCountResponse represents counts of task annotations or inputs (i.e. task assignments) for labelers in given task
// @@protoc_insertion_point(message:clarifai.api.SingleTaskCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleTaskCountResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.app_id)
    pub app_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.task_id)
    pub task_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.SingleTaskCountResponse.counts)
    pub counts: ::std::vec::Vec<super::resources::TaskStatusCountPerUser>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleTaskCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleTaskCountResponse {
    fn default() -> &'a SingleTaskCountResponse {
        <SingleTaskCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskCountResponse {
    pub fn new() -> SingleTaskCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleTaskCountResponse| { &m.status },
            |m: &mut SingleTaskCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_id",
            |m: &SingleTaskCountResponse| { &m.app_id },
            |m: &mut SingleTaskCountResponse| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &SingleTaskCountResponse| { &m.task_id },
            |m: &mut SingleTaskCountResponse| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "counts",
            |m: &SingleTaskCountResponse| { &m.counts },
            |m: &mut SingleTaskCountResponse| { &mut m.counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleTaskCountResponse>(
            "SingleTaskCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleTaskCountResponse {
    const NAME: &'static str = "SingleTaskCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.app_id = is.read_string()?;
                },
                26 => {
                    self.task_id = is.read_string()?;
                },
                34 => {
                    self.counts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.task_id);
        }
        for value in &self.counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(3, &self.task_id)?;
        }
        for v in &self.counts {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleTaskCountResponse {
        SingleTaskCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.app_id.clear();
        self.task_id.clear();
        self.counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleTaskCountResponse {
        static instance: SingleTaskCountResponse = SingleTaskCountResponse {
            status: ::protobuf::MessageField::none(),
            app_id: ::std::string::String::new(),
            task_id: ::std::string::String::new(),
            counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleTaskCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleTaskCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleTaskCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create label orders.
// @@protoc_insertion_point(message:clarifai.api.PostLabelOrdersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostLabelOrdersRequest.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostLabelOrdersRequest {
    fn default() -> &'a PostLabelOrdersRequest {
        <PostLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostLabelOrdersRequest {
    pub fn new() -> PostLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostLabelOrdersRequest| { &m.user_app_id },
            |m: &mut PostLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &PostLabelOrdersRequest| { &m.label_orders },
            |m: &mut PostLabelOrdersRequest| { &mut m.label_orders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostLabelOrdersRequest>(
            "PostLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostLabelOrdersRequest {
    const NAME: &'static str = "PostLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostLabelOrdersRequest {
        PostLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostLabelOrdersRequest {
        static instance: PostLabelOrdersRequest = PostLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get one label order.
// @@protoc_insertion_point(message:clarifai.api.GetLabelOrderRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetLabelOrderRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetLabelOrderRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetLabelOrderRequest.label_order_id)
    pub label_order_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetLabelOrderRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLabelOrderRequest {
    fn default() -> &'a GetLabelOrderRequest {
        <GetLabelOrderRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLabelOrderRequest {
    pub fn new() -> GetLabelOrderRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetLabelOrderRequest| { &m.user_app_id },
            |m: &mut GetLabelOrderRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label_order_id",
            |m: &GetLabelOrderRequest| { &m.label_order_id },
            |m: &mut GetLabelOrderRequest| { &mut m.label_order_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLabelOrderRequest>(
            "GetLabelOrderRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLabelOrderRequest {
    const NAME: &'static str = "GetLabelOrderRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_order_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.label_order_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label_order_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.label_order_id.is_empty() {
            os.write_string(2, &self.label_order_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLabelOrderRequest {
        GetLabelOrderRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_order_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLabelOrderRequest {
        static instance: GetLabelOrderRequest = GetLabelOrderRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_order_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLabelOrderRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLabelOrderRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLabelOrderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLabelOrderRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list multiple label orders.
// @@protoc_insertion_point(message:clarifai.api.ListLabelOrdersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListLabelOrdersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListLabelOrdersRequest {
    fn default() -> &'a ListLabelOrdersRequest {
        <ListLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListLabelOrdersRequest {
    pub fn new() -> ListLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListLabelOrdersRequest| { &m.user_app_id },
            |m: &mut ListLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListLabelOrdersRequest| { &m.page },
            |m: &mut ListLabelOrdersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListLabelOrdersRequest| { &m.per_page },
            |m: &mut ListLabelOrdersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListLabelOrdersRequest>(
            "ListLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListLabelOrdersRequest {
    const NAME: &'static str = "ListLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListLabelOrdersRequest {
        ListLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListLabelOrdersRequest {
        static instance: ListLabelOrdersRequest = ListLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to patch a list of label orders.
// @@protoc_insertion_point(message:clarifai.api.PatchLabelOrdersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    ///  The action to perform on the patched objects
    ///  For now actions 'merge', 'overwrite', and 'remove' are supported
    // @@protoc_insertion_point(field:clarifai.api.PatchLabelOrdersRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchLabelOrdersRequest {
    fn default() -> &'a PatchLabelOrdersRequest {
        <PatchLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchLabelOrdersRequest {
    pub fn new() -> PatchLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchLabelOrdersRequest| { &m.user_app_id },
            |m: &mut PatchLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &PatchLabelOrdersRequest| { &m.label_orders },
            |m: &mut PatchLabelOrdersRequest| { &mut m.label_orders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchLabelOrdersRequest| { &m.action },
            |m: &mut PatchLabelOrdersRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchLabelOrdersRequest>(
            "PatchLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchLabelOrdersRequest {
    const NAME: &'static str = "PatchLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchLabelOrdersRequest {
        PatchLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_orders.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchLabelOrdersRequest {
        static instance: PatchLabelOrdersRequest = PatchLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete a list of label orders.
// @@protoc_insertion_point(message:clarifai.api.DeleteLabelOrdersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteLabelOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteLabelOrdersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteLabelOrdersRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteLabelOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteLabelOrdersRequest {
    fn default() -> &'a DeleteLabelOrdersRequest {
        <DeleteLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteLabelOrdersRequest {
    pub fn new() -> DeleteLabelOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteLabelOrdersRequest| { &m.user_app_id },
            |m: &mut DeleteLabelOrdersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteLabelOrdersRequest| { &m.ids },
            |m: &mut DeleteLabelOrdersRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteLabelOrdersRequest>(
            "DeleteLabelOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteLabelOrdersRequest {
    const NAME: &'static str = "DeleteLabelOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteLabelOrdersRequest {
        DeleteLabelOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteLabelOrdersRequest {
        static instance: DeleteLabelOrdersRequest = DeleteLabelOrdersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteLabelOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteLabelOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteLabelOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple label order.
// @@protoc_insertion_point(message:clarifai.api.MultiLabelOrderResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiLabelOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiLabelOrderResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiLabelOrderResponse.label_orders)
    pub label_orders: ::std::vec::Vec<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiLabelOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiLabelOrderResponse {
    fn default() -> &'a MultiLabelOrderResponse {
        <MultiLabelOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiLabelOrderResponse {
    pub fn new() -> MultiLabelOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiLabelOrderResponse| { &m.status },
            |m: &mut MultiLabelOrderResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_orders",
            |m: &MultiLabelOrderResponse| { &m.label_orders },
            |m: &mut MultiLabelOrderResponse| { &mut m.label_orders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiLabelOrderResponse>(
            "MultiLabelOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiLabelOrderResponse {
    const NAME: &'static str = "MultiLabelOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.label_orders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.label_orders {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiLabelOrderResponse {
        MultiLabelOrderResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.label_orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiLabelOrderResponse {
        static instance: MultiLabelOrderResponse = MultiLabelOrderResponse {
            status: ::protobuf::MessageField::none(),
            label_orders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiLabelOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiLabelOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiLabelOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiLabelOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a label order.
// @@protoc_insertion_point(message:clarifai.api.SingleLabelOrderResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleLabelOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleLabelOrderResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleLabelOrderResponse.label_order)
    pub label_order: ::protobuf::MessageField<super::resources::LabelOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleLabelOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleLabelOrderResponse {
    fn default() -> &'a SingleLabelOrderResponse {
        <SingleLabelOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleLabelOrderResponse {
    pub fn new() -> SingleLabelOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleLabelOrderResponse| { &m.status },
            |m: &mut SingleLabelOrderResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::LabelOrder>(
            "label_order",
            |m: &SingleLabelOrderResponse| { &m.label_order },
            |m: &mut SingleLabelOrderResponse| { &mut m.label_order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleLabelOrderResponse>(
            "SingleLabelOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleLabelOrderResponse {
    const NAME: &'static str = "SingleLabelOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.label_order)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.label_order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.label_order.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleLabelOrderResponse {
        SingleLabelOrderResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.label_order.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleLabelOrderResponse {
        static instance: SingleLabelOrderResponse = SingleLabelOrderResponse {
            status: ::protobuf::MessageField::none(),
            label_order: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleLabelOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleLabelOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleLabelOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleLabelOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to create Collectors.
// @@protoc_insertion_point(message:clarifai.api.PostCollectorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostCollectorsRequest.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostCollectorsRequest {
    fn default() -> &'a PostCollectorsRequest {
        <PostCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollectorsRequest {
    pub fn new() -> PostCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostCollectorsRequest| { &m.user_app_id },
            |m: &mut PostCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &PostCollectorsRequest| { &m.collectors },
            |m: &mut PostCollectorsRequest| { &mut m.collectors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostCollectorsRequest>(
            "PostCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostCollectorsRequest {
    const NAME: &'static str = "PostCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostCollectorsRequest {
        PostCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostCollectorsRequest {
        static instance: PostCollectorsRequest = PostCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchCollectorsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchCollectorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    ///  The action to perform on the patched objects
    ///  Only 'overwrite' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchCollectorsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchCollectorsRequest {
    fn default() -> &'a PatchCollectorsRequest {
        <PatchCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollectorsRequest {
    pub fn new() -> PatchCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchCollectorsRequest| { &m.user_app_id },
            |m: &mut PatchCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &PatchCollectorsRequest| { &m.collectors },
            |m: &mut PatchCollectorsRequest| { &mut m.collectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchCollectorsRequest| { &m.action },
            |m: &mut PatchCollectorsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchCollectorsRequest>(
            "PatchCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchCollectorsRequest {
    const NAME: &'static str = "PatchCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchCollectorsRequest {
        PatchCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchCollectorsRequest {
        static instance: PatchCollectorsRequest = PatchCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteCollectorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteCollectorsRequest.delete_all)
    pub delete_all: bool,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteCollectorsRequest {
    fn default() -> &'a DeleteCollectorsRequest {
        <DeleteCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollectorsRequest {
    pub fn new() -> DeleteCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteCollectorsRequest| { &m.user_app_id },
            |m: &mut DeleteCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteCollectorsRequest| { &m.ids },
            |m: &mut DeleteCollectorsRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteCollectorsRequest| { &m.delete_all },
            |m: &mut DeleteCollectorsRequest| { &mut m.delete_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteCollectorsRequest>(
            "DeleteCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteCollectorsRequest {
    const NAME: &'static str = "DeleteCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                24 => {
                    self.delete_all = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteCollectorsRequest {
        DeleteCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteCollectorsRequest {
        static instance: DeleteCollectorsRequest = DeleteCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to GET a single Collector.
// @@protoc_insertion_point(message:clarifai.api.GetCollectorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCollectorRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetCollectorRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetCollectorRequest.collector_id)
    pub collector_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetCollectorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCollectorRequest {
    fn default() -> &'a GetCollectorRequest {
        <GetCollectorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCollectorRequest {
    pub fn new() -> GetCollectorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetCollectorRequest| { &m.user_app_id },
            |m: &mut GetCollectorRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collector_id",
            |m: &GetCollectorRequest| { &m.collector_id },
            |m: &mut GetCollectorRequest| { &mut m.collector_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCollectorRequest>(
            "GetCollectorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCollectorRequest {
    const NAME: &'static str = "GetCollectorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.collector_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.collector_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collector_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.collector_id.is_empty() {
            os.write_string(2, &self.collector_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCollectorRequest {
        GetCollectorRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collector_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCollectorRequest {
        static instance: GetCollectorRequest = GetCollectorRequest {
            user_app_id: ::protobuf::MessageField::none(),
            collector_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCollectorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCollectorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCollectorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCollectorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to GET all the Collectors.
// @@protoc_insertion_point(message:clarifai.api.ListCollectorsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListCollectorsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListCollectorsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListCollectorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListCollectorsRequest {
    fn default() -> &'a ListCollectorsRequest {
        <ListCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollectorsRequest {
    pub fn new() -> ListCollectorsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListCollectorsRequest| { &m.user_app_id },
            |m: &mut ListCollectorsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListCollectorsRequest| { &m.page },
            |m: &mut ListCollectorsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListCollectorsRequest| { &m.per_page },
            |m: &mut ListCollectorsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListCollectorsRequest>(
            "ListCollectorsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListCollectorsRequest {
    const NAME: &'static str = "ListCollectorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListCollectorsRequest {
        ListCollectorsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListCollectorsRequest {
        static instance: ListCollectorsRequest = ListCollectorsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListCollectorsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListCollectorsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollectorsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with multiple Collectors.
// @@protoc_insertion_point(message:clarifai.api.MultiCollectorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiCollectorResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiCollectorResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiCollectorResponse.collectors)
    pub collectors: ::std::vec::Vec<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiCollectorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiCollectorResponse {
    fn default() -> &'a MultiCollectorResponse {
        <MultiCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollectorResponse {
    pub fn new() -> MultiCollectorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiCollectorResponse| { &m.status },
            |m: &mut MultiCollectorResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectors",
            |m: &MultiCollectorResponse| { &m.collectors },
            |m: &mut MultiCollectorResponse| { &mut m.collectors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiCollectorResponse>(
            "MultiCollectorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiCollectorResponse {
    const NAME: &'static str = "MultiCollectorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.collectors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.collectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiCollectorResponse {
        MultiCollectorResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collectors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiCollectorResponse {
        static instance: MultiCollectorResponse = MultiCollectorResponse {
            status: ::protobuf::MessageField::none(),
            collectors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiCollectorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiCollectorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollectorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Response with a single Collector.
// @@protoc_insertion_point(message:clarifai.api.SingleCollectorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleCollectorResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleCollectorResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleCollectorResponse.collector)
    pub collector: ::protobuf::MessageField<super::resources::Collector>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleCollectorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleCollectorResponse {
    fn default() -> &'a SingleCollectorResponse {
        <SingleCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleCollectorResponse {
    pub fn new() -> SingleCollectorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleCollectorResponse| { &m.status },
            |m: &mut SingleCollectorResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Collector>(
            "collector",
            |m: &SingleCollectorResponse| { &m.collector },
            |m: &mut SingleCollectorResponse| { &mut m.collector },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleCollectorResponse>(
            "SingleCollectorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleCollectorResponse {
    const NAME: &'static str = "SingleCollectorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.collector)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.collector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.collector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleCollectorResponse {
        SingleCollectorResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.collector.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleCollectorResponse {
        static instance: SingleCollectorResponse = SingleCollectorResponse {
            status: ::protobuf::MessageField::none(),
            collector: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleCollectorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleCollectorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleCollectorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostStatValuesRequest
// @@protoc_insertion_point(message:clarifai.api.PostStatValuesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostStatValuesRequest {
    // message fields
    ///  The user and app information for the request.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The stats to post, can post more than one at a time.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesRequest.stat_values)
    pub stat_values: ::std::vec::Vec<super::resources::StatValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostStatValuesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostStatValuesRequest {
    fn default() -> &'a PostStatValuesRequest {
        <PostStatValuesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesRequest {
    pub fn new() -> PostStatValuesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostStatValuesRequest| { &m.user_app_id },
            |m: &mut PostStatValuesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_values",
            |m: &PostStatValuesRequest| { &m.stat_values },
            |m: &mut PostStatValuesRequest| { &mut m.stat_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostStatValuesRequest>(
            "PostStatValuesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostStatValuesRequest {
    const NAME: &'static str = "PostStatValuesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.stat_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_values {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostStatValuesRequest {
        PostStatValuesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostStatValuesRequest {
        static instance: PostStatValuesRequest = PostStatValuesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            stat_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostStatValuesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostStatValuesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostStatValuesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatValueResponse
// @@protoc_insertion_point(message:clarifai.api.MultiStatValueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiStatValueResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The returned stats values.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueResponse.stat_values)
    pub stat_values: ::std::vec::Vec<super::resources::StatValue>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatValueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatValueResponse {
    fn default() -> &'a MultiStatValueResponse {
        <MultiStatValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueResponse {
    pub fn new() -> MultiStatValueResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatValueResponse| { &m.status },
            |m: &mut MultiStatValueResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_values",
            |m: &MultiStatValueResponse| { &m.stat_values },
            |m: &mut MultiStatValueResponse| { &mut m.stat_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatValueResponse>(
            "MultiStatValueResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatValueResponse {
    const NAME: &'static str = "MultiStatValueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.stat_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_values {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatValueResponse {
        MultiStatValueResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.stat_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatValueResponse {
        static instance: MultiStatValueResponse = MultiStatValueResponse {
            status: ::protobuf::MessageField::none(),
            stat_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatValueResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatValueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostStatValuesAggregateRequest
// @@protoc_insertion_point(message:clarifai.api.PostStatValuesAggregateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostStatValuesAggregateRequest {
    // message fields
    ///  Ids present in the url of the request.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesAggregateRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Query to retrieve aggregate values.
    // @@protoc_insertion_point(field:clarifai.api.PostStatValuesAggregateRequest.stat_value_aggregate_queries)
    pub stat_value_aggregate_queries: ::std::vec::Vec<super::resources::StatValueAggregateQuery>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostStatValuesAggregateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostStatValuesAggregateRequest {
    fn default() -> &'a PostStatValuesAggregateRequest {
        <PostStatValuesAggregateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesAggregateRequest {
    pub fn new() -> PostStatValuesAggregateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostStatValuesAggregateRequest| { &m.user_app_id },
            |m: &mut PostStatValuesAggregateRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_value_aggregate_queries",
            |m: &PostStatValuesAggregateRequest| { &m.stat_value_aggregate_queries },
            |m: &mut PostStatValuesAggregateRequest| { &mut m.stat_value_aggregate_queries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostStatValuesAggregateRequest>(
            "PostStatValuesAggregateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostStatValuesAggregateRequest {
    const NAME: &'static str = "PostStatValuesAggregateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.stat_value_aggregate_queries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_value_aggregate_queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_value_aggregate_queries {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostStatValuesAggregateRequest {
        PostStatValuesAggregateRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_value_aggregate_queries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostStatValuesAggregateRequest {
        static instance: PostStatValuesAggregateRequest = PostStatValuesAggregateRequest {
            user_app_id: ::protobuf::MessageField::none(),
            stat_value_aggregate_queries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostStatValuesAggregateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostStatValuesAggregateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostStatValuesAggregateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesAggregateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiStatValueAggregateResponse
// @@protoc_insertion_point(message:clarifai.api.MultiStatValueAggregateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiStatValueAggregateResponse {
    // message fields
    ///  The response status.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueAggregateResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    ///  The aggregate results for each query passedin.
    // @@protoc_insertion_point(field:clarifai.api.MultiStatValueAggregateResponse.stat_value_aggregate_results)
    pub stat_value_aggregate_results: ::std::vec::Vec<super::resources::StatValueAggregateResult>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiStatValueAggregateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiStatValueAggregateResponse {
    fn default() -> &'a MultiStatValueAggregateResponse {
        <MultiStatValueAggregateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueAggregateResponse {
    pub fn new() -> MultiStatValueAggregateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiStatValueAggregateResponse| { &m.status },
            |m: &mut MultiStatValueAggregateResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stat_value_aggregate_results",
            |m: &MultiStatValueAggregateResponse| { &m.stat_value_aggregate_results },
            |m: &mut MultiStatValueAggregateResponse| { &mut m.stat_value_aggregate_results },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiStatValueAggregateResponse>(
            "MultiStatValueAggregateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiStatValueAggregateResponse {
    const NAME: &'static str = "MultiStatValueAggregateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.stat_value_aggregate_results.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stat_value_aggregate_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.stat_value_aggregate_results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiStatValueAggregateResponse {
        MultiStatValueAggregateResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.stat_value_aggregate_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiStatValueAggregateResponse {
        static instance: MultiStatValueAggregateResponse = MultiStatValueAggregateResponse {
            status: ::protobuf::MessageField::none(),
            stat_value_aggregate_results: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiStatValueAggregateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiStatValueAggregateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiStatValueAggregateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueAggregateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostTrendingMetricsViewRequest
// @@protoc_insertion_point(message:clarifai.api.PostTrendingMetricsViewRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostTrendingMetricsViewRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  For now view types 'apps', 'workflows', and 'models' are supported.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.view_type)
    pub view_type: ::std::string::String,
    ///  ID of the views object.
    // @@protoc_insertion_point(field:clarifai.api.PostTrendingMetricsViewRequest.object_id)
    pub object_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostTrendingMetricsViewRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostTrendingMetricsViewRequest {
    fn default() -> &'a PostTrendingMetricsViewRequest {
        <PostTrendingMetricsViewRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTrendingMetricsViewRequest {
    pub fn new() -> PostTrendingMetricsViewRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostTrendingMetricsViewRequest| { &m.user_app_id },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "view_type",
            |m: &PostTrendingMetricsViewRequest| { &m.view_type },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.view_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &PostTrendingMetricsViewRequest| { &m.object_id },
            |m: &mut PostTrendingMetricsViewRequest| { &mut m.object_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostTrendingMetricsViewRequest>(
            "PostTrendingMetricsViewRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostTrendingMetricsViewRequest {
    const NAME: &'static str = "PostTrendingMetricsViewRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.view_type = is.read_string()?;
                },
                26 => {
                    self.object_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.view_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.view_type);
        }
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.view_type.is_empty() {
            os.write_string(2, &self.view_type)?;
        }
        if !self.object_id.is_empty() {
            os.write_string(3, &self.object_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostTrendingMetricsViewRequest {
        PostTrendingMetricsViewRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.view_type.clear();
        self.object_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostTrendingMetricsViewRequest {
        static instance: PostTrendingMetricsViewRequest = PostTrendingMetricsViewRequest {
            user_app_id: ::protobuf::MessageField::none(),
            view_type: ::std::string::String::new(),
            object_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostTrendingMetricsViewRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostTrendingMetricsViewRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostTrendingMetricsViewRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTrendingMetricsViewRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListTrendingMetricsViewsRequest
// @@protoc_insertion_point(message:clarifai.api.ListTrendingMetricsViewsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListTrendingMetricsViewsRequest {
    // message fields
    ///  The user_id and app_id information.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  For now view types 'apps', 'workflows', and 'models' are supported.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.view_type)
    pub view_type: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListTrendingMetricsViewsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListTrendingMetricsViewsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListTrendingMetricsViewsRequest {
    fn default() -> &'a ListTrendingMetricsViewsRequest {
        <ListTrendingMetricsViewsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTrendingMetricsViewsRequest {
    pub fn new() -> ListTrendingMetricsViewsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListTrendingMetricsViewsRequest| { &m.user_app_id },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "view_type",
            |m: &ListTrendingMetricsViewsRequest| { &m.view_type },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.view_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListTrendingMetricsViewsRequest| { &m.page },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListTrendingMetricsViewsRequest| { &m.per_page },
            |m: &mut ListTrendingMetricsViewsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListTrendingMetricsViewsRequest>(
            "ListTrendingMetricsViewsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListTrendingMetricsViewsRequest {
    const NAME: &'static str = "ListTrendingMetricsViewsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.view_type = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.view_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.view_type);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.view_type.is_empty() {
            os.write_string(2, &self.view_type)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListTrendingMetricsViewsRequest {
        ListTrendingMetricsViewsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.view_type.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListTrendingMetricsViewsRequest {
        static instance: ListTrendingMetricsViewsRequest = ListTrendingMetricsViewsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            view_type: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListTrendingMetricsViewsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListTrendingMetricsViewsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListTrendingMetricsViewsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTrendingMetricsViewsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiTrendingMetricsViewResponse
// @@protoc_insertion_point(message:clarifai.api.MultiTrendingMetricsViewResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiTrendingMetricsViewResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTrendingMetricsViewResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTrendingMetricsViewResponse.metrics)
    pub metrics: ::std::vec::Vec<super::resources::TrendingMetric>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTrendingMetricsViewResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTrendingMetricsViewResponse {
    fn default() -> &'a MultiTrendingMetricsViewResponse {
        <MultiTrendingMetricsViewResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTrendingMetricsViewResponse {
    pub fn new() -> MultiTrendingMetricsViewResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTrendingMetricsViewResponse| { &m.status },
            |m: &mut MultiTrendingMetricsViewResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &MultiTrendingMetricsViewResponse| { &m.metrics },
            |m: &mut MultiTrendingMetricsViewResponse| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTrendingMetricsViewResponse>(
            "MultiTrendingMetricsViewResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTrendingMetricsViewResponse {
    const NAME: &'static str = "MultiTrendingMetricsViewResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTrendingMetricsViewResponse {
        MultiTrendingMetricsViewResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTrendingMetricsViewResponse {
        static instance: MultiTrendingMetricsViewResponse = MultiTrendingMetricsViewResponse {
            status: ::protobuf::MessageField::none(),
            metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTrendingMetricsViewResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTrendingMetricsViewResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTrendingMetricsViewResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTrendingMetricsViewResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetModuleRequest
// @@protoc_insertion_point(message:clarifai.api.GetModuleRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModuleRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModuleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleRequest {
    fn default() -> &'a GetModuleRequest {
        <GetModuleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleRequest {
    pub fn new() -> GetModuleRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModuleRequest| { &m.user_app_id },
            |m: &mut GetModuleRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleRequest| { &m.module_id },
            |m: &mut GetModuleRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &GetModuleRequest| { &m.additional_fields },
            |m: &mut GetModuleRequest| { &mut m.additional_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleRequest>(
            "GetModuleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleRequest {
    const NAME: &'static str = "GetModuleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.additional_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.additional_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleRequest {
        GetModuleRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.additional_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleRequest {
        static instance: GetModuleRequest = GetModuleRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            additional_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModulesRequest
// @@protoc_insertion_point(message:clarifai.api.ListModulesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.per_page)
    pub per_page: u32,
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.additional_fields)
    pub additional_fields: ::std::vec::Vec<::std::string::String>,
    ///  Sorting options:
    ///  Whether to sort in ascending order. If false, will order in descending order.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.sort_ascending)
    pub sort_ascending: bool,
    ///  Filtering options:
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.starred_only)
    pub starred_only: bool,
    ///  Filter modules by bookmark. If set, only return bookmarked modules. Otherwise none bookmarked modules only.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.bookmark)
    pub bookmark: bool,
    ///  Searching options:
    ///  Specify a search parameter in order to perform keyword search on the
    ///  following fields of the module:
    ///    - id
    ///    - description
    ///    - user_id (unless user_app_id.user_id is already set)
    ///
    ///  Keywords are both normalized for search (so searching for "satisfy" matches "satisfied")
    ///  and used for partial prefix-matching (so searching for "clari" matches "clarifai").
    ///
    ///  NOTE: Both the list of fields searched and the exact keyword matching
    ///  rules are subject to change and not guaranteed to be backwards-compatible.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.search)
    pub search: ::std::string::String,
    ///  Filter by the id and description of the module. This supports wildcard queries like "gen*" to match "general" as an example.
    ///  Deprecated: use search instead.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.name)
    pub name: ::std::string::String,
    ///  Filter by the application owner whose this module belongs to
    ///  Deprecated: use search instead of name.
    // @@protoc_insertion_point(field:clarifai.api.ListModulesRequest.filter_by_user_id)
    pub filter_by_user_id: bool,
    // message oneof groups
    pub sort_by: ::std::option::Option<list_modules_request::Sort_by>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModulesRequest {
    fn default() -> &'a ListModulesRequest {
        <ListModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModulesRequest {
    pub fn new() -> ListModulesRequest {
        ::std::default::Default::default()
    }

    // bool sort_by_created_at = 7;

    pub fn sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_created_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_created_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_created_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(v))
    }

    // bool sort_by_star_count = 8;

    pub fn sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_star_count(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_star_count(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_star_count(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(v))
    }

    // bool sort_by_modified_at = 9;

    pub fn sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(v))
    }

    // bool sort_by_id = 11;

    pub fn sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortById(v)) => v,
            _ => false,
        }
    }

    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(list_modules_request::Sort_by::SortById(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortById(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModulesRequest| { &m.user_app_id },
            |m: &mut ListModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModulesRequest| { &m.page },
            |m: &mut ListModulesRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModulesRequest| { &m.per_page },
            |m: &mut ListModulesRequest| { &mut m.per_page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_fields",
            |m: &ListModulesRequest| { &m.additional_fields },
            |m: &mut ListModulesRequest| { &mut m.additional_fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_ascending",
            |m: &ListModulesRequest| { &m.sort_ascending },
            |m: &mut ListModulesRequest| { &mut m.sort_ascending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_created_at",
            ListModulesRequest::has_sort_by_created_at,
            ListModulesRequest::sort_by_created_at,
            ListModulesRequest::set_sort_by_created_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_star_count",
            ListModulesRequest::has_sort_by_star_count,
            ListModulesRequest::sort_by_star_count,
            ListModulesRequest::set_sort_by_star_count,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_modified_at",
            ListModulesRequest::has_sort_by_modified_at,
            ListModulesRequest::sort_by_modified_at,
            ListModulesRequest::set_sort_by_modified_at,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "sort_by_id",
            ListModulesRequest::has_sort_by_id,
            ListModulesRequest::sort_by_id,
            ListModulesRequest::set_sort_by_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "starred_only",
            |m: &ListModulesRequest| { &m.starred_only },
            |m: &mut ListModulesRequest| { &mut m.starred_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bookmark",
            |m: &ListModulesRequest| { &m.bookmark },
            |m: &mut ListModulesRequest| { &mut m.bookmark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search",
            |m: &ListModulesRequest| { &m.search },
            |m: &mut ListModulesRequest| { &mut m.search },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListModulesRequest| { &m.name },
            |m: &mut ListModulesRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filter_by_user_id",
            |m: &ListModulesRequest| { &m.filter_by_user_id },
            |m: &mut ListModulesRequest| { &mut m.filter_by_user_id },
        ));
        oneofs.push(list_modules_request::Sort_by::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModulesRequest>(
            "ListModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModulesRequest {
    const NAME: &'static str = "ListModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                42 => {
                    self.additional_fields.push(is.read_string()?);
                },
                48 => {
                    self.sort_ascending = is.read_bool()?;
                },
                56 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByCreatedAt(is.read_bool()?));
                },
                64 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByStarCount(is.read_bool()?));
                },
                72 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortByModifiedAt(is.read_bool()?));
                },
                88 => {
                    self.sort_by = ::std::option::Option::Some(list_modules_request::Sort_by::SortById(is.read_bool()?));
                },
                32 => {
                    self.starred_only = is.read_bool()?;
                },
                80 => {
                    self.bookmark = is.read_bool()?;
                },
                114 => {
                    self.search = is.read_string()?;
                },
                98 => {
                    self.name = is.read_string()?;
                },
                104 => {
                    self.filter_by_user_id = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.sort_ascending != false {
            my_size += 1 + 1;
        }
        if self.starred_only != false {
            my_size += 1 + 1;
        }
        if self.bookmark != false {
            my_size += 1 + 1;
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.search);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.name);
        }
        if self.filter_by_user_id != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_modules_request::Sort_by::SortByCreatedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortByStarCount(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortByModifiedAt(v) => {
                    my_size += 1 + 1;
                },
                &list_modules_request::Sort_by::SortById(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.additional_fields {
            os.write_string(5, &v)?;
        };
        if self.sort_ascending != false {
            os.write_bool(6, self.sort_ascending)?;
        }
        if self.starred_only != false {
            os.write_bool(4, self.starred_only)?;
        }
        if self.bookmark != false {
            os.write_bool(10, self.bookmark)?;
        }
        if !self.search.is_empty() {
            os.write_string(14, &self.search)?;
        }
        if !self.name.is_empty() {
            os.write_string(12, &self.name)?;
        }
        if self.filter_by_user_id != false {
            os.write_bool(13, self.filter_by_user_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &list_modules_request::Sort_by::SortByCreatedAt(v) => {
                    os.write_bool(7, v)?;
                },
                &list_modules_request::Sort_by::SortByStarCount(v) => {
                    os.write_bool(8, v)?;
                },
                &list_modules_request::Sort_by::SortByModifiedAt(v) => {
                    os.write_bool(9, v)?;
                },
                &list_modules_request::Sort_by::SortById(v) => {
                    os.write_bool(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModulesRequest {
        ListModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.additional_fields.clear();
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.starred_only = false;
        self.bookmark = false;
        self.search.clear();
        self.name.clear();
        self.filter_by_user_id = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModulesRequest {
        static instance: ListModulesRequest = ListModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            additional_fields: ::std::vec::Vec::new(),
            sort_ascending: false,
            starred_only: false,
            bookmark: false,
            search: ::std::string::String::new(),
            name: ::std::string::String::new(),
            filter_by_user_id: false,
            sort_by: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListModulesRequest`
pub mod list_modules_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.ListModulesRequest.sort_by)
    pub enum Sort_by {
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_created_at)
        SortByCreatedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_star_count)
        SortByStarCount(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_modified_at)
        SortByModifiedAt(bool),
        // @@protoc_insertion_point(oneof_field:clarifai.api.ListModulesRequest.sort_by_id)
        SortById(bool),
    }

    impl ::protobuf::Oneof for Sort_by {
    }

    impl ::protobuf::OneofFull for Sort_by {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ListModulesRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("sort_by").unwrap()).clone()
        }
    }

    impl Sort_by {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Sort_by>("sort_by")
        }
    }
}

///  PostModulesRequest
// @@protoc_insertion_point(message:clarifai.api.PostModulesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModulesRequest.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModulesRequest {
    fn default() -> &'a PostModulesRequest {
        <PostModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModulesRequest {
    pub fn new() -> PostModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModulesRequest| { &m.user_app_id },
            |m: &mut PostModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &PostModulesRequest| { &m.modules },
            |m: &mut PostModulesRequest| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModulesRequest>(
            "PostModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModulesRequest {
    const NAME: &'static str = "PostModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModulesRequest {
        PostModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModulesRequest {
        static instance: PostModulesRequest = PostModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModulesRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModulesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    ///  The action to perform on the patched objects
    ///  Supported values: 'overwrite' and 'remove'.
    ///
    ///  Note that 'remove' can only be used to remove the module image by setting
    ///  'image.url' in the request to the current value returned for that module.
    // @@protoc_insertion_point(field:clarifai.api.PatchModulesRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModulesRequest {
    fn default() -> &'a PatchModulesRequest {
        <PatchModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModulesRequest {
    pub fn new() -> PatchModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModulesRequest| { &m.user_app_id },
            |m: &mut PatchModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &PatchModulesRequest| { &m.modules },
            |m: &mut PatchModulesRequest| { &mut m.modules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModulesRequest| { &m.action },
            |m: &mut PatchModulesRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModulesRequest>(
            "PatchModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModulesRequest {
    const NAME: &'static str = "PatchModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.modules.push(is.read_message()?);
                },
                26 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModulesRequest {
        PatchModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.modules.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModulesRequest {
        static instance: PatchModulesRequest = PatchModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteModulesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModulesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModulesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModulesRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModulesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModulesRequest {
    fn default() -> &'a DeleteModulesRequest {
        <DeleteModulesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModulesRequest {
    pub fn new() -> DeleteModulesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModulesRequest| { &m.user_app_id },
            |m: &mut DeleteModulesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModulesRequest| { &m.ids },
            |m: &mut DeleteModulesRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModulesRequest>(
            "DeleteModulesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModulesRequest {
    const NAME: &'static str = "DeleteModulesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModulesRequest {
        DeleteModulesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModulesRequest {
        static instance: DeleteModulesRequest = DeleteModulesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModulesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModulesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModulesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModulesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModuleResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModuleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleResponse.module)
    pub module: ::protobuf::MessageField<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModuleResponse {
    fn default() -> &'a SingleModuleResponse {
        <SingleModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModuleResponse {
    pub fn new() -> SingleModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModuleResponse| { &m.status },
            |m: &mut SingleModuleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Module>(
            "module",
            |m: &SingleModuleResponse| { &m.module },
            |m: &mut SingleModuleResponse| { &mut m.module },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModuleResponse>(
            "SingleModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModuleResponse {
    const NAME: &'static str = "SingleModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModuleResponse {
        SingleModuleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModuleResponse {
        static instance: SingleModuleResponse = SingleModuleResponse {
            status: ::protobuf::MessageField::none(),
            module: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModuleResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModuleResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModuleResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleResponse.modules)
    pub modules: ::std::vec::Vec<super::resources::Module>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModuleResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModuleResponse {
    fn default() -> &'a MultiModuleResponse {
        <MultiModuleResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModuleResponse {
    pub fn new() -> MultiModuleResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModuleResponse| { &m.status },
            |m: &mut MultiModuleResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &MultiModuleResponse| { &m.modules },
            |m: &mut MultiModuleResponse| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModuleResponse>(
            "MultiModuleResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModuleResponse {
    const NAME: &'static str = "MultiModuleResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModuleResponse {
        MultiModuleResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModuleResponse {
        static instance: MultiModuleResponse = MultiModuleResponse {
            status: ::protobuf::MessageField::none(),
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModuleResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModuleResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModuleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModuleResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  request for different endpoints currently.
// @@protoc_insertion_point(message:clarifai.api.GetModuleVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModuleVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionRequest.module_version_id)
    pub module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModuleVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleVersionRequest {
    fn default() -> &'a GetModuleVersionRequest {
        <GetModuleVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleVersionRequest {
    pub fn new() -> GetModuleVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModuleVersionRequest| { &m.user_app_id },
            |m: &mut GetModuleVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleVersionRequest| { &m.module_id },
            |m: &mut GetModuleVersionRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_version_id",
            |m: &GetModuleVersionRequest| { &m.module_version_id },
            |m: &mut GetModuleVersionRequest| { &mut m.module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleVersionRequest>(
            "GetModuleVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleVersionRequest {
    const NAME: &'static str = "GetModuleVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if !self.module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if !self.module_version_id.is_empty() {
            os.write_string(3, &self.module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleVersionRequest {
        GetModuleVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleVersionRequest {
        static instance: GetModuleVersionRequest = GetModuleVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListModuleVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListModuleVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListModuleVersionsRequest {
    fn default() -> &'a ListModuleVersionsRequest {
        <ListModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModuleVersionsRequest {
    pub fn new() -> ListModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListModuleVersionsRequest| { &m.user_app_id },
            |m: &mut ListModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &ListModuleVersionsRequest| { &m.module_id },
            |m: &mut ListModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListModuleVersionsRequest| { &m.page },
            |m: &mut ListModuleVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListModuleVersionsRequest| { &m.per_page },
            |m: &mut ListModuleVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListModuleVersionsRequest>(
            "ListModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListModuleVersionsRequest {
    const NAME: &'static str = "ListModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListModuleVersionsRequest {
        ListModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListModuleVersionsRequest {
        static instance: ListModuleVersionsRequest = ListModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostModuleVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.PostModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostModuleVersionsRequest.module_versions)
    pub module_versions: ::std::vec::Vec<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModuleVersionsRequest {
    fn default() -> &'a PostModuleVersionsRequest {
        <PostModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModuleVersionsRequest {
    pub fn new() -> PostModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModuleVersionsRequest| { &m.user_app_id },
            |m: &mut PostModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &PostModuleVersionsRequest| { &m.module_id },
            |m: &mut PostModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_versions",
            |m: &PostModuleVersionsRequest| { &m.module_versions },
            |m: &mut PostModuleVersionsRequest| { &mut m.module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModuleVersionsRequest>(
            "PostModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModuleVersionsRequest {
    const NAME: &'static str = "PostModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModuleVersionsRequest {
        PostModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModuleVersionsRequest {
        static instance: PostModuleVersionsRequest = PostModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PatchModuleVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.PatchModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PatchModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PatchModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PatchModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    ///  This allows you to modify the module version details.
    ///  ########## Supported fields ##########
    ///  - description
    ///  - id
    ///  - metadata.fields
    ///  - module_nav.module_sub_navs[].query_key
    ///  - module_nav.module_sub_navs[].query_value
    ///  - module_nav.module_sub_navs[].title
    ///  - module_nav.title
    ///  - notes
    ///  - visibility.gettable
    // @@protoc_insertion_point(field:clarifai.api.PatchModuleVersionsRequest.module_versions)
    pub module_versions: ::std::vec::Vec<super::resources::ModuleVersion>,
    ///  The action to perform on the patched objects
    ///  For now only action 'merge' is supported
    // @@protoc_insertion_point(field:clarifai.api.PatchModuleVersionsRequest.action)
    pub action: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PatchModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PatchModuleVersionsRequest {
    fn default() -> &'a PatchModuleVersionsRequest {
        <PatchModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModuleVersionsRequest {
    pub fn new() -> PatchModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PatchModuleVersionsRequest| { &m.user_app_id },
            |m: &mut PatchModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &PatchModuleVersionsRequest| { &m.module_id },
            |m: &mut PatchModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_versions",
            |m: &PatchModuleVersionsRequest| { &m.module_versions },
            |m: &mut PatchModuleVersionsRequest| { &mut m.module_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PatchModuleVersionsRequest| { &m.action },
            |m: &mut PatchModuleVersionsRequest| { &mut m.action },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PatchModuleVersionsRequest>(
            "PatchModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PatchModuleVersionsRequest {
    const NAME: &'static str = "PatchModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_versions.push(is.read_message()?);
                },
                34 => {
                    self.action = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PatchModuleVersionsRequest {
        PatchModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_versions.clear();
        self.action.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PatchModuleVersionsRequest {
        static instance: PatchModuleVersionsRequest = PatchModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_versions: ::std::vec::Vec::new(),
            action: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PatchModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PatchModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PatchModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several module versions by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.DeleteModuleVersionsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModuleVersionsRequest {
    fn default() -> &'a DeleteModuleVersionsRequest {
        <DeleteModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModuleVersionsRequest {
    pub fn new() -> DeleteModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteModuleVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &DeleteModuleVersionsRequest| { &m.module_id },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteModuleVersionsRequest| { &m.ids },
            |m: &mut DeleteModuleVersionsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModuleVersionsRequest>(
            "DeleteModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModuleVersionsRequest {
    const NAME: &'static str = "DeleteModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModuleVersionsRequest {
        DeleteModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModuleVersionsRequest {
        static instance: DeleteModuleVersionsRequest = DeleteModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get the number of installations (by all users) for the module version
// @@protoc_insertion_point(message:clarifai.api.GetModuleVersionUsageCountRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetModuleVersionUsageCountRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionUsageCountRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionUsageCountRequest.module_id)
    pub module_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.GetModuleVersionUsageCountRequest.module_version_id)
    pub module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetModuleVersionUsageCountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetModuleVersionUsageCountRequest {
    fn default() -> &'a GetModuleVersionUsageCountRequest {
        <GetModuleVersionUsageCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModuleVersionUsageCountRequest {
    pub fn new() -> GetModuleVersionUsageCountRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetModuleVersionUsageCountRequest| { &m.user_app_id },
            |m: &mut GetModuleVersionUsageCountRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_id",
            |m: &GetModuleVersionUsageCountRequest| { &m.module_id },
            |m: &mut GetModuleVersionUsageCountRequest| { &mut m.module_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module_version_id",
            |m: &GetModuleVersionUsageCountRequest| { &m.module_version_id },
            |m: &mut GetModuleVersionUsageCountRequest| { &mut m.module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetModuleVersionUsageCountRequest>(
            "GetModuleVersionUsageCountRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetModuleVersionUsageCountRequest {
    const NAME: &'static str = "GetModuleVersionUsageCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.module_id = is.read_string()?;
                },
                26 => {
                    self.module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.module_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module_id);
        }
        if !self.module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.module_id.is_empty() {
            os.write_string(2, &self.module_id)?;
        }
        if !self.module_version_id.is_empty() {
            os.write_string(3, &self.module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetModuleVersionUsageCountRequest {
        GetModuleVersionUsageCountRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.module_id.clear();
        self.module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetModuleVersionUsageCountRequest {
        static instance: GetModuleVersionUsageCountRequest = GetModuleVersionUsageCountRequest {
            user_app_id: ::protobuf::MessageField::none(),
            module_id: ::std::string::String::new(),
            module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetModuleVersionUsageCountRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetModuleVersionUsageCountRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetModuleVersionUsageCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModuleVersionUsageCountRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModuleVersionResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModuleVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionResponse.module_version)
    pub module_version: ::protobuf::MessageField<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModuleVersionResponse {
    fn default() -> &'a SingleModuleVersionResponse {
        <SingleModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModuleVersionResponse {
    pub fn new() -> SingleModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModuleVersionResponse| { &m.status },
            |m: &mut SingleModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ModuleVersion>(
            "module_version",
            |m: &SingleModuleVersionResponse| { &m.module_version },
            |m: &mut SingleModuleVersionResponse| { &mut m.module_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModuleVersionResponse>(
            "SingleModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModuleVersionResponse {
    const NAME: &'static str = "SingleModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.module_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.module_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModuleVersionResponse {
        SingleModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModuleVersionResponse {
        static instance: SingleModuleVersionResponse = SingleModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            module_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiModuleVersionResponse
// @@protoc_insertion_point(message:clarifai.api.MultiModuleVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiModuleVersionResponse.module_versions)
    pub module_versions: ::std::vec::Vec<super::resources::ModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiModuleVersionResponse {
    fn default() -> &'a MultiModuleVersionResponse {
        <MultiModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModuleVersionResponse {
    pub fn new() -> MultiModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiModuleVersionResponse| { &m.status },
            |m: &mut MultiModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "module_versions",
            |m: &MultiModuleVersionResponse| { &m.module_versions },
            |m: &mut MultiModuleVersionResponse| { &mut m.module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiModuleVersionResponse>(
            "MultiModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiModuleVersionResponse {
    const NAME: &'static str = "MultiModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiModuleVersionResponse {
        MultiModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiModuleVersionResponse {
        static instance: MultiModuleVersionResponse = MultiModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleModuleVersionUsageCountResponse
// @@protoc_insertion_point(message:clarifai.api.SingleModuleVersionUsageCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleModuleVersionUsageCountResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionUsageCountResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleModuleVersionUsageCountResponse.usage_count)
    pub usage_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleModuleVersionUsageCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleModuleVersionUsageCountResponse {
    fn default() -> &'a SingleModuleVersionUsageCountResponse {
        <SingleModuleVersionUsageCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModuleVersionUsageCountResponse {
    pub fn new() -> SingleModuleVersionUsageCountResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleModuleVersionUsageCountResponse| { &m.status },
            |m: &mut SingleModuleVersionUsageCountResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage_count",
            |m: &SingleModuleVersionUsageCountResponse| { &m.usage_count },
            |m: &mut SingleModuleVersionUsageCountResponse| { &mut m.usage_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleModuleVersionUsageCountResponse>(
            "SingleModuleVersionUsageCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleModuleVersionUsageCountResponse {
    const NAME: &'static str = "SingleModuleVersionUsageCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                16 => {
                    self.usage_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.usage_count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.usage_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.usage_count != 0 {
            os.write_uint32(2, self.usage_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleModuleVersionUsageCountResponse {
        SingleModuleVersionUsageCountResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.usage_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleModuleVersionUsageCountResponse {
        static instance: SingleModuleVersionUsageCountResponse = SingleModuleVersionUsageCountResponse {
            status: ::protobuf::MessageField::none(),
            usage_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleModuleVersionUsageCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleModuleVersionUsageCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleModuleVersionUsageCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModuleVersionUsageCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetInstalledModuleVersionRequest
// @@protoc_insertion_point(message:clarifai.api.GetInstalledModuleVersionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInstalledModuleVersionRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInstalledModuleVersionRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the ID to get of the install module version.
    // @@protoc_insertion_point(field:clarifai.api.GetInstalledModuleVersionRequest.installed_module_version_id)
    pub installed_module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInstalledModuleVersionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInstalledModuleVersionRequest {
    fn default() -> &'a GetInstalledModuleVersionRequest {
        <GetInstalledModuleVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInstalledModuleVersionRequest {
    pub fn new() -> GetInstalledModuleVersionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInstalledModuleVersionRequest| { &m.user_app_id },
            |m: &mut GetInstalledModuleVersionRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "installed_module_version_id",
            |m: &GetInstalledModuleVersionRequest| { &m.installed_module_version_id },
            |m: &mut GetInstalledModuleVersionRequest| { &mut m.installed_module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInstalledModuleVersionRequest>(
            "GetInstalledModuleVersionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInstalledModuleVersionRequest {
    const NAME: &'static str = "GetInstalledModuleVersionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.installed_module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.installed_module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.installed_module_version_id.is_empty() {
            os.write_string(2, &self.installed_module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInstalledModuleVersionRequest {
        GetInstalledModuleVersionRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInstalledModuleVersionRequest {
        static instance: GetInstalledModuleVersionRequest = GetInstalledModuleVersionRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInstalledModuleVersionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInstalledModuleVersionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInstalledModuleVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInstalledModuleVersionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListInstalledModuleVersionsRequest
// @@protoc_insertion_point(message:clarifai.api.ListInstalledModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInstalledModuleVersionsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInstalledModuleVersionsRequest {
    fn default() -> &'a ListInstalledModuleVersionsRequest {
        <ListInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInstalledModuleVersionsRequest {
    pub fn new() -> ListInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInstalledModuleVersionsRequest| { &m.page },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInstalledModuleVersionsRequest| { &m.per_page },
            |m: &mut ListInstalledModuleVersionsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInstalledModuleVersionsRequest>(
            "ListInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInstalledModuleVersionsRequest {
    const NAME: &'static str = "ListInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInstalledModuleVersionsRequest {
        ListInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInstalledModuleVersionsRequest {
        static instance: ListInstalledModuleVersionsRequest = ListInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInstalledModuleVersionsRequest to install a module version into the app in the URL
// @@protoc_insertion_point(message:clarifai.api.PostInstalledModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more module by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsRequest.installed_module_versions)
    pub installed_module_versions: ::std::vec::Vec<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInstalledModuleVersionsRequest {
    fn default() -> &'a PostInstalledModuleVersionsRequest {
        <PostInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInstalledModuleVersionsRequest {
    pub fn new() -> PostInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut PostInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "installed_module_versions",
            |m: &PostInstalledModuleVersionsRequest| { &m.installed_module_versions },
            |m: &mut PostInstalledModuleVersionsRequest| { &mut m.installed_module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInstalledModuleVersionsRequest>(
            "PostInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInstalledModuleVersionsRequest {
    const NAME: &'static str = "PostInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.installed_module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.installed_module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInstalledModuleVersionsRequest {
        PostInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInstalledModuleVersionsRequest {
        static instance: PostInstalledModuleVersionsRequest = PostInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostInstalledModuleVersionsKeyRequest to associate a key of the caller's to the installed module
///  version.
// @@protoc_insertion_point(message:clarifai.api.PostInstalledModuleVersionsKeyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInstalledModuleVersionsKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsKeyRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  the ID to get of the install module version.
    // @@protoc_insertion_point(field:clarifai.api.PostInstalledModuleVersionsKeyRequest.installed_module_version_id)
    pub installed_module_version_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInstalledModuleVersionsKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInstalledModuleVersionsKeyRequest {
    fn default() -> &'a PostInstalledModuleVersionsKeyRequest {
        <PostInstalledModuleVersionsKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInstalledModuleVersionsKeyRequest {
    pub fn new() -> PostInstalledModuleVersionsKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInstalledModuleVersionsKeyRequest| { &m.user_app_id },
            |m: &mut PostInstalledModuleVersionsKeyRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "installed_module_version_id",
            |m: &PostInstalledModuleVersionsKeyRequest| { &m.installed_module_version_id },
            |m: &mut PostInstalledModuleVersionsKeyRequest| { &mut m.installed_module_version_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInstalledModuleVersionsKeyRequest>(
            "PostInstalledModuleVersionsKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInstalledModuleVersionsKeyRequest {
    const NAME: &'static str = "PostInstalledModuleVersionsKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.installed_module_version_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.installed_module_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.installed_module_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.installed_module_version_id.is_empty() {
            os.write_string(2, &self.installed_module_version_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInstalledModuleVersionsKeyRequest {
        PostInstalledModuleVersionsKeyRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.installed_module_version_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInstalledModuleVersionsKeyRequest {
        static instance: PostInstalledModuleVersionsKeyRequest = PostInstalledModuleVersionsKeyRequest {
            user_app_id: ::protobuf::MessageField::none(),
            installed_module_version_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInstalledModuleVersionsKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInstalledModuleVersionsKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInstalledModuleVersionsKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInstalledModuleVersionsKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several installed module versions by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteInstalledModuleVersionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteInstalledModuleVersionsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteInstalledModuleVersionsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteInstalledModuleVersionsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteInstalledModuleVersionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteInstalledModuleVersionsRequest {
    fn default() -> &'a DeleteInstalledModuleVersionsRequest {
        <DeleteInstalledModuleVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInstalledModuleVersionsRequest {
    pub fn new() -> DeleteInstalledModuleVersionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteInstalledModuleVersionsRequest| { &m.user_app_id },
            |m: &mut DeleteInstalledModuleVersionsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteInstalledModuleVersionsRequest| { &m.ids },
            |m: &mut DeleteInstalledModuleVersionsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteInstalledModuleVersionsRequest>(
            "DeleteInstalledModuleVersionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteInstalledModuleVersionsRequest {
    const NAME: &'static str = "DeleteInstalledModuleVersionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteInstalledModuleVersionsRequest {
        DeleteInstalledModuleVersionsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteInstalledModuleVersionsRequest {
        static instance: DeleteInstalledModuleVersionsRequest = DeleteInstalledModuleVersionsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteInstalledModuleVersionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteInstalledModuleVersionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteInstalledModuleVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInstalledModuleVersionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInstalledModuleVersionResponse
// @@protoc_insertion_point(message:clarifai.api.SingleInstalledModuleVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInstalledModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInstalledModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInstalledModuleVersionResponse.installed_module_version)
    pub installed_module_version: ::protobuf::MessageField<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInstalledModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInstalledModuleVersionResponse {
    fn default() -> &'a SingleInstalledModuleVersionResponse {
        <SingleInstalledModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInstalledModuleVersionResponse {
    pub fn new() -> SingleInstalledModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInstalledModuleVersionResponse| { &m.status },
            |m: &mut SingleInstalledModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InstalledModuleVersion>(
            "installed_module_version",
            |m: &SingleInstalledModuleVersionResponse| { &m.installed_module_version },
            |m: &mut SingleInstalledModuleVersionResponse| { &mut m.installed_module_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInstalledModuleVersionResponse>(
            "SingleInstalledModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInstalledModuleVersionResponse {
    const NAME: &'static str = "SingleInstalledModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.installed_module_version)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.installed_module_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.installed_module_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInstalledModuleVersionResponse {
        SingleInstalledModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.installed_module_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInstalledModuleVersionResponse {
        static instance: SingleInstalledModuleVersionResponse = SingleInstalledModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            installed_module_version: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInstalledModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInstalledModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInstalledModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInstalledModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInstalledModuleVersionResponse
// @@protoc_insertion_point(message:clarifai.api.MultiInstalledModuleVersionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInstalledModuleVersionResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInstalledModuleVersionResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInstalledModuleVersionResponse.installed_module_versions)
    pub installed_module_versions: ::std::vec::Vec<super::resources::InstalledModuleVersion>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInstalledModuleVersionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInstalledModuleVersionResponse {
    fn default() -> &'a MultiInstalledModuleVersionResponse {
        <MultiInstalledModuleVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInstalledModuleVersionResponse {
    pub fn new() -> MultiInstalledModuleVersionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInstalledModuleVersionResponse| { &m.status },
            |m: &mut MultiInstalledModuleVersionResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "installed_module_versions",
            |m: &MultiInstalledModuleVersionResponse| { &m.installed_module_versions },
            |m: &mut MultiInstalledModuleVersionResponse| { &mut m.installed_module_versions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInstalledModuleVersionResponse>(
            "MultiInstalledModuleVersionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInstalledModuleVersionResponse {
    const NAME: &'static str = "MultiInstalledModuleVersionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.installed_module_versions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.installed_module_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.installed_module_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInstalledModuleVersionResponse {
        MultiInstalledModuleVersionResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.installed_module_versions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInstalledModuleVersionResponse {
        static instance: MultiInstalledModuleVersionResponse = MultiInstalledModuleVersionResponse {
            status: ::protobuf::MessageField::none(),
            installed_module_versions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInstalledModuleVersionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInstalledModuleVersionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInstalledModuleVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInstalledModuleVersionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListNextTaskAssignmentsRequest
// @@protoc_insertion_point(message:clarifai.api.ListNextTaskAssignmentsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListNextTaskAssignmentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListNextTaskAssignmentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListNextTaskAssignmentsRequest.task_id)
    pub task_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListNextTaskAssignmentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListNextTaskAssignmentsRequest {
    fn default() -> &'a ListNextTaskAssignmentsRequest {
        <ListNextTaskAssignmentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListNextTaskAssignmentsRequest {
    pub fn new() -> ListNextTaskAssignmentsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListNextTaskAssignmentsRequest| { &m.user_app_id },
            |m: &mut ListNextTaskAssignmentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &ListNextTaskAssignmentsRequest| { &m.task_id },
            |m: &mut ListNextTaskAssignmentsRequest| { &mut m.task_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListNextTaskAssignmentsRequest>(
            "ListNextTaskAssignmentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListNextTaskAssignmentsRequest {
    const NAME: &'static str = "ListNextTaskAssignmentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListNextTaskAssignmentsRequest {
        ListNextTaskAssignmentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListNextTaskAssignmentsRequest {
        static instance: ListNextTaskAssignmentsRequest = ListNextTaskAssignmentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListNextTaskAssignmentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListNextTaskAssignmentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListNextTaskAssignmentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNextTaskAssignmentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to perform bulk operations on a list of inputs based on input source.
// @@protoc_insertion_point(message:clarifai.api.PostBulkOperationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostBulkOperationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostBulkOperationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation(s) to be performed e.g bulk update metadata or tags or labels etc.
    // @@protoc_insertion_point(field:clarifai.api.PostBulkOperationsRequest.bulk_operations)
    pub bulk_operations: ::std::vec::Vec<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostBulkOperationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostBulkOperationsRequest {
    fn default() -> &'a PostBulkOperationsRequest {
        <PostBulkOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostBulkOperationsRequest {
    pub fn new() -> PostBulkOperationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostBulkOperationsRequest| { &m.user_app_id },
            |m: &mut PostBulkOperationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bulk_operations",
            |m: &PostBulkOperationsRequest| { &m.bulk_operations },
            |m: &mut PostBulkOperationsRequest| { &mut m.bulk_operations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostBulkOperationsRequest>(
            "PostBulkOperationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostBulkOperationsRequest {
    const NAME: &'static str = "PostBulkOperationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.bulk_operations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.bulk_operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.bulk_operations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostBulkOperationsRequest {
        PostBulkOperationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.bulk_operations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostBulkOperationsRequest {
        static instance: PostBulkOperationsRequest = PostBulkOperationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            bulk_operations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostBulkOperationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostBulkOperationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostBulkOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostBulkOperationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to list all the bulk operations.
// @@protoc_insertion_point(message:clarifai.api.ListBulkOperationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListBulkOperationsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListBulkOperationsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListBulkOperationsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListBulkOperationsRequest {
    fn default() -> &'a ListBulkOperationsRequest {
        <ListBulkOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBulkOperationsRequest {
    pub fn new() -> ListBulkOperationsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListBulkOperationsRequest| { &m.user_app_id },
            |m: &mut ListBulkOperationsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListBulkOperationsRequest| { &m.page },
            |m: &mut ListBulkOperationsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListBulkOperationsRequest| { &m.per_page },
            |m: &mut ListBulkOperationsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListBulkOperationsRequest>(
            "ListBulkOperationsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListBulkOperationsRequest {
    const NAME: &'static str = "ListBulkOperationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListBulkOperationsRequest {
        ListBulkOperationsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListBulkOperationsRequest {
        static instance: ListBulkOperationsRequest = ListBulkOperationsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListBulkOperationsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListBulkOperationsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListBulkOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBulkOperationsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to get the details of a bulk operation by ID.
// @@protoc_insertion_point(message:clarifai.api.GetBulkOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The bulk operation id
    // @@protoc_insertion_point(field:clarifai.api.GetBulkOperationRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBulkOperationRequest {
    fn default() -> &'a GetBulkOperationRequest {
        <GetBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBulkOperationRequest {
    pub fn new() -> GetBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetBulkOperationRequest| { &m.user_app_id },
            |m: &mut GetBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetBulkOperationRequest| { &m.id },
            |m: &mut GetBulkOperationRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBulkOperationRequest>(
            "GetBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBulkOperationRequest {
    const NAME: &'static str = "GetBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBulkOperationRequest {
        GetBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBulkOperationRequest {
        static instance: GetBulkOperationRequest = GetBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Cancel a list of bulk operation ids
// @@protoc_insertion_point(message:clarifai.api.CancelBulkOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation ids to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelBulkOperationRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelBulkOperationRequest {
    fn default() -> &'a CancelBulkOperationRequest {
        <CancelBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelBulkOperationRequest {
    pub fn new() -> CancelBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelBulkOperationRequest| { &m.user_app_id },
            |m: &mut CancelBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &CancelBulkOperationRequest| { &m.ids },
            |m: &mut CancelBulkOperationRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelBulkOperationRequest>(
            "CancelBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelBulkOperationRequest {
    const NAME: &'static str = "CancelBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelBulkOperationRequest {
        CancelBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelBulkOperationRequest {
        static instance: CancelBulkOperationRequest = CancelBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete the terminated bulk operations by ID
///  Only operations in terminated state can be deleted.
// @@protoc_insertion_point(message:clarifai.api.DeleteBulkOperationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteBulkOperationRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteBulkOperationRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of bulk operation ids to be deleted
    // @@protoc_insertion_point(field:clarifai.api.DeleteBulkOperationRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteBulkOperationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteBulkOperationRequest {
    fn default() -> &'a DeleteBulkOperationRequest {
        <DeleteBulkOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteBulkOperationRequest {
    pub fn new() -> DeleteBulkOperationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteBulkOperationRequest| { &m.user_app_id },
            |m: &mut DeleteBulkOperationRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteBulkOperationRequest| { &m.ids },
            |m: &mut DeleteBulkOperationRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteBulkOperationRequest>(
            "DeleteBulkOperationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteBulkOperationRequest {
    const NAME: &'static str = "DeleteBulkOperationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteBulkOperationRequest {
        DeleteBulkOperationRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteBulkOperationRequest {
        static instance: DeleteBulkOperationRequest = DeleteBulkOperationRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteBulkOperationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteBulkOperationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteBulkOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteBulkOperationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleBulkOperationsResponse
// @@protoc_insertion_point(message:clarifai.api.SingleBulkOperationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleBulkOperationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleBulkOperationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleBulkOperationsResponse.bulk_operation)
    pub bulk_operation: ::protobuf::MessageField<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleBulkOperationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleBulkOperationsResponse {
    fn default() -> &'a SingleBulkOperationsResponse {
        <SingleBulkOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleBulkOperationsResponse {
    pub fn new() -> SingleBulkOperationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleBulkOperationsResponse| { &m.status },
            |m: &mut SingleBulkOperationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::BulkOperation>(
            "bulk_operation",
            |m: &SingleBulkOperationsResponse| { &m.bulk_operation },
            |m: &mut SingleBulkOperationsResponse| { &mut m.bulk_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleBulkOperationsResponse>(
            "SingleBulkOperationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleBulkOperationsResponse {
    const NAME: &'static str = "SingleBulkOperationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bulk_operation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bulk_operation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bulk_operation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleBulkOperationsResponse {
        SingleBulkOperationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.bulk_operation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleBulkOperationsResponse {
        static instance: SingleBulkOperationsResponse = SingleBulkOperationsResponse {
            status: ::protobuf::MessageField::none(),
            bulk_operation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleBulkOperationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleBulkOperationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleBulkOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleBulkOperationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiBulkOperationsResponse
// @@protoc_insertion_point(message:clarifai.api.MultiBulkOperationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiBulkOperationsResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiBulkOperationsResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiBulkOperationsResponse.bulk_operation)
    pub bulk_operation: ::std::vec::Vec<super::resources::BulkOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiBulkOperationsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiBulkOperationsResponse {
    fn default() -> &'a MultiBulkOperationsResponse {
        <MultiBulkOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiBulkOperationsResponse {
    pub fn new() -> MultiBulkOperationsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiBulkOperationsResponse| { &m.status },
            |m: &mut MultiBulkOperationsResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bulk_operation",
            |m: &MultiBulkOperationsResponse| { &m.bulk_operation },
            |m: &mut MultiBulkOperationsResponse| { &mut m.bulk_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiBulkOperationsResponse>(
            "MultiBulkOperationsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiBulkOperationsResponse {
    const NAME: &'static str = "MultiBulkOperationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.bulk_operation.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.bulk_operation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.bulk_operation {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiBulkOperationsResponse {
        MultiBulkOperationsResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.bulk_operation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiBulkOperationsResponse {
        static instance: MultiBulkOperationsResponse = MultiBulkOperationsResponse {
            status: ::protobuf::MessageField::none(),
            bulk_operation: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiBulkOperationsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiBulkOperationsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiBulkOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiBulkOperationsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PutTaskAssignmentsRequest
// @@protoc_insertion_point(message:clarifai.api.PutTaskAssignmentsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutTaskAssignmentsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.task_id)
    pub task_id: ::std::string::String,
    ///  Deprecated: use action and action_config instead.
    ///  Supported for backwards compatibility: setting this field is equivalent with
    ///  * action = LABEL_SUBMIT
    ///  * label_submit_config = [{"task_assignments": {{"id": "<task-assignment-id-for-input-id>"}}]
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.input_id)
    pub input_id: ::std::string::String,
    ///  Action to perform on selected task.
    // @@protoc_insertion_point(field:clarifai.api.PutTaskAssignmentsRequest.action)
    pub action: ::protobuf::EnumOrUnknown<PutTaskAssignmentsRequestAction>,
    // message oneof groups
    pub action_config: ::std::option::Option<put_task_assignments_request::Action_config>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutTaskAssignmentsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutTaskAssignmentsRequest {
    fn default() -> &'a PutTaskAssignmentsRequest {
        <PutTaskAssignmentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutTaskAssignmentsRequest {
    pub fn new() -> PutTaskAssignmentsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.LabelSubmitConfig label_submit_config = 6;

    pub fn label_submit_config(&self) -> &LabelSubmitConfig {
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::LabelSubmitConfig(ref v)) => v,
            _ => <LabelSubmitConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_label_submit_config(&mut self) {
        self.action_config = ::std::option::Option::None;
    }

    pub fn has_label_submit_config(&self) -> bool {
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::LabelSubmitConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_label_submit_config(&mut self, v: LabelSubmitConfig) {
        self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::LabelSubmitConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_label_submit_config(&mut self) -> &mut LabelSubmitConfig {
        if let ::std::option::Option::Some(put_task_assignments_request::Action_config::LabelSubmitConfig(_)) = self.action_config {
        } else {
            self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::LabelSubmitConfig(LabelSubmitConfig::new()));
        }
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::LabelSubmitConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_label_submit_config(&mut self) -> LabelSubmitConfig {
        if self.has_label_submit_config() {
            match self.action_config.take() {
                ::std::option::Option::Some(put_task_assignments_request::Action_config::LabelSubmitConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            LabelSubmitConfig::new()
        }
    }

    // .clarifai.api.ReviewApproveConfig review_approve_config = 7;

    pub fn review_approve_config(&self) -> &ReviewApproveConfig {
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewApproveConfig(ref v)) => v,
            _ => <ReviewApproveConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_review_approve_config(&mut self) {
        self.action_config = ::std::option::Option::None;
    }

    pub fn has_review_approve_config(&self) -> bool {
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewApproveConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_review_approve_config(&mut self, v: ReviewApproveConfig) {
        self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewApproveConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_review_approve_config(&mut self) -> &mut ReviewApproveConfig {
        if let ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewApproveConfig(_)) = self.action_config {
        } else {
            self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewApproveConfig(ReviewApproveConfig::new()));
        }
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewApproveConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_review_approve_config(&mut self) -> ReviewApproveConfig {
        if self.has_review_approve_config() {
            match self.action_config.take() {
                ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewApproveConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ReviewApproveConfig::new()
        }
    }

    // .clarifai.api.ReviewRequestChangesConfig review_request_changes_config = 8;

    pub fn review_request_changes_config(&self) -> &ReviewRequestChangesConfig {
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRequestChangesConfig(ref v)) => v,
            _ => <ReviewRequestChangesConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_review_request_changes_config(&mut self) {
        self.action_config = ::std::option::Option::None;
    }

    pub fn has_review_request_changes_config(&self) -> bool {
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRequestChangesConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_review_request_changes_config(&mut self, v: ReviewRequestChangesConfig) {
        self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRequestChangesConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_review_request_changes_config(&mut self) -> &mut ReviewRequestChangesConfig {
        if let ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRequestChangesConfig(_)) = self.action_config {
        } else {
            self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRequestChangesConfig(ReviewRequestChangesConfig::new()));
        }
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRequestChangesConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_review_request_changes_config(&mut self) -> ReviewRequestChangesConfig {
        if self.has_review_request_changes_config() {
            match self.action_config.take() {
                ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRequestChangesConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ReviewRequestChangesConfig::new()
        }
    }

    // .clarifai.api.ReviewRejectConfig review_reject_config = 9;

    pub fn review_reject_config(&self) -> &ReviewRejectConfig {
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRejectConfig(ref v)) => v,
            _ => <ReviewRejectConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_review_reject_config(&mut self) {
        self.action_config = ::std::option::Option::None;
    }

    pub fn has_review_reject_config(&self) -> bool {
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRejectConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_review_reject_config(&mut self, v: ReviewRejectConfig) {
        self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRejectConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_review_reject_config(&mut self) -> &mut ReviewRejectConfig {
        if let ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRejectConfig(_)) = self.action_config {
        } else {
            self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRejectConfig(ReviewRejectConfig::new()));
        }
        match self.action_config {
            ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRejectConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_review_reject_config(&mut self) -> ReviewRejectConfig {
        if self.has_review_reject_config() {
            match self.action_config.take() {
                ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRejectConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ReviewRejectConfig::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutTaskAssignmentsRequest| { &m.user_app_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "task_id",
            |m: &PutTaskAssignmentsRequest| { &m.task_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.task_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_id",
            |m: &PutTaskAssignmentsRequest| { &m.input_id },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.input_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &PutTaskAssignmentsRequest| { &m.action },
            |m: &mut PutTaskAssignmentsRequest| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LabelSubmitConfig>(
            "label_submit_config",
            PutTaskAssignmentsRequest::has_label_submit_config,
            PutTaskAssignmentsRequest::label_submit_config,
            PutTaskAssignmentsRequest::mut_label_submit_config,
            PutTaskAssignmentsRequest::set_label_submit_config,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReviewApproveConfig>(
            "review_approve_config",
            PutTaskAssignmentsRequest::has_review_approve_config,
            PutTaskAssignmentsRequest::review_approve_config,
            PutTaskAssignmentsRequest::mut_review_approve_config,
            PutTaskAssignmentsRequest::set_review_approve_config,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReviewRequestChangesConfig>(
            "review_request_changes_config",
            PutTaskAssignmentsRequest::has_review_request_changes_config,
            PutTaskAssignmentsRequest::review_request_changes_config,
            PutTaskAssignmentsRequest::mut_review_request_changes_config,
            PutTaskAssignmentsRequest::set_review_request_changes_config,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReviewRejectConfig>(
            "review_reject_config",
            PutTaskAssignmentsRequest::has_review_reject_config,
            PutTaskAssignmentsRequest::review_reject_config,
            PutTaskAssignmentsRequest::mut_review_reject_config,
            PutTaskAssignmentsRequest::set_review_reject_config,
        ));
        oneofs.push(put_task_assignments_request::Action_config::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutTaskAssignmentsRequest>(
            "PutTaskAssignmentsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutTaskAssignmentsRequest {
    const NAME: &'static str = "PutTaskAssignmentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.task_id = is.read_string()?;
                },
                26 => {
                    self.input_id = is.read_string()?;
                },
                32 => {
                    self.action = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::LabelSubmitConfig(is.read_message()?));
                },
                58 => {
                    self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewApproveConfig(is.read_message()?));
                },
                66 => {
                    self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRequestChangesConfig(is.read_message()?));
                },
                74 => {
                    self.action_config = ::std::option::Option::Some(put_task_assignments_request::Action_config::ReviewRejectConfig(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        if self.action != ::protobuf::EnumOrUnknown::new(PutTaskAssignmentsRequestAction::PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(4, self.action.value());
        }
        if let ::std::option::Option::Some(ref v) = self.action_config {
            match v {
                &put_task_assignments_request::Action_config::LabelSubmitConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &put_task_assignments_request::Action_config::ReviewApproveConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &put_task_assignments_request::Action_config::ReviewRequestChangesConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &put_task_assignments_request::Action_config::ReviewRejectConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(PutTaskAssignmentsRequestAction::PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.action))?;
        }
        if let ::std::option::Option::Some(ref v) = self.action_config {
            match v {
                &put_task_assignments_request::Action_config::LabelSubmitConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &put_task_assignments_request::Action_config::ReviewApproveConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &put_task_assignments_request::Action_config::ReviewRequestChangesConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &put_task_assignments_request::Action_config::ReviewRejectConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutTaskAssignmentsRequest {
        PutTaskAssignmentsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.input_id.clear();
        self.action = ::protobuf::EnumOrUnknown::new(PutTaskAssignmentsRequestAction::PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET);
        self.action_config = ::std::option::Option::None;
        self.action_config = ::std::option::Option::None;
        self.action_config = ::std::option::Option::None;
        self.action_config = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutTaskAssignmentsRequest {
        static instance: PutTaskAssignmentsRequest = PutTaskAssignmentsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            task_id: ::std::string::String::new(),
            input_id: ::std::string::String::new(),
            action: ::protobuf::EnumOrUnknown::from_i32(0),
            action_config: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutTaskAssignmentsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutTaskAssignmentsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutTaskAssignmentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutTaskAssignmentsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PutTaskAssignmentsRequest`
pub mod put_task_assignments_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.PutTaskAssignmentsRequest.action_config)
    pub enum Action_config {
        // @@protoc_insertion_point(oneof_field:clarifai.api.PutTaskAssignmentsRequest.label_submit_config)
        LabelSubmitConfig(super::LabelSubmitConfig),
        // @@protoc_insertion_point(oneof_field:clarifai.api.PutTaskAssignmentsRequest.review_approve_config)
        ReviewApproveConfig(super::ReviewApproveConfig),
        // @@protoc_insertion_point(oneof_field:clarifai.api.PutTaskAssignmentsRequest.review_request_changes_config)
        ReviewRequestChangesConfig(super::ReviewRequestChangesConfig),
        // @@protoc_insertion_point(oneof_field:clarifai.api.PutTaskAssignmentsRequest.review_reject_config)
        ReviewRejectConfig(super::ReviewRejectConfig),
    }

    impl ::protobuf::Oneof for Action_config {
    }

    impl ::protobuf::OneofFull for Action_config {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PutTaskAssignmentsRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("action_config").unwrap()).clone()
        }
    }

    impl Action_config {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action_config>("action_config")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.LabelSubmitConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LabelSubmitConfig {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.LabelSubmitConfig.task_assignments)
    pub task_assignments: ::std::vec::Vec<super::resources::TaskAssignment>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.LabelSubmitConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelSubmitConfig {
    fn default() -> &'a LabelSubmitConfig {
        <LabelSubmitConfig as ::protobuf::Message>::default_instance()
    }
}

impl LabelSubmitConfig {
    pub fn new() -> LabelSubmitConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "task_assignments",
            |m: &LabelSubmitConfig| { &m.task_assignments },
            |m: &mut LabelSubmitConfig| { &mut m.task_assignments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelSubmitConfig>(
            "LabelSubmitConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelSubmitConfig {
    const NAME: &'static str = "LabelSubmitConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.task_assignments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.task_assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.task_assignments {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelSubmitConfig {
        LabelSubmitConfig::new()
    }

    fn clear(&mut self) {
        self.task_assignments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelSubmitConfig {
        static instance: LabelSubmitConfig = LabelSubmitConfig {
            task_assignments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelSubmitConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelSubmitConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelSubmitConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelSubmitConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ReviewApproveConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReviewApproveConfig {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ReviewApproveConfig.task_assignments)
    pub task_assignments: ::std::vec::Vec<super::resources::TaskAssignment>,
    // @@protoc_insertion_point(field:clarifai.api.ReviewApproveConfig.workers)
    pub workers: ::std::vec::Vec<super::resources::Worker>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ReviewApproveConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReviewApproveConfig {
    fn default() -> &'a ReviewApproveConfig {
        <ReviewApproveConfig as ::protobuf::Message>::default_instance()
    }
}

impl ReviewApproveConfig {
    pub fn new() -> ReviewApproveConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "task_assignments",
            |m: &ReviewApproveConfig| { &m.task_assignments },
            |m: &mut ReviewApproveConfig| { &mut m.task_assignments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workers",
            |m: &ReviewApproveConfig| { &m.workers },
            |m: &mut ReviewApproveConfig| { &mut m.workers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReviewApproveConfig>(
            "ReviewApproveConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReviewApproveConfig {
    const NAME: &'static str = "ReviewApproveConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.task_assignments.push(is.read_message()?);
                },
                18 => {
                    self.workers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.task_assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.workers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.task_assignments {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.workers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReviewApproveConfig {
        ReviewApproveConfig::new()
    }

    fn clear(&mut self) {
        self.task_assignments.clear();
        self.workers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReviewApproveConfig {
        static instance: ReviewApproveConfig = ReviewApproveConfig {
            task_assignments: ::std::vec::Vec::new(),
            workers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReviewApproveConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReviewApproveConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReviewApproveConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewApproveConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ReviewRequestChangesConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReviewRequestChangesConfig {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ReviewRequestChangesConfig.task_assignments)
    pub task_assignments: ::std::vec::Vec<super::resources::TaskAssignment>,
    // @@protoc_insertion_point(field:clarifai.api.ReviewRequestChangesConfig.workers)
    pub workers: ::std::vec::Vec<super::resources::Worker>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ReviewRequestChangesConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReviewRequestChangesConfig {
    fn default() -> &'a ReviewRequestChangesConfig {
        <ReviewRequestChangesConfig as ::protobuf::Message>::default_instance()
    }
}

impl ReviewRequestChangesConfig {
    pub fn new() -> ReviewRequestChangesConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "task_assignments",
            |m: &ReviewRequestChangesConfig| { &m.task_assignments },
            |m: &mut ReviewRequestChangesConfig| { &mut m.task_assignments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workers",
            |m: &ReviewRequestChangesConfig| { &m.workers },
            |m: &mut ReviewRequestChangesConfig| { &mut m.workers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReviewRequestChangesConfig>(
            "ReviewRequestChangesConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReviewRequestChangesConfig {
    const NAME: &'static str = "ReviewRequestChangesConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.task_assignments.push(is.read_message()?);
                },
                18 => {
                    self.workers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.task_assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.workers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.task_assignments {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.workers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReviewRequestChangesConfig {
        ReviewRequestChangesConfig::new()
    }

    fn clear(&mut self) {
        self.task_assignments.clear();
        self.workers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReviewRequestChangesConfig {
        static instance: ReviewRequestChangesConfig = ReviewRequestChangesConfig {
            task_assignments: ::std::vec::Vec::new(),
            workers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReviewRequestChangesConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReviewRequestChangesConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReviewRequestChangesConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewRequestChangesConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ReviewRejectConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReviewRejectConfig {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ReviewRejectConfig.task_assignments)
    pub task_assignments: ::std::vec::Vec<super::resources::TaskAssignment>,
    // @@protoc_insertion_point(field:clarifai.api.ReviewRejectConfig.workers)
    pub workers: ::std::vec::Vec<super::resources::Worker>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ReviewRejectConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReviewRejectConfig {
    fn default() -> &'a ReviewRejectConfig {
        <ReviewRejectConfig as ::protobuf::Message>::default_instance()
    }
}

impl ReviewRejectConfig {
    pub fn new() -> ReviewRejectConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "task_assignments",
            |m: &ReviewRejectConfig| { &m.task_assignments },
            |m: &mut ReviewRejectConfig| { &mut m.task_assignments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workers",
            |m: &ReviewRejectConfig| { &m.workers },
            |m: &mut ReviewRejectConfig| { &mut m.workers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReviewRejectConfig>(
            "ReviewRejectConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReviewRejectConfig {
    const NAME: &'static str = "ReviewRejectConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.task_assignments.push(is.read_message()?);
                },
                18 => {
                    self.workers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.task_assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.workers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.task_assignments {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.workers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReviewRejectConfig {
        ReviewRejectConfig::new()
    }

    fn clear(&mut self) {
        self.task_assignments.clear();
        self.workers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReviewRejectConfig {
        static instance: ReviewRejectConfig = ReviewRejectConfig {
            task_assignments: ::std::vec::Vec::new(),
            workers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReviewRejectConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReviewRejectConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReviewRejectConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewRejectConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiTaskAssignmentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiTaskAssignmentResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTaskAssignmentResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTaskAssignmentResponse.task_assignments)
    pub task_assignments: ::std::vec::Vec<super::resources::TaskAssignment>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTaskAssignmentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTaskAssignmentResponse {
    fn default() -> &'a MultiTaskAssignmentResponse {
        <MultiTaskAssignmentResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTaskAssignmentResponse {
    pub fn new() -> MultiTaskAssignmentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTaskAssignmentResponse| { &m.status },
            |m: &mut MultiTaskAssignmentResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "task_assignments",
            |m: &MultiTaskAssignmentResponse| { &m.task_assignments },
            |m: &mut MultiTaskAssignmentResponse| { &mut m.task_assignments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTaskAssignmentResponse>(
            "MultiTaskAssignmentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTaskAssignmentResponse {
    const NAME: &'static str = "MultiTaskAssignmentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.task_assignments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.task_assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.task_assignments {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTaskAssignmentResponse {
        MultiTaskAssignmentResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.task_assignments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTaskAssignmentResponse {
        static instance: MultiTaskAssignmentResponse = MultiTaskAssignmentResponse {
            status: ::protobuf::MessageField::none(),
            task_assignments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTaskAssignmentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTaskAssignmentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTaskAssignmentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTaskAssignmentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  List all the input ingestion jobs
// @@protoc_insertion_point(message:clarifai.api.ListInputsAddJobsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListInputsAddJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsAddJobsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsAddJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsAddJobsRequest {
    fn default() -> &'a ListInputsAddJobsRequest {
        <ListInputsAddJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsAddJobsRequest {
    pub fn new() -> ListInputsAddJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsAddJobsRequest| { &m.user_app_id },
            |m: &mut ListInputsAddJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsAddJobsRequest| { &m.page },
            |m: &mut ListInputsAddJobsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsAddJobsRequest| { &m.per_page },
            |m: &mut ListInputsAddJobsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsAddJobsRequest>(
            "ListInputsAddJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsAddJobsRequest {
    const NAME: &'static str = "ListInputsAddJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsAddJobsRequest {
        ListInputsAddJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsAddJobsRequest {
        static instance: ListInputsAddJobsRequest = ListInputsAddJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsAddJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsAddJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsAddJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsAddJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetInputsAddJobRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputsAddJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputsAddJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of add inputs job
    // @@protoc_insertion_point(field:clarifai.api.GetInputsAddJobRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputsAddJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputsAddJobRequest {
    fn default() -> &'a GetInputsAddJobRequest {
        <GetInputsAddJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputsAddJobRequest {
    pub fn new() -> GetInputsAddJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputsAddJobRequest| { &m.user_app_id },
            |m: &mut GetInputsAddJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetInputsAddJobRequest| { &m.id },
            |m: &mut GetInputsAddJobRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputsAddJobRequest>(
            "GetInputsAddJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputsAddJobRequest {
    const NAME: &'static str = "GetInputsAddJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputsAddJobRequest {
        GetInputsAddJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputsAddJobRequest {
        static instance: GetInputsAddJobRequest = GetInputsAddJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputsAddJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputsAddJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputsAddJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputsAddJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.CancelInputsAddJobRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelInputsAddJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsAddJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  id of add inputs job to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsAddJobRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelInputsAddJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelInputsAddJobRequest {
    fn default() -> &'a CancelInputsAddJobRequest {
        <CancelInputsAddJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelInputsAddJobRequest {
    pub fn new() -> CancelInputsAddJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelInputsAddJobRequest| { &m.user_app_id },
            |m: &mut CancelInputsAddJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CancelInputsAddJobRequest| { &m.id },
            |m: &mut CancelInputsAddJobRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelInputsAddJobRequest>(
            "CancelInputsAddJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelInputsAddJobRequest {
    const NAME: &'static str = "CancelInputsAddJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelInputsAddJobRequest {
        CancelInputsAddJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelInputsAddJobRequest {
        static instance: CancelInputsAddJobRequest = CancelInputsAddJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelInputsAddJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelInputsAddJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelInputsAddJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelInputsAddJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiInputsAddJobResponse
// @@protoc_insertion_point(message:clarifai.api.MultiInputsAddJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInputsAddJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsAddJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsAddJobResponse.inputs_add_jobs)
    pub inputs_add_jobs: ::std::vec::Vec<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputsAddJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputsAddJobResponse {
    fn default() -> &'a MultiInputsAddJobResponse {
        <MultiInputsAddJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputsAddJobResponse {
    pub fn new() -> MultiInputsAddJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputsAddJobResponse| { &m.status },
            |m: &mut MultiInputsAddJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_add_jobs",
            |m: &MultiInputsAddJobResponse| { &m.inputs_add_jobs },
            |m: &mut MultiInputsAddJobResponse| { &mut m.inputs_add_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputsAddJobResponse>(
            "MultiInputsAddJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputsAddJobResponse {
    const NAME: &'static str = "MultiInputsAddJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs_add_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_add_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_add_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputsAddJobResponse {
        MultiInputsAddJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_add_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputsAddJobResponse {
        static instance: MultiInputsAddJobResponse = MultiInputsAddJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_add_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputsAddJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputsAddJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputsAddJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputsAddJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleInputsAddJobResponse
// @@protoc_insertion_point(message:clarifai.api.SingleInputsAddJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInputsAddJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsAddJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsAddJobResponse.inputs_add_job)
    pub inputs_add_job: ::protobuf::MessageField<super::resources::InputsAddJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputsAddJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputsAddJobResponse {
    fn default() -> &'a SingleInputsAddJobResponse {
        <SingleInputsAddJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputsAddJobResponse {
    pub fn new() -> SingleInputsAddJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputsAddJobResponse| { &m.status },
            |m: &mut SingleInputsAddJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsAddJob>(
            "inputs_add_job",
            |m: &SingleInputsAddJobResponse| { &m.inputs_add_job },
            |m: &mut SingleInputsAddJobResponse| { &mut m.inputs_add_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputsAddJobResponse>(
            "SingleInputsAddJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputsAddJobResponse {
    const NAME: &'static str = "SingleInputsAddJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_add_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inputs_add_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.inputs_add_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputsAddJobResponse {
        SingleInputsAddJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_add_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputsAddJobResponse {
        static instance: SingleInputsAddJobResponse = SingleInputsAddJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_add_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputsAddJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputsAddJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputsAddJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputsAddJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start a multipart upload
// @@protoc_insertion_point(message:clarifai.api.PostUploadsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostUploadsRequest.uploads)
    pub uploads: ::std::vec::Vec<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostUploadsRequest {
    fn default() -> &'a PostUploadsRequest {
        <PostUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostUploadsRequest {
    pub fn new() -> PostUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostUploadsRequest| { &m.user_app_id },
            |m: &mut PostUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uploads",
            |m: &PostUploadsRequest| { &m.uploads },
            |m: &mut PostUploadsRequest| { &mut m.uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostUploadsRequest>(
            "PostUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostUploadsRequest {
    const NAME: &'static str = "PostUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostUploadsRequest {
        PostUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostUploadsRequest {
        static instance: PostUploadsRequest = PostUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Stops or deletes multipart upload
// @@protoc_insertion_point(message:clarifai.api.DeleteUploadsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteUploadsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteUploadsRequest {
    fn default() -> &'a DeleteUploadsRequest {
        <DeleteUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteUploadsRequest {
    pub fn new() -> DeleteUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteUploadsRequest| { &m.user_app_id },
            |m: &mut DeleteUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteUploadsRequest| { &m.ids },
            |m: &mut DeleteUploadsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteUploadsRequest>(
            "DeleteUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteUploadsRequest {
    const NAME: &'static str = "DeleteUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteUploadsRequest {
        DeleteUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteUploadsRequest {
        static instance: DeleteUploadsRequest = DeleteUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListUploadsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListUploadsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListUploadsRequest {
    fn default() -> &'a ListUploadsRequest {
        <ListUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUploadsRequest {
    pub fn new() -> ListUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListUploadsRequest| { &m.user_app_id },
            |m: &mut ListUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListUploadsRequest| { &m.page },
            |m: &mut ListUploadsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListUploadsRequest| { &m.per_page },
            |m: &mut ListUploadsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListUploadsRequest>(
            "ListUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListUploadsRequest {
    const NAME: &'static str = "ListUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListUploadsRequest {
        ListUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListUploadsRequest {
        static instance: ListUploadsRequest = ListUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetUploadRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  Upload ID
    // @@protoc_insertion_point(field:clarifai.api.GetUploadRequest.upload_id)
    pub upload_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUploadRequest {
    fn default() -> &'a GetUploadRequest {
        <GetUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUploadRequest {
    pub fn new() -> GetUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetUploadRequest| { &m.user_app_id },
            |m: &mut GetUploadRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_id",
            |m: &GetUploadRequest| { &m.upload_id },
            |m: &mut GetUploadRequest| { &mut m.upload_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUploadRequest>(
            "GetUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUploadRequest {
    const NAME: &'static str = "GetUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.upload_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.upload_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.upload_id.is_empty() {
            os.write_string(2, &self.upload_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUploadRequest {
        GetUploadRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.upload_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUploadRequest {
        static instance: GetUploadRequest = GetUploadRequest {
            user_app_id: ::protobuf::MessageField::none(),
            upload_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SingleUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleUploadResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleUploadResponse.upload)
    pub upload: ::protobuf::MessageField<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleUploadResponse {
    fn default() -> &'a SingleUploadResponse {
        <SingleUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleUploadResponse {
    pub fn new() -> SingleUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleUploadResponse| { &m.status },
            |m: &mut SingleUploadResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Upload>(
            "upload",
            |m: &SingleUploadResponse| { &m.upload },
            |m: &mut SingleUploadResponse| { &mut m.upload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleUploadResponse>(
            "SingleUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleUploadResponse {
    const NAME: &'static str = "SingleUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.upload)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.upload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.upload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleUploadResponse {
        SingleUploadResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.upload.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleUploadResponse {
        static instance: SingleUploadResponse = SingleUploadResponse {
            status: ::protobuf::MessageField::none(),
            upload: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiUploadResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiUploadResponse.uploads)
    pub uploads: ::std::vec::Vec<super::resources::Upload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiUploadResponse {
    fn default() -> &'a MultiUploadResponse {
        <MultiUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiUploadResponse {
    pub fn new() -> MultiUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiUploadResponse| { &m.status },
            |m: &mut MultiUploadResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uploads",
            |m: &MultiUploadResponse| { &m.uploads },
            |m: &mut MultiUploadResponse| { &mut m.uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiUploadResponse>(
            "MultiUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiUploadResponse {
    const NAME: &'static str = "MultiUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiUploadResponse {
        MultiUploadResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiUploadResponse {
        static instance: MultiUploadResponse = MultiUploadResponse {
            status: ::protobuf::MessageField::none(),
            uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Upload a part of a multipart upload.
///  Behaviour on completion depends on the endpoint that was used to initiate the upload.
// @@protoc_insertion_point(message:clarifai.api.PutUploadContentPartsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutUploadContentPartsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.upload_id)
    pub upload_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PutUploadContentPartsRequest.content_parts)
    pub content_parts: ::std::vec::Vec<super::resources::UploadContentPart>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PutUploadContentPartsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutUploadContentPartsRequest {
    fn default() -> &'a PutUploadContentPartsRequest {
        <PutUploadContentPartsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutUploadContentPartsRequest {
    pub fn new() -> PutUploadContentPartsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PutUploadContentPartsRequest| { &m.user_app_id },
            |m: &mut PutUploadContentPartsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_id",
            |m: &PutUploadContentPartsRequest| { &m.upload_id },
            |m: &mut PutUploadContentPartsRequest| { &mut m.upload_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_parts",
            |m: &PutUploadContentPartsRequest| { &m.content_parts },
            |m: &mut PutUploadContentPartsRequest| { &mut m.content_parts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutUploadContentPartsRequest>(
            "PutUploadContentPartsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutUploadContentPartsRequest {
    const NAME: &'static str = "PutUploadContentPartsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.upload_id = is.read_string()?;
                },
                26 => {
                    self.content_parts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.upload_id);
        }
        for value in &self.content_parts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.upload_id.is_empty() {
            os.write_string(2, &self.upload_id)?;
        }
        for v in &self.content_parts {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutUploadContentPartsRequest {
        PutUploadContentPartsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.upload_id.clear();
        self.content_parts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutUploadContentPartsRequest {
        static instance: PutUploadContentPartsRequest = PutUploadContentPartsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            upload_id: ::std::string::String::new(),
            content_parts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutUploadContentPartsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutUploadContentPartsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutUploadContentPartsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutUploadContentPartsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Initiates retrieval of inputs from cloud storage from a user provided data source.
///  Will create and return an inputs-add-job for tracking progress.
///  Archives will be extracted and their contents will be processed as inputs.
///
///  The cloud URL will be treated as a filter prefix. For example s3:/bucket/images_folder/abc will process
///  files in the images_folder beginning with abc or in a subfolder beginning with abc.
///  For example:
///  bucket/images_folder/abcImage.png
///  bucket/images_folder/abc-1/Data.zip
///
///  If given URL is for a private bucket or file, then credentials should be provided to access the bucket.
///  Credentials should include rights to list the objects in the bucket, except when pointed directly at a file archive,
///  in which case it only requires rights to access that particular file.
// @@protoc_insertion_point(message:clarifai.api.PostInputsDataSourcesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInputsDataSourcesRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.data_sources)
    pub data_sources: ::std::vec::Vec<super::resources::InputsDataSource>,
    ///  If call back url is set, we will send a Post request to this endpoint with job status.
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.call_back_url)
    pub call_back_url: ::std::string::String,
    ///  Personal Access Token to the application to which inputs are added
    // @@protoc_insertion_point(field:clarifai.api.PostInputsDataSourcesRequest.app_pat)
    pub app_pat: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsDataSourcesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsDataSourcesRequest {
    fn default() -> &'a PostInputsDataSourcesRequest {
        <PostInputsDataSourcesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsDataSourcesRequest {
    pub fn new() -> PostInputsDataSourcesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsDataSourcesRequest| { &m.user_app_id },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_sources",
            |m: &PostInputsDataSourcesRequest| { &m.data_sources },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.data_sources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "call_back_url",
            |m: &PostInputsDataSourcesRequest| { &m.call_back_url },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.call_back_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "app_pat",
            |m: &PostInputsDataSourcesRequest| { &m.app_pat },
            |m: &mut PostInputsDataSourcesRequest| { &mut m.app_pat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsDataSourcesRequest>(
            "PostInputsDataSourcesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsDataSourcesRequest {
    const NAME: &'static str = "PostInputsDataSourcesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.data_sources.push(is.read_message()?);
                },
                26 => {
                    self.call_back_url = is.read_string()?;
                },
                34 => {
                    self.app_pat = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.data_sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.call_back_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.call_back_url);
        }
        if !self.app_pat.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.app_pat);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.data_sources {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.call_back_url.is_empty() {
            os.write_string(3, &self.call_back_url)?;
        }
        if !self.app_pat.is_empty() {
            os.write_string(4, &self.app_pat)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsDataSourcesRequest {
        PostInputsDataSourcesRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.data_sources.clear();
        self.call_back_url.clear();
        self.app_pat.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsDataSourcesRequest {
        static instance: PostInputsDataSourcesRequest = PostInputsDataSourcesRequest {
            user_app_id: ::protobuf::MessageField::none(),
            data_sources: ::std::vec::Vec::new(),
            call_back_url: ::std::string::String::new(),
            app_pat: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsDataSourcesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsDataSourcesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsDataSourcesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsDataSourcesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.GetInputsExtractionJobRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetInputsExtractionJobRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetInputsExtractionJobRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetInputsExtractionJobRequest.inputs_extraction_job_id)
    pub inputs_extraction_job_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetInputsExtractionJobRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetInputsExtractionJobRequest {
    fn default() -> &'a GetInputsExtractionJobRequest {
        <GetInputsExtractionJobRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputsExtractionJobRequest {
    pub fn new() -> GetInputsExtractionJobRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetInputsExtractionJobRequest| { &m.user_app_id },
            |m: &mut GetInputsExtractionJobRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inputs_extraction_job_id",
            |m: &GetInputsExtractionJobRequest| { &m.inputs_extraction_job_id },
            |m: &mut GetInputsExtractionJobRequest| { &mut m.inputs_extraction_job_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInputsExtractionJobRequest>(
            "GetInputsExtractionJobRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetInputsExtractionJobRequest {
    const NAME: &'static str = "GetInputsExtractionJobRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs_extraction_job_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.inputs_extraction_job_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.inputs_extraction_job_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.inputs_extraction_job_id.is_empty() {
            os.write_string(2, &self.inputs_extraction_job_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetInputsExtractionJobRequest {
        GetInputsExtractionJobRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs_extraction_job_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetInputsExtractionJobRequest {
        static instance: GetInputsExtractionJobRequest = GetInputsExtractionJobRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs_extraction_job_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetInputsExtractionJobRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetInputsExtractionJobRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetInputsExtractionJobRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputsExtractionJobRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListInputsExtractionJobsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListInputsExtractionJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListInputsExtractionJobsRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListInputsExtractionJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListInputsExtractionJobsRequest {
    fn default() -> &'a ListInputsExtractionJobsRequest {
        <ListInputsExtractionJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsExtractionJobsRequest {
    pub fn new() -> ListInputsExtractionJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListInputsExtractionJobsRequest| { &m.user_app_id },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListInputsExtractionJobsRequest| { &m.page },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListInputsExtractionJobsRequest| { &m.per_page },
            |m: &mut ListInputsExtractionJobsRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListInputsExtractionJobsRequest>(
            "ListInputsExtractionJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListInputsExtractionJobsRequest {
    const NAME: &'static str = "ListInputsExtractionJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListInputsExtractionJobsRequest {
        ListInputsExtractionJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListInputsExtractionJobsRequest {
        static instance: ListInputsExtractionJobsRequest = ListInputsExtractionJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListInputsExtractionJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListInputsExtractionJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListInputsExtractionJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsExtractionJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.SingleInputsExtractionJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleInputsExtractionJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsExtractionJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleInputsExtractionJobResponse.inputs_extraction_job)
    pub inputs_extraction_job: ::protobuf::MessageField<super::resources::InputsExtractionJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleInputsExtractionJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleInputsExtractionJobResponse {
    fn default() -> &'a SingleInputsExtractionJobResponse {
        <SingleInputsExtractionJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputsExtractionJobResponse {
    pub fn new() -> SingleInputsExtractionJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleInputsExtractionJobResponse| { &m.status },
            |m: &mut SingleInputsExtractionJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::InputsExtractionJob>(
            "inputs_extraction_job",
            |m: &SingleInputsExtractionJobResponse| { &m.inputs_extraction_job },
            |m: &mut SingleInputsExtractionJobResponse| { &mut m.inputs_extraction_job },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleInputsExtractionJobResponse>(
            "SingleInputsExtractionJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleInputsExtractionJobResponse {
    const NAME: &'static str = "SingleInputsExtractionJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inputs_extraction_job)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.inputs_extraction_job.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.inputs_extraction_job.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleInputsExtractionJobResponse {
        SingleInputsExtractionJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_extraction_job.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleInputsExtractionJobResponse {
        static instance: SingleInputsExtractionJobResponse = SingleInputsExtractionJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_extraction_job: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleInputsExtractionJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleInputsExtractionJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleInputsExtractionJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputsExtractionJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.MultiInputsExtractionJobResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiInputsExtractionJobResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsExtractionJobResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiInputsExtractionJobResponse.inputs_extraction_jobs)
    pub inputs_extraction_jobs: ::std::vec::Vec<super::resources::InputsExtractionJob>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiInputsExtractionJobResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiInputsExtractionJobResponse {
    fn default() -> &'a MultiInputsExtractionJobResponse {
        <MultiInputsExtractionJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputsExtractionJobResponse {
    pub fn new() -> MultiInputsExtractionJobResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiInputsExtractionJobResponse| { &m.status },
            |m: &mut MultiInputsExtractionJobResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_extraction_jobs",
            |m: &MultiInputsExtractionJobResponse| { &m.inputs_extraction_jobs },
            |m: &mut MultiInputsExtractionJobResponse| { &mut m.inputs_extraction_jobs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiInputsExtractionJobResponse>(
            "MultiInputsExtractionJobResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiInputsExtractionJobResponse {
    const NAME: &'static str = "MultiInputsExtractionJobResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.inputs_extraction_jobs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_extraction_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_extraction_jobs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiInputsExtractionJobResponse {
        MultiInputsExtractionJobResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.inputs_extraction_jobs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiInputsExtractionJobResponse {
        static instance: MultiInputsExtractionJobResponse = MultiInputsExtractionJobResponse {
            status: ::protobuf::MessageField::none(),
            inputs_extraction_jobs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiInputsExtractionJobResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiInputsExtractionJobResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiInputsExtractionJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputsExtractionJobResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Cancel a list of extraction job ids
// @@protoc_insertion_point(message:clarifai.api.CancelInputsExtractionJobsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CancelInputsExtractionJobsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsExtractionJobsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  List of extraction job ids to be cancelled
    // @@protoc_insertion_point(field:clarifai.api.CancelInputsExtractionJobsRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.CancelInputsExtractionJobsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelInputsExtractionJobsRequest {
    fn default() -> &'a CancelInputsExtractionJobsRequest {
        <CancelInputsExtractionJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelInputsExtractionJobsRequest {
    pub fn new() -> CancelInputsExtractionJobsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &CancelInputsExtractionJobsRequest| { &m.user_app_id },
            |m: &mut CancelInputsExtractionJobsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &CancelInputsExtractionJobsRequest| { &m.ids },
            |m: &mut CancelInputsExtractionJobsRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelInputsExtractionJobsRequest>(
            "CancelInputsExtractionJobsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelInputsExtractionJobsRequest {
    const NAME: &'static str = "CancelInputsExtractionJobsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelInputsExtractionJobsRequest {
        CancelInputsExtractionJobsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelInputsExtractionJobsRequest {
        static instance: CancelInputsExtractionJobsRequest = CancelInputsExtractionJobsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelInputsExtractionJobsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelInputsExtractionJobsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelInputsExtractionJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelInputsExtractionJobsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Start uploading a file archive containing inputs.
///  Will create and return an inputs-add-job for tracking progress.
///
///  Associated inputs-add-job contains an upload id which should be completed through `PutUploadContentParts` endpoint.
///  Completing the upload will automatically begin unpacking the archive and uploading the contents as inputs.
// @@protoc_insertion_point(message:clarifai.api.PostInputsUploadsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostInputsUploadsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostInputsUploadsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostInputsUploadsRequest.inputs_uploads)
    pub inputs_uploads: ::std::vec::Vec<super::resources::InputsUpload>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostInputsUploadsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostInputsUploadsRequest {
    fn default() -> &'a PostInputsUploadsRequest {
        <PostInputsUploadsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsUploadsRequest {
    pub fn new() -> PostInputsUploadsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostInputsUploadsRequest| { &m.user_app_id },
            |m: &mut PostInputsUploadsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs_uploads",
            |m: &PostInputsUploadsRequest| { &m.inputs_uploads },
            |m: &mut PostInputsUploadsRequest| { &mut m.inputs_uploads },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostInputsUploadsRequest>(
            "PostInputsUploadsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostInputsUploadsRequest {
    const NAME: &'static str = "PostInputsUploadsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.inputs_uploads.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inputs_uploads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inputs_uploads {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostInputsUploadsRequest {
        PostInputsUploadsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs_uploads.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostInputsUploadsRequest {
        static instance: PostInputsUploadsRequest = PostInputsUploadsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            inputs_uploads: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostInputsUploadsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostInputsUploadsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostInputsUploadsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsUploadsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  GetRunnerRequest
// @@protoc_insertion_point(message:clarifai.api.GetRunnerRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetRunnerRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.GetRunnerRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.GetRunnerRequest.runner_id)
    pub runner_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.GetRunnerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetRunnerRequest {
    fn default() -> &'a GetRunnerRequest {
        <GetRunnerRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRunnerRequest {
    pub fn new() -> GetRunnerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &GetRunnerRequest| { &m.user_app_id },
            |m: &mut GetRunnerRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &GetRunnerRequest| { &m.runner_id },
            |m: &mut GetRunnerRequest| { &mut m.runner_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetRunnerRequest>(
            "GetRunnerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetRunnerRequest {
    const NAME: &'static str = "GetRunnerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetRunnerRequest {
        GetRunnerRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetRunnerRequest {
        static instance: GetRunnerRequest = GetRunnerRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetRunnerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetRunnerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetRunnerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRunnerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ListRunnersRequest
// @@protoc_insertion_point(message:clarifai.api.ListRunnersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  (optional URL parameter) The page number. Pagination is used to split the results into chunks.
    ///  Defaults to 1.
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.page)
    pub page: u32,
    ///  (optional URL parameter) The number of results that will be contained in each page. Defaults
    ///  to 128.
    // @@protoc_insertion_point(field:clarifai.api.ListRunnersRequest.per_page)
    pub per_page: u32,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRunnersRequest {
    fn default() -> &'a ListRunnersRequest {
        <ListRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRunnersRequest {
    pub fn new() -> ListRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListRunnersRequest| { &m.user_app_id },
            |m: &mut ListRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ListRunnersRequest| { &m.page },
            |m: &mut ListRunnersRequest| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "per_page",
            |m: &ListRunnersRequest| { &m.per_page },
            |m: &mut ListRunnersRequest| { &mut m.per_page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRunnersRequest>(
            "ListRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRunnersRequest {
    const NAME: &'static str = "ListRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.per_page = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.per_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRunnersRequest {
        ListRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRunnersRequest {
        static instance: ListRunnersRequest = ListRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            page: 0,
            per_page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostRunnersRequest
// @@protoc_insertion_point(message:clarifai.api.PostRunnersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  This allows you to create one or more runner by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnersRequest.runners)
    pub runners: ::std::vec::Vec<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostRunnersRequest {
    fn default() -> &'a PostRunnersRequest {
        <PostRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostRunnersRequest {
    pub fn new() -> PostRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostRunnersRequest| { &m.user_app_id },
            |m: &mut PostRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runners",
            |m: &PostRunnersRequest| { &m.runners },
            |m: &mut PostRunnersRequest| { &mut m.runners },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostRunnersRequest>(
            "PostRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostRunnersRequest {
    const NAME: &'static str = "PostRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                26 => {
                    self.runners.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runners {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostRunnersRequest {
        PostRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runners.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostRunnersRequest {
        static instance: PostRunnersRequest = PostRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runners: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to delete several things by the list of ids.
// @@protoc_insertion_point(message:clarifai.api.DeleteRunnersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteRunnersRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.DeleteRunnersRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.DeleteRunnersRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.DeleteRunnersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteRunnersRequest {
    fn default() -> &'a DeleteRunnersRequest {
        <DeleteRunnersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRunnersRequest {
    pub fn new() -> DeleteRunnersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &DeleteRunnersRequest| { &m.user_app_id },
            |m: &mut DeleteRunnersRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteRunnersRequest| { &m.ids },
            |m: &mut DeleteRunnersRequest| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteRunnersRequest>(
            "DeleteRunnersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteRunnersRequest {
    const NAME: &'static str = "DeleteRunnersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteRunnersRequest {
        DeleteRunnersRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteRunnersRequest {
        static instance: DeleteRunnersRequest = DeleteRunnersRequest {
            user_app_id: ::protobuf::MessageField::none(),
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteRunnersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteRunnersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteRunnersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRunnersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  SingleRunnerResponse
// @@protoc_insertion_point(message:clarifai.api.SingleRunnerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleRunnerResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.SingleRunnerResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.SingleRunnerResponse.runner)
    pub runner: ::protobuf::MessageField<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.SingleRunnerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleRunnerResponse {
    fn default() -> &'a SingleRunnerResponse {
        <SingleRunnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleRunnerResponse {
    pub fn new() -> SingleRunnerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &SingleRunnerResponse| { &m.status },
            |m: &mut SingleRunnerResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::Runner>(
            "runner",
            |m: &SingleRunnerResponse| { &m.runner },
            |m: &mut SingleRunnerResponse| { &mut m.runner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleRunnerResponse>(
            "SingleRunnerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleRunnerResponse {
    const NAME: &'static str = "SingleRunnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.runner)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.runner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.runner.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleRunnerResponse {
        SingleRunnerResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleRunnerResponse {
        static instance: SingleRunnerResponse = SingleRunnerResponse {
            status: ::protobuf::MessageField::none(),
            runner: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleRunnerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleRunnerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleRunnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleRunnerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiRunnerResponse
// @@protoc_insertion_point(message:clarifai.api.MultiRunnerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiRunnerResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerResponse.runners)
    pub runners: ::std::vec::Vec<super::resources::Runner>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerResponse {
    fn default() -> &'a MultiRunnerResponse {
        <MultiRunnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerResponse {
    pub fn new() -> MultiRunnerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerResponse| { &m.status },
            |m: &mut MultiRunnerResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runners",
            |m: &MultiRunnerResponse| { &m.runners },
            |m: &mut MultiRunnerResponse| { &mut m.runners },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerResponse>(
            "MultiRunnerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerResponse {
    const NAME: &'static str = "MultiRunnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.runners.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runners {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerResponse {
        MultiRunnerResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runners.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerResponse {
        static instance: MultiRunnerResponse = MultiRunnerResponse {
            status: ::protobuf::MessageField::none(),
            runners: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:clarifai.api.ListRunnerItemsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListRunnerItemsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.ListRunnerItemsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.ListRunnerItemsRequest.runner_id)
    pub runner_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.ListRunnerItemsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRunnerItemsRequest {
    fn default() -> &'a ListRunnerItemsRequest {
        <ListRunnerItemsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRunnerItemsRequest {
    pub fn new() -> ListRunnerItemsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &ListRunnerItemsRequest| { &m.user_app_id },
            |m: &mut ListRunnerItemsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &ListRunnerItemsRequest| { &m.runner_id },
            |m: &mut ListRunnerItemsRequest| { &mut m.runner_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRunnerItemsRequest>(
            "ListRunnerItemsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRunnerItemsRequest {
    const NAME: &'static str = "ListRunnerItemsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRunnerItemsRequest {
        ListRunnerItemsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRunnerItemsRequest {
        static instance: ListRunnerItemsRequest = ListRunnerItemsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRunnerItemsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRunnerItemsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRunnerItemsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRunnerItemsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PostRunnerItemOutputsRequest
// @@protoc_insertion_point(message:clarifai.api.PostRunnerItemOutputsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostRunnerItemOutputsRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    ///  The particular runner that processed the work.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.runner_id)
    pub runner_id: ::std::string::String,
    ///  The particular item of work processed.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.runner_item_id)
    pub runner_item_id: ::std::string::String,
    ///  This allows you to create one or more runner by posting it to the API.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.runner_item_outputs)
    pub runner_item_outputs: ::std::vec::Vec<RunnerItemOutput>,
    ///  This request has a status so that it can communicate to the API from runners and
    ///  communicate status, errors, etc. This is on the request since runners operate
    ///  in a reverse protocol.
    // @@protoc_insertion_point(field:clarifai.api.PostRunnerItemOutputsRequest.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostRunnerItemOutputsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostRunnerItemOutputsRequest {
    fn default() -> &'a PostRunnerItemOutputsRequest {
        <PostRunnerItemOutputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostRunnerItemOutputsRequest {
    pub fn new() -> PostRunnerItemOutputsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostRunnerItemOutputsRequest| { &m.user_app_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_id",
            |m: &PostRunnerItemOutputsRequest| { &m.runner_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.runner_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runner_item_id",
            |m: &PostRunnerItemOutputsRequest| { &m.runner_item_id },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.runner_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runner_item_outputs",
            |m: &PostRunnerItemOutputsRequest| { &m.runner_item_outputs },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.runner_item_outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &PostRunnerItemOutputsRequest| { &m.status },
            |m: &mut PostRunnerItemOutputsRequest| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostRunnerItemOutputsRequest>(
            "PostRunnerItemOutputsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostRunnerItemOutputsRequest {
    const NAME: &'static str = "PostRunnerItemOutputsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.runner_id = is.read_string()?;
                },
                26 => {
                    self.runner_item_id = is.read_string()?;
                },
                34 => {
                    self.runner_item_outputs.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.runner_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runner_id);
        }
        if !self.runner_item_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.runner_item_id);
        }
        for value in &self.runner_item_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.runner_id.is_empty() {
            os.write_string(2, &self.runner_id)?;
        }
        if !self.runner_item_id.is_empty() {
            os.write_string(3, &self.runner_item_id)?;
        }
        for v in &self.runner_item_outputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostRunnerItemOutputsRequest {
        PostRunnerItemOutputsRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.runner_id.clear();
        self.runner_item_id.clear();
        self.runner_item_outputs.clear();
        self.status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostRunnerItemOutputsRequest {
        static instance: PostRunnerItemOutputsRequest = PostRunnerItemOutputsRequest {
            user_app_id: ::protobuf::MessageField::none(),
            runner_id: ::std::string::String::new(),
            runner_item_id: ::std::string::String::new(),
            runner_item_outputs: ::std::vec::Vec::new(),
            status: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostRunnerItemOutputsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostRunnerItemOutputsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostRunnerItemOutputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostRunnerItemOutputsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MultiRunnerItemResponse
// @@protoc_insertion_point(message:clarifai.api.MultiRunnerItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiRunnerItemResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemResponse.runner_items)
    pub runner_items: ::std::vec::Vec<RunnerItem>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerItemResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerItemResponse {
    fn default() -> &'a MultiRunnerItemResponse {
        <MultiRunnerItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerItemResponse {
    pub fn new() -> MultiRunnerItemResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerItemResponse| { &m.status },
            |m: &mut MultiRunnerItemResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runner_items",
            |m: &MultiRunnerItemResponse| { &m.runner_items },
            |m: &mut MultiRunnerItemResponse| { &mut m.runner_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerItemResponse>(
            "MultiRunnerItemResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerItemResponse {
    const NAME: &'static str = "MultiRunnerItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.runner_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runner_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runner_items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerItemResponse {
        MultiRunnerItemResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runner_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerItemResponse {
        static instance: MultiRunnerItemResponse = MultiRunnerItemResponse {
            status: ::protobuf::MessageField::none(),
            runner_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerItemResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerItemResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerItemResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is a piece of work for a runner to process.
// @@protoc_insertion_point(message:clarifai.api.RunnerItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RunnerItem {
    // message fields
    ///  A UUID hash for this work item.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.id)
    pub id: ::std::string::String,
    ///  A description of the work to be done in case needed for UIs.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.description)
    pub description: ::std::string::String,
    ///  Information on how to process the given RunnerItem.
    // @@protoc_insertion_point(field:clarifai.api.RunnerItem.processing_info)
    pub processing_info: ::protobuf::MessageField<super::resources::ProcessingInfo>,
    // message oneof groups
    pub request: ::std::option::Option<runner_item::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.RunnerItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunnerItem {
    fn default() -> &'a RunnerItem {
        <RunnerItem as ::protobuf::Message>::default_instance()
    }
}

impl RunnerItem {
    pub fn new() -> RunnerItem {
        ::std::default::Default::default()
    }

    // .clarifai.api.PostModelOutputsRequest post_model_outputs_request = 4;

    pub fn post_model_outputs_request(&self) -> &PostModelOutputsRequest {
        match self.request {
            ::std::option::Option::Some(runner_item::Request::PostModelOutputsRequest(ref v)) => v,
            _ => <PostModelOutputsRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_post_model_outputs_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_post_model_outputs_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(runner_item::Request::PostModelOutputsRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_post_model_outputs_request(&mut self, v: PostModelOutputsRequest) {
        self.request = ::std::option::Option::Some(runner_item::Request::PostModelOutputsRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_post_model_outputs_request(&mut self) -> &mut PostModelOutputsRequest {
        if let ::std::option::Option::Some(runner_item::Request::PostModelOutputsRequest(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(runner_item::Request::PostModelOutputsRequest(PostModelOutputsRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(runner_item::Request::PostModelOutputsRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_post_model_outputs_request(&mut self) -> PostModelOutputsRequest {
        if self.has_post_model_outputs_request() {
            match self.request.take() {
                ::std::option::Option::Some(runner_item::Request::PostModelOutputsRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            PostModelOutputsRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &RunnerItem| { &m.id },
            |m: &mut RunnerItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &RunnerItem| { &m.description },
            |m: &mut RunnerItem| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::ProcessingInfo>(
            "processing_info",
            |m: &RunnerItem| { &m.processing_info },
            |m: &mut RunnerItem| { &mut m.processing_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PostModelOutputsRequest>(
            "post_model_outputs_request",
            RunnerItem::has_post_model_outputs_request,
            RunnerItem::post_model_outputs_request,
            RunnerItem::mut_post_model_outputs_request,
            RunnerItem::set_post_model_outputs_request,
        ));
        oneofs.push(runner_item::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunnerItem>(
            "RunnerItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunnerItem {
    const NAME: &'static str = "RunnerItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.processing_info)?;
                },
                34 => {
                    self.request = ::std::option::Option::Some(runner_item::Request::PostModelOutputsRequest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(v) = self.processing_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &runner_item::Request::PostModelOutputsRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(v) = self.processing_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &runner_item::Request::PostModelOutputsRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunnerItem {
        RunnerItem::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.description.clear();
        self.processing_info.clear();
        self.request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunnerItem {
        static instance: RunnerItem = RunnerItem {
            id: ::std::string::String::new(),
            description: ::std::string::String::new(),
            processing_info: ::protobuf::MessageField::none(),
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunnerItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunnerItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunnerItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunnerItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RunnerItem`
pub mod runner_item {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.RunnerItem.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:clarifai.api.RunnerItem.post_model_outputs_request)
        PostModelOutputsRequest(super::PostModelOutputsRequest),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RunnerItem as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.RunnerItemOutput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RunnerItemOutput {
    // message oneof groups
    pub response: ::std::option::Option<runner_item_output::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.RunnerItemOutput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunnerItemOutput {
    fn default() -> &'a RunnerItemOutput {
        <RunnerItemOutput as ::protobuf::Message>::default_instance()
    }
}

impl RunnerItemOutput {
    pub fn new() -> RunnerItemOutput {
        ::std::default::Default::default()
    }

    // .clarifai.api.MultiOutputResponse multi_output_response = 1;

    pub fn multi_output_response(&self) -> &MultiOutputResponse {
        match self.response {
            ::std::option::Option::Some(runner_item_output::Response::MultiOutputResponse(ref v)) => v,
            _ => <MultiOutputResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi_output_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_multi_output_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(runner_item_output::Response::MultiOutputResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_output_response(&mut self, v: MultiOutputResponse) {
        self.response = ::std::option::Option::Some(runner_item_output::Response::MultiOutputResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_output_response(&mut self) -> &mut MultiOutputResponse {
        if let ::std::option::Option::Some(runner_item_output::Response::MultiOutputResponse(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(runner_item_output::Response::MultiOutputResponse(MultiOutputResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(runner_item_output::Response::MultiOutputResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_output_response(&mut self) -> MultiOutputResponse {
        if self.has_multi_output_response() {
            match self.response.take() {
                ::std::option::Option::Some(runner_item_output::Response::MultiOutputResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiOutputResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MultiOutputResponse>(
            "multi_output_response",
            RunnerItemOutput::has_multi_output_response,
            RunnerItemOutput::multi_output_response,
            RunnerItemOutput::mut_multi_output_response,
            RunnerItemOutput::set_multi_output_response,
        ));
        oneofs.push(runner_item_output::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunnerItemOutput>(
            "RunnerItemOutput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunnerItemOutput {
    const NAME: &'static str = "RunnerItemOutput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response = ::std::option::Option::Some(runner_item_output::Response::MultiOutputResponse(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &runner_item_output::Response::MultiOutputResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &runner_item_output::Response::MultiOutputResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunnerItemOutput {
        RunnerItemOutput::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunnerItemOutput {
        static instance: RunnerItemOutput = RunnerItemOutput {
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunnerItemOutput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunnerItemOutput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunnerItemOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunnerItemOutput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RunnerItemOutput`
pub mod runner_item_output {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:clarifai.api.RunnerItemOutput.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:clarifai.api.RunnerItemOutput.multi_output_response)
        MultiOutputResponse(super::MultiOutputResponse),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RunnerItemOutput as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
}

// @@protoc_insertion_point(message:clarifai.api.MultiRunnerItemOutputResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiRunnerItemOutputResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemOutputResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiRunnerItemOutputResponse.runner_item_outputs)
    pub runner_item_outputs: ::std::vec::Vec<RunnerItemOutput>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiRunnerItemOutputResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiRunnerItemOutputResponse {
    fn default() -> &'a MultiRunnerItemOutputResponse {
        <MultiRunnerItemOutputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiRunnerItemOutputResponse {
    pub fn new() -> MultiRunnerItemOutputResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiRunnerItemOutputResponse| { &m.status },
            |m: &mut MultiRunnerItemOutputResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runner_item_outputs",
            |m: &MultiRunnerItemOutputResponse| { &m.runner_item_outputs },
            |m: &mut MultiRunnerItemOutputResponse| { &mut m.runner_item_outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiRunnerItemOutputResponse>(
            "MultiRunnerItemOutputResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiRunnerItemOutputResponse {
    const NAME: &'static str = "MultiRunnerItemOutputResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.runner_item_outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.runner_item_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.runner_item_outputs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiRunnerItemOutputResponse {
        MultiRunnerItemOutputResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.runner_item_outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiRunnerItemOutputResponse {
        static instance: MultiRunnerItemOutputResponse = MultiRunnerItemOutputResponse {
            status: ::protobuf::MessageField::none(),
            runner_item_outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiRunnerItemOutputResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiRunnerItemOutputResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiRunnerItemOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiRunnerItemOutputResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Get the estimated training time for a model version
// @@protoc_insertion_point(message:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostModelVersionsTrainingTimeEstimateRequest {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.user_app_id)
    pub user_app_id: ::protobuf::MessageField<super::resources::UserAppIDSet>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.model_id)
    pub model_id: ::std::string::String,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.model_versions)
    pub model_versions: ::std::vec::Vec<super::resources::ModelVersion>,
    // @@protoc_insertion_point(field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.estimated_input_count)
    pub estimated_input_count: u64,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.PostModelVersionsTrainingTimeEstimateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsTrainingTimeEstimateRequest {
    fn default() -> &'a PostModelVersionsTrainingTimeEstimateRequest {
        <PostModelVersionsTrainingTimeEstimateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsTrainingTimeEstimateRequest {
    pub fn new() -> PostModelVersionsTrainingTimeEstimateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::resources::UserAppIDSet>(
            "user_app_id",
            |m: &PostModelVersionsTrainingTimeEstimateRequest| { &m.user_app_id },
            |m: &mut PostModelVersionsTrainingTimeEstimateRequest| { &mut m.user_app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &PostModelVersionsTrainingTimeEstimateRequest| { &m.model_id },
            |m: &mut PostModelVersionsTrainingTimeEstimateRequest| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "model_versions",
            |m: &PostModelVersionsTrainingTimeEstimateRequest| { &m.model_versions },
            |m: &mut PostModelVersionsTrainingTimeEstimateRequest| { &mut m.model_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "estimated_input_count",
            |m: &PostModelVersionsTrainingTimeEstimateRequest| { &m.estimated_input_count },
            |m: &mut PostModelVersionsTrainingTimeEstimateRequest| { &mut m.estimated_input_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostModelVersionsTrainingTimeEstimateRequest>(
            "PostModelVersionsTrainingTimeEstimateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostModelVersionsTrainingTimeEstimateRequest {
    const NAME: &'static str = "PostModelVersionsTrainingTimeEstimateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_app_id)?;
                },
                18 => {
                    self.model_id = is.read_string()?;
                },
                26 => {
                    self.model_versions.push(is.read_message()?);
                },
                32 => {
                    self.estimated_input_count = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.estimated_input_count != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.estimated_input_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_app_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.estimated_input_count != 0 {
            os.write_uint64(4, self.estimated_input_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostModelVersionsTrainingTimeEstimateRequest {
        PostModelVersionsTrainingTimeEstimateRequest::new()
    }

    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.estimated_input_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostModelVersionsTrainingTimeEstimateRequest {
        static instance: PostModelVersionsTrainingTimeEstimateRequest = PostModelVersionsTrainingTimeEstimateRequest {
            user_app_id: ::protobuf::MessageField::none(),
            model_id: ::std::string::String::new(),
            model_versions: ::std::vec::Vec::new(),
            estimated_input_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostModelVersionsTrainingTimeEstimateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostModelVersionsTrainingTimeEstimateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostModelVersionsTrainingTimeEstimateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsTrainingTimeEstimateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Estimated training time in seconds
// @@protoc_insertion_point(message:clarifai.api.MultiTrainingTimeEstimateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MultiTrainingTimeEstimateResponse {
    // message fields
    // @@protoc_insertion_point(field:clarifai.api.MultiTrainingTimeEstimateResponse.status)
    pub status: ::protobuf::MessageField<super::status::Status>,
    // @@protoc_insertion_point(field:clarifai.api.MultiTrainingTimeEstimateResponse.training_time_estimates)
    pub training_time_estimates: ::std::vec::Vec<::protobuf::well_known_types::duration::Duration>,
    // special fields
    // @@protoc_insertion_point(special_field:clarifai.api.MultiTrainingTimeEstimateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiTrainingTimeEstimateResponse {
    fn default() -> &'a MultiTrainingTimeEstimateResponse {
        <MultiTrainingTimeEstimateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTrainingTimeEstimateResponse {
    pub fn new() -> MultiTrainingTimeEstimateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::status::Status>(
            "status",
            |m: &MultiTrainingTimeEstimateResponse| { &m.status },
            |m: &mut MultiTrainingTimeEstimateResponse| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "training_time_estimates",
            |m: &MultiTrainingTimeEstimateResponse| { &m.training_time_estimates },
            |m: &mut MultiTrainingTimeEstimateResponse| { &mut m.training_time_estimates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiTrainingTimeEstimateResponse>(
            "MultiTrainingTimeEstimateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiTrainingTimeEstimateResponse {
    const NAME: &'static str = "MultiTrainingTimeEstimateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.status)?;
                },
                18 => {
                    self.training_time_estimates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.training_time_estimates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.training_time_estimates {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiTrainingTimeEstimateResponse {
        MultiTrainingTimeEstimateResponse::new()
    }

    fn clear(&mut self) {
        self.status.clear();
        self.training_time_estimates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiTrainingTimeEstimateResponse {
        static instance: MultiTrainingTimeEstimateResponse = MultiTrainingTimeEstimateResponse {
            status: ::protobuf::MessageField::none(),
            training_time_estimates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiTrainingTimeEstimateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiTrainingTimeEstimateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiTrainingTimeEstimateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTrainingTimeEstimateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.OrganizationInvitationStatus)
pub enum OrganizationInvitationStatus {
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.NOT_SET)
    NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.PENDING)
    PENDING = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.ACCEPTED)
    ACCEPTED = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.CANCELLED)
    CANCELLED = 3,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.DECLINED)
    DECLINED = 4,
    // @@protoc_insertion_point(enum_value:clarifai.api.OrganizationInvitationStatus.EXPIRED)
    EXPIRED = 5,
}

impl ::protobuf::Enum for OrganizationInvitationStatus {
    const NAME: &'static str = "OrganizationInvitationStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrganizationInvitationStatus> {
        match value {
            0 => ::std::option::Option::Some(OrganizationInvitationStatus::NOT_SET),
            1 => ::std::option::Option::Some(OrganizationInvitationStatus::PENDING),
            2 => ::std::option::Option::Some(OrganizationInvitationStatus::ACCEPTED),
            3 => ::std::option::Option::Some(OrganizationInvitationStatus::CANCELLED),
            4 => ::std::option::Option::Some(OrganizationInvitationStatus::DECLINED),
            5 => ::std::option::Option::Some(OrganizationInvitationStatus::EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<OrganizationInvitationStatus> {
        match str {
            "NOT_SET" => ::std::option::Option::Some(OrganizationInvitationStatus::NOT_SET),
            "PENDING" => ::std::option::Option::Some(OrganizationInvitationStatus::PENDING),
            "ACCEPTED" => ::std::option::Option::Some(OrganizationInvitationStatus::ACCEPTED),
            "CANCELLED" => ::std::option::Option::Some(OrganizationInvitationStatus::CANCELLED),
            "DECLINED" => ::std::option::Option::Some(OrganizationInvitationStatus::DECLINED),
            "EXPIRED" => ::std::option::Option::Some(OrganizationInvitationStatus::EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OrganizationInvitationStatus] = &[
        OrganizationInvitationStatus::NOT_SET,
        OrganizationInvitationStatus::PENDING,
        OrganizationInvitationStatus::ACCEPTED,
        OrganizationInvitationStatus::CANCELLED,
        OrganizationInvitationStatus::DECLINED,
        OrganizationInvitationStatus::EXPIRED,
    ];
}

impl ::protobuf::EnumFull for OrganizationInvitationStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OrganizationInvitationStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OrganizationInvitationStatus {
    fn default() -> Self {
        OrganizationInvitationStatus::NOT_SET
    }
}

impl OrganizationInvitationStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrganizationInvitationStatus>("OrganizationInvitationStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:clarifai.api.PutTaskAssignmentsRequestAction)
pub enum PutTaskAssignmentsRequestAction {
    // @@protoc_insertion_point(enum_value:clarifai.api.PutTaskAssignmentsRequestAction.PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET)
    PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:clarifai.api.PutTaskAssignmentsRequestAction.LABEL_START)
    LABEL_START = 1,
    // @@protoc_insertion_point(enum_value:clarifai.api.PutTaskAssignmentsRequestAction.LABEL_SUBMIT)
    LABEL_SUBMIT = 2,
    // @@protoc_insertion_point(enum_value:clarifai.api.PutTaskAssignmentsRequestAction.REVIEW_START)
    REVIEW_START = 10,
    // @@protoc_insertion_point(enum_value:clarifai.api.PutTaskAssignmentsRequestAction.REVIEW_APPROVE)
    REVIEW_APPROVE = 11,
    // @@protoc_insertion_point(enum_value:clarifai.api.PutTaskAssignmentsRequestAction.REVIEW_REQUEST_CHANGES)
    REVIEW_REQUEST_CHANGES = 12,
    // @@protoc_insertion_point(enum_value:clarifai.api.PutTaskAssignmentsRequestAction.REVIEW_REJECT)
    REVIEW_REJECT = 13,
}

impl ::protobuf::Enum for PutTaskAssignmentsRequestAction {
    const NAME: &'static str = "PutTaskAssignmentsRequestAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PutTaskAssignmentsRequestAction> {
        match value {
            0 => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET),
            1 => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::LABEL_START),
            2 => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::LABEL_SUBMIT),
            10 => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::REVIEW_START),
            11 => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::REVIEW_APPROVE),
            12 => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::REVIEW_REQUEST_CHANGES),
            13 => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::REVIEW_REJECT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PutTaskAssignmentsRequestAction> {
        match str {
            "PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET" => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET),
            "LABEL_START" => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::LABEL_START),
            "LABEL_SUBMIT" => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::LABEL_SUBMIT),
            "REVIEW_START" => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::REVIEW_START),
            "REVIEW_APPROVE" => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::REVIEW_APPROVE),
            "REVIEW_REQUEST_CHANGES" => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::REVIEW_REQUEST_CHANGES),
            "REVIEW_REJECT" => ::std::option::Option::Some(PutTaskAssignmentsRequestAction::REVIEW_REJECT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PutTaskAssignmentsRequestAction] = &[
        PutTaskAssignmentsRequestAction::PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET,
        PutTaskAssignmentsRequestAction::LABEL_START,
        PutTaskAssignmentsRequestAction::LABEL_SUBMIT,
        PutTaskAssignmentsRequestAction::REVIEW_START,
        PutTaskAssignmentsRequestAction::REVIEW_APPROVE,
        PutTaskAssignmentsRequestAction::REVIEW_REQUEST_CHANGES,
        PutTaskAssignmentsRequestAction::REVIEW_REJECT,
    ];
}

impl ::protobuf::EnumFull for PutTaskAssignmentsRequestAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PutTaskAssignmentsRequestAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            PutTaskAssignmentsRequestAction::PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET => 0,
            PutTaskAssignmentsRequestAction::LABEL_START => 1,
            PutTaskAssignmentsRequestAction::LABEL_SUBMIT => 2,
            PutTaskAssignmentsRequestAction::REVIEW_START => 3,
            PutTaskAssignmentsRequestAction::REVIEW_APPROVE => 4,
            PutTaskAssignmentsRequestAction::REVIEW_REQUEST_CHANGES => 5,
            PutTaskAssignmentsRequestAction::REVIEW_REJECT => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PutTaskAssignmentsRequestAction {
    fn default() -> Self {
        PutTaskAssignmentsRequestAction::PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET
    }
}

impl PutTaskAssignmentsRequestAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PutTaskAssignmentsRequestAction>("PutTaskAssignmentsRequestAction")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20proto/clarifai/api/service.proto\x12\x0cclarifai.api\x1a\"proto/cl\
    arifai/api/resources.proto\x1a&proto/clarifai/api/status/status.proto\
    \x1a)proto/clarifai/api/utils/extensions.proto\x1a%proto/clarifai/auth/s\
    cope/scope.proto\x1a(proto/clarifai/auth/util/extension.proto\x1a+proto/\
    clarifai/api/status/status_code.proto\x1a\x1cgoogle/api/annotations.prot\
    o\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/protobuf/struct.pr\
    oto\x1a\x1fgoogle/protobuf/timestamp.proto\";\n\nPagination\x12\x12\n\
    \x04page\x18\x01\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x02\x20\
    \x01(\rR\x07perPage\"\x92\x01\n\x14GetAnnotationRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12#\n\rannotation_id\x18\x02\x20\x01(\tR\x0cannotationId\x12\x19\n\x08\
    input_id\x18\x03\x20\x01(\tR\x07inputId\"\xe5\x03\n\x16ListAnnotationsRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1b\
    \n\tinput_ids\x18\x03\x20\x03(\tR\x08inputIds\x12\x19\n\x08user_ids\x18\
    \t\x20\x03(\tR\x07userIds\x12*\n\x11model_version_ids\x18\n\x20\x03(\tR\
    \x0fmodelVersionIds\x120\n\x14workflow_version_ids\x18\r\x20\x03(\tR\x12\
    workflowVersionIds\x127\n\x08statuses\x18\x05\x20\x03(\x0b2\x1b.clarifai\
    .api.status.StatusR\x08statuses\x120\n\x14list_all_annotations\x18\x06\
    \x20\x01(\x08R\x12listAllAnnotations\x12.\n\x13return_model_output\x18\
    \x0c\x20\x01(\x08R\x11returnModelOutput\x12\x12\n\x04page\x18\x07\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x08\x20\x01(\rR\x07perPage\
    \x12\x17\n\x07task_id\x18\x0b\x20\x01(\tR\x06taskIdJ\x04\x08\x04\x10\x05\
    \"\x90\x01\n\x16PostAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotatio\
    ns\x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\"\
    \xda\x01\n\x17PatchAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotatio\
    ns\x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\x12/\n\x14delete_if_empty\
    _data\x18\x04\x20\x01(\x08R\x11deleteIfEmptyData\"\xad\x02\n\x1dPatchAnn\
    otationsStatusRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08user_ids\x18\x03\x20\
    \x03(\tR\x07userIds\x12\x17\n\x07task_id\x18\x04\x20\x01(\tR\x06taskId\
    \x12B\n\x0cstatus_codes\x18\x06\x20\x03(\x0e2\x1f.clarifai.api.status.St\
    atusCodeR\x0bstatusCodes\x12\x16\n\x06action\x18\x05\x20\x01(\tR\x06acti\
    on\x12@\n\x0bstatus_code\x18\x02\x20\x01(\x0e2\x1f.clarifai.api.status.S\
    tatusCodeR\nstatusCode\"\x95\x01\n\x1ePatchAnnotationsStatusResponse\x12\
    3\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06s\
    tatus\x12\x19\n\x08user_ids\x18\x02\x20\x03(\tR\x07userIds\x12#\n\rupdat\
    ed_count\x18\x03\x20\x01(\rR\x0cupdatedCount\"\x95\x01\n\x17DeleteAnnota\
    tionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07i\
    nputId\x12#\n\rannotation_id\x18\x03\x20\x01(\tR\x0cannotationId\"\x85\
    \x01\n\x18DeleteAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\
    \x02\x20\x03(\tR\x03ids\x12\x1b\n\tinput_ids\x18\x03\x20\x03(\tR\x08inpu\
    tIds\"\x89\x01\n\x18SingleAnnotationResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x128\n\nannotat\
    ion\x18\x02\x20\x01(\x0b2\x18.clarifai.api.AnnotationR\nannotation\"\x90\
    \x01\n\x17MultiAnnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12@\n\x0bannotations\x18\x02\
    \x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotationsB\x04\x80\xb5\
    \x18\x01\"\xd9\x01\n\x1cListAnnotationWorkersRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\
    \x20\x01(\rR\x07perPage\x12+\n\x11additional_fields\x18\x04\x20\x03(\tR\
    \x10additionalFields\x12!\n\x0ctrusted_only\x18\x05\x20\x01(\x08R\x0btru\
    stedOnly\"\x80\x01\n\x13MultiWorkerResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x124\n\x07workers\
    \x18\x02\x20\x03(\x0b2\x14.clarifai.api.WorkerR\x07workersB\x04\x80\xb5\
    \x18\x01\"x\n\rGetAppRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\x11additional_fields\
    \x18\x02\x20\x03(\tR\x10additionalFields\"\xd9\x04\n\x0fListAppsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12+\n\x11additional_fields\
    \x18\n\x20\x03(\tR\x10additionalFields\x12%\n\x0esort_ascending\x18\x05\
    \x20\x01(\x08R\rsortAscending\x12\"\n\x0csort_by_name\x18\x06\x20\x01(\
    \x08H\0R\nsortByName\x12/\n\x13sort_by_modified_at\x18\x07\x20\x01(\x08H\
    \0R\x10sortByModifiedAt\x12-\n\x12sort_by_created_at\x18\x0c\x20\x01(\
    \x08H\0R\x0fsortByCreatedAt\x12-\n\x12sort_by_star_count\x18\r\x20\x01(\
    \x08H\0R\x0fsortByStarCount\x12#\n\rfeatured_only\x18\t\x20\x01(\x08R\
    \x0cfeaturedOnly\x12!\n\x0cstarred_only\x18\x0b\x20\x01(\x08R\x0bstarred\
    Only\x12#\n\rtemplate_only\x18\x10\x20\x01(\x08R\x0ctemplateOnly\x12\x16\
    \n\x06search\x18\x0f\x20\x01(\tR\x06search\x12\x18\n\x05query\x18\x08\
    \x20\x01(\tR\x05queryB\x02\x18\x01\x12\x16\n\x04name\x18\x04\x20\x01(\tR\
    \x04nameB\x02\x18\x01\x12\x12\n\x02id\x18\x0e\x20\x01(\tR\x02idB\x02\x18\
    \x01B\t\n\x07sort_by\"t\n\x0fPostAppsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04a\
    pps\x18\x02\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\"N\n\x10DeleteAp\
    pRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\"\xeb\x01\n\x10PatchAppsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    %\n\x04apps\x18\x02\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\x12\x16\
    \n\x06action\x18\x03\x20\x01(\tR\x06action\x12B\n\x0fmetadata_action\x18\
    \x04\x20\x01(\x0b2\x19.clarifai.api.PatchActionR\x0emetadataAction\x12\
    \x18\n\x07reindex\x18\x05\x20\x01(\x08R\x07reindex\"\xe8\x01\n\x0fPatchA\
    ppRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12#\n\x03app\x18\x02\x20\x01(\x0b2\x11.clarifai\
    .api.AppR\x03app\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\x12B\
    \n\x0fmetadata_action\x18\x04\x20\x01(\x0b2\x19.clarifai.api.PatchAction\
    R\x0emetadataAction\x12\x18\n\x07reindex\x18\x05\x20\x01(\x08R\x07reinde\
    x\"\x99\x01\n\x13PatchAppsIdsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\x03ids\x18\
    \x03\x20\x03(\x0b2\x1c.clarifai.api.IdUpdateSourceR\x03ids\x12\x16\n\x06\
    action\x18\x04\x20\x01(\tR\x06action\"\xc4\x01\n\x17PostAppsSearchesRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x123\n\tapp_query\x18\x02\x20\x01(\x0b2\x16.clarifai.a\
    pi.AppQueryR\x08appQuery\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.cl\
    arifai.api.PaginationR\npagination\"m\n\x11SingleAppResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12#\n\x03app\x18\x02\x20\x01(\x0b2\x11.clarifai.api.AppR\x03app\"t\n\
    \x10MultiAppResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x12+\n\x04apps\x18\x02\x20\x03(\x0b2\x11.c\
    larifai.api.AppR\x04appsB\x04\x80\xb5\x18\x01\"\xbb\x01\n\x18ListCollabo\
    ratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x124\n\x16list_all_collaborators\x18\x02\x20\
    \x01(\x08R\x14listAllCollaborators\x12\x12\n\x04page\x18\x03\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\x98\x01\
    \n\x18PostCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollaborators\
    \x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborators\"\
    \xb1\x01\n\x19PatchCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollabo\
    rators\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborato\
    rs\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\xa4\x01\n\x1aDele\
    teCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.c\
    larifai.api.UserAppIDSetR\tuserAppId\x12)\n\x10collaborator_ids\x18\x02\
    \x20\x03(\tR\x0fcollaboratorIds\x12\x1f\n\x0buser_emails\x18\x03\x20\x03\
    (\tR\nuserEmails\"\xca\x01\n\x1aMultiCollaboratorsResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12F\
    \n\rcollaborators\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\r\
    collaboratorsB\x04\x80\xb5\x18\x01\x12/\n\tapp_owner\x18\x03\x20\x01(\
    \x0b2\x12.clarifai.api.UserR\x08appOwner\"\xab\x01\n\x19ListCollaboratio\
    nsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12#\n\rtemplate_o\
    nly\x18\x04\x20\x01(\x08R\x0ctemplateOnly\"\x9d\x01\n\x1bMultiCollaborat\
    ionsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12I\n\x0ecollaborations\x18\x02\x20\x03(\x0b2\x1b\
    .clarifai.api.CollaborationR\x0ecollaborationsB\x04\x80\xb5\x18\x01\"<\n\
    \x14GetStatusCodeRequest\x12$\n\x0estatus_code_id\x18\x01\x20\x01(\tR\
    \x0cstatusCodeId\"\x18\n\x16ListStatusCodesRequest\"O\n\x18SingleStatusC\
    odeResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\"\x87\x01\n\x17MultiStatusCodeResponse\x123\n\x06st\
    atus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    7\n\x08statuses\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.status.StatusR\
    \x08statuses\"n\n\x11GetConceptRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_\
    id\x18\x02\x20\x01(\tR\tconceptId\"\x90\x01\n\x13ListConceptsRequest\x12\
    :\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\
    \tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08p\
    er_page\x18\x03\x20\x01(\rR\x07perPage\x12\x0e\n\x02id\x18\x04\x20\x01(\
    \tR\x02id\"\xd7\x01\n\x18ListModelConceptsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\
    \n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\
    \x03\x20\x01(\tR\tversionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\x04pag\
    e\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\x12\x16\n\x06sear\
    ch\x18\x06\x20\x01(\tR\x06search\"\x9a\x02\n\x1bPostConceptsSearchesRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12?\n\rconcept_query\x18\x02\x20\x01(\x0b2\x1a.clarif\
    ai.api.ConceptQueryR\x0cconceptQuery\x12D\n\nextra_info\x18\x04\x20\x01(\
    \x0b2%.clarifai.api.ConceptExtraInfoRequestR\textraInfo\x128\n\npaginati\
    on\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"U\n\
    \x17ConceptExtraInfoRequest\x12:\n\x0erankable_model\x18\x01\x20\x01(\
    \x0b2\x13.clarifai.api.ModelR\rrankableModel\"\x84\x01\n\x13PostConcepts\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x121\n\x08concepts\x18\x02\x20\x03(\x0b2\x15.clari\
    fai.api.ConceptR\x08concepts\"\x9d\x01\n\x14PatchConceptsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x121\n\x08concepts\x18\x02\x20\x03(\x0b2\x15.clarifai.api.Concep\
    tR\x08concepts\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x84\
    \x01\n\x17GetConceptCountsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\"}\n\x15SingleConceptResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12/\n\x07concept\x18\
    \x02\x20\x01(\x0b2\x15.clarifai.api.ConceptR\x07concept\"\x84\x01\n\x14M\
    ultiConceptResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x127\n\x08concepts\x18\x02\x20\x03(\x0b2\
    \x15.clarifai.api.ConceptR\x08conceptsB\x04\x80\xb5\x18\x01\"\x99\x01\n\
    \x19MultiConceptCountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b\
    .clarifai.api.status.StatusR\x06status\x12G\n\x0econcept_counts\x18\x02\
    \x20\x03(\x0b2\x1a.clarifai.api.ConceptCountR\rconceptCountsB\x04\x80\
    \xb5\x18\x01\"\xf3\x01\n\x1bListConceptRelationsRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x1c\n\tpredica\
    te\x18\x03\x20\x01(\tR\tpredicate\x12,\n\x12knowledge_graph_id\x18\x04\
    \x20\x01(\tR\x10knowledgeGraphId\x12\x12\n\x04page\x18\x05\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x06\x20\x01(\rR\x07perPage\"\xc4\x01\
    \n\x1bPostConceptRelationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\
    \x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_relations\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.ConceptRelationR\x10conceptRelations\"\x8c\
    \x01\n\x1dDeleteConceptRelationsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconc\
    ept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x10\n\x03ids\x18\x03\x20\x03(\
    \tR\x03ids\"X\n\x1aListKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\xa1\x01\n\
    \x1aPostKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12G\n\x10knowledge_grap\
    hs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fknowledgeGr\
    aphs\"\xae\x01\n\x1dPostConceptMappingJobsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12Q\n\
    \x14concept_mapping_jobs\x18\x02\x20\x03(\x0b2\x1f.clarifai.api.ConceptM\
    appingJobR\x12conceptMappingJobs\"\xa5\x01\n\x1cMultiConceptRelationResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x12P\n\x11concept_relations\x18\x02\x20\x03(\x0b2\x1d.clar\
    ifai.api.ConceptRelationR\x10conceptRelationsB\x04\x80\xb5\x18\x01\"\xa1\
    \x01\n\x1bMultiKnowledgeGraphResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12M\n\x10knowledge_grap\
    hs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fknowledgeGr\
    aphsB\x04\x80\xb5\x18\x01\"g\n\x1eMultiConceptMappingJobResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x92\x01\n\x19GetConcept\
    LanguageRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\
    \tconceptId\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\x08language\"\xa7\
    \x01\n\x1bListConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_\
    id\x18\x02\x20\x01(\tR\tconceptId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\xdd\x01\
    \n\x1cPatchConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\
    \x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_languages\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguages\x12\x16\
    \n\x06action\x18\x04\x20\x01(\tR\x06action\"\xc4\x01\n\x1bPostConceptLan\
    guagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tc\
    onceptId\x12J\n\x11concept_languages\x18\x03\x20\x03(\x0b2\x1d.clarifai.\
    api.ConceptLanguageR\x10conceptLanguages\"\x9e\x01\n\x1dSingleConceptLan\
    guageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12H\n\x10concept_language\x18\x02\x20\x01(\x0b2\
    \x1d.clarifai.api.ConceptLanguageR\x0fconceptLanguage\"\xa5\x01\n\x1cMul\
    tiConceptLanguageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12P\n\x11concept_languages\x18\x02\
    \x20\x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguagesB\
    \x04\x80\xb5\x18\x01\"h\n\x0fGetInputRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08input_id\x18\x02\x20\x01(\tR\x07inputId\"p\n\x17GetVideoManifestRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\"\
    \x88\x01\n\x16GetInputSamplesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_i\
    d\x18\x02\x20\x01(\tR\x06taskId\x12\x19\n\x08user_ids\x18\x03\x20\x03(\t\
    R\x07userIds\"\xc5\x01\n\x11ListInputsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\x123\n\x06status\x18\x05\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x12\x10\n\x03ids\x18\x04\x20\x03(\tR\x03ids\
    \"\xc5\x01\n\x13StreamInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08per_pa\
    ge\x18\x02\x20\x01(\rR\x07perPage\x12\x17\n\x07last_id\x18\x03\x20\x01(\
    \tR\x06lastId\x12\x1e\n\x0border_by_id\x18\x05\x20\x01(\x08R\torderById\
    \x12\x1e\n\ndescending\x18\x04\x20\x01(\x08R\ndescending\"\x91\x02\n\x11\
    PostInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12+\n\x06inputs\x18\x02\x20\x03(\x0b2\
    \x13.clarifai.api.InputR\x06inputs\x12)\n\x11inputs_add_job_id\x18\x03\
    \x20\x01(\tR\x0einputsAddJobId\x12h\n\x1cinput_id_conflict_resolution\
    \x18\x04\x20\x01(\x0e2'.clarifai.api.InputIDConflictResolutionR\x19input\
    IdConflictResolution\"\x95\x01\n\x12PatchInputsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    +\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\x06inputs\
    \x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"k\n\x12DeleteInputRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\
    \"i\n\x13DeleteInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\
    \x03(\tR\x03idsJ\x04\x08\x03\x10\x04\"u\n\x13SingleInputResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12)\n\x05input\x18\x02\x20\x01(\x0b2\x13.clarifai.api.InputR\x05inpu\
    t\"r\n\x18GetVideoManifestResponse\x123\n\x06status\x18\x01\x20\x01(\x0b\
    2\x1b.clarifai.api.status.StatusR\x06status\x12!\n\x0cmanifest_url\x18\
    \x02\x20\x01(\tR\x0bmanifestUrl\"\xbe\x01\n\x12MultiInputResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x121\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\x06inp\
    utsB\x04\x80\xb5\x18\x01\x12@\n\x0einputs_add_job\x18\x03\x20\x01(\x0b2\
    \x1a.clarifai.api.InputsAddJobR\x0cinputsAddJob\"\x80\x01\n\x1cMultiInpu\
    tAnnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x12+\n\x04hits\x18\x03\x20\x03(\x0b2\x11.cl\
    arifai.api.HitR\x04hitsB\x04\x80\xb5\x18\x01\"\x81\x01\n\x18SingleInputC\
    ountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x120\n\x06counts\x18\x02\x20\x01(\x0b2\x18.clarifa\
    i.api.InputCountR\x06counts\"R\n\x14GetInputCountRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\
    \xf9\x03\n\x13ListDatasetsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\x12+\n\x11additional_fields\x18\x05\x20\x03(\tR\x10additionalField\
    s\x12%\n\x0esort_ascending\x18\x06\x20\x01(\x08R\rsortAscending\x12-\n\
    \x12sort_by_created_at\x18\x07\x20\x01(\x08H\0R\x0fsortByCreatedAt\x12-\
    \n\x12sort_by_star_count\x18\x08\x20\x01(\x08H\0R\x0fsortByStarCount\x12\
    /\n\x13sort_by_modified_at\x18\t\x20\x01(\x08H\0R\x10sortByModifiedAt\
    \x12\x1e\n\nsort_by_id\x18\x0b\x20\x01(\x08H\0R\x08sortById\x12!\n\x0cst\
    arred_only\x18\x04\x20\x01(\x08R\x0bstarredOnly\x12\x1a\n\x08bookmark\
    \x18\n\x20\x01(\x08R\x08bookmark\x12\x16\n\x06search\x18\r\x20\x01(\tR\
    \x06search\x12\x12\n\x02id\x18\x0c\x20\x01(\tR\x02idB\x02\x18\x01B\t\n\
    \x07sort_by\"\x9b\x01\n\x11GetDatasetRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\n\
    dataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12+\n\x11additional_fields\
    \x18\x03\x20\x03(\tR\x10additionalFields\"\x84\x01\n\x13PostDatasetsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x121\n\x08datasets\x18\x02\x20\x03(\x0b2\x15.clarifai.\
    api.DatasetR\x08datasets\"\x9d\x01\n\x14PatchDatasetsRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x121\n\x08datasets\x18\x02\x20\x03(\x0b2\x15.clarifai.api.DatasetR\
    \x08datasets\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"t\n\x15D\
    eleteDatasetsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bdataset_ids\x18\x02\x20\
    \x03(\tR\ndatasetIds\"\x84\x01\n\x14MultiDatasetResponse\x123\n\x06statu\
    s\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\n\
    \x08datasets\x18\x02\x20\x03(\x0b2\x15.clarifai.api.DatasetR\x08datasets\
    B\x04\x80\xb5\x18\x01\"}\n\x15SingleDatasetResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12/\n\x07d\
    ataset\x18\x02\x20\x01(\x0b2\x15.clarifai.api.DatasetR\x07dataset\"\xa4\
    \x01\n\x18ListDatasetInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\
    \x18\x02\x20\x01(\tR\tdatasetId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\x8e\x01\
    \n\x16GetDatasetInputRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\
    \x20\x01(\tR\tdatasetId\x12\x19\n\x08input_id\x18\x03\x20\x01(\tR\x07inp\
    utId\"\xe6\x01\n\x18PostDatasetInputsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\n\
    dataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12A\n\x0edataset_inputs\x18\
    \x03\x20\x03(\x0b2\x1a.clarifai.api.DatasetInputR\rdatasetInputs\x12,\n\
    \x06search\x18\x04\x20\x01(\x0b2\x14.clarifai.api.SearchR\x06search\"\
    \x94\x01\n\x1aDeleteDatasetInputsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndata\
    set_id\x18\x02\x20\x01(\tR\tdatasetId\x12\x1b\n\tinput_ids\x18\x03\x20\
    \x03(\tR\x08inputIds\"\xe3\x01\n\x19MultiDatasetInputResponse\x123\n\x06\
    status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12G\n\x0edataset_inputs\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.Dataset\
    InputR\rdatasetInputsB\x04\x80\xb5\x18\x01\x12B\n\x0ebulk_operation\x18\
    \x04\x20\x01(\x0b2\x1b.clarifai.api.BulkOperationR\rbulkOperationJ\x04\
    \x08\x03\x10\x04\"\x92\x01\n\x1aSingleDatasetInputResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12?\
    \n\rdataset_input\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.DatasetInputR\
    \x0cdatasetInput\"\xfa\x01\n\x1aListDatasetVersionsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12\x12\n\x04page\
    \x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\
    \x07perPage\x12R\n\x0frequest_origins\x18\x05\x20\x03(\x0e2).clarifai.ap\
    i.DatasetVersionRequestOriginR\x0erequestOrigins\"\xa3\x01\n\x18GetDatas\
    etVersionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\
    \tdatasetId\x12,\n\x12dataset_version_id\x18\x03\x20\x01(\tR\x10datasetV\
    ersionId\"\xf7\x02\n&ListDatasetVersionMetricsGroupsRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12,\n\x12dataset\
    _version_id\x18\x03\x20\x01(\tR\x10datasetVersionId\x12\x12\n\x04page\
    \x18\x04\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\
    \x07perPage\x12!\n\x0cparent_paths\x18\x06\x20\x03(\tR\x0bparentPaths\
    \x12B\n\x05types\x18\x07\x20\x03(\x0e2,.clarifai.api.DatasetVersionMetri\
    csGroupTypeR\x05types\x12.\n\x06values\x18\x08\x20\x03(\x0b2\x16.google.\
    protobuf.ValueR\x06values\"\xc0\x01\n\x1aPostDatasetVersionsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12G\n\
    \x10dataset_versions\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.DatasetVersi\
    onR\x0fdatasetVersions\"\xd9\x01\n\x1bPatchDatasetVersionsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tdatasetId\x12G\n\x10d\
    ataset_versions\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.DatasetVersionR\
    \x0fdatasetVersions\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\"\
    \xa9\x01\n\x1cDeleteDatasetVersionsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\ndata\
    set_id\x18\x02\x20\x01(\tR\tdatasetId\x12.\n\x13dataset_version_ids\x18\
    \x03\x20\x03(\tR\x11datasetVersionIds\"\xe8\x01\n\x1fPutDatasetVersionEx\
    portsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x1d\n\ndataset_id\x18\x02\x20\x01(\tR\tda\
    tasetId\x12,\n\x12dataset_version_id\x18\x03\x20\x01(\tR\x10datasetVersi\
    onId\x12<\n\x07exports\x18\x04\x20\x03(\x0b2\".clarifai.api.DatasetVersi\
    onExportR\x07exports\"\xa1\x01\n\x1bMultiDatasetVersionResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12M\n\x10dataset_versions\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.Dat\
    asetVersionR\x0fdatasetVersionsB\x04\x80\xb5\x18\x01\"\x9c\x01\n!MultiDa\
    tasetVersionExportResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cl\
    arifai.api.status.StatusR\x06status\x12B\n\x07exports\x18\x02\x20\x03(\
    \x0b2\".clarifai.api.DatasetVersionExportR\x07exportsB\x04\x80\xb5\x18\
    \x01\"\xd3\x01\n'MultiDatasetVersionMetricsGroupResponse\x123\n\x06statu\
    s\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12s\n\
    \x1edataset_version_metrics_groups\x18\x02\x20\x03(\x0b2(.clarifai.api.D\
    atasetVersionMetricsGroupR\x1bdatasetVersionMetricsGroupsB\x04\x80\xb5\
    \x18\x01\"\x9a\x01\n\x1cSingleDatasetVersionResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12E\n\
    \x0fdataset_version\x18\x02\x20\x01(\x0b2\x1c.clarifai.api.DatasetVersio\
    nR\x0edatasetVersion\"\xae\x02\n\x17PostModelOutputsRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversio\
    n_id\x18\x03\x20\x01(\tR\tversionId\x12+\n\x06inputs\x18\x04\x20\x03(\
    \x0b2\x13.clarifai.api.InputR\x06inputs\x12)\n\x05model\x18\x05\x20\x01(\
    \x0b2\x13.clarifai.api.ModelR\x05model\x12E\n\x0frunner_selector\x18\x06\
    \x20\x01(\x0b2\x1c.clarifai.api.RunnerSelectorR\x0erunnerSelector\"\xbd\
    \x01\n\x16ListModelInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\
    \x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\t\
    R\tversionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\x04page\x12\x19\n\x08\
    per_page\x18\x05\x20\x01(\rR\x07perPage\"b\n\rGetKeyRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x15\n\x06key_id\x18\x02\x20\x01(\tR\x05keyId\"\xd3\x01\n\x0fListKe\
    ysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12\x1f\n\x0bnot_e\
    xpired\x18\x04\x20\x01(\x08R\nnotExpired\x12\x16\n\x06scopes\x18\x05\x20\
    \x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\x06\x20\x03(\tR\tendpoints\"\
    \x7f\n\x12ListAppKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"t\
    \n\x0fPostKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04keys\x18\x02\x20\x03(\x0b2\
    \x11.clarifai.api.KeyR\x04keys\"e\n\x10DeleteKeyRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x15\n\x06key_id\x18\x02\x20\x01(\tR\x05keyId\"\x8d\x01\n\x10PatchKe\
    ysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12%\n\x04keys\x18\x02\x20\x03(\x0b2\x11.clarifa\
    i.api.KeyR\x04keys\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"m\
    \n\x11SingleKeyResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x12#\n\x03key\x18\x02\x20\x01(\x0b2\x11\
    .clarifai.api.KeyR\x03key\"t\n\x10MultiKeyResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12+\n\x04k\
    eys\x18\x02\x20\x03(\x0b2\x11.clarifai.api.KeyR\x04keysB\x04\x80\xb5\x18\
    \x01\"\xf7\x01\n\x0fGetModelRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_\
    id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\
    \tR\tversionId\x12\x1a\n\x08language\x18\x04\x20\x01(\tR\x08language\x12\
    %\n\x0etrained_before\x18\x05\x20\x01(\x08R\rtrainedBefore\x12+\n\x11add\
    itional_fields\x18\x13\x20\x03(\tR\x10additionalFields\"\xd3\x07\n\x11Li\
    stModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04p\
    age\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12+\n\x11addit\
    ional_fields\x18\x13\x20\x03(\tR\x10additionalFields\x12%\n\x0esort_asce\
    nding\x18\n\x20\x01(\x08R\rsortAscending\x12\"\n\x0csort_by_name\x18\x0b\
    \x20\x01(\x08H\0R\nsortByName\x12-\n\x12sort_by_num_inputs\x18\x0c\x20\
    \x01(\x08H\0R\x0fsortByNumInputs\x12/\n\x13sort_by_modified_at\x18\r\x20\
    \x01(\x08H\0R\x10sortByModifiedAt\x12-\n\x12sort_by_created_at\x18\x18\
    \x20\x01(\x08H\0R\x0fsortByCreatedAt\x12-\n\x12sort_by_star_count\x18\
    \x19\x20\x01(\x08H\0R\x0fsortByStarCount\x12\"\n\rmodel_type_id\x18\x06\
    \x20\x01(\tR\x0bmodelTypeId\x12!\n\x0ctrained_only\x18\x07\x20\x01(\x08R\
    \x0btrainedOnly\x12!\n\x0cinput_fields\x18\x08\x20\x03(\tR\x0binputField\
    s\x12#\n\routput_fields\x18\t\x20\x03(\tR\x0coutputFields\x12\x18\n\x07l\
    icense\x18\x0f\x20\x01(\tR\x07license\x12#\n\rfeatured_only\x18\x10\x20\
    \x01(\x08R\x0cfeaturedOnly\x12!\n\x0cstarred_only\x18\x14\x20\x01(\x08R\
    \x0bstarredOnly\x12\x1a\n\x08toolkits\x18\x11\x20\x03(\tR\x08toolkits\
    \x12\x1b\n\tuse_cases\x18\x12\x20\x03(\tR\x08useCases\x12\x1c\n\tlanguag\
    es\x18\x15\x20\x03(\tR\tlanguages\x12/\n\x14dont_fetch_from_main\x18\x17\
    \x20\x01(\x08R\x11dontFetchFromMain\x12\x1a\n\x08bookmark\x18\x1a\x20\
    \x01(\x08R\x08bookmark\x12\x16\n\x06search\x18\x1b\x20\x01(\tR\x06search\
    \x12\x18\n\x05query\x18\x0e\x20\x01(\tR\x05queryB\x02\x18\x01\x12\x16\n\
    \x04name\x18\x05\x20\x01(\tR\x04nameB\x02\x18\x01\x12-\n\x11filter_by_us\
    er_id\x18\x16\x20\x01(\x08R\x0efilterByUserIdB\x02\x18\x01B\t\n\x07sort_\
    byJ\x04\x08\x04\x10\x05\"V\n\x18GetResourceCountsRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\
    \xd4\x01\n\x19GetResourceCountsResponse\x123\n\x06status\x18\x01\x20\x01\
    (\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1a\n\x08datasets\
    \x18\x02\x20\x01(\x03R\x08datasets\x12\x16\n\x06models\x18\x03\x20\x01(\
    \x03R\x06models\x12\x1c\n\tworkflows\x18\x04\x20\x01(\x03R\tworkflows\
    \x12\x18\n\x07modules\x18\x05\x20\x01(\x03R\x07modules\x12\x16\n\x06inpu\
    ts\x18\x06\x20\x01(\x03R\x06inputs\"\xa6\x01\n\x19PatchModelToolkitsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\
    \x12\x1a\n\x08toolkits\x18\x03\x20\x03(\tR\x08toolkits\x12\x16\n\x06acti\
    on\x18\x04\x20\x01(\tR\x06action\"\xb6\x01\n\x1ePatchModelCheckConsentsR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelI\
    d\x12%\n\x0echeck_consents\x18\x03\x20\x03(\tR\rcheckConsents\x12\x16\n\
    \x06action\x18\x04\x20\x01(\tR\x06action\"\xa6\x01\n\x19PatchModelUseCas\
    esRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07mod\
    elId\x12\x1a\n\x08usecases\x18\x03\x20\x03(\tR\x08usecases\x12\x16\n\x06\
    action\x18\x04\x20\x01(\tR\x06action\"\xa9\x01\n\x1aPatchModelLanguagesR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelI\
    d\x12\x1c\n\tlanguages\x18\x03\x20\x03(\tR\tlanguages\x12\x16\n\x06actio\
    n\x18\x04\x20\x01(\tR\x06action\"l\n\x19MultiModelToolkitResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12\x1a\n\x08toolkits\x18\x02\x20\x03(\tR\x08toolkits\"|\n\x1eMultiMo\
    delCheckConsentResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x12%\n\x0echeck_consents\x18\x02\x20\
    \x03(\tR\rcheckConsents\"l\n\x19MultiModelUseCaseResponse\x123\n\x06stat\
    us\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    \x1a\n\x08usecases\x18\x02\x20\x03(\tR\x08usecases\"o\n\x1aMultiModelLan\
    guageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12\x1c\n\tlanguages\x18\x02\x20\x03(\tR\tlanguag\
    es\"\xab\x01\n\x11PostModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12-\n\x05model\x18\
    \x02\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05modelB\x02\x18\x01\x12+\n\
    \x06models\x18\x03\x20\x03(\x0b2\x13.clarifai.api.ModelR\x06models\"\x95\
    \x01\n\x12PatchModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\x06models\x18\x02\x20\
    \x03(\x0b2\x13.clarifai.api.ModelR\x06models\x12\x16\n\x06action\x18\x03\
    \x20\x01(\tR\x06action\"7\n\x0eIdUpdateSource\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x15\n\x06new_id\x18\x02\x20\x01(\tR\x05newId\"\
    \x9a\x01\n\x14PatchModelIdsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\x03ids\x18\x03\
    \x20\x03(\x0b2\x1c.clarifai.api.IdUpdateSourceR\x03ids\x12\x16\n\x06acti\
    on\x18\x04\x20\x01(\tR\x06action\"k\n\x12DeleteModelRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\"\x82\x01\n\x13De\
    leteModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03\
    ids\x12\x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\tdeleteAll\"\xcc\x01\n\
    \x19PostModelsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b\
    2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x129\n\x0bmodel_query\x18\
    \x02\x20\x01(\x0b2\x18.clarifai.api.ModelQueryR\nmodelQuery\x128\n\npagi\
    nation\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"u\
    \n\x13SingleModelResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12)\n\x05model\x18\x02\x20\x01(\x0b2\
    \x13.clarifai.api.ModelR\x05model\"|\n\x12MultiModelResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x121\n\x06models\x18\x02\x20\x03(\x0b2\x13.clarifai.api.ModelR\x06model\
    sB\x04\x80\xb5\x18\x01\"\xcd\x01\n\x19PatchModelVersionsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12A\n\x0em\
    odel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.ModelVersionR\rmode\
    lVersions\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\"\x8e\x01\n\
    \x16GetModelVersionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\
    \x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversi\
    onId\"\xd7\x03\n\x18ListModelVersionsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x12\n\x04page\x18\x03\
    \x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPag\
    e\x12\x1f\n\x0bconcept_ids\x18\x05\x20\x03(\tR\nconceptIds\x12!\n\x0ctra\
    ined_only\x18\x06\x20\x01(\x08R\x0btrainedOnly\x12%\n\x0esort_ascending\
    \x18\x07\x20\x01(\x08R\rsortAscending\x12/\n\x13sort_by_status_code\x18\
    \x08\x20\x01(\x08H\0R\x10sortByStatusCode\x12-\n\x12sort_by_num_inputs\
    \x18\t\x20\x01(\x08H\0R\x0fsortByNumInputs\x120\n\x13sort_by_description\
    \x18\n\x20\x01(\x08H\0R\x11sortByDescription\x12-\n\x12sort_by_created_a\
    t\x18\x0b\x20\x01(\x08H\0R\x0fsortByCreatedAtB\t\n\x07sort_by\"\x91\x01\
    \n\x19DeleteModelVersionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\
    \x18\x03\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x04\x20\x01(\t\
    R\tversionId\"\x92\x01\n\x1aSingleModelVersionResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12?\n\
    \rmodel_version\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.ModelVersionR\x0c\
    modelVersion\"\x99\x01\n\x19MultiModelVersionResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12G\n\
    \x0emodel_versions\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.ModelVersionR\
    \rmodelVersionsB\x04\x80\xb5\x18\x01\"\xa9\x02\n\x18PostModelVersionsReq\
    uest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAp\
    pIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\
    \x12A\n\x0emodel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.ModelVe\
    rsionR\rmodelVersions\x12\x20\n\x0bdescription\x18\x08\x20\x01(\tR\x0bde\
    scription\x123\n\teval_info\x18\n\x20\x01(\x0b2\x16.clarifai.api.EvalInf\
    oR\x08evalInfoJ\x04\x08\x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x06\
    \x10\x07J\x04\x08\x07\x10\x08J\x04\x08\t\x10\n\"\xc9\x01\n\x1ePostModelV\
    ersionsUploadRequest\x12R\n\rupload_config\x18\x01\x20\x01(\x0b2+.clarif\
    ai.api.PostModelVersionsUploadConfigH\0R\x0cuploadConfig\x12D\n\x0cconte\
    nt_part\x18\x02\x20\x01(\x0b2\x1f.clarifai.api.UploadContentPartH\0R\x0b\
    contentPartB\r\n\x0bupload_data\"\xa9\x01\n\x1fPostModelVersionsUploadRe\
    sponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.St\
    atusR\x06status\x12'\n\x0fbytes_remaining\x18\x02\x20\x01(\x04R\x0ebytes\
    Remaining\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersion\
    Id\"\xd6\x01\n\x1dPostModelVersionsUploadConfig\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\
    \n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12?\n\rmodel_version\x18\
    \x03\x20\x01(\x0b2\x1a.clarifai.api.ModelVersionR\x0cmodelVersion\x12\
    \x1d\n\ntotal_size\x18\x04\x20\x01(\x04R\ttotalSize\"\x95\x01\n\x1dPutMo\
    delVersionExportsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\
    \x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversionId\
    \"\x94\x01\n\x1cGetModelVersionExportRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\
    \x03\x20\x01(\tR\tversionId\"\x97\x01\n\x20SingleModelVersionExportRespo\
    nse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Statu\
    sR\x06status\x12>\n\x06export\x18\x02\x20\x01(\x0b2\x20.clarifai.api.Mod\
    elVersionExportR\x06exportB\x04\x80\xb5\x18\x01\"\xd6\x01\n$PostWorkflow\
    VersionsUnPublishRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\
    \x20\x01(\tR\nworkflowId\x12Q\n\x0cpublications\x18\x03\x20\x03(\x0b2-.c\
    larifai.api.WorkflowVersionUnPublishRequestR\x0cpublications\"\xd2\x01\n\
    \"PostWorkflowVersionsPublishRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkfl\
    ow_id\x18\x02\x20\x01(\tR\nworkflowId\x12O\n\x0cpublications\x18\x03\x20\
    \x03(\x0b2+.clarifai.api.WorkflowVersionPublishRequestR\x0cpublications\
    \">\n\x1dWorkflowVersionPublishRequest\x12\x1d\n\nversion_id\x18\x01\x20\
    \x01(\tR\tversionId\"@\n\x1fWorkflowVersionUnPublishRequest\x12\x1d\n\nv\
    ersion_id\x18\x01\x20\x01(\tR\tversionId\";\n\x1aModelVersionPublishRequ\
    est\x12\x1d\n\nversion_id\x18\x01\x20\x01(\tR\tversionId\"\xc6\x01\n\x1f\
    PostModelVersionsPublishRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\
    \x18\x02\x20\x01(\tR\x07modelId\x12L\n\x0cpublications\x18\x03\x20\x03(\
    \x0b2(.clarifai.api.ModelVersionPublishRequestR\x0cpublications\"=\n\x1c\
    ModelVersionUnpublishRequest\x12\x1d\n\nversion_id\x18\x01\x20\x01(\tR\t\
    versionId\"\xca\x01\n!PostModelVersionsUnPublishRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12N\n\x0cpublicat\
    ions\x18\x03\x20\x03(\x0b2*.clarifai.api.ModelVersionUnpublishRequestR\
    \x0cpublications\"\x92\x01\n\x16PostEvaluationsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    <\n\x0ceval_metrics\x18\x02\x20\x03(\x0b2\x19.clarifai.api.EvalMetricsR\
    \x0bevalMetrics\"\xd0\x06\n\x16ListEvaluationsRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\
    \x20\x01(\rR\x07perPage\x12%\n\x0esort_ascending\x18\x04\x20\x01(\x08R\r\
    sortAscending\x12%\n\x0esort_by_app_id\x18\x05\x20\x01(\x08H\0R\x0bsortB\
    yAppId\x12'\n\x0fsort_by_roc_auc\x18\x06\x20\x01(\x08H\0R\x0csortByRocAu\
    c\x12\x1e\n\nsort_by_f1\x18\x07\x20\x01(\x08H\0R\x08sortByF1\x12-\n\x12s\
    ort_by_created_at\x18\x08\x20\x01(\x08H\0R\x0fsortByCreatedAt\x12<\n\x1a\
    sort_by_mean_avg_precision\x18\t\x20\x01(\x08H\0R\x16sortByMeanAvgPrecis\
    ion\x12,\n\x11sort_by_precision\x18\n\x20\x01(\x08H\0R\x0fsortByPrecisio\
    n\x12&\n\x0esort_by_recall\x18\x0b\x20\x01(\x08H\0R\x0csortByRecall\x12)\
    \n\x10sort_by_model_id\x18\x10\x20\x01(\x08H\0R\rsortByModelId\x126\n\
    \x17sort_by_eval_dataset_id\x18\x11\x20\x01(\x08H\0R\x13sortByEvalDatase\
    tId\x128\n\x18sort_by_train_dataset_id\x18\x12\x20\x01(\x08H\0R\x14sortB\
    yTrainDatasetId\x12\"\n\rmodel_type_id\x18\x0c\x20\x01(\tR\x0bmodelTypeI\
    d\x12(\n\x10eval_dataset_ids\x18\r\x20\x03(\tR\x0eevalDatasetIds\x12*\n\
    \x11train_dataset_ids\x18\x0e\x20\x03(\tR\x0ftrainDatasetIds\x12\x1f\n\
    \x0bconcept_ids\x18\x0f\x20\x03(\tR\nconceptIds\x12.\n\x13show_failed_me\
    trics\x18\x13\x20\x01(\x08R\x11showFailedMetricsB\t\n\x07sort_by\"\xaa\
    \x01\n\x14GetEvaluationRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12#\n\revaluation_id\
    \x18\x02\x20\x01(\tR\x0cevaluationId\x121\n\x06fields\x18\x03\x20\x01(\
    \x0b2\x19.clarifai.api.FieldsValueR\x06fields\"\xe3\x01\n\"PostModelVers\
    ionEvaluationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\
    \x01(\tR\x07modelId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emo\
    delVersionId\x12<\n\x0ceval_metrics\x18\x04\x20\x03(\x0b2\x19.clarifai.a\
    pi.EvalMetricsR\x0bevalMetrics\"\xd4\x01\n\"ListModelVersionEvaluationsR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelI\
    d\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\x12\
    \x12\n\x04page\x18\x04\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x05\
    \x20\x01(\rR\x07perPage\"\xfb\x01\n\x20GetModelVersionEvaluationRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12(\
    \n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\x12#\n\reva\
    luation_id\x18\x04\x20\x01(\tR\x0cevaluationId\x121\n\x06fields\x18\x05\
    \x20\x01(\x0b2\x19.clarifai.api.FieldsValueR\x06fields\"\x8e\x01\n\x19Si\
    ngleEvalMetricsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x12<\n\x0ceval_metrics\x18\x02\x20\x01(\
    \x0b2\x19.clarifai.api.EvalMetricsR\x0bevalMetrics\"\x8d\x01\n\x18MultiE\
    valMetricsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.a\
    pi.status.StatusR\x06status\x12<\n\x0ceval_metrics\x18\x02\x20\x03(\x0b2\
    \x19.clarifai.api.EvalMetricsR\x0bevalMetrics\"\x88\x02\n\x1ePostModelVe\
    rsionMetricsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\
    \tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversionId\x125\
    \n\x0btest_search\x18\x05\x20\x01(\x0b2\x14.clarifai.api.SearchR\ntestSe\
    arch\x123\n\teval_info\x18\n\x20\x01(\x0b2\x16.clarifai.api.EvalInfoR\
    \x08evalInfoJ\x04\x08\x04\x10\x05\"\xc8\x01\n\x1dGetModelVersionMetricsR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelI\
    d\x12\x1d\n\nversion_id\x18\x03\x20\x01(\tR\tversionId\x121\n\x06fields\
    \x18\x04\x20\x01(\x0b2\x19.clarifai.api.FieldsValueR\x06fields\"u\n\x13G\
    etModelTypeRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clari\
    fai.api.UserAppIDSetR\tuserAppId\x12\"\n\rmodel_type_id\x18\x02\x20\x01(\
    \tR\x0bmodelTypeId\"\x82\x01\n\x15ListModelTypesRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\"\x1f\n\x1dListOpenSourceLicensesRequest\"q\
    \n\x1eListOpenSourceLicensesResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1a\n\x08licenses\
    \x18\x02\x20\x03(\tR\x08licenses\"\x8c\x01\n\x17SingleModelTypeResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12<\n\nmodel_type\x18\x02\x20\x01(\x0b2\x17.clarifai.api.Mod\
    elTypeR\tmodelTypeB\x04\x80\xb5\x18\x01\"\xab\x02\n\x16MultiModelTypeRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12>\n\x0bmodel_types\x18\x02\x20\x03(\x0b2\x17.clarifai.\
    api.ModelTypeR\nmodelTypesB\x04\x80\xb5\x18\x01\x12E\n\x0fmodel_importer\
    s\x18\x03\x20\x01(\x0b2\x1c.clarifai.api.ModelTypeFieldR\x0emodelImporte\
    rs\x12U\n\x16triton_conda_envs_info\x18\x04\x20\x03(\x0b2\x20.clarifai.a\
    pi.TritonCondaEnvInfoR\x13tritonCondaEnvsInfo\"\xc4\x01\n\"GetModelVersi\
    onInputExampleRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\
    \x01(\tR\x07modelId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emo\
    delVersionId\x12\x1d\n\nexample_id\x18\x04\x20\x01(\tR\texampleId\"\xd6\
    \x01\n$ListModelVersionInputExamplesRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12(\n\x10model_version_id\
    \x18\x03\x20\x01(\tR\x0emodelVersionId\x12\x12\n\x04page\x18\x04\x20\x01\
    (\rR\x04page\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\"\xc4\
    \x01\n&SingleModelVersionInputExampleResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12e\n\x1bmodel\
    _version_input_example\x18\x02\x20\x01(\x0b2&.clarifai.api.ModelVersionI\
    nputExampleR\x18modelVersionInputExample\"\xc5\x01\n%MultiModelVersionIn\
    putExampleResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.a\
    pi.status.StatusR\x06status\x12g\n\x1cmodel_version_input_examples\x18\
    \x02\x20\x03(\x0b2&.clarifai.api.ModelVersionInputExampleR\x19modelVersi\
    onInputExamples\"\xa2\x01\n\x1aListModelReferencesRequest\x12:\n\x0buser\
    _app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x12\n\x04page\
    \x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\
    \x07perPage\"\x9b\x01\n\x1bMultiModelReferenceResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12G\n\
    \x10model_references\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.ModelReferen\
    ceR\x0fmodelReferences\"\x80\x01\n\x13MultiOutputResponse\x123\n\x06stat\
    us\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x124\
    \n\x07outputs\x18\x02\x20\x03(\x0b2\x14.clarifai.api.OutputR\x07outputsB\
    \x04\x80\xb5\x18\x01\"j\n\x11ListScopesRequest\x12\x19\n\x08key_type\x18\
    \x01\x20\x01(\tR\x07keyType\x12:\n\x0buser_app_id\x18\x02\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\"M\n\x0fMyScopesRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\"Q\n\x13MyScopesUserRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\x15\n\x13MyScopes\
    RootRequest\"\xc6\x01\n\x16MultiScopeDepsResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x126\n\nsco\
    pe_deps\x18\x02\x20\x03(\x0b2\x17.clarifai.api.ScopeDepsR\tscopeDeps\x12\
    ?\n\rendpoint_deps\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.EndpointDepsR\
    \x0cendpointDeps\"\xd2\x01\n\x12MultiScopeResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x16\n\
    \x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12#\n\x03app\x18\x03\x20\x01(\
    \x0b2\x11.clarifai.api.AppR\x03app\x12\x1c\n\tendpoints\x18\x04\x20\x03(\
    \tR\tendpoints\x12,\n\x12user_feature_flags\x18\x05\x20\x01(\tR\x10userF\
    eatureFlags\"\xb1\x01\n\x16MultiScopeUserResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x16\n\
    \x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\x04\
    \x20\x03(\tR\tendpoints\x12,\n\x12user_feature_flags\x18\x05\x20\x01(\tR\
    \x10userFeatureFlags\"\xb1\x01\n\x16MultiScopeRootResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    \x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12\x1c\n\tendpoints\x18\
    \x04\x20\x03(\tR\tendpoints\x12,\n\x12user_feature_flags\x18\x05\x20\x01\
    (\tR\x10userFeatureFlags\"^\n\x10GetSearchRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\
    \n\x02id\x18\x02\x20\x01(\tR\x02id\"\x80\x01\n\x13ListSearchesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xec\x01\n\x13PostSearchesR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12-\n\x05query\x18\x02\x20\x01(\x0b2\x13.clarifai.\
    api.QueryR\x05queryB\x02\x18\x01\x120\n\x08searches\x18\x03\x20\x03(\x0b\
    2\x14.clarifai.api.SearchR\x08searches\x128\n\npagination\x18\x04\x20\
    \x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"\xa2\x01\n\x1aPatch\
    InputsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cl\
    arifai.api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\
    \x0b2\x14.clarifai.api.SearchR\x08searches\x12\x16\n\x06action\x18\x03\
    \x20\x01(\tR\x06action\"\xa7\x01\n\x1fPatchAnnotationsSearchesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarifai.api\
    .SearchR\x08searches\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\
    \x9c\x01\n\x14PatchSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\
    \x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x12\x16\n\x06act\
    ion\x18\x03\x20\x01(\tR\x06action\"\x9f\x01\n\x17PostSearchesByIDRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x128\n\npaginat\
    ion\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"a\n\
    \x13DeleteSearchRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.\
    clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\t\
    R\x02id\"\xc8\x01\n\x1ePostAnnotationsSearchesRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\
    \n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searche\
    s\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\
    \npagination\"r\n$DeleteAnnotationSearchMetricsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\xe2\x01\n\x19PostInputsSearches\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clari\
    fai.api.SearchR\x08searches\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18\
    .clarifai.api.PaginationR\npagination\x12\x1d\n\nonly_count\x18\x04\x20\
    \x01(\x08R\tonlyCount\"y\n\x14SingleSearchResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12,\n\x06s\
    earch\x18\x05\x20\x01(\x0b2\x14.clarifai.api.SearchR\x06search\"\x9b\x02\
    \n\x13MultiSearchResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\
    \x02id\x12+\n\x04hits\x18\x03\x20\x03(\x0b2\x11.clarifai.api.HitR\x04hit\
    sB\x04\x80\xb5\x18\x01\x12)\n\x05query\x18\x04\x20\x01(\x0b2\x13.clarifa\
    i.api.QueryR\x05query\x120\n\x08searches\x18\x05\x20\x03(\x0b2\x14.clari\
    fai.api.SearchR\x08searches\x125\n\nhit_counts\x18\x06\x20\x03(\x0b2\x16\
    .clarifai.api.HitCountR\thitCounts\"\xd4\x02\n\"PostAnnotationSearchMetr\
    icsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x127\
    \n\x0cground_truth\x18\x03\x20\x01(\x0b2\x14.clarifai.api.SearchR\x0bgro\
    undTruth\x12:\n\x0esearch_to_eval\x18\x04\x20\x01(\x0b2\x14.clarifai.api\
    .SearchR\x0csearchToEval\x12&\n\x04data\x18\x05\x20\x01(\x0b2\x12.clarif\
    ai.api.DataR\x04data\x12E\n\x0fevaluation_type\x18\x06\x20\x01(\x0e2\x1c\
    .clarifai.api.EvaluationTypeR\x0eevaluationType\"o\n!GetAnnotationSearch\
    MetricsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.\
    api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\
    `\n\"ListAnnotationSearchMetricsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\xbe\x01\n$Mul\
    tiAnnotationSearchMetricsResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12a\n\x19annotation_search_m\
    etrics\x18\x02\x20\x03(\x0b2%.clarifai.api.AnnotationSearchMetricsR\x17a\
    nnotationSearchMetrics\"\x89\x01\n\x1cListAnnotationFiltersRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per\
    _page\x18\x03\x20\x01(\rR\x07perPage\"\x8a\x01\n\x1aGetAnnotationFilterR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x120\n\x14annotation_filter_id\x18\x02\x20\x01(\tR\
    \x12annotationFilterId\"\xa9\x01\n\x1cPostAnnotationFiltersRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12M\n\x12annotation_filters\x18\x02\x20\x03(\x0b2\x1e.clarifa\
    i.api.AnnotationFilterR\x11annotationFilters\"\xc2\x01\n\x1dPatchAnnotat\
    ionFiltersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12M\n\x12annotation_filters\x18\x02\x20\
    \x03(\x0b2\x1e.clarifai.api.AnnotationFilterR\x11annotationFilters\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x90\x01\n\x1eDeleteAnno\
    tationFiltersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x122\n\x15annotation_filter_ids\x18\
    \x02\x20\x03(\tR\x13annotationFilterIds\"\xa9\x01\n\x1dMultiAnnotationFi\
    lterResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12S\n\x12annotation_filters\x18\x02\x20\x03(\x0b2\
    \x1e.clarifai.api.AnnotationFilterR\x11annotationFiltersB\x04\x80\xb5\
    \x18\x01\"\xa2\x01\n\x1eSingleAnnotationFilterResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12K\n\
    \x11annotation_filter\x18\x02\x20\x01(\x0b2\x1e.clarifai.api.AnnotationF\
    ilterR\x10annotationFilter\"y\n\x0eGetUserRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\
    \x11additional_fields\x18\x02\x20\x03(\tR\x10additionalFields\"q\n\x12Si\
    ngleUserResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api\
    .status.StatusR\x06status\x12&\n\x04user\x18\x02\x20\x01(\x0b2\x12.clari\
    fai.api.UserR\x04user\"\x8d\x01\n\x1bPostValidatePasswordRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x122\n\x08password\x18\x02\x20\x01(\x0b2\x16.clarifai.api.Passwo\
    rdR\x08password\"\xaa\x01\n\x20SinglePasswordValidationResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12Q\n\x13password_violations\x18\x02\x20\x01(\x0b2\x20.clarifai.api.\
    PasswordViolationsR\x12passwordViolations\"\x96\x02\n\x12GetWorkflowRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflow\
    Id\x128\n\x18favor_clarifai_workflows\x18\x03\x20\x01(\x08R\x16favorClar\
    ifaiWorkflows\x12+\n\x11additional_fields\x18\x04\x20\x03(\tR\x10additio\
    nalFields\x12<\n\x1aexclude_clarifai_workflows\x18\x05\x20\x01(\x08R\x18\
    excludeClarifaiWorkflows\"\xde\x04\n\x14ListWorkflowsRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x03\x20\x01(\rR\x07perPage\x12+\n\x11additional_fields\x18\n\x20\
    \x03(\tR\x10additionalFields\x12%\n\x0esort_ascending\x18\x05\x20\x01(\
    \x08R\rsortAscending\x12\x1e\n\nsort_by_id\x18\x06\x20\x01(\x08H\0R\x08s\
    ortById\x12/\n\x13sort_by_modified_at\x18\x07\x20\x01(\x08H\0R\x10sortBy\
    ModifiedAt\x12-\n\x12sort_by_created_at\x18\r\x20\x01(\x08H\0R\x0fsortBy\
    CreatedAt\x12-\n\x12sort_by_star_count\x18\x0e\x20\x01(\x08H\0R\x0fsortB\
    yStarCount\x12#\n\rfeatured_only\x18\t\x20\x01(\x08R\x0cfeaturedOnly\x12\
    !\n\x0cstarred_only\x18\x0b\x20\x01(\x08R\x0bstarredOnly\x12\x1a\n\x08bo\
    okmark\x18\x0f\x20\x01(\x08R\x08bookmark\x12\x16\n\x06search\x18\x10\x20\
    \x01(\tR\x06search\x12\x18\n\x05query\x18\x08\x20\x01(\tR\x05queryB\x02\
    \x18\x01\x12\x12\n\x02id\x18\x04\x20\x01(\tR\x02idB\x02\x18\x01\x12#\n\
    \x0bsearch_term\x18\x0c\x20\x01(\tR\nsearchTermB\x02\x18\x01B\t\n\x07sor\
    t_by\"\x88\x01\n\x14PostWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x124\n\tworkflo\
    ws\x18\x02\x20\x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflows\"\xa1\x01\
    \n\x15PatchWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x124\n\tworkflows\x18\x02\x20\
    \x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflows\x12\x16\n\x06action\x18\
    \x03\x20\x01(\tR\x06action\"\x9d\x01\n\x17PatchWorkflowIdsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12.\n\x03ids\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.IdUpdateSou\
    rceR\x03ids\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\"t\n\x15De\
    leteWorkflowRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\
    \x01(\tR\nworkflowId\"\x85\x01\n\x16DeleteWorkflowsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\ndelete_all\x18\
    \x03\x20\x01(\x08R\tdeleteAll\"\x81\x01\n\x16SingleWorkflowResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x122\n\x08workflow\x18\x02\x20\x01(\x0b2\x16.clarifai.api.WorkflowR\
    \x08workflow\"\x88\x01\n\x15MultiWorkflowResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12:\n\twor\
    kflows\x18\x02\x20\x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflowsB\x04\
    \x80\xb5\x18\x01\"\x84\x03\n\x1aPostWorkflowResultsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x12\x1d\n\nver\
    sion_id\x18\x07\x20\x01(\tR\tversionId\x12+\n\x06inputs\x18\x03\x20\x03(\
    \x0b2\x13.clarifai.api.InputR\x06inputs\x12?\n\routput_config\x18\x04\
    \x20\x01(\x0b2\x1a.clarifai.api.OutputConfigR\x0coutputConfig\x128\n\x18\
    favor_clarifai_workflows\x18\x05\x20\x01(\x08R\x16favorClarifaiWorkflows\
    \x12B\n\x0eworkflow_state\x18\x06\x20\x01(\x0b2\x1b.clarifai.api.Workflo\
    wStateR\rworkflowState\"\x82\x02\n\x1bPostWorkflowResultsResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x122\n\x08workflow\x18\x02\x20\x01(\x0b2\x16.clarifai.api.WorkflowR\
    \x08workflow\x126\n\x07results\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.Wo\
    rkflowResultR\x07results\x12B\n\x0eworkflow_state\x18\x04\x20\x01(\x0b2\
    \x1b.clarifai.api.WorkflowStateR\rworkflowState\"\xf4\x02\n$PostWorkflow\
    ResultsSimilarityRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\
    \x20\x01(\tR\nworkflowId\x12\x1d\n\nversion_id\x18\x07\x20\x01(\tR\tvers\
    ionId\x12(\n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\
    \x126\n\x0cprobe_inputs\x18\x04\x20\x03(\x0b2\x13.clarifai.api.InputR\
    \x0bprobeInputs\x124\n\x0bpool_inputs\x18\x05\x20\x03(\x0b2\x13.clarifai\
    .api.InputR\npoolInputs\x128\n\x18favor_clarifai_workflows\x18\x06\x20\
    \x01(\x08R\x16favorClarifaiWorkflows\"\x9f\x01\n%PostWorkflowResultsSimi\
    larityResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.s\
    tatus.StatusR\x06status\x12A\n\x07results\x18\x02\x20\x03(\x0b2'.clarifa\
    i.api.WorkflowResultsSimilarityR\x07results\"\xa9\x01\n\x1bListWorkflowV\
    ersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.\
    api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\t\
    R\nworkflowId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\xa8\x01\n\x19GetWorkflowVe\
    rsionRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\
    \nworkflowId\x12.\n\x13workflow_version_id\x18\x03\x20\x01(\tR\x11workfl\
    owVersionId\"\xae\x01\n\x1dDeleteWorkflowVersionsRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x120\n\x14work\
    flow_version_ids\x18\x03\x20\x03(\tR\x12workflowVersionIds\"\xdf\x01\n\
    \x1cPatchWorkflowVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\
    \x18\x02\x20\x01(\tR\nworkflowId\x12J\n\x11workflow_versions\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.WorkflowVersionR\x10workflowVersions\x12\x16\
    \n\x06action\x18\x04\x20\x01(\tR\x06action\"\xa5\x01\n\x1cMultiWorkflowV\
    ersionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.s\
    tatus.StatusR\x06status\x12P\n\x11workflow_versions\x18\x02\x20\x03(\x0b\
    2\x1d.clarifai.api.WorkflowVersionR\x10workflowVersionsB\x04\x80\xb5\x18\
    \x01\"\x9e\x01\n\x1dSingleWorkflowVersionResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12H\n\x10w\
    orkflow_version\x18\x02\x20\x01(\x0b2\x1d.clarifai.api.WorkflowVersionR\
    \x0fworkflowVersion\"\xa1\x01\n\x1aPostAppDuplicationsRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12G\n\x10app_duplications\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.Ap\
    pDuplicationR\x0fappDuplications\"\x84\x01\n\x18GetAppDuplicationRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12,\n\x12app_duplication_id\x18\x02\x20\x01(\tR\x10appDu\
    plicationId\"\x87\x01\n\x1aListAppDuplicationsRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\
    \x20\x01(\rR\x07perPage\"\x9c\x01\n\x1cMultiAppDuplicationsResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x12G\n\x10app_duplications\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.A\
    ppDuplicationR\x0fappDuplications\"\x9a\x01\n\x1cSingleAppDuplicationRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12E\n\x0fapp_duplication\x18\x02\x20\x01(\x0b2\x1c.clari\
    fai.api.AppDuplicationR\x0eappDuplication\"x\n\x10PostTasksRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12(\n\x05tasks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\
    \x05tasks\"\x92\x01\n\x0eGetTaskRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07ta\
    sk_id\x18\x02\x20\x01(\tR\x06taskId\x12+\n\x11additional_fields\x18\x03\
    \x20\x03(\tR\x10additionalFields\"\xf3\x02\n\x10ListTasksRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_p\
    age\x18\x03\x20\x01(\rR\x07perPage\x12&\n\x0fworker_user_ids\x18\x04\x20\
    \x03(\tR\rworkerUserIds\x12&\n\x0freview_user_ids\x18\x05\x20\x03(\tR\rr\
    eviewUserIds\x12&\n\x0flabel_order_ids\x18\x08\x20\x03(\tR\rlabelOrderId\
    s\x12=\n\x1bincluding_label_order_tasks\x18\x06\x20\x01(\x08R\x18includi\
    ngLabelOrderTasks\x12+\n\x11additional_fields\x18\x07\x20\x03(\tR\x10add\
    itionalFields\x12\x10\n\x03ids\x18\t\x20\x03(\tR\x03ids\"\x91\x01\n\x11P\
    atchTasksRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12(\n\x05tasks\x18\x02\x20\x03(\x0b2\x12\
    .clarifai.api.TaskR\x05tasks\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06\
    action\"b\n\x12DeleteTasksRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\
    \x20\x03(\tR\x03ids\"x\n\x11MultiTaskResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12.\n\x05tasks\
    \x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\x05tasksB\x04\x80\xb5\x18\
    \x01\"q\n\x12SingleTaskResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12&\n\x04task\x18\x02\x20\
    \x01(\x0b2\x12.clarifai.api.TaskR\x04task\"\xe3\x01\n\x13GetTaskCountReq\
    uest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAp\
    pIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06taskId\
    \x12\x19\n\x08user_ids\x18\x03\x20\x03(\tR\x07userIds\x12*\n\x11model_ve\
    rsion_ids\x18\x04\x20\x03(\tR\x0fmodelVersionIds\x120\n\x14workflow_vers\
    ion_ids\x18\x05\x20\x03(\tR\x12workflowVersionIds\"\xbc\x01\n\x17SingleT\
    askCountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api\
    .status.StatusR\x06status\x12\x15\n\x06app_id\x18\x02\x20\x01(\tR\x05app\
    Id\x12\x17\n\x07task_id\x18\x03\x20\x01(\tR\x06taskId\x12<\n\x06counts\
    \x18\x04\x20\x03(\x0b2$.clarifai.api.TaskStatusCountPerUserR\x06counts\"\
    \x91\x01\n\x16PostLabelOrdersRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12;\n\x0clabel_ord\
    ers\x18\x02\x20\x03(\x0b2\x18.clarifai.api.LabelOrderR\x0blabelOrders\"x\
    \n\x14GetLabelOrderRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12$\n\x0elabel_order_id\x18\
    \x02\x20\x01(\tR\x0clabelOrderId\"\x83\x01\n\x16ListLabelOrdersRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xaa\x01\n\x17PatchLabelOrd\
    ersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12;\n\x0clabel_orders\x18\x02\x20\x03(\x0b2\
    \x18.clarifai.api.LabelOrderR\x0blabelOrders\x12\x16\n\x06action\x18\x03\
    \x20\x01(\tR\x06action\"h\n\x18DeleteLabelOrdersRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x91\x01\n\x17MultiLabelOr\
    derResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\x12A\n\x0clabel_orders\x18\x02\x20\x03(\x0b2\x18.cl\
    arifai.api.LabelOrderR\x0blabelOrdersB\x04\x80\xb5\x18\x01\"\x8a\x01\n\
    \x18SingleLabelOrderResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.\
    clarifai.api.status.StatusR\x06status\x129\n\x0blabel_order\x18\x02\x20\
    \x01(\x0b2\x18.clarifai.api.LabelOrderR\nlabelOrder\"\x8c\x01\n\x15PostC\
    ollectorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x127\n\ncollectors\x18\x02\x20\x03(\x0b2\
    \x17.clarifai.api.CollectorR\ncollectors\"\xa5\x01\n\x16PatchCollectorsR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x127\n\ncollectors\x18\x02\x20\x03(\x0b2\x17.clarif\
    ai.api.CollectorR\ncollectors\x12\x16\n\x06action\x18\x03\x20\x01(\tR\
    \x06action\"\x86\x01\n\x17DeleteCollectorsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\
    \n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\ndelete_all\x18\x03\x20\
    \x01(\x08R\tdeleteAll\"t\n\x13GetCollectorRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12!\n\
    \x0ccollector_id\x18\x02\x20\x01(\tR\x0bcollectorId\"\x82\x01\n\x15ListC\
    ollectorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04\
    page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\x86\x01\n\
    \x16MultiCollectorResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cl\
    arifai.api.status.StatusR\x06status\x127\n\ncollectors\x18\x02\x20\x03(\
    \x0b2\x17.clarifai.api.CollectorR\ncollectors\"\x85\x01\n\x17SingleColle\
    ctorResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x125\n\tcollector\x18\x02\x20\x01(\x0b2\x17.clarif\
    ai.api.CollectorR\tcollector\"\x8d\x01\n\x15PostStatValuesRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x128\n\x0bstat_values\x18\x02\x20\x03(\x0b2\x17.clarifai.api.Sta\
    tValueR\nstatValues\"\x8d\x01\n\x16MultiStatValueResponse\x123\n\x06stat\
    us\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12>\
    \n\x0bstat_values\x18\x02\x20\x03(\x0b2\x17.clarifai.api.StatValueR\nsta\
    tValuesB\x04\x80\xb5\x18\x01\"\xc4\x01\n\x1ePostStatValuesAggregateReque\
    st\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppI\
    DSetR\tuserAppId\x12f\n\x1cstat_value_aggregate_queries\x18\x02\x20\x03(\
    \x0b2%.clarifai.api.StatValueAggregateQueryR\x19statValueAggregateQuerie\
    s\"\xbf\x01\n\x1fMultiStatValueAggregateResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12g\n\x1cs\
    tat_value_aggregate_results\x18\x02\x20\x03(\x0b2&.clarifai.api.StatValu\
    eAggregateResultR\x19statValueAggregateResults\"\x96\x01\n\x1ePostTrendi\
    ngMetricsViewRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tview_type\x18\x02\x20\x01(\
    \tR\x08viewType\x12\x1b\n\tobject_id\x18\x03\x20\x01(\tR\x08objectId\"\
    \xa9\x01\n\x1fListTrendingMetricsViewsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\t\
    view_type\x18\x02\x20\x01(\tR\x08viewType\x12\x12\n\x04page\x18\x03\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\
    \x8f\x01\n\x20MultiTrendingMetricsViewResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x126\n\x07metri\
    cs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.TrendingMetricR\x07metrics\"\
    \x98\x01\n\x10GetModuleRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\
    \x02\x20\x01(\tR\x08moduleId\x12+\n\x11additional_fields\x18\x03\x20\x03\
    (\tR\x10additionalFields\"\xab\x04\n\x12ListModulesRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\x12+\n\x11additional_fields\x18\x05\x20\x03(\
    \tR\x10additionalFields\x12%\n\x0esort_ascending\x18\x06\x20\x01(\x08R\r\
    sortAscending\x12-\n\x12sort_by_created_at\x18\x07\x20\x01(\x08H\0R\x0fs\
    ortByCreatedAt\x12-\n\x12sort_by_star_count\x18\x08\x20\x01(\x08H\0R\x0f\
    sortByStarCount\x12/\n\x13sort_by_modified_at\x18\t\x20\x01(\x08H\0R\x10\
    sortByModifiedAt\x12\x1e\n\nsort_by_id\x18\x0b\x20\x01(\x08H\0R\x08sortB\
    yId\x12!\n\x0cstarred_only\x18\x04\x20\x01(\x08R\x0bstarredOnly\x12\x1a\
    \n\x08bookmark\x18\n\x20\x01(\x08R\x08bookmark\x12\x16\n\x06search\x18\
    \x0e\x20\x01(\tR\x06search\x12\x16\n\x04name\x18\x0c\x20\x01(\tR\x04name\
    B\x02\x18\x01\x12-\n\x11filter_by_user_id\x18\r\x20\x01(\x08R\x0efilterB\
    yUserIdB\x02\x18\x01B\t\n\x07sort_by\"\x80\x01\n\x12PostModulesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12.\n\x07modules\x18\x03\x20\x03(\x0b2\x14.clarifai.api.\
    ModuleR\x07modules\"\x99\x01\n\x13PatchModulesRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\
    \n\x07modules\x18\x02\x20\x03(\x0b2\x14.clarifai.api.ModuleR\x07modules\
    \x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"d\n\x14DeleteModules\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"y\n\
    \x14SingleModuleResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clar\
    ifai.api.status.StatusR\x06status\x12,\n\x06module\x18\x02\x20\x01(\x0b2\
    \x14.clarifai.api.ModuleR\x06module\"\x80\x01\n\x13MultiModuleResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x124\n\x07modules\x18\x02\x20\x03(\x0b2\x14.clarifai.api.Modu\
    leR\x07modulesB\x04\x80\xb5\x18\x01\"\x9e\x01\n\x17GetModuleVersionReque\
    st\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppI\
    DSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08moduleId\
    \x12*\n\x11module_version_id\x18\x03\x20\x01(\tR\x0fmoduleVersionId\"\
    \xa3\x01\n\x19ListModuleVersionsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tmodu\
    le_id\x18\x02\x20\x01(\tR\x08moduleId\x12\x12\n\x04page\x18\x03\x20\x01(\
    \rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\xba\
    \x01\n\x19PostModuleVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tmodule_i\
    d\x18\x02\x20\x01(\tR\x08moduleId\x12D\n\x0fmodule_versions\x18\x03\x20\
    \x03(\x0b2\x1b.clarifai.api.ModuleVersionR\x0emoduleVersions\"\xd3\x01\n\
    \x1aPatchModuleVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\
    \x02\x20\x01(\tR\x08moduleId\x12D\n\x0fmodule_versions\x18\x03\x20\x03(\
    \x0b2\x1b.clarifai.api.ModuleVersionR\x0emoduleVersions\x12\x16\n\x06act\
    ion\x18\x04\x20\x01(\tR\x06action\"\x88\x01\n\x1bDeleteModuleVersionsReq\
    uest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAp\
    pIDSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\tR\x08moduleId\
    \x12\x10\n\x03ids\x18\x03\x20\x03(\tR\x03ids\"\xa8\x01\n!GetModuleVersio\
    nUsageCountRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clari\
    fai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tmodule_id\x18\x02\x20\x01(\t\
    R\x08moduleId\x12*\n\x11module_version_id\x18\x03\x20\x01(\tR\x0fmoduleV\
    ersionId\"\x96\x01\n\x1bSingleModuleVersionResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12B\n\x0em\
    odule_version\x18\x02\x20\x01(\x0b2\x1b.clarifai.api.ModuleVersionR\rmod\
    uleVersion\"\x9d\x01\n\x1aMultiModuleVersionResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12J\n\
    \x0fmodule_versions\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.ModuleVersion\
    R\x0emoduleVersionsB\x04\x80\xb5\x18\x01\"}\n%SingleModuleVersionUsageCo\
    untResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.stat\
    us.StatusR\x06status\x12\x1f\n\x0busage_count\x18\x02\x20\x01(\rR\nusage\
    Count\"\x9d\x01\n\x20GetInstalledModuleVersionRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12=\
    \n\x1binstalled_module_version_id\x18\x02\x20\x01(\tR\x18installedModule\
    VersionId\"\x8f\x01\n\"ListInstalledModuleVersionsRequest\x12:\n\x0buser\
    _app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\"\xc2\x01\n\"PostInstalledModuleVersionsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12`\n\x19installed_module_versions\x18\x02\x20\x03(\
    \x0b2$.clarifai.api.InstalledModuleVersionR\x17installedModuleVersions\"\
    \xa2\x01\n%PostInstalledModuleVersionsKeyRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12=\n\
    \x1binstalled_module_version_id\x18\x02\x20\x01(\tR\x18installedModuleVe\
    rsionId\"t\n$DeleteInstalledModuleVersionsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\
    \n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\xbb\x01\n$SingleInstalledModuleVe\
    rsionResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12^\n\x18installed_module_version\x18\x02\x20\
    \x01(\x0b2$.clarifai.api.InstalledModuleVersionR\x16installedModuleVersi\
    on\"\xc2\x01\n#MultiInstalledModuleVersionResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12f\n\x19i\
    nstalled_module_versions\x18\x02\x20\x03(\x0b2$.clarifai.api.InstalledMo\
    duleVersionR\x17installedModuleVersionsB\x04\x80\xb5\x18\x01\"u\n\x1eLis\
    tNextTaskAssignmentsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\x02\
    \x20\x01(\tR\x06taskId\"\x9d\x01\n\x19PostBulkOperationsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12D\n\x0fbulk_operations\x18\x02\x20\x03(\x0b2\x1b.clarifai.api\
    .BulkOperationR\x0ebulkOperations\"\x86\x01\n\x19ListBulkOperationsReque\
    st\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppI\
    DSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\"e\n\x17GetBulkOperationRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"j\n\x1aCanc\
    elBulkOperationRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.c\
    larifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\t\
    R\x03ids\"j\n\x1aDeleteBulkOperationRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\
    \x03ids\x18\x02\x20\x03(\tR\x03ids\"\x97\x01\n\x1cSingleBulkOperationsRe\
    sponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.St\
    atusR\x06status\x12B\n\x0ebulk_operation\x18\x02\x20\x01(\x0b2\x1b.clari\
    fai.api.BulkOperationR\rbulkOperation\"\x96\x01\n\x1bMultiBulkOperations\
    Response\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x12B\n\x0ebulk_operation\x18\x02\x20\x03(\x0b2\x1b.cla\
    rifai.api.BulkOperationR\rbulkOperation\"\xd4\x04\n\x19PutTaskAssignment\
    sRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06taskI\
    d\x12\x19\n\x08input_id\x18\x03\x20\x01(\tR\x07inputId\x12E\n\x06action\
    \x18\x04\x20\x01(\x0e2-.clarifai.api.PutTaskAssignmentsRequestActionR\
    \x06action\x12Q\n\x13label_submit_config\x18\x06\x20\x01(\x0b2\x1f.clari\
    fai.api.LabelSubmitConfigH\0R\x11labelSubmitConfig\x12W\n\x15review_appr\
    ove_config\x18\x07\x20\x01(\x0b2!.clarifai.api.ReviewApproveConfigH\0R\
    \x13reviewApproveConfig\x12m\n\x1dreview_request_changes_config\x18\x08\
    \x20\x01(\x0b2(.clarifai.api.ReviewRequestChangesConfigH\0R\x1areviewReq\
    uestChangesConfig\x12T\n\x14review_reject_config\x18\t\x20\x01(\x0b2\x20\
    .clarifai.api.ReviewRejectConfigH\0R\x12reviewRejectConfigB\x0f\n\ractio\
    n_config\"\\\n\x11LabelSubmitConfig\x12G\n\x10task_assignments\x18\x01\
    \x20\x03(\x0b2\x1c.clarifai.api.TaskAssignmentR\x0ftaskAssignments\"\x8e\
    \x01\n\x13ReviewApproveConfig\x12G\n\x10task_assignments\x18\x01\x20\x03\
    (\x0b2\x1c.clarifai.api.TaskAssignmentR\x0ftaskAssignments\x12.\n\x07wor\
    kers\x18\x02\x20\x03(\x0b2\x14.clarifai.api.WorkerR\x07workers\"\x95\x01\
    \n\x1aReviewRequestChangesConfig\x12G\n\x10task_assignments\x18\x01\x20\
    \x03(\x0b2\x1c.clarifai.api.TaskAssignmentR\x0ftaskAssignments\x12.\n\
    \x07workers\x18\x02\x20\x03(\x0b2\x14.clarifai.api.WorkerR\x07workers\"\
    \x8d\x01\n\x12ReviewRejectConfig\x12G\n\x10task_assignments\x18\x01\x20\
    \x03(\x0b2\x1c.clarifai.api.TaskAssignmentR\x0ftaskAssignments\x12.\n\
    \x07workers\x18\x02\x20\x03(\x0b2\x14.clarifai.api.WorkerR\x07workers\"\
    \xa1\x01\n\x1bMultiTaskAssignmentResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12M\n\x10task_assi\
    gnments\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.TaskAssignmentR\x0ftaskAs\
    signmentsB\x04\x80\xb5\x18\x01\"\x85\x01\n\x18ListInputsAddJobsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\"d\n\x16GetInputsAddJobReque\
    st\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppI\
    DSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"g\n\x19Cance\
    lInputsAddJobRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\
    \x02id\"\x9a\x01\n\x19MultiInputsAddJobResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12H\n\x0finput\
    s_add_jobs\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.InputsAddJobR\rinputsA\
    ddJobsB\x04\x80\xb5\x18\x01\"\x93\x01\n\x1aSingleInputsAddJobResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12@\n\x0einputs_add_job\x18\x02\x20\x01(\x0b2\x1a.clarifai.a\
    pi.InputsAddJobR\x0cinputsAddJob\"\x80\x01\n\x12PostUploadsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12.\n\x07uploads\x18\x02\x20\x03(\x0b2\x14.clarifai.api.Uploa\
    dR\x07uploads\"d\n\x14DeleteUploadsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03id\
    s\x18\x02\x20\x03(\tR\x03ids\"\x7f\n\x12ListUploadsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\"k\n\x10GetUploadRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1b\n\tupload_id\x18\x02\x20\x01(\tR\x08uploadId\"y\n\x14SingleUploadRe\
    sponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.St\
    atusR\x06status\x12,\n\x06upload\x18\x02\x20\x01(\x0b2\x14.clarifai.api.\
    UploadR\x06upload\"z\n\x13MultiUploadResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12.\n\x07uploa\
    ds\x18\x02\x20\x03(\x0b2\x14.clarifai.api.UploadR\x07uploads\"\xbd\x01\n\
    \x1cPutUploadContentPartsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\tupload_id\x18\
    \x02\x20\x01(\tR\x08uploadId\x12D\n\rcontent_parts\x18\x03\x20\x03(\x0b2\
    \x1f.clarifai.api.UploadContentPartR\x0ccontentParts\"\xda\x01\n\x1cPost\
    InputsDataSourcesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12A\n\x0cdata_sources\x18\x02\
    \x20\x03(\x0b2\x1e.clarifai.api.InputsDataSourceR\x0bdataSources\x12\"\n\
    \rcall_back_url\x18\x03\x20\x01(\tR\x0bcallBackUrl\x12\x17\n\x07app_pat\
    \x18\x04\x20\x01(\tR\x06appPat\"\x94\x01\n\x1dGetInputsExtractionJobRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x127\n\x18inputs_extraction_job_id\x18\x02\x20\x01(\tR\
    \x15inputsExtractionJobId\"\x8c\x01\n\x1fListInputsExtractionJobsRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\
    \x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xaf\x01\n!SingleInputsExtr\
    actionJobResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x12U\n\x15inputs_extraction_job\x18\x02\x20\
    \x01(\x0b2!.clarifai.api.InputsExtractionJobR\x13inputsExtractionJob\"\
    \xb0\x01\n\x20MultiInputsExtractionJobResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12W\n\x16input\
    s_extraction_jobs\x18\x02\x20\x03(\x0b2!.clarifai.api.InputsExtractionJo\
    bR\x14inputsExtractionJobs\"q\n!CancelInputsExtractionJobsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x99\x01\n\x18PostI\
    nputsUploadsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12A\n\x0einputs_uploads\x18\x02\x20\
    \x03(\x0b2\x1a.clarifai.api.InputsUploadR\rinputsUploads\"k\n\x10GetRunn\
    erRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x1b\n\trunner_id\x18\x02\x20\x01(\tR\x08runn\
    erId\"\x7f\n\x12ListRunnersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\"\x80\x01\n\x12PostRunnersRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12.\n\x07runne\
    rs\x18\x03\x20\x03(\x0b2\x14.clarifai.api.RunnerR\x07runners\"d\n\x14Del\
    eteRunnersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03\
    ids\"y\n\x14SingleRunnerResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12,\n\x06runner\x18\x02\x20\
    \x01(\x0b2\x14.clarifai.api.RunnerR\x06runner\"\x80\x01\n\x13MultiRunner\
    Response\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x124\n\x07runners\x18\x02\x20\x03(\x0b2\x14.clarifai.a\
    pi.RunnerR\x07runnersB\x04\x80\xb5\x18\x01\"q\n\x16ListRunnerItemsReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\x12\x1b\n\trunner_id\x18\x02\x20\x01(\tR\x08runnerId\"\
    \xa2\x02\n\x1cPostRunnerItemOutputsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1b\n\trunn\
    er_id\x18\x02\x20\x01(\tR\x08runnerId\x12$\n\x0erunner_item_id\x18\x03\
    \x20\x01(\tR\x0crunnerItemId\x12N\n\x13runner_item_outputs\x18\x04\x20\
    \x03(\x0b2\x1e.clarifai.api.RunnerItemOutputR\x11runnerItemOutputs\x123\
    \n\x06status\x18\x05\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\"\x91\x01\n\x17MultiRunnerItemResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12A\n\x0crunner_it\
    ems\x18\x02\x20\x03(\x0b2\x18.clarifai.api.RunnerItemR\x0brunnerItemsB\
    \x04\x80\xb5\x18\x01\"\xf6\x01\n\nRunnerItem\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescripti\
    on\x12E\n\x0fprocessing_info\x18\x03\x20\x01(\x0b2\x1c.clarifai.api.Proc\
    essingInfoR\x0eprocessingInfo\x12d\n\x1apost_model_outputs_request\x18\
    \x04\x20\x01(\x0b2%.clarifai.api.PostModelOutputsRequestH\0R\x17postMode\
    lOutputsRequestB\t\n\x07request\"w\n\x10RunnerItemOutput\x12W\n\x15multi\
    _output_response\x18\x01\x20\x01(\x0b2!.clarifai.api.MultiOutputResponse\
    H\0R\x13multiOutputResponseB\n\n\x08response\"\xaa\x01\n\x1dMultiRunnerI\
    temOutputResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x12T\n\x13runner_item_outputs\x18\x02\x20\x03\
    (\x0b2\x1e.clarifai.api.RunnerItemOutputR\x11runnerItemOutputsB\x04\x80\
    \xb5\x18\x01\"\xfc\x01\n,PostModelVersionsTrainingTimeEstimateRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12A\
    \n\x0emodel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.ModelVersion\
    R\rmodelVersions\x122\n\x15estimated_input_count\x18\x04\x20\x01(\x04R\
    \x13estimatedInputCount\"\xab\x01\n!MultiTrainingTimeEstimateResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12Q\n\x17training_time_estimates\x18\x02\x20\x03(\x0b2\x19.g\
    oogle.protobuf.DurationR\x15trainingTimeEstimates*p\n\x1cOrganizationInv\
    itationStatus\x12\x0b\n\x07NOT_SET\x10\0\x12\x0b\n\x07PENDING\x10\x01\
    \x12\x0c\n\x08ACCEPTED\x10\x02\x12\r\n\tCANCELLED\x10\x03\x12\x0c\n\x08D\
    ECLINED\x10\x04\x12\x0b\n\x07EXPIRED\x10\x05*\xca\x01\n\x1fPutTaskAssign\
    mentsRequestAction\x12/\n+PUT_TASK_ASSIGNMENTS_REQUEST_ACTION_NOT_SET\
    \x10\0\x12\x0f\n\x0bLABEL_START\x10\x01\x12\x10\n\x0cLABEL_SUBMIT\x10\
    \x02\x12\x10\n\x0cREVIEW_START\x10\n\x12\x12\n\x0eREVIEW_APPROVE\x10\x0b\
    \x12\x1a\n\x16REVIEW_REQUEST_CHANGES\x10\x0c\x12\x11\n\rREVIEW_REJECT\
    \x10\r2\x9c\x9d\x03\n\x02V2\x12\xae\x02\n\x14ListConceptRelations\x12).c\
    larifai.api.ListConceptRelationsRequest\x1a*.clarifai.api.MultiConceptRe\
    lationResponse\"\xbe\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\
    \x93\x02\xab\x01\x12Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/concepts/{concept_id}/relationsZN\x12L/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/concepts/relations\x12\xe3\x01\n\x14PostC\
    onceptRelations\x12).clarifai.api.PostConceptRelationsRequest\x1a*.clari\
    fai.api.MultiConceptRelationResponse\"t\x98\x9c'\x05\x90\x9c'-\x90\x9c'\
    \n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02^\"Y/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/concepts/{concept_id}/relations:\x01*\x12\xe2\
    \x01\n\x16DeleteConceptRelations\x12+.clarifai.api.DeleteConceptRelation\
    sRequest\x1a!.clarifai.api.status.BaseResponse\"x\x98\x9c'\x05\x90\x9c'-\
    \x90\x9c'\r\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02^*Y/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relati\
    ons:\x01*\x12\xe0\x01\n\x10GetConceptCounts\x12%.clarifai.api.GetConcept\
    CountsRequest\x1a'.clarifai.api.MultiConceptCountResponse\"|\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02b\
    \x12I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/\
    statusZ\x15\x12\x13/v2/concepts/status\x12\xd5\x01\n\nGetConcept\x12\x1f\
    .clarifai.api.GetConceptRequest\x1a#.clarifai.api.SingleConceptResponse\
    \"\x80\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02n\x12O\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{conc\
    ept_id}Z\x1b\x12\x19/v2/concepts/{concept_id}\x12\xbd\x01\n\x0cListConce\
    pts\x12!.clarifai.api.ListConceptsRequest\x1a\".clarifai.api.MultiConcep\
    tResponse\"f\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\xd3\xe4\x93\x02T\
    \x12B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/conceptsZ\
    \x0e\x12\x0c/v2/concepts\x12\xbd\x02\n\x11ListModelConcepts\x12&.clarifa\
    i.api.ListModelConceptsRequest\x1a\".clarifai.api.MultiConceptResponse\"\
    \xdb\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\
    \x93\x02\xc4\x01\x12T/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/models/{model_id}/conceptsZl\x12j/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/concep\
    ts\x12\xee\x01\n\x14PostConceptsSearches\x12).clarifai.api.PostConceptsS\
    earchesRequest\x1a\".clarifai.api.MultiConceptResponse\"\x86\x01\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02l\"K/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concep\
    ts/searches:\x01*Z\x1a\"\x15/v2/concepts/searches:\x01*\x12\xc7\x01\n\
    \x0cPostConcepts\x12!.clarifai.api.PostConceptsRequest\x1a\".clarifai.ap\
    i.MultiConceptResponse\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\
    \x82\xd3\xe4\x93\x02Z\"B/v2/users/{user_app_id.user_id}/apps/{user_app_i\
    d.app_id}/concepts:\x01*Z\x11\"\x0c/v2/concepts:\x01*\x12\xc9\x01\n\rPat\
    chConcepts\x12\".clarifai.api.PatchConceptsRequest\x1a\".clarifai.api.Mu\
    ltiConceptResponse\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\
    \xd3\xe4\x93\x02Z2B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/concepts:\x01*Z\x112\x0c/v2/concepts:\x01*\x12\x98\x02\n\x12GetConc\
    eptLanguage\x12'.clarifai.api.GetConceptLanguageRequest\x1a+.clarifai.ap\
    i.SingleConceptLanguageResponse\"\xab\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c\
    '\x0b\x82\xd3\xe4\x93\x02\x98\x01\x12d/v2/users/{user_app_id.user_id}/ap\
    ps/{user_app_id.app_id}/concepts/{concept_id}/languages/{language}Z0\x12\
    ./v2/concepts/{concept_id}/languages/{language}\x12\x85\x02\n\x14ListCon\
    ceptLanguages\x12).clarifai.api.ListConceptLanguagesRequest\x1a*.clarifa\
    i.api.MultiConceptLanguageResponse\"\x95\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0b\x82\xd3\xe4\x93\x02\x82\x01\x12Y/v2/users/{user_app_id.user_id\
    }/apps/{user_app_id.app_id}/concepts/{concept_id}/languagesZ%\x12#/v2/co\
    ncepts/{concept_id}/languages\x12\x8f\x02\n\x14PostConceptLanguages\x12)\
    .clarifai.api.PostConceptLanguagesRequest\x1a*.clarifai.api.MultiConcept\
    LanguageResponse\"\x9f\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\
    \x0b\x82\xd3\xe4\x93\x02\x88\x01\"Y/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/concepts/{concept_id}/languages:\x01*Z(\"#/v2/conce\
    pts/{concept_id}/languages:\x01*\x12\x91\x02\n\x15PatchConceptLanguages\
    \x12*.clarifai.api.PatchConceptLanguagesRequest\x1a*.clarifai.api.MultiC\
    onceptLanguageResponse\"\x9f\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\
    \x9c'\x0b\x82\xd3\xe4\x93\x02\x88\x012Y/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/concepts/{concept_id}/languages:\x01*Z(2#/v2/co\
    ncepts/{concept_id}/languages:\x01*\x12\xf5\x01\n\x13ListKnowledgeGraphs\
    \x12(.clarifai.api.ListKnowledgeGraphsRequest\x1a).clarifai.api.MultiKno\
    wledgeGraphResponse\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x82\
    \xd3\xe4\x93\x02v\x12S/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/concepts/knowledge_graphsZ\x1f\x12\x1d/v2/concepts/knowledge_gra\
    phs\x12\xff\x01\n\x13PostKnowledgeGraphs\x12(.clarifai.api.PostKnowledge\
    GraphsRequest\x1a).clarifai.api.MultiKnowledgeGraphResponse\"\x92\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02|\"S/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowle\
    dge_graphs:\x01*Z\"\"\x1d/v2/concepts/knowledge_graphs:\x01*\x12\x82\x02\
    \n\x16PostConceptMappingJobs\x12+.clarifai.api.PostConceptMappingJobsReq\
    uest\x1a,.clarifai.api.MultiConceptMappingJobResponse\"\x8c\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02v\"P/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings/jobs:\
    \x01*Z\x1f\"\x1a/v2/concepts/mappings/jobs:\x01*\x12\x97\x02\n\rGetAnnot\
    ation\x12\".clarifai.api.GetAnnotationRequest\x1a&.clarifai.api.SingleAn\
    notationResponse\"\xb9\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x9e\x01\x12g/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotatio\
    n_id}Z3\x121/v2/inputs/{input_id}/annotations/{annotation_id}\x12\xd4\
    \x01\n\x0fListAnnotations\x12$.clarifai.api.ListAnnotationsRequest\x1a%.\
    clarifai.api.MultiAnnotationResponse\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02Z\x12E/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/annotationsZ\x11\x12\x0f/v2/annota\
    tions\x12\xe7\x01\n\x0fPostAnnotations\x12$.clarifai.api.PostAnnotations\
    Request\x1a%.clarifai.api.MultiAnnotationResponse\"\x86\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x05\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02`\"E/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/annotations:\x01*Z\x14\"\x0f/v2/annotations:\x01*\
    \x12\xe9\x01\n\x10PatchAnnotations\x12%.clarifai.api.PatchAnnotationsReq\
    uest\x1a%.clarifai.api.MultiAnnotationResponse\"\x86\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x05\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x13\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02`2E/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/annotations:\x01*Z\x142\x0f/v2/annotations:\x01*\
    \x12\xf8\x01\n\x16PatchAnnotationsStatus\x12+.clarifai.api.PatchAnnotati\
    onsStatusRequest\x1a,.clarifai.api.PatchAnnotationsStatusResponse\"\x82\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\
    \x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02`2[/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/task/{task_id}/annotations/status:\x01*\x12\
    \xa0\x02\n\x10DeleteAnnotation\x12%.clarifai.api.DeleteAnnotationRequest\
    \x1a!.clarifai.api.status.BaseResponse\"\xc1\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\
    \x02\x9e\x01*g/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    inputs/{input_id}/annotations/{annotation_id}Z3*1/v2/inputs/{input_id}/a\
    nnotations/{annotation_id}\x12\xd4\x02\n\x11DeleteAnnotations\x12&.clari\
    fai.api.DeleteAnnotationsRequest\x1a!.clarifai.api.status.BaseResponse\"\
    \xf3\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\
    \x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xd0\x01*L/v2/users/{user_app_id.us\
    er_id}/apps/{user_app_id.app_id}/inputs/annotations:\x01*Z\x1b*\x16/v2/i\
    nputs/annotations:\x01*ZJ*E/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/annotations:\x01*Z\x14*\x0f/v2/annotations:\x01*\x12\xf7\
    \x01\n\x18PatchAnnotationsSearches\x12-.clarifai.api.PatchAnnotationsSea\
    rchesRequest\x1a!.clarifai.api.MultiSearchResponse\"\x88\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c's\x90\x9c'r\x82\xd3\xe4\x93\x02r2N/v2/users/{user\
    _app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches:\x01*Z\
    \x1d2\x18/v2/annotations/searches:\x01*\x12\x85\x02\n\x17PostAnnotations\
    Searches\x12,.clarifai.api.PostAnnotationsSearchesRequest\x1a!.clarifai.\
    api.MultiSearchResponse\"\x98\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\xd3\
    \xe4\x93\x02r\"N/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/annotations/searches:\x01*Z\x1d\"\x18/v2/annotations/searches:\x01*\
    \x12\xf1\x01\n\x15ListAnnotationWorkers\x12*.clarifai.api.ListAnnotation\
    WorkersRequest\x1a!.clarifai.api.MultiWorkerResponse\"\x88\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'&\x90\x9c'2\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\
    \x93\x02j\x12M/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    annotations/workersZ\x19\x12\x17/v2/annotations/workers\x12\xd5\x01\n\rG\
    etInputCount\x12\".clarifai.api.GetInputCountRequest\x1a&.clarifai.api.S\
    ingleInputCountResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x05\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/inputs/statusZ\x13\x12\x11/v2/inputs/status\x12\
    \xcd\x01\n\x0cStreamInputs\x12!.clarifai.api.StreamInputsRequest\x1a\x20\
    .clarifai.api.MultiInputResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/inputs/streamZ\x13\x12\x11/v2/inputs/s\
    tream\x12\x81\x02\n\x0fGetInputSamples\x12$.clarifai.api.GetInputSamples\
    Request\x1a*.clarifai.api.MultiInputAnnotationResponse\"\x9b\x01\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02\
    \x80\x01\x12X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/t\
    asks/{task_id}/inputs/samplesZ$\x12\"/v2/tasks/{task_id}/inputs/samples\
    \x12\xcf\x01\n\x08GetInput\x12\x1d.clarifai.api.GetInputRequest\x1a!.cla\
    rifai.api.SingleInputResponse\"\x80\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02f\x12K/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}Z\x17\x12\x15/v2/\
    inputs/{input_id}\x12\x80\x02\n\x15GetInputVideoManifest\x12%.clarifai.a\
    pi.GetVideoManifestRequest\x1a&.clarifai.api.GetVideoManifestResponse\"\
    \x97\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x82\xd3\xe4\x93\x02\x84\x01\
    \x12Z/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{i\
    nput_id}/video_manifestZ&\x12$/v2/inputs/{input_id}/video_manifest\x12\
    \xbb\x01\n\nListInputs\x12\x1f.clarifai.api.ListInputsRequest\x1a\x20.cl\
    arifai.api.MultiInputResponse\"j\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02P\x12@/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/inputsZ\x0c\x12\n/v2/inputs\x12\xd6\
    \x01\n\nPostInputs\x12\x1f.clarifai.api.PostInputsRequest\x1a\x20.clarif\
    ai.api.MultiInputResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x02\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02V\"@/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/inputs:\x01*Z\x0f\"\n/v2/inputs:\x01*\x12\xcf\x01\
    \n\x0bPatchInputs\x12\x20.clarifai.api.PatchInputsRequest\x1a\x20.clarif\
    ai.api.MultiInputResponse\"|\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\
    V2@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs:\x01\
    *Z\x0f2\n/v2/inputs:\x01*\x12\xe9\x01\n\x0bDeleteInput\x12\x20.clarifai.\
    api.DeleteInputRequest\x1a!.clarifai.api.status.BaseResponse\"\x94\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\x04\x90\
    \x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02f*K/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_i\
    d}Z\x17*\x15/v2/inputs/{input_id}\x12\xdb\x01\n\x0cDeleteInputs\x12!.cla\
    rifai.api.DeleteInputsRequest\x1a!.clarifai.api.status.BaseResponse\"\
    \x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\
    \x04\x90\x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02V*@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs:\
    \x01*Z\x0f*\n/v2/inputs:\x01*\x12\xe2\x01\n\x13PatchInputsSearches\x12(.\
    clarifai.api.PatchInputsSearchesRequest\x1a!.clarifai.api.MultiSearchRes\
    ponse\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c's\x90\x9c'r\x82\xd3\xe4\x93\x02h\
    2I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/searc\
    hes:\x01*Z\x182\x13/v2/inputs/searches:\x01*\x12\xf1\x01\n\x12PostInputs\
    Searches\x12'.clarifai.api.PostInputsSearchesRequest\x1a!.clarifai.api.M\
    ultiSearchResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02h\"I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs\
    /searches:\x01*Z\x18\"\x13/v2/inputs/searches:\x01*\x12\x89\x04\n\x10Pos\
    tModelOutputs\x12%.clarifai.api.PostModelOutputsRequest\x1a!.clarifai.ap\
    i.MultiOutputResponse\"\xaa\x03\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\
    \x9c'\x0f\x90\x9c'\x02\x82\xd3\xe4\x93\x02\x8f\x03\"i/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{versi\
    on_id}/outputs:\x01*Z8\"3/v2/models/{model_id}/versions/{version_id}/out\
    puts:\x01*ZX\"S/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /models/{model_id}/outputs:\x01*Z\"\"\x1d/v2/models/{model_id}/outputs:\
    \x01*Zg\"b/v2/users/{runner_selector.deployment.user_id}/deployments/{ru\
    nner_selector.deployment.id}/outputs:\x01*\x12\xda\x02\n\x14GenerateMode\
    lOutputs\x12%.clarifai.api.PostModelOutputsRequest\x1a!.clarifai.api.Mul\
    tiOutputResponse\"\xf5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\
    \x0f\x90\x9c'\x02\x82\xd3\xe4\x93\x02\xda\x01\"r/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id\
    }/outputs/generate:\x01*Za\"\\/v2/users/{user_app_id.user_id}/apps/{user\
    _app_id.app_id}/models/{model_id}/outputs/generate:\x01*0\x01\x12x\n\x12\
    StreamModelOutputs\x12%.clarifai.api.PostModelOutputsRequest\x1a!.clarif\
    ai.api.MultiOutputResponse\"\x14\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\
    \x9c'\x0f\x90\x9c'\x02(\x010\x01\x12\xef\x01\n\x0cListDatasets\x12!.clar\
    ifai.api.ListDatasetsRequest\x1a\".clarifai.api.MultiDatasetResponse\"\
    \x97\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\x02\
    \x80\x01\x12B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/d\
    atasetsZ*\x12(/v2/users/{user_app_id.user_id}/datasetsZ\x0e\x12\x0c/v2/d\
    atasets\x12\xd9\x01\n\nGetDataset\x12\x1f.clarifai.api.GetDatasetRequest\
    \x1a#.clarifai.api.SingleDatasetResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'\
    -\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\x02n\x12O/v2/users/{user_app_id.us\
    er_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}Z\x1b\x12\x19/v2/d\
    atasets/{dataset_id}\x12\xcb\x01\n\x0cPostDatasets\x12!.clarifai.api.Pos\
    tDatasetsRequest\x1a\".clarifai.api.MultiDatasetResponse\"t\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'r\x82\xd3\xe4\x93\x02Z\"B/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets:\x01*Z\x11\"\
    \x0c/v2/datasets:\x01*\x12\xcd\x01\n\rPatchDatasets\x12\".clarifai.api.P\
    atchDatasetsRequest\x1a\".clarifai.api.MultiDatasetResponse\"t\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'r\x82\xd3\xe4\x93\x02Z2B/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets:\x01*Z\x11\
    2\x0c/v2/datasets:\x01*\x12\xce\x01\n\x0eDeleteDatasets\x12#.clarifai.ap\
    i.DeleteDatasetsRequest\x1a!.clarifai.api.status.BaseResponse\"t\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'k\x82\xd3\xe4\x93\x02Z*B/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets:\x01*Z\
    \x11*\x0c/v2/datasets:\x01*\x12\x81\x02\n\x11ListDatasetInputs\x12&.clar\
    ifai.api.ListDatasetInputsRequest\x1a'.clarifai.api.MultiDatasetInputRes\
    ponse\"\x9a\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'\x05\x90\x9c'&\
    \x90\x9c'\x0b\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/datasets/{dataset_id}/inputsZ\"\x12\x20/v2/data\
    sets/{dataset_id}/inputs\x12\x95\x02\n\x0fGetDatasetInput\x12$.clarifai.\
    api.GetDatasetInputRequest\x1a(.clarifai.api.SingleDatasetInputResponse\
    \"\xb1\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'\x05\x90\x9c'&\x90\
    \x9c'\x0b\x82\xd3\xe4\x93\x02\x92\x01\x12a/v2/users/{user_app_id.user_id\
    }/apps/{user_app_id.app_id}/datasets/{dataset_id}/inputs/{input_id}Z-\
    \x12+/v2/datasets/{dataset_id}/inputs/{input_id}\x12\x8c\x02\n\x11PostDa\
    tasetInputs\x12&.clarifai.api.PostDatasetInputsRequest\x1a'.clarifai.api\
    .MultiDatasetInputResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\
    \x90\x9c'j\x90\x9c'\x05\x90\x9c'&\x90\x9c'\x0b\x82\xd3\xe4\x93\x02\x82\
    \x01\"V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/dataset\
    s/{dataset_id}/inputs:\x01*Z%\"\x20/v2/datasets/{dataset_id}/inputs:\x01\
    *\x12\x86\x02\n\x13DeleteDatasetInputs\x12(.clarifai.api.DeleteDatasetIn\
    putsRequest\x1a!.clarifai.api.status.BaseResponse\"\xa1\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'k\x90\x9c'\x05\x82\xd3\xe4\x93\
    \x02\x82\x01*V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    datasets/{dataset_id}/inputs:\x01*Z%*\x20/v2/datasets/{dataset_id}/input\
    s:\x01*\x12\x84\x02\n\x13ListDatasetVersions\x12(.clarifai.api.ListDatas\
    etVersionsRequest\x1a).clarifai.api.MultiDatasetVersionResponse\"\x97\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\x02\x80\
    \x01\x12X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datas\
    ets/{dataset_id}/versionsZ$\x12\"/v2/datasets/{dataset_id}/versions\x12\
    \xab\x02\n\x11GetDatasetVersion\x12&.clarifai.api.GetDatasetVersionReque\
    st\x1a*.clarifai.api.SingleDatasetVersionResponse\"\xc1\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'i\x90\x9c'r\x82\xd3\xe4\x93\x02\xaa\x01\x12m/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{dataset_id}/v\
    ersions/{dataset_version_id}Z9\x127/v2/datasets/{dataset_id}/versions/{d\
    ataset_version_id}\x12\xea\x02\n\x1fListDatasetVersionMetricsGroups\x124\
    .clarifai.api.ListDatasetVersionMetricsGroupsRequest\x1a5.clarifai.api.M\
    ultiDatasetVersionMetricsGroupResponse\"\xd9\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'i\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02\xba\
    \x01\x12u/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datas\
    ets/{dataset_id}/versions/{dataset_version_id}/metricsZA\x12?/v2/dataset\
    s/{dataset_id}/versions/{dataset_version_id}/metrics\x12\x92\x02\n\x13Po\
    stDatasetVersions\x12(.clarifai.api.PostDatasetVersionsRequest\x1a).clar\
    ifai.api.MultiDatasetVersionResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'i\x90\x9c'j\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x86\
    \x01\"X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/dataset\
    s/{dataset_id}/versions:\x01*Z'\"\"/v2/datasets/{dataset_id}/versions:\
    \x01*\x12\x8c\x02\n\x14PatchDatasetVersions\x12).clarifai.api.PatchDatas\
    etVersionsRequest\x1a).clarifai.api.MultiDatasetVersionResponse\"\x9d\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x82\xd3\xe4\x93\x02\x86\
    \x012X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets\
    /{dataset_id}/versions:\x01*Z'2\"/v2/datasets/{dataset_id}/versions:\x01\
    *\x12\x8a\x02\n\x15DeleteDatasetVersions\x12*.clarifai.api.DeleteDataset\
    VersionsRequest\x1a!.clarifai.api.status.BaseResponse\"\xa1\x01\x98\x9c'\
    \x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x90\x9c'k\x82\xd3\xe4\x93\x02\x86\x01\
    *X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/datasets/{da\
    taset_id}/versions:\x01*Z'*\"/v2/datasets/{dataset_id}/versions:\x01*\
    \x12\xd4\x02\n\x18PutDatasetVersionExports\x12-.clarifai.api.PutDatasetV\
    ersionExportsRequest\x1a/.clarifai.api.MultiDatasetVersionExportResponse\
    \"\xd7\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'i\x90\x9c'j\x82\xd3\xe4\x93\
    \x02\xc0\x01\x1au/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_i\
    d}/datasets/{dataset_id}/versions/{dataset_version_id}/exports:\x01*ZD\
    \x1a?/v2/datasets/{dataset_id}/versions/{dataset_version_id}/exports:\
    \x01*\x12\xe9\x01\n\x0cGetModelType\x12!.clarifai.api.GetModelTypeReques\
    t\x1a%.clarifai.api.SingleModelTypeResponse\"\x8e\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/models/types/{model_type_id}Z\"\x12\x20/v\
    2/models/types/{model_type_id}\x12\x99\x01\n\x16ListOpenSourceLicenses\
    \x12+.clarifai.api.ListOpenSourceLicensesRequest\x1a,.clarifai.api.ListO\
    penSourceLicensesResponse\"$\x98\x9c'\x01\x82\xd3\xe4\x93\x02\x1a\x12\
    \x18/v2/open_source_licenses\x12\xcb\x01\n\x0eListModelTypes\x12#.clarif\
    ai.api.ListModelTypesRequest\x1a$.clarifai.api.MultiModelTypeResponse\"n\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\\\x12F/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/models/typesZ\x12\x12\
    \x10/v2/models/types\x12\xca\x01\n\x08GetModel\x12\x1d.clarifai.api.GetM\
    odelRequest\x1a!.clarifai.api.SingleModelResponse\"|\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02f\x12K/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}Z\x17\x12\
    \x15/v2/models/{model_id}\x12\x9a\x03\n\x12GetModelOutputInfo\x12\x1d.cl\
    arifai.api.GetModelRequest\x1a!.clarifai.api.SingleModelResponse\"\xc1\
    \x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\
    \x02\xaa\x02\x12W/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_i\
    d}/models/{model_id}/output_infoZ#\x12!/v2/models/{model_id}/output_info\
    Zo\x12m/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/\
    {model_id}/versions/{version_id}/output_infoZ9\x127/v2/models/{model_id}\
    /versions/{version_id}/output_info\x12\xe2\x01\n\nListModels\x12\x1f.cla\
    rifai.api.ListModelsRequest\x1a\x20.clarifai.api.MultiModelResponse\"\
    \x90\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\
    \x93\x02z\x12@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    modelsZ(\x12&/v2/users/{user_app_id.user_id}/modelsZ\x0c\x12\n/v2/models\
    \x12\xe7\x01\n\x11GetResourceCounts\x12&.clarifai.api.GetResourceCountsR\
    equest\x1a'.clarifai.api.GetResourceCountsResponse\"\x80\x01\x98\x9c'\
    \x02\x90\x9c'i\x90\x9c'\x0f\x90\x9c'\x13\x90\x9c'm\x90\x9c'-\x82\xd3\xe4\
    \x93\x02b\x12I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    resource_countsZ\x15\x12\x13/v2/resource_counts\x12\xdf\x01\n\x12PostMod\
    elsSearches\x12'.clarifai.api.PostModelsSearchesRequest\x1a\x20.clarifai\
    .api.MultiModelResponse\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\
    \x0f\x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/models/searches:\x01*Z\x18\"\x13/v2/models/searches:\x01*\
    \x12\xca\x01\n\nPostModels\x12\x1f.clarifai.api.PostModelsRequest\x1a!.c\
    larifai.api.SingleModelResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\
    \x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x82\xd3\xe4\x93\x02\
    V\"@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models:\
    \x01*Z\x0f\"\n/v2/models:\x01*\x12\xc7\x01\n\x0bPatchModels\x12\x20.clar\
    ifai.api.PatchModelsRequest\x1a\x20.clarifai.api.MultiModelResponse\"t\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\
    \x1a\x82\xd3\xe4\x93\x02V2@/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/models:\x01*Z\x0f2\n/v2/models:\x01*\x12\xb6\x01\n\rPatchMo\
    delIds\x12\".clarifai.api.PatchModelIdsRequest\x1a\x20.clarifai.api.Mult\
    iModelResponse\"_\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0e\x90\x9c'\x0f\x82\
    \xd3\xe4\x93\x02I2D/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/models/ids:\x01*\x12\xdd\x01\n\x0bDeleteModel\x12\x20.clarifai.api.\
    DeleteModelRequest\x1a!.clarifai.api.status.BaseResponse\"\x88\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02f*K/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/models/{model_id}Z\x17*\x15/v2/models/{model_id}\
    \x12\xce\x01\n\x0cDeleteModels\x12!.clarifai.api.DeleteModelsRequest\x1a\
    !.clarifai.api.status.BaseResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    \x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\
    \x02V*@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models:\
    \x01*Z\x0f*\n/v2/models:\x01*\x12\x95\x02\n\x17PatchModelCheckConsents\
    \x12,.clarifai.api.PatchModelCheckConsentsRequest\x1a,.clarifai.api.Mult\
    iModelCheckConsentResponse\"\x9d\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\
    \x82\xd3\xe4\x93\x02\x8a\x012Z/v2/users/{user_app_id.user_id}/apps/{user\
    _app_id.app_id}/models/{model_id}/check_consents:\x01*Z)2$/v2/models/{mo\
    del_id}/check_consents:\x01*\x12\xf9\x01\n\x12PatchModelToolkits\x12'.cl\
    arifai.api.PatchModelToolkitsRequest\x1a'.clarifai.api.MultiModelToolkit\
    Response\"\x90\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\
    \x02~2T/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/\
    {model_id}/toolkits:\x01*Z#2\x1e/v2/models/{model_id}/toolkits:\x01*\x12\
    \xf9\x01\n\x12PatchModelUseCases\x12'.clarifai.api.PatchModelUseCasesReq\
    uest\x1a'.clarifai.api.MultiModelUseCaseResponse\"\x90\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02~2T/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/models/{model_id}/usecases:\x01*Z#2\x1e/\
    v2/models/{model_id}/usecases:\x01*\x12\xff\x01\n\x13PatchModelLanguages\
    \x12(.clarifai.api.PatchModelLanguagesRequest\x1a(.clarifai.api.MultiMod\
    elLanguageResponse\"\x93\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\
    \xe4\x93\x02\x80\x012U/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/models/{model_id}/languages:\x01*Z$2\x1f/v2/models/{model_id}/la\
    nguages:\x01*\x12\x94\x03\n\x0fListModelInputs\x12$.clarifai.api.ListMod\
    elInputsRequest\x1a\x20.clarifai.api.MultiInputResponse\"\xb8\x02\x88\
    \x02\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\
    \x9c'\x0f\x82\xd3\xe4\x93\x02\x96\x02\x12R/v2/users/{user_app_id.user_id\
    }/apps/{user_app_id.app_id}/models/{model_id}/inputsZ\x1e\x12\x1c/v2/mod\
    els/{model_id}/inputsZj\x12h/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/models/{model_id}/versions/{version_id}/inputsZ4\x122/v2/m\
    odels/{model_id}/versions/{version_id}/inputs\x12\x8d\x02\n\x0fGetModelV\
    ersion\x12$.clarifai.api.GetModelVersionRequest\x1a(.clarifai.api.Single\
    ModelVersionResponse\"\xa9\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\
    \x9c'\x0f\x82\xd3\xe4\x93\x02\x92\x01\x12a/v2/users/{user_app_id.user_id\
    }/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}Z-\
    \x12+/v2/models/{model_id}/versions/{version_id}\x12\xf5\x01\n\x11ListMo\
    delVersions\x12&.clarifai.api.ListModelVersionsRequest\x1a'.clarifai.api\
    .MultiModelVersionResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02x\x12T/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/models/{model_id}/versionsZ\x20\x12\x1e/v2/mode\
    ls/{model_id}/versions\x12\xbc\x02\n\x1dPostWorkflowVersionsUnPublish\
    \x122.clarifai.api.PostWorkflowVersionsUnPublishRequest\x1a!.clarifai.ap\
    i.status.BaseResponse\"\xc3\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'x\x90\x9c\
    '&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\
    \x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\x8c\x01\"[/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/un\
    publish:\x01*Z*\"%/v2/workflows/{workflow_id}/unpublish:\x01*\x12\xb4\
    \x02\n\x1bPostWorkflowVersionsPublish\x120.clarifai.api.PostWorkflowVers\
    ionsPublishRequest\x1a!.clarifai.api.status.BaseResponse\"\xbf\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'w\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\
    \x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\
    \xd3\xe4\x93\x02\x88\x01\"Y/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/workflows/{workflow_id}/publish:\x01*Z(\"#/v2/workflows/{wo\
    rkflow_id}/publish:\x01*\x12\xa1\x02\n\x18PostModelVersionsPublish\x12-.\
    clarifai.api.PostModelVersionsPublishRequest\x1a!.clarifai.api.status.Ba\
    seResponse\"\xb2\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'u\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\
    \x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02|\"S/v2/users/{user_app_id.user_\
    id}/apps/{user_app_id.app_id}/models/{model_id}/publish:\x01*Z\"\"\x1d/v\
    2/models/{model_id}/publish:\x01*\x12\xaa\x02\n\x1aPostModelVersionsUnPu\
    blish\x12/.clarifai.api.PostModelVersionsUnPublishRequest\x1a!.clarifai.\
    api.status.BaseResponse\"\xb7\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'v\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\
    \x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\x80\x01\"U/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/unpu\
    blish:\x01*Z$\"\x1f/v2/models/{model_id}/unpublish:\x01*\x12\x91\x02\n\
    \x11PostModelVersions\x12&.clarifai.api.PostModelVersionsRequest\x1a!.cl\
    arifai.api.SingleModelResponse\"\xb0\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\
    &\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\
    \x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02~\"T/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions:\x01*Z\
    #\"\x1e/v2/models/{model_id}/versions:\x01*\x12\xdf\x01\n\x12PatchModelV\
    ersions\x12'.clarifai.api.PatchModelVersionsRequest\x1a'.clarifai.api.Mu\
    ltiModelVersionResponse\"w\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0b\x90\x9c'\
    \x0f\x90\x9c'\x0e\x90\x9c'\x1a\x82\xd3\xe4\x93\x02Y2T/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions:\x01*\
    \x12\x98\x02\n\x12DeleteModelVersion\x12'.clarifai.api.DeleteModelVersio\
    nRequest\x1a!.clarifai.api.status.BaseResponse\"\xb5\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\x9c'\
    \x13\x82\xd3\xe4\x93\x02\x92\x01*a/v2/users/{user_app_id.user_id}/apps/{\
    user_app_id.app_id}/models/{model_id}/versions/{version_id}Z-*+/v2/model\
    s/{model_id}/versions/{version_id}\x12\xb9\x01\n\x17PostModelVersionsUpl\
    oad\x12,.clarifai.api.PostModelVersionsUploadRequest\x1a-.clarifai.api.P\
    ostModelVersionsUploadResponse\"=\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0e\
    \x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x1f\"\x1a/v2\
    /models/versions/upload:\x01*(\x010\x01\x12\xb7\x02\n\x16PutModelVersion\
    Exports\x12+.clarifai.api.PutModelVersionExportsRequest\x1a..clarifai.ap\
    i.SingleModelVersionExportResponse\"\xbf\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0f\x90\x9c'\x8e\x01\x90\x9c'\x8f\x01\x82\xd3\xe4\x93\x02\xa2\x01\
    \x1ai/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{m\
    odel_id}/versions/{version_id}/exportsZ5\x1a3/v2/models/{model_id}/versi\
    ons/{version_id}/exports\x12\xb0\x02\n\x15GetModelVersionExport\x12*.cla\
    rifai.api.GetModelVersionExportRequest\x1a..clarifai.api.SingleModelVers\
    ionExportResponse\"\xba\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\
    \x8e\x01\x82\xd3\xe4\x93\x02\xa2\x01\x12i/v2/users/{user_app_id.user_id}\
    /apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/expor\
    tsZ5\x123/v2/models/{model_id}/versions/{version_id}/exports\x12\xb7\x02\
    \n\x16GetModelVersionMetrics\x12+.clarifai.api.GetModelVersionMetricsReq\
    uest\x1a(.clarifai.api.SingleModelVersionResponse\"\xc5\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\
    \x82\xd3\xe4\x93\x02\xa2\x01\x12i/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/models/{model_id}/versions/{version_id}/metricsZ5\x12\
    3/v2/models/{model_id}/versions/{version_id}/metrics\x12\xd3\x02\n\x17Po\
    stModelVersionMetrics\x12,.clarifai.api.PostModelVersionMetricsRequest\
    \x1a(.clarifai.api.SingleModelVersionResponse\"\xdf\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\
    \x9c'\x1a\x90\x9c'\x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\
    \x02\xa8\x01\"i/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /models/{model_id}/versions/{version_id}/metrics:\x01*Z8\"3/v2/models/{m\
    odel_id}/versions/{version_id}/metrics:\x01*\x12\xed\x02\n\x1bPostModelV\
    ersionEvaluations\x120.clarifai.api.PostModelVersionEvaluationsRequest\
    \x1a&.clarifai.api.MultiEvalMetricsResponse\"\xf3\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\
    \x9c'\x1a\x90\x9c'\x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\
    \x02\xbc\x01\"s/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /models/{model_id}/versions/{model_version_id}/evaluations:\x01*ZB\"=/v2\
    /models/{model_id}/versions/{model_version_id}/evaluations:\x01*\x12\xd3\
    \x02\n\x1bListModelVersionEvaluations\x120.clarifai.api.ListModelVersion\
    EvaluationsRequest\x1a&.clarifai.api.MultiEvalMetricsResponse\"\xd9\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\
    \x90\x9c'5\x82\xd3\xe4\x93\x02\xb6\x01\x12s/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/models/{model_id}/versions/{model_version_i\
    d}/evaluationsZ?\x12=/v2/models/{model_id}/versions/{model_version_id}/e\
    valuations\x12\xf1\x02\n\x19GetModelVersionEvaluation\x12..clarifai.api.\
    GetModelVersionEvaluationRequest\x1a'.clarifai.api.SingleEvalMetricsResp\
    onse\"\xfa\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\
    \x0f\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\xd7\x01\x12\x83\x01/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/v\
    ersions/{model_version_id}/evaluations/{evaluation_id}ZO\x12M/v2/models/\
    {model_id}/versions/{model_version_id}/evaluations/{evaluation_id}\x12\
    \xf8\x01\n\x0fPostEvaluations\x12$.clarifai.api.PostEvaluationsRequest\
    \x1a&.clarifai.api.MultiEvalMetricsResponse\"\x96\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\
    \x9c'\x1a\x90\x9c'\x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\
    \x02`\"E/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/evalua\
    tions:\x01*Z\x14\"\x0f/v2/evaluations:\x01*\x12\x8e\x02\n\x0fListEvaluat\
    ions\x12$.clarifai.api.ListEvaluationsRequest\x1a&.clarifai.api.MultiEva\
    lMetricsResponse\"\xac\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\x89\x01\x12E/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/evaluationsZ-\x12\
    +/v2/users/{user_app_id.user_id}/evaluationsZ\x11\x12\x0f/v2/evaluations\
    \x12\xfb\x01\n\rGetEvaluation\x12\".clarifai.api.GetEvaluationRequest\
    \x1a'.clarifai.api.SingleEvalMetricsResponse\"\x9c\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\
    \xd3\xe4\x93\x02z\x12U/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/evaluations/{evaluation_id}Z!\x12\x1f/v2/evaluations/{evaluation\
    _id}\x12\xfb\x01\n\x13ListModelReferences\x12(.clarifai.api.ListModelRef\
    erencesRequest\x1a).clarifai.api.MultiModelReferenceResponse\"\x8e\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02|\x12V/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/refere\
    ncesZ\"\x12\x20/v2/models/{model_id}/references\x12\xf2\x02\n\x1bGetMode\
    lVersionInputExample\x120.clarifai.api.GetModelVersionInputExampleReques\
    t\x1a4.clarifai.api.SingleModelVersionInputExampleResponse\"\xea\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\xd7\x01\x12\x83\x01\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_\
    id}/versions/{model_version_id}/input_examples/{example_id}ZO\x12M/v2/mo\
    dels/{model_id}/versions/{model_version_id}/input_examples/{example_id}\
    \x12\xda\x02\n\x1dListModelVersionInputExamples\x122.clarifai.api.ListMo\
    delVersionInputExamplesRequest\x1a3.clarifai.api.MultiModelVersionInputE\
    xampleResponse\"\xcf\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\
    \x93\x02\xbc\x01\x12v/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/models/{model_id}/versions/{model_version_id}/input_examplesZB\
    \x12@/v2/models/{model_id}/versions/{model_version_id}/input_examples\
    \x12\xe0\x01\n\x0bGetWorkflow\x12\x20.clarifai.api.GetWorkflowRequest\
    \x1a$.clarifai.api.SingleWorkflowResponse\"\x88\x01\x98\x9c'\x02\x90\x9c\
    '-\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02r\x12Q/v2/users/{user_ap\
    p_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}Z\x1d\x12\
    \x1b/v2/workflows/{workflow_id}\x12\xf5\x01\n\rListWorkflows\x12\".clari\
    fai.api.ListWorkflowsRequest\x1a#.clarifai.api.MultiWorkflowResponse\"\
    \x9a\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\
    \x93\x02\x83\x01\x12C/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/workflowsZ+\x12)/v2/users/{user_app_id.user_id}/workflowsZ\x0f\
    \x12\r/v2/workflows\x12\xd0\x01\n\rPostWorkflows\x12\".clarifai.api.Post\
    WorkflowsRequest\x1a#.clarifai.api.MultiWorkflowResponse\"v\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x12\x90\x9c'\x13\x82\xd3\xe4\x93\x02\\\
    \"C/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows:\
    \x01*Z\x12\"\r/v2/workflows:\x01*\x12\xd2\x01\n\x0ePatchWorkflows\x12#.c\
    larifai.api.PatchWorkflowsRequest\x1a#.clarifai.api.MultiWorkflowRespons\
    e\"v\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x12\x90\x9c'\x13\x82\
    \xd3\xe4\x93\x02\\2C/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/workflows:\x01*Z\x122\r/v2/workflows:\x01*\x12\xc2\x01\n\x10PatchW\
    orkflowIds\x12%.clarifai.api.PatchWorkflowIdsRequest\x1a#.clarifai.api.M\
    ultiWorkflowResponse\"b\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x12\x90\x9c'\x13\
    \x82\xd3\xe4\x93\x02L2G/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/workflows/ids:\x01*\x12\xe7\x01\n\x0eDeleteWorkflow\x12#.clarif\
    ai.api.DeleteWorkflowRequest\x1a!.clarifai.api.status.BaseResponse\"\x8c\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x12\x90\x9c'\x15\x90\x9c'\x13\x82\
    \xd3\xe4\x93\x02r*Q/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/workflows/{workflow_id}Z\x1d*\x1b/v2/workflows/{workflow_id}\x12\
    \xd2\x01\n\x0fDeleteWorkflows\x12$.clarifai.api.DeleteWorkflowsRequest\
    \x1a!.clarifai.api.status.BaseResponse\"v\x98\x9c'\x02\x90\x9c'-\x90\x9c\
    '\x12\x90\x9c'\x15\x90\x9c'\x13\x82\xd3\xe4\x93\x02\\*C/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/workflows:\x01*Z\x12*\r/v2/work\
    flows:\x01*\x12\x8a\x03\n\x13PostWorkflowResults\x12(.clarifai.api.PostW\
    orkflowResultsRequest\x1a).clarifai.api.PostWorkflowResultsResponse\"\
    \x9d\x02\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x0b\x90\x9c'\x02\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02\xfe\x01\"o/v2/users/{user_app_id.user_\
    id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{version_\
    id}/results:\x01*Z^\"Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/workflows/{workflow_id}/results:\x01*Z(\"#/v2/workflows/{workflo\
    w_id}/results:\x01*\x12\xc9\x03\n\x1dPostWorkflowResultsSimilarity\x122.\
    clarifai.api.PostWorkflowResultsSimilarityRequest\x1a3.clarifai.api.Post\
    WorkflowResultsSimilarityResponse\"\xbe\x02\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x0f\x90\x9c'\x0b\x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x9f\
    \x02\"z/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflo\
    ws/{workflow_id}/versions/{version_id}/results/similarity:\x01*Zi\"d/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflo\
    w_id}/results/similarity:\x01*Z3\"./v2/workflows/{workflow_id}/results/s\
    imilarity:\x01*\x12\x8b\x02\n\x14ListWorkflowVersions\x12).clarifai.api.\
    ListWorkflowVersionsRequest\x1a*.clarifai.api.MultiWorkflowVersionRespon\
    se\"\x9b\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\
    \xe4\x93\x02\x84\x01\x12Z/v2/users/{user_app_id.user_id}/apps/{user_app_\
    id.app_id}/workflows/{workflow_id}/versionsZ&\x12$/v2/workflows/{workflo\
    w_id}/versions\x12\xb4\x02\n\x12GetWorkflowVersion\x12'.clarifai.api.Get\
    WorkflowVersionRequest\x1a+.clarifai.api.SingleWorkflowVersionResponse\"\
    \xc7\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\
    \x93\x02\xb0\x01\x12p/v2/users/{user_app_id.user_id}/apps/{user_app_id.a\
    pp_id}/workflows/{workflow_id}/versions/{workflow_version_id}Z<\x12:/v2/\
    workflows/{workflow_id}/versions/{workflow_version_id}\x12\x90\x02\n\x16\
    DeleteWorkflowVersions\x12+.clarifai.api.DeleteWorkflowVersionsRequest\
    \x1a!.clarifai.api.status.BaseResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'\x13\x90\x9c'\x12\x90\x9c'\x15\x82\xd3\xe4\x93\x02\x8a\x01*Z/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workfl\
    ow_id}/versions:\x01*Z)*$/v2/workflows/{workflow_id}/versions:\x01*\x12\
    \x97\x02\n\x15PatchWorkflowVersions\x12*.clarifai.api.PatchWorkflowVersi\
    onsRequest\x1a*.clarifai.api.MultiWorkflowVersionResponse\"\xa5\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\x90\x9c'\x12\x82\xd3\xe4\
    \x93\x02\x8a\x012Z/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/workflows/{workflow_id}/versions:\x01*Z)2$/v2/workflows/{workflow_id\
    }/versions:\x01*\x12\x85\x01\n\x06GetKey\x12\x1b.clarifai.api.GetKeyRequ\
    est\x1a\x1f.clarifai.api.SingleKeyResponse\"=\x98\x9c'\x05\x90\x9c'0\x82\
    \xd3\xe4\x93\x02/\x12-/v2/users/{user_app_id.user_id}/keys/{key_id}\x12\
    \x7f\n\x08ListKeys\x12\x1d.clarifai.api.ListKeysRequest\x1a\x1e.clarifai\
    .api.MultiKeyResponse\"4\x98\x9c'\x05\x90\x9c'0\x82\xd3\xe4\x93\x02&\x12\
    $/v2/users/{user_app_id.user_id}/keys\x12\xa3\x01\n\x0bListAppKeys\x12\
    \x20.clarifai.api.ListAppKeysRequest\x1a\x1e.clarifai.api.MultiKeyRespon\
    se\"R\x98\x9c'\x05\x90\x9c'-\x90\x9c'0\x82\xd3\xe4\x93\x02@\x12>/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/keys\x12\x95\x01\n\tDe\
    leteKey\x12\x1e.clarifai.api.DeleteKeyRequest\x1a!.clarifai.api.status.B\
    aseResponse\"E\x98\x9c'\x05\x90\x9c'/\x90\x9c'1\x90\x9c'0\x82\xd3\xe4\
    \x93\x02/*-/v2/users/{user_app_id.user_id}/keys/{key_id}\x12\x8a\x01\n\
    \x08PostKeys\x12\x1d.clarifai.api.PostKeysRequest\x1a\x1e.clarifai.api.M\
    ultiKeyResponse\"?\x98\x9c'\x05\x90\x9c'-\x90\x9c'/\x90\x9c'0\x82\xd3\
    \xe4\x93\x02)\"$/v2/users/{user_app_id.user_id}/keys:\x01*\x12\x88\x01\n\
    \tPatchKeys\x12\x1e.clarifai.api.PatchKeysRequest\x1a\x1e.clarifai.api.M\
    ultiKeyResponse\";\x98\x9c'\x05\x90\x9c'/\x90\x9c'0\x82\xd3\xe4\x93\x02)\
    2$/v2/users/{user_app_id.user_id}/keys:\x01*\x12\xbc\x01\n\x08MyScopes\
    \x12\x1d.clarifai.api.MyScopesRequest\x1a\x20.clarifai.api.MultiScopeRes\
    ponse\"o\x98\x9c'\x02\x82\xd3\xe4\x93\x02e\x12B/v2/users/{user_app_id.us\
    er_id}/apps/{user_app_id.app_id}/myscopesZ\x0e\x12\x0c/v2/myscopesZ\x0f\
    \x12\r/v2/my_scopes\x12\x8d\x01\n\x0cMyScopesUser\x12!.clarifai.api.MySc\
    opesUserRequest\x1a$.clarifai.api.MultiScopeUserResponse\"4\x98\x9c'\x05\
    \x82\xd3\xe4\x93\x02*\x12(/v2/users/{user_app_id.user_id}/myscopes\x12u\
    \n\x0cMyScopesRoot\x12!.clarifai.api.MyScopesRootRequest\x1a$.clarifai.a\
    pi.MultiScopeRootResponse\"\x1c\x98\x9c'\x05\x82\xd3\xe4\x93\x02\x12\x12\
    \x10/v2/myscopesroot\x12\x87\x01\n\nListScopes\x12\x1f.clarifai.api.List\
    ScopesRequest\x1a$.clarifai.api.MultiScopeDepsResponse\"2\x98\x9c'\x03\
    \x82\xd3\xe4\x93\x02(\x12&/v2/users/{user_app_id.user_id}/scopes\x12\xa0\
    \x01\n\x06GetApp\x12\x1b.clarifai.api.GetAppRequest\x1a\x1f.clarifai.api\
    .SingleAppResponse\"X\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x13\x82\xd3\xe4\
    \x93\x02F\x129/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}Z\
    \t\x12\x07/v2/app\x12\x8f\x01\n\x08ListApps\x12\x1d.clarifai.api.ListApp\
    sRequest\x1a\x1e.clarifai.api.MultiAppResponse\"D\x98\x9c'\x05\x90\x9c'-\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x022\x12$/v2/users/{user_app_id.user_id}/a\
    ppsZ\n\x12\x08/v2/apps\x12\xa5\x01\n\tDeleteApp\x12\x1e.clarifai.api.Del\
    eteAppRequest\x1a!.clarifai.api.status.BaseResponse\"U\x98\x9c'\x05\x90\
    \x9c',\x90\x9c'.\x90\x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\x02;*9/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}\x12\x92\x01\n\x08PostApp\
    s\x12\x1d.clarifai.api.PostAppsRequest\x1a\x1e.clarifai.api.MultiAppResp\
    onse\"G\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x90\x9c'\x0f\x90\x9c'\x13\x90\
    \x9c'\x12\x82\xd3\xe4\x93\x02)\"$/v2/users/{user_app_id.user_id}/apps:\
    \x01*\x12\x88\x01\n\tPatchApps\x12\x1e.clarifai.api.PatchAppsRequest\x1a\
    \x1e.clarifai.api.MultiAppResponse\";\x98\x9c'\x05\x90\x9c',\x90\x9c'-\
    \x82\xd3\xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/apps:\x01*\x12\
    \x92\x01\n\x0cPatchAppsIds\x12!.clarifai.api.PatchAppsIdsRequest\x1a\x1e\
    .clarifai.api.MultiAppResponse\"?\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x82\
    \xd3\xe4\x93\x02-2(/v2/users/{user_app_id.user_id}/apps/ids:\x01*\x12\
    \x9c\x01\n\x08PatchApp\x12\x1d.clarifai.api.PatchAppRequest\x1a\x1f.clar\
    ifai.api.SingleAppResponse\"P\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x82\xd3\
    \xe4\x93\x02>29/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    :\x01*\x12\x9f\x01\n\x10PostAppsSearches\x12%.clarifai.api.PostAppsSearc\
    hesRequest\x1a\x1e.clarifai.api.MultiAppResponse\"D\x98\x9c'\x05\x90\x9c\
    '-\x90\x9c'\x13\x82\xd3\xe4\x93\x022\"-/v2/users/{user_app_id.user_id}/a\
    pps/searches:\x01*\x12v\n\x07GetUser\x12\x1c.clarifai.api.GetUserRequest\
    \x1a\x20.clarifai.api.SingleUserResponse\"+\x98\x9c'\x05\x82\xd3\xe4\x93\
    \x02!\x12\x1f/v2/users/{user_app_id.user_id}\x12\xcf\x01\n\x14PostValida\
    tePassword\x12).clarifai.api.PostValidatePasswordRequest\x1a..clarifai.a\
    pi.SinglePasswordValidationResponse\"\\\x98\x9c'\x03\x82\xd3\xe4\x93\x02\
    R\"1/v2/users/{user_app_id.user_id}/validate_password:\x01*Z\x1a\"\x15/v\
    2/validate_password:\x01*\x12\xc1\x01\n\tGetSearch\x12\x1e.clarifai.api.\
    GetSearchRequest\x1a\".clarifai.api.SingleSearchResponse\"p\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'r\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/searches/{id}Z\x13\x12\x11/v2/searches/{\
    id}\x12\xbc\x01\n\x0cListSearches\x12!.clarifai.api.ListSearchesRequest\
    \x1a!.clarifai.api.MultiSearchResponse\"f\x98\x9c'\x02\x90\x9c'-\x90\x9c\
    'r\x82\xd3\xe4\x93\x02T\x12B/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/searchesZ\x0e\x12\x0c/v2/searches\x12\xc8\x01\n\rPatchSear\
    ches\x12\".clarifai.api.PatchSearchesRequest\x1a!.clarifai.api.MultiSear\
    chResponse\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c's\x90\x9c'r\x82\xd3\xe4\x93\
    \x02Z2B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searche\
    s:\x01*Z\x112\x0c/v2/searches:\x01*\x12\xda\x01\n\x0cPostSearches\x12!.c\
    larifai.api.PostSearchesRequest\x1a!.clarifai.api.MultiSearchResponse\"\
    \x83\x01\x88\x02\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\
    \x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\xd3\xe4\x93\x02Z\"B\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches:\x01*\
    Z\x11\"\x0c/v2/searches:\x01*\x12\xd8\x01\n\x10PostSearchesByID\x12%.cla\
    rifai.api.PostSearchesByIDRequest\x1a!.clarifai.api.MultiSearchResponse\
    \"z\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c'\x03\x82\xd3\xe4\x93\x02d\"\
    G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}\
    :\x01*Z\x16\"\x11/v2/searches/{id}:\x01*\x12\xb3\x02\n\x1bPostAnnotation\
    SearchMetrics\x120.clarifai.api.PostAnnotationSearchMetricsRequest\x1a2.\
    clarifai.api.MultiAnnotationSearchMetricsResponse\"\xad\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x90\x9c'6\x90\
    \x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x82\x01\"V/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics:\x01\
    *Z%\"\x20/v2/annotations/searches/metrics:\x01*\x12\xa9\x02\n\x1aGetAnno\
    tationSearchMetrics\x12/.clarifai.api.GetAnnotationSearchMetricsRequest\
    \x1a2.clarifai.api.MultiAnnotationSearchMetricsResponse\"\xa5\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x82\
    \xd3\xe4\x93\x02\x86\x01\x12[/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/annotations/searches/metrics/{id}Z'\x12%/v2/annotations/s\
    earches/metrics/{id}\x12\xa0\x02\n\x1bListAnnotationSearchMetrics\x120.c\
    larifai.api.ListAnnotationSearchMetricsRequest\x1a2.clarifai.api.MultiAn\
    notationSearchMetricsResponse\"\x9a\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02|\x12V/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/met\
    ricsZ\"\x12\x20/v2/annotations/searches/metrics\x12\x9a\x02\n\x1dDeleteA\
    nnotationSearchMetrics\x122.clarifai.api.DeleteAnnotationSearchMetricsRe\
    quest\x1a!.clarifai.api.status.BaseResponse\"\xa1\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'5\x90\x9c'6\x90\x9c'?\x82\xd3\xe4\x93\x02\x86\x01*[/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches\
    /metrics/{id}Z'*%/v2/annotations/searches/metrics/{id}\x12\xce\x01\n\x0c\
    DeleteSearch\x12!.clarifai.api.DeleteSearchRequest\x1a!.clarifai.api.sta\
    tus.BaseResponse\"x\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c's\x90\x9c't\
    \x82\xd3\xe4\x93\x02^*G/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/searches/{id}Z\x13*\x11/v2/searches/{id}\x12\xec\x01\n\x15ListA\
    nnotationFilters\x12*.clarifai.api.ListAnnotationFiltersRequest\x1a+.cla\
    rifai.api.MultiAnnotationFilterResponse\"z\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'r\x82\xd3\xe4\x93\x02h\x12L/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/annotation_filtersZ\x18\x12\x16/v2/annotation_filters\
    \x12\x99\x02\n\x13GetAnnotationFilter\x12(.clarifai.api.GetAnnotationFil\
    terRequest\x1a,.clarifai.api.SingleAnnotationFilterResponse\"\xa9\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x82\xd3\xe4\x93\x02\x96\x01\x12c/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filters/{\
    annotation_filter_id}Z/\x12-/v2/annotation_filters/{annotation_filter_id\
    }\x12\xf7\x01\n\x15PostAnnotationFilters\x12*.clarifai.api.PostAnnotatio\
    nFiltersRequest\x1a+.clarifai.api.MultiAnnotationFilterResponse\"\x84\
    \x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c's\x82\xd3\xe4\x93\x02n\"L/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotation_filt\
    ers:\x01*Z\x1b\"\x16/v2/annotation_filters:\x01*\x12\xf9\x01\n\x16PatchA\
    nnotationFilters\x12+.clarifai.api.PatchAnnotationFiltersRequest\x1a+.cl\
    arifai.api.MultiAnnotationFilterResponse\"\x84\x01\x98\x9c'\x02\x90\x9c'\
    -\x90\x9c'r\x90\x9c's\x82\xd3\xe4\x93\x02n2L/v2/users/{user_app_id.user_\
    id}/apps/{user_app_id.app_id}/annotation_filters:\x01*Z\x1b2\x16/v2/anno\
    tation_filters:\x01*\x12\xf1\x01\n\x17DeleteAnnotationFilters\x12,.clari\
    fai.api.DeleteAnnotationFiltersRequest\x1a!.clarifai.api.status.BaseResp\
    onse\"\x84\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'r\x90\x9c's\x82\xd3\xe4\
    \x93\x02n*L/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/ann\
    otation_filters:\x01*Z\x1b*\x16/v2/annotation_filters:\x01*\x12|\n\x0fLi\
    stStatusCodes\x12$.clarifai.api.ListStatusCodesRequest\x1a%.clarifai.api\
    .MultiStatusCodeResponse\"\x1c\x98\x9c'\x01\x82\xd3\xe4\x93\x02\x12\x12\
    \x10/v2/status_codes\x12\x8a\x01\n\rGetStatusCode\x12\".clarifai.api.Get\
    StatusCodeRequest\x1a&.clarifai.api.SingleStatusCodeResponse\"-\x98\x9c'\
    \x01\x82\xd3\xe4\x93\x02#\x12!/v2/status_codes/{status_code_id}\x12\xc2\
    \x01\n\x11ListCollaborators\x12&.clarifai.api.ListCollaboratorsRequest\
    \x1a(.clarifai.api.MultiCollaboratorsResponse\"[\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'2\x82\xd3\xe4\x93\x02I\x12G/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/collaborators\x12\xc9\x01\n\x11PostCollaborators\
    \x12&.clarifai.api.PostCollaboratorsRequest\x1a(.clarifai.api.MultiColla\
    boratorsResponse\"b\x98\x9c'\x02\x90\x9c'-\x90\x9c'3\x90\x9c'2\x82\xd3\
    \xe4\x93\x02L\"G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/collaborators:\x01*\x12\xcf\x01\n\x12PatchCollaborators\x12'.clarifai.\
    api.PatchCollaboratorsRequest\x1a(.clarifai.api.MultiCollaboratorsRespon\
    se\"f\x98\x9c'\x02\x90\x9c'-\x90\x9c'3\x90\x9c'2\x90\x9c'4\x82\xd3\xe4\
    \x93\x02L2G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/col\
    laborators:\x01*\x12\xd2\x01\n\x13DeleteCollaborators\x12(.clarifai.api.\
    DeleteCollaboratorsRequest\x1a!.clarifai.api.status.BaseResponse\"n\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'3\x90\x9c'2\x90\x9c'4\x90\x9c'7\x90\x9c'8\
    \x82\xd3\xe4\x93\x02L*G/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/collaborators:\x01*\x12\xa4\x01\n\x12ListCollaborations\x12'.cl\
    arifai.api.ListCollaborationsRequest\x1a).clarifai.api.MultiCollaboratio\
    nsResponse\":\x98\x9c'\x03\x82\xd3\xe4\x93\x020\x12./v2/users/{user_app_\
    id.user_id}/collaborations\x12\xc6\x01\n\x13PostAppDuplications\x12(.cla\
    rifai.api.PostAppDuplicationsRequest\x1a*.clarifai.api.MultiAppDuplicati\
    onsResponse\"Y\x98\x9c'\x05\x90\x9c'-\x82\xd3\xe4\x93\x02K\"F/v2/users/{\
    user_app_id.user_id}/apps/{user_app_id.app_id}/duplications:\x01*\x12\
    \xa5\x01\n\x13ListAppDuplications\x12(.clarifai.api.ListAppDuplicationsR\
    equest\x1a*.clarifai.api.MultiAppDuplicationsResponse\"8\x98\x9c'\x05\
    \x82\xd3\xe4\x93\x02.\x12,/v2/users/{user_app_id.user_id}/duplications\
    \x12\xb6\x01\n\x11GetAppDuplication\x12&.clarifai.api.GetAppDuplicationR\
    equest\x1a*.clarifai.api.SingleAppDuplicationResponse\"M\x98\x9c'\x05\
    \x82\xd3\xe4\x93\x02C\x12A/v2/users/{user_app_id.user_id}/duplications/{\
    app_duplication_id}\x12\xd9\x01\n\tPostTasks\x12\x1e.clarifai.api.PostTa\
    sksRequest\x1a\x1f.clarifai.api.MultiTaskResponse\"\x8a\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'\x03\x90\x9c'r\x90\
    \x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x90\x9c'%\x90\x9c'&\x82\xd3\xe4\x93\
    \x02T\"?/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks:\
    \x01*Z\x0e\"\t/v2/tasks:\x01*\x12\xfe\x01\n\x16GetTaskAnnotationCount\
    \x12!.clarifai.api.GetTaskCountRequest\x1a%.clarifai.api.SingleTaskCount\
    Response\"\x99\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'8\x82\xd3\xe4\x93\x02\
    \x86\x01\x12[/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/t\
    asks/{task_id}/annotations/countZ'\x12%/v2/tasks/{task_id}/annotations/c\
    ount\x12\xee\x01\n\x11GetTaskInputCount\x12!.clarifai.api.GetTaskCountRe\
    quest\x1a%.clarifai.api.SingleTaskCountResponse\"\x8e\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'8\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/countZ\"\x12\x20/\
    v2/tasks/{task_id}/inputs/count\x12\xd0\x01\n\x07GetTask\x12\x1c.clarifa\
    i.api.GetTaskRequest\x1a\x20.clarifai.api.SingleTaskResponse\"\x84\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'8\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/tasks/{task_id}Z\x15\x12\x13/v2/tasks/{task_id}\
    \x12\xbe\x01\n\tListTasks\x12\x1e.clarifai.api.ListTasksRequest\x1a\x1f.\
    clarifai.api.MultiTaskResponse\"p\x98\x9c'\x02\x90\x9c'-\x90\x9c'8\x90\
    \x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02N\x12?/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasksZ\x0b\x12\
    \t/v2/tasks\x12\xd7\x01\n\nPatchTasks\x12\x1f.clarifai.api.PatchTasksReq\
    uest\x1a\x1f.clarifai.api.MultiTaskResponse\"\x86\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\
    \x13\x90\x9c'\x0f\x90\x9c'%\x90\x9c'&\x82\xd3\xe4\x93\x02T2?/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/tasks:\x01*Z\x0e2\t/v2/tas\
    ks:\x01*\x12\xc2\x01\n\x0bDeleteTasks\x12\x20.clarifai.api.DeleteTasksRe\
    quest\x1a!.clarifai.api.status.BaseResponse\"n\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'7\x90\x9c'8\x90\x9c'F\x82\xd3\xe4\x93\x02T*?/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/tasks:\x01*Z\x0e*\t/v2/tasks:\x01\
    *\x12\xf5\x01\n\x0fPostLabelOrders\x12$.clarifai.api.PostLabelOrdersRequ\
    est\x1a%.clarifai.api.MultiLabelOrderResponse\"\x94\x01\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'C\x90\x9c'D\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'r\
    \x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x82\xd3\xe4\x93\x02b\"F/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders:\x01*Z\x15\
    \"\x10/v2/label_orders:\x01*\x12\xf6\x01\n\rGetLabelOrder\x12\".clarifai\
    .api.GetLabelOrderRequest\x1a&.clarifai.api.SingleLabelOrderResponse\"\
    \x98\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'C\x90\x9c'\x0b\x90\x9c'8\x82\xd3\
    \xe4\x93\x02~\x12W/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/label_orders/{label_order_id}Z#\x12!/v2/label_orders/{label_order_id\
    }\x12\xd6\x01\n\x0fListLabelOrders\x12$.clarifai.api.ListLabelOrdersRequ\
    est\x1a%.clarifai.api.MultiLabelOrderResponse\"v\x98\x9c'\x02\x90\x9c'-\
    \x90\x9c'C\x90\x9c'\x0b\x90\x9c'8\x82\xd3\xe4\x93\x02\\\x12F/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/label_ordersZ\x12\x12\x10/\
    v2/label_orders\x12\xeb\x01\n\x10PatchLabelOrders\x12%.clarifai.api.Patc\
    hLabelOrdersRequest\x1a%.clarifai.api.MultiLabelOrderResponse\"\x88\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'C\x90\x9c'D\x90\x9c'\x0b\x90\x9c'7\x90\
    \x9c'8\x90\x9c'F\x82\xd3\xe4\x93\x02b2F/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/label_orders:\x01*Z\x152\x10/v2/label_orders:\
    \x01*\x12\xe5\x01\n\x11DeleteLabelOrders\x12&.clarifai.api.DeleteLabelOr\
    dersRequest\x1a!.clarifai.api.status.BaseResponse\"\x84\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'E\x90\x9c'C\x90\x9c'D\x90\x9c'7\x90\x9c'8\x82\xd3\xe4\
    \x93\x02b*F/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/lab\
    el_orders:\x01*Z\x15*\x10/v2/label_orders:\x01*\x12\xf2\x01\n\x0ePostCol\
    lectors\x12#.clarifai.api.PostCollectorsRequest\x1a$.clarifai.api.MultiC\
    ollectorResponse\"\x94\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x04\x90\x9c'%\
    \x90\x9c'&\x90\x9c')\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\
    \x90\x9c'\x02\x90\x9c'\x13\x82\xd3\xe4\x93\x02^\"D/v2/users/{user_app_id\
    .user_id}/apps/{user_app_id.app_id}/collectors:\x01*Z\x13\"\x0e/v2/colle\
    ctors:\x01*\x12\xe3\x01\n\x0cGetCollector\x12!.clarifai.api.GetCollector\
    Request\x1a%.clarifai.api.SingleCollectorResponse\"\x88\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'*\x82\xd3\xe4\x93\x02v\x12S/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/collectors/{collector_id}Z\x1f\x12\x1d/v\
    2/collectors/{collector_id}\x12\xc7\x01\n\x0eListCollectors\x12#.clarifa\
    i.api.ListCollectorsRequest\x1a$.clarifai.api.MultiCollectorResponse\"j\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'*\x82\xd3\xe4\x93\x02X\x12D/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/collectorsZ\x10\x12\x0e/v2/\
    collectors\x12\xd3\x01\n\x0fPatchCollectors\x12$.clarifai.api.PatchColle\
    ctorsRequest\x1a$.clarifai.api.MultiCollectorResponse\"t\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c')\x90\x9c'*\x82\xd3\xe4\x93\x02^2D/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/collectors:\x01*Z\x132\x0e/v2/col\
    lectors:\x01*\x12\xd6\x01\n\x10DeleteCollectors\x12%.clarifai.api.Delete\
    CollectorsRequest\x1a!.clarifai.api.status.BaseResponse\"x\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c')\x90\x9c'+\x90\x9c'*\x82\xd3\xe4\x93\x02^*D/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors:\x01*Z\x13*\
    \x0e/v2/collectors:\x01*\x12\xc9\x01\n\x0ePostStatValues\x12#.clarifai.a\
    pi.PostStatValuesRequest\x1a$.clarifai.api.MultiStatValueResponse\"l\x98\
    \x9c'\x02\x82\xd3\xe4\x93\x02b\"F/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/stats/values:\x01*Z\x15\"\x10/v2/stats/values:\x01*\
    \x12\xfd\x01\n\x17PostStatValuesAggregate\x12,.clarifai.api.PostStatValu\
    esAggregateRequest\x1a-.clarifai.api.MultiStatValueAggregateResponse\"\
    \x84\x01\x98\x9c'\x02\x90\x9c'-\x82\xd3\xe4\x93\x02v\"P/v2/users/{user_a\
    pp_id.user_id}/apps/{user_app_id.app_id}/stats/values/aggregate:\x01*Z\
    \x1f\"\x1a/v2/stats/values/aggregate:\x01*\x12\xe3\x01\n\x17PostTrending\
    MetricsView\x12,.clarifai.api.PostTrendingMetricsViewRequest\x1a!.clarif\
    ai.api.status.BaseResponse\"w\x98\x9c'\x02\x82\xd3\xe4\x93\x02m\"h/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/trending_metrics/vie\
    ws/{view_type}/{object_id}:\x01*\x12\x8f\x02\n\x18ListTrendingMetricsVie\
    ws\x12-.clarifai.api.ListTrendingMetricsViewsRequest\x1a..clarifai.api.M\
    ultiTrendingMetricsViewResponse\"\x93\x01\x98\x9c'\x02\x82\xd3\xe4\x93\
    \x02\x88\x01\x12\\/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/trending_metrics/views/{view_type}Z(\x12&/v2/trending_metrics/views/\
    {view_type}\x12\xb2\x01\n\tGetModule\x12\x1e.clarifai.api.GetModuleReque\
    st\x1a\".clarifai.api.SingleModuleResponse\"a\x98\x9c'\x05\x90\x9c'-\x90\
    \x9c'm\x82\xd3\xe4\x93\x02O\x12M/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/modules/{module_id}\x12\xe4\x01\n\x0bListModules\x12\
    \x20.clarifai.api.ListModulesRequest\x1a!.clarifai.api.MultiModuleRespon\
    se\"\x8f\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\xe4\x93\x02}\x12A/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/modulesZ)\x12'/\
    v2/users/{user_app_id.user_id}/modulesZ\r\x12\x0b/v2/modules\x12\xb0\x01\
    \n\x0bPostModules\x12\x20.clarifai.api.PostModulesRequest\x1a!.clarifai.\
    api.MultiModuleResponse\"\\\x98\x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'm\
    \x82\xd3\xe4\x93\x02F\"A/v2/users/{user_app_id.user_id}/apps/{user_app_i\
    d.app_id}/modules:\x01*\x12\xb2\x01\n\x0cPatchModules\x12!.clarifai.api.\
    PatchModulesRequest\x1a!.clarifai.api.MultiModuleResponse\"\\\x98\x9c'\
    \x05\x90\x9c'-\x90\x9c'l\x90\x9c'm\x82\xd3\xe4\x93\x02F2A/v2/users/{user\
    _app_id.user_id}/apps/{user_app_id.app_id}/modules:\x01*\x12\xd0\x01\n\r\
    DeleteModules\x12\".clarifai.api.DeleteModulesRequest\x1a!.clarifai.api.\
    status.BaseResponse\"x\x98\x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'n\x90\
    \x9c'm\x90\x9c'p\x90\x9c'o\x90\x9c'q\x90\x9c'1\x90\x9c'0\x90\x9c'/\x82\
    \xd3\xe4\x93\x02F*A/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/modules:\x01*\x12\xe4\x01\n\x10GetModuleVersion\x12%.clarifai.api.G\
    etModuleVersionRequest\x1a).clarifai.api.SingleModuleVersionResponse\"~\
    \x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\xe4\x93\x02l\x12j/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/version\
    s/{module_version_id}\x12\xd3\x01\n\x12ListModuleVersions\x12'.clarifai.\
    api.ListModuleVersionsRequest\x1a(.clarifai.api.MultiModuleVersionRespon\
    se\"j\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x82\xd3\xe4\x93\x02X\x12V/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/ve\
    rsions\x12\xda\x01\n\x12PostModuleVersions\x12'.clarifai.api.PostModuleV\
    ersionsRequest\x1a(.clarifai.api.MultiModuleVersionResponse\"q\x98\x9c'\
    \x05\x90\x9c'-\x90\x9c'l\x90\x9c'm\x82\xd3\xe4\x93\x02[\"V/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/versions\
    :\x01*\x12\xdc\x01\n\x13PatchModuleVersions\x12(.clarifai.api.PatchModul\
    eVersionsRequest\x1a(.clarifai.api.MultiModuleVersionResponse\"q\x98\x9c\
    '\x05\x90\x9c'-\x90\x9c'l\x90\x9c'm\x82\xd3\xe4\x93\x02[2V/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/versions\
    :\x01*\x12\xf4\x01\n\x14DeleteModuleVersions\x12).clarifai.api.DeleteMod\
    uleVersionsRequest\x1a!.clarifai.api.status.BaseResponse\"\x8d\x01\x98\
    \x9c'\x05\x90\x9c'-\x90\x9c'l\x90\x9c'n\x90\x9c'm\x90\x9c'p\x90\x9c'o\
    \x90\x9c'q\x90\x9c'1\x90\x9c'0\x90\x9c'/\x82\xd3\xe4\x93\x02[*V/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/modules/{module_id}/ver\
    sions:\x01*\x12\x93\x02\n\x1aGetModuleVersionUsageCount\x12/.clarifai.ap\
    i.GetModuleVersionUsageCountRequest\x1a3.clarifai.api.SingleModuleVersio\
    nUsageCountResponse\"\x8e\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'm\x90\x9c'p\
    \x82\xd3\xe4\x93\x02x\x12v/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/modules/{module_id}/versions/{module_version_id}/usage_count\
    \x12\x8f\x02\n\x19GetInstalledModuleVersion\x12..clarifai.api.GetInstall\
    edModuleVersionRequest\x1a2.clarifai.api.SingleInstalledModuleVersionRes\
    ponse\"\x8d\x01\x98\x9c'\x05\x90\x9c'-\x90\x9c'p\x90\x9c'm\x90\x9c'0\x82\
    \xd3\xe4\x93\x02s\x12q/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/installed_module_versions/{installed_module_version_id}\x12\xf3\
    \x01\n\x1bListInstalledModuleVersions\x120.clarifai.api.ListInstalledMod\
    uleVersionsRequest\x1a1.clarifai.api.MultiInstalledModuleVersionResponse\
    \"o\x98\x9c'\x05\x90\x9c'-\x90\x9c'p\x90\x9c'm\x90\x9c'0\x82\xd3\xe4\x93\
    \x02U\x12S/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inst\
    alled_module_versions\x12\xf6\x01\n\x1bPostInstalledModuleVersions\x120.\
    clarifai.api.PostInstalledModuleVersionsRequest\x1a1.clarifai.api.MultiI\
    nstalledModuleVersionResponse\"r\x98\x9c'\x05\x90\x9c'o\x90\x9c'p\x90\
    \x9c'm\x90\x9c'-\x82\xd3\xe4\x93\x02X\"S/v2/users/{user_app_id.user_id}/\
    apps/{user_app_id.app_id}/installed_module_versions:\x01*\x12\xfb\x01\n\
    \x1dDeleteInstalledModuleVersions\x122.clarifai.api.DeleteInstalledModul\
    eVersionsRequest\x1a!.clarifai.api.status.BaseResponse\"\x82\x01\x98\x9c\
    '\x05\x90\x9c'-\x90\x9c'm\x90\x9c'o\x90\x9c'p\x90\x9c'q\x90\x9c'1\x90\
    \x9c'/\x90\x9c'0\x82\xd3\xe4\x93\x02X*S/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/installed_module_versions:\x01*\x12\x95\x02\n\
    \x1ePostInstalledModuleVersionsKey\x123.clarifai.api.PostInstalledModule\
    VersionsKeyRequest\x1a\x1f.clarifai.api.SingleKeyResponse\"\x9c\x01\x98\
    \x9c'\x05\x90\x9c'o\x90\x9c'p\x90\x9c'm\x90\x9c'-\x90\x9c'/\x90\x9c'0\
    \x82\xd3\xe4\x93\x02z\"u/v2/users/{user_app_id.user_id}/apps/{user_app_i\
    d.app_id}/installed_module_versions/{installed_module_version_id}/key:\
    \x01*\x12\xf5\x01\n\x12PostBulkOperations\x12'.clarifai.api.PostBulkOper\
    ationsRequest\x1a).clarifai.api.MultiBulkOperationsResponse\"\x8a\x01\
    \x98\x9c'\x02\x90\x9c'-\x90\x9c'z\x90\x9c'y\x90\x9c'%\x90\x9c'&\x90\x9c'\
    (\x82\xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/apps/{user_app_\
    id.app_id}/bulk_operations:\x01*Z\x18\"\x13/v2/bulk_operations:\x01*\x12\
    \xde\x01\n\x12ListBulkOperations\x12'.clarifai.api.ListBulkOperationsReq\
    uest\x1a).clarifai.api.MultiBulkOperationsResponse\"t\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'z\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id\
    }/apps/{user_app_id.app_id}/bulk_operationsZ\x15\x12\x13/v2/bulk_operati\
    ons\x12\xe5\x01\n\x10GetBulkOperation\x12%.clarifai.api.GetBulkOperation\
    Request\x1a*.clarifai.api.SingleBulkOperationsResponse\"~\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'z\x82\xd3\xe4\x93\x02l\x12N/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/bulk_operations/{id}Z\x1a\x12\x18/v2/bul\
    k_operations/{id}\x12\xeb\x01\n\x14CancelBulkOperations\x12(.clarifai.ap\
    i.CancelBulkOperationRequest\x1a).clarifai.api.MultiBulkOperationsRespon\
    se\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c'y\x90\x9c'z\x82\xd3\xe4\x93\x02h2I/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations\
    :\x01*Z\x182\x13/v2/bulk_operations:\x01*\x12\xf4\x01\n\x14DeleteBulkOpe\
    rations\x12(.clarifai.api.DeleteBulkOperationRequest\x1a!.clarifai.api.s\
    tatus.BaseResponse\"\x8e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'%\
    \x90\x9c'(\x90\x9c'y\x90\x9c'z\x90\x9c'{\x82\xd3\xe4\x93\x02h*I/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/bulk_operations:\x01*Z\
    \x18*\x13/v2/bulk_operations:\x01*\x12\x88\x02\n\x17ListNextTaskAssignme\
    nts\x12,.clarifai.api.ListNextTaskAssignmentsRequest\x1a\x20.clarifai.ap\
    i.MultiInputResponse\"\x9c\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x05\x90\x9c'8\x90\x9c'i\x82\xd3\xe4\x93\x02z\x12U/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/assignm\
    entsZ!\x12\x1f/v2/tasks/{task_id}/assignments\x12\xeb\x01\n\x12PutTaskAs\
    signments\x12'.clarifai.api.PutTaskAssignmentsRequest\x1a).clarifai.api.\
    MultiTaskAssignmentResponse\"\x80\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\
    \x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'8\x90\x9c'i\x82\xd3\xe4\x93\
    \x02Z\x1aU/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/task\
    s/{task_id}/assignments:\x01*\x12\xda\x01\n\x11ListInputsAddJobs\x12&.cl\
    arifai.api.ListInputsAddJobsRequest\x1a'.clarifai.api.MultiInputsAddJobR\
    esponse\"t\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x82\xd3\xe4\x93\x02b\x12I\
    /v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/ad\
    dZ\x15\x12\x13/v2/inputs/jobs/add\x12\xe1\x01\n\x0fGetInputsAddJob\x12$.\
    clarifai.api.GetInputsAddJobRequest\x1a(.clarifai.api.SingleInputsAddJob\
    Response\"~\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x82\xd3\xe4\x93\x02l\x12\
    N/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/jobs/a\
    dd/{id}Z\x1a\x12\x18/v2/inputs/jobs/add/{id}\x12\xf2\x01\n\x12CancelInpu\
    tsAddJob\x12'.clarifai.api.CancelInputsAddJobRequest\x1a(.clarifai.api.S\
    ingleInputsAddJobResponse\"\x88\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x04\
    \x90\x9c'\x05\x82\xd3\xe4\x93\x02r2N/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/inputs/jobs/add/{id}:\x01*Z\x1d2\x18/v2/inputs/job\
    s/add/{id}:\x01*\x12\xc4\x01\n\x0bPostUploads\x12\x20.clarifai.api.PostU\
    ploadsRequest\x1a!.clarifai.api.MultiUploadResponse\"p\x98\x9c'\x02\x90\
    \x9c'-\x90\x9c'\x81\x01\x90\x9c'\x80\x01\x82\xd3\xe4\x93\x02X\"A/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads:\x01*Z\x10\"\
    \x0b/v2/uploads:\x01*\x12\x8c\x02\n\x15PutUploadContentParts\x12*.clarif\
    ai.api.PutUploadContentPartsRequest\x1a\".clarifai.api.SingleUploadRespo\
    nse\"\xa2\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x81\x01\x90\x9c'\x80\x01\
    \x82\xd3\xe4\x93\x02\x89\x01\x1a[/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/uploads/{upload_id}/content_parts:\x01*Z'\x1a%/v2/upl\
    oads/{upload_id}/content_parts\x12\xce\x01\n\tGetUpload\x12\x1e.clarifai\
    .api.GetUploadRequest\x1a\".clarifai.api.SingleUploadResponse\"}\x98\x9c\
    '\x02\x90\x9c'-\x90\x9c'\x80\x01\x82\xd3\xe4\x93\x02j\x12M/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/uploads/{upload_id}Z\x19\x12\
    \x17/v2/uploads/{upload_id}\x12\xb9\x01\n\x0bListUploads\x12\x20.clarifa\
    i.api.ListUploadsRequest\x1a!.clarifai.api.MultiUploadResponse\"e\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'\x80\x01\x82\xd3\xe4\x93\x02R\x12A/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/uploadsZ\r\x12\x0b/v2/up\
    loads\x12\xcd\x01\n\rDeleteUploads\x12\".clarifai.api.DeleteUploadsReque\
    st\x1a!.clarifai.api.status.BaseResponse\"u\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x80\x01\x90\x9c'\x81\x01\x90\x9c'\x82\x01\x82\xd3\xe4\x93\x02X*A/v\
    2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/uploads:\x01*Z\
    \x10*\x0b/v2/uploads:\x01*\x12\x8d\x02\n\x15PostInputsDataSources\x12*.c\
    larifai.api.PostInputsDataSourcesRequest\x1a'.clarifai.api.MultiInputsAd\
    dJobResponse\"\x9e\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\
    \x13\x82\xd3\xe4\x93\x02p\"M/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/inputs/data_sources:\x01*Z\x1c\"\x17/v2/inputs/data_source\
    s:\x01*\x12\xb2\x02\n\x16GetInputsExtractionJob\x12+.clarifai.api.GetInp\
    utsExtractionJobRequest\x1a/.clarifai.api.SingleInputsExtractionJobRespo\
    nse\"\xb9\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x05\x82\xd3\xe4\x93\x02\
    \xa6\x01\x12k/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/i\
    nputs/jobs/extraction/{inputs_extraction_job_id}Z7\x125/v2/inputs/jobs/e\
    xtraction/{inputs_extraction_job_id}\x12\xfe\x01\n\x18ListInputsExtracti\
    onJobs\x12-.clarifai.api.ListInputsExtractionJobsRequest\x1a..clarifai.a\
    pi.MultiInputsExtractionJobResponse\"\x82\x01\x98\x9c'\x02\x90\x9c'-\x90\
    \x9c'\x05\x82\xd3\xe4\x93\x02p\x12P/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/inputs/jobs/extractionZ\x1c\x12\x1a/v2/inputs/jobs/\
    extraction\x12\x8c\x02\n\x1aCancelInputsExtractionJobs\x12/.clarifai.api\
    .CancelInputsExtractionJobsRequest\x1a..clarifai.api.MultiInputsExtracti\
    onJobResponse\"\x8c\x01\x98\x9c'\x02\x90\x9c'-\x90\x9c'\x04\x90\x9c'\x05\
    \x82\xd3\xe4\x93\x02v2P/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/inputs/jobs/extraction:\x01*Z\x1f2\x1a/v2/inputs/jobs/extractio\
    n:\x01*\x12\x85\x02\n\x11PostInputsUploads\x12&.clarifai.api.PostInputsU\
    ploadsRequest\x1a'.clarifai.api.MultiInputsAddJobResponse\"\x9e\x01\x98\
    \x9c'\x02\x90\x9c'-\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\
    \x9c'\x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\x13\x90\x9c'\x81\x01\x90\
    \x9c'\x80\x01\x82\xd3\xe4\x93\x02f\"H/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/inputs/uploads:\x01*Z\x17\"\x12/v2/inputs/uploads\
    :\x01*\x12\x99\x01\n\tGetRunner\x12\x1e.clarifai.api.GetRunnerRequest\
    \x1a\".clarifai.api.SingleRunnerResponse\"H\x98\x9c'\x05\x90\x9c'-\x90\
    \x9c'\x83\x01\x82\xd3\xe4\x93\x025\x123/v2/users/{user_app_id.user_id}/r\
    unners/{runner_id}\x12\x90\x01\n\x0bListRunners\x12\x20.clarifai.api.Lis\
    tRunnersRequest\x1a!.clarifai.api.MultiRunnerResponse\"<\x98\x9c'\x05\
    \x90\x9c'-\x90\x9c'\x83\x01\x82\xd3\xe4\x93\x02)\x12'/v2/users/{user_app\
    _id.user_id}/runners\x12\x98\x01\n\x0bPostRunners\x12\x20.clarifai.api.P\
    ostRunnersRequest\x1a!.clarifai.api.MultiRunnerResponse\"D\x98\x9c'\x05\
    \x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x84\x01\x82\xd3\xe4\x93\x02,\"'/v2/\
    users/{user_app_id.user_id}/runners:\x01*\x12\xa1\x01\n\rDeleteRunners\
    \x12\".clarifai.api.DeleteRunnersRequest\x1a!.clarifai.api.status.BaseRe\
    sponse\"I\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x84\x01\x90\
    \x9c'\x85\x01\x82\xd3\xe4\x93\x02,*'/v2/users/{user_app_id.user_id}/runn\
    ers:\x01*\x12\xb3\x01\n\x0fListRunnerItems\x12$.clarifai.api.ListRunnerI\
    temsRequest\x1a%.clarifai.api.MultiRunnerItemResponse\"S\x98\x9c'\x05\
    \x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x86\x01\x82\xd3\xe4\x93\x02;\x129/v\
    2/users/{user_app_id.user_id}/runners/{runner_id}/items\x12\xe6\x01\n\
    \x15PostRunnerItemOutputs\x12*.clarifai.api.PostRunnerItemOutputsRequest\
    \x1a+.clarifai.api.MultiRunnerItemOutputResponse\"t\x98\x9c'\x05\x90\x9c\
    '-\x90\x9c'\x83\x01\x90\x9c'\x86\x01\x90\x9c'\x87\x01\x82\xd3\xe4\x93\
    \x02W\"R/v2/users/{user_app_id.user_id}/runners/{runner_id}/items/{runne\
    r_item_id}/outputs:\x01*\x12\x84\x01\n\x12ProcessRunnerItems\x12*.clarif\
    ai.api.PostRunnerItemOutputsRequest\x1a%.clarifai.api.MultiRunnerItemRes\
    ponse\"\x17\x98\x9c'\x05\x90\x9c'-\x90\x9c'\x83\x01\x90\x9c'\x86\x01\x90\
    \x9c'\x87\x01(\x010\x01\x12\xc4\x02\n%PostModelVersionsTrainingTimeEstim\
    ate\x12:.clarifai.api.PostModelVersionsTrainingTimeEstimateRequest\x1a/.\
    clarifai.api.MultiTrainingTimeEstimateResponse\"\xad\x01\x98\x9c'\x02\
    \x90\x9c'-\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x9a\x01\"b/v2/users/{user_ap\
    p_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/time_\
    estimate:\x01*Z1\",/v2/models/{model_id}/versions/time_estimate:\x01*BY\
    \n\x15com.clarifai.grpc.apiP\x01Z7github.com/Clarifai/clarifai-go-grpc/p\
    roto/clarifai/api\xa2\x02\x04CAIPJ\xf6\xce\r\n\x07\x12\x05\x02\0\xe2;\
    \x01\n\x08\n\x01\x0c\x12\x03\x02\0\x12\n\t\n\x02\x03\0\x12\x03\x04\0,\n\
    \t\n\x02\x03\x01\x12\x03\x05\00\n\t\n\x02\x03\x02\x12\x03\x06\03\n\t\n\
    \x02\x03\x03\x12\x03\x07\0/\n\t\n\x02\x03\x04\x12\x03\x08\02\n\t\n\x02\
    \x03\x05\x12\x03\t\05\n\t\n\x02\x03\x06\x12\x03\x0c\0&\n\t\n\x02\x03\x07\
    \x12\x03\r\0(\n\t\n\x02\x03\x08\x12\x03\x0e\0&\n\t\n\x02\x03\t\x12\x03\
    \x0f\0)\n\x08\n\x01\x02\x12\x03\x12\0\x15\n\x08\n\x01\x08\x12\x03\x14\0N\
    \n\t\n\x02\x08\x0b\x12\x03\x14\0N\n\x08\n\x01\x08\x12\x03\x15\0\"\n\t\n\
    \x02\x08\n\x12\x03\x15\0\"\n\x08\n\x01\x08\x12\x03\x16\0.\n\t\n\x02\x08\
    \x01\x12\x03\x16\0.\n\x08\n\x01\x08\x12\x03\x17\0\"\n\t\n\x02\x08$\x12\
    \x03\x17\0\"\n\xb4\x06\n\x02\x06\0\x12\x05-\0\xd2\x1d\x012\xa6\x06\nNote\
    :\x20this\x20is\x20based\x20on\x20the\x20google\x20api\x20format\x20defi\
    ned\x20here.\x20Please\nread\x20this\x20before\x20contributing\x20to\x20\
    this\x20file\x20and\x20other\x20*.proto\x20files\nfor\x20the\x20API.\nht\
    tps://cloud.google.com/service-management/reference/rpc/google.api#googl\
    e.api.HttpRule\n\nFor\x20the\x20cl_depending_scopes\x20in\x20this\x20fil\
    e,\x20see\x20the\x20docstring\x20that\x20explains\x20the\x20two\x20types\
    \x20of\nscope\x20dependencies\x20in\x20clarifai/auth/scope/scope.proto\n\
    \nFor\x20new\x20endpoints\x20you\x20should\x20typically\x20only\x20add\
    \x20the\x20fully\x20qualified\x20url\x20that\x20includes\x20the\x20user_\
    id\nand\x20app_id.\n\nYou\x20should\x20typicaly\x20use\x20KeyAuth\x20(th\
    e\x20most\x20restricted\x20auth\x20type)\x20for\x20new\x20endpoints\x20u\
    nless\x20they\x20are\nfor\x20resources\x20not\x20contained\x20in\x20an\
    \x20app\x20or\x20need\x20access\x20from\x20things\x20across\x20apps.\x20\
    See\x20more\x20about\x20the\nauth\x20types\x20here:\nhttps://clarifai.at\
    lassian.net/wiki/spaces/TT/pages/1821409336/API+Authorizers+and+Resource\
    +Access\n\n\n\n\n\x03\x06\0\x01\x12\x03-\x08\n\n\xdd\x01\n\x04\x06\0\x02\
    \0\x12\x047\x02A\x03\x1a\xce\x01\x20List\x20concept\x20relations\x20betw\
    een\x20concepts\x20in\x20the\x20platform.\n\x20MUST\x20be\x20above\x20Li\
    stConcepts\x20so\x20that\x20if\x20concept_id\x20is\x20empty\x20this\x20w\
    ill\x20still\x20match\n\x20/concepts/relations\x20to\x20list\x20all\x20t\
    he\x20concept\x20relations\x20in\x20the\x20app.\n\n\x0c\n\x05\x06\0\x02\
    \0\x01\x12\x037\x06\x1a\n\x0c\n\x05\x06\0\x02\0\x02\x12\x037\x1c7\n\x0c\
    \n\x05\x06\0\x02\0\x03\x12\x037B^\n\r\n\x05\x06\0\x02\0\x04\x12\x048\x04\
    =\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x048\x04=\x06\n\x0c\n\
    \x05\x06\0\x02\0\x04\x12\x03>\x047\n\x0f\n\x08\x06\0\x02\0\x04\xc3\xf3\
    \x04\x12\x03>\x047\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03?\x04?\n\x10\n\t\
    \x06\0\x02\0\x04\xc2\xf3\x04\0\x12\x03?\x04?\n\x0c\n\x05\x06\0\x02\0\x04\
    \x12\x03@\x04C\n\x10\n\t\x06\0\x02\0\x04\xc2\xf3\x04\x01\x12\x03@\x04C\n\
    \\\n\x04\x06\0\x02\x01\x12\x04F\x02O\x03\x1aN\x20Post\x20concept\x20rela\
    tions\x20to\x20create\x20relations\x20between\x20concepts\x20in\x20the\
    \x20platform.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03F\x06\x1a\n\x0c\n\
    \x05\x06\0\x02\x01\x02\x12\x03F\x1c7\n\x0c\n\x05\x06\0\x02\x01\x03\x12\
    \x03FB^\n\r\n\x05\x06\0\x02\x01\x04\x12\x04G\x04J\x06\n\x11\n\t\x06\0\
    \x02\x01\x04\xb0\xca\xbc\"\x12\x04G\x04J\x06\n\x0c\n\x05\x06\0\x02\x01\
    \x04\x12\x03K\x047\n\x0f\n\x08\x06\0\x02\x01\x04\xc3\xf3\x04\x12\x03K\
    \x047\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03L\x04?\n\x10\n\t\x06\0\x02\
    \x01\x04\xc2\xf3\x04\0\x12\x03L\x04?\n\x0c\n\x05\x06\0\x02\x01\x04\x12\
    \x03M\x04C\n\x10\n\t\x06\0\x02\x01\x04\xc2\xf3\x04\x01\x12\x03M\x04C\n\
    \x0c\n\x05\x06\0\x02\x01\x04\x12\x03N\x04C\n\x10\n\t\x06\0\x02\x01\x04\
    \xc2\xf3\x04\x02\x12\x03N\x04C\n\\\n\x04\x06\0\x02\x02\x12\x04R\x02\\\
    \x03\x1aN\x20Post\x20concept\x20relations\x20to\x20create\x20relations\
    \x20between\x20concepts\x20in\x20the\x20platform.\n\n\x0c\n\x05\x06\0\
    \x02\x02\x01\x12\x03R\x06\x1c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03R\x1e\
    ;\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03RFf\n\r\n\x05\x06\0\x02\x02\x04\
    \x12\x04S\x04V\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04S\
    \x04V\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03W\x047\n\x0f\n\x08\x06\0\
    \x02\x02\x04\xc3\xf3\x04\x12\x03W\x047\n\x0c\n\x05\x06\0\x02\x02\x04\x12\
    \x03X\x04?\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\0\x12\x03X\x04?\n\x0c\
    \n\x05\x06\0\x02\x02\x04\x12\x03Y\x04F\n\x10\n\t\x06\0\x02\x02\x04\xc2\
    \xf3\x04\x01\x12\x03Y\x04F\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03Z\x04C\n\
    \x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\x02\x12\x03Z\x04C\n\x0c\n\x05\x06\
    \0\x02\x02\x04\x12\x03[\x04C\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\x03\
    \x12\x03[\x04C\nM\n\x04\x06\0\x02\x03\x12\x04_\x02k\x03\x1a?\x20List\x20\
    all\x20the\x20concepts\x20with\x20their\x20positive\x20and\x20negative\
    \x20counts\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03_\x06\x16\n\x0c\n\x05\
    \x06\0\x02\x03\x02\x12\x03_\x18/\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03_:\
    S\n\r\n\x05\x06\0\x02\x03\x04\x12\x04`\x04e\x06\n\x11\n\t\x06\0\x02\x03\
    \x04\xb0\xca\xbc\"\x12\x04`\x04e\x06\n\x0c\n\x05\x06\0\x02\x03\x04\x12\
    \x03f\x047\n\x0f\n\x08\x06\0\x02\x03\x04\xc3\xf3\x04\x12\x03f\x047\n\x0c\
    \n\x05\x06\0\x02\x03\x04\x12\x03g\x04?\n\x10\n\t\x06\0\x02\x03\x04\xc2\
    \xf3\x04\0\x12\x03g\x04?\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03h\x04F\n\
    \x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\x01\x12\x03h\x04F\n\x0c\n\x05\x06\
    \0\x02\x03\x04\x12\x03i\x04C\n\x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\x02\
    \x12\x03i\x04C\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03j\x04A\n\x10\n\t\x06\
    \0\x02\x03\x04\xc2\xf3\x04\x03\x12\x03j\x04A\n3\n\x04\x06\0\x02\x04\x12\
    \x04n\x02x\x03\x1a%\x20Get\x20a\x20specific\x20concept\x20from\x20an\x20\
    app.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03n\x06\x10\n\x0c\n\x05\x06\0\
    \x02\x04\x02\x12\x03n\x12#\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03n.C\n\r\
    \n\x05\x06\0\x02\x04\x04\x12\x04o\x04t\x06\n\x11\n\t\x06\0\x02\x04\x04\
    \xb0\xca\xbc\"\x12\x04o\x04t\x06\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03u\
    \x047\n\x0f\n\x08\x06\0\x02\x04\x04\xc3\xf3\x04\x12\x03u\x047\n\x0c\n\
    \x05\x06\0\x02\x04\x04\x12\x03v\x04?\n\x10\n\t\x06\0\x02\x04\x04\xc2\xf3\
    \x04\0\x12\x03v\x04?\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03w\x04C\n\x10\n\
    \t\x06\0\x02\x04\x04\xc2\xf3\x04\x01\x12\x03w\x04C\n'\n\x04\x06\0\x02\
    \x05\x12\x05{\x02\x85\x01\x03\x1a\x18\x20List\x20all\x20the\x20concepts.\
    \n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03{\x06\x12\n\x0c\n\x05\x06\0\x02\
    \x05\x02\x12\x03{\x14'\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03{2F\n\x0e\n\
    \x05\x06\0\x02\x05\x04\x12\x05|\x04\x81\x01\x06\n\x12\n\t\x06\0\x02\x05\
    \x04\xb0\xca\xbc\"\x12\x05|\x04\x81\x01\x06\n\r\n\x05\x06\0\x02\x05\x04\
    \x12\x04\x82\x01\x047\n\x10\n\x08\x06\0\x02\x05\x04\xc3\xf3\x04\x12\x04\
    \x82\x01\x047\n\r\n\x05\x06\0\x02\x05\x04\x12\x04\x83\x01\x04?\n\x11\n\t\
    \x06\0\x02\x05\x04\xc2\xf3\x04\0\x12\x04\x83\x01\x04?\n\r\n\x05\x06\0\
    \x02\x05\x04\x12\x04\x84\x01\x04C\n\x11\n\t\x06\0\x02\x05\x04\xc2\xf3\
    \x04\x01\x12\x04\x84\x01\x04C\n'\n\x04\x06\0\x02\x06\x12\x06\x88\x01\x02\
    \x93\x01\x03\x1a\x17\x20List\x20models\x20concepts.\n\n\r\n\x05\x06\0\
    \x02\x06\x01\x12\x04\x88\x01\x06\x17\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\
    \x88\x01\x191\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\x88\x01<P\n\x0f\n\x05\
    \x06\0\x02\x06\x04\x12\x06\x89\x01\x04\x8e\x01\x06\n\x13\n\t\x06\0\x02\
    \x06\x04\xb0\xca\xbc\"\x12\x06\x89\x01\x04\x8e\x01\x06\n\r\n\x05\x06\0\
    \x02\x06\x04\x12\x04\x8f\x01\x047\n\x10\n\x08\x06\0\x02\x06\x04\xc3\xf3\
    \x04\x12\x04\x8f\x01\x047\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x90\x01\
    \x04?\n\x11\n\t\x06\0\x02\x06\x04\xc2\xf3\x04\0\x12\x04\x90\x01\x04?\n\r\
    \n\x05\x06\0\x02\x06\x04\x12\x04\x91\x01\x04C\n\x11\n\t\x06\0\x02\x06\
    \x04\xc2\xf3\x04\x01\x12\x04\x91\x01\x04C\n\r\n\x05\x06\0\x02\x06\x04\
    \x12\x04\x92\x01\x04A\n\x11\n\t\x06\0\x02\x06\x04\xc2\xf3\x04\x02\x12\
    \x04\x92\x01\x04A\n\xcd\x01\n\x04\x06\0\x02\x07\x12\x06\x98\x01\x02\xa6\
    \x01\x03\x1a\xbc\x01\x20Search\x20over\x20the\x20concepts\x20to\x20find\
    \x20one\x20or\x20more\x20you're\x20looking\x20for.\n\x20This\x20leverage\
    \x20the\x20\"body\"\x20parameter\x20because\x20we\x20also\x20have\x20pag\
    e\x20and\n\x20per_page\x20as\x20url\x20query\x20param\x20variables\x20in\
    \x20this\x20request.\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\x98\x01\x06\
    \x1a\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\x98\x01\x1c7\n\r\n\x05\x06\0\
    \x02\x07\x03\x12\x04\x98\x01BV\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x99\
    \x01\x04\xa0\x01\x06\n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\
    \x99\x01\x04\xa0\x01\x06\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\xa1\x01\x04\
    7\n\x10\n\x08\x06\0\x02\x07\x04\xc3\xf3\x04\x12\x04\xa1\x01\x047\n\r\n\
    \x05\x06\0\x02\x07\x04\x12\x04\xa2\x01\x04?\n\x11\n\t\x06\0\x02\x07\x04\
    \xc2\xf3\x04\0\x12\x04\xa2\x01\x04?\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\
    \xa3\x01\x04C\n\x11\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\x01\x12\x04\xa3\
    \x01\x04C\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\xa4\x01\x04A\n\x11\n\t\x06\
    \0\x02\x07\x04\xc2\xf3\x04\x02\x12\x04\xa4\x01\x04A\n\r\n\x05\x06\0\x02\
    \x07\x04\x12\x04\xa5\x01\x04D\nP\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\x03\
    \x12\x04\xa5\x01\x04D\"=\x20as\x20it\x20needs\x20to\x20know\x20the\x20co\
    ncepts\x20in\x20your\x20workflow's\x20models.\n\n*\n\x04\x06\0\x02\x08\
    \x12\x06\xa9\x01\x02\xb6\x01\x03\x1a\x1a\x20Add\x20a\x20concept\x20to\
    \x20an\x20app.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xa9\x01\x06\x12\n\r\
    \n\x05\x06\0\x02\x08\x02\x12\x04\xa9\x01\x14'\n\r\n\x05\x06\0\x02\x08\
    \x03\x12\x04\xa9\x012F\n\x0f\n\x05\x06\0\x02\x08\x04\x12\x06\xaa\x01\x04\
    \xb1\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x06\xaa\x01\
    \x04\xb1\x01\x06\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xb2\x01\x047\n\x10\
    \n\x08\x06\0\x02\x08\x04\xc3\xf3\x04\x12\x04\xb2\x01\x047\n\r\n\x05\x06\
    \0\x02\x08\x04\x12\x04\xb3\x01\x04?\n\x11\n\t\x06\0\x02\x08\x04\xc2\xf3\
    \x04\0\x12\x04\xb3\x01\x04?\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\xb4\x01\
    \x04C\n\x11\n\t\x06\0\x02\x08\x04\xc2\xf3\x04\x01\x12\x04\xb4\x01\x04C\n\
    \r\n\x05\x06\0\x02\x08\x04\x12\x04\xb5\x01\x04C\n\x11\n\t\x06\0\x02\x08\
    \x04\xc2\xf3\x04\x02\x12\x04\xb5\x01\x04C\n-\n\x04\x06\0\x02\t\x12\x06\
    \xb9\x01\x02\xc6\x01\x03\x1a\x1d\x20Patch\x20one\x20or\x20more\x20concep\
    ts.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\xb9\x01\x06\x13\n\r\n\x05\x06\0\
    \x02\t\x02\x12\x04\xb9\x01\x15)\n\r\n\x05\x06\0\x02\t\x03\x12\x04\xb9\
    \x014H\n\x0f\n\x05\x06\0\x02\t\x04\x12\x06\xba\x01\x04\xc1\x01\x06\n\x13\
    \n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x06\xba\x01\x04\xc1\x01\x06\n\r\n\
    \x05\x06\0\x02\t\x04\x12\x04\xc2\x01\x047\n\x10\n\x08\x06\0\x02\t\x04\
    \xc3\xf3\x04\x12\x04\xc2\x01\x047\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xc3\
    \x01\x04?\n\x11\n\t\x06\0\x02\t\x04\xc2\xf3\x04\0\x12\x04\xc3\x01\x04?\n\
    \r\n\x05\x06\0\x02\t\x04\x12\x04\xc4\x01\x04C\n\x11\n\t\x06\0\x02\t\x04\
    \xc2\xf3\x04\x01\x12\x04\xc4\x01\x04C\n\r\n\x05\x06\0\x02\t\x04\x12\x04\
    \xc5\x01\x04C\n\x11\n\t\x06\0\x02\t\x04\xc2\xf3\x04\x02\x12\x04\xc5\x01\
    \x04C\n5\n\x04\x06\0\x02\n\x12\x06\xd3\x01\x02\xdd\x01\x03\x1a%\x20Get\
    \x20a\x20specific\x20concept\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\
    \n\x01\x12\x04\xd3\x01\x06\x18\n\r\n\x05\x06\0\x02\n\x02\x12\x04\xd3\x01\
    \x1a3\n\r\n\x05\x06\0\x02\n\x03\x12\x04\xd3\x01>[\n\x0f\n\x05\x06\0\x02\
    \n\x04\x12\x06\xd4\x01\x04\xd9\x01\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\
    \xbc\"\x12\x06\xd4\x01\x04\xd9\x01\x06\n\r\n\x05\x06\0\x02\n\x04\x12\x04\
    \xda\x01\x047\n\x10\n\x08\x06\0\x02\n\x04\xc3\xf3\x04\x12\x04\xda\x01\
    \x047\n\r\n\x05\x06\0\x02\n\x04\x12\x04\xdb\x01\x04?\n\x11\n\t\x06\0\x02\
    \n\x04\xc2\xf3\x04\0\x12\x04\xdb\x01\x04?\n\r\n\x05\x06\0\x02\n\x04\x12\
    \x04\xdc\x01\x04C\n\x11\n\t\x06\0\x02\n\x04\xc2\xf3\x04\x01\x12\x04\xdc\
    \x01\x04C\nC\n\x04\x06\0\x02\x0b\x12\x06\xe0\x01\x02\xea\x01\x03\x1a3\
    \x20List\x20the\x20concept\x20in\x20all\x20the\x20translated\x20language\
    s.\n\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\xe0\x01\x06\x1a\n\r\n\x05\x06\0\
    \x02\x0b\x02\x12\x04\xe0\x01\x1c7\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\
    \xe0\x01B^\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xe1\x01\x04\xe6\x01\x06\
    \n\x13\n\t\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xe1\x01\x04\xe6\x01\
    \x06\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xe7\x01\x047\n\x10\n\x08\x06\0\
    \x02\x0b\x04\xc3\xf3\x04\x12\x04\xe7\x01\x047\n\r\n\x05\x06\0\x02\x0b\
    \x04\x12\x04\xe8\x01\x04?\n\x11\n\t\x06\0\x02\x0b\x04\xc2\xf3\x04\0\x12\
    \x04\xe8\x01\x04?\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xe9\x01\x04C\n\x11\
    \n\t\x06\0\x02\x0b\x04\xc2\xf3\x04\x01\x12\x04\xe9\x01\x04C\n9\n\x04\x06\
    \0\x02\x0c\x12\x06\xed\x01\x02\xfa\x01\x03\x1a)\x20Add\x20a\x20new\x20tr\
    anslation\x20for\x20this\x20concept.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\
    \x04\xed\x01\x06\x1a\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xed\x01\x1c7\n\
    \r\n\x05\x06\0\x02\x0c\x03\x12\x04\xed\x01B^\n\x0f\n\x05\x06\0\x02\x0c\
    \x04\x12\x06\xee\x01\x04\xf5\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\
    \xbc\"\x12\x06\xee\x01\x04\xf5\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\x12\
    \x04\xf6\x01\x047\n\x10\n\x08\x06\0\x02\x0c\x04\xc3\xf3\x04\x12\x04\xf6\
    \x01\x047\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf7\x01\x04?\n\x11\n\t\x06\
    \0\x02\x0c\x04\xc2\xf3\x04\0\x12\x04\xf7\x01\x04?\n\r\n\x05\x06\0\x02\
    \x0c\x04\x12\x04\xf8\x01\x04C\n\x11\n\t\x06\0\x02\x0c\x04\xc2\xf3\x04\
    \x01\x12\x04\xf8\x01\x04C\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xf9\x01\
    \x04C\n\x11\n\t\x06\0\x02\x0c\x04\xc2\xf3\x04\x02\x12\x04\xf9\x01\x04C\n\
    \x83\x01\n\x04\x06\0\x02\r\x12\x06\xfe\x01\x02\x8b\x02\x03\x1as\x20Patch\
    \x20the\x20name\x20for\x20a\x20given\x20language\x20names\x20by\x20passi\
    ng\x20in\x20a\x20list\x20of\x20concepts\x20with\x20the\x20new\x20names\n\
    \x20for\x20the\x20languages.\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\xfe\x01\
    \x06\x1b\n\r\n\x05\x06\0\x02\r\x02\x12\x04\xfe\x01\x1d9\n\r\n\x05\x06\0\
    \x02\r\x03\x12\x04\xfe\x01D`\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\xff\x01\
    \x04\x86\x02\x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\xff\x01\
    \x04\x86\x02\x06\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x87\x02\x047\n\x10\n\
    \x08\x06\0\x02\r\x04\xc3\xf3\x04\x12\x04\x87\x02\x047\n\r\n\x05\x06\0\
    \x02\r\x04\x12\x04\x88\x02\x04?\n\x11\n\t\x06\0\x02\r\x04\xc2\xf3\x04\0\
    \x12\x04\x88\x02\x04?\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x89\x02\x04C\n\
    \x11\n\t\x06\0\x02\r\x04\xc2\xf3\x04\x01\x12\x04\x89\x02\x04C\n\r\n\x05\
    \x06\0\x02\r\x04\x12\x04\x8a\x02\x04C\n\x11\n\t\x06\0\x02\r\x04\xc2\xf3\
    \x04\x02\x12\x04\x8a\x02\x04C\n)\n\x04\x06\0\x02\x0e\x12\x06\x91\x02\x02\
    \x9b\x02\x03\x1a\x19\x20List\x20all\x20domain\x20graphs.\n\n\r\n\x05\x06\
    \0\x02\x0e\x01\x12\x04\x91\x02\x06\x19\n\r\n\x05\x06\0\x02\x0e\x02\x12\
    \x04\x91\x02\x1b5\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\x91\x02@[\n\x0f\n\
    \x05\x06\0\x02\x0e\x04\x12\x06\x92\x02\x04\x97\x02\x06\n\x13\n\t\x06\0\
    \x02\x0e\x04\xb0\xca\xbc\"\x12\x06\x92\x02\x04\x97\x02\x06\n\r\n\x05\x06\
    \0\x02\x0e\x04\x12\x04\x98\x02\x047\n\x10\n\x08\x06\0\x02\x0e\x04\xc3\
    \xf3\x04\x12\x04\x98\x02\x047\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\x99\
    \x02\x04?\n\x11\n\t\x06\0\x02\x0e\x04\xc2\xf3\x04\0\x12\x04\x99\x02\x04?\
    \n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\x9a\x02\x04C\n\x11\n\t\x06\0\x02\
    \x0e\x04\xc2\xf3\x04\x01\x12\x04\x9a\x02\x04C\n%\n\x04\x06\0\x02\x0f\x12\
    \x06\x9e\x02\x02\xab\x02\x03\x1a\x15\x20Post\x20domain\x20graphs.\n\n\r\
    \n\x05\x06\0\x02\x0f\x01\x12\x04\x9e\x02\x06\x19\n\r\n\x05\x06\0\x02\x0f\
    \x02\x12\x04\x9e\x02\x1b5\n\r\n\x05\x06\0\x02\x0f\x03\x12\x04\x9e\x02@[\
    \n\x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\x9f\x02\x04\xa6\x02\x06\n\x13\n\t\
    \x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\x9f\x02\x04\xa6\x02\x06\n\r\n\
    \x05\x06\0\x02\x0f\x04\x12\x04\xa7\x02\x047\n\x10\n\x08\x06\0\x02\x0f\
    \x04\xc3\xf3\x04\x12\x04\xa7\x02\x047\n\r\n\x05\x06\0\x02\x0f\x04\x12\
    \x04\xa8\x02\x04?\n\x11\n\t\x06\0\x02\x0f\x04\xc2\xf3\x04\0\x12\x04\xa8\
    \x02\x04?\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\xa9\x02\x04C\n\x11\n\t\x06\
    \0\x02\x0f\x04\xc2\xf3\x04\x01\x12\x04\xa9\x02\x04C\n\r\n\x05\x06\0\x02\
    \x0f\x04\x12\x04\xaa\x02\x04C\n\x11\n\t\x06\0\x02\x0f\x04\xc2\xf3\x04\
    \x02\x12\x04\xaa\x02\x04C\n-\n\x04\x06\0\x02\x10\x12\x06\xae\x02\x02\xbb\
    \x02\x03\x1a\x1d\x20Start\x20concept\x20mapping\x20jobs.\n\n\r\n\x05\x06\
    \0\x02\x10\x01\x12\x04\xae\x02\x06\x1c\n\r\n\x05\x06\0\x02\x10\x02\x12\
    \x04\xae\x02\x1e;\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\xae\x02Fd\n\x0f\n\
    \x05\x06\0\x02\x10\x04\x12\x06\xaf\x02\x04\xb6\x02\x06\n\x13\n\t\x06\0\
    \x02\x10\x04\xb0\xca\xbc\"\x12\x06\xaf\x02\x04\xb6\x02\x06\n\r\n\x05\x06\
    \0\x02\x10\x04\x12\x04\xb7\x02\x047\n\x10\n\x08\x06\0\x02\x10\x04\xc3\
    \xf3\x04\x12\x04\xb7\x02\x047\n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xb8\
    \x02\x04?\n\x11\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\0\x12\x04\xb8\x02\x04?\
    \n\r\n\x05\x06\0\x02\x10\x04\x12\x04\xb9\x02\x04C\n\x11\n\t\x06\0\x02\
    \x10\x04\xc2\xf3\x04\x01\x12\x04\xb9\x02\x04C\n\r\n\x05\x06\0\x02\x10\
    \x04\x12\x04\xba\x02\x04C\n\x11\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\x02\
    \x12\x04\xba\x02\x04C\n8\n\x04\x06\0\x02\x11\x12\x06\xc0\x02\x02\xcc\x02\
    \x03\x1a(\x20Get\x20a\x20specific\x20annotation\x20from\x20an\x20app.\n\
    \n\r\n\x05\x06\0\x02\x11\x01\x12\x04\xc0\x02\x06\x13\n\r\n\x05\x06\0\x02\
    \x11\x02\x12\x04\xc0\x02\x15)\n\r\n\x05\x06\0\x02\x11\x03\x12\x04\xc0\
    \x024L\n\x0f\n\x05\x06\0\x02\x11\x04\x12\x06\xc1\x02\x04\xc6\x02\x06\n\
    \x13\n\t\x06\0\x02\x11\x04\xb0\xca\xbc\"\x12\x06\xc1\x02\x04\xc6\x02\x06\
    \n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc7\x02\x047\n\x10\n\x08\x06\0\x02\
    \x11\x04\xc3\xf3\x04\x12\x04\xc7\x02\x047\n\r\n\x05\x06\0\x02\x11\x04\
    \x12\x04\xc8\x02\x04?\n\x11\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\0\x12\x04\
    \xc8\x02\x04?\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xc9\x02\x04F\n\x11\n\t\
    \x06\0\x02\x11\x04\xc2\xf3\x04\x01\x12\x04\xc9\x02\x04F\n\r\n\x05\x06\0\
    \x02\x11\x04\x12\x04\xca\x02\x04C\n\x11\n\t\x06\0\x02\x11\x04\xc2\xf3\
    \x04\x02\x12\x04\xca\x02\x04C\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xcb\
    \x02\x04A\n5\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\x03\x12\x04\xcb\x02\x04A\
    \"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20worker.\n\n*\n\x04\
    \x06\0\x02\x12\x12\x06\xcf\x02\x02\xdb\x02\x03\x1a\x1a\x20List\x20all\
    \x20the\x20annotation.\n\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\xcf\x02\x06\
    \x15\n\r\n\x05\x06\0\x02\x12\x02\x12\x04\xcf\x02\x17-\n\r\n\x05\x06\0\
    \x02\x12\x03\x12\x04\xcf\x028O\n\x0f\n\x05\x06\0\x02\x12\x04\x12\x06\xd0\
    \x02\x04\xd5\x02\x06\n\x13\n\t\x06\0\x02\x12\x04\xb0\xca\xbc\"\x12\x06\
    \xd0\x02\x04\xd5\x02\x06\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xd6\x02\x04\
    7\n\x10\n\x08\x06\0\x02\x12\x04\xc3\xf3\x04\x12\x04\xd6\x02\x047\n\r\n\
    \x05\x06\0\x02\x12\x04\x12\x04\xd7\x02\x04?\n\x11\n\t\x06\0\x02\x12\x04\
    \xc2\xf3\x04\0\x12\x04\xd7\x02\x04?\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\
    \xd8\x02\x04F\n\x11\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x01\x12\x04\xd8\
    \x02\x04F\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xd9\x02\x04C\n\x11\n\t\x06\
    \0\x02\x12\x04\xc2\xf3\x04\x02\x12\x04\xd9\x02\x04C\n\r\n\x05\x06\0\x02\
    \x12\x04\x12\x04\xda\x02\x04A\n5\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x03\
    \x12\x04\xda\x02\x04A\"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20\
    worker.\n\n#\n\x04\x06\0\x02\x13\x12\x06\xde\x02\x02\xef\x02\x03\x1a\x13\
    \x20Post\x20annotations.\n\n\r\n\x05\x06\0\x02\x13\x01\x12\x04\xde\x02\
    \x06\x15\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\xde\x02\x17-\n\r\n\x05\x06\
    \0\x02\x13\x03\x12\x04\xde\x028O\n\x0f\n\x05\x06\0\x02\x13\x04\x12\x06\
    \xdf\x02\x04\xe6\x02\x06\n\x13\n\t\x06\0\x02\x13\x04\xb0\xca\xbc\"\x12\
    \x06\xdf\x02\x04\xe6\x02\x06\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xe7\x02\
    \x047\n\x10\n\x08\x06\0\x02\x13\x04\xc3\xf3\x04\x12\x04\xe7\x02\x047\n\r\
    \n\x05\x06\0\x02\x13\x04\x12\x04\xe8\x02\x04?\n\x11\n\t\x06\0\x02\x13\
    \x04\xc2\xf3\x04\0\x12\x04\xe8\x02\x04?\n\r\n\x05\x06\0\x02\x13\x04\x12\
    \x04\xe9\x02\x04A\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x01\x12\x04\
    \xe9\x02\x04A\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xea\x02\x04F\n\x11\n\t\
    \x06\0\x02\x13\x04\xc2\xf3\x04\x02\x12\x04\xea\x02\x04F\n\r\n\x05\x06\0\
    \x02\x13\x04\x12\x04\xeb\x02\x04F\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\
    \x04\x03\x12\x04\xeb\x02\x04F\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xec\
    \x02\x04C\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x04\x12\x04\xec\x02\
    \x04C\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xed\x02\x04A\n\x11\n\t\x06\0\
    \x02\x13\x04\xc2\xf3\x04\x05\x12\x04\xed\x02\x04A\n\r\n\x05\x06\0\x02\
    \x13\x04\x12\x04\xee\x02\x04D\nA\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x06\
    \x12\x04\xee\x02\x04D\".\x20to\x20know\x20the\x20models\x20in\x20your\
    \x20default\x20workflow.\n\n0\n\x04\x06\0\x02\x14\x12\x06\xf2\x02\x02\
    \x83\x03\x03\x1a\x20\x20Patch\x20one\x20or\x20more\x20annotations.\n\n\r\
    \n\x05\x06\0\x02\x14\x01\x12\x04\xf2\x02\x06\x16\n\r\n\x05\x06\0\x02\x14\
    \x02\x12\x04\xf2\x02\x18/\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\xf2\x02:Q\
    \n\x0f\n\x05\x06\0\x02\x14\x04\x12\x06\xf3\x02\x04\xfa\x02\x06\n\x13\n\t\
    \x06\0\x02\x14\x04\xb0\xca\xbc\"\x12\x06\xf3\x02\x04\xfa\x02\x06\n\r\n\
    \x05\x06\0\x02\x14\x04\x12\x04\xfb\x02\x047\n\x10\n\x08\x06\0\x02\x14\
    \x04\xc3\xf3\x04\x12\x04\xfb\x02\x047\n\r\n\x05\x06\0\x02\x14\x04\x12\
    \x04\xfc\x02\x04?\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\0\x12\x04\xfc\
    \x02\x04?\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xfd\x02\x04A\n\x11\n\t\x06\
    \0\x02\x14\x04\xc2\xf3\x04\x01\x12\x04\xfd\x02\x04A\n\r\n\x05\x06\0\x02\
    \x14\x04\x12\x04\xfe\x02\x04F\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\
    \x02\x12\x04\xfe\x02\x04F\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xff\x02\
    \x04F\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\x03\x12\x04\xff\x02\x04F\n\
    \r\n\x05\x06\0\x02\x14\x04\x12\x04\x80\x03\x04C\n\x11\n\t\x06\0\x02\x14\
    \x04\xc2\xf3\x04\x04\x12\x04\x80\x03\x04C\n\r\n\x05\x06\0\x02\x14\x04\
    \x12\x04\x81\x03\x04D\nA\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\x05\x12\x04\
    \x81\x03\x04D\".\x20to\x20know\x20the\x20models\x20in\x20your\x20default\
    \x20workflow.\n\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\x82\x03\x04A\n5\n\t\
    \x06\0\x02\x14\x04\xc2\xf3\x04\x06\x12\x04\x82\x03\x04A\"\"\x20to\x20get\
    \x20the\x20model\x20for\x20the\x20worker.\n\n\x92\x02\n\x04\x06\0\x02\
    \x15\x12\x06\x89\x03\x02\x95\x03\x03\x1a\x81\x02\x20Patch\x20annotations\
    \x20status\x20by\x20worker\x20id\x20and\x20task\x20id.\n\x20Deprecated:\
    \x20Use\x20PutTaskAssignments\x20to\x20update\x20task\x20annotations.\n\
    \x20\x20\x20For\x20example,\x20you\x20can\x20use\x20PutTaskAssignments\
    \x20with\x20action\x20REVIEW_APPROVE\n\x20\x20\x20to\x20approve\x20task\
    \x20assignments\x20and\x20associated\x20annotations\x20in\x20bulk.\n\n\r\
    \n\x05\x06\0\x02\x15\x01\x12\x04\x89\x03\x06\x1c\n\r\n\x05\x06\0\x02\x15\
    \x02\x12\x04\x89\x03\x1e;\n\r\n\x05\x06\0\x02\x15\x03\x12\x04\x89\x03Fd\
    \n\x0f\n\x05\x06\0\x02\x15\x04\x12\x06\x8a\x03\x04\x8d\x03\x06\n\x13\n\t\
    \x06\0\x02\x15\x04\xb0\xca\xbc\"\x12\x06\x8a\x03\x04\x8d\x03\x06\n\r\n\
    \x05\x06\0\x02\x15\x04\x12\x04\x8e\x03\x047\n\x10\n\x08\x06\0\x02\x15\
    \x04\xc3\xf3\x04\x12\x04\x8e\x03\x047\n\r\n\x05\x06\0\x02\x15\x04\x12\
    \x04\x8f\x03\x04?\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\0\x12\x04\x8f\
    \x03\x04?\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x90\x03\x04F\n\x11\n\t\x06\
    \0\x02\x15\x04\xc2\xf3\x04\x01\x12\x04\x90\x03\x04F\n\r\n\x05\x06\0\x02\
    \x15\x04\x12\x04\x91\x03\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\
    \x02\x12\x04\x91\x03\x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\x92\x03\
    \x04C\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x03\x12\x04\x92\x03\x04C\n\
    \r\n\x05\x06\0\x02\x15\x04\x12\x04\x93\x03\x04D\n\x11\n\t\x06\0\x02\x15\
    \x04\xc2\xf3\x04\x04\x12\x04\x93\x03\x04D\n\r\n\x05\x06\0\x02\x15\x04\
    \x12\x04\x94\x03\x04A\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x05\x12\
    \x04\x94\x03\x04A\n-\n\x04\x06\0\x02\x16\x12\x06\x98\x03\x02\xa6\x03\x03\
    \x1a\x1d\x20Delete\x20a\x20single\x20annotation.\n\n\r\n\x05\x06\0\x02\
    \x16\x01\x12\x04\x98\x03\x06\x16\n\r\n\x05\x06\0\x02\x16\x02\x12\x04\x98\
    \x03\x18/\n\r\n\x05\x06\0\x02\x16\x03\x12\x04\x98\x03:Z\n\x0f\n\x05\x06\
    \0\x02\x16\x04\x12\x06\x99\x03\x04\x9e\x03\x06\n\x13\n\t\x06\0\x02\x16\
    \x04\xb0\xca\xbc\"\x12\x06\x99\x03\x04\x9e\x03\x06\n\r\n\x05\x06\0\x02\
    \x16\x04\x12\x04\x9f\x03\x047\n\x10\n\x08\x06\0\x02\x16\x04\xc3\xf3\x04\
    \x12\x04\x9f\x03\x047\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\xa0\x03\x04?\n\
    \x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\0\x12\x04\xa0\x03\x04?\n\r\n\x05\
    \x06\0\x02\x16\x04\x12\x04\xa1\x03\x04F\n\x11\n\t\x06\0\x02\x16\x04\xc2\
    \xf3\x04\x01\x12\x04\xa1\x03\x04F\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\
    \xa2\x03\x04I\n\x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x02\x12\x04\xa2\
    \x03\x04I\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\xa3\x03\x04F\n\x11\n\t\x06\
    \0\x02\x16\x04\xc2\xf3\x04\x03\x12\x04\xa3\x03\x04F\n\r\n\x05\x06\0\x02\
    \x16\x04\x12\x04\xa4\x03\x04D\n\\\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x04\
    \x12\x04\xa4\x03\x04D\"I\x20for\x20cleaning\x20up\x20some\x20optimizatio\
    ns\x20we\x20have\x20in\x20DB\x20layer\x20for\x20annotations.\n\n\r\n\x05\
    \x06\0\x02\x16\x04\x12\x04\xa5\x03\x04A\n\x11\n\t\x06\0\x02\x16\x04\xc2\
    \xf3\x04\x05\x12\x04\xa5\x03\x04A\n=\n\x04\x06\0\x02\x17\x12\x06\xa9\x03\
    \x02\xc1\x03\x03\x1a-\x20Delete\x20multiple\x20annotations\x20in\x20one\
    \x20request.\n\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\xa9\x03\x06\x17\n\r\n\
    \x05\x06\0\x02\x17\x02\x12\x04\xa9\x03\x191\n\r\n\x05\x06\0\x02\x17\x03\
    \x12\x04\xa9\x03<\\\n\x0f\n\x05\x06\0\x02\x17\x04\x12\x06\xaa\x03\x04\
    \xb9\x03\x06\n\x13\n\t\x06\0\x02\x17\x04\xb0\xca\xbc\"\x12\x06\xaa\x03\
    \x04\xb9\x03\x06\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xba\x03\x047\n\x10\
    \n\x08\x06\0\x02\x17\x04\xc3\xf3\x04\x12\x04\xba\x03\x047\n\r\n\x05\x06\
    \0\x02\x17\x04\x12\x04\xbb\x03\x04?\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\
    \x04\0\x12\x04\xbb\x03\x04?\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xbc\x03\
    \x04F\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x01\x12\x04\xbc\x03\x04F\n\
    \r\n\x05\x06\0\x02\x17\x04\x12\x04\xbd\x03\x04I\n\x11\n\t\x06\0\x02\x17\
    \x04\xc2\xf3\x04\x02\x12\x04\xbd\x03\x04I\n\r\n\x05\x06\0\x02\x17\x04\
    \x12\x04\xbe\x03\x04F\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x03\x12\
    \x04\xbe\x03\x04F\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xbf\x03\x04D\n\\\n\
    \t\x06\0\x02\x17\x04\xc2\xf3\x04\x04\x12\x04\xbf\x03\x04D\"I\x20for\x20c\
    leaning\x20up\x20some\x20optimizations\x20we\x20have\x20in\x20DB\x20laye\
    r\x20for\x20annotations.\n\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\xc0\x03\
    \x04A\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x05\x12\x04\xc0\x03\x04A\n\
    :\n\x04\x06\0\x02\x18\x12\x06\xc4\x03\x02\xd1\x03\x03\x1a*\x20Patch\x20s\
    aved\x20annotations\x20searches\x20by\x20ids.\n\n\r\n\x05\x06\0\x02\x18\
    \x01\x12\x04\xc4\x03\x06\x1e\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\xc4\x03\
    \x20?\n\r\n\x05\x06\0\x02\x18\x03\x12\x04\xc4\x03J]\n\x0f\n\x05\x06\0\
    \x02\x18\x04\x12\x06\xc5\x03\x04\xcc\x03\x06\n\x13\n\t\x06\0\x02\x18\x04\
    \xb0\xca\xbc\"\x12\x06\xc5\x03\x04\xcc\x03\x06\n\r\n\x05\x06\0\x02\x18\
    \x04\x12\x04\xcd\x03\x047\n\x10\n\x08\x06\0\x02\x18\x04\xc3\xf3\x04\x12\
    \x04\xcd\x03\x047\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xce\x03\x04?\n\x11\
    \n\t\x06\0\x02\x18\x04\xc2\xf3\x04\0\x12\x04\xce\x03\x04?\n\r\n\x05\x06\
    \0\x02\x18\x04\x12\x04\xcf\x03\x04F\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\
    \x04\x01\x12\x04\xcf\x03\x04F\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xd0\
    \x03\x04F\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\x04\x02\x12\x04\xd0\x03\
    \x04F\n3\n\x04\x06\0\x02\x19\x12\x06\xd4\x03\x02\xe5\x03\x03\x1a#\x20Exe\
    cute\x20a\x20search\x20over\x20annotations\n\n\r\n\x05\x06\0\x02\x19\x01\
    \x12\x04\xd4\x03\x06\x1d\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xd4\x03\x1e\
    <\n\r\n\x05\x06\0\x02\x19\x03\x12\x04\xd4\x03GZ\n\x0f\n\x05\x06\0\x02\
    \x19\x04\x12\x06\xd5\x03\x04\xdc\x03\x06\n\x13\n\t\x06\0\x02\x19\x04\xb0\
    \xca\xbc\"\x12\x06\xd5\x03\x04\xdc\x03\x06\n\r\n\x05\x06\0\x02\x19\x04\
    \x12\x04\xdd\x03\x047\n\x10\n\x08\x06\0\x02\x19\x04\xc3\xf3\x04\x12\x04\
    \xdd\x03\x047\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xde\x03\x04?\n\x11\n\t\
    \x06\0\x02\x19\x04\xc2\xf3\x04\0\x12\x04\xde\x03\x04?\n\r\n\x05\x06\0\
    \x02\x19\x04\x12\x04\xdf\x03\x04F\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\
    \x04\x01\x12\x04\xdf\x03\x04F\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xe0\
    \x03\x04C\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x02\x12\x04\xe0\x03\
    \x04C\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xe1\x03\x04A\n\x11\n\t\x06\0\
    \x02\x19\x04\xc2\xf3\x04\x03\x12\x04\xe1\x03\x04A\n\r\n\x05\x06\0\x02\
    \x19\x04\x12\x04\xe2\x03\x04A\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\
    \x04\x12\x04\xe2\x03\x04A\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xe3\x03\
    \x04=\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x05\x12\x04\xe3\x03\x04=\n\
    \r\n\x05\x06\0\x02\x19\x04\x12\x04\xe4\x03\x04D\nN\n\t\x06\0\x02\x19\x04\
    \xc2\xf3\x04\x06\x12\x04\xe4\x03\x04D\";\x20to\x20know\x20the\x20concept\
    s\x20and\x20models\x20in\x20your\x20default\x20workflow.\n\n\x9e\x01\n\
    \x04\x06\0\x02\x1a\x12\x06\xe9\x03\x02\xf6\x03\x03\x1a\x8d\x01\x20ListAn\
    notationWorkers\x20lists\x20users,\x20models,\x20and\x20workflows\x20(co\
    llectively\n\x20known\x20as\x20\"workers\")\x20that\x20have\x20added\x20\
    annotations\x20to\x20the\x20application.\n\n\r\n\x05\x06\0\x02\x1a\x01\
    \x12\x04\xe9\x03\x06\x1b\n\r\n\x05\x06\0\x02\x1a\x02\x12\x04\xe9\x03\x1d\
    9\n\r\n\x05\x06\0\x02\x1a\x03\x12\x04\xe9\x03DW\n\x0f\n\x05\x06\0\x02\
    \x1a\x04\x12\x06\xea\x03\x04\xef\x03\x06\n\x13\n\t\x06\0\x02\x1a\x04\xb0\
    \xca\xbc\"\x12\x06\xea\x03\x04\xef\x03\x06\n\r\n\x05\x06\0\x02\x1a\x04\
    \x12\x04\xf0\x03\x047\n\x10\n\x08\x06\0\x02\x1a\x04\xc3\xf3\x04\x12\x04\
    \xf0\x03\x047\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xf1\x03\x04?\n\x11\n\t\
    \x06\0\x02\x1a\x04\xc2\xf3\x04\0\x12\x04\xf1\x03\x04?\n\r\n\x05\x06\0\
    \x02\x1a\x04\x12\x04\xf2\x03\x04F\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\
    \x04\x01\x12\x04\xf2\x03\x04F\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xf3\
    \x03\x04H\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\x02\x12\x04\xf3\x03\
    \x04H\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xf4\x03\x04A\n\x11\n\t\x06\0\
    \x02\x1a\x04\xc2\xf3\x04\x03\x12\x04\xf4\x03\x04A\n\r\n\x05\x06\0\x02\
    \x1a\x04\x12\x04\xf5\x03\x04D\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\
    \x04\x12\x04\xf5\x03\x04D\n-\n\x04\x06\0\x02\x1b\x12\x06\xf9\x03\x02\x85\
    \x04\x03\x1a\x1d\x20Get\x20input\x20count\x20per\x20status.\n\n\r\n\x05\
    \x06\0\x02\x1b\x01\x12\x04\xf9\x03\x06\x13\n\r\n\x05\x06\0\x02\x1b\x02\
    \x12\x04\xf9\x03\x15)\n\r\n\x05\x06\0\x02\x1b\x03\x12\x04\xf9\x034L\n\
    \x0f\n\x05\x06\0\x02\x1b\x04\x12\x06\xfa\x03\x04\xff\x03\x06\n\x13\n\t\
    \x06\0\x02\x1b\x04\xb0\xca\xbc\"\x12\x06\xfa\x03\x04\xff\x03\x06\n\r\n\
    \x05\x06\0\x02\x1b\x04\x12\x04\x80\x04\x047\n\x10\n\x08\x06\0\x02\x1b\
    \x04\xc3\xf3\x04\x12\x04\x80\x04\x047\n\r\n\x05\x06\0\x02\x1b\x04\x12\
    \x04\x81\x04\x04?\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\0\x12\x04\x81\
    \x04\x04?\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\x82\x04\x04F\n\x11\n\t\x06\
    \0\x02\x1b\x04\xc2\xf3\x04\x01\x12\x04\x82\x04\x04F\n\r\n\x05\x06\0\x02\
    \x1b\x04\x12\x04\x83\x04\x04C\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\
    \x02\x12\x04\x83\x04\x04C\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\x84\x04\
    \x04A\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\x03\x12\x04\x84\x04\x04A\n\
    E\n\x04\x06\0\x02\x1c\x12\x06\x88\x04\x02\x94\x04\x03\x1a5\x20Streams\
    \x20all\x20the\x20inputs\x20starting\x20from\x20oldest\x20assets.\n\n\r\
    \n\x05\x06\0\x02\x1c\x01\x12\x04\x88\x04\x06\x12\n\r\n\x05\x06\0\x02\x1c\
    \x02\x12\x04\x88\x04\x14'\n\r\n\x05\x06\0\x02\x1c\x03\x12\x04\x88\x042D\
    \n\x0f\n\x05\x06\0\x02\x1c\x04\x12\x06\x89\x04\x04\x8e\x04\x06\n\x13\n\t\
    \x06\0\x02\x1c\x04\xb0\xca\xbc\"\x12\x06\x89\x04\x04\x8e\x04\x06\n\r\n\
    \x05\x06\0\x02\x1c\x04\x12\x04\x8f\x04\x047\n\x10\n\x08\x06\0\x02\x1c\
    \x04\xc3\xf3\x04\x12\x04\x8f\x04\x047\n\r\n\x05\x06\0\x02\x1c\x04\x12\
    \x04\x90\x04\x04?\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\0\x12\x04\x90\
    \x04\x04?\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x91\x04\x04F\n\x11\n\t\x06\
    \0\x02\x1c\x04\xc2\xf3\x04\x01\x12\x04\x91\x04\x04F\n\r\n\x05\x06\0\x02\
    \x1c\x04\x12\x04\x92\x04\x04C\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\
    \x02\x12\x04\x92\x04\x04C\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\x93\x04\
    \x04A\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\x03\x12\x04\x93\x04\x04A\n\
    3\n\x04\x06\0\x02\x1d\x12\x06\x97\x04\x02\xa3\x04\x03\x1a#\x20Get\x20a\
    \x20specific\x20input\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\x1d\
    \x01\x12\x04\x97\x04\x06\x15\n\r\n\x05\x06\0\x02\x1d\x02\x12\x04\x97\x04\
    \x17-\n\r\n\x05\x06\0\x02\x1d\x03\x12\x04\x97\x048T\n\x0f\n\x05\x06\0\
    \x02\x1d\x04\x12\x06\x98\x04\x04\x9d\x04\x06\n\x13\n\t\x06\0\x02\x1d\x04\
    \xb0\xca\xbc\"\x12\x06\x98\x04\x04\x9d\x04\x06\n\r\n\x05\x06\0\x02\x1d\
    \x04\x12\x04\x9e\x04\x047\n\x10\n\x08\x06\0\x02\x1d\x04\xc3\xf3\x04\x12\
    \x04\x9e\x04\x047\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\x9f\x04\x04?\n\x11\
    \n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\0\x12\x04\x9f\x04\x04?\n\r\n\x05\x06\
    \0\x02\x1d\x04\x12\x04\xa0\x04\x04F\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\
    \x04\x01\x12\x04\xa0\x04\x04F\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\xa1\
    \x04\x04C\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\x02\x12\x04\xa1\x04\
    \x04C\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\xa2\x04\x04A\n\x11\n\t\x06\0\
    \x02\x1d\x04\xc2\xf3\x04\x03\x12\x04\xa2\x04\x04A\n3\n\x04\x06\0\x02\x1e\
    \x12\x06\xa6\x04\x02\xb2\x04\x03\x1a#\x20Get\x20a\x20specific\x20input\
    \x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\x1e\x01\x12\x04\xa6\x04\x06\
    \x0e\n\r\n\x05\x06\0\x02\x1e\x02\x12\x04\xa6\x04\x10\x1f\n\r\n\x05\x06\0\
    \x02\x1e\x03\x12\x04\xa6\x04*=\n\x0f\n\x05\x06\0\x02\x1e\x04\x12\x06\xa7\
    \x04\x04\xac\x04\x06\n\x13\n\t\x06\0\x02\x1e\x04\xb0\xca\xbc\"\x12\x06\
    \xa7\x04\x04\xac\x04\x06\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\xad\x04\x04\
    7\n\x10\n\x08\x06\0\x02\x1e\x04\xc3\xf3\x04\x12\x04\xad\x04\x047\n\r\n\
    \x05\x06\0\x02\x1e\x04\x12\x04\xae\x04\x04?\n\x11\n\t\x06\0\x02\x1e\x04\
    \xc2\xf3\x04\0\x12\x04\xae\x04\x04?\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\
    \xaf\x04\x04F\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x01\x12\x04\xaf\
    \x04\x04F\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\xb0\x04\x04C\n\x11\n\t\x06\
    \0\x02\x1e\x04\xc2\xf3\x04\x02\x12\x04\xb0\x04\x04C\n\r\n\x05\x06\0\x02\
    \x1e\x04\x12\x04\xb1\x04\x04A\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\
    \x03\x12\x04\xb1\x04\x04A\n-\n\x04\x06\0\x02\x1f\x12\x06\xb5\x04\x02\xbf\
    \x04\x03\x1a\x1d\x20Get\x20a\x20video\x20input\x20manifest.\n\n\r\n\x05\
    \x06\0\x02\x1f\x01\x12\x04\xb5\x04\x06\x1b\n\r\n\x05\x06\0\x02\x1f\x02\
    \x12\x04\xb5\x04\x1d4\n\r\n\x05\x06\0\x02\x1f\x03\x12\x04\xb5\x04?W\n\
    \x0f\n\x05\x06\0\x02\x1f\x04\x12\x06\xb6\x04\x04\xbb\x04\x06\n\x13\n\t\
    \x06\0\x02\x1f\x04\xb0\xca\xbc\"\x12\x06\xb6\x04\x04\xbb\x04\x06\n\r\n\
    \x05\x06\0\x02\x1f\x04\x12\x04\xbc\x04\x047\n\x10\n\x08\x06\0\x02\x1f\
    \x04\xc3\xf3\x04\x12\x04\xbc\x04\x047\n\r\n\x05\x06\0\x02\x1f\x04\x12\
    \x04\xbd\x04\x04?\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\0\x12\x04\xbd\
    \x04\x04?\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\xbe\x04\x04A\n\x11\n\t\x06\
    \0\x02\x1f\x04\xc2\xf3\x04\x01\x12\x04\xbe\x04\x04A\n&\n\x04\x06\0\x02\
    \x20\x12\x06\xc2\x04\x02\xce\x04\x03\x1a\x16\x20List\x20all\x20the\x20in\
    puts.\n\n\r\n\x05\x06\0\x02\x20\x01\x12\x04\xc2\x04\x06\x10\n\r\n\x05\
    \x06\0\x02\x20\x02\x12\x04\xc2\x04\x12#\n\r\n\x05\x06\0\x02\x20\x03\x12\
    \x04\xc2\x04.@\n\x0f\n\x05\x06\0\x02\x20\x04\x12\x06\xc3\x04\x04\xc8\x04\
    \x06\n\x13\n\t\x06\0\x02\x20\x04\xb0\xca\xbc\"\x12\x06\xc3\x04\x04\xc8\
    \x04\x06\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xc9\x04\x047\n\x10\n\x08\
    \x06\0\x02\x20\x04\xc3\xf3\x04\x12\x04\xc9\x04\x047\n\r\n\x05\x06\0\x02\
    \x20\x04\x12\x04\xca\x04\x04?\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\0\
    \x12\x04\xca\x04\x04?\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xcb\x04\x04F\n\
    \x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x01\x12\x04\xcb\x04\x04F\n\r\n\
    \x05\x06\0\x02\x20\x04\x12\x04\xcc\x04\x04C\n\x11\n\t\x06\0\x02\x20\x04\
    \xc2\xf3\x04\x02\x12\x04\xcc\x04\x04C\n\r\n\x05\x06\0\x02\x20\x04\x12\
    \x04\xcd\x04\x04A\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x03\x12\x04\
    \xcd\x04\x04A\n_\n\x04\x06\0\x02!\x12\x06\xd2\x04\x02\xe5\x04\x03\x1aO\
    \x20Add\x201\x20or\x20more\x20input\x20to\x20an\x20app.\n\x20The\x20actu\
    al\x20inputs\x20processing\x20is\x20asynchronous.\n\n\r\n\x05\x06\0\x02!\
    \x01\x12\x04\xd2\x04\x06\x10\n\r\n\x05\x06\0\x02!\x02\x12\x04\xd2\x04\
    \x12#\n\r\n\x05\x06\0\x02!\x03\x12\x04\xd2\x04.@\n\x0f\n\x05\x06\0\x02!\
    \x04\x12\x06\xd3\x04\x04\xda\x04\x06\n\x13\n\t\x06\0\x02!\x04\xb0\xca\
    \xbc\"\x12\x06\xd3\x04\x04\xda\x04\x06\n\r\n\x05\x06\0\x02!\x04\x12\x04\
    \xdb\x04\x047\n\x10\n\x08\x06\0\x02!\x04\xc3\xf3\x04\x12\x04\xdb\x04\x04\
    7\n\r\n\x05\x06\0\x02!\x04\x12\x04\xdc\x04\x04?\n\x11\n\t\x06\0\x02!\x04\
    \xc2\xf3\x04\0\x12\x04\xdc\x04\x04?\n\r\n\x05\x06\0\x02!\x04\x12\x04\xdd\
    \x04\x04F\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x01\x12\x04\xdd\x04\x04F\
    \n\r\n\x05\x06\0\x02!\x04\x12\x04\xde\x04\x04F\n\x11\n\t\x06\0\x02!\x04\
    \xc2\xf3\x04\x02\x12\x04\xde\x04\x04F\n\r\n\x05\x06\0\x02!\x04\x12\x04\
    \xdf\x04\x04C\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x03\x12\x04\xdf\x04\
    \x04C\n\r\n\x05\x06\0\x02!\x04\x12\x04\xe0\x04\x04A\n\x11\n\t\x06\0\x02!\
    \x04\xc2\xf3\x04\x04\x12\x04\xe0\x04\x04A\n\r\n\x05\x06\0\x02!\x04\x12\
    \x04\xe1\x04\x04A\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x05\x12\x04\xe1\
    \x04\x04A\n\r\n\x05\x06\0\x02!\x04\x12\x04\xe2\x04\x04A\n\x11\n\t\x06\0\
    \x02!\x04\xc2\xf3\x04\x06\x12\x04\xe2\x04\x04A\n\r\n\x05\x06\0\x02!\x04\
    \x12\x04\xe3\x04\x04>\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x07\x12\x04\
    \xe3\x04\x04>\n\r\n\x05\x06\0\x02!\x04\x12\x04\xe4\x04\x04D\n\x11\n\t\
    \x06\0\x02!\x04\xc2\xf3\x04\x08\x12\x04\xe4\x04\x04D\n+\n\x04\x06\0\x02\
    \"\x12\x06\xea\x04\x02\xfb\x04\x03\x1a\x1b\x20Patch\x20one\x20or\x20more\
    \x20inputs.\n\n\r\n\x05\x06\0\x02\"\x01\x12\x04\xea\x04\x06\x11\n\r\n\
    \x05\x06\0\x02\"\x02\x12\x04\xea\x04\x13%\n\r\n\x05\x06\0\x02\"\x03\x12\
    \x04\xea\x040B\n\x0f\n\x05\x06\0\x02\"\x04\x12\x06\xeb\x04\x04\xf2\x04\
    \x06\n\x13\n\t\x06\0\x02\"\x04\xb0\xca\xbc\"\x12\x06\xeb\x04\x04\xf2\x04\
    \x06\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf3\x04\x047\n\x10\n\x08\x06\0\
    \x02\"\x04\xc3\xf3\x04\x12\x04\xf3\x04\x047\n\r\n\x05\x06\0\x02\"\x04\
    \x12\x04\xf4\x04\x04?\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\0\x12\x04\
    \xf4\x04\x04?\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf5\x04\x04F\n\x11\n\t\
    \x06\0\x02\"\x04\xc2\xf3\x04\x01\x12\x04\xf5\x04\x04F\n\r\n\x05\x06\0\
    \x02\"\x04\x12\x04\xf6\x04\x04F\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\
    \x02\x12\x04\xf6\x04\x04F\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf7\x04\x04C\
    \n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\x03\x12\x04\xf7\x04\x04C\n\r\n\
    \x05\x06\0\x02\"\x04\x12\x04\xf8\x04\x04A\n\x11\n\t\x06\0\x02\"\x04\xc2\
    \xf3\x04\x04\x12\x04\xf8\x04\x04A\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xf9\
    \x04\x04A\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\x05\x12\x04\xf9\x04\x04A\
    \n\r\n\x05\x06\0\x02\"\x04\x12\x04\xfa\x04\x04A\n\x11\n\t\x06\0\x02\"\
    \x04\xc2\xf3\x04\x06\x12\x04\xfa\x04\x04A\n7\n\x04\x06\0\x02#\x12\x06\
    \xfe\x04\x02\x8f\x05\x03\x1a'\x20Delete\x20a\x20single\x20input\x20async\
    hronously.\n\n\r\n\x05\x06\0\x02#\x01\x12\x04\xfe\x04\x06\x11\n\r\n\x05\
    \x06\0\x02#\x02\x12\x04\xfe\x04\x13%\n\r\n\x05\x06\0\x02#\x03\x12\x04\
    \xfe\x040P\n\x0f\n\x05\x06\0\x02#\x04\x12\x06\xff\x04\x04\x84\x05\x06\n\
    \x13\n\t\x06\0\x02#\x04\xb0\xca\xbc\"\x12\x06\xff\x04\x04\x84\x05\x06\n\
    \r\n\x05\x06\0\x02#\x04\x12\x04\x85\x05\x047\n\x10\n\x08\x06\0\x02#\x04\
    \xc3\xf3\x04\x12\x04\x85\x05\x047\n\r\n\x05\x06\0\x02#\x04\x12\x04\x86\
    \x05\x04?\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\0\x12\x04\x86\x05\x04?\n\
    \r\n\x05\x06\0\x02#\x04\x12\x04\x87\x05\x04F\n\x11\n\t\x06\0\x02#\x04\
    \xc2\xf3\x04\x01\x12\x04\x87\x05\x04F\n\r\n\x05\x06\0\x02#\x04\x12\x04\
    \x88\x05\x04I\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x02\x12\x04\x88\x05\
    \x04I\n\r\n\x05\x06\0\x02#\x04\x12\x04\x89\x05\x04F\n\x11\n\t\x06\0\x02#\
    \x04\xc2\xf3\x04\x03\x12\x04\x89\x05\x04F\n\r\n\x05\x06\0\x02#\x04\x12\
    \x04\x8a\x05\x04A\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x04\x12\x04\x8a\
    \x05\x04A\n\r\n\x05\x06\0\x02#\x04\x12\x04\x8b\x05\x04D\n\x11\n\t\x06\0\
    \x02#\x04\xc2\xf3\x04\x05\x12\x04\x8b\x05\x04D\n\r\n\x05\x06\0\x02#\x04\
    \x12\x04\x8c\x05\x04A\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x06\x12\x04\
    \x8c\x05\x04A\n\r\n\x05\x06\0\x02#\x04\x12\x04\x8d\x05\x04A\n\x11\n\t\
    \x06\0\x02#\x04\xc2\xf3\x04\x07\x12\x04\x8d\x05\x04A\n\r\n\x05\x06\0\x02\
    #\x04\x12\x04\x8e\x05\x04D\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x08\x12\
    \x04\x8e\x05\x04D\nT\n\x04\x06\0\x02$\x12\x06\x93\x05\x02\xa6\x05\x03\
    \x1aD\x20Delete\x20multiple\x20inputs\x20in\x20one\x20request.\n\x20This\
    \x20call\x20is\x20asynchronous.\n\n\r\n\x05\x06\0\x02$\x01\x12\x04\x93\
    \x05\x06\x12\n\r\n\x05\x06\0\x02$\x02\x12\x04\x93\x05\x14'\n\r\n\x05\x06\
    \0\x02$\x03\x12\x04\x93\x052R\n\x0f\n\x05\x06\0\x02$\x04\x12\x06\x94\x05\
    \x04\x9b\x05\x06\n\x13\n\t\x06\0\x02$\x04\xb0\xca\xbc\"\x12\x06\x94\x05\
    \x04\x9b\x05\x06\n\r\n\x05\x06\0\x02$\x04\x12\x04\x9c\x05\x047\n\x10\n\
    \x08\x06\0\x02$\x04\xc3\xf3\x04\x12\x04\x9c\x05\x047\n\r\n\x05\x06\0\x02\
    $\x04\x12\x04\x9d\x05\x04?\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\0\x12\
    \x04\x9d\x05\x04?\n\r\n\x05\x06\0\x02$\x04\x12\x04\x9e\x05\x04F\n\x11\n\
    \t\x06\0\x02$\x04\xc2\xf3\x04\x01\x12\x04\x9e\x05\x04F\n\r\n\x05\x06\0\
    \x02$\x04\x12\x04\x9f\x05\x04I\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x02\
    \x12\x04\x9f\x05\x04I\n\r\n\x05\x06\0\x02$\x04\x12\x04\xa0\x05\x04F\n\
    \x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x03\x12\x04\xa0\x05\x04F\n\r\n\x05\
    \x06\0\x02$\x04\x12\x04\xa1\x05\x04A\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\
    \x04\x04\x12\x04\xa1\x05\x04A\n\r\n\x05\x06\0\x02$\x04\x12\x04\xa2\x05\
    \x04D\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x05\x12\x04\xa2\x05\x04D\n\r\
    \n\x05\x06\0\x02$\x04\x12\x04\xa3\x05\x04A\n\x11\n\t\x06\0\x02$\x04\xc2\
    \xf3\x04\x06\x12\x04\xa3\x05\x04A\n\r\n\x05\x06\0\x02$\x04\x12\x04\xa4\
    \x05\x04A\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x07\x12\x04\xa4\x05\x04A\
    \n\r\n\x05\x06\0\x02$\x04\x12\x04\xa5\x05\x04D\n\x11\n\t\x06\0\x02$\x04\
    \xc2\xf3\x04\x08\x12\x04\xa5\x05\x04D\n5\n\x04\x06\0\x02%\x12\x06\xa9\
    \x05\x02\xb6\x05\x03\x1a%\x20Patch\x20saved\x20inputs\x20searches\x20by\
    \x20ids.\n\n\r\n\x05\x06\0\x02%\x01\x12\x04\xa9\x05\x06\x19\n\r\n\x05\
    \x06\0\x02%\x02\x12\x04\xa9\x05\x1b5\n\r\n\x05\x06\0\x02%\x03\x12\x04\
    \xa9\x05@S\n\x0f\n\x05\x06\0\x02%\x04\x12\x06\xaa\x05\x04\xb1\x05\x06\n\
    \x13\n\t\x06\0\x02%\x04\xb0\xca\xbc\"\x12\x06\xaa\x05\x04\xb1\x05\x06\n\
    \r\n\x05\x06\0\x02%\x04\x12\x04\xb2\x05\x047\n\x10\n\x08\x06\0\x02%\x04\
    \xc3\xf3\x04\x12\x04\xb2\x05\x047\n\r\n\x05\x06\0\x02%\x04\x12\x04\xb3\
    \x05\x04?\n\x11\n\t\x06\0\x02%\x04\xc2\xf3\x04\0\x12\x04\xb3\x05\x04?\n\
    \r\n\x05\x06\0\x02%\x04\x12\x04\xb4\x05\x04F\n\x11\n\t\x06\0\x02%\x04\
    \xc2\xf3\x04\x01\x12\x04\xb4\x05\x04F\n\r\n\x05\x06\0\x02%\x04\x12\x04\
    \xb5\x05\x04F\n\x11\n\t\x06\0\x02%\x04\xc2\xf3\x04\x02\x12\x04\xb5\x05\
    \x04F\n.\n\x04\x06\0\x02&\x12\x06\xb9\x05\x02\xca\x05\x03\x1a\x1e\x20Exe\
    cute\x20a\x20search\x20over\x20inputs\n\n\r\n\x05\x06\0\x02&\x01\x12\x04\
    \xb9\x05\x06\x18\n\r\n\x05\x06\0\x02&\x02\x12\x04\xb9\x05\x192\n\r\n\x05\
    \x06\0\x02&\x03\x12\x04\xb9\x05=P\n\x0f\n\x05\x06\0\x02&\x04\x12\x06\xba\
    \x05\x04\xc1\x05\x06\n\x13\n\t\x06\0\x02&\x04\xb0\xca\xbc\"\x12\x06\xba\
    \x05\x04\xc1\x05\x06\n\r\n\x05\x06\0\x02&\x04\x12\x04\xc2\x05\x047\n\x10\
    \n\x08\x06\0\x02&\x04\xc3\xf3\x04\x12\x04\xc2\x05\x047\n\r\n\x05\x06\0\
    \x02&\x04\x12\x04\xc3\x05\x04?\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\0\
    \x12\x04\xc3\x05\x04?\n\r\n\x05\x06\0\x02&\x04\x12\x04\xc4\x05\x04F\n\
    \x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x01\x12\x04\xc4\x05\x04F\n\r\n\x05\
    \x06\0\x02&\x04\x12\x04\xc5\x05\x04C\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\
    \x04\x02\x12\x04\xc5\x05\x04C\n\r\n\x05\x06\0\x02&\x04\x12\x04\xc6\x05\
    \x04A\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x03\x12\x04\xc6\x05\x04A\n\r\
    \n\x05\x06\0\x02&\x04\x12\x04\xc7\x05\x04A\n\x11\n\t\x06\0\x02&\x04\xc2\
    \xf3\x04\x04\x12\x04\xc7\x05\x04A\n\r\n\x05\x06\0\x02&\x04\x12\x04\xc8\
    \x05\x04=\n\x11\n\t\x06\0\x02&\x04\xc2\xf3\x04\x05\x12\x04\xc8\x05\x04=\
    \n\r\n\x05\x06\0\x02&\x04\x12\x04\xc9\x05\x04D\nN\n\t\x06\0\x02&\x04\xc2\
    \xf3\x04\x06\x12\x04\xc9\x05\x04D\";\x20to\x20know\x20the\x20concepts\
    \x20and\x20models\x20in\x20your\x20default\x20workflow.\n\n7\n\x04\x06\0\
    \x02'\x12\x06\xcd\x05\x02\xea\x05\x03\x1a'\x20Get\x20predicted\x20output\
    s\x20from\x20the\x20model.\n\n\r\n\x05\x06\0\x02'\x01\x12\x04\xcd\x05\
    \x06\x16\n\r\n\x05\x06\0\x02'\x02\x12\x04\xcd\x05\x18/\n\r\n\x05\x06\0\
    \x02'\x03\x12\x04\xcd\x05:M\n\x0f\n\x05\x06\0\x02'\x04\x12\x06\xce\x05\
    \x04\xe1\x05\x06\n\x13\n\t\x06\0\x02'\x04\xb0\xca\xbc\"\x12\x06\xce\x05\
    \x04\xe1\x05\x06\n\r\n\x05\x06\0\x02'\x04\x12\x04\xe2\x05\x047\n\x10\n\
    \x08\x06\0\x02'\x04\xc3\xf3\x04\x12\x04\xe2\x05\x047\n\r\n\x05\x06\0\x02\
    '\x04\x12\x04\xe3\x05\x04?\n\x11\n\t\x06\0\x02'\x04\xc2\xf3\x04\0\x12\
    \x04\xe3\x05\x04?\n\r\n\x05\x06\0\x02'\x04\x12\x04\xe4\x05\x04C\n\x11\n\
    \t\x06\0\x02'\x04\xc2\xf3\x04\x01\x12\x04\xe4\x05\x04C\n\r\n\x05\x06\0\
    \x02'\x04\x12\x04\xe5\x05\x04A\n\x11\n\t\x06\0\x02'\x04\xc2\xf3\x04\x02\
    \x12\x04\xe5\x05\x04A\n\r\n\x05\x06\0\x02'\x04\x12\x04\xe6\x05\x04>\n\
    \xdf\x01\n\t\x06\0\x02'\x04\xc2\xf3\x04\x03\x12\x04\xe6\x05\x04>\"\xcb\
    \x01\x20TODO(zeiler):\x20will\x20need\x20to\x20add\x20these\x20for\x20mo\
    del\x20prediction\x20requests.\n\x20option\x20(clarifai.auth.util.cl_dep\
    ending_scopes)\x20=\x20Nodepools_Get;\n\x20option\x20(clarifai.auth.util\
    .cl_depending_scopes)\x20=\x20Deployments_Get;\n\nU\n\x04\x06\0\x02(\x12\
    \x06\xee\x05\x02\xff\x05\x03\x1aE\x20TODO(zeiler):\x20will\x20need\x20to\
    \n\x20Single\x20request\x20but\x20streaming\x20resopnses.\n\n\r\n\x05\
    \x06\0\x02(\x01\x12\x04\xee\x05\x06\x1a\n\r\n\x05\x06\0\x02(\x02\x12\x04\
    \xee\x05\x1c3\n\r\n\x05\x06\0\x02(\x06\x12\x04\xee\x05>D\n\r\n\x05\x06\0\
    \x02(\x03\x12\x04\xee\x05EX\n\x0f\n\x05\x06\0\x02(\x04\x12\x06\xef\x05\
    \x04\xf6\x05\x06\n\x13\n\t\x06\0\x02(\x04\xb0\xca\xbc\"\x12\x06\xef\x05\
    \x04\xf6\x05\x06\n\r\n\x05\x06\0\x02(\x04\x12\x04\xf7\x05\x047\n\x10\n\
    \x08\x06\0\x02(\x04\xc3\xf3\x04\x12\x04\xf7\x05\x047\n\r\n\x05\x06\0\x02\
    (\x04\x12\x04\xf8\x05\x04?\n\x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\0\x12\
    \x04\xf8\x05\x04?\n\r\n\x05\x06\0\x02(\x04\x12\x04\xf9\x05\x04C\n\x11\n\
    \t\x06\0\x02(\x04\xc2\xf3\x04\x01\x12\x04\xf9\x05\x04C\n\r\n\x05\x06\0\
    \x02(\x04\x12\x04\xfa\x05\x04A\n\x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\x02\
    \x12\x04\xfa\x05\x04A\n\r\n\x05\x06\0\x02(\x04\x12\x04\xfb\x05\x04>\n\
    \xdf\x01\n\t\x06\0\x02(\x04\xc2\xf3\x04\x03\x12\x04\xfb\x05\x04>\"\xcb\
    \x01\x20TODO(zeiler):\x20will\x20need\x20to\x20add\x20these\x20for\x20mo\
    del\x20prediction\x20requests.\n\x20option\x20(clarifai.auth.util.cl_dep\
    ending_scopes)\x20=\x20Nodepools_Get;\n\x20option\x20(clarifai.auth.util\
    .cl_depending_scopes)\x20=\x20Deployments_Get;\n\n<\n\x04\x06\0\x02)\x12\
    \x06\x82\x06\x02\x8b\x06\x03\x1a,\x20Stream\x20of\x20requests\x20and\x20\
    stream\x20of\x20responses\n\n\r\n\x05\x06\0\x02)\x01\x12\x04\x82\x06\x06\
    \x18\n\r\n\x05\x06\0\x02)\x05\x12\x04\x82\x06\x1a\x20\n\r\n\x05\x06\0\
    \x02)\x02\x12\x04\x82\x06!8\n\r\n\x05\x06\0\x02)\x06\x12\x04\x82\x06CI\n\
    \r\n\x05\x06\0\x02)\x03\x12\x04\x82\x06J]\n\r\n\x05\x06\0\x02)\x04\x12\
    \x04\x83\x06\x047\n\x10\n\x08\x06\0\x02)\x04\xc3\xf3\x04\x12\x04\x83\x06\
    \x047\n\r\n\x05\x06\0\x02)\x04\x12\x04\x84\x06\x04?\n\x11\n\t\x06\0\x02)\
    \x04\xc2\xf3\x04\0\x12\x04\x84\x06\x04?\n\r\n\x05\x06\0\x02)\x04\x12\x04\
    \x85\x06\x04C\n\x11\n\t\x06\0\x02)\x04\xc2\xf3\x04\x01\x12\x04\x85\x06\
    \x04C\n\r\n\x05\x06\0\x02)\x04\x12\x04\x86\x06\x04A\n\x11\n\t\x06\0\x02)\
    \x04\xc2\xf3\x04\x02\x12\x04\x86\x06\x04A\n\r\n\x05\x06\0\x02)\x04\x12\
    \x04\x87\x06\x04>\n\xdf\x01\n\t\x06\0\x02)\x04\xc2\xf3\x04\x03\x12\x04\
    \x87\x06\x04>\"\xcb\x01\x20TODO(zeiler):\x20will\x20need\x20to\x20add\
    \x20these\x20for\x20model\x20prediction\x20requests.\n\x20option\x20(cla\
    rifai.auth.util.cl_depending_scopes)\x20=\x20Nodepools_Get;\n\x20option\
    \x20(clarifai.auth.util.cl_depending_scopes)\x20=\x20Deployments_Get;\n\
    \n(\n\x04\x06\0\x02*\x12\x06\x8e\x06\x02\x9c\x06\x03\x1a\x18\x20List\x20\
    all\x20the\x20datasets.\n\n\r\n\x05\x06\0\x02*\x01\x12\x04\x8e\x06\x06\
    \x12\n\r\n\x05\x06\0\x02*\x02\x12\x04\x8e\x06\x14'\n\r\n\x05\x06\0\x02*\
    \x03\x12\x04\x8e\x062F\n\x0f\n\x05\x06\0\x02*\x04\x12\x06\x8f\x06\x04\
    \x97\x06\x06\n\x13\n\t\x06\0\x02*\x04\xb0\xca\xbc\"\x12\x06\x8f\x06\x04\
    \x97\x06\x06\n\r\n\x05\x06\0\x02*\x04\x12\x04\x98\x06\x047\n\x10\n\x08\
    \x06\0\x02*\x04\xc3\xf3\x04\x12\x04\x98\x06\x047\n\r\n\x05\x06\0\x02*\
    \x04\x12\x04\x99\x06\x04?\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\0\x12\x04\
    \x99\x06\x04?\n\r\n\x05\x06\0\x02*\x04\x12\x04\x9a\x06\x04C\n\x11\n\t\
    \x06\0\x02*\x04\xc2\xf3\x04\x01\x12\x04\x9a\x06\x04C\n\r\n\x05\x06\0\x02\
    *\x04\x12\x04\x9b\x06\x04F\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\x02\x12\
    \x04\x9b\x06\x04F\n)\n\x04\x06\0\x02+\x12\x06\x9f\x06\x02\xaa\x06\x03\
    \x1a\x19\x20Get\x20a\x20specific\x20dataset.\n\n\r\n\x05\x06\0\x02+\x01\
    \x12\x04\x9f\x06\x06\x10\n\r\n\x05\x06\0\x02+\x02\x12\x04\x9f\x06\x12#\n\
    \r\n\x05\x06\0\x02+\x03\x12\x04\x9f\x06.C\n\x0f\n\x05\x06\0\x02+\x04\x12\
    \x06\xa0\x06\x04\xa5\x06\x06\n\x13\n\t\x06\0\x02+\x04\xb0\xca\xbc\"\x12\
    \x06\xa0\x06\x04\xa5\x06\x06\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa6\x06\
    \x047\n\x10\n\x08\x06\0\x02+\x04\xc3\xf3\x04\x12\x04\xa6\x06\x047\n\r\n\
    \x05\x06\0\x02+\x04\x12\x04\xa7\x06\x04?\n\x11\n\t\x06\0\x02+\x04\xc2\
    \xf3\x04\0\x12\x04\xa7\x06\x04?\n\r\n\x05\x06\0\x02+\x04\x12\x04\xa8\x06\
    \x04C\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\x01\x12\x04\xa8\x06\x04C\n\r\
    \n\x05\x06\0\x02+\x04\x12\x04\xa9\x06\x04F\n\x11\n\t\x06\0\x02+\x04\xc2\
    \xf3\x04\x02\x12\x04\xa9\x06\x04F\n\xd8\x01\n\x04\x06\0\x02,\x12\x06\xb0\
    \x06\x02\xbe\x06\x03\x1a\xc7\x01\x20Add\x20datasets\x20to\x20an\x20app.\
    \n\x20The\x20process\x20is\x20atomic,\x20i.e.\x20either\x20all\x20or\x20\
    no\x20datasets\x20are\x20added.\n\x20If\x20there\x20is\x20an\x20error\
    \x20for\x20one\x20dataset,\n\x20the\x20process\x20will\x20stop,\x20rever\
    t\x20the\x20transaction\x20and\x20return\x20the\x20error.\n\n\r\n\x05\
    \x06\0\x02,\x01\x12\x04\xb0\x06\x06\x12\n\r\n\x05\x06\0\x02,\x02\x12\x04\
    \xb0\x06\x14'\n\r\n\x05\x06\0\x02,\x03\x12\x04\xb0\x062F\n\x0f\n\x05\x06\
    \0\x02,\x04\x12\x06\xb1\x06\x04\xb8\x06\x06\n\x13\n\t\x06\0\x02,\x04\xb0\
    \xca\xbc\"\x12\x06\xb1\x06\x04\xb8\x06\x06\n\r\n\x05\x06\0\x02,\x04\x12\
    \x04\xb9\x06\x047\n\x10\n\x08\x06\0\x02,\x04\xc3\xf3\x04\x12\x04\xb9\x06\
    \x047\n\r\n\x05\x06\0\x02,\x04\x12\x04\xba\x06\x04?\n\x11\n\t\x06\0\x02,\
    \x04\xc2\xf3\x04\0\x12\x04\xba\x06\x04?\n\r\n\x05\x06\0\x02,\x04\x12\x04\
    \xbb\x06\x04C\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x01\x12\x04\xbb\x06\
    \x04C\n\r\n\x05\x06\0\x02,\x04\x12\x04\xbc\x06\x04C\n\x11\n\t\x06\0\x02,\
    \x04\xc2\xf3\x04\x02\x12\x04\xbc\x06\x04C\n\r\n\x05\x06\0\x02,\x04\x12\
    \x04\xbd\x06\x04F\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x03\x12\x04\xbd\
    \x06\x04F\n\xde\x01\n\x04\x06\0\x02-\x12\x06\xc4\x06\x02\xd2\x06\x03\x1a\
    \xcd\x01\x20Patch\x20one\x20or\x20more\x20datasets.\n\x20The\x20process\
    \x20is\x20atomic,\x20i.e.\x20either\x20all\x20or\x20no\x20datasets\x20ar\
    e\x20patched.\n\x20If\x20there\x20is\x20an\x20error\x20for\x20one\x20dat\
    aset,\n\x20the\x20process\x20will\x20stop,\x20revert\x20the\x20transacti\
    on\x20and\x20return\x20the\x20error.\n\n\r\n\x05\x06\0\x02-\x01\x12\x04\
    \xc4\x06\x06\x13\n\r\n\x05\x06\0\x02-\x02\x12\x04\xc4\x06\x15)\n\r\n\x05\
    \x06\0\x02-\x03\x12\x04\xc4\x064H\n\x0f\n\x05\x06\0\x02-\x04\x12\x06\xc5\
    \x06\x04\xcc\x06\x06\n\x13\n\t\x06\0\x02-\x04\xb0\xca\xbc\"\x12\x06\xc5\
    \x06\x04\xcc\x06\x06\n\r\n\x05\x06\0\x02-\x04\x12\x04\xcd\x06\x047\n\x10\
    \n\x08\x06\0\x02-\x04\xc3\xf3\x04\x12\x04\xcd\x06\x047\n\r\n\x05\x06\0\
    \x02-\x04\x12\x04\xce\x06\x04?\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\0\
    \x12\x04\xce\x06\x04?\n\r\n\x05\x06\0\x02-\x04\x12\x04\xcf\x06\x04C\n\
    \x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x01\x12\x04\xcf\x06\x04C\n\r\n\x05\
    \x06\0\x02-\x04\x12\x04\xd0\x06\x04C\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\
    \x04\x02\x12\x04\xd0\x06\x04C\n\r\n\x05\x06\0\x02-\x04\x12\x04\xd1\x06\
    \x04F\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x03\x12\x04\xd1\x06\x04F\nB\n\
    \x04\x06\0\x02.\x12\x06\xd5\x06\x02\xe3\x06\x03\x1a2\x20Delete\x20one\
    \x20or\x20more\x20datasets\x20in\x20a\x20single\x20request.\n\n\r\n\x05\
    \x06\0\x02.\x01\x12\x04\xd5\x06\x06\x14\n\r\n\x05\x06\0\x02.\x02\x12\x04\
    \xd5\x06\x16+\n\r\n\x05\x06\0\x02.\x03\x12\x04\xd5\x066V\n\x0f\n\x05\x06\
    \0\x02.\x04\x12\x06\xd6\x06\x04\xdd\x06\x06\n\x13\n\t\x06\0\x02.\x04\xb0\
    \xca\xbc\"\x12\x06\xd6\x06\x04\xdd\x06\x06\n\r\n\x05\x06\0\x02.\x04\x12\
    \x04\xde\x06\x047\n\x10\n\x08\x06\0\x02.\x04\xc3\xf3\x04\x12\x04\xde\x06\
    \x047\n\r\n\x05\x06\0\x02.\x04\x12\x04\xdf\x06\x04?\n\x11\n\t\x06\0\x02.\
    \x04\xc2\xf3\x04\0\x12\x04\xdf\x06\x04?\n\r\n\x05\x06\0\x02.\x04\x12\x04\
    \xe0\x06\x04C\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\x01\x12\x04\xe0\x06\
    \x04C\n\r\n\x05\x06\0\x02.\x04\x12\x04\xe1\x06\x04C\n\x11\n\t\x06\0\x02.\
    \x04\xc2\xf3\x04\x02\x12\x04\xe1\x06\x04C\n\r\n\x05\x06\0\x02.\x04\x12\
    \x04\xe2\x06\x04F\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\x03\x12\x04\xe2\
    \x06\x04F\n;\n\x04\x06\0\x02/\x12\x06\xe6\x06\x02\xf3\x06\x03\x1a+\x20Li\
    st\x20all\x20the\x20dataset\x20inputs\x20in\x20a\x20dataset.\n\n\r\n\x05\
    \x06\0\x02/\x01\x12\x04\xe6\x06\x06\x17\n\r\n\x05\x06\0\x02/\x02\x12\x04\
    \xe6\x06\x191\n\r\n\x05\x06\0\x02/\x03\x12\x04\xe6\x06<U\n\x0f\n\x05\x06\
    \0\x02/\x04\x12\x06\xe7\x06\x04\xec\x06\x06\n\x13\n\t\x06\0\x02/\x04\xb0\
    \xca\xbc\"\x12\x06\xe7\x06\x04\xec\x06\x06\n\r\n\x05\x06\0\x02/\x04\x12\
    \x04\xed\x06\x047\n\x10\n\x08\x06\0\x02/\x04\xc3\xf3\x04\x12\x04\xed\x06\
    \x047\n\r\n\x05\x06\0\x02/\x04\x12\x04\xee\x06\x04?\n\x11\n\t\x06\0\x02/\
    \x04\xc2\xf3\x04\0\x12\x04\xee\x06\x04?\n\r\n\x05\x06\0\x02/\x04\x12\x04\
    \xef\x06\x04C\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x01\x12\x04\xef\x06\
    \x04C\n\r\n\x05\x06\0\x02/\x04\x12\x04\xf0\x06\x04A\n\x11\n\t\x06\0\x02/\
    \x04\xc2\xf3\x04\x02\x12\x04\xf0\x06\x04A\n\r\n\x05\x06\0\x02/\x04\x12\
    \x04\xf1\x06\x04F\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x03\x12\x04\xf1\
    \x06\x04F\n\r\n\x05\x06\0\x02/\x04\x12\x04\xf2\x06\x04C\n\x11\n\t\x06\0\
    \x02/\x04\xc2\xf3\x04\x04\x12\x04\xf2\x06\x04C\n/\n\x04\x06\0\x020\x12\
    \x06\xf6\x06\x02\x83\x07\x03\x1a\x1f\x20Get\x20a\x20specific\x20dataset\
    \x20input.\n\n\r\n\x05\x06\0\x020\x01\x12\x04\xf6\x06\x06\x15\n\r\n\x05\
    \x06\0\x020\x02\x12\x04\xf6\x06\x17-\n\r\n\x05\x06\0\x020\x03\x12\x04\
    \xf6\x068R\n\x0f\n\x05\x06\0\x020\x04\x12\x06\xf7\x06\x04\xfc\x06\x06\n\
    \x13\n\t\x06\0\x020\x04\xb0\xca\xbc\"\x12\x06\xf7\x06\x04\xfc\x06\x06\n\
    \r\n\x05\x06\0\x020\x04\x12\x04\xfd\x06\x047\n\x10\n\x08\x06\0\x020\x04\
    \xc3\xf3\x04\x12\x04\xfd\x06\x047\n\r\n\x05\x06\0\x020\x04\x12\x04\xfe\
    \x06\x04?\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\0\x12\x04\xfe\x06\x04?\n\
    \r\n\x05\x06\0\x020\x04\x12\x04\xff\x06\x04C\n\x11\n\t\x06\0\x020\x04\
    \xc2\xf3\x04\x01\x12\x04\xff\x06\x04C\n\r\n\x05\x06\0\x020\x04\x12\x04\
    \x80\x07\x04A\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x02\x12\x04\x80\x07\
    \x04A\n\r\n\x05\x06\0\x020\x04\x12\x04\x81\x07\x04F\n\x11\n\t\x06\0\x020\
    \x04\xc2\xf3\x04\x03\x12\x04\x81\x07\x04F\n\r\n\x05\x06\0\x020\x04\x12\
    \x04\x82\x07\x04C\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x04\x12\x04\x82\
    \x07\x04C\n\xce\x03\n\x04\x06\0\x021\x12\x06\x8d\x07\x02\x9d\x07\x03\x1a\
    \xbd\x03\x20Add\x20dataset\x20inputs\x20to\x20a\x20dataset.\n\x20The\x20\
    process\x20is\x20not\x20atomic,\x20i.e.\x20if\x20there\x20are\x20errors\
    \x20with\x20some\x20dataset\n\x20inputs,\x20others\x20might\x20still\x20\
    be\x20added.\x20The\x20response\x20reports\n\x20\x20\x20-\x20SUCCESS\x20\
    if\x20all\x20dataset\x20inputs\x20were\x20added,\n\x20\x20\x20-\x20MIXED\
    _STATUS\x20if\x20only\x20some\x20dataset\x20inputs\x20were\x20added,\x20\
    and\n\x20\x20\x20-\x20FAILURE\x20if\x20no\x20dataset\x20inputs\x20were\
    \x20added.\n\x20Each\x20individual\x20dataset\x20input\x20in\x20the\x20r\
    esponse\x20has\x20the\x20status\x20set\x20to\n\x20indicate\x20if\x20it\
    \x20was\x20successful\x20or\x20if\x20there\x20was\x20an\x20error.\n\n\r\
    \n\x05\x06\0\x021\x01\x12\x04\x8d\x07\x06\x17\n\r\n\x05\x06\0\x021\x02\
    \x12\x04\x8d\x07\x191\n\r\n\x05\x06\0\x021\x03\x12\x04\x8d\x07<U\n\x0f\n\
    \x05\x06\0\x021\x04\x12\x06\x8e\x07\x04\x95\x07\x06\n\x13\n\t\x06\0\x021\
    \x04\xb0\xca\xbc\"\x12\x06\x8e\x07\x04\x95\x07\x06\n\r\n\x05\x06\0\x021\
    \x04\x12\x04\x96\x07\x047\n\x10\n\x08\x06\0\x021\x04\xc3\xf3\x04\x12\x04\
    \x96\x07\x047\n\r\n\x05\x06\0\x021\x04\x12\x04\x97\x07\x04?\n\x11\n\t\
    \x06\0\x021\x04\xc2\xf3\x04\0\x12\x04\x97\x07\x04?\n\r\n\x05\x06\0\x021\
    \x04\x12\x04\x98\x07\x04C\n\x11\n\t\x06\0\x021\x04\xc2\xf3\x04\x01\x12\
    \x04\x98\x07\x04C\n\r\n\x05\x06\0\x021\x04\x12\x04\x99\x07\x04C\n\x11\n\
    \t\x06\0\x021\x04\xc2\xf3\x04\x02\x12\x04\x99\x07\x04C\n\r\n\x05\x06\0\
    \x021\x04\x12\x04\x9a\x07\x04A\n\x11\n\t\x06\0\x021\x04\xc2\xf3\x04\x03\
    \x12\x04\x9a\x07\x04A\n\r\n\x05\x06\0\x021\x04\x12\x04\x9b\x07\x04F\n\
    \x11\n\t\x06\0\x021\x04\xc2\xf3\x04\x04\x12\x04\x9b\x07\x04F\n\r\n\x05\
    \x06\0\x021\x04\x12\x04\x9c\x07\x04C\n\x11\n\t\x06\0\x021\x04\xc2\xf3\
    \x04\x05\x12\x04\x9c\x07\x04C\nH\n\x04\x06\0\x022\x12\x06\xa0\x07\x02\
    \xaf\x07\x03\x1a8\x20Delete\x20one\x20or\x20more\x20dataset\x20inputs\
    \x20in\x20a\x20single\x20request.\n\n\r\n\x05\x06\0\x022\x01\x12\x04\xa0\
    \x07\x06\x19\n\r\n\x05\x06\0\x022\x02\x12\x04\xa0\x07\x1b5\n\r\n\x05\x06\
    \0\x022\x03\x12\x04\xa0\x07@`\n\x0f\n\x05\x06\0\x022\x04\x12\x06\xa1\x07\
    \x04\xa8\x07\x06\n\x13\n\t\x06\0\x022\x04\xb0\xca\xbc\"\x12\x06\xa1\x07\
    \x04\xa8\x07\x06\n\r\n\x05\x06\0\x022\x04\x12\x04\xa9\x07\x047\n\x10\n\
    \x08\x06\0\x022\x04\xc3\xf3\x04\x12\x04\xa9\x07\x047\n\r\n\x05\x06\0\x02\
    2\x04\x12\x04\xaa\x07\x04?\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\0\x12\
    \x04\xaa\x07\x04?\n\r\n\x05\x06\0\x022\x04\x12\x04\xab\x07\x04C\n\x11\n\
    \t\x06\0\x022\x04\xc2\xf3\x04\x01\x12\x04\xab\x07\x04C\n\r\n\x05\x06\0\
    \x022\x04\x12\x04\xac\x07\x04C\n\x11\n\t\x06\0\x022\x04\xc2\xf3\x04\x02\
    \x12\x04\xac\x07\x04C\n\r\n\x05\x06\0\x022\x04\x12\x04\xad\x07\x04F\n\
    \x11\n\t\x06\0\x022\x04\xc2\xf3\x04\x03\x12\x04\xad\x07\x04F\n\r\n\x05\
    \x06\0\x022\x04\x12\x04\xae\x07\x04A\n\x11\n\t\x06\0\x022\x04\xc2\xf3\
    \x04\x04\x12\x04\xae\x07\x04A\n0\n\x04\x06\0\x023\x12\x06\xb2\x07\x02\
    \xbd\x07\x03\x1a\x20\x20List\x20all\x20the\x20dataset\x20versions.\n\n\r\
    \n\x05\x06\0\x023\x01\x12\x04\xb2\x07\x06\x19\n\r\n\x05\x06\0\x023\x02\
    \x12\x04\xb2\x07\x1b5\n\r\n\x05\x06\0\x023\x03\x12\x04\xb2\x07@[\n\x0f\n\
    \x05\x06\0\x023\x04\x12\x06\xb3\x07\x04\xb8\x07\x06\n\x13\n\t\x06\0\x023\
    \x04\xb0\xca\xbc\"\x12\x06\xb3\x07\x04\xb8\x07\x06\n\r\n\x05\x06\0\x023\
    \x04\x12\x04\xb9\x07\x047\n\x10\n\x08\x06\0\x023\x04\xc3\xf3\x04\x12\x04\
    \xb9\x07\x047\n\r\n\x05\x06\0\x023\x04\x12\x04\xba\x07\x04?\n\x11\n\t\
    \x06\0\x023\x04\xc2\xf3\x04\0\x12\x04\xba\x07\x04?\n\r\n\x05\x06\0\x023\
    \x04\x12\x04\xbb\x07\x04C\n\x11\n\t\x06\0\x023\x04\xc2\xf3\x04\x01\x12\
    \x04\xbb\x07\x04C\n\r\n\x05\x06\0\x023\x04\x12\x04\xbc\x07\x04F\n\x11\n\
    \t\x06\0\x023\x04\xc2\xf3\x04\x02\x12\x04\xbc\x07\x04F\n1\n\x04\x06\0\
    \x024\x12\x06\xc0\x07\x02\xcb\x07\x03\x1a!\x20Get\x20a\x20specific\x20da\
    taset\x20version.\n\n\r\n\x05\x06\0\x024\x01\x12\x04\xc0\x07\x06\x17\n\r\
    \n\x05\x06\0\x024\x02\x12\x04\xc0\x07\x191\n\r\n\x05\x06\0\x024\x03\x12\
    \x04\xc0\x07<X\n\x0f\n\x05\x06\0\x024\x04\x12\x06\xc1\x07\x04\xc6\x07\
    \x06\n\x13\n\t\x06\0\x024\x04\xb0\xca\xbc\"\x12\x06\xc1\x07\x04\xc6\x07\
    \x06\n\r\n\x05\x06\0\x024\x04\x12\x04\xc7\x07\x047\n\x10\n\x08\x06\0\x02\
    4\x04\xc3\xf3\x04\x12\x04\xc7\x07\x047\n\r\n\x05\x06\0\x024\x04\x12\x04\
    \xc8\x07\x04?\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\0\x12\x04\xc8\x07\x04\
    ?\n\r\n\x05\x06\0\x024\x04\x12\x04\xc9\x07\x04C\n\x11\n\t\x06\0\x024\x04\
    \xc2\xf3\x04\x01\x12\x04\xc9\x07\x04C\n\r\n\x05\x06\0\x024\x04\x12\x04\
    \xca\x07\x04F\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x02\x12\x04\xca\x07\
    \x04F\n\x0e\n\x04\x06\0\x025\x12\x06\xcd\x07\x02\xda\x07\x03\n\r\n\x05\
    \x06\0\x025\x01\x12\x04\xcd\x07\x06%\n\r\n\x05\x06\0\x025\x02\x12\x04\
    \xcd\x07'M\n\r\n\x05\x06\0\x025\x03\x12\x04\xcd\x07X\x7f\n\x0f\n\x05\x06\
    \0\x025\x04\x12\x06\xce\x07\x04\xd3\x07\x06\n\x13\n\t\x06\0\x025\x04\xb0\
    \xca\xbc\"\x12\x06\xce\x07\x04\xd3\x07\x06\n\r\n\x05\x06\0\x025\x04\x12\
    \x04\xd4\x07\x047\n\x10\n\x08\x06\0\x025\x04\xc3\xf3\x04\x12\x04\xd4\x07\
    \x047\n\r\n\x05\x06\0\x025\x04\x12\x04\xd5\x07\x04?\n\x11\n\t\x06\0\x025\
    \x04\xc2\xf3\x04\0\x12\x04\xd5\x07\x04?\n\r\n\x05\x06\0\x025\x04\x12\x04\
    \xd6\x07\x04C\n\x11\n\t\x06\0\x025\x04\xc2\xf3\x04\x01\x12\x04\xd6\x07\
    \x04C\n\r\n\x05\x06\0\x025\x04\x12\x04\xd7\x07\x04F\n\x11\n\t\x06\0\x025\
    \x04\xc2\xf3\x04\x02\x12\x04\xd7\x07\x04F\n\r\n\x05\x06\0\x025\x04\x12\
    \x04\xd8\x07\x04C\n\x11\n\t\x06\0\x025\x04\xc2\xf3\x04\x03\x12\x04\xd8\
    \x07\x04C\n\r\n\x05\x06\0\x025\x04\x12\x04\xd9\x07\x04A\n\x11\n\t\x06\0\
    \x025\x04\xc2\xf3\x04\x04\x12\x04\xd9\x07\x04A\n4\n\x04\x06\0\x026\x12\
    \x06\xdd\x07\x02\xec\x07\x03\x1a$\x20Add\x20dataset\x20versions\x20to\
    \x20a\x20dataset.\n\n\r\n\x05\x06\0\x026\x01\x12\x04\xdd\x07\x06\x19\n\r\
    \n\x05\x06\0\x026\x02\x12\x04\xdd\x07\x1b5\n\r\n\x05\x06\0\x026\x03\x12\
    \x04\xdd\x07@[\n\x0f\n\x05\x06\0\x026\x04\x12\x06\xde\x07\x04\xe5\x07\
    \x06\n\x13\n\t\x06\0\x026\x04\xb0\xca\xbc\"\x12\x06\xde\x07\x04\xe5\x07\
    \x06\n\r\n\x05\x06\0\x026\x04\x12\x04\xe6\x07\x047\n\x10\n\x08\x06\0\x02\
    6\x04\xc3\xf3\x04\x12\x04\xe6\x07\x047\n\r\n\x05\x06\0\x026\x04\x12\x04\
    \xe7\x07\x04?\n\x11\n\t\x06\0\x026\x04\xc2\xf3\x04\0\x12\x04\xe7\x07\x04\
    ?\n\r\n\x05\x06\0\x026\x04\x12\x04\xe8\x07\x04C\n\x11\n\t\x06\0\x026\x04\
    \xc2\xf3\x04\x01\x12\x04\xe8\x07\x04C\n\r\n\x05\x06\0\x026\x04\x12\x04\
    \xe9\x07\x04C\n\x11\n\t\x06\0\x026\x04\xc2\xf3\x04\x02\x12\x04\xe9\x07\
    \x04C\n\r\n\x05\x06\0\x026\x04\x12\x04\xea\x07\x04A\n\x11\n\t\x06\0\x026\
    \x04\xc2\xf3\x04\x03\x12\x04\xea\x07\x04A\n\r\n\x05\x06\0\x026\x04\x12\
    \x04\xeb\x07\x04D\n\x11\n\t\x06\0\x026\x04\xc2\xf3\x04\x04\x12\x04\xeb\
    \x07\x04D\n5\n\x04\x06\0\x027\x12\x06\xef\x07\x02\xfc\x07\x03\x1a%\x20Pa\
    tch\x20one\x20or\x20more\x20dataset\x20versions.\n\n\r\n\x05\x06\0\x027\
    \x01\x12\x04\xef\x07\x06\x1a\n\r\n\x05\x06\0\x027\x02\x12\x04\xef\x07\
    \x1c7\n\r\n\x05\x06\0\x027\x03\x12\x04\xef\x07B]\n\x0f\n\x05\x06\0\x027\
    \x04\x12\x06\xf0\x07\x04\xf7\x07\x06\n\x13\n\t\x06\0\x027\x04\xb0\xca\
    \xbc\"\x12\x06\xf0\x07\x04\xf7\x07\x06\n\r\n\x05\x06\0\x027\x04\x12\x04\
    \xf8\x07\x047\n\x10\n\x08\x06\0\x027\x04\xc3\xf3\x04\x12\x04\xf8\x07\x04\
    7\n\r\n\x05\x06\0\x027\x04\x12\x04\xf9\x07\x04?\n\x11\n\t\x06\0\x027\x04\
    \xc2\xf3\x04\0\x12\x04\xf9\x07\x04?\n\r\n\x05\x06\0\x027\x04\x12\x04\xfa\
    \x07\x04C\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\x01\x12\x04\xfa\x07\x04C\
    \n\r\n\x05\x06\0\x027\x04\x12\x04\xfb\x07\x04C\n\x11\n\t\x06\0\x027\x04\
    \xc2\xf3\x04\x02\x12\x04\xfb\x07\x04C\nJ\n\x04\x06\0\x028\x12\x06\xff\
    \x07\x02\x8d\x08\x03\x1a:\x20Delete\x20one\x20or\x20more\x20dataset\x20v\
    ersions\x20in\x20a\x20single\x20request.\n\n\r\n\x05\x06\0\x028\x01\x12\
    \x04\xff\x07\x06\x1b\n\r\n\x05\x06\0\x028\x02\x12\x04\xff\x07\x1d9\n\r\n\
    \x05\x06\0\x028\x03\x12\x04\xff\x07Dd\n\x0f\n\x05\x06\0\x028\x04\x12\x06\
    \x80\x08\x04\x87\x08\x06\n\x13\n\t\x06\0\x028\x04\xb0\xca\xbc\"\x12\x06\
    \x80\x08\x04\x87\x08\x06\n\r\n\x05\x06\0\x028\x04\x12\x04\x88\x08\x047\n\
    \x10\n\x08\x06\0\x028\x04\xc3\xf3\x04\x12\x04\x88\x08\x047\n\r\n\x05\x06\
    \0\x028\x04\x12\x04\x89\x08\x04?\n\x11\n\t\x06\0\x028\x04\xc2\xf3\x04\0\
    \x12\x04\x89\x08\x04?\n\r\n\x05\x06\0\x028\x04\x12\x04\x8a\x08\x04C\n\
    \x11\n\t\x06\0\x028\x04\xc2\xf3\x04\x01\x12\x04\x8a\x08\x04C\n\r\n\x05\
    \x06\0\x028\x04\x12\x04\x8b\x08\x04C\n\x11\n\t\x06\0\x028\x04\xc2\xf3\
    \x04\x02\x12\x04\x8b\x08\x04C\n\r\n\x05\x06\0\x028\x04\x12\x04\x8c\x08\
    \x04F\n\x11\n\t\x06\0\x028\x04\xc2\xf3\x04\x03\x12\x04\x8c\x08\x04F\n5\n\
    \x04\x06\0\x029\x12\x06\x90\x08\x02\x9d\x08\x03\x1a%\x20Create\x20export\
    \x20of\x20a\x20dataset\x20version.\n\n\r\n\x05\x06\0\x029\x01\x12\x04\
    \x90\x08\x06\x1e\n\r\n\x05\x06\0\x029\x02\x12\x04\x90\x08\x20?\n\r\n\x05\
    \x06\0\x029\x03\x12\x04\x90\x08Jk\n\x0f\n\x05\x06\0\x029\x04\x12\x06\x91\
    \x08\x04\x98\x08\x06\n\x13\n\t\x06\0\x029\x04\xb0\xca\xbc\"\x12\x06\x91\
    \x08\x04\x98\x08\x06\n\r\n\x05\x06\0\x029\x04\x12\x04\x99\x08\x047\n\x10\
    \n\x08\x06\0\x029\x04\xc3\xf3\x04\x12\x04\x99\x08\x047\n\r\n\x05\x06\0\
    \x029\x04\x12\x04\x9a\x08\x04?\n\x11\n\t\x06\0\x029\x04\xc2\xf3\x04\0\
    \x12\x04\x9a\x08\x04?\n\r\n\x05\x06\0\x029\x04\x12\x04\x9b\x08\x04C\n\
    \x11\n\t\x06\0\x029\x04\xc2\xf3\x04\x01\x12\x04\x9b\x08\x04C\n\r\n\x05\
    \x06\0\x029\x04\x12\x04\x9c\x08\x04C\n\x11\n\t\x06\0\x029\x04\xc2\xf3\
    \x04\x02\x12\x04\x9c\x08\x04C\n\x84\x01\n\x04\x06\0\x02:\x12\x06\xa5\x08\
    \x02\xaf\x08\x03\x1a\x1c\x20Get\x20a\x20specific\x20model\x20type.\n2V//\
    ////////////////////////////////////\n\x20Models\n//////////////////////\
    ////////////////\n\n\r\n\x05\x06\0\x02:\x01\x12\x04\xa5\x08\x06\x12\n\r\
    \n\x05\x06\0\x02:\x02\x12\x04\xa5\x08\x14'\n\r\n\x05\x06\0\x02:\x03\x12\
    \x04\xa5\x082I\n\x0f\n\x05\x06\0\x02:\x04\x12\x06\xa6\x08\x04\xab\x08\
    \x06\n\x13\n\t\x06\0\x02:\x04\xb0\xca\xbc\"\x12\x06\xa6\x08\x04\xab\x08\
    \x06\n\r\n\x05\x06\0\x02:\x04\x12\x04\xac\x08\x047\n\x10\n\x08\x06\0\x02\
    :\x04\xc3\xf3\x04\x12\x04\xac\x08\x047\n\r\n\x05\x06\0\x02:\x04\x12\x04\
    \xad\x08\x04?\n\x11\n\t\x06\0\x02:\x04\xc2\xf3\x04\0\x12\x04\xad\x08\x04\
    ?\n\r\n\x05\x06\0\x02:\x04\x12\x04\xae\x08\x04A\n\x11\n\t\x06\0\x02:\x04\
    \xc2\xf3\x04\x01\x12\x04\xae\x08\x04A\nN\n\x04\x06\0\x02;\x12\x06\xb2\
    \x08\x02\xb7\x08\x03\x1a>\x20List\x20all\x20the\x20supported\x20open\x20\
    source\x20licenses\x20in\x20the\x20platform.\n\n\r\n\x05\x06\0\x02;\x01\
    \x12\x04\xb2\x08\x06\x1c\n\r\n\x05\x06\0\x02;\x02\x12\x04\xb2\x08\x1e;\n\
    \r\n\x05\x06\0\x02;\x03\x12\x04\xb2\x08Fd\n\x0f\n\x05\x06\0\x02;\x04\x12\
    \x06\xb3\x08\x04\xb5\x08\x06\n\x13\n\t\x06\0\x02;\x04\xb0\xca\xbc\"\x12\
    \x06\xb3\x08\x04\xb5\x08\x06\n\r\n\x05\x06\0\x02;\x04\x12\x04\xb6\x08\
    \x046\n\x10\n\x08\x06\0\x02;\x04\xc3\xf3\x04\x12\x04\xb6\x08\x046\n\x9a\
    \x01\n\x04\x06\0\x02<\x12\x06\xbb\x08\x02\xc5\x08\x03\x1a\x89\x01\x20Lis\
    t\x20all\x20the\x20model\x20types\x20available\x20in\x20the\x20platform.\
    \n\x20This\x20MUST\x20be\x20above\x20ListModels\x20so\x20that\x20the\x20\
    /models/types\x20endpoint\x20takes\x20precedence.\n\n\r\n\x05\x06\0\x02<\
    \x01\x12\x04\xbb\x08\x06\x14\n\r\n\x05\x06\0\x02<\x02\x12\x04\xbb\x08\
    \x16+\n\r\n\x05\x06\0\x02<\x03\x12\x04\xbb\x086L\n\x0f\n\x05\x06\0\x02<\
    \x04\x12\x06\xbc\x08\x04\xc1\x08\x06\n\x13\n\t\x06\0\x02<\x04\xb0\xca\
    \xbc\"\x12\x06\xbc\x08\x04\xc1\x08\x06\n\r\n\x05\x06\0\x02<\x04\x12\x04\
    \xc2\x08\x047\n\x10\n\x08\x06\0\x02<\x04\xc3\xf3\x04\x12\x04\xc2\x08\x04\
    7\n\r\n\x05\x06\0\x02<\x04\x12\x04\xc3\x08\x04?\n\x11\n\t\x06\0\x02<\x04\
    \xc2\xf3\x04\0\x12\x04\xc3\x08\x04?\n\r\n\x05\x06\0\x02<\x04\x12\x04\xc4\
    \x08\x04A\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\x01\x12\x04\xc4\x08\x04A\
    \n3\n\x04\x06\0\x02=\x12\x06\xc8\x08\x02\xd3\x08\x03\x1a#\x20Get\x20a\
    \x20specific\x20model\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02=\x01\
    \x12\x04\xc8\x08\x06\x0e\n\r\n\x05\x06\0\x02=\x02\x12\x04\xc8\x08\x10\
    \x1f\n\r\n\x05\x06\0\x02=\x03\x12\x04\xc8\x08*=\n\x0f\n\x05\x06\0\x02=\
    \x04\x12\x06\xc9\x08\x04\xce\x08\x06\n\x13\n\t\x06\0\x02=\x04\xb0\xca\
    \xbc\"\x12\x06\xc9\x08\x04\xce\x08\x06\n\r\n\x05\x06\0\x02=\x04\x12\x04\
    \xcf\x08\x047\n\x10\n\x08\x06\0\x02=\x04\xc3\xf3\x04\x12\x04\xcf\x08\x04\
    7\n\r\n\x05\x06\0\x02=\x04\x12\x04\xd0\x08\x04?\n\x11\n\t\x06\0\x02=\x04\
    \xc2\xf3\x04\0\x12\x04\xd0\x08\x04?\n\r\n\x05\x06\0\x02=\x04\x12\x04\xd1\
    \x08\x04C\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x01\x12\x04\xd1\x08\x04C\
    \n\r\n\x05\x06\0\x02=\x04\x12\x04\xd2\x08\x04A\n\x11\n\t\x06\0\x02=\x04\
    \xc2\xf3\x04\x02\x12\x04\xd2\x08\x04A\n[\n\x04\x06\0\x02>\x12\x06\xd7\
    \x08\x02\xe8\x08\x03\x1aK\x20Get\x20a\x20the\x20output\x20info\x20for\
    \x20a\x20given\x20model_id\x20or\x20model_id/version_id\n\x20combo.\n\n\
    \r\n\x05\x06\0\x02>\x01\x12\x04\xd7\x08\x06\x18\n\r\n\x05\x06\0\x02>\x02\
    \x12\x04\xd7\x08\x1a)\n\r\n\x05\x06\0\x02>\x03\x12\x04\xd7\x084G\n\x0f\n\
    \x05\x06\0\x02>\x04\x12\x06\xd8\x08\x04\xe3\x08\x06\n\x13\n\t\x06\0\x02>\
    \x04\xb0\xca\xbc\"\x12\x06\xd8\x08\x04\xe3\x08\x06\n\r\n\x05\x06\0\x02>\
    \x04\x12\x04\xe4\x08\x047\n\x10\n\x08\x06\0\x02>\x04\xc3\xf3\x04\x12\x04\
    \xe4\x08\x047\n\r\n\x05\x06\0\x02>\x04\x12\x04\xe5\x08\x04?\n\x11\n\t\
    \x06\0\x02>\x04\xc2\xf3\x04\0\x12\x04\xe5\x08\x04?\n\r\n\x05\x06\0\x02>\
    \x04\x12\x04\xe6\x08\x04C\n\x11\n\t\x06\0\x02>\x04\xc2\xf3\x04\x01\x12\
    \x04\xe6\x08\x04C\n\r\n\x05\x06\0\x02>\x04\x12\x04\xe7\x08\x04A\n\x11\n\
    \t\x06\0\x02>\x04\xc2\xf3\x04\x02\x12\x04\xe7\x08\x04A\n&\n\x04\x06\0\
    \x02?\x12\x06\xeb\x08\x02\xf9\x08\x03\x1a\x16\x20List\x20all\x20the\x20m\
    odels.\n\n\r\n\x05\x06\0\x02?\x01\x12\x04\xeb\x08\x06\x10\n\r\n\x05\x06\
    \0\x02?\x02\x12\x04\xeb\x08\x12#\n\r\n\x05\x06\0\x02?\x03\x12\x04\xeb\
    \x08.@\n\x0f\n\x05\x06\0\x02?\x04\x12\x06\xec\x08\x04\xf4\x08\x06\n\x13\
    \n\t\x06\0\x02?\x04\xb0\xca\xbc\"\x12\x06\xec\x08\x04\xf4\x08\x06\n\r\n\
    \x05\x06\0\x02?\x04\x12\x04\xf5\x08\x047\n\x10\n\x08\x06\0\x02?\x04\xc3\
    \xf3\x04\x12\x04\xf5\x08\x047\n\r\n\x05\x06\0\x02?\x04\x12\x04\xf6\x08\
    \x04?\n\x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\0\x12\x04\xf6\x08\x04?\n\r\n\
    \x05\x06\0\x02?\x04\x12\x04\xf7\x08\x04C\n\x11\n\t\x06\0\x02?\x04\xc2\
    \xf3\x04\x01\x12\x04\xf7\x08\x04C\n\r\n\x05\x06\0\x02?\x04\x12\x04\xf8\
    \x08\x04A\n\x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\x02\x12\x04\xf8\x08\x04A\
    \n7\n\x04\x06\0\x02@\x12\x06\xfc\x08\x02\x89\t\x03\x1a'\x20List\x20the\
    \x20resource\x20counts\x20for\x20the\x20app.\n\n\r\n\x05\x06\0\x02@\x01\
    \x12\x04\xfc\x08\x06\x17\n\r\n\x05\x06\0\x02@\x02\x12\x04\xfc\x08\x191\n\
    \r\n\x05\x06\0\x02@\x03\x12\x04\xfc\x08<U\n\x0f\n\x05\x06\0\x02@\x04\x12\
    \x06\xfd\x08\x04\x82\t\x06\n\x13\n\t\x06\0\x02@\x04\xb0\xca\xbc\"\x12\
    \x06\xfd\x08\x04\x82\t\x06\n\r\n\x05\x06\0\x02@\x04\x12\x04\x83\t\x047\n\
    \x10\n\x08\x06\0\x02@\x04\xc3\xf3\x04\x12\x04\x83\t\x047\n\r\n\x05\x06\0\
    \x02@\x04\x12\x04\x84\t\x04C\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\0\x12\
    \x04\x84\t\x04C\n\r\n\x05\x06\0\x02@\x04\x12\x04\x85\t\x04A\n\x11\n\t\
    \x06\0\x02@\x04\xc2\xf3\x04\x01\x12\x04\x85\t\x04A\n\r\n\x05\x06\0\x02@\
    \x04\x12\x04\x86\t\x04D\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\x02\x12\x04\
    \x86\t\x04D\n\r\n\x05\x06\0\x02@\x04\x12\x04\x87\t\x04B\n\x11\n\t\x06\0\
    \x02@\x04\xc2\xf3\x04\x03\x12\x04\x87\t\x04B\n\r\n\x05\x06\0\x02@\x04\
    \x12\x04\x88\t\x04?\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\x04\x12\x04\x88\
    \t\x04?\n\xcb\x01\n\x04\x06\0\x02A\x12\x06\x8e\t\x02\x9b\t\x03\x1a\xba\
    \x01\x20Search\x20over\x20the\x20models\x20to\x20find\x20one\x20or\x20mo\
    re\x20you're\x20looking\x20for.\n\x20This\x20leverage\x20the\x20\"body\"\
    \x20parameter\x20because\x20we\x20also\x20have\x20page\x20and\n\x20per_p\
    age\x20as\x20url\x20query\x20param\x20variables\x20in\x20this\x20request\
    .\n\n\r\n\x05\x06\0\x02A\x01\x12\x04\x8e\t\x06\x18\n\r\n\x05\x06\0\x02A\
    \x02\x12\x04\x8e\t\x1a3\n\r\n\x05\x06\0\x02A\x03\x12\x04\x8e\t>P\n\x0f\n\
    \x05\x06\0\x02A\x04\x12\x06\x8f\t\x04\x96\t\x06\n\x13\n\t\x06\0\x02A\x04\
    \xb0\xca\xbc\"\x12\x06\x8f\t\x04\x96\t\x06\n\r\n\x05\x06\0\x02A\x04\x12\
    \x04\x97\t\x047\n\x10\n\x08\x06\0\x02A\x04\xc3\xf3\x04\x12\x04\x97\t\x04\
    7\n\r\n\x05\x06\0\x02A\x04\x12\x04\x98\t\x04?\n\x11\n\t\x06\0\x02A\x04\
    \xc2\xf3\x04\0\x12\x04\x98\t\x04?\n\r\n\x05\x06\0\x02A\x04\x12\x04\x99\t\
    \x04C\n\x11\n\t\x06\0\x02A\x04\xc2\xf3\x04\x01\x12\x04\x99\t\x04C\n\r\n\
    \x05\x06\0\x02A\x04\x12\x04\x9a\t\x04A\n\x11\n\t\x06\0\x02A\x04\xc2\xf3\
    \x04\x02\x12\x04\x9a\t\x04A\n)\n\x04\x06\0\x02B\x12\x06\x9e\t\x02\xae\t\
    \x03\x1a\x19\x20Add\x20a\x20models\x20to\x20an\x20app.\n\n\r\n\x05\x06\0\
    \x02B\x01\x12\x04\x9e\t\x06\x10\n\r\n\x05\x06\0\x02B\x02\x12\x04\x9e\t\
    \x12#\n\r\n\x05\x06\0\x02B\x03\x12\x04\x9e\t.A\n\x0f\n\x05\x06\0\x02B\
    \x04\x12\x06\x9f\t\x04\xa6\t\x06\n\x13\n\t\x06\0\x02B\x04\xb0\xca\xbc\"\
    \x12\x06\x9f\t\x04\xa6\t\x06\n\r\n\x05\x06\0\x02B\x04\x12\x04\xa7\t\x047\
    \n\x10\n\x08\x06\0\x02B\x04\xc3\xf3\x04\x12\x04\xa7\t\x047\n\r\n\x05\x06\
    \0\x02B\x04\x12\x04\xa8\t\x04?\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\x04\0\
    \x12\x04\xa8\t\x04?\n\r\n\x05\x06\0\x02B\x04\x12\x04\xa9\t\x04C\n\x11\n\
    \t\x06\0\x02B\x04\xc2\xf3\x04\x01\x12\x04\xa9\t\x04C\n\r\n\x05\x06\0\x02\
    B\x04\x12\x04\xaa\t\x04A\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\x04\x02\x12\
    \x04\xaa\t\x04A\n\r\n\x05\x06\0\x02B\x04\x12\x04\xab\t\x04A\n\x11\n\t\
    \x06\0\x02B\x04\xc2\xf3\x04\x03\x12\x04\xab\t\x04A\n\r\n\x05\x06\0\x02B\
    \x04\x12\x04\xac\t\x04C\nF\n\t\x06\0\x02B\x04\xc2\xf3\x04\x04\x12\x04\
    \xac\t\x04C\"3\x20Train\x20is\x20needed\x20because\x20it\x20creates\x20a\
    \x20new\x20version.\n\n\r\n\x05\x06\0\x02B\x04\x12\x04\xad\t\x04D\nF\n\t\
    \x06\0\x02B\x04\xc2\xf3\x04\x05\x12\x04\xad\t\x04D\"3\x20Needs\x20to\x20\
    check\x20the\x20base\x20workflow\x20to\x20build\x20off\x20of.\n\n+\n\x04\
    \x06\0\x02C\x12\x06\xb1\t\x02\xc0\t\x03\x1a\x1b\x20Patch\x20one\x20or\
    \x20more\x20models.\n\n\r\n\x05\x06\0\x02C\x01\x12\x04\xb1\t\x06\x11\n\r\
    \n\x05\x06\0\x02C\x02\x12\x04\xb1\t\x13%\n\r\n\x05\x06\0\x02C\x03\x12\
    \x04\xb1\t0B\n\x0f\n\x05\x06\0\x02C\x04\x12\x06\xb2\t\x04\xb9\t\x06\n\
    \x13\n\t\x06\0\x02C\x04\xb0\xca\xbc\"\x12\x06\xb2\t\x04\xb9\t\x06\n\r\n\
    \x05\x06\0\x02C\x04\x12\x04\xba\t\x047\n\x10\n\x08\x06\0\x02C\x04\xc3\
    \xf3\x04\x12\x04\xba\t\x047\n\r\n\x05\x06\0\x02C\x04\x12\x04\xbb\t\x04?\
    \n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\0\x12\x04\xbb\t\x04?\n\r\n\x05\x06\
    \0\x02C\x04\x12\x04\xbc\t\x04C\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\x01\
    \x12\x04\xbc\t\x04C\n\r\n\x05\x06\0\x02C\x04\x12\x04\xbd\t\x04A\n\x11\n\
    \t\x06\0\x02C\x04\xc2\xf3\x04\x02\x12\x04\xbd\t\x04A\n\r\n\x05\x06\0\x02\
    C\x04\x12\x04\xbe\t\x04A\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\x03\x12\
    \x04\xbe\t\x04A\n\r\n\x05\x06\0\x02C\x04\x12\x04\xbf\t\x04C\n\x11\n\t\
    \x06\0\x02C\x04\xc2\xf3\x04\x04\x12\x04\xbf\t\x04C\n/\n\x04\x06\0\x02D\
    \x12\x06\xc3\t\x02\xcc\t\x03\x1a\x1f\x20Patch\x20one\x20or\x20more\x20mo\
    dels\x20ids.\n\n\r\n\x05\x06\0\x02D\x01\x12\x04\xc3\t\x06\x13\n\r\n\x05\
    \x06\0\x02D\x02\x12\x04\xc3\t\x15)\n\r\n\x05\x06\0\x02D\x03\x12\x04\xc3\
    \t4F\n\x0f\n\x05\x06\0\x02D\x04\x12\x06\xc4\t\x04\xc7\t\x06\n\x13\n\t\
    \x06\0\x02D\x04\xb0\xca\xbc\"\x12\x06\xc4\t\x04\xc7\t\x06\n\r\n\x05\x06\
    \0\x02D\x04\x12\x04\xc8\t\x047\n\x10\n\x08\x06\0\x02D\x04\xc3\xf3\x04\
    \x12\x04\xc8\t\x047\n\r\n\x05\x06\0\x02D\x04\x12\x04\xc9\t\x04?\n\x11\n\
    \t\x06\0\x02D\x04\xc2\xf3\x04\0\x12\x04\xc9\t\x04?\n\r\n\x05\x06\0\x02D\
    \x04\x12\x04\xca\t\x04A\n\x11\n\t\x06\0\x02D\x04\xc2\xf3\x04\x01\x12\x04\
    \xca\t\x04A\n\r\n\x05\x06\0\x02D\x04\x12\x04\xcb\t\x04A\n\x11\n\t\x06\0\
    \x02D\x04\xc2\xf3\x04\x02\x12\x04\xcb\t\x04A\n(\n\x04\x06\0\x02E\x12\x06\
    \xcf\t\x02\xdd\t\x03\x1a\x18\x20Delete\x20a\x20single\x20model.\n\n\r\n\
    \x05\x06\0\x02E\x01\x12\x04\xcf\t\x06\x11\n\r\n\x05\x06\0\x02E\x02\x12\
    \x04\xcf\t\x13%\n\r\n\x05\x06\0\x02E\x03\x12\x04\xcf\t0P\n\x0f\n\x05\x06\
    \0\x02E\x04\x12\x06\xd0\t\x04\xd5\t\x06\n\x13\n\t\x06\0\x02E\x04\xb0\xca\
    \xbc\"\x12\x06\xd0\t\x04\xd5\t\x06\n\r\n\x05\x06\0\x02E\x04\x12\x04\xd6\
    \t\x047\n\x10\n\x08\x06\0\x02E\x04\xc3\xf3\x04\x12\x04\xd6\t\x047\n\r\n\
    \x05\x06\0\x02E\x04\x12\x04\xd7\t\x04?\n\x11\n\t\x06\0\x02E\x04\xc2\xf3\
    \x04\0\x12\x04\xd7\t\x04?\n\r\n\x05\x06\0\x02E\x04\x12\x04\xd8\t\x04C\n\
    \x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\x01\x12\x04\xd8\t\x04C\n\r\n\x05\x06\
    \0\x02E\x04\x12\x04\xd9\t\x04A\n\x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\x02\
    \x12\x04\xd9\t\x04A\n\r\n\x05\x06\0\x02E\x04\x12\x04\xda\t\x04D\n\x11\n\
    \t\x06\0\x02E\x04\xc2\xf3\x04\x03\x12\x04\xda\t\x04D\n\r\n\x05\x06\0\x02\
    E\x04\x12\x04\xdb\t\x04A\n\x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\x04\x12\
    \x04\xdb\t\x04A\n\r\n\x05\x06\0\x02E\x04\x12\x04\xdc\t\x04D\n\x11\n\t\
    \x06\0\x02E\x04\xc2\xf3\x04\x05\x12\x04\xdc\t\x04D\n8\n\x04\x06\0\x02F\
    \x12\x06\xe0\t\x02\xf0\t\x03\x1a(\x20Delete\x20multiple\x20models\x20in\
    \x20one\x20request.\n\n\r\n\x05\x06\0\x02F\x01\x12\x04\xe0\t\x06\x12\n\r\
    \n\x05\x06\0\x02F\x02\x12\x04\xe0\t\x14'\n\r\n\x05\x06\0\x02F\x03\x12\
    \x04\xe0\t2R\n\x0f\n\x05\x06\0\x02F\x04\x12\x06\xe1\t\x04\xe8\t\x06\n\
    \x13\n\t\x06\0\x02F\x04\xb0\xca\xbc\"\x12\x06\xe1\t\x04\xe8\t\x06\n\r\n\
    \x05\x06\0\x02F\x04\x12\x04\xe9\t\x047\n\x10\n\x08\x06\0\x02F\x04\xc3\
    \xf3\x04\x12\x04\xe9\t\x047\n\r\n\x05\x06\0\x02F\x04\x12\x04\xea\t\x04?\
    \n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\0\x12\x04\xea\t\x04?\n\r\n\x05\x06\
    \0\x02F\x04\x12\x04\xeb\t\x04C\n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\x01\
    \x12\x04\xeb\t\x04C\n\r\n\x05\x06\0\x02F\x04\x12\x04\xec\t\x04A\n\x11\n\
    \t\x06\0\x02F\x04\xc2\xf3\x04\x02\x12\x04\xec\t\x04A\n\r\n\x05\x06\0\x02\
    F\x04\x12\x04\xed\t\x04D\n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\x03\x12\
    \x04\xed\t\x04D\n\r\n\x05\x06\0\x02F\x04\x12\x04\xee\t\x04A\n\x11\n\t\
    \x06\0\x02F\x04\xc2\xf3\x04\x04\x12\x04\xee\t\x04A\n\r\n\x05\x06\0\x02F\
    \x04\x12\x04\xef\t\x04D\n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\x05\x12\x04\
    \xef\t\x04D\n-\n\x04\x06\0\x02G\x12\x06\xf3\t\x02\xff\t\x03\x1a\x1d\x20U\
    pdate\x20model\x20check\x20consents\n\n\r\n\x05\x06\0\x02G\x01\x12\x04\
    \xf3\t\x06\x1d\n\r\n\x05\x06\0\x02G\x02\x12\x04\xf3\t\x1f=\n\r\n\x05\x06\
    \0\x02G\x03\x12\x04\xf3\tHf\n\x0f\n\x05\x06\0\x02G\x04\x12\x06\xf4\t\x04\
    \xfb\t\x06\n\x13\n\t\x06\0\x02G\x04\xb0\xca\xbc\"\x12\x06\xf4\t\x04\xfb\
    \t\x06\n\r\n\x05\x06\0\x02G\x04\x12\x04\xfc\t\x047\n\x10\n\x08\x06\0\x02\
    G\x04\xc3\xf3\x04\x12\x04\xfc\t\x047\n\r\n\x05\x06\0\x02G\x04\x12\x04\
    \xfd\t\x04?\n\x11\n\t\x06\0\x02G\x04\xc2\xf3\x04\0\x12\x04\xfd\t\x04?\n\
    \r\n\x05\x06\0\x02G\x04\x12\x04\xfe\t\x04A\n\x11\n\t\x06\0\x02G\x04\xc2\
    \xf3\x04\x01\x12\x04\xfe\t\x04A\n,\n\x04\x06\0\x02H\x12\x06\x82\n\x02\
    \x8e\n\x03\x1a\x1c\x20Update\x20model\x20toolkits\x20tags\n\n\r\n\x05\
    \x06\0\x02H\x01\x12\x04\x82\n\x06\x18\n\r\n\x05\x06\0\x02H\x02\x12\x04\
    \x82\n\x1a3\n\r\n\x05\x06\0\x02H\x03\x12\x04\x82\n>W\n\x0f\n\x05\x06\0\
    \x02H\x04\x12\x06\x83\n\x04\x8a\n\x06\n\x13\n\t\x06\0\x02H\x04\xb0\xca\
    \xbc\"\x12\x06\x83\n\x04\x8a\n\x06\n\r\n\x05\x06\0\x02H\x04\x12\x04\x8b\
    \n\x047\n\x10\n\x08\x06\0\x02H\x04\xc3\xf3\x04\x12\x04\x8b\n\x047\n\r\n\
    \x05\x06\0\x02H\x04\x12\x04\x8c\n\x04?\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\
    \x04\0\x12\x04\x8c\n\x04?\n\r\n\x05\x06\0\x02H\x04\x12\x04\x8d\n\x04A\n\
    \x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\x01\x12\x04\x8d\n\x04A\n-\n\x04\x06\
    \0\x02I\x12\x06\x91\n\x02\x9d\n\x03\x1a\x1d\x20Update\x20model\x20use_ca\
    ses\x20tags\n\n\r\n\x05\x06\0\x02I\x01\x12\x04\x91\n\x06\x18\n\r\n\x05\
    \x06\0\x02I\x02\x12\x04\x91\n\x1a3\n\r\n\x05\x06\0\x02I\x03\x12\x04\x91\
    \n>W\n\x0f\n\x05\x06\0\x02I\x04\x12\x06\x92\n\x04\x99\n\x06\n\x13\n\t\
    \x06\0\x02I\x04\xb0\xca\xbc\"\x12\x06\x92\n\x04\x99\n\x06\n\r\n\x05\x06\
    \0\x02I\x04\x12\x04\x9a\n\x047\n\x10\n\x08\x06\0\x02I\x04\xc3\xf3\x04\
    \x12\x04\x9a\n\x047\n\r\n\x05\x06\0\x02I\x04\x12\x04\x9b\n\x04?\n\x11\n\
    \t\x06\0\x02I\x04\xc2\xf3\x04\0\x12\x04\x9b\n\x04?\n\r\n\x05\x06\0\x02I\
    \x04\x12\x04\x9c\n\x04A\n\x11\n\t\x06\0\x02I\x04\xc2\xf3\x04\x01\x12\x04\
    \x9c\n\x04A\n-\n\x04\x06\0\x02J\x12\x06\xa0\n\x02\xac\n\x03\x1a\x1d\x20U\
    pdate\x20model\x20languages\x20tags\n\n\r\n\x05\x06\0\x02J\x01\x12\x04\
    \xa0\n\x06\x19\n\r\n\x05\x06\0\x02J\x02\x12\x04\xa0\n\x1b5\n\r\n\x05\x06\
    \0\x02J\x03\x12\x04\xa0\n@Z\n\x0f\n\x05\x06\0\x02J\x04\x12\x06\xa1\n\x04\
    \xa8\n\x06\n\x13\n\t\x06\0\x02J\x04\xb0\xca\xbc\"\x12\x06\xa1\n\x04\xa8\
    \n\x06\n\r\n\x05\x06\0\x02J\x04\x12\x04\xa9\n\x047\n\x10\n\x08\x06\0\x02\
    J\x04\xc3\xf3\x04\x12\x04\xa9\n\x047\n\r\n\x05\x06\0\x02J\x04\x12\x04\
    \xaa\n\x04?\n\x11\n\t\x06\0\x02J\x04\xc2\xf3\x04\0\x12\x04\xaa\n\x04?\n\
    \r\n\x05\x06\0\x02J\x04\x12\x04\xab\n\x04A\n\x11\n\t\x06\0\x02J\x04\xc2\
    \xf3\x04\x01\x12\x04\xab\n\x04A\n\x95\x01\n\x04\x06\0\x02K\x12\x06\xb0\n\
    \x02\xc4\n\x03\x1a\x84\x01\x20Deprecated:\x20Unmaintained\x20and\x20idea\
    lly\x20replaced\x20with\x20usage\x20of\x20datasets\n\x20\x20\x20The\x20s\
    erver\x20may\x20refuse\x20to\x20accept\x20requests\x20to\x20this\x20endp\
    oint.\n\n\r\n\x05\x06\0\x02K\x01\x12\x04\xb0\n\x06\x15\n\r\n\x05\x06\0\
    \x02K\x02\x12\x04\xb0\n\x17-\n\r\n\x05\x06\0\x02K\x03\x12\x04\xb0\n8J\n\
    \x0f\n\x05\x06\0\x02K\x04\x12\x06\xb1\n\x04\xbc\n\x06\n\x13\n\t\x06\0\
    \x02K\x04\xb0\xca\xbc\"\x12\x06\xb1\n\x04\xbc\n\x06\n\r\n\x05\x06\0\x02K\
    \x04\x12\x04\xbd\n\x047\n\x10\n\x08\x06\0\x02K\x04\xc3\xf3\x04\x12\x04\
    \xbd\n\x047\n\r\n\x05\x06\0\x02K\x04\x12\x04\xbe\n\x04?\n\x11\n\t\x06\0\
    \x02K\x04\xc2\xf3\x04\0\x12\x04\xbe\n\x04?\n\r\n\x05\x06\0\x02K\x04\x12\
    \x04\xbf\n\x04F\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\x01\x12\x04\xbf\n\
    \x04F\n\r\n\x05\x06\0\x02K\x04\x12\x04\xc0\n\x04C\n\x11\n\t\x06\0\x02K\
    \x04\xc2\xf3\x04\x02\x12\x04\xc0\n\x04C\n\r\n\x05\x06\0\x02K\x04\x12\x04\
    \xc1\n\x04A\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\x03\x12\x04\xc1\n\x04A\
    \n\r\n\x05\x06\0\x02K\x04\x12\x04\xc2\n\x04A\n\x11\n\t\x06\0\x02K\x04\
    \xc2\xf3\x04\x04\x12\x04\xc2\n\x04A\n\r\n\x05\x06\0\x02K\x04\x12\x04\xc3\
    \n\x04\x1d\n\x0e\n\x06\x06\0\x02K\x04!\x12\x04\xc3\n\x04\x1d\n3\n\x04\
    \x06\0\x02L\x12\x06\xc7\n\x02\xd2\n\x03\x1a#\x20Get\x20a\x20specific\x20\
    model\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02L\x01\x12\x04\xc7\n\x06\
    \x15\n\r\n\x05\x06\0\x02L\x02\x12\x04\xc7\n\x17-\n\r\n\x05\x06\0\x02L\
    \x03\x12\x04\xc7\n8R\n\x0f\n\x05\x06\0\x02L\x04\x12\x06\xc8\n\x04\xcd\n\
    \x06\n\x13\n\t\x06\0\x02L\x04\xb0\xca\xbc\"\x12\x06\xc8\n\x04\xcd\n\x06\
    \n\r\n\x05\x06\0\x02L\x04\x12\x04\xce\n\x047\n\x10\n\x08\x06\0\x02L\x04\
    \xc3\xf3\x04\x12\x04\xce\n\x047\n\r\n\x05\x06\0\x02L\x04\x12\x04\xcf\n\
    \x04?\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\0\x12\x04\xcf\n\x04?\n\r\n\
    \x05\x06\0\x02L\x04\x12\x04\xd0\n\x04C\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\
    \x04\x01\x12\x04\xd0\n\x04C\n\r\n\x05\x06\0\x02L\x04\x12\x04\xd1\n\x04A\
    \n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x02\x12\x04\xd1\n\x04A\n&\n\x04\
    \x06\0\x02M\x12\x06\xd5\n\x02\xe0\n\x03\x1a\x16\x20List\x20all\x20the\
    \x20models.\n\n\r\n\x05\x06\0\x02M\x01\x12\x04\xd5\n\x06\x17\n\r\n\x05\
    \x06\0\x02M\x02\x12\x04\xd5\n\x191\n\r\n\x05\x06\0\x02M\x03\x12\x04\xd5\
    \n<U\n\x0f\n\x05\x06\0\x02M\x04\x12\x06\xd6\n\x04\xdb\n\x06\n\x13\n\t\
    \x06\0\x02M\x04\xb0\xca\xbc\"\x12\x06\xd6\n\x04\xdb\n\x06\n\r\n\x05\x06\
    \0\x02M\x04\x12\x04\xdc\n\x047\n\x10\n\x08\x06\0\x02M\x04\xc3\xf3\x04\
    \x12\x04\xdc\n\x047\n\r\n\x05\x06\0\x02M\x04\x12\x04\xdd\n\x04?\n\x11\n\
    \t\x06\0\x02M\x04\xc2\xf3\x04\0\x12\x04\xdd\n\x04?\n\r\n\x05\x06\0\x02M\
    \x04\x12\x04\xde\n\x04C\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\x01\x12\x04\
    \xde\n\x04C\n\r\n\x05\x06\0\x02M\x04\x12\x04\xdf\n\x04A\n\x11\n\t\x06\0\
    \x02M\x04\xc2\xf3\x04\x02\x12\x04\xdf\n\x04A\n\xf7\x07\n\x04\x06\0\x02N\
    \x12\x06\xf4\n\x02\x89\x0b\x032\xe6\x07\x20TODO(zeiler):\x20in\x20future\
    \x20we\x20can\x20add\x20endpoints\x20like\x20this\x20for\x20listing\x20r\
    unners\x20for\x20a\x20specific\x20model\n\x20List\x20all\x20the\x20runne\
    rs\x20currently\x20handling\x20work\x20for\x20the\x20given\x20model.\n\
    \x20By\x20default\x20this\x20lists\x20the\x20runners\x20available\x20in\
    \x20your\x20account\x20as\x20well\x20as\x20all\x20the\x20orgs\x20you\x20\
    have\n\x20access\x20to.\n\x20Could\x20have\x20RunnerSelector\x20to\x20br\
    eak\x20it\x20down\x20by\x20Nodepool\x20or\x20Deployment.\n\x20Addition\
    \x20filters\x20on\x20the\x20request\x20can\x20select\x20specific\x20user\
    /org\x20to\x20list\x20from\x20or\x20nodepool.\n\x20rpc\x20ListModelVersi\
    onRunners\x20(ListModelVersionRunnersRequest)\x20returns\x20(MultiRunner\
    Response)\x20{\n\x20\x20\x20option\x20(google.api.http)\x20=\x20{\n\x20\
    \x20\x20\x20\x20get:\x20\"/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/models/{model_id}/versions/{version_id}/runners\"\n\x20\x20\
    \x20};\n\x20\x20\x20option\x20(clarifai.auth.util.cl_auth_type)\x20=\x20\
    KeyAuth;\n\x20\x20\x20option\x20(clarifai.auth.util.cl_depending_scopes)\
    \x20=\x20Apps_Get;\n\x20\x20\x20option\x20(clarifai.auth.util.cl_dependi\
    ng_scopes)\x20=\x20Concepts_Get;\n\x20\x20\x20option\x20(clarifai.auth.u\
    til.cl_depending_scopes)\x20=\x20Models_Get;\n\x20\x20\x20option\x20(cla\
    rifai.auth.util.cl_depending_scopes)\x20=\x20Runners_Get;\n\x20}\n\n\r\n\
    \x05\x06\0\x02N\x01\x12\x04\xf4\n\x06#\n\r\n\x05\x06\0\x02N\x02\x12\x04\
    \xf4\n%I\n\r\n\x05\x06\0\x02N\x03\x12\x04\xf4\nTt\n\x0f\n\x05\x06\0\x02N\
    \x04\x12\x06\xf5\n\x04\xfc\n\x06\n\x13\n\t\x06\0\x02N\x04\xb0\xca\xbc\"\
    \x12\x06\xf5\n\x04\xfc\n\x06\n\r\n\x05\x06\0\x02N\x04\x12\x04\xfd\n\x047\
    \n\x10\n\x08\x06\0\x02N\x04\xc3\xf3\x04\x12\x04\xfd\n\x047\n\r\n\x05\x06\
    \0\x02N\x04\x12\x04\xfe\n\x04?\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\0\
    \x12\x04\xfe\n\x04?\n\r\n\x05\x06\0\x02N\x04\x12\x04\xff\n\x04R\n\x11\n\
    \t\x06\0\x02N\x04\xc2\xf3\x04\x01\x12\x04\xff\n\x04R\n\r\n\x05\x06\0\x02\
    N\x04\x12\x04\x80\x0b\x04F\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x02\x12\
    \x04\x80\x0b\x04F\n\r\n\x05\x06\0\x02N\x04\x12\x04\x81\x0b\x04C\n\x11\n\
    \t\x06\0\x02N\x04\xc2\xf3\x04\x03\x12\x04\x81\x0b\x04C\n\r\n\x05\x06\0\
    \x02N\x04\x12\x04\x82\x0b\x04A\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x04\
    \x12\x04\x82\x0b\x04A\n\r\n\x05\x06\0\x02N\x04\x12\x04\x83\x0b\x04A\n\
    \x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x05\x12\x04\x83\x0b\x04A\n\r\n\x05\
    \x06\0\x02N\x04\x12\x04\x84\x0b\x04A\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\
    \x04\x06\x12\x04\x84\x0b\x04A\n\r\n\x05\x06\0\x02N\x04\x12\x04\x85\x0b\
    \x04C\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\x07\x12\x04\x85\x0b\x04C\n\r\
    \n\x05\x06\0\x02N\x04\x12\x04\x86\x0b\x04D\n\x11\n\t\x06\0\x02N\x04\xc2\
    \xf3\x04\x08\x12\x04\x86\x0b\x04D\n\r\n\x05\x06\0\x02N\x04\x12\x04\x87\
    \x0b\x04B\n\x11\n\t\x06\0\x02N\x04\xc2\xf3\x04\t\x12\x04\x87\x0b\x04B\n\
    \r\n\x05\x06\0\x02N\x04\x12\x04\x88\x0b\x04B\n\x11\n\t\x06\0\x02N\x04\
    \xc2\xf3\x04\n\x12\x04\x88\x0b\x04B\n\x0e\n\x04\x06\0\x02O\x12\x06\x8b\
    \x0b\x02\xa0\x0b\x03\n\r\n\x05\x06\0\x02O\x01\x12\x04\x8b\x0b\x06!\n\r\n\
    \x05\x06\0\x02O\x02\x12\x04\x8b\x0b#E\n\r\n\x05\x06\0\x02O\x03\x12\x04\
    \x8b\x0bPp\n\x0f\n\x05\x06\0\x02O\x04\x12\x06\x8c\x0b\x04\x93\x0b\x06\n\
    \x13\n\t\x06\0\x02O\x04\xb0\xca\xbc\"\x12\x06\x8c\x0b\x04\x93\x0b\x06\n\
    \r\n\x05\x06\0\x02O\x04\x12\x04\x94\x0b\x047\n\x10\n\x08\x06\0\x02O\x04\
    \xc3\xf3\x04\x12\x04\x94\x0b\x047\n\r\n\x05\x06\0\x02O\x04\x12\x04\x95\
    \x0b\x04?\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\0\x12\x04\x95\x0b\x04?\n\
    \r\n\x05\x06\0\x02O\x04\x12\x04\x96\x0b\x04O\n\x11\n\t\x06\0\x02O\x04\
    \xc2\xf3\x04\x01\x12\x04\x96\x0b\x04O\n\r\n\x05\x06\0\x02O\x04\x12\x04\
    \x97\x0b\x04F\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x02\x12\x04\x97\x0b\
    \x04F\n\r\n\x05\x06\0\x02O\x04\x12\x04\x98\x0b\x04C\n\x11\n\t\x06\0\x02O\
    \x04\xc2\xf3\x04\x03\x12\x04\x98\x0b\x04C\n\r\n\x05\x06\0\x02O\x04\x12\
    \x04\x99\x0b\x04A\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x04\x12\x04\x99\
    \x0b\x04A\n\r\n\x05\x06\0\x02O\x04\x12\x04\x9a\x0b\x04A\n\x11\n\t\x06\0\
    \x02O\x04\xc2\xf3\x04\x05\x12\x04\x9a\x0b\x04A\n\r\n\x05\x06\0\x02O\x04\
    \x12\x04\x9b\x0b\x04A\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x06\x12\x04\
    \x9b\x0b\x04A\n\r\n\x05\x06\0\x02O\x04\x12\x04\x9c\x0b\x04C\n\x11\n\t\
    \x06\0\x02O\x04\xc2\xf3\x04\x07\x12\x04\x9c\x0b\x04C\n\r\n\x05\x06\0\x02\
    O\x04\x12\x04\x9d\x0b\x04D\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\x08\x12\
    \x04\x9d\x0b\x04D\n\r\n\x05\x06\0\x02O\x04\x12\x04\x9e\x0b\x04B\n\x11\n\
    \t\x06\0\x02O\x04\xc2\xf3\x04\t\x12\x04\x9e\x0b\x04B\n\r\n\x05\x06\0\x02\
    O\x04\x12\x04\x9f\x0b\x04B\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\x04\n\x12\
    \x04\x9f\x0b\x04B\n*\n\x04\x06\0\x02P\x12\x06\xa3\x0b\x02\xb8\x0b\x03\
    \x1a\x1a\x20PostModelVersionsPublish\n\n\r\n\x05\x06\0\x02P\x01\x12\x04\
    \xa3\x0b\x06\x1e\n\r\n\x05\x06\0\x02P\x02\x12\x04\xa3\x0b\x20?\n\r\n\x05\
    \x06\0\x02P\x03\x12\x04\xa3\x0bJj\n\x0f\n\x05\x06\0\x02P\x04\x12\x06\xa4\
    \x0b\x04\xab\x0b\x06\n\x13\n\t\x06\0\x02P\x04\xb0\xca\xbc\"\x12\x06\xa4\
    \x0b\x04\xab\x0b\x06\n\r\n\x05\x06\0\x02P\x04\x12\x04\xac\x0b\x047\n\x10\
    \n\x08\x06\0\x02P\x04\xc3\xf3\x04\x12\x04\xac\x0b\x047\n\r\n\x05\x06\0\
    \x02P\x04\x12\x04\xad\x0b\x04?\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\0\
    \x12\x04\xad\x0b\x04?\n\r\n\x05\x06\0\x02P\x04\x12\x04\xae\x0b\x04S\n\
    \x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x01\x12\x04\xae\x0b\x04S\n\r\n\x05\
    \x06\0\x02P\x04\x12\x04\xaf\x0b\x04F\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\
    \x04\x02\x12\x04\xaf\x0b\x04F\n\r\n\x05\x06\0\x02P\x04\x12\x04\xb0\x0b\
    \x04C\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x03\x12\x04\xb0\x0b\x04C\n\r\
    \n\x05\x06\0\x02P\x04\x12\x04\xb1\x0b\x04A\n\x11\n\t\x06\0\x02P\x04\xc2\
    \xf3\x04\x04\x12\x04\xb1\x0b\x04A\n\r\n\x05\x06\0\x02P\x04\x12\x04\xb2\
    \x0b\x04A\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x05\x12\x04\xb2\x0b\x04A\
    \n\r\n\x05\x06\0\x02P\x04\x12\x04\xb3\x0b\x04A\n\x11\n\t\x06\0\x02P\x04\
    \xc2\xf3\x04\x06\x12\x04\xb3\x0b\x04A\n\r\n\x05\x06\0\x02P\x04\x12\x04\
    \xb4\x0b\x04C\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x07\x12\x04\xb4\x0b\
    \x04C\n\r\n\x05\x06\0\x02P\x04\x12\x04\xb5\x0b\x04D\n\x11\n\t\x06\0\x02P\
    \x04\xc2\xf3\x04\x08\x12\x04\xb5\x0b\x04D\n\r\n\x05\x06\0\x02P\x04\x12\
    \x04\xb6\x0b\x04B\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\t\x12\x04\xb6\x0b\
    \x04B\n\r\n\x05\x06\0\x02P\x04\x12\x04\xb7\x0b\x04B\n\x11\n\t\x06\0\x02P\
    \x04\xc2\xf3\x04\n\x12\x04\xb7\x0b\x04B\n,\n\x04\x06\0\x02Q\x12\x06\xbb\
    \x0b\x02\xd0\x0b\x03\x1a\x1c\x20PostModelVersionsUnPublish\n\n\r\n\x05\
    \x06\0\x02Q\x01\x12\x04\xbb\x0b\x06\x20\n\r\n\x05\x06\0\x02Q\x02\x12\x04\
    \xbb\x0b\"C\n\r\n\x05\x06\0\x02Q\x03\x12\x04\xbb\x0bNn\n\x0f\n\x05\x06\0\
    \x02Q\x04\x12\x06\xbc\x0b\x04\xc3\x0b\x06\n\x13\n\t\x06\0\x02Q\x04\xb0\
    \xca\xbc\"\x12\x06\xbc\x0b\x04\xc3\x0b\x06\n\r\n\x05\x06\0\x02Q\x04\x12\
    \x04\xc4\x0b\x047\n\x10\n\x08\x06\0\x02Q\x04\xc3\xf3\x04\x12\x04\xc4\x0b\
    \x047\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xc5\x0b\x04?\n\x11\n\t\x06\0\x02Q\
    \x04\xc2\xf3\x04\0\x12\x04\xc5\x0b\x04?\n\r\n\x05\x06\0\x02Q\x04\x12\x04\
    \xc6\x0b\x04V\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x01\x12\x04\xc6\x0b\
    \x04V\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xc7\x0b\x04F\n\x11\n\t\x06\0\x02Q\
    \x04\xc2\xf3\x04\x02\x12\x04\xc7\x0b\x04F\n\r\n\x05\x06\0\x02Q\x04\x12\
    \x04\xc8\x0b\x04C\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x03\x12\x04\xc8\
    \x0b\x04C\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xc9\x0b\x04A\n\x11\n\t\x06\0\
    \x02Q\x04\xc2\xf3\x04\x04\x12\x04\xc9\x0b\x04A\n\r\n\x05\x06\0\x02Q\x04\
    \x12\x04\xca\x0b\x04A\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x05\x12\x04\
    \xca\x0b\x04A\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xcb\x0b\x04A\n\x11\n\t\
    \x06\0\x02Q\x04\xc2\xf3\x04\x06\x12\x04\xcb\x0b\x04A\n\r\n\x05\x06\0\x02\
    Q\x04\x12\x04\xcc\x0b\x04C\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x07\x12\
    \x04\xcc\x0b\x04C\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xcd\x0b\x04D\n\x11\n\
    \t\x06\0\x02Q\x04\xc2\xf3\x04\x08\x12\x04\xcd\x0b\x04D\n\r\n\x05\x06\0\
    \x02Q\x04\x12\x04\xce\x0b\x04B\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\t\
    \x12\x04\xce\x0b\x04B\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xcf\x0b\x04B\n\
    \x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\n\x12\x04\xcf\x0b\x04B\n\x97\x01\n\
    \x04\x06\0\x02R\x12\x06\xd6\x0b\x02\xea\x0b\x03\x1a>\x20Create\x20a\x20n\
    ew\x20model\x20version\x20to\x20trigger\x20training\x20of\x20the\x20mode\
    l.\n2G\x20NOTE:\x20inconsistency:\x20do\x20we\x20want\x20this\x20to\x20r\
    eturn\x20a\x20SingleModelResponse?\n\n\r\n\x05\x06\0\x02R\x01\x12\x04\
    \xd6\x0b\x06\x17\n\r\n\x05\x06\0\x02R\x02\x12\x04\xd6\x0b\x191\n\r\n\x05\
    \x06\0\x02R\x03\x12\x04\xd6\x0b<O\n\x0f\n\x05\x06\0\x02R\x04\x12\x06\xd7\
    \x0b\x04\xde\x0b\x06\n\x13\n\t\x06\0\x02R\x04\xb0\xca\xbc\"\x12\x06\xd7\
    \x0b\x04\xde\x0b\x06\n\r\n\x05\x06\0\x02R\x04\x12\x04\xdf\x0b\x047\n\x10\
    \n\x08\x06\0\x02R\x04\xc3\xf3\x04\x12\x04\xdf\x0b\x047\n\r\n\x05\x06\0\
    \x02R\x04\x12\x04\xe0\x0b\x04?\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\0\
    \x12\x04\xe0\x0b\x04?\n\r\n\x05\x06\0\x02R\x04\x12\x04\xe1\x0b\x04F\n\
    \x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x01\x12\x04\xe1\x0b\x04F\n\r\n\x05\
    \x06\0\x02R\x04\x12\x04\xe2\x0b\x04C\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\
    \x04\x02\x12\x04\xe2\x0b\x04C\n\r\n\x05\x06\0\x02R\x04\x12\x04\xe3\x0b\
    \x04A\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x03\x12\x04\xe3\x0b\x04A\n\r\
    \n\x05\x06\0\x02R\x04\x12\x04\xe4\x0b\x04A\n\x11\n\t\x06\0\x02R\x04\xc2\
    \xf3\x04\x04\x12\x04\xe4\x0b\x04A\n\r\n\x05\x06\0\x02R\x04\x12\x04\xe5\
    \x0b\x04A\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x05\x12\x04\xe5\x0b\x04A\
    \n\r\n\x05\x06\0\x02R\x04\x12\x04\xe6\x0b\x04C\n\x11\n\t\x06\0\x02R\x04\
    \xc2\xf3\x04\x06\x12\x04\xe6\x0b\x04C\n\r\n\x05\x06\0\x02R\x04\x12\x04\
    \xe7\x0b\x04D\nF\n\t\x06\0\x02R\x04\xc2\xf3\x04\x07\x12\x04\xe7\x0b\x04D\
    \"3\x20Needs\x20to\x20check\x20the\x20base\x20workflow\x20to\x20build\
    \x20off\x20of.\n\n\r\n\x05\x06\0\x02R\x04\x12\x04\xe8\x0b\x04B\n\x11\n\t\
    \x06\0\x02R\x04\xc2\xf3\x04\x08\x12\x04\xe8\x0b\x04B\n\r\n\x05\x06\0\x02\
    R\x04\x12\x04\xe9\x0b\x04B\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\t\x12\
    \x04\xe9\x0b\x04B\n$\n\x04\x06\0\x02S\x12\x06\xed\x0b\x02\xf8\x0b\x03\
    \x1a\x14\x20PatchModelVersions\n\n\r\n\x05\x06\0\x02S\x01\x12\x04\xed\
    \x0b\x06\x18\n\r\n\x05\x06\0\x02S\x02\x12\x04\xed\x0b\x1a3\n\r\n\x05\x06\
    \0\x02S\x03\x12\x04\xed\x0b>W\n\x0f\n\x05\x06\0\x02S\x04\x12\x06\xee\x0b\
    \x04\xf1\x0b\x06\n\x13\n\t\x06\0\x02S\x04\xb0\xca\xbc\"\x12\x06\xee\x0b\
    \x04\xf1\x0b\x06\n\r\n\x05\x06\0\x02S\x04\x12\x04\xf2\x0b\x047\n\x10\n\
    \x08\x06\0\x02S\x04\xc3\xf3\x04\x12\x04\xf2\x0b\x047\n\r\n\x05\x06\0\x02\
    S\x04\x12\x04\xf3\x0b\x04?\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\0\x12\
    \x04\xf3\x0b\x04?\n\r\n\x05\x06\0\x02S\x04\x12\x04\xf4\x0b\x04C\n\x11\n\
    \t\x06\0\x02S\x04\xc2\xf3\x04\x01\x12\x04\xf4\x0b\x04C\n\r\n\x05\x06\0\
    \x02S\x04\x12\x04\xf5\x0b\x04A\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x02\
    \x12\x04\xf5\x0b\x04A\n\r\n\x05\x06\0\x02S\x04\x12\x04\xf6\x0b\x04A\n\
    \x11\n\t\x06\0\x02S\x04\xc2\xf3\x04\x03\x12\x04\xf6\x0b\x04A\n\r\n\x05\
    \x06\0\x02S\x04\x12\x04\xf7\x0b\x04C\n\x11\n\t\x06\0\x02S\x04\xc2\xf3\
    \x04\x04\x12\x04\xf7\x0b\x04C\n(\n\x04\x06\0\x02T\x12\x06\xfb\x0b\x02\
    \x89\x0c\x03\x1a\x18\x20Delete\x20a\x20single\x20model.\n\n\r\n\x05\x06\
    \0\x02T\x01\x12\x04\xfb\x0b\x06\x18\n\r\n\x05\x06\0\x02T\x02\x12\x04\xfb\
    \x0b\x1a3\n\r\n\x05\x06\0\x02T\x03\x12\x04\xfb\x0b>^\n\x0f\n\x05\x06\0\
    \x02T\x04\x12\x06\xfc\x0b\x04\x81\x0c\x06\n\x13\n\t\x06\0\x02T\x04\xb0\
    \xca\xbc\"\x12\x06\xfc\x0b\x04\x81\x0c\x06\n\r\n\x05\x06\0\x02T\x04\x12\
    \x04\x82\x0c\x047\n\x10\n\x08\x06\0\x02T\x04\xc3\xf3\x04\x12\x04\x82\x0c\
    \x047\n\r\n\x05\x06\0\x02T\x04\x12\x04\x83\x0c\x04?\n\x11\n\t\x06\0\x02T\
    \x04\xc2\xf3\x04\0\x12\x04\x83\x0c\x04?\n\r\n\x05\x06\0\x02T\x04\x12\x04\
    \x84\x0c\x04C\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x01\x12\x04\x84\x0c\
    \x04C\n\r\n\x05\x06\0\x02T\x04\x12\x04\x85\x0c\x04A\n\x11\n\t\x06\0\x02T\
    \x04\xc2\xf3\x04\x02\x12\x04\x85\x0c\x04A\n\r\n\x05\x06\0\x02T\x04\x12\
    \x04\x86\x0c\x04D\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x03\x12\x04\x86\
    \x0c\x04D\n\r\n\x05\x06\0\x02T\x04\x12\x04\x87\x0c\x04A\n\x11\n\t\x06\0\
    \x02T\x04\xc2\xf3\x04\x04\x12\x04\x87\x0c\x04A\n\r\n\x05\x06\0\x02T\x04\
    \x12\x04\x88\x0c\x04D\n\x11\n\t\x06\0\x02T\x04\xc2\xf3\x04\x05\x12\x04\
    \x88\x0c\x04D\n\x8f\x05\n\x04\x06\0\x02U\x12\x06\x90\x0c\x02\x9b\x0c\x03\
    \x1a\xfe\x04\x20This\x20is\x20a\x20streaming\x20endpoint,\x20the\x20requ\
    est\x20has\x20a\x20field,\x20upload_data,\x20which\x20can\x20either\x20b\
    e\x20the\x20config\x20for\x20the\x20upload\x20or\x20the\x20actual\x20dat\
    a\x20to\x20upload.\n\x20The\x20config\x20must\x20be\x20sent\x20first\x20\
    before\x20the\x20model_bytes\x20can\x20be\x20uploaded.\n\x20Once\x20the\
    \x20config\x20has\x20been\x20sent,\x20the\x20server\x20will\x20respond\
    \x20with\x20a\x20confirmation\x20containing\x20the\x20model_version_id.\
    \n\x20This\x20is\x20so\x20that\x20if\x20your\x20upload\x20is\x20interrup\
    ted,\x20you\x20can\x20resume\x20the\x20upload\x20by\x20sending\x20the\
    \x20config\x20again\x20with\x20the\x20model_version_id\x20specified\x20f\
    or\x20your\x20model_version.\n\x20The\x20actual\x20upload\x20will\x20be\
    \x20done\x20via\x20a\x20multipart\x20upload,\x20the\x20latest\x20success\
    ful\x20part_id\x20will\x20be\x20sent\x20from\x20the\x20server\x20in\x20t\
    he\x20response\x20to\x20the\x20model_bytes.\n\n\r\n\x05\x06\0\x02U\x01\
    \x12\x04\x90\x0c\x06\x1d\n\r\n\x05\x06\0\x02U\x05\x12\x04\x90\x0c\x1f%\n\
    \r\n\x05\x06\0\x02U\x02\x12\x04\x90\x0c&D\n\r\n\x05\x06\0\x02U\x06\x12\
    \x04\x90\x0cOU\n\r\n\x05\x06\0\x02U\x03\x12\x04\x90\x0cVu\n\x0f\n\x05\
    \x06\0\x02U\x04\x12\x06\x91\x0c\x04\x94\x0c\x06\n\x13\n\t\x06\0\x02U\x04\
    \xb0\xca\xbc\"\x12\x06\x91\x0c\x04\x94\x0c\x06\n\r\n\x05\x06\0\x02U\x04\
    \x12\x04\x95\x0c\x047\n\x10\n\x08\x06\0\x02U\x04\xc3\xf3\x04\x12\x04\x95\
    \x0c\x047\n\r\n\x05\x06\0\x02U\x04\x12\x04\x96\x0c\x04?\n\x11\n\t\x06\0\
    \x02U\x04\xc2\xf3\x04\0\x12\x04\x96\x0c\x04?\n\r\n\x05\x06\0\x02U\x04\
    \x12\x04\x97\x0c\x04A\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\x01\x12\x04\
    \x97\x0c\x04A\n\r\n\x05\x06\0\x02U\x04\x12\x04\x98\x0c\x04A\n\x11\n\t\
    \x06\0\x02U\x04\xc2\xf3\x04\x02\x12\x04\x98\x0c\x04A\n\r\n\x05\x06\0\x02\
    U\x04\x12\x04\x99\x0c\x04C\n\x11\n\t\x06\0\x02U\x04\xc2\xf3\x04\x03\x12\
    \x04\x99\x0c\x04C\n\r\n\x05\x06\0\x02U\x04\x12\x04\x9a\x0c\x04D\nF\n\t\
    \x06\0\x02U\x04\xc2\xf3\x04\x04\x12\x04\x9a\x0c\x04D\"3\x20Needs\x20to\
    \x20check\x20the\x20base\x20workflow\x20to\x20build\x20off\x20of.\n\n2\n\
    \x04\x06\0\x02V\x12\x06\xa1\x0c\x02\xad\x0c\x03\x1a\x10\x20Export\x20a\
    \x20model\n2\x10\x20Export\x20a\x20model\n\n\r\n\x05\x06\0\x02V\x01\x12\
    \x04\xa1\x0c\x06\x1c\n\r\n\x05\x06\0\x02V\x02\x12\x04\xa1\x0c\x1e;\n\r\n\
    \x05\x06\0\x02V\x03\x12\x04\xa1\x0cFf\n\x0f\n\x05\x06\0\x02V\x04\x12\x06\
    \xa2\x0c\x04\xa7\x0c\x06\n\x13\n\t\x06\0\x02V\x04\xb0\xca\xbc\"\x12\x06\
    \xa2\x0c\x04\xa7\x0c\x06\n\r\n\x05\x06\0\x02V\x04\x12\x04\xa8\x0c\x047\n\
    \x10\n\x08\x06\0\x02V\x04\xc3\xf3\x04\x12\x04\xa8\x0c\x047\n\r\n\x05\x06\
    \0\x02V\x04\x12\x04\xa9\x0c\x04?\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\0\
    \x12\x04\xa9\x0c\x04?\n\r\n\x05\x06\0\x02V\x04\x12\x04\xaa\x0c\x04A\n\
    \x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\x01\x12\x04\xaa\x0c\x04A\n\r\n\x05\
    \x06\0\x02V\x04\x12\x04\xab\x0c\x04G\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\
    \x04\x02\x12\x04\xab\x0c\x04G\n\r\n\x05\x06\0\x02V\x04\x12\x04\xac\x0c\
    \x04G\n\x11\n\t\x06\0\x02V\x04\xc2\xf3\x04\x03\x12\x04\xac\x0c\x04G\n'\n\
    \x04\x06\0\x02W\x12\x06\xb0\x0c\x02\xbb\x0c\x03\x1a\x17\x20GetModelVersi\
    onExport\n\n\r\n\x05\x06\0\x02W\x01\x12\x04\xb0\x0c\x06\x1b\n\r\n\x05\
    \x06\0\x02W\x02\x12\x04\xb0\x0c\x1d9\n\r\n\x05\x06\0\x02W\x03\x12\x04\
    \xb0\x0cDd\n\x0f\n\x05\x06\0\x02W\x04\x12\x06\xb1\x0c\x04\xb6\x0c\x06\n\
    \x13\n\t\x06\0\x02W\x04\xb0\xca\xbc\"\x12\x06\xb1\x0c\x04\xb6\x0c\x06\n\
    \r\n\x05\x06\0\x02W\x04\x12\x04\xb7\x0c\x047\n\x10\n\x08\x06\0\x02W\x04\
    \xc3\xf3\x04\x12\x04\xb7\x0c\x047\n\r\n\x05\x06\0\x02W\x04\x12\x04\xb8\
    \x0c\x04?\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\0\x12\x04\xb8\x0c\x04?\n\
    \r\n\x05\x06\0\x02W\x04\x12\x04\xb9\x0c\x04A\n\x11\n\t\x06\0\x02W\x04\
    \xc2\xf3\x04\x01\x12\x04\xb9\x0c\x04A\n\r\n\x05\x06\0\x02W\x04\x12\x04\
    \xba\x0c\x04G\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\x02\x12\x04\xba\x0c\
    \x04G\n\xa7\x01\n\x04\x06\0\x02X\x12\x06\xc0\x0c\x02\xce\x0c\x03\x1a\x96\
    \x01\x20Get\x20the\x20evaluation\x20metrics\x20for\x20a\x20model\x20vers\
    ion.\n\x20Deprecated:\x20Use\x20GetEvaluation\x20instead\n\x20\x20\x20Th\
    e\x20server\x20may\x20refuse\x20to\x20accept\x20requests\x20to\x20this\
    \x20endpoint.\n\n\r\n\x05\x06\0\x02X\x01\x12\x04\xc0\x0c\x06\x1c\n\r\n\
    \x05\x06\0\x02X\x02\x12\x04\xc0\x0c\x1e;\n\r\n\x05\x06\0\x02X\x03\x12\
    \x04\xc0\x0cF`\n\x0f\n\x05\x06\0\x02X\x04\x12\x06\xc1\x0c\x04\xc6\x0c\
    \x06\n\x13\n\t\x06\0\x02X\x04\xb0\xca\xbc\"\x12\x06\xc1\x0c\x04\xc6\x0c\
    \x06\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc7\x0c\x047\n\x10\n\x08\x06\0\x02\
    X\x04\xc3\xf3\x04\x12\x04\xc7\x0c\x047\n\r\n\x05\x06\0\x02X\x04\x12\x04\
    \xc8\x0c\x04?\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\0\x12\x04\xc8\x0c\x04\
    ?\n\r\n\x05\x06\0\x02X\x04\x12\x04\xc9\x0c\x04F\n\x11\n\t\x06\0\x02X\x04\
    \xc2\xf3\x04\x01\x12\x04\xc9\x0c\x04F\n\r\n\x05\x06\0\x02X\x04\x12\x04\
    \xca\x0c\x04C\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x02\x12\x04\xca\x0c\
    \x04C\n\r\n\x05\x06\0\x02X\x04\x12\x04\xcb\x0c\x04A\n\x11\n\t\x06\0\x02X\
    \x04\xc2\xf3\x04\x03\x12\x04\xcb\x0c\x04A\n\r\n\x05\x06\0\x02X\x04\x12\
    \x04\xcc\x0c\x04A\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x04\x12\x04\xcc\
    \x0c\x04A\n\r\n\x05\x06\0\x02X\x04\x12\x04\xcd\x0c\x04B\n\x11\n\t\x06\0\
    \x02X\x04\xc2\xf3\x04\x05\x12\x04\xcd\x0c\x04B\nj\n\x04\x06\0\x02Y\x12\
    \x06\xd2\x0c\x02\xe7\x0c\x03\x1aZ\x20Deprecated,\x20use\x20PostEvaluatio\
    ns\x20instead\n\x20Run\x20the\x20evaluation\x20metrics\x20for\x20a\x20mo\
    del\x20version.\n\n\r\n\x05\x06\0\x02Y\x01\x12\x04\xd2\x0c\x06\x1d\n\r\n\
    \x05\x06\0\x02Y\x02\x12\x04\xd2\x0c\x1f=\n\r\n\x05\x06\0\x02Y\x03\x12\
    \x04\xd2\x0cHb\n\x0f\n\x05\x06\0\x02Y\x04\x12\x06\xd3\x0c\x04\xda\x0c\
    \x06\n\x13\n\t\x06\0\x02Y\x04\xb0\xca\xbc\"\x12\x06\xd3\x0c\x04\xda\x0c\
    \x06\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xdb\x0c\x047\n\x10\n\x08\x06\0\x02\
    Y\x04\xc3\xf3\x04\x12\x04\xdb\x0c\x047\n\r\n\x05\x06\0\x02Y\x04\x12\x04\
    \xdc\x0c\x04?\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\0\x12\x04\xdc\x0c\x04\
    ?\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xdd\x0c\x04F\n\x11\n\t\x06\0\x02Y\x04\
    \xc2\xf3\x04\x01\x12\x04\xdd\x0c\x04F\n\r\n\x05\x06\0\x02Y\x04\x12\x04\
    \xde\x0c\x04C\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x02\x12\x04\xde\x0c\
    \x04C\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xdf\x0c\x04A\n\x11\n\t\x06\0\x02Y\
    \x04\xc2\xf3\x04\x03\x12\x04\xdf\x0c\x04A\n\r\n\x05\x06\0\x02Y\x04\x12\
    \x04\xe0\x0c\x04A\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x04\x12\x04\xe0\
    \x0c\x04A\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xe1\x0c\x04A\n\x11\n\t\x06\0\
    \x02Y\x04\xc2\xf3\x04\x05\x12\x04\xe1\x0c\x04A\n\r\n\x05\x06\0\x02Y\x04\
    \x12\x04\xe2\x0c\x04C\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x06\x12\x04\
    \xe2\x0c\x04C\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xe3\x0c\x04>\n\x11\n\t\
    \x06\0\x02Y\x04\xc2\xf3\x04\x07\x12\x04\xe3\x0c\x04>\n\r\n\x05\x06\0\x02\
    Y\x04\x12\x04\xe4\x0c\x04D\nF\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x08\x12\x04\
    \xe4\x0c\x04D\"3\x20Needs\x20to\x20check\x20the\x20base\x20workflow\x20t\
    o\x20build\x20off\x20of.\n\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xe5\x0c\x04B\
    \n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\t\x12\x04\xe5\x0c\x04B\n\r\n\x05\
    \x06\0\x02Y\x04\x12\x04\xe6\x0c\x04B\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\
    \x04\n\x12\x04\xe6\x0c\x04B\n9\n\x04\x06\0\x02Z\x12\x06\xea\x0c\x02\xff\
    \x0c\x03\x1a)\x20Deprecated,\x20use\x20PostEvaluations\x20instead\n\n\r\
    \n\x05\x06\0\x02Z\x01\x12\x04\xea\x0c\x06!\n\r\n\x05\x06\0\x02Z\x02\x12\
    \x04\xea\x0c#E\n\r\n\x05\x06\0\x02Z\x03\x12\x04\xea\x0cPh\n\x0f\n\x05\
    \x06\0\x02Z\x04\x12\x06\xeb\x0c\x04\xf2\x0c\x06\n\x13\n\t\x06\0\x02Z\x04\
    \xb0\xca\xbc\"\x12\x06\xeb\x0c\x04\xf2\x0c\x06\n\r\n\x05\x06\0\x02Z\x04\
    \x12\x04\xf3\x0c\x047\n\x10\n\x08\x06\0\x02Z\x04\xc3\xf3\x04\x12\x04\xf3\
    \x0c\x047\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xf4\x0c\x04?\n\x11\n\t\x06\0\
    \x02Z\x04\xc2\xf3\x04\0\x12\x04\xf4\x0c\x04?\n\r\n\x05\x06\0\x02Z\x04\
    \x12\x04\xf5\x0c\x04F\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x01\x12\x04\
    \xf5\x0c\x04F\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xf6\x0c\x04C\n\x11\n\t\
    \x06\0\x02Z\x04\xc2\xf3\x04\x02\x12\x04\xf6\x0c\x04C\n\r\n\x05\x06\0\x02\
    Z\x04\x12\x04\xf7\x0c\x04A\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x03\x12\
    \x04\xf7\x0c\x04A\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xf8\x0c\x04A\n\x11\n\
    \t\x06\0\x02Z\x04\xc2\xf3\x04\x04\x12\x04\xf8\x0c\x04A\n\r\n\x05\x06\0\
    \x02Z\x04\x12\x04\xf9\x0c\x04A\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x05\
    \x12\x04\xf9\x0c\x04A\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xfa\x0c\x04C\n\
    \x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x06\x12\x04\xfa\x0c\x04C\n\r\n\x05\
    \x06\0\x02Z\x04\x12\x04\xfb\x0c\x04>\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\
    \x04\x07\x12\x04\xfb\x0c\x04>\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xfc\x0c\
    \x04D\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x08\x12\x04\xfc\x0c\x04D\n\r\
    \n\x05\x06\0\x02Z\x04\x12\x04\xfd\x0c\x04B\n\x11\n\t\x06\0\x02Z\x04\xc2\
    \xf3\x04\t\x12\x04\xfd\x0c\x04B\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xfe\x0c\
    \x04B\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\n\x12\x04\xfe\x0c\x04B\ni\n\
    \x04\x06\0\x02[\x12\x06\x83\r\x02\x91\r\x03\x1aY\x20Deprecated,\x20use\
    \x20GetEvaluation\x20instead\n\x20List\x20the\x20evaluation\x20metrics\
    \x20for\x20a\x20model\x20version.\n\n\r\n\x05\x06\0\x02[\x01\x12\x04\x83\
    \r\x06!\n\r\n\x05\x06\0\x02[\x02\x12\x04\x83\r#E\n\r\n\x05\x06\0\x02[\
    \x03\x12\x04\x83\rPh\n\x0f\n\x05\x06\0\x02[\x04\x12\x06\x84\r\x04\x89\r\
    \x06\n\x13\n\t\x06\0\x02[\x04\xb0\xca\xbc\"\x12\x06\x84\r\x04\x89\r\x06\
    \n\r\n\x05\x06\0\x02[\x04\x12\x04\x8a\r\x047\n\x10\n\x08\x06\0\x02[\x04\
    \xc3\xf3\x04\x12\x04\x8a\r\x047\n\r\n\x05\x06\0\x02[\x04\x12\x04\x8b\r\
    \x04?\n\x11\n\t\x06\0\x02[\x04\xc2\xf3\x04\0\x12\x04\x8b\r\x04?\n\r\n\
    \x05\x06\0\x02[\x04\x12\x04\x8c\r\x04F\n\x11\n\t\x06\0\x02[\x04\xc2\xf3\
    \x04\x01\x12\x04\x8c\r\x04F\n\r\n\x05\x06\0\x02[\x04\x12\x04\x8d\r\x04C\
    \n\x11\n\t\x06\0\x02[\x04\xc2\xf3\x04\x02\x12\x04\x8d\r\x04C\n\r\n\x05\
    \x06\0\x02[\x04\x12\x04\x8e\r\x04A\n\x11\n\t\x06\0\x02[\x04\xc2\xf3\x04\
    \x03\x12\x04\x8e\r\x04A\n\r\n\x05\x06\0\x02[\x04\x12\x04\x8f\r\x04A\n\
    \x11\n\t\x06\0\x02[\x04\xc2\xf3\x04\x04\x12\x04\x8f\r\x04A\n\r\n\x05\x06\
    \0\x02[\x04\x12\x04\x90\r\x04B\n\x11\n\t\x06\0\x02[\x04\xc2\xf3\x04\x05\
    \x12\x04\x90\r\x04B\ng\n\x04\x06\0\x02\\\x12\x06\x95\r\x02\xa3\r\x03\x1a\
    W\x20Deprecated,\x20use\x20GetEvaluation\x20instead\n\x20Get\x20an\x20ev\
    aluation\x20metrics\x20for\x20a\x20model\x20version.\n\n\r\n\x05\x06\0\
    \x02\\\x01\x12\x04\x95\r\x06\x1f\n\r\n\x05\x06\0\x02\\\x02\x12\x04\x95\r\
    !A\n\r\n\x05\x06\0\x02\\\x03\x12\x04\x95\rLe\n\x0f\n\x05\x06\0\x02\\\x04\
    \x12\x06\x96\r\x04\x9b\r\x06\n\x13\n\t\x06\0\x02\\\x04\xb0\xca\xbc\"\x12\
    \x06\x96\r\x04\x9b\r\x06\n\r\n\x05\x06\0\x02\\\x04\x12\x04\x9c\r\x047\n\
    \x10\n\x08\x06\0\x02\\\x04\xc3\xf3\x04\x12\x04\x9c\r\x047\n\r\n\x05\x06\
    \0\x02\\\x04\x12\x04\x9d\r\x04?\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\0\
    \x12\x04\x9d\r\x04?\n\r\n\x05\x06\0\x02\\\x04\x12\x04\x9e\r\x04F\n\x11\n\
    \t\x06\0\x02\\\x04\xc2\xf3\x04\x01\x12\x04\x9e\r\x04F\n\r\n\x05\x06\0\
    \x02\\\x04\x12\x04\x9f\r\x04C\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\x02\
    \x12\x04\x9f\r\x04C\n\r\n\x05\x06\0\x02\\\x04\x12\x04\xa0\r\x04A\n\x11\n\
    \t\x06\0\x02\\\x04\xc2\xf3\x04\x03\x12\x04\xa0\r\x04A\n\r\n\x05\x06\0\
    \x02\\\x04\x12\x04\xa1\r\x04A\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\x04\
    \x12\x04\xa1\r\x04A\n\r\n\x05\x06\0\x02\\\x04\x12\x04\xa2\r\x04B\n\x11\n\
    \t\x06\0\x02\\\x04\xc2\xf3\x04\x05\x12\x04\xa2\r\x04B\n\x0e\n\x04\x06\0\
    \x02]\x12\x06\xa5\r\x02\xba\r\x03\n\r\n\x05\x06\0\x02]\x01\x12\x04\xa5\r\
    \x06\x15\n\r\n\x05\x06\0\x02]\x02\x12\x04\xa5\r\x17-\n\r\n\x05\x06\0\x02\
    ]\x03\x12\x04\xa5\r8P\n\x0f\n\x05\x06\0\x02]\x04\x12\x06\xa6\r\x04\xad\r\
    \x06\n\x13\n\t\x06\0\x02]\x04\xb0\xca\xbc\"\x12\x06\xa6\r\x04\xad\r\x06\
    \n\r\n\x05\x06\0\x02]\x04\x12\x04\xae\r\x047\n\x10\n\x08\x06\0\x02]\x04\
    \xc3\xf3\x04\x12\x04\xae\r\x047\n\r\n\x05\x06\0\x02]\x04\x12\x04\xaf\r\
    \x04?\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\0\x12\x04\xaf\r\x04?\n\r\n\
    \x05\x06\0\x02]\x04\x12\x04\xb0\r\x04F\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\
    \x04\x01\x12\x04\xb0\r\x04F\n\r\n\x05\x06\0\x02]\x04\x12\x04\xb1\r\x04C\
    \n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\x02\x12\x04\xb1\r\x04C\n\r\n\x05\
    \x06\0\x02]\x04\x12\x04\xb2\r\x04A\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\
    \x03\x12\x04\xb2\r\x04A\n\r\n\x05\x06\0\x02]\x04\x12\x04\xb3\r\x04A\n\
    \x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\x04\x12\x04\xb3\r\x04A\n\r\n\x05\x06\
    \0\x02]\x04\x12\x04\xb4\r\x04A\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\x05\
    \x12\x04\xb4\r\x04A\n\r\n\x05\x06\0\x02]\x04\x12\x04\xb5\r\x04C\n\x11\n\
    \t\x06\0\x02]\x04\xc2\xf3\x04\x06\x12\x04\xb5\r\x04C\n\r\n\x05\x06\0\x02\
    ]\x04\x12\x04\xb6\r\x04>\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\x07\x12\
    \x04\xb6\r\x04>\n\r\n\x05\x06\0\x02]\x04\x12\x04\xb7\r\x04D\n\x11\n\t\
    \x06\0\x02]\x04\xc2\xf3\x04\x08\x12\x04\xb7\r\x04D\n\r\n\x05\x06\0\x02]\
    \x04\x12\x04\xb8\r\x04B\n\x11\n\t\x06\0\x02]\x04\xc2\xf3\x04\t\x12\x04\
    \xb8\r\x04B\n\r\n\x05\x06\0\x02]\x04\x12\x04\xb9\r\x04B\n\x11\n\t\x06\0\
    \x02]\x04\xc2\xf3\x04\n\x12\x04\xb9\r\x04B\n\x0e\n\x04\x06\0\x02^\x12\
    \x06\xbc\r\x02\xcd\r\x03\n\r\n\x05\x06\0\x02^\x01\x12\x04\xbc\r\x06\x15\
    \n\r\n\x05\x06\0\x02^\x02\x12\x04\xbc\r\x17-\n\r\n\x05\x06\0\x02^\x03\
    \x12\x04\xbc\r8P\n\x0f\n\x05\x06\0\x02^\x04\x12\x06\xbd\r\x04\xc5\r\x06\
    \n\x13\n\t\x06\0\x02^\x04\xb0\xca\xbc\"\x12\x06\xbd\r\x04\xc5\r\x06\n\r\
    \n\x05\x06\0\x02^\x04\x12\x04\xc6\r\x047\n\x10\n\x08\x06\0\x02^\x04\xc3\
    \xf3\x04\x12\x04\xc6\r\x047\n\r\n\x05\x06\0\x02^\x04\x12\x04\xc7\r\x04?\
    \n\x11\n\t\x06\0\x02^\x04\xc2\xf3\x04\0\x12\x04\xc7\r\x04?\n\r\n\x05\x06\
    \0\x02^\x04\x12\x04\xc8\r\x04F\n\x11\n\t\x06\0\x02^\x04\xc2\xf3\x04\x01\
    \x12\x04\xc8\r\x04F\n\r\n\x05\x06\0\x02^\x04\x12\x04\xc9\r\x04C\n\x11\n\
    \t\x06\0\x02^\x04\xc2\xf3\x04\x02\x12\x04\xc9\r\x04C\n\r\n\x05\x06\0\x02\
    ^\x04\x12\x04\xca\r\x04A\n\x11\n\t\x06\0\x02^\x04\xc2\xf3\x04\x03\x12\
    \x04\xca\r\x04A\n\r\n\x05\x06\0\x02^\x04\x12\x04\xcb\r\x04A\n\x11\n\t\
    \x06\0\x02^\x04\xc2\xf3\x04\x04\x12\x04\xcb\r\x04A\n\r\n\x05\x06\0\x02^\
    \x04\x12\x04\xcc\r\x04B\n\x11\n\t\x06\0\x02^\x04\xc2\xf3\x04\x05\x12\x04\
    \xcc\r\x04B\n\x0e\n\x04\x06\0\x02_\x12\x06\xcf\r\x02\xdd\r\x03\n\r\n\x05\
    \x06\0\x02_\x01\x12\x04\xcf\r\x06\x13\n\r\n\x05\x06\0\x02_\x02\x12\x04\
    \xcf\r\x15)\n\r\n\x05\x06\0\x02_\x03\x12\x04\xcf\r4M\n\x0f\n\x05\x06\0\
    \x02_\x04\x12\x06\xd0\r\x04\xd5\r\x06\n\x13\n\t\x06\0\x02_\x04\xb0\xca\
    \xbc\"\x12\x06\xd0\r\x04\xd5\r\x06\n\r\n\x05\x06\0\x02_\x04\x12\x04\xd6\
    \r\x047\n\x10\n\x08\x06\0\x02_\x04\xc3\xf3\x04\x12\x04\xd6\r\x047\n\r\n\
    \x05\x06\0\x02_\x04\x12\x04\xd7\r\x04?\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\
    \x04\0\x12\x04\xd7\r\x04?\n\r\n\x05\x06\0\x02_\x04\x12\x04\xd8\r\x04F\n\
    \x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x01\x12\x04\xd8\r\x04F\n\r\n\x05\x06\
    \0\x02_\x04\x12\x04\xd9\r\x04C\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x02\
    \x12\x04\xd9\r\x04C\n\r\n\x05\x06\0\x02_\x04\x12\x04\xda\r\x04A\n\x11\n\
    \t\x06\0\x02_\x04\xc2\xf3\x04\x03\x12\x04\xda\r\x04A\n\r\n\x05\x06\0\x02\
    _\x04\x12\x04\xdb\r\x04A\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\x04\x12\
    \x04\xdb\r\x04A\n\r\n\x05\x06\0\x02_\x04\x12\x04\xdc\r\x04B\n\x11\n\t\
    \x06\0\x02_\x04\xc2\xf3\x04\x05\x12\x04\xdc\r\x04B\nG\n\x04\x06\0\x02`\
    \x12\x06\xe0\r\x02\xea\r\x03\x1a7\x20Lists\x20model\x20references\x20tie\
    d\x20to\x20a\x20particular\x20model\x20id.\n\n\r\n\x05\x06\0\x02`\x01\
    \x12\x04\xe0\r\x06\x19\n\r\n\x05\x06\0\x02`\x02\x12\x04\xe0\r\x1b5\n\r\n\
    \x05\x06\0\x02`\x03\x12\x04\xe0\r@[\n\x0f\n\x05\x06\0\x02`\x04\x12\x06\
    \xe1\r\x04\xe6\r\x06\n\x13\n\t\x06\0\x02`\x04\xb0\xca\xbc\"\x12\x06\xe1\
    \r\x04\xe6\r\x06\n\r\n\x05\x06\0\x02`\x04\x12\x04\xe7\r\x047\n\x10\n\x08\
    \x06\0\x02`\x04\xc3\xf3\x04\x12\x04\xe7\r\x047\n\r\n\x05\x06\0\x02`\x04\
    \x12\x04\xe8\r\x04?\n\x11\n\t\x06\0\x02`\x04\xc2\xf3\x04\0\x12\x04\xe8\r\
    \x04?\n\r\n\x05\x06\0\x02`\x04\x12\x04\xe9\r\x04A\n\x11\n\t\x06\0\x02`\
    \x04\xc2\xf3\x04\x01\x12\x04\xe9\r\x04A\n-\n\x04\x06\0\x02a\x12\x06\xef\
    \r\x02\xf9\r\x03\x1a\x1d\x20GetModelVersionInputExample\n\n\r\n\x05\x06\
    \0\x02a\x01\x12\x04\xef\r\x06!\n\r\n\x05\x06\0\x02a\x02\x12\x04\xef\r#E\
    \n\r\n\x05\x06\0\x02a\x03\x12\x04\xef\rPv\n\x0f\n\x05\x06\0\x02a\x04\x12\
    \x06\xf0\r\x04\xf5\r\x06\n\x13\n\t\x06\0\x02a\x04\xb0\xca\xbc\"\x12\x06\
    \xf0\r\x04\xf5\r\x06\n\r\n\x05\x06\0\x02a\x04\x12\x04\xf6\r\x047\n\x10\n\
    \x08\x06\0\x02a\x04\xc3\xf3\x04\x12\x04\xf6\r\x047\n\r\n\x05\x06\0\x02a\
    \x04\x12\x04\xf7\r\x04?\n\x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\0\x12\x04\
    \xf7\r\x04?\n\r\n\x05\x06\0\x02a\x04\x12\x04\xf8\r\x04A\n\x11\n\t\x06\0\
    \x02a\x04\xc2\xf3\x04\x01\x12\x04\xf8\r\x04A\n/\n\x04\x06\0\x02b\x12\x06\
    \xfc\r\x02\x86\x0e\x03\x1a\x1f\x20ListModelVersionInputExamples\n\n\r\n\
    \x05\x06\0\x02b\x01\x12\x04\xfc\r\x06#\n\r\n\x05\x06\0\x02b\x02\x12\x04\
    \xfc\r%I\n\r\n\x05\x06\0\x02b\x03\x12\x04\xfc\rTy\n\x0f\n\x05\x06\0\x02b\
    \x04\x12\x06\xfd\r\x04\x82\x0e\x06\n\x13\n\t\x06\0\x02b\x04\xb0\xca\xbc\
    \"\x12\x06\xfd\r\x04\x82\x0e\x06\n\r\n\x05\x06\0\x02b\x04\x12\x04\x83\
    \x0e\x047\n\x10\n\x08\x06\0\x02b\x04\xc3\xf3\x04\x12\x04\x83\x0e\x047\n\
    \r\n\x05\x06\0\x02b\x04\x12\x04\x84\x0e\x04?\n\x11\n\t\x06\0\x02b\x04\
    \xc2\xf3\x04\0\x12\x04\x84\x0e\x04?\n\r\n\x05\x06\0\x02b\x04\x12\x04\x85\
    \x0e\x04A\n\x11\n\t\x06\0\x02b\x04\xc2\xf3\x04\x01\x12\x04\x85\x0e\x04A\
    \n\xba\x01\n\x04\x06\0\x02c\x12\x06\x9d\x0e\x02\xa8\x0e\x03\x1a&\x20Get\
    \x20a\x20specific\x20workflow\x20from\x20an\x20app.\n2'/////////////////\
    /////////////////////\n2Y//////////////////////////////////////\n\x20Wor\
    kflows\n//////////////////////////////////////\n\n\r\n\x05\x06\0\x02c\
    \x01\x12\x04\x9d\x0e\x06\x11\n\r\n\x05\x06\0\x02c\x02\x12\x04\x9d\x0e\
    \x13%\n\r\n\x05\x06\0\x02c\x03\x12\x04\x9d\x0e0F\n\x0f\n\x05\x06\0\x02c\
    \x04\x12\x06\x9e\x0e\x04\xa3\x0e\x06\n\x13\n\t\x06\0\x02c\x04\xb0\xca\
    \xbc\"\x12\x06\x9e\x0e\x04\xa3\x0e\x06\n\r\n\x05\x06\0\x02c\x04\x12\x04\
    \xa4\x0e\x047\n\x10\n\x08\x06\0\x02c\x04\xc3\xf3\x04\x12\x04\xa4\x0e\x04\
    7\n\r\n\x05\x06\0\x02c\x04\x12\x04\xa5\x0e\x04?\n\x11\n\t\x06\0\x02c\x04\
    \xc2\xf3\x04\0\x12\x04\xa5\x0e\x04?\n\r\n\x05\x06\0\x02c\x04\x12\x04\xa6\
    \x0e\x04A\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x01\x12\x04\xa6\x0e\x04A\
    \n\r\n\x05\x06\0\x02c\x04\x12\x04\xa7\x0e\x04D\n\x11\n\t\x06\0\x02c\x04\
    \xc2\xf3\x04\x02\x12\x04\xa7\x0e\x04D\n)\n\x04\x06\0\x02d\x12\x06\xab\
    \x0e\x02\xb9\x0e\x03\x1a\x19\x20List\x20all\x20the\x20workflows.\n\n\r\n\
    \x05\x06\0\x02d\x01\x12\x04\xab\x0e\x06\x13\n\r\n\x05\x06\0\x02d\x02\x12\
    \x04\xab\x0e\x15)\n\r\n\x05\x06\0\x02d\x03\x12\x04\xab\x0e4I\n\x0f\n\x05\
    \x06\0\x02d\x04\x12\x06\xac\x0e\x04\xb4\x0e\x06\n\x13\n\t\x06\0\x02d\x04\
    \xb0\xca\xbc\"\x12\x06\xac\x0e\x04\xb4\x0e\x06\n\r\n\x05\x06\0\x02d\x04\
    \x12\x04\xb5\x0e\x047\n\x10\n\x08\x06\0\x02d\x04\xc3\xf3\x04\x12\x04\xb5\
    \x0e\x047\n\r\n\x05\x06\0\x02d\x04\x12\x04\xb6\x0e\x04?\n\x11\n\t\x06\0\
    \x02d\x04\xc2\xf3\x04\0\x12\x04\xb6\x0e\x04?\n\r\n\x05\x06\0\x02d\x04\
    \x12\x04\xb7\x0e\x04A\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\x01\x12\x04\
    \xb7\x0e\x04A\n\r\n\x05\x06\0\x02d\x04\x12\x04\xb8\x0e\x04D\n\x11\n\t\
    \x06\0\x02d\x04\xc2\xf3\x04\x02\x12\x04\xb8\x0e\x04D\n\x84\x03\n\x04\x06\
    \0\x02e\x12\x06\xc2\x0e\x02\xd0\x0e\x03\x1a\xf3\x02\x20Add\x20a\x20workf\
    low\x20to\x20an\x20app.\n\x20Note(zeiler):\x20the\x20order\x20of\x20the\
    \x20workflows\x20that\x20are\x20returned\x20from\x20this\x20endpoint\n\
    \x20may\x20be\x20different\x20than\x20the\x20order\x20in\x20which\x20the\
    \x20user\x20provides\x20them.\x20This\x20is\x20because\n\x20we\x20reorde\
    r\x20by\x20a\x20sort\x20that\x20optimizes\x20for\x20performance\x20of\
    \x20the\x20graph\x20and\x20its\x20dependencies.\n\x20When\x20using\x20th\
    e\x20workflow\x20in\x20any\x20future\x20call\x20the\x20order\x20returned\
    \x20by\x20this\x20endpoint\n\x20will\x20be\x20used.\n\n\r\n\x05\x06\0\
    \x02e\x01\x12\x04\xc2\x0e\x06\x13\n\r\n\x05\x06\0\x02e\x02\x12\x04\xc2\
    \x0e\x15)\n\r\n\x05\x06\0\x02e\x03\x12\x04\xc2\x0e4I\n\x0f\n\x05\x06\0\
    \x02e\x04\x12\x06\xc3\x0e\x04\xca\x0e\x06\n\x13\n\t\x06\0\x02e\x04\xb0\
    \xca\xbc\"\x12\x06\xc3\x0e\x04\xca\x0e\x06\n\r\n\x05\x06\0\x02e\x04\x12\
    \x04\xcb\x0e\x047\n\x10\n\x08\x06\0\x02e\x04\xc3\xf3\x04\x12\x04\xcb\x0e\
    \x047\n\r\n\x05\x06\0\x02e\x04\x12\x04\xcc\x0e\x04?\n\x11\n\t\x06\0\x02e\
    \x04\xc2\xf3\x04\0\x12\x04\xcc\x0e\x04?\n\r\n\x05\x06\0\x02e\x04\x12\x04\
    \xcd\x0e\x04A\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\x01\x12\x04\xcd\x0e\
    \x04A\n\r\n\x05\x06\0\x02e\x04\x12\x04\xce\x0e\x04D\n\x11\n\t\x06\0\x02e\
    \x04\xc2\xf3\x04\x02\x12\x04\xce\x0e\x04D\n\r\n\x05\x06\0\x02e\x04\x12\
    \x04\xcf\x0e\x04D\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\x03\x12\x04\xcf\
    \x0e\x04D\n.\n\x04\x06\0\x02f\x12\x06\xd3\x0e\x02\xe1\x0e\x03\x1a\x1e\
    \x20Patch\x20one\x20or\x20more\x20workflows.\n\n\r\n\x05\x06\0\x02f\x01\
    \x12\x04\xd3\x0e\x06\x14\n\r\n\x05\x06\0\x02f\x02\x12\x04\xd3\x0e\x16+\n\
    \r\n\x05\x06\0\x02f\x03\x12\x04\xd3\x0e6K\n\x0f\n\x05\x06\0\x02f\x04\x12\
    \x06\xd4\x0e\x04\xdb\x0e\x06\n\x13\n\t\x06\0\x02f\x04\xb0\xca\xbc\"\x12\
    \x06\xd4\x0e\x04\xdb\x0e\x06\n\r\n\x05\x06\0\x02f\x04\x12\x04\xdc\x0e\
    \x047\n\x10\n\x08\x06\0\x02f\x04\xc3\xf3\x04\x12\x04\xdc\x0e\x047\n\r\n\
    \x05\x06\0\x02f\x04\x12\x04\xdd\x0e\x04?\n\x11\n\t\x06\0\x02f\x04\xc2\
    \xf3\x04\0\x12\x04\xdd\x0e\x04?\n\r\n\x05\x06\0\x02f\x04\x12\x04\xde\x0e\
    \x04A\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x01\x12\x04\xde\x0e\x04A\n\r\
    \n\x05\x06\0\x02f\x04\x12\x04\xdf\x0e\x04D\n\x11\n\t\x06\0\x02f\x04\xc2\
    \xf3\x04\x02\x12\x04\xdf\x0e\x04D\n\r\n\x05\x06\0\x02f\x04\x12\x04\xe0\
    \x0e\x04D\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x03\x12\x04\xe0\x0e\x04D\
    \n2\n\x04\x06\0\x02g\x12\x06\xe4\x0e\x02\xed\x0e\x03\x1a\"\x20Patch\x20o\
    ne\x20or\x20more\x20workflows\x20ids.\n\n\r\n\x05\x06\0\x02g\x01\x12\x04\
    \xe4\x0e\x06\x16\n\r\n\x05\x06\0\x02g\x02\x12\x04\xe4\x0e\x18/\n\r\n\x05\
    \x06\0\x02g\x03\x12\x04\xe4\x0e:O\n\x0f\n\x05\x06\0\x02g\x04\x12\x06\xe5\
    \x0e\x04\xe8\x0e\x06\n\x13\n\t\x06\0\x02g\x04\xb0\xca\xbc\"\x12\x06\xe5\
    \x0e\x04\xe8\x0e\x06\n\r\n\x05\x06\0\x02g\x04\x12\x04\xe9\x0e\x047\n\x10\
    \n\x08\x06\0\x02g\x04\xc3\xf3\x04\x12\x04\xe9\x0e\x047\n\r\n\x05\x06\0\
    \x02g\x04\x12\x04\xea\x0e\x04?\n\x11\n\t\x06\0\x02g\x04\xc2\xf3\x04\0\
    \x12\x04\xea\x0e\x04?\n\r\n\x05\x06\0\x02g\x04\x12\x04\xeb\x0e\x04D\n\
    \x11\n\t\x06\0\x02g\x04\xc2\xf3\x04\x01\x12\x04\xeb\x0e\x04D\n\r\n\x05\
    \x06\0\x02g\x04\x12\x04\xec\x0e\x04D\n\x11\n\t\x06\0\x02g\x04\xc2\xf3\
    \x04\x02\x12\x04\xec\x0e\x04D\n+\n\x04\x06\0\x02h\x12\x06\xf0\x0e\x02\
    \xfc\x0e\x03\x1a\x1b\x20Delete\x20a\x20single\x20workflow.\n\n\r\n\x05\
    \x06\0\x02h\x01\x12\x04\xf0\x0e\x06\x14\n\r\n\x05\x06\0\x02h\x02\x12\x04\
    \xf0\x0e\x16+\n\r\n\x05\x06\0\x02h\x03\x12\x04\xf0\x0e6V\n\x0f\n\x05\x06\
    \0\x02h\x04\x12\x06\xf1\x0e\x04\xf6\x0e\x06\n\x13\n\t\x06\0\x02h\x04\xb0\
    \xca\xbc\"\x12\x06\xf1\x0e\x04\xf6\x0e\x06\n\r\n\x05\x06\0\x02h\x04\x12\
    \x04\xf7\x0e\x047\n\x10\n\x08\x06\0\x02h\x04\xc3\xf3\x04\x12\x04\xf7\x0e\
    \x047\n\r\n\x05\x06\0\x02h\x04\x12\x04\xf8\x0e\x04?\n\x11\n\t\x06\0\x02h\
    \x04\xc2\xf3\x04\0\x12\x04\xf8\x0e\x04?\n\r\n\x05\x06\0\x02h\x04\x12\x04\
    \xf9\x0e\x04D\n\x11\n\t\x06\0\x02h\x04\xc2\xf3\x04\x01\x12\x04\xf9\x0e\
    \x04D\n\r\n\x05\x06\0\x02h\x04\x12\x04\xfa\x0e\x04G\n\x11\n\t\x06\0\x02h\
    \x04\xc2\xf3\x04\x02\x12\x04\xfa\x0e\x04G\n\r\n\x05\x06\0\x02h\x04\x12\
    \x04\xfb\x0e\x04D\n\x11\n\t\x06\0\x02h\x04\xc2\xf3\x04\x03\x12\x04\xfb\
    \x0e\x04D\n;\n\x04\x06\0\x02i\x12\x06\xff\x0e\x02\x8d\x0f\x03\x1a+\x20De\
    lete\x20multiple\x20workflows\x20in\x20one\x20request.\n\n\r\n\x05\x06\0\
    \x02i\x01\x12\x04\xff\x0e\x06\x15\n\r\n\x05\x06\0\x02i\x02\x12\x04\xff\
    \x0e\x17-\n\r\n\x05\x06\0\x02i\x03\x12\x04\xff\x0e8X\n\x0f\n\x05\x06\0\
    \x02i\x04\x12\x06\x80\x0f\x04\x87\x0f\x06\n\x13\n\t\x06\0\x02i\x04\xb0\
    \xca\xbc\"\x12\x06\x80\x0f\x04\x87\x0f\x06\n\r\n\x05\x06\0\x02i\x04\x12\
    \x04\x88\x0f\x047\n\x10\n\x08\x06\0\x02i\x04\xc3\xf3\x04\x12\x04\x88\x0f\
    \x047\n\r\n\x05\x06\0\x02i\x04\x12\x04\x89\x0f\x04?\n\x11\n\t\x06\0\x02i\
    \x04\xc2\xf3\x04\0\x12\x04\x89\x0f\x04?\n\r\n\x05\x06\0\x02i\x04\x12\x04\
    \x8a\x0f\x04D\n\x11\n\t\x06\0\x02i\x04\xc2\xf3\x04\x01\x12\x04\x8a\x0f\
    \x04D\n\r\n\x05\x06\0\x02i\x04\x12\x04\x8b\x0f\x04G\n\x11\n\t\x06\0\x02i\
    \x04\xc2\xf3\x04\x02\x12\x04\x8b\x0f\x04G\n\r\n\x05\x06\0\x02i\x04\x12\
    \x04\x8c\x0f\x04D\n\x11\n\t\x06\0\x02i\x04\xc2\xf3\x04\x03\x12\x04\x8c\
    \x0f\x04D\n+\n\x04\x06\0\x02j\x12\x06\x90\x0f\x02\xa3\x0f\x03\x1a\x1b\
    \x20Predict\x20using\x20a\x20workflow.\n\n\r\n\x05\x06\0\x02j\x01\x12\
    \x04\x90\x0f\x06\x19\n\r\n\x05\x06\0\x02j\x02\x12\x04\x90\x0f\x1b5\n\r\n\
    \x05\x06\0\x02j\x03\x12\x04\x90\x0f@[\n\x0f\n\x05\x06\0\x02j\x04\x12\x06\
    \x91\x0f\x04\x9c\x0f\x06\n\x13\n\t\x06\0\x02j\x04\xb0\xca\xbc\"\x12\x06\
    \x91\x0f\x04\x9c\x0f\x06\n\r\n\x05\x06\0\x02j\x04\x12\x04\x9d\x0f\x047\n\
    \x10\n\x08\x06\0\x02j\x04\xc3\xf3\x04\x12\x04\x9d\x0f\x047\n\r\n\x05\x06\
    \0\x02j\x04\x12\x04\x9e\x0f\x04?\n\x11\n\t\x06\0\x02j\x04\xc2\xf3\x04\0\
    \x12\x04\x9e\x0f\x04?\n\r\n\x05\x06\0\x02j\x04\x12\x04\x9f\x0f\x04A\n\
    \x11\n\t\x06\0\x02j\x04\xc2\xf3\x04\x01\x12\x04\x9f\x0f\x04A\n\r\n\x05\
    \x06\0\x02j\x04\x12\x04\xa0\x0f\x04C\n\x11\n\t\x06\0\x02j\x04\xc2\xf3\
    \x04\x02\x12\x04\xa0\x0f\x04C\n\r\n\x05\x06\0\x02j\x04\x12\x04\xa1\x0f\
    \x04>\n\x11\n\t\x06\0\x02j\x04\xc2\xf3\x04\x03\x12\x04\xa1\x0f\x04>\n\r\
    \n\x05\x06\0\x02j\x04\x12\x04\xa2\x0f\x04D\n\x11\n\t\x06\0\x02j\x04\xc2\
    \xf3\x04\x04\x12\x04\xa2\x0f\x04D\n?\n\x04\x06\0\x02k\x12\x06\xa6\x0f\
    \x02\xb9\x0f\x03\x1a/\x20Compare\x20embeddings\x20distances\x20using\x20\
    a\x20workflow\n\n\r\n\x05\x06\0\x02k\x01\x12\x04\xa6\x0f\x06#\n\r\n\x05\
    \x06\0\x02k\x02\x12\x04\xa6\x0f$H\n\r\n\x05\x06\0\x02k\x03\x12\x04\xa6\
    \x0fSx\n\x0f\n\x05\x06\0\x02k\x04\x12\x06\xa7\x0f\x04\xb2\x0f\x06\n\x13\
    \n\t\x06\0\x02k\x04\xb0\xca\xbc\"\x12\x06\xa7\x0f\x04\xb2\x0f\x06\n\r\n\
    \x05\x06\0\x02k\x04\x12\x04\xb3\x0f\x047\n\x10\n\x08\x06\0\x02k\x04\xc3\
    \xf3\x04\x12\x04\xb3\x0f\x047\n\r\n\x05\x06\0\x02k\x04\x12\x04\xb4\x0f\
    \x04?\n\x11\n\t\x06\0\x02k\x04\xc2\xf3\x04\0\x12\x04\xb4\x0f\x04?\n\r\n\
    \x05\x06\0\x02k\x04\x12\x04\xb5\x0f\x04A\n\x11\n\t\x06\0\x02k\x04\xc2\
    \xf3\x04\x01\x12\x04\xb5\x0f\x04A\n\r\n\x05\x06\0\x02k\x04\x12\x04\xb6\
    \x0f\x04C\n\x11\n\t\x06\0\x02k\x04\xc2\xf3\x04\x02\x12\x04\xb6\x0f\x04C\
    \n\r\n\x05\x06\0\x02k\x04\x12\x04\xb7\x0f\x04>\n\x11\n\t\x06\0\x02k\x04\
    \xc2\xf3\x04\x03\x12\x04\xb7\x0f\x04>\n\r\n\x05\x06\0\x02k\x04\x12\x04\
    \xb8\x0f\x04D\n\x11\n\t\x06\0\x02k\x04\xc2\xf3\x04\x04\x12\x04\xb8\x0f\
    \x04D\n)\n\x04\x06\0\x02l\x12\x06\xbc\x0f\x02\xc7\x0f\x03\x1a\x19\x20Lis\
    t\x20workflow\x20versions.\n\n\r\n\x05\x06\0\x02l\x01\x12\x04\xbc\x0f\
    \x06\x1a\n\r\n\x05\x06\0\x02l\x02\x12\x04\xbc\x0f\x1c7\n\r\n\x05\x06\0\
    \x02l\x03\x12\x04\xbc\x0fB^\n\x0f\n\x05\x06\0\x02l\x04\x12\x06\xbd\x0f\
    \x04\xc2\x0f\x06\n\x13\n\t\x06\0\x02l\x04\xb0\xca\xbc\"\x12\x06\xbd\x0f\
    \x04\xc2\x0f\x06\n\r\n\x05\x06\0\x02l\x04\x12\x04\xc3\x0f\x047\n\x10\n\
    \x08\x06\0\x02l\x04\xc3\xf3\x04\x12\x04\xc3\x0f\x047\n\r\n\x05\x06\0\x02\
    l\x04\x12\x04\xc4\x0f\x04?\n\x11\n\t\x06\0\x02l\x04\xc2\xf3\x04\0\x12\
    \x04\xc4\x0f\x04?\n\r\n\x05\x06\0\x02l\x04\x12\x04\xc5\x0f\x04A\n\x11\n\
    \t\x06\0\x02l\x04\xc2\xf3\x04\x01\x12\x04\xc5\x0f\x04A\n\r\n\x05\x06\0\
    \x02l\x04\x12\x04\xc6\x0f\x04D\n\x11\n\t\x06\0\x02l\x04\xc2\xf3\x04\x02\
    \x12\x04\xc6\x0f\x04D\n.\n\x04\x06\0\x02m\x12\x06\xca\x0f\x02\xd5\x0f\
    \x03\x1a\x1e\x20Get\x20single\x20workflow\x20version.\n\n\r\n\x05\x06\0\
    \x02m\x01\x12\x04\xca\x0f\x06\x18\n\r\n\x05\x06\0\x02m\x02\x12\x04\xca\
    \x0f\x1a3\n\r\n\x05\x06\0\x02m\x03\x12\x04\xca\x0f>[\n\x0f\n\x05\x06\0\
    \x02m\x04\x12\x06\xcb\x0f\x04\xd0\x0f\x06\n\x13\n\t\x06\0\x02m\x04\xb0\
    \xca\xbc\"\x12\x06\xcb\x0f\x04\xd0\x0f\x06\n\r\n\x05\x06\0\x02m\x04\x12\
    \x04\xd1\x0f\x047\n\x10\n\x08\x06\0\x02m\x04\xc3\xf3\x04\x12\x04\xd1\x0f\
    \x047\n\r\n\x05\x06\0\x02m\x04\x12\x04\xd2\x0f\x04?\n\x11\n\t\x06\0\x02m\
    \x04\xc2\xf3\x04\0\x12\x04\xd2\x0f\x04?\n\r\n\x05\x06\0\x02m\x04\x12\x04\
    \xd3\x0f\x04A\n\x11\n\t\x06\0\x02m\x04\xc2\xf3\x04\x01\x12\x04\xd3\x0f\
    \x04A\n\r\n\x05\x06\0\x02m\x04\x12\x04\xd4\x0f\x04D\n\x11\n\t\x06\0\x02m\
    \x04\xc2\xf3\x04\x02\x12\x04\xd4\x0f\x04D\n+\n\x04\x06\0\x02n\x12\x06\
    \xd8\x0f\x02\xe6\x0f\x03\x1a\x1b\x20Delete\x20workflow\x20versions.\n\n\
    \r\n\x05\x06\0\x02n\x01\x12\x04\xd8\x0f\x06\x1c\n\r\n\x05\x06\0\x02n\x02\
    \x12\x04\xd8\x0f\x1e;\n\r\n\x05\x06\0\x02n\x03\x12\x04\xd8\x0fFf\n\x0f\n\
    \x05\x06\0\x02n\x04\x12\x06\xd9\x0f\x04\xe0\x0f\x06\n\x13\n\t\x06\0\x02n\
    \x04\xb0\xca\xbc\"\x12\x06\xd9\x0f\x04\xe0\x0f\x06\n\r\n\x05\x06\0\x02n\
    \x04\x12\x04\xe1\x0f\x047\n\x10\n\x08\x06\0\x02n\x04\xc3\xf3\x04\x12\x04\
    \xe1\x0f\x047\n\r\n\x05\x06\0\x02n\x04\x12\x04\xe2\x0f\x04?\n\x11\n\t\
    \x06\0\x02n\x04\xc2\xf3\x04\0\x12\x04\xe2\x0f\x04?\n\r\n\x05\x06\0\x02n\
    \x04\x12\x04\xe3\x0f\x04D\n\x11\n\t\x06\0\x02n\x04\xc2\xf3\x04\x01\x12\
    \x04\xe3\x0f\x04D\n\r\n\x05\x06\0\x02n\x04\x12\x04\xe4\x0f\x04D\n\x11\n\
    \t\x06\0\x02n\x04\xc2\xf3\x04\x02\x12\x04\xe4\x0f\x04D\n\r\n\x05\x06\0\
    \x02n\x04\x12\x04\xe5\x0f\x04G\n\x11\n\t\x06\0\x02n\x04\xc2\xf3\x04\x03\
    \x12\x04\xe5\x0f\x04G\n*\n\x04\x06\0\x02o\x12\x06\xe9\x0f\x02\xf7\x0f\
    \x03\x1a\x1a\x20Patch\x20workflow\x20versions.\n\n\r\n\x05\x06\0\x02o\
    \x01\x12\x04\xe9\x0f\x06\x1b\n\r\n\x05\x06\0\x02o\x02\x12\x04\xe9\x0f\
    \x1d9\n\r\n\x05\x06\0\x02o\x03\x12\x04\xe9\x0fD`\n\x0f\n\x05\x06\0\x02o\
    \x04\x12\x06\xea\x0f\x04\xf1\x0f\x06\n\x13\n\t\x06\0\x02o\x04\xb0\xca\
    \xbc\"\x12\x06\xea\x0f\x04\xf1\x0f\x06\n\r\n\x05\x06\0\x02o\x04\x12\x04\
    \xf2\x0f\x047\n\x10\n\x08\x06\0\x02o\x04\xc3\xf3\x04\x12\x04\xf2\x0f\x04\
    7\n\r\n\x05\x06\0\x02o\x04\x12\x04\xf3\x0f\x04?\n\x11\n\t\x06\0\x02o\x04\
    \xc2\xf3\x04\0\x12\x04\xf3\x0f\x04?\n\r\n\x05\x06\0\x02o\x04\x12\x04\xf4\
    \x0f\x04A\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\x01\x12\x04\xf4\x0f\x04A\
    \n\r\n\x05\x06\0\x02o\x04\x12\x04\xf5\x0f\x04D\n\x11\n\t\x06\0\x02o\x04\
    \xc2\xf3\x04\x02\x12\x04\xf5\x0f\x04D\n\r\n\x05\x06\0\x02o\x04\x12\x04\
    \xf6\x0f\x04D\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\x03\x12\x04\xf6\x0f\
    \x04D\n1\n\x04\x06\0\x02p\x12\x06\xff\x0f\x02\x85\x10\x03\x1a!\x20Get\
    \x20a\x20specific\x20key\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02p\
    \x01\x12\x04\xff\x0f\x06\x0c\n\r\n\x05\x06\0\x02p\x02\x12\x04\xff\x0f\
    \x0e\x1b\n\r\n\x05\x06\0\x02p\x03\x12\x04\xff\x0f&7\n\x0f\n\x05\x06\0\
    \x02p\x04\x12\x06\x80\x10\x04\x82\x10\x06\n\x13\n\t\x06\0\x02p\x04\xb0\
    \xca\xbc\"\x12\x06\x80\x10\x04\x82\x10\x06\n\r\n\x05\x06\0\x02p\x04\x12\
    \x04\x83\x10\x047\n\x10\n\x08\x06\0\x02p\x04\xc3\xf3\x04\x12\x04\x83\x10\
    \x047\n\r\n\x05\x06\0\x02p\x04\x12\x04\x84\x10\x04?\n\x11\n\t\x06\0\x02p\
    \x04\xc2\xf3\x04\0\x12\x04\x84\x10\x04?\n$\n\x04\x06\0\x02q\x12\x06\x88\
    \x10\x02\x8e\x10\x03\x1a\x14\x20List\x20all\x20the\x20keys.\n\n\r\n\x05\
    \x06\0\x02q\x01\x12\x04\x88\x10\x06\x0e\n\r\n\x05\x06\0\x02q\x02\x12\x04\
    \x88\x10\x10\x1f\n\r\n\x05\x06\0\x02q\x03\x12\x04\x88\x10*:\n\x0f\n\x05\
    \x06\0\x02q\x04\x12\x06\x89\x10\x04\x8b\x10\x06\n\x13\n\t\x06\0\x02q\x04\
    \xb0\xca\xbc\"\x12\x06\x89\x10\x04\x8b\x10\x06\n\r\n\x05\x06\0\x02q\x04\
    \x12\x04\x8c\x10\x047\n\x10\n\x08\x06\0\x02q\x04\xc3\xf3\x04\x12\x04\x8c\
    \x10\x047\n\r\n\x05\x06\0\x02q\x04\x12\x04\x8d\x10\x04?\n\x11\n\t\x06\0\
    \x02q\x04\xc2\xf3\x04\0\x12\x04\x8d\x10\x04?\n%\n\x04\x06\0\x02r\x12\x06\
    \x91\x10\x02\x98\x10\x03\x1a\x15\x20List\x20keys\x20by\x20app_id\n\n\r\n\
    \x05\x06\0\x02r\x01\x12\x04\x91\x10\x06\x11\n\r\n\x05\x06\0\x02r\x02\x12\
    \x04\x91\x10\x13%\n\r\n\x05\x06\0\x02r\x03\x12\x04\x91\x100@\n\x0f\n\x05\
    \x06\0\x02r\x04\x12\x06\x92\x10\x04\x94\x10\x06\n\x13\n\t\x06\0\x02r\x04\
    \xb0\xca\xbc\"\x12\x06\x92\x10\x04\x94\x10\x06\n\r\n\x05\x06\0\x02r\x04\
    \x12\x04\x95\x10\x047\n\x10\n\x08\x06\0\x02r\x04\xc3\xf3\x04\x12\x04\x95\
    \x10\x047\n\r\n\x05\x06\0\x02r\x04\x12\x04\x96\x10\x04?\n\x11\n\t\x06\0\
    \x02r\x04\xc2\xf3\x04\0\x12\x04\x96\x10\x04?\n\r\n\x05\x06\0\x02r\x04\
    \x12\x04\x97\x10\x04?\n\x11\n\t\x06\0\x02r\x04\xc2\xf3\x04\x01\x12\x04\
    \x97\x10\x04?\n\xc9\x01\n\x04\x06\0\x02s\x12\x06\x9d\x10\x02\xa5\x10\x03\
    \x1a\xb8\x01\x20Search\x20over\x20the\x20keys\x20to\x20find\x20one\x20or\
    \x20more\x20you're\x20looking\x20for.\n\x20This\x20leverage\x20the\x20\"\
    body\"\x20parameter\x20because\x20we\x20also\x20have\x20page\x20and\n\
    \x20per_page\x20as\x20url\x20query\x20param\x20variables\x20in\x20this\
    \x20request.\n\n\r\n\x05\x06\0\x02s\x01\x12\x04\x9d\x10\x06\x0f\n\r\n\
    \x05\x06\0\x02s\x02\x12\x04\x9d\x10\x11!\n\r\n\x05\x06\0\x02s\x03\x12\
    \x04\x9d\x10,L\n\x0f\n\x05\x06\0\x02s\x04\x12\x06\x9e\x10\x04\xa0\x10\
    \x06\n\x13\n\t\x06\0\x02s\x04\xb0\xca\xbc\"\x12\x06\x9e\x10\x04\xa0\x10\
    \x06\n\r\n\x05\x06\0\x02s\x04\x12\x04\xa1\x10\x047\n\x10\n\x08\x06\0\x02\
    s\x04\xc3\xf3\x04\x12\x04\xa1\x10\x047\n\r\n\x05\x06\0\x02s\x04\x12\x04\
    \xa2\x10\x04?\n\x11\n\t\x06\0\x02s\x04\xc2\xf3\x04\0\x12\x04\xa2\x10\x04\
    ?\n\r\n\x05\x06\0\x02s\x04\x12\x04\xa3\x10\x04B\n\x11\n\t\x06\0\x02s\x04\
    \xc2\xf3\x04\x01\x12\x04\xa3\x10\x04B\n\r\n\x05\x06\0\x02s\x04\x12\x04\
    \xa4\x10\x04?\n\x11\n\t\x06\0\x02s\x04\xc2\xf3\x04\x02\x12\x04\xa4\x10\
    \x04?\n&\n\x04\x06\0\x02t\x12\x06\xa8\x10\x02\xb1\x10\x03\x1a\x16\x20Add\
    \x20a\x20key\x20to\x20an\x20app.\n\n\r\n\x05\x06\0\x02t\x01\x12\x04\xa8\
    \x10\x06\x0e\n\r\n\x05\x06\0\x02t\x02\x12\x04\xa8\x10\x10\x1f\n\r\n\x05\
    \x06\0\x02t\x03\x12\x04\xa8\x10*:\n\x0f\n\x05\x06\0\x02t\x04\x12\x06\xa9\
    \x10\x04\xac\x10\x06\n\x13\n\t\x06\0\x02t\x04\xb0\xca\xbc\"\x12\x06\xa9\
    \x10\x04\xac\x10\x06\n\r\n\x05\x06\0\x02t\x04\x12\x04\xad\x10\x047\n\x10\
    \n\x08\x06\0\x02t\x04\xc3\xf3\x04\x12\x04\xad\x10\x047\n\r\n\x05\x06\0\
    \x02t\x04\x12\x04\xae\x10\x04?\n\x11\n\t\x06\0\x02t\x04\xc2\xf3\x04\0\
    \x12\x04\xae\x10\x04?\n\r\n\x05\x06\0\x02t\x04\x12\x04\xaf\x10\x04?\n\
    \x11\n\t\x06\0\x02t\x04\xc2\xf3\x04\x01\x12\x04\xaf\x10\x04?\n\r\n\x05\
    \x06\0\x02t\x04\x12\x04\xb0\x10\x04?\n\x11\n\t\x06\0\x02t\x04\xc2\xf3\
    \x04\x02\x12\x04\xb0\x10\x04?\n)\n\x04\x06\0\x02u\x12\x06\xb4\x10\x02\
    \xbc\x10\x03\x1a\x19\x20Patch\x20one\x20or\x20more\x20keys.\n\n\r\n\x05\
    \x06\0\x02u\x01\x12\x04\xb4\x10\x06\x0f\n\r\n\x05\x06\0\x02u\x02\x12\x04\
    \xb4\x10\x11!\n\r\n\x05\x06\0\x02u\x03\x12\x04\xb4\x10,<\n\x0f\n\x05\x06\
    \0\x02u\x04\x12\x06\xb5\x10\x04\xb8\x10\x06\n\x13\n\t\x06\0\x02u\x04\xb0\
    \xca\xbc\"\x12\x06\xb5\x10\x04\xb8\x10\x06\n\r\n\x05\x06\0\x02u\x04\x12\
    \x04\xb9\x10\x047\n\x10\n\x08\x06\0\x02u\x04\xc3\xf3\x04\x12\x04\xb9\x10\
    \x047\n\r\n\x05\x06\0\x02u\x04\x12\x04\xba\x10\x04?\n\x11\n\t\x06\0\x02u\
    \x04\xc2\xf3\x04\0\x12\x04\xba\x10\x04?\n\r\n\x05\x06\0\x02u\x04\x12\x04\
    \xbb\x10\x04?\n\x11\n\t\x06\0\x02u\x04\xc2\xf3\x04\x01\x12\x04\xbb\x10\
    \x04?\n\xc5\x01\n\x04\x06\0\x02v\x12\x06\xc1\x10\x02\xcc\x10\x03\x1a\xb4\
    \x01\x20API\x20Keys\x20in\x20the\x20public\x20API\x20--\x20request\x20is\
    \x20itself\x20Key\x20authorized,\x20and\x20will\x20tell\n\x20the\x20user\
    \x20the\x20scopes/access\x20of\x20the\x20key/credential\x20they're\x20pr\
    oviding,\x20as\x20computed\x20by\n\x20our\x20authorizer:\n\n\r\n\x05\x06\
    \0\x02v\x01\x12\x04\xc1\x10\x06\x0e\n\r\n\x05\x06\0\x02v\x02\x12\x04\xc1\
    \x10\x10\x1f\n\r\n\x05\x06\0\x02v\x03\x12\x04\xc1\x10*<\n\x0f\n\x05\x06\
    \0\x02v\x04\x12\x06\xc2\x10\x04\xca\x10\x06\n\x13\n\t\x06\0\x02v\x04\xb0\
    \xca\xbc\"\x12\x06\xc2\x10\x04\xca\x10\x06\n\r\n\x05\x06\0\x02v\x04\x12\
    \x04\xcb\x10\x047\n\x10\n\x08\x06\0\x02v\x04\xc3\xf3\x04\x12\x04\xcb\x10\
    \x047\n\x0e\n\x04\x06\0\x02w\x12\x06\xce\x10\x02\xd3\x10\x03\n\r\n\x05\
    \x06\0\x02w\x01\x12\x04\xce\x10\x06\x12\n\r\n\x05\x06\0\x02w\x02\x12\x04\
    \xce\x10\x14'\n\r\n\x05\x06\0\x02w\x03\x12\x04\xce\x102H\n\x0f\n\x05\x06\
    \0\x02w\x04\x12\x06\xcf\x10\x04\xd1\x10\x06\n\x13\n\t\x06\0\x02w\x04\xb0\
    \xca\xbc\"\x12\x06\xcf\x10\x04\xd1\x10\x06\n\r\n\x05\x06\0\x02w\x04\x12\
    \x04\xd2\x10\x047\n\x10\n\x08\x06\0\x02w\x04\xc3\xf3\x04\x12\x04\xd2\x10\
    \x047\n\x0e\n\x04\x06\0\x02x\x12\x06\xd5\x10\x02\xda\x10\x03\n\r\n\x05\
    \x06\0\x02x\x01\x12\x04\xd5\x10\x06\x12\n\r\n\x05\x06\0\x02x\x02\x12\x04\
    \xd5\x10\x14'\n\r\n\x05\x06\0\x02x\x03\x12\x04\xd5\x102H\n\x0f\n\x05\x06\
    \0\x02x\x04\x12\x06\xd6\x10\x04\xd8\x10\x06\n\x13\n\t\x06\0\x02x\x04\xb0\
    \xca\xbc\"\x12\x06\xd6\x10\x04\xd8\x10\x06\n\r\n\x05\x06\0\x02x\x04\x12\
    \x04\xd9\x10\x047\n\x10\n\x08\x06\0\x02x\x04\xc3\xf3\x04\x12\x04\xd9\x10\
    \x047\nA\n\x04\x06\0\x02y\x12\x06\xdd\x10\x02\xe2\x10\x03\x1a1\x20List\
    \x20all\x20auth\x20scopes\x20available\x20to\x20me\x20as\x20a\x20user.\n\
    \n\r\n\x05\x06\0\x02y\x01\x12\x04\xdd\x10\x06\x10\n\r\n\x05\x06\0\x02y\
    \x02\x12\x04\xdd\x10\x12#\n\r\n\x05\x06\0\x02y\x03\x12\x04\xdd\x10.D\n\
    \x0f\n\x05\x06\0\x02y\x04\x12\x06\xde\x10\x04\xe0\x10\x06\n\x13\n\t\x06\
    \0\x02y\x04\xb0\xca\xbc\"\x12\x06\xde\x10\x04\xe0\x10\x06\n\r\n\x05\x06\
    \0\x02y\x04\x12\x04\xe1\x10\x04@\n\x10\n\x08\x06\0\x02y\x04\xc3\xf3\x04\
    \x12\x04\xe1\x10\x04@\n1\n\x04\x06\0\x02z\x12\x06\xe5\x10\x02\xef\x10\
    \x03\x1a!\x20Get\x20a\x20specific\x20app\x20from\x20an\x20app.\n\n\r\n\
    \x05\x06\0\x02z\x01\x12\x04\xe5\x10\x06\x0c\n\r\n\x05\x06\0\x02z\x02\x12\
    \x04\xe5\x10\x0e\x1b\n\r\n\x05\x06\0\x02z\x03\x12\x04\xe5\x10&7\n\x0f\n\
    \x05\x06\0\x02z\x04\x12\x06\xe6\x10\x04\xeb\x10\x06\n\x13\n\t\x06\0\x02z\
    \x04\xb0\xca\xbc\"\x12\x06\xe6\x10\x04\xeb\x10\x06\n\r\n\x05\x06\0\x02z\
    \x04\x12\x04\xec\x10\x047\n\x10\n\x08\x06\0\x02z\x04\xc3\xf3\x04\x12\x04\
    \xec\x10\x047\n\r\n\x05\x06\0\x02z\x04\x12\x04\xed\x10\x04?\n\x11\n\t\
    \x06\0\x02z\x04\xc2\xf3\x04\0\x12\x04\xed\x10\x04?\n\r\n\x05\x06\0\x02z\
    \x04\x12\x04\xee\x10\x04D\n\x11\n\t\x06\0\x02z\x04\xc2\xf3\x04\x01\x12\
    \x04\xee\x10\x04D\n$\n\x04\x06\0\x02{\x12\x06\xf2\x10\x02\xfc\x10\x03\
    \x1a\x14\x20List\x20all\x20the\x20apps.\n\n\r\n\x05\x06\0\x02{\x01\x12\
    \x04\xf2\x10\x06\x0e\n\r\n\x05\x06\0\x02{\x02\x12\x04\xf2\x10\x10\x1f\n\
    \r\n\x05\x06\0\x02{\x03\x12\x04\xf2\x10*:\n\x0f\n\x05\x06\0\x02{\x04\x12\
    \x06\xf3\x10\x04\xf8\x10\x06\n\x13\n\t\x06\0\x02{\x04\xb0\xca\xbc\"\x12\
    \x06\xf3\x10\x04\xf8\x10\x06\n\r\n\x05\x06\0\x02{\x04\x12\x04\xf9\x10\
    \x047\n\x10\n\x08\x06\0\x02{\x04\xc3\xf3\x04\x12\x04\xf9\x10\x047\n\r\n\
    \x05\x06\0\x02{\x04\x12\x04\xfa\x10\x04?\n\x11\n\t\x06\0\x02{\x04\xc2\
    \xf3\x04\0\x12\x04\xfa\x10\x04?\n\r\n\x05\x06\0\x02{\x04\x12\x04\xfb\x10\
    \x04D\n\x11\n\t\x06\0\x02{\x04\xc2\xf3\x04\x01\x12\x04\xfb\x10\x04D\n\
    \xc9\x01\n\x04\x06\0\x02|\x12\x06\x81\x11\x02\x8a\x11\x03\x1a\xb8\x01\
    \x20Search\x20over\x20the\x20apps\x20to\x20find\x20one\x20or\x20more\x20\
    you're\x20looking\x20for.\n\x20This\x20leverage\x20the\x20\"body\"\x20pa\
    rameter\x20because\x20we\x20also\x20have\x20page\x20and\n\x20per_page\
    \x20as\x20url\x20query\x20param\x20variables\x20in\x20this\x20request.\n\
    \n\r\n\x05\x06\0\x02|\x01\x12\x04\x81\x11\x06\x0f\n\r\n\x05\x06\0\x02|\
    \x02\x12\x04\x81\x11\x11!\n\r\n\x05\x06\0\x02|\x03\x12\x04\x81\x11,L\n\
    \x0f\n\x05\x06\0\x02|\x04\x12\x06\x82\x11\x04\x84\x11\x06\n\x13\n\t\x06\
    \0\x02|\x04\xb0\xca\xbc\"\x12\x06\x82\x11\x04\x84\x11\x06\n\r\n\x05\x06\
    \0\x02|\x04\x12\x04\x85\x11\x047\n\x10\n\x08\x06\0\x02|\x04\xc3\xf3\x04\
    \x12\x04\x85\x11\x047\n\r\n\x05\x06\0\x02|\x04\x12\x04\x86\x11\x04?\n\
    \x11\n\t\x06\0\x02|\x04\xc2\xf3\x04\0\x12\x04\x86\x11\x04?\n\r\n\x05\x06\
    \0\x02|\x04\x12\x04\x87\x11\x04B\n\x11\n\t\x06\0\x02|\x04\xc2\xf3\x04\
    \x01\x12\x04\x87\x11\x04B\n\r\n\x05\x06\0\x02|\x04\x12\x04\x88\x11\x04?\
    \n\x11\n\t\x06\0\x02|\x04\xc2\xf3\x04\x02\x12\x04\x88\x11\x04?\n\r\n\x05\
    \x06\0\x02|\x04\x12\x04\x89\x11\x04D\n\x11\n\t\x06\0\x02|\x04\xc2\xf3\
    \x04\x03\x12\x04\x89\x11\x04D\n\xba\x01\n\x04\x06\0\x02}\x12\x06\x8f\x11\
    \x02\x9a\x11\x03\x1a\xa9\x01\x20Add\x20a\x20app\x20to\x20an\x20app.\n\
    \x20This\x20needs\x20to\x20load\x20the\x20default\x20workflow\x20to\x20m\
    ake\x20a\x20copy,\x20validating\x20all\x20the\x20models\x20in\x20it,\x20\
    and\n\x20then\x20writing\x20the\x20new\x20workflow\x20back\x20to\x20this\
    \x20new\x20app.\n\n\r\n\x05\x06\0\x02}\x01\x12\x04\x8f\x11\x06\x0e\n\r\n\
    \x05\x06\0\x02}\x02\x12\x04\x8f\x11\x10\x1f\n\r\n\x05\x06\0\x02}\x03\x12\
    \x04\x8f\x11*:\n\x0f\n\x05\x06\0\x02}\x04\x12\x06\x90\x11\x04\x93\x11\
    \x06\n\x13\n\t\x06\0\x02}\x04\xb0\xca\xbc\"\x12\x06\x90\x11\x04\x93\x11\
    \x06\n\r\n\x05\x06\0\x02}\x04\x12\x04\x94\x11\x047\n\x10\n\x08\x06\0\x02\
    }\x04\xc3\xf3\x04\x12\x04\x94\x11\x047\n\r\n\x05\x06\0\x02}\x04\x12\x04\
    \x95\x11\x04?\n\x11\n\t\x06\0\x02}\x04\xc2\xf3\x04\0\x12\x04\x95\x11\x04\
    ?\n\r\n\x05\x06\0\x02}\x04\x12\x04\x96\x11\x04?\n\x11\n\t\x06\0\x02}\x04\
    \xc2\xf3\x04\x01\x12\x04\x96\x11\x04?\n\r\n\x05\x06\0\x02}\x04\x12\x04\
    \x97\x11\x04A\n\x11\n\t\x06\0\x02}\x04\xc2\xf3\x04\x02\x12\x04\x97\x11\
    \x04A\n\r\n\x05\x06\0\x02}\x04\x12\x04\x98\x11\x04D\n\x11\n\t\x06\0\x02}\
    \x04\xc2\xf3\x04\x03\x12\x04\x98\x11\x04D\n\r\n\x05\x06\0\x02}\x04\x12\
    \x04\x99\x11\x04D\n\x11\n\t\x06\0\x02}\x04\xc2\xf3\x04\x04\x12\x04\x99\
    \x11\x04D\n)\n\x04\x06\0\x02~\x12\x06\x9d\x11\x02\xa5\x11\x03\x1a\x19\
    \x20Patch\x20one\x20or\x20more\x20apps.\n\n\r\n\x05\x06\0\x02~\x01\x12\
    \x04\x9d\x11\x06\x0f\n\r\n\x05\x06\0\x02~\x02\x12\x04\x9d\x11\x11!\n\r\n\
    \x05\x06\0\x02~\x03\x12\x04\x9d\x11,<\n\x0f\n\x05\x06\0\x02~\x04\x12\x06\
    \x9e\x11\x04\xa1\x11\x06\n\x13\n\t\x06\0\x02~\x04\xb0\xca\xbc\"\x12\x06\
    \x9e\x11\x04\xa1\x11\x06\n\r\n\x05\x06\0\x02~\x04\x12\x04\xa2\x11\x047\n\
    \x10\n\x08\x06\0\x02~\x04\xc3\xf3\x04\x12\x04\xa2\x11\x047\n\r\n\x05\x06\
    \0\x02~\x04\x12\x04\xa3\x11\x04?\n\x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\0\
    \x12\x04\xa3\x11\x04?\n\r\n\x05\x06\0\x02~\x04\x12\x04\xa4\x11\x04?\n\
    \x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\x01\x12\x04\xa4\x11\x04?\n!\n\x04\
    \x06\0\x02\x7f\x12\x06\xa8\x11\x02\xb0\x11\x03\x1a\x11\x20Patch\x20apps\
    \x20ids.\n\n\r\n\x05\x06\0\x02\x7f\x01\x12\x04\xa8\x11\x06\x12\n\r\n\x05\
    \x06\0\x02\x7f\x02\x12\x04\xa8\x11\x14'\n\r\n\x05\x06\0\x02\x7f\x03\x12\
    \x04\xa8\x112B\n\x0f\n\x05\x06\0\x02\x7f\x04\x12\x06\xa9\x11\x04\xac\x11\
    \x06\n\x13\n\t\x06\0\x02\x7f\x04\xb0\xca\xbc\"\x12\x06\xa9\x11\x04\xac\
    \x11\x06\n\r\n\x05\x06\0\x02\x7f\x04\x12\x04\xad\x11\x047\n\x10\n\x08\
    \x06\0\x02\x7f\x04\xc3\xf3\x04\x12\x04\xad\x11\x047\n\r\n\x05\x06\0\x02\
    \x7f\x04\x12\x04\xae\x11\x04?\n\x11\n\t\x06\0\x02\x7f\x04\xc2\xf3\x04\0\
    \x12\x04\xae\x11\x04?\n\r\n\x05\x06\0\x02\x7f\x04\x12\x04\xaf\x11\x04?\n\
    \x11\n\t\x06\0\x02\x7f\x04\xc2\xf3\x04\x01\x12\x04\xaf\x11\x04?\n!\n\x05\
    \x06\0\x02\x80\x01\x12\x06\xb3\x11\x02\xbb\x11\x03\x1a\x10\x20Patch\x20o\
    ne\x20app.\n\n\x0e\n\x06\x06\0\x02\x80\x01\x01\x12\x04\xb3\x11\x06\x0e\n\
    \x0e\n\x06\x06\0\x02\x80\x01\x02\x12\x04\xb3\x11\x10\x1f\n\x0e\n\x06\x06\
    \0\x02\x80\x01\x03\x12\x04\xb3\x11*;\n\x10\n\x06\x06\0\x02\x80\x01\x04\
    \x12\x06\xb4\x11\x04\xb7\x11\x06\n\x14\n\n\x06\0\x02\x80\x01\x04\xb0\xca\
    \xbc\"\x12\x06\xb4\x11\x04\xb7\x11\x06\n\x0e\n\x06\x06\0\x02\x80\x01\x04\
    \x12\x04\xb8\x11\x047\n\x11\n\t\x06\0\x02\x80\x01\x04\xc3\xf3\x04\x12\
    \x04\xb8\x11\x047\n\x0e\n\x06\x06\0\x02\x80\x01\x04\x12\x04\xb9\x11\x04?\
    \n\x12\n\n\x06\0\x02\x80\x01\x04\xc2\xf3\x04\0\x12\x04\xb9\x11\x04?\n\
    \x0e\n\x06\x06\0\x02\x80\x01\x04\x12\x04\xba\x11\x04?\n\x12\n\n\x06\0\
    \x02\x80\x01\x04\xc2\xf3\x04\x01\x12\x04\xba\x11\x04?\nW\n\x05\x06\0\x02\
    \x81\x01\x12\x06\xbf\x11\x02\xc7\x11\x03\x1aF\x20Search\x20over\x20the\
    \x20applications\x20to\x20find\x20one\x20or\x20more\x20you're\x20looking\
    \x20for.\n\n\x0e\n\x06\x06\0\x02\x81\x01\x01\x12\x04\xbf\x11\x06\x16\n\
    \x0e\n\x06\x06\0\x02\x81\x01\x02\x12\x04\xbf\x11\x18/\n\x0e\n\x06\x06\0\
    \x02\x81\x01\x03\x12\x04\xbf\x11:J\n\x10\n\x06\x06\0\x02\x81\x01\x04\x12\
    \x06\xc0\x11\x04\xc3\x11\x06\n\x14\n\n\x06\0\x02\x81\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xc0\x11\x04\xc3\x11\x06\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\
    \x04\xc4\x11\x047\n\x11\n\t\x06\0\x02\x81\x01\x04\xc3\xf3\x04\x12\x04\
    \xc4\x11\x047\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc5\x11\x04?\n\
    \x12\n\n\x06\0\x02\x81\x01\x04\xc2\xf3\x04\0\x12\x04\xc5\x11\x04?\n\x0e\
    \n\x06\x06\0\x02\x81\x01\x04\x12\x04\xc6\x11\x04D\n\x12\n\n\x06\0\x02\
    \x81\x01\x04\xc2\xf3\x04\x01\x12\x04\xc6\x11\x04D\n'\n\x05\x06\0\x02\x82\
    \x01\x12\x06\xca\x11\x02\xcf\x11\x03\x1a\x16\x20Get\x20user\x20informati\
    on\n\n\x0e\n\x06\x06\0\x02\x82\x01\x01\x12\x04\xca\x11\x06\r\n\x0e\n\x06\
    \x06\0\x02\x82\x01\x02\x12\x04\xca\x11\x0f\x1d\n\x0e\n\x06\x06\0\x02\x82\
    \x01\x03\x12\x04\xca\x11(:\n\x10\n\x06\x06\0\x02\x82\x01\x04\x12\x06\xcb\
    \x11\x04\xcd\x11\x06\n\x14\n\n\x06\0\x02\x82\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xcb\x11\x04\xcd\x11\x06\n\x0e\n\x06\x06\0\x02\x82\x01\x04\x12\x04\
    \xce\x11\x047\n\x11\n\t\x06\0\x02\x82\x01\x04\xc3\xf3\x04\x12\x04\xce\
    \x11\x047\n@\n\x05\x06\0\x02\x83\x01\x12\x06\xdb\x11\x02\xe5\x11\x03\x1a\
    /\x20Validate\x20new\x20password\x20in\x20real-time\x20for\x20a\x20user\
    \n\n\x0e\n\x06\x06\0\x02\x83\x01\x01\x12\x04\xdb\x11\x06\x1a\n\x0e\n\x06\
    \x06\0\x02\x83\x01\x02\x12\x04\xdb\x11\x1c7\n\x0e\n\x06\x06\0\x02\x83\
    \x01\x03\x12\x04\xdb\x11Bb\n\x10\n\x06\x06\0\x02\x83\x01\x04\x12\x06\xdc\
    \x11\x04\xe3\x11\x06\n\x14\n\n\x06\0\x02\x83\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xdc\x11\x04\xe3\x11\x06\n\x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\
    \xe4\x11\x04@\n\x11\n\t\x06\0\x02\x83\x01\x04\xc3\xf3\x04\x12\x04\xe4\
    \x11\x04@\n-\n\x05\x06\0\x02\x84\x01\x12\x06\x95\x12\x02\x9f\x12\x03\x1a\
    \x1c\x20Get\x20a\x20saved\x20legacy\x20search.\n\n\x0e\n\x06\x06\0\x02\
    \x84\x01\x01\x12\x04\x95\x12\x06\x0f\n\x0e\n\x06\x06\0\x02\x84\x01\x02\
    \x12\x04\x95\x12\x11!\n\x0e\n\x06\x06\0\x02\x84\x01\x03\x12\x04\x95\x12,\
    @\n\x10\n\x06\x06\0\x02\x84\x01\x04\x12\x06\x96\x12\x04\x9b\x12\x06\n\
    \x14\n\n\x06\0\x02\x84\x01\x04\xb0\xca\xbc\"\x12\x06\x96\x12\x04\x9b\x12\
    \x06\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\x04\x9c\x12\x047\n\x11\n\t\
    \x06\0\x02\x84\x01\x04\xc3\xf3\x04\x12\x04\x9c\x12\x047\n\x0e\n\x06\x06\
    \0\x02\x84\x01\x04\x12\x04\x9d\x12\x04?\n\x12\n\n\x06\0\x02\x84\x01\x04\
    \xc2\xf3\x04\0\x12\x04\x9d\x12\x04?\n\x0e\n\x06\x06\0\x02\x84\x01\x04\
    \x12\x04\x9e\x12\x04F\n\x12\n\n\x06\0\x02\x84\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\x9e\x12\x04F\n2\n\x05\x06\0\x02\x85\x01\x12\x06\xa2\x12\x02\xac\
    \x12\x03\x1a!\x20List\x20all\x20saved\x20legacy\x20searches.\n\n\x0e\n\
    \x06\x06\0\x02\x85\x01\x01\x12\x04\xa2\x12\x06\x12\n\x0e\n\x06\x06\0\x02\
    \x85\x01\x02\x12\x04\xa2\x12\x14'\n\x0e\n\x06\x06\0\x02\x85\x01\x03\x12\
    \x04\xa2\x122E\n\x10\n\x06\x06\0\x02\x85\x01\x04\x12\x06\xa3\x12\x04\xa8\
    \x12\x06\n\x14\n\n\x06\0\x02\x85\x01\x04\xb0\xca\xbc\"\x12\x06\xa3\x12\
    \x04\xa8\x12\x06\n\x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\xa9\x12\x047\
    \n\x11\n\t\x06\0\x02\x85\x01\x04\xc3\xf3\x04\x12\x04\xa9\x12\x047\n\x0e\
    \n\x06\x06\0\x02\x85\x01\x04\x12\x04\xaa\x12\x04?\n\x12\n\n\x06\0\x02\
    \x85\x01\x04\xc2\xf3\x04\0\x12\x04\xaa\x12\x04?\n\x0e\n\x06\x06\0\x02\
    \x85\x01\x04\x12\x04\xab\x12\x04F\n\x12\n\n\x06\0\x02\x85\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xab\x12\x04F\n6\n\x05\x06\0\x02\x86\x01\x12\x06\xaf\
    \x12\x02\xbc\x12\x03\x1a%\x20Patch\x20saved\x20legacy\x20searches\x20by\
    \x20ids.\n\n\x0e\n\x06\x06\0\x02\x86\x01\x01\x12\x04\xaf\x12\x06\x13\n\
    \x0e\n\x06\x06\0\x02\x86\x01\x02\x12\x04\xaf\x12\x15)\n\x0e\n\x06\x06\0\
    \x02\x86\x01\x03\x12\x04\xaf\x124G\n\x10\n\x06\x06\0\x02\x86\x01\x04\x12\
    \x06\xb0\x12\x04\xb7\x12\x06\n\x14\n\n\x06\0\x02\x86\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xb0\x12\x04\xb7\x12\x06\n\x0e\n\x06\x06\0\x02\x86\x01\x04\x12\
    \x04\xb8\x12\x047\n\x11\n\t\x06\0\x02\x86\x01\x04\xc3\xf3\x04\x12\x04\
    \xb8\x12\x047\n\x0e\n\x06\x06\0\x02\x86\x01\x04\x12\x04\xb9\x12\x04?\n\
    \x12\n\n\x06\0\x02\x86\x01\x04\xc2\xf3\x04\0\x12\x04\xb9\x12\x04?\n\x0e\
    \n\x06\x06\0\x02\x86\x01\x04\x12\x04\xba\x12\x04F\n\x12\n\n\x06\0\x02\
    \x86\x01\x04\xc2\xf3\x04\x01\x12\x04\xba\x12\x04F\n\x0e\n\x06\x06\0\x02\
    \x86\x01\x04\x12\x04\xbb\x12\x04F\n\x12\n\n\x06\0\x02\x86\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xbb\x12\x04F\n\xc6\x01\n\x05\x06\0\x02\x87\x01\x12\
    \x06\xc2\x12\x02\xd5\x12\x03\x1a\xb4\x01\x20Execute\x20a\x20new\x20searc\
    h\x20and\x20optionally\x20save\x20it.\n\n\x20Deprecated:\x20Use\x20PostI\
    nputsSearches\x20or\x20PostAnnotationsSearches\x20instead.\n\x20\x20The\
    \x20server\x20may\x20refuse\x20to\x20accept\x20requests\x20to\x20this\
    \x20endpoint.\n\n\x0e\n\x06\x06\0\x02\x87\x01\x01\x12\x04\xc2\x12\x06\
    \x12\n\x0e\n\x06\x06\0\x02\x87\x01\x02\x12\x04\xc2\x12\x14'\n\x0e\n\x06\
    \x06\0\x02\x87\x01\x03\x12\x04\xc2\x122E\n\x10\n\x06\x06\0\x02\x87\x01\
    \x04\x12\x06\xc3\x12\x04\xca\x12\x06\n\x14\n\n\x06\0\x02\x87\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xc3\x12\x04\xca\x12\x06\n\x0e\n\x06\x06\0\x02\x87\x01\
    \x04\x12\x04\xcb\x12\x047\n\x11\n\t\x06\0\x02\x87\x01\x04\xc3\xf3\x04\
    \x12\x04\xcb\x12\x047\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xcc\x12\
    \x04?\n\x12\n\n\x06\0\x02\x87\x01\x04\xc2\xf3\x04\0\x12\x04\xcc\x12\x04?\
    \n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xcd\x12\x04F\n\x12\n\n\x06\0\
    \x02\x87\x01\x04\xc2\xf3\x04\x01\x12\x04\xcd\x12\x04F\n\x0e\n\x06\x06\0\
    \x02\x87\x01\x04\x12\x04\xce\x12\x04C\n\x12\n\n\x06\0\x02\x87\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xce\x12\x04C\n\x0e\n\x06\x06\0\x02\x87\x01\x04\
    \x12\x04\xcf\x12\x04A\n\x12\n\n\x06\0\x02\x87\x01\x04\xc2\xf3\x04\x03\
    \x12\x04\xcf\x12\x04A\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xd0\x12\
    \x04A\n\x12\n\n\x06\0\x02\x87\x01\x04\xc2\xf3\x04\x04\x12\x04\xd0\x12\
    \x04A\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xd2\x12\x04=\n\\\n\n\x06\
    \0\x02\x87\x01\x04\xc2\xf3\x04\x05\x12\x04\xd2\x12\x04=\x1aH\x20option\
    \x20(clarifai.auth.util.cl_depending_scopes)\x20=\x20Predict;\x20//\x20o\
    ptional\n\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xd3\x12\x04D\nO\n\n\
    \x06\0\x02\x87\x01\x04\xc2\xf3\x04\x06\x12\x04\xd3\x12\x04D\";\x20to\x20\
    know\x20the\x20concepts\x20and\x20models\x20in\x20your\x20default\x20wor\
    kflow.\n\n\x0e\n\x06\x06\0\x02\x87\x01\x04\x12\x04\xd4\x12\x04\x1d\n\x0f\
    \n\x07\x06\0\x02\x87\x01\x04!\x12\x04\xd4\x12\x04\x1d\n<\n\x05\x06\0\x02\
    \x88\x01\x12\x06\xd8\x12\x02\xe5\x12\x03\x1a+\x20Execute\x20a\x20previou\
    sly\x20saved\x20legacy\x20search.\n\n\x0e\n\x06\x06\0\x02\x88\x01\x01\
    \x12\x04\xd8\x12\x06\x16\n\x0e\n\x06\x06\0\x02\x88\x01\x02\x12\x04\xd8\
    \x12\x18/\n\x0e\n\x06\x06\0\x02\x88\x01\x03\x12\x04\xd8\x12:M\n\x10\n\
    \x06\x06\0\x02\x88\x01\x04\x12\x06\xd9\x12\x04\xe0\x12\x06\n\x14\n\n\x06\
    \0\x02\x88\x01\x04\xb0\xca\xbc\"\x12\x06\xd9\x12\x04\xe0\x12\x06\n\x0e\n\
    \x06\x06\0\x02\x88\x01\x04\x12\x04\xe1\x12\x047\n\x11\n\t\x06\0\x02\x88\
    \x01\x04\xc3\xf3\x04\x12\x04\xe1\x12\x047\n\x0e\n\x06\x06\0\x02\x88\x01\
    \x04\x12\x04\xe2\x12\x04?\n\x12\n\n\x06\0\x02\x88\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xe2\x12\x04?\n\x0e\n\x06\x06\0\x02\x88\x01\x04\x12\x04\xe3\x12\
    \x04F\n\x12\n\n\x06\0\x02\x88\x01\x04\xc2\xf3\x04\x01\x12\x04\xe3\x12\
    \x04F\n\x0e\n\x06\x06\0\x02\x88\x01\x04\x12\x04\xe4\x12\x04=\n\x12\n\n\
    \x06\0\x02\x88\x01\x04\xc2\xf3\x04\x02\x12\x04\xe4\x12\x04=\n>\n\x05\x06\
    \0\x02\x89\x01\x12\x06\xe8\x12\x02\xfa\x12\x03\x1a-\x20Evaluate\x20the\
    \x20results\x20of\x20two\x20search\x20requests\n\n\x0e\n\x06\x06\0\x02\
    \x89\x01\x01\x12\x04\xe8\x12\x06!\n\x0e\n\x06\x06\0\x02\x89\x01\x02\x12\
    \x04\xe8\x12\"D\n\x0e\n\x06\x06\0\x02\x89\x01\x03\x12\x04\xe8\x12Os\n\
    \x10\n\x06\x06\0\x02\x89\x01\x04\x12\x06\xe9\x12\x04\xf0\x12\x06\n\x14\n\
    \n\x06\0\x02\x89\x01\x04\xb0\xca\xbc\"\x12\x06\xe9\x12\x04\xf0\x12\x06\n\
    \x0e\n\x06\x06\0\x02\x89\x01\x04\x12\x04\xf1\x12\x047\n\x11\n\t\x06\0\
    \x02\x89\x01\x04\xc3\xf3\x04\x12\x04\xf1\x12\x047\n\x0e\n\x06\x06\0\x02\
    \x89\x01\x04\x12\x04\xf2\x12\x04?\n\x12\n\n\x06\0\x02\x89\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xf2\x12\x04?\n\x0e\n\x06\x06\0\x02\x89\x01\x04\x12\
    \x04\xf3\x12\x04F\n\x12\n\n\x06\0\x02\x89\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xf3\x12\x04F\n\x0e\n\x06\x06\0\x02\x89\x01\x04\x12\x04\xf4\x12\x04C\
    \n\x12\n\n\x06\0\x02\x89\x01\x04\xc2\xf3\x04\x02\x12\x04\xf4\x12\x04C\n\
    \x0e\n\x06\x06\0\x02\x89\x01\x04\x12\x04\xf5\x12\x04A\n\x12\n\n\x06\0\
    \x02\x89\x01\x04\xc2\xf3\x04\x03\x12\x04\xf5\x12\x04A\n\x0e\n\x06\x06\0\
    \x02\x89\x01\x04\x12\x04\xf6\x12\x04B\n\x12\n\n\x06\0\x02\x89\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xf6\x12\x04B\n\x0e\n\x06\x06\0\x02\x89\x01\x04\
    \x12\x04\xf7\x12\x04B\n\x12\n\n\x06\0\x02\x89\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xf7\x12\x04B\n\x0e\n\x06\x06\0\x02\x89\x01\x04\x12\x04\xf8\x12\
    \x04A\n\x12\n\n\x06\0\x02\x89\x01\x04\xc2\xf3\x04\x06\x12\x04\xf8\x12\
    \x04A\n\x0e\n\x06\x06\0\x02\x89\x01\x04\x12\x04\xf9\x12\x04D\nQ\n\n\x06\
    \0\x02\x89\x01\x04\xc2\xf3\x04\x07\x12\x04\xf9\x12\x04D\"=\x20as\x20it\
    \x20needs\x20to\x20know\x20the\x20concepts\x20in\x20your\x20workflow's\
    \x20models.\n\nI\n\x05\x06\0\x02\x8a\x01\x12\x06\xfd\x12\x02\x8a\x13\x03\
    \x1a8\x20Get\x20the\x20evaluation\x20results\x20between\x20two\x20search\
    \x20requests\n\n\x0e\n\x06\x06\0\x02\x8a\x01\x01\x12\x04\xfd\x12\x06\x20\
    \n\x0e\n\x06\x06\0\x02\x8a\x01\x02\x12\x04\xfd\x12!B\n\x0e\n\x06\x06\0\
    \x02\x8a\x01\x03\x12\x04\xfd\x12Mq\n\x10\n\x06\x06\0\x02\x8a\x01\x04\x12\
    \x06\xfe\x12\x04\x83\x13\x06\n\x14\n\n\x06\0\x02\x8a\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xfe\x12\x04\x83\x13\x06\n\x0e\n\x06\x06\0\x02\x8a\x01\x04\x12\
    \x04\x84\x13\x047\n\x11\n\t\x06\0\x02\x8a\x01\x04\xc3\xf3\x04\x12\x04\
    \x84\x13\x047\n\x0e\n\x06\x06\0\x02\x8a\x01\x04\x12\x04\x85\x13\x04?\n\
    \x12\n\n\x06\0\x02\x8a\x01\x04\xc2\xf3\x04\0\x12\x04\x85\x13\x04?\n\x0e\
    \n\x06\x06\0\x02\x8a\x01\x04\x12\x04\x86\x13\x04F\n\x12\n\n\x06\0\x02\
    \x8a\x01\x04\xc2\xf3\x04\x01\x12\x04\x86\x13\x04F\n\x0e\n\x06\x06\0\x02\
    \x8a\x01\x04\x12\x04\x87\x13\x04C\n\x12\n\n\x06\0\x02\x8a\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\x87\x13\x04C\n\x0e\n\x06\x06\0\x02\x8a\x01\x04\x12\
    \x04\x88\x13\x04A\n\x12\n\n\x06\0\x02\x8a\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\x88\x13\x04A\n\x0e\n\x06\x06\0\x02\x8a\x01\x04\x12\x04\x89\x13\x04B\
    \n\x12\n\n\x06\0\x02\x8a\x01\x04\xc2\xf3\x04\x04\x12\x04\x89\x13\x04B\nJ\
    \n\x05\x06\0\x02\x8b\x01\x12\x06\x8f\x13\x02\x9c\x13\x03\x1a9\x20List\
    \x20the\x20evaluation\x20results\x20between\x20two\x20search\x20requests\
    \n\n\x0e\n\x06\x06\0\x02\x8b\x01\x01\x12\x04\x8f\x13\x06!\n\x0e\n\x06\
    \x06\0\x02\x8b\x01\x02\x12\x04\x8f\x13\"D\n\x0e\n\x06\x06\0\x02\x8b\x01\
    \x03\x12\x04\x8f\x13Os\n\x10\n\x06\x06\0\x02\x8b\x01\x04\x12\x06\x90\x13\
    \x04\x95\x13\x06\n\x14\n\n\x06\0\x02\x8b\x01\x04\xb0\xca\xbc\"\x12\x06\
    \x90\x13\x04\x95\x13\x06\n\x0e\n\x06\x06\0\x02\x8b\x01\x04\x12\x04\x96\
    \x13\x047\n\x11\n\t\x06\0\x02\x8b\x01\x04\xc3\xf3\x04\x12\x04\x96\x13\
    \x047\n\x0e\n\x06\x06\0\x02\x8b\x01\x04\x12\x04\x97\x13\x04?\n\x12\n\n\
    \x06\0\x02\x8b\x01\x04\xc2\xf3\x04\0\x12\x04\x97\x13\x04?\n\x0e\n\x06\
    \x06\0\x02\x8b\x01\x04\x12\x04\x98\x13\x04F\n\x12\n\n\x06\0\x02\x8b\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\x98\x13\x04F\n\x0e\n\x06\x06\0\x02\x8b\x01\
    \x04\x12\x04\x99\x13\x04C\n\x12\n\n\x06\0\x02\x8b\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\x99\x13\x04C\n\x0e\n\x06\x06\0\x02\x8b\x01\x04\x12\x04\x9a\
    \x13\x04A\n\x12\n\n\x06\0\x02\x8b\x01\x04\xc2\xf3\x04\x03\x12\x04\x9a\
    \x13\x04A\n\x0e\n\x06\x06\0\x02\x8b\x01\x04\x12\x04\x9b\x13\x04B\n\x12\n\
    \n\x06\0\x02\x8b\x01\x04\xc2\xf3\x04\x04\x12\x04\x9b\x13\x04B\n0\n\x05\
    \x06\0\x02\x8c\x01\x12\x06\x9f\x13\x02\xab\x13\x03\x1a\x1f\x20DeleteAnno\
    tationSearchMetrics\n\n\x0e\n\x06\x06\0\x02\x8c\x01\x01\x12\x04\x9f\x13\
    \x06#\n\x0e\n\x06\x06\0\x02\x8c\x01\x02\x12\x04\x9f\x13%I\n\x0e\n\x06\
    \x06\0\x02\x8c\x01\x03\x12\x04\x9f\x13Tt\n\x10\n\x06\x06\0\x02\x8c\x01\
    \x04\x12\x06\xa0\x13\x04\xa5\x13\x06\n\x14\n\n\x06\0\x02\x8c\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xa0\x13\x04\xa5\x13\x06\n\x0e\n\x06\x06\0\x02\x8c\x01\
    \x04\x12\x04\xa6\x13\x047\n\x11\n\t\x06\0\x02\x8c\x01\x04\xc3\xf3\x04\
    \x12\x04\xa6\x13\x047\n\x0e\n\x06\x06\0\x02\x8c\x01\x04\x12\x04\xa7\x13\
    \x04?\n\x12\n\n\x06\0\x02\x8c\x01\x04\xc2\xf3\x04\0\x12\x04\xa7\x13\x04?\
    \n\x0e\n\x06\x06\0\x02\x8c\x01\x04\x12\x04\xa8\x13\x04B\n\x12\n\n\x06\0\
    \x02\x8c\x01\x04\xc2\xf3\x04\x01\x12\x04\xa8\x13\x04B\n\x0e\n\x06\x06\0\
    \x02\x8c\x01\x04\x12\x04\xa9\x13\x04B\n\x12\n\n\x06\0\x02\x8c\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xa9\x13\x04B\n\x0e\n\x06\x06\0\x02\x8c\x01\x04\
    \x12\x04\xaa\x13\x04E\n\x12\n\n\x06\0\x02\x8c\x01\x04\xc2\xf3\x04\x03\
    \x12\x04\xaa\x13\x04E\n)\n\x05\x06\0\x02\x8d\x01\x12\x06\xae\x13\x02\xba\
    \x13\x03\x1a\x18\x20Delete\x20a\x20saved\x20search.\n\n\x0e\n\x06\x06\0\
    \x02\x8d\x01\x01\x12\x04\xae\x13\x06\x12\n\x0e\n\x06\x06\0\x02\x8d\x01\
    \x02\x12\x04\xae\x13\x14'\n\x0e\n\x06\x06\0\x02\x8d\x01\x03\x12\x04\xae\
    \x132R\n\x10\n\x06\x06\0\x02\x8d\x01\x04\x12\x06\xaf\x13\x04\xb4\x13\x06\
    \n\x14\n\n\x06\0\x02\x8d\x01\x04\xb0\xca\xbc\"\x12\x06\xaf\x13\x04\xb4\
    \x13\x06\n\x0e\n\x06\x06\0\x02\x8d\x01\x04\x12\x04\xb5\x13\x047\n\x11\n\
    \t\x06\0\x02\x8d\x01\x04\xc3\xf3\x04\x12\x04\xb5\x13\x047\n\x0e\n\x06\
    \x06\0\x02\x8d\x01\x04\x12\x04\xb6\x13\x04?\n\x12\n\n\x06\0\x02\x8d\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xb6\x13\x04?\n\x0e\n\x06\x06\0\x02\x8d\x01\
    \x04\x12\x04\xb7\x13\x04F\n\x12\n\n\x06\0\x02\x8d\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xb7\x13\x04F\n\x0e\n\x06\x06\0\x02\x8d\x01\x04\x12\x04\xb8\
    \x13\x04F\n\x12\n\n\x06\0\x02\x8d\x01\x04\xc2\xf3\x04\x02\x12\x04\xb8\
    \x13\x04F\n\x0e\n\x06\x06\0\x02\x8d\x01\x04\x12\x04\xb9\x13\x04I\n\x12\n\
    \n\x06\0\x02\x8d\x01\x04\xc2\xf3\x04\x03\x12\x04\xb9\x13\x04I\n3\n\x05\
    \x06\0\x02\x8e\x01\x12\x06\xbd\x13\x02\xc7\x13\x03\x1a\"\x20List\x20all\
    \x20the\x20annotation\x20filters.\n\n\x0e\n\x06\x06\0\x02\x8e\x01\x01\
    \x12\x04\xbd\x13\x06\x1b\n\x0e\n\x06\x06\0\x02\x8e\x01\x02\x12\x04\xbd\
    \x13\x1d9\n\x0e\n\x06\x06\0\x02\x8e\x01\x03\x12\x04\xbd\x13Da\n\x10\n\
    \x06\x06\0\x02\x8e\x01\x04\x12\x06\xbe\x13\x04\xc3\x13\x06\n\x14\n\n\x06\
    \0\x02\x8e\x01\x04\xb0\xca\xbc\"\x12\x06\xbe\x13\x04\xc3\x13\x06\n\x0e\n\
    \x06\x06\0\x02\x8e\x01\x04\x12\x04\xc4\x13\x047\n\x11\n\t\x06\0\x02\x8e\
    \x01\x04\xc3\xf3\x04\x12\x04\xc4\x13\x047\n\x0e\n\x06\x06\0\x02\x8e\x01\
    \x04\x12\x04\xc5\x13\x04?\n\x12\n\n\x06\0\x02\x8e\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xc5\x13\x04?\n\x0e\n\x06\x06\0\x02\x8e\x01\x04\x12\x04\xc6\x13\
    \x04F\n\x12\n\n\x06\0\x02\x8e\x01\x04\xc2\xf3\x04\x01\x12\x04\xc6\x13\
    \x04F\n4\n\x05\x06\0\x02\x8f\x01\x12\x06\xca\x13\x02\xd4\x13\x03\x1a#\
    \x20Get\x20a\x20specific\x20annotation\x20filter.\n\n\x0e\n\x06\x06\0\
    \x02\x8f\x01\x01\x12\x04\xca\x13\x06\x19\n\x0e\n\x06\x06\0\x02\x8f\x01\
    \x02\x12\x04\xca\x13\x1b5\n\x0e\n\x06\x06\0\x02\x8f\x01\x03\x12\x04\xca\
    \x13@^\n\x10\n\x06\x06\0\x02\x8f\x01\x04\x12\x06\xcb\x13\x04\xd0\x13\x06\
    \n\x14\n\n\x06\0\x02\x8f\x01\x04\xb0\xca\xbc\"\x12\x06\xcb\x13\x04\xd0\
    \x13\x06\n\x0e\n\x06\x06\0\x02\x8f\x01\x04\x12\x04\xd1\x13\x047\n\x11\n\
    \t\x06\0\x02\x8f\x01\x04\xc3\xf3\x04\x12\x04\xd1\x13\x047\n\x0e\n\x06\
    \x06\0\x02\x8f\x01\x04\x12\x04\xd2\x13\x04?\n\x12\n\n\x06\0\x02\x8f\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xd2\x13\x04?\n\x0e\n\x06\x06\0\x02\x8f\x01\
    \x04\x12\x04\xd3\x13\x04F\n\x12\n\n\x06\0\x02\x8f\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xd3\x13\x04F\n*\n\x05\x06\0\x02\x90\x01\x12\x06\xd7\x13\x02\
    \xe4\x13\x03\x1a\x19\x20Add\x20annotation\x20filters.\n\n\x0e\n\x06\x06\
    \0\x02\x90\x01\x01\x12\x04\xd7\x13\x06\x1b\n\x0e\n\x06\x06\0\x02\x90\x01\
    \x02\x12\x04\xd7\x13\x1d9\n\x0e\n\x06\x06\0\x02\x90\x01\x03\x12\x04\xd7\
    \x13Da\n\x10\n\x06\x06\0\x02\x90\x01\x04\x12\x06\xd8\x13\x04\xdf\x13\x06\
    \n\x14\n\n\x06\0\x02\x90\x01\x04\xb0\xca\xbc\"\x12\x06\xd8\x13\x04\xdf\
    \x13\x06\n\x0e\n\x06\x06\0\x02\x90\x01\x04\x12\x04\xe0\x13\x047\n\x11\n\
    \t\x06\0\x02\x90\x01\x04\xc3\xf3\x04\x12\x04\xe0\x13\x047\n\x0e\n\x06\
    \x06\0\x02\x90\x01\x04\x12\x04\xe1\x13\x04?\n\x12\n\n\x06\0\x02\x90\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xe1\x13\x04?\n\x0e\n\x06\x06\0\x02\x90\x01\
    \x04\x12\x04\xe2\x13\x04F\n\x12\n\n\x06\0\x02\x90\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xe2\x13\x04F\n\x0e\n\x06\x06\0\x02\x90\x01\x04\x12\x04\xe3\
    \x13\x04F\n\x12\n\n\x06\0\x02\x90\x01\x04\xc2\xf3\x04\x02\x12\x04\xe3\
    \x13\x04F\n8\n\x05\x06\0\x02\x91\x01\x12\x06\xe7\x13\x02\xf4\x13\x03\x1a\
    '\x20Patch\x20one\x20or\x20more\x20annotation\x20filters.\n\n\x0e\n\x06\
    \x06\0\x02\x91\x01\x01\x12\x04\xe7\x13\x06\x1c\n\x0e\n\x06\x06\0\x02\x91\
    \x01\x02\x12\x04\xe7\x13\x1e;\n\x0e\n\x06\x06\0\x02\x91\x01\x03\x12\x04\
    \xe7\x13Fc\n\x10\n\x06\x06\0\x02\x91\x01\x04\x12\x06\xe8\x13\x04\xef\x13\
    \x06\n\x14\n\n\x06\0\x02\x91\x01\x04\xb0\xca\xbc\"\x12\x06\xe8\x13\x04\
    \xef\x13\x06\n\x0e\n\x06\x06\0\x02\x91\x01\x04\x12\x04\xf0\x13\x047\n\
    \x11\n\t\x06\0\x02\x91\x01\x04\xc3\xf3\x04\x12\x04\xf0\x13\x047\n\x0e\n\
    \x06\x06\0\x02\x91\x01\x04\x12\x04\xf1\x13\x04?\n\x12\n\n\x06\0\x02\x91\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xf1\x13\x04?\n\x0e\n\x06\x06\0\x02\x91\
    \x01\x04\x12\x04\xf2\x13\x04F\n\x12\n\n\x06\0\x02\x91\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xf2\x13\x04F\n\x0e\n\x06\x06\0\x02\x91\x01\x04\x12\x04\
    \xf3\x13\x04F\n\x12\n\n\x06\0\x02\x91\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xf3\x13\x04F\nM\n\x05\x06\0\x02\x92\x01\x12\x06\xf7\x13\x02\x84\x14\x03\
    \x1a<\x20Delete\x20one\x20or\x20more\x20annotation\x20filters\x20in\x20a\
    \x20single\x20request.\n\n\x0e\n\x06\x06\0\x02\x92\x01\x01\x12\x04\xf7\
    \x13\x06\x1d\n\x0e\n\x06\x06\0\x02\x92\x01\x02\x12\x04\xf7\x13\x1f=\n\
    \x0e\n\x06\x06\0\x02\x92\x01\x03\x12\x04\xf7\x13Hh\n\x10\n\x06\x06\0\x02\
    \x92\x01\x04\x12\x06\xf8\x13\x04\xff\x13\x06\n\x14\n\n\x06\0\x02\x92\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xf8\x13\x04\xff\x13\x06\n\x0e\n\x06\x06\0\x02\
    \x92\x01\x04\x12\x04\x80\x14\x047\n\x11\n\t\x06\0\x02\x92\x01\x04\xc3\
    \xf3\x04\x12\x04\x80\x14\x047\n\x0e\n\x06\x06\0\x02\x92\x01\x04\x12\x04\
    \x81\x14\x04?\n\x12\n\n\x06\0\x02\x92\x01\x04\xc2\xf3\x04\0\x12\x04\x81\
    \x14\x04?\n\x0e\n\x06\x06\0\x02\x92\x01\x04\x12\x04\x82\x14\x04F\n\x12\n\
    \n\x06\0\x02\x92\x01\x04\xc2\xf3\x04\x01\x12\x04\x82\x14\x04F\n\x0e\n\
    \x06\x06\0\x02\x92\x01\x04\x12\x04\x83\x14\x04F\n\x12\n\n\x06\0\x02\x92\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\x83\x14\x04F\n)\n\x05\x06\0\x02\x93\x01\
    \x12\x06\xa5\x14\x02\xaa\x14\x03\x1a\x18\x20List\x20all\x20status\x20cod\
    es.\n\n\x0e\n\x06\x06\0\x02\x93\x01\x01\x12\x04\xa5\x14\x06\x15\n\x0e\n\
    \x06\x06\0\x02\x93\x01\x02\x12\x04\xa5\x14\x17-\n\x0e\n\x06\x06\0\x02\
    \x93\x01\x03\x12\x04\xa5\x148O\n\x10\n\x06\x06\0\x02\x93\x01\x04\x12\x06\
    \xa6\x14\x04\xa8\x14\x06\n\x14\n\n\x06\0\x02\x93\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xa6\x14\x04\xa8\x14\x06\n\x0e\n\x06\x06\0\x02\x93\x01\x04\x12\
    \x04\xa9\x14\x046\n\x11\n\t\x06\0\x02\x93\x01\x04\xc3\xf3\x04\x12\x04\
    \xa9\x14\x046\n6\n\x05\x06\0\x02\x94\x01\x12\x06\xad\x14\x02\xb2\x14\x03\
    \x1a%\x20Get\x20more\x20details\x20for\x20a\x20status\x20code.\n\n\x0e\n\
    \x06\x06\0\x02\x94\x01\x01\x12\x04\xad\x14\x06\x13\n\x0e\n\x06\x06\0\x02\
    \x94\x01\x02\x12\x04\xad\x14\x15)\n\x0e\n\x06\x06\0\x02\x94\x01\x03\x12\
    \x04\xad\x144L\n\x10\n\x06\x06\0\x02\x94\x01\x04\x12\x06\xae\x14\x04\xb0\
    \x14\x06\n\x14\n\n\x06\0\x02\x94\x01\x04\xb0\xca\xbc\"\x12\x06\xae\x14\
    \x04\xb0\x14\x06\n\x0e\n\x06\x06\0\x02\x94\x01\x04\x12\x04\xb1\x14\x046\
    \n\x11\n\t\x06\0\x02\x94\x01\x04\xc3\xf3\x04\x12\x04\xb1\x14\x046\n>\n\
    \x05\x06\0\x02\x95\x01\x12\x06\xc1\x14\x02\xc8\x14\x03\x1a-\x20owner\x20\
    list\x20users\x20who\x20the\x20app\x20is\x20shared\x20with\n\n\x0e\n\x06\
    \x06\0\x02\x95\x01\x01\x12\x04\xc1\x14\x06\x17\n\x0e\n\x06\x06\0\x02\x95\
    \x01\x02\x12\x04\xc1\x14\x191\n\x0e\n\x06\x06\0\x02\x95\x01\x03\x12\x04\
    \xc1\x14<V\n\x10\n\x06\x06\0\x02\x95\x01\x04\x12\x06\xc2\x14\x04\xc4\x14\
    \x06\n\x14\n\n\x06\0\x02\x95\x01\x04\xb0\xca\xbc\"\x12\x06\xc2\x14\x04\
    \xc4\x14\x06\n\x0e\n\x06\x06\0\x02\x95\x01\x04\x12\x04\xc5\x14\x047\n\
    \x11\n\t\x06\0\x02\x95\x01\x04\xc3\xf3\x04\x12\x04\xc5\x14\x047\n\x0e\n\
    \x06\x06\0\x02\x95\x01\x04\x12\x04\xc6\x14\x04?\n\x12\n\n\x06\0\x02\x95\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xc6\x14\x04?\n\x0e\n\x06\x06\0\x02\x95\
    \x01\x04\x12\x04\xc7\x14\x04H\n\x12\n\n\x06\0\x02\x95\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xc7\x14\x04H\n/\n\x05\x06\0\x02\x96\x01\x12\x06\xcb\x14\
    \x02\xd4\x14\x03\x1a\x1e\x20add\x20collaborators\x20to\x20an\x20app.\n\n\
    \x0e\n\x06\x06\0\x02\x96\x01\x01\x12\x04\xcb\x14\x06\x17\n\x0e\n\x06\x06\
    \0\x02\x96\x01\x02\x12\x04\xcb\x14\x191\n\x0e\n\x06\x06\0\x02\x96\x01\
    \x03\x12\x04\xcb\x14<V\n\x10\n\x06\x06\0\x02\x96\x01\x04\x12\x06\xcc\x14\
    \x04\xcf\x14\x06\n\x14\n\n\x06\0\x02\x96\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xcc\x14\x04\xcf\x14\x06\n\x0e\n\x06\x06\0\x02\x96\x01\x04\x12\x04\xd0\
    \x14\x047\n\x11\n\t\x06\0\x02\x96\x01\x04\xc3\xf3\x04\x12\x04\xd0\x14\
    \x047\n\x0e\n\x06\x06\0\x02\x96\x01\x04\x12\x04\xd1\x14\x04?\n\x12\n\n\
    \x06\0\x02\x96\x01\x04\xc2\xf3\x04\0\x12\x04\xd1\x14\x04?\n\x0e\n\x06\
    \x06\0\x02\x96\x01\x04\x12\x04\xd2\x14\x04H\n\x12\n\n\x06\0\x02\x96\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xd2\x14\x04H\n\x0e\n\x06\x06\0\x02\x96\x01\
    \x04\x12\x04\xd3\x14\x04H\n\x12\n\n\x06\0\x02\x96\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xd3\x14\x04H\n0\n\x05\x06\0\x02\x97\x01\x12\x06\xd7\x14\x02\
    \xe1\x14\x03\x1a\x1f\x20Patch\x20existing\x20collaborators.\n\n\x0e\n\
    \x06\x06\0\x02\x97\x01\x01\x12\x04\xd7\x14\x06\x18\n\x0e\n\x06\x06\0\x02\
    \x97\x01\x02\x12\x04\xd7\x14\x1a3\n\x0e\n\x06\x06\0\x02\x97\x01\x03\x12\
    \x04\xd7\x14>X\n\x10\n\x06\x06\0\x02\x97\x01\x04\x12\x06\xd8\x14\x04\xdb\
    \x14\x06\n\x14\n\n\x06\0\x02\x97\x01\x04\xb0\xca\xbc\"\x12\x06\xd8\x14\
    \x04\xdb\x14\x06\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xdc\x14\x047\
    \n\x11\n\t\x06\0\x02\x97\x01\x04\xc3\xf3\x04\x12\x04\xdc\x14\x047\n\x0e\
    \n\x06\x06\0\x02\x97\x01\x04\x12\x04\xdd\x14\x04?\n\x12\n\n\x06\0\x02\
    \x97\x01\x04\xc2\xf3\x04\0\x12\x04\xdd\x14\x04?\n\x0e\n\x06\x06\0\x02\
    \x97\x01\x04\x12\x04\xde\x14\x04H\n\x12\n\n\x06\0\x02\x97\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xde\x14\x04H\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\
    \x04\xdf\x14\x04H\n\x12\n\n\x06\0\x02\x97\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xdf\x14\x04H\n\x0e\n\x06\x06\0\x02\x97\x01\x04\x12\x04\xe0\x14\x04K\
    \n\x12\n\n\x06\0\x02\x97\x01\x04\xc2\xf3\x04\x03\x12\x04\xe0\x14\x04K\n1\
    \n\x05\x06\0\x02\x98\x01\x12\x06\xe4\x14\x02\xf0\x14\x03\x1a\x20\x20Dele\
    te\x20existing\x20collaborators.\n\n\x0e\n\x06\x06\0\x02\x98\x01\x01\x12\
    \x04\xe4\x14\x06\x19\n\x0e\n\x06\x06\0\x02\x98\x01\x02\x12\x04\xe4\x14\
    \x1b5\n\x0e\n\x06\x06\0\x02\x98\x01\x03\x12\x04\xe4\x14@`\n\x10\n\x06\
    \x06\0\x02\x98\x01\x04\x12\x06\xe5\x14\x04\xe8\x14\x06\n\x14\n\n\x06\0\
    \x02\x98\x01\x04\xb0\xca\xbc\"\x12\x06\xe5\x14\x04\xe8\x14\x06\n\x0e\n\
    \x06\x06\0\x02\x98\x01\x04\x12\x04\xe9\x14\x047\n\x11\n\t\x06\0\x02\x98\
    \x01\x04\xc3\xf3\x04\x12\x04\xe9\x14\x047\n\x0e\n\x06\x06\0\x02\x98\x01\
    \x04\x12\x04\xea\x14\x04?\n\x12\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xea\x14\x04?\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xeb\x14\
    \x04H\n\x12\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\x01\x12\x04\xeb\x14\
    \x04H\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xec\x14\x04H\n\x12\n\n\
    \x06\0\x02\x98\x01\x04\xc2\xf3\x04\x02\x12\x04\xec\x14\x04H\n\x0e\n\x06\
    \x06\0\x02\x98\x01\x04\x12\x04\xed\x14\x04K\n\x12\n\n\x06\0\x02\x98\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\xed\x14\x04K\n\x0e\n\x06\x06\0\x02\x98\x01\
    \x04\x12\x04\xee\x14\x04@\no\n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\x04\
    \x12\x04\xee\x14\x04@\"[\x20when\x20deleting\x20a\x20collaborator,\x20we\
    \x20also\x20delete\x20task\x20workers\x20associated\x20to\x20this\x20col\
    laborator\n\n\x0e\n\x06\x06\0\x02\x98\x01\x04\x12\x04\xef\x14\x04@\n\x12\
    \n\n\x06\0\x02\x98\x01\x04\xc2\xf3\x04\x05\x12\x04\xef\x14\x04@\nN\n\x05\
    \x06\0\x02\x99\x01\x12\x06\xf3\x14\x02\xf8\x14\x03\x1a=\x20Collaboration\
    \x20includes\x20the\x20app\x20user\x20are\x20invitied\x20to\x20work\x20o\
    n\n\n\x0e\n\x06\x06\0\x02\x99\x01\x01\x12\x04\xf3\x14\x06\x18\n\x0e\n\
    \x06\x06\0\x02\x99\x01\x02\x12\x04\xf3\x14\x1a3\n\x0e\n\x06\x06\0\x02\
    \x99\x01\x03\x12\x04\xf3\x14>Y\n\x10\n\x06\x06\0\x02\x99\x01\x04\x12\x06\
    \xf4\x14\x04\xf6\x14\x06\n\x14\n\n\x06\0\x02\x99\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xf4\x14\x04\xf6\x14\x06\n\x0e\n\x06\x06\0\x02\x99\x01\x04\x12\
    \x04\xf7\x14\x04@\n\x11\n\t\x06\0\x02\x99\x01\x04\xc3\xf3\x04\x12\x04\
    \xf7\x14\x04@\n\xe5\x05\n\x05\x06\0\x02\x9a\x01\x12\x06\x89\x15\x02\x90\
    \x15\x03\x1a\xd3\x05\x20PostAppDuplications\x20starts\x20async\x20app\
    \x20duplication\x20jobs\x20which\x20copy\x20resources\n\x20(inputs,\x20a\
    nnotations,\x20models\x20etc)\x20from\x20one\x20application\x20to\x20ano\
    ther.\x20It\x20can\n\x20also\x20create\x20the\x20destination\x20applicat\
    ion\x20if\x20it\x20does\x20not\x20exist,\x20with\x20fields\n\x20(descrip\
    tion,\x20metadata\x20etc)\x20copied\x20from\x20the\x20source\x20applicat\
    ion.\n\n\x20A\x20duplication\x20job\x20can\x20be\x20started\x20by\x20any\
    \x20user\x20that\x20can\x20read\x20from\x20the\x20source\n\x20applicatio\
    n\x20(the\x20target\x20of\x20this\x20call)\x20and\x20can\x20create\x20an\
    d\x20write\x20to\x20the\n\x20destination\x20application.\x20The\x20dupli\
    cation\x20is\x20associated\x20with\x20the\x20user\x20that\n\x20created\
    \x20it,\x20so\x20in\x20order\x20to\x20read\x20the\x20status\x20and\x20pr\
    ogress\x20of\x20the\x20job,\x20that\n\x20user's\x20ID\x20has\x20to\x20be\
    \x20used\x20in\x20the\x20call\x20to\x20GetAppDuplication,\x20which\x20mi\
    ght\x20be\n\x20different\x20to\x20the\x20source\x20application\x20owner\
    \x20ID\x20in\x20this\x20call.\n\n\x0e\n\x06\x06\0\x02\x9a\x01\x01\x12\
    \x04\x89\x15\x06\x19\n\x0e\n\x06\x06\0\x02\x9a\x01\x02\x12\x04\x89\x15\
    \x1b5\n\x0e\n\x06\x06\0\x02\x9a\x01\x03\x12\x04\x89\x15@\\\n\x10\n\x06\
    \x06\0\x02\x9a\x01\x04\x12\x06\x8a\x15\x04\x8d\x15\x06\n\x14\n\n\x06\0\
    \x02\x9a\x01\x04\xb0\xca\xbc\"\x12\x06\x8a\x15\x04\x8d\x15\x06\n\x0e\n\
    \x06\x06\0\x02\x9a\x01\x04\x12\x04\x8e\x15\x047\n\x11\n\t\x06\0\x02\x9a\
    \x01\x04\xc3\xf3\x04\x12\x04\x8e\x15\x047\n\x0e\n\x06\x06\0\x02\x9a\x01\
    \x04\x12\x04\x8f\x15\x04?\n\x12\n\n\x06\0\x02\x9a\x01\x04\xc2\xf3\x04\0\
    \x12\x04\x8f\x15\x04?\nZ\n\x05\x06\0\x02\x9b\x01\x12\x06\x93\x15\x02\x98\
    \x15\x03\x1aI\x20ListAppDuplications\x20lists\x20all\x20app\x20duplicati\
    on\x20jobs\x20created\x20by\x20the\x20user.\n\n\x0e\n\x06\x06\0\x02\x9b\
    \x01\x01\x12\x04\x93\x15\x06\x19\n\x0e\n\x06\x06\0\x02\x9b\x01\x02\x12\
    \x04\x93\x15\x1b5\n\x0e\n\x06\x06\0\x02\x9b\x01\x03\x12\x04\x93\x15@\\\n\
    \x10\n\x06\x06\0\x02\x9b\x01\x04\x12\x06\x94\x15\x04\x96\x15\x06\n\x14\n\
    \n\x06\0\x02\x9b\x01\x04\xb0\xca\xbc\"\x12\x06\x94\x15\x04\x96\x15\x06\n\
    \x0e\n\x06\x06\0\x02\x9b\x01\x04\x12\x04\x97\x15\x047\n\x11\n\t\x06\0\
    \x02\x9b\x01\x04\xc3\xf3\x04\x12\x04\x97\x15\x047\nX\n\x05\x06\0\x02\x9c\
    \x01\x12\x06\x9b\x15\x02\xa0\x15\x03\x1aG\x20GetAppDuplication\x20return\
    s\x20an\x20app\x20duplication\x20job\x20created\x20by\x20the\x20user.\n\
    \n\x0e\n\x06\x06\0\x02\x9c\x01\x01\x12\x04\x9b\x15\x06\x17\n\x0e\n\x06\
    \x06\0\x02\x9c\x01\x02\x12\x04\x9b\x15\x191\n\x0e\n\x06\x06\0\x02\x9c\
    \x01\x03\x12\x04\x9b\x15<X\n\x10\n\x06\x06\0\x02\x9c\x01\x04\x12\x06\x9c\
    \x15\x04\x9e\x15\x06\n\x14\n\n\x06\0\x02\x9c\x01\x04\xb0\xca\xbc\"\x12\
    \x06\x9c\x15\x04\x9e\x15\x06\n\x0e\n\x06\x06\0\x02\x9c\x01\x04\x12\x04\
    \x9f\x15\x047\n\x11\n\t\x06\0\x02\x9c\x01\x04\xc3\xf3\x04\x12\x04\x9f\
    \x15\x047\n'\n\x05\x06\0\x02\x9d\x01\x12\x06\xa3\x15\x02\xb9\x15\x03\x1a\
    \x16\x20Add\x20tasks\x20to\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\x9d\x01\
    \x01\x12\x04\xa3\x15\x06\x0f\n\x0e\n\x06\x06\0\x02\x9d\x01\x02\x12\x04\
    \xa3\x15\x11!\n\x0e\n\x06\x06\0\x02\x9d\x01\x03\x12\x04\xa3\x15,=\n\x10\
    \n\x06\x06\0\x02\x9d\x01\x04\x12\x06\xa4\x15\x04\xab\x15\x06\n\x14\n\n\
    \x06\0\x02\x9d\x01\x04\xb0\xca\xbc\"\x12\x06\xa4\x15\x04\xab\x15\x06\n\
    \x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\xac\x15\x047\n\x11\n\t\x06\0\
    \x02\x9d\x01\x04\xc3\xf3\x04\x12\x04\xac\x15\x047\n\x0e\n\x06\x06\0\x02\
    \x9d\x01\x04\x12\x04\xad\x15\x04?\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xad\x15\x04?\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\
    \x04\xae\x15\x04@\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xae\x15\x04@\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\xaf\x15\x04@\
    \n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x02\x12\x04\xaf\x15\x04@\n\
    \x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\xb0\x15\x04A\n\x12\n\n\x06\0\
    \x02\x9d\x01\x04\xc2\xf3\x04\x03\x12\x04\xb0\x15\x04A\n\x0e\n\x06\x06\0\
    \x02\x9d\x01\x04\x12\x04\xb1\x15\x04=\n\x12\n\n\x06\0\x02\x9d\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xb1\x15\x04=\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\
    \x12\x04\xb2\x15\x04F\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xb2\x15\x04F\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\xb3\x15\
    \x04C\n\x12\n\n\x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x06\x12\x04\xb3\x15\
    \x04C\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\xb4\x15\x04D\n\x12\n\n\
    \x06\0\x02\x9d\x01\x04\xc2\xf3\x04\x07\x12\x04\xb4\x15\x04D\n\x0e\n\x06\
    \x06\0\x02\x9d\x01\x04\x12\x04\xb5\x15\x04A\nP\n\n\x06\0\x02\x9d\x01\x04\
    \xc2\xf3\x04\x08\x12\x04\xb5\x15\x04A\"<\x20needed\x20for\x20converting\
    \x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\n\x0e\n\x06\
    \x06\0\x02\x9d\x01\x04\x12\x04\xb7\x15\x04F\n\xcc\x01\n\n\x06\0\x02\x9d\
    \x01\x04\xc2\xf3\x04\t\x12\x04\xb7\x15\x04F\x1a\x91\x01\x20option\x20(cl\
    arifai.auth.util.cl_depending_scopes)\x20=\x20Predict;\x20//\x20optional\
    ,\x20needed\x20for\x20add_task_annotations.go\x20when\x20saved\x20search\
    \x20uses\x20visual\x20search\n\"$\x20needed\x20for\x20add_task_annotatio\
    ns.go\n\n\x0e\n\x06\x06\0\x02\x9d\x01\x04\x12\x04\xb8\x15\x04F\n8\n\n\
    \x06\0\x02\x9d\x01\x04\xc2\xf3\x04\n\x12\x04\xb8\x15\x04F\"$\x20needed\
    \x20for\x20add_task_annotations.go\n\n(\n\x05\x06\0\x02\x9e\x01\x12\x06\
    \xbc\x15\x02\xc6\x15\x03\x1a\x17\x20Task\x20annotation\x20count\n\n\x0e\
    \n\x06\x06\0\x02\x9e\x01\x01\x12\x04\xbc\x15\x06\x1c\n\x0e\n\x06\x06\0\
    \x02\x9e\x01\x02\x12\x04\xbc\x15\x1e1\n\x0e\n\x06\x06\0\x02\x9e\x01\x03\
    \x12\x04\xbc\x15<S\n\x10\n\x06\x06\0\x02\x9e\x01\x04\x12\x06\xbd\x15\x04\
    \xc2\x15\x06\n\x14\n\n\x06\0\x02\x9e\x01\x04\xb0\xca\xbc\"\x12\x06\xbd\
    \x15\x04\xc2\x15\x06\n\x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xc3\x15\
    \x047\n\x11\n\t\x06\0\x02\x9e\x01\x04\xc3\xf3\x04\x12\x04\xc3\x15\x047\n\
    \x0e\n\x06\x06\0\x02\x9e\x01\x04\x12\x04\xc4\x15\x04?\n\x12\n\n\x06\0\
    \x02\x9e\x01\x04\xc2\xf3\x04\0\x12\x04\xc4\x15\x04?\n\x0e\n\x06\x06\0\
    \x02\x9e\x01\x04\x12\x04\xc5\x15\x04@\n\x12\n\n\x06\0\x02\x9e\x01\x04\
    \xc2\xf3\x04\x01\x12\x04\xc5\x15\x04@\n#\n\x05\x06\0\x02\x9f\x01\x12\x06\
    \xc9\x15\x02\xd3\x15\x03\x1a\x12\x20Task\x20Input\x20count\n\n\x0e\n\x06\
    \x06\0\x02\x9f\x01\x01\x12\x04\xc9\x15\x06\x17\n\x0e\n\x06\x06\0\x02\x9f\
    \x01\x02\x12\x04\xc9\x15\x19,\n\x0e\n\x06\x06\0\x02\x9f\x01\x03\x12\x04\
    \xc9\x157N\n\x10\n\x06\x06\0\x02\x9f\x01\x04\x12\x06\xca\x15\x04\xcf\x15\
    \x06\n\x14\n\n\x06\0\x02\x9f\x01\x04\xb0\xca\xbc\"\x12\x06\xca\x15\x04\
    \xcf\x15\x06\n\x0e\n\x06\x06\0\x02\x9f\x01\x04\x12\x04\xd0\x15\x047\n\
    \x11\n\t\x06\0\x02\x9f\x01\x04\xc3\xf3\x04\x12\x04\xd0\x15\x047\n\x0e\n\
    \x06\x06\0\x02\x9f\x01\x04\x12\x04\xd1\x15\x04?\n\x12\n\n\x06\0\x02\x9f\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xd1\x15\x04?\n\x0e\n\x06\x06\0\x02\x9f\
    \x01\x04\x12\x04\xd2\x15\x04@\n\x12\n\n\x06\0\x02\x9f\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xd2\x15\x04@\n3\n\x05\x06\0\x02\xa0\x01\x12\x06\xd6\x15\
    \x02\xe4\x15\x03\x1a\"\x20Get\x20a\x20specific\x20task\x20from\x20an\x20\
    app.\n\n\x0e\n\x06\x06\0\x02\xa0\x01\x01\x12\x04\xd6\x15\x06\r\n\x0e\n\
    \x06\x06\0\x02\xa0\x01\x02\x12\x04\xd6\x15\x0f\x1d\n\x0e\n\x06\x06\0\x02\
    \xa0\x01\x03\x12\x04\xd6\x15(:\n\x10\n\x06\x06\0\x02\xa0\x01\x04\x12\x06\
    \xd7\x15\x04\xdc\x15\x06\n\x14\n\n\x06\0\x02\xa0\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xd7\x15\x04\xdc\x15\x06\n\x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\
    \x04\xdd\x15\x047\n\x11\n\t\x06\0\x02\xa0\x01\x04\xc3\xf3\x04\x12\x04\
    \xdd\x15\x047\n\x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\x04\xde\x15\x04?\n\
    \x12\n\n\x06\0\x02\xa0\x01\x04\xc2\xf3\x04\0\x12\x04\xde\x15\x04?\n\x0e\
    \n\x06\x06\0\x02\xa0\x01\x04\x12\x04\xdf\x15\x04@\n\x12\n\n\x06\0\x02\
    \xa0\x01\x04\xc2\xf3\x04\x01\x12\x04\xdf\x15\x04@\n\x0e\n\x06\x06\0\x02\
    \xa0\x01\x04\x12\x04\xe0\x15\x04F\n\x12\n\n\x06\0\x02\xa0\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xe0\x15\x04F\n\x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\
    \x04\xe1\x15\x04C\n\x12\n\n\x06\0\x02\xa0\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xe1\x15\x04C\n\x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\x04\xe2\x15\x04D\
    \n\x12\n\n\x06\0\x02\xa0\x01\x04\xc2\xf3\x04\x04\x12\x04\xe2\x15\x04D\n\
    \x0e\n\x06\x06\0\x02\xa0\x01\x04\x12\x04\xe3\x15\x04A\nP\n\n\x06\0\x02\
    \xa0\x01\x04\xc2\xf3\x04\x05\x12\x04\xe3\x15\x04A\"<\x20needed\x20for\
    \x20converting\x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\
    \n*\n\x05\x06\0\x02\xa1\x01\x12\x06\xe7\x15\x02\xf5\x15\x03\x1a\x19\x20L\
    ist\x20tasks\x20from\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\xa1\x01\x01\
    \x12\x04\xe7\x15\x06\x0f\n\x0e\n\x06\x06\0\x02\xa1\x01\x02\x12\x04\xe7\
    \x15\x11!\n\x0e\n\x06\x06\0\x02\xa1\x01\x03\x12\x04\xe7\x15,=\n\x10\n\
    \x06\x06\0\x02\xa1\x01\x04\x12\x06\xe8\x15\x04\xed\x15\x06\n\x14\n\n\x06\
    \0\x02\xa1\x01\x04\xb0\xca\xbc\"\x12\x06\xe8\x15\x04\xed\x15\x06\n\x0e\n\
    \x06\x06\0\x02\xa1\x01\x04\x12\x04\xee\x15\x047\n\x11\n\t\x06\0\x02\xa1\
    \x01\x04\xc3\xf3\x04\x12\x04\xee\x15\x047\n\x0e\n\x06\x06\0\x02\xa1\x01\
    \x04\x12\x04\xef\x15\x04?\n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xef\x15\x04?\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xf0\x15\
    \x04@\n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\x01\x12\x04\xf0\x15\
    \x04@\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xf1\x15\x04F\n\x12\n\n\
    \x06\0\x02\xa1\x01\x04\xc2\xf3\x04\x02\x12\x04\xf1\x15\x04F\n\x0e\n\x06\
    \x06\0\x02\xa1\x01\x04\x12\x04\xf2\x15\x04C\n\x12\n\n\x06\0\x02\xa1\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\xf2\x15\x04C\n\x0e\n\x06\x06\0\x02\xa1\x01\
    \x04\x12\x04\xf3\x15\x04D\n\x12\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\
    \x04\x12\x04\xf3\x15\x04D\n\x0e\n\x06\x06\0\x02\xa1\x01\x04\x12\x04\xf4\
    \x15\x04A\nP\n\n\x06\0\x02\xa1\x01\x04\xc2\xf3\x04\x05\x12\x04\xf4\x15\
    \x04A\"<\x20needed\x20for\x20converting\x20workers\x20internal\x20ids\
    \x20to\x20external\x20ids\n\n+\n\x05\x06\0\x02\xa2\x01\x12\x06\xf8\x15\
    \x02\x8d\x16\x03\x1a\x1a\x20Patch\x20one\x20or\x20more\x20tasks.\n\n\x0e\
    \n\x06\x06\0\x02\xa2\x01\x01\x12\x04\xf8\x15\x06\x10\n\x0e\n\x06\x06\0\
    \x02\xa2\x01\x02\x12\x04\xf8\x15\x12#\n\x0e\n\x06\x06\0\x02\xa2\x01\x03\
    \x12\x04\xf8\x15.?\n\x10\n\x06\x06\0\x02\xa2\x01\x04\x12\x06\xf9\x15\x04\
    \x80\x16\x06\n\x14\n\n\x06\0\x02\xa2\x01\x04\xb0\xca\xbc\"\x12\x06\xf9\
    \x15\x04\x80\x16\x06\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\x81\x16\
    \x047\n\x11\n\t\x06\0\x02\xa2\x01\x04\xc3\xf3\x04\x12\x04\x81\x16\x047\n\
    \x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\x82\x16\x04?\n\x12\n\n\x06\0\
    \x02\xa2\x01\x04\xc2\xf3\x04\0\x12\x04\x82\x16\x04?\n\x0e\n\x06\x06\0\
    \x02\xa2\x01\x04\x12\x04\x83\x16\x04@\n\x12\n\n\x06\0\x02\xa2\x01\x04\
    \xc2\xf3\x04\x01\x12\x04\x83\x16\x04@\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\
    \x12\x04\x84\x16\x04@\n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x02\
    \x12\x04\x84\x16\x04@\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\x85\x16\
    \x04A\n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x03\x12\x04\x85\x16\
    \x04A\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\x86\x16\x04F\n\x12\n\n\
    \x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x04\x12\x04\x86\x16\x04F\n\x0e\n\x06\
    \x06\0\x02\xa2\x01\x04\x12\x04\x87\x16\x04C\n\x12\n\n\x06\0\x02\xa2\x01\
    \x04\xc2\xf3\x04\x05\x12\x04\x87\x16\x04C\n\x0e\n\x06\x06\0\x02\xa2\x01\
    \x04\x12\x04\x88\x16\x04D\n\x12\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\
    \x06\x12\x04\x88\x16\x04D\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\x89\
    \x16\x04A\nP\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x07\x12\x04\x89\x16\
    \x04A\"<\x20needed\x20for\x20converting\x20workers\x20internal\x20ids\
    \x20to\x20external\x20ids\n\n\x0e\n\x06\x06\0\x02\xa2\x01\x04\x12\x04\
    \x8b\x16\x04F\n\xcc\x01\n\n\x06\0\x02\xa2\x01\x04\xc2\xf3\x04\x08\x12\
    \x04\x8b\x16\x04F\x1a\x91\x01\x20option\x20(clarifai.auth.util.cl_depend\
    ing_scopes)\x20=\x20Predict;\x20//\x20optional,\x20needed\x20for\x20add_\
    task_annotations.go\x20when\x20saved\x20search\x20uses\x20visual\x20sear\
    ch\n\"$\x20needed\x20for\x20add_task_annotations.go\n\n\x0e\n\x06\x06\0\
    \x02\xa2\x01\x04\x12\x04\x8c\x16\x04F\n8\n\n\x06\0\x02\xa2\x01\x04\xc2\
    \xf3\x04\t\x12\x04\x8c\x16\x04F\"$\x20needed\x20for\x20add_task_annotati\
    ons.go\n\n8\n\x05\x06\0\x02\xa3\x01\x12\x06\x90\x16\x02\x9e\x16\x03\x1a'\
    \x20Delete\x20multiple\x20tasks\x20in\x20one\x20request.\n\n\x0e\n\x06\
    \x06\0\x02\xa3\x01\x01\x12\x04\x90\x16\x06\x11\n\x0e\n\x06\x06\0\x02\xa3\
    \x01\x02\x12\x04\x90\x16\x13%\n\x0e\n\x06\x06\0\x02\xa3\x01\x03\x12\x04\
    \x90\x160P\n\x10\n\x06\x06\0\x02\xa3\x01\x04\x12\x06\x91\x16\x04\x98\x16\
    \x06\n\x14\n\n\x06\0\x02\xa3\x01\x04\xb0\xca\xbc\"\x12\x06\x91\x16\x04\
    \x98\x16\x06\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x99\x16\x047\n\
    \x11\n\t\x06\0\x02\xa3\x01\x04\xc3\xf3\x04\x12\x04\x99\x16\x047\n\x0e\n\
    \x06\x06\0\x02\xa3\x01\x04\x12\x04\x9a\x16\x04?\n\x12\n\n\x06\0\x02\xa3\
    \x01\x04\xc2\xf3\x04\0\x12\x04\x9a\x16\x04?\n\x0e\n\x06\x06\0\x02\xa3\
    \x01\x04\x12\x04\x9b\x16\x04@\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\x9b\x16\x04@\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\
    \x9c\x16\x04@\n\x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \x9c\x16\x04@\n\x0e\n\x06\x06\0\x02\xa3\x01\x04\x12\x04\x9d\x16\x04C\n\
    \x12\n\n\x06\0\x02\xa3\x01\x04\xc2\xf3\x04\x03\x12\x04\x9d\x16\x04C\n\
    \x81\x01\n\x05\x06\0\x02\xa4\x01\x12\x06\xa8\x16\x02\xbd\x16\x03\x1a\x13\
    \x20Add\x20Label\x20orders.\n2[//////////////////////////////////////\n\
    \x20Label\x20Order\n//////////////////////////////////////\n\n\x0e\n\x06\
    \x06\0\x02\xa4\x01\x01\x12\x04\xa8\x16\x06\x15\n\x0e\n\x06\x06\0\x02\xa4\
    \x01\x02\x12\x04\xa8\x16\x17-\n\x0e\n\x06\x06\0\x02\xa4\x01\x03\x12\x04\
    \xa8\x168O\n\x10\n\x06\x06\0\x02\xa4\x01\x04\x12\x06\xa9\x16\x04\xb0\x16\
    \x06\n\x14\n\n\x06\0\x02\xa4\x01\x04\xb0\xca\xbc\"\x12\x06\xa9\x16\x04\
    \xb0\x16\x06\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xb2\x16\x047\n\
    \x11\n\t\x06\0\x02\xa4\x01\x04\xc3\xf3\x04\x12\x04\xb2\x16\x047\n\x0e\n\
    \x06\x06\0\x02\xa4\x01\x04\x12\x04\xb3\x16\x04?\n\x12\n\n\x06\0\x02\xa4\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xb3\x16\x04?\n\x0e\n\x06\x06\0\x02\xa4\
    \x01\x04\x12\x04\xb4\x16\x04F\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xb4\x16\x04F\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\
    \xb5\x16\x04F\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xb5\x16\x04F\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xb6\x16\x04@\n\
    \x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x03\x12\x04\xb6\x16\x04@\n\
    \x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xb7\x16\x04@\n\x12\n\n\x06\0\
    \x02\xa4\x01\x04\xc2\xf3\x04\x04\x12\x04\xb7\x16\x04@\n\x0e\n\x06\x06\0\
    \x02\xa4\x01\x04\x12\x04\xb8\x16\x04A\n\x12\n\n\x06\0\x02\xa4\x01\x04\
    \xc2\xf3\x04\x05\x12\x04\xb8\x16\x04A\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\
    \x12\x04\xb9\x16\x04F\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x06\
    \x12\x04\xb9\x16\x04F\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xba\x16\
    \x04C\n\x12\n\n\x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x07\x12\x04\xba\x16\
    \x04C\n\x0e\n\x06\x06\0\x02\xa4\x01\x04\x12\x04\xbb\x16\x04D\n\x12\n\n\
    \x06\0\x02\xa4\x01\x04\xc2\xf3\x04\x08\x12\x04\xbb\x16\x04D\n\x0e\n\x06\
    \x06\0\x02\xa4\x01\x04\x12\x04\xbc\x16\x04A\nP\n\n\x06\0\x02\xa4\x01\x04\
    \xc2\xf3\x04\t\x12\x04\xbc\x16\x04A\"<\x20needed\x20for\x20converting\
    \x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\n%\n\x05\x06\0\
    \x02\xa5\x01\x12\x06\xc0\x16\x02\xcd\x16\x03\x1a\x14\x20Get\x20a\x20labe\
    l\x20order.\n\n\x0e\n\x06\x06\0\x02\xa5\x01\x01\x12\x04\xc0\x16\x06\x13\
    \n\x0e\n\x06\x06\0\x02\xa5\x01\x02\x12\x04\xc0\x16\x15)\n\x0e\n\x06\x06\
    \0\x02\xa5\x01\x03\x12\x04\xc0\x164L\n\x10\n\x06\x06\0\x02\xa5\x01\x04\
    \x12\x06\xc1\x16\x04\xc6\x16\x06\n\x14\n\n\x06\0\x02\xa5\x01\x04\xb0\xca\
    \xbc\"\x12\x06\xc1\x16\x04\xc6\x16\x06\n\x0e\n\x06\x06\0\x02\xa5\x01\x04\
    \x12\x04\xc8\x16\x047\n\x11\n\t\x06\0\x02\xa5\x01\x04\xc3\xf3\x04\x12\
    \x04\xc8\x16\x047\n\x0e\n\x06\x06\0\x02\xa5\x01\x04\x12\x04\xc9\x16\x04?\
    \n\x12\n\n\x06\0\x02\xa5\x01\x04\xc2\xf3\x04\0\x12\x04\xc9\x16\x04?\n\
    \x0e\n\x06\x06\0\x02\xa5\x01\x04\x12\x04\xca\x16\x04F\n\x12\n\n\x06\0\
    \x02\xa5\x01\x04\xc2\xf3\x04\x01\x12\x04\xca\x16\x04F\n\x0e\n\x06\x06\0\
    \x02\xa5\x01\x04\x12\x04\xcb\x16\x04C\n\x12\n\n\x06\0\x02\xa5\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xcb\x16\x04C\n\x0e\n\x06\x06\0\x02\xa5\x01\x04\
    \x12\x04\xcc\x16\x04@\n5\n\n\x06\0\x02\xa5\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xcc\x16\x04@\"!\x20needed\x20because\x20task\x20is\x20embedded\n\n%\
    \n\x05\x06\0\x02\xa6\x01\x12\x06\xd0\x16\x02\xdd\x16\x03\x1a\x14\x20List\
    \x20label\x20orders.\n\n\x0e\n\x06\x06\0\x02\xa6\x01\x01\x12\x04\xd0\x16\
    \x06\x15\n\x0e\n\x06\x06\0\x02\xa6\x01\x02\x12\x04\xd0\x16\x17-\n\x0e\n\
    \x06\x06\0\x02\xa6\x01\x03\x12\x04\xd0\x168O\n\x10\n\x06\x06\0\x02\xa6\
    \x01\x04\x12\x06\xd1\x16\x04\xd6\x16\x06\n\x14\n\n\x06\0\x02\xa6\x01\x04\
    \xb0\xca\xbc\"\x12\x06\xd1\x16\x04\xd6\x16\x06\n\x0e\n\x06\x06\0\x02\xa6\
    \x01\x04\x12\x04\xd8\x16\x047\n\x11\n\t\x06\0\x02\xa6\x01\x04\xc3\xf3\
    \x04\x12\x04\xd8\x16\x047\n\x0e\n\x06\x06\0\x02\xa6\x01\x04\x12\x04\xd9\
    \x16\x04?\n\x12\n\n\x06\0\x02\xa6\x01\x04\xc2\xf3\x04\0\x12\x04\xd9\x16\
    \x04?\n\x0e\n\x06\x06\0\x02\xa6\x01\x04\x12\x04\xda\x16\x04F\n\x12\n\n\
    \x06\0\x02\xa6\x01\x04\xc2\xf3\x04\x01\x12\x04\xda\x16\x04F\n\x0e\n\x06\
    \x06\0\x02\xa6\x01\x04\x12\x04\xdb\x16\x04C\n\x12\n\n\x06\0\x02\xa6\x01\
    \x04\xc2\xf3\x04\x02\x12\x04\xdb\x16\x04C\n\x0e\n\x06\x06\0\x02\xa6\x01\
    \x04\x12\x04\xdc\x16\x04@\n5\n\n\x06\0\x02\xa6\x01\x04\xc2\xf3\x04\x03\
    \x12\x04\xdc\x16\x04@\"!\x20needed\x20because\x20task\x20is\x20embedded\
    \n\n2\n\x05\x06\0\x02\xa7\x01\x12\x06\xe0\x16\x02\xf2\x16\x03\x1a!\x20Pa\
    tch\x20one\x20or\x20more\x20label\x20orders.\n\n\x0e\n\x06\x06\0\x02\xa7\
    \x01\x01\x12\x04\xe0\x16\x06\x16\n\x0e\n\x06\x06\0\x02\xa7\x01\x02\x12\
    \x04\xe0\x16\x18/\n\x0e\n\x06\x06\0\x02\xa7\x01\x03\x12\x04\xe0\x16:Q\n\
    \x10\n\x06\x06\0\x02\xa7\x01\x04\x12\x06\xe1\x16\x04\xe8\x16\x06\n\x14\n\
    \n\x06\0\x02\xa7\x01\x04\xb0\xca\xbc\"\x12\x06\xe1\x16\x04\xe8\x16\x06\n\
    \x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\xea\x16\x047\n\x11\n\t\x06\0\
    \x02\xa7\x01\x04\xc3\xf3\x04\x12\x04\xea\x16\x047\n\x0e\n\x06\x06\0\x02\
    \xa7\x01\x04\x12\x04\xeb\x16\x04?\n\x12\n\n\x06\0\x02\xa7\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xeb\x16\x04?\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\
    \x04\xec\x16\x04F\n\x12\n\n\x06\0\x02\xa7\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xec\x16\x04F\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\xed\x16\x04F\
    \n\x12\n\n\x06\0\x02\xa7\x01\x04\xc2\xf3\x04\x02\x12\x04\xed\x16\x04F\n\
    \x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\xee\x16\x04C\n\x12\n\n\x06\0\
    \x02\xa7\x01\x04\xc2\xf3\x04\x03\x12\x04\xee\x16\x04C\n\x0e\n\x06\x06\0\
    \x02\xa7\x01\x04\x12\x04\xef\x16\x04@\n\x12\n\n\x06\0\x02\xa7\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xef\x16\x04@\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\
    \x12\x04\xf0\x16\x04@\n\x12\n\n\x06\0\x02\xa7\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xf0\x16\x04@\n\x0e\n\x06\x06\0\x02\xa7\x01\x04\x12\x04\xf1\x16\
    \x04C\n\x12\n\n\x06\0\x02\xa7\x01\x04\xc2\xf3\x04\x06\x12\x04\xf1\x16\
    \x04C\n_\n\x05\x06\0\x02\xa8\x01\x12\x06\xf6\x16\x02\x87\x17\x03\x1aN\
    \x20Delete\x20multiple\x20label\x20orders\x20in\x20one\x20request.\n\x20\
    this\x20do\x20not\x20change\x20task\x20status\n\n\x0e\n\x06\x06\0\x02\
    \xa8\x01\x01\x12\x04\xf6\x16\x06\x17\n\x0e\n\x06\x06\0\x02\xa8\x01\x02\
    \x12\x04\xf6\x16\x191\n\x0e\n\x06\x06\0\x02\xa8\x01\x03\x12\x04\xf6\x16<\
    \\\n\x10\n\x06\x06\0\x02\xa8\x01\x04\x12\x06\xf7\x16\x04\xfe\x16\x06\n\
    \x14\n\n\x06\0\x02\xa8\x01\x04\xb0\xca\xbc\"\x12\x06\xf7\x16\x04\xfe\x16\
    \x06\n\x0e\n\x06\x06\0\x02\xa8\x01\x04\x12\x04\x80\x17\x047\n\x11\n\t\
    \x06\0\x02\xa8\x01\x04\xc3\xf3\x04\x12\x04\x80\x17\x047\n\x0e\n\x06\x06\
    \0\x02\xa8\x01\x04\x12\x04\x81\x17\x04?\n\x12\n\n\x06\0\x02\xa8\x01\x04\
    \xc2\xf3\x04\0\x12\x04\x81\x17\x04?\n\x0e\n\x06\x06\0\x02\xa8\x01\x04\
    \x12\x04\x82\x17\x04I\n\x12\n\n\x06\0\x02\xa8\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\x82\x17\x04I\n\x0e\n\x06\x06\0\x02\xa8\x01\x04\x12\x04\x83\x17\
    \x04F\n\x12\n\n\x06\0\x02\xa8\x01\x04\xc2\xf3\x04\x02\x12\x04\x83\x17\
    \x04F\n\x0e\n\x06\x06\0\x02\xa8\x01\x04\x12\x04\x84\x17\x04F\n\x12\n\n\
    \x06\0\x02\xa8\x01\x04\xc2\xf3\x04\x03\x12\x04\x84\x17\x04F\n\x0e\n\x06\
    \x06\0\x02\xa8\x01\x04\x12\x04\x85\x17\x04@\n\x12\n\n\x06\0\x02\xa8\x01\
    \x04\xc2\xf3\x04\x04\x12\x04\x85\x17\x04@\n\x0e\n\x06\x06\0\x02\xa8\x01\
    \x04\x12\x04\x86\x17\x04@\n\x12\n\n\x06\0\x02\xa8\x01\x04\xc2\xf3\x04\
    \x05\x12\x04\x86\x17\x04@\n\xf3\x02\n\x05\x06\0\x02\xa9\x01\x12\x06\x8f\
    \x17\x02\xa4\x17\x03\x1a\xe1\x02\x20Add\x20a\x20list\x20of\x20Collectors\
    \x20to\x20an\x20app.\n\x20In\x20the\x20handler\x20of\x20this\x20endpoint\
    \x20we\x20also\x20check\x20for\x20all\x20the\x20scopes\x20of\x20the\x20\
    \x20POST\x20/inputs\n\x20endpoint.\n\x20Those\x20current\x20scopes\x20ar\
    e\x20listed\x20here\x20as\x20a\x20hard\x20requirement.\n\x20They\x20are\
    \x20needed\x20when\x20adding\x20the\x20collectors\x20just\x20so\x20we\
    \x20now\x20that\x20you\x20have\x20permission\x20with\n\x20that\x20key\
    \x20at\x20least\x20to\x20do\x20the\x20writing\x20to\x20this\x20app\x20wi\
    th\x20POST\x20/inputs.\n\n\x0e\n\x06\x06\0\x02\xa9\x01\x01\x12\x04\x8f\
    \x17\x06\x14\n\x0e\n\x06\x06\0\x02\xa9\x01\x02\x12\x04\x8f\x17\x16+\n\
    \x0e\n\x06\x06\0\x02\xa9\x01\x03\x12\x04\x8f\x176L\n\x10\n\x06\x06\0\x02\
    \xa9\x01\x04\x12\x06\x90\x17\x04\x97\x17\x06\n\x14\n\n\x06\0\x02\xa9\x01\
    \x04\xb0\xca\xbc\"\x12\x06\x90\x17\x04\x97\x17\x06\n\x0e\n\x06\x06\0\x02\
    \xa9\x01\x04\x12\x04\x98\x17\x047\n\x11\n\t\x06\0\x02\xa9\x01\x04\xc3\
    \xf3\x04\x12\x04\x98\x17\x047\n\x0e\n\x06\x06\0\x02\xa9\x01\x04\x12\x04\
    \x99\x17\x04?\n\x12\n\n\x06\0\x02\xa9\x01\x04\xc2\xf3\x04\0\x12\x04\x99\
    \x17\x04?\n\x0e\n\x06\x06\0\x02\xa9\x01\x04\x12\x04\x9a\x17\x04A\n\x12\n\
    \n\x06\0\x02\xa9\x01\x04\xc2\xf3\x04\x01\x12\x04\x9a\x17\x04A\n\x0e\n\
    \x06\x06\0\x02\xa9\x01\x04\x12\x04\x9b\x17\x04F\n\x12\n\n\x06\0\x02\xa9\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\x9b\x17\x04F\n\x0e\n\x06\x06\0\x02\xa9\
    \x01\x04\x12\x04\x9c\x17\x04F\n\x12\n\n\x06\0\x02\xa9\x01\x04\xc2\xf3\
    \x04\x03\x12\x04\x9c\x17\x04F\n\x0e\n\x06\x06\0\x02\xa9\x01\x04\x12\x04\
    \x9d\x17\x04E\n\x12\n\n\x06\0\x02\xa9\x01\x04\xc2\xf3\x04\x04\x12\x04\
    \x9d\x17\x04E\n\x0e\n\x06\x06\0\x02\xa9\x01\x04\x12\x04\x9e\x17\x04C\n\
    \x12\n\n\x06\0\x02\xa9\x01\x04\xc2\xf3\x04\x05\x12\x04\x9e\x17\x04C\n\
    \x0e\n\x06\x06\0\x02\xa9\x01\x04\x12\x04\x9f\x17\x04A\n\x12\n\n\x06\0\
    \x02\xa9\x01\x04\xc2\xf3\x04\x06\x12\x04\x9f\x17\x04A\n\x0e\n\x06\x06\0\
    \x02\xa9\x01\x04\x12\x04\xa0\x17\x04A\n\x12\n\n\x06\0\x02\xa9\x01\x04\
    \xc2\xf3\x04\x07\x12\x04\xa0\x17\x04A\n\x0e\n\x06\x06\0\x02\xa9\x01\x04\
    \x12\x04\xa1\x17\x04A\n\x12\n\n\x06\0\x02\xa9\x01\x04\xc2\xf3\x04\x08\
    \x12\x04\xa1\x17\x04A\n\x0e\n\x06\x06\0\x02\xa9\x01\x04\x12\x04\xa2\x17\
    \x04>\n\x12\n\n\x06\0\x02\xa9\x01\x04\xc2\xf3\x04\t\x12\x04\xa2\x17\x04>\
    \n\x0e\n\x06\x06\0\x02\xa9\x01\x04\x12\x04\xa3\x17\x04D\n\x12\n\n\x06\0\
    \x02\xa9\x01\x04\xc2\xf3\x04\n\x12\x04\xa3\x17\x04D\n8\n\x05\x06\0\x02\
    \xaa\x01\x12\x06\xa7\x17\x02\xb1\x17\x03\x1a'\x20Get\x20a\x20specific\
    \x20collector\x20from\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\xaa\x01\x01\
    \x12\x04\xa7\x17\x06\x12\n\x0e\n\x06\x06\0\x02\xaa\x01\x02\x12\x04\xa7\
    \x17\x14'\n\x0e\n\x06\x06\0\x02\xaa\x01\x03\x12\x04\xa7\x172I\n\x10\n\
    \x06\x06\0\x02\xaa\x01\x04\x12\x06\xa8\x17\x04\xad\x17\x06\n\x14\n\n\x06\
    \0\x02\xaa\x01\x04\xb0\xca\xbc\"\x12\x06\xa8\x17\x04\xad\x17\x06\n\x0e\n\
    \x06\x06\0\x02\xaa\x01\x04\x12\x04\xae\x17\x047\n\x11\n\t\x06\0\x02\xaa\
    \x01\x04\xc3\xf3\x04\x12\x04\xae\x17\x047\n\x0e\n\x06\x06\0\x02\xaa\x01\
    \x04\x12\x04\xaf\x17\x04?\n\x12\n\n\x06\0\x02\xaa\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xaf\x17\x04?\n\x0e\n\x06\x06\0\x02\xaa\x01\x04\x12\x04\xb0\x17\
    \x04E\n\x12\n\n\x06\0\x02\xaa\x01\x04\xc2\xf3\x04\x01\x12\x04\xb0\x17\
    \x04E\n+\n\x05\x06\0\x02\xab\x01\x12\x06\xb4\x17\x02\xbe\x17\x03\x1a\x1a\
    \x20List\x20all\x20the\x20collectors.\n\n\x0e\n\x06\x06\0\x02\xab\x01\
    \x01\x12\x04\xb4\x17\x06\x14\n\x0e\n\x06\x06\0\x02\xab\x01\x02\x12\x04\
    \xb4\x17\x16+\n\x0e\n\x06\x06\0\x02\xab\x01\x03\x12\x04\xb4\x176L\n\x10\
    \n\x06\x06\0\x02\xab\x01\x04\x12\x06\xb5\x17\x04\xba\x17\x06\n\x14\n\n\
    \x06\0\x02\xab\x01\x04\xb0\xca\xbc\"\x12\x06\xb5\x17\x04\xba\x17\x06\n\
    \x0e\n\x06\x06\0\x02\xab\x01\x04\x12\x04\xbb\x17\x047\n\x11\n\t\x06\0\
    \x02\xab\x01\x04\xc3\xf3\x04\x12\x04\xbb\x17\x047\n\x0e\n\x06\x06\0\x02\
    \xab\x01\x04\x12\x04\xbc\x17\x04?\n\x12\n\n\x06\0\x02\xab\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xbc\x17\x04?\n\x0e\n\x06\x06\0\x02\xab\x01\x04\x12\
    \x04\xbd\x17\x04E\n\x12\n\n\x06\0\x02\xab\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xbd\x17\x04E\n0\n\x05\x06\0\x02\xac\x01\x12\x06\xc1\x17\x02\xce\x17\
    \x03\x1a\x1f\x20Patch\x20one\x20or\x20more\x20collectors.\n\n\x0e\n\x06\
    \x06\0\x02\xac\x01\x01\x12\x04\xc1\x17\x06\x15\n\x0e\n\x06\x06\0\x02\xac\
    \x01\x02\x12\x04\xc1\x17\x17-\n\x0e\n\x06\x06\0\x02\xac\x01\x03\x12\x04\
    \xc1\x178N\n\x10\n\x06\x06\0\x02\xac\x01\x04\x12\x06\xc2\x17\x04\xc9\x17\
    \x06\n\x14\n\n\x06\0\x02\xac\x01\x04\xb0\xca\xbc\"\x12\x06\xc2\x17\x04\
    \xc9\x17\x06\n\x0e\n\x06\x06\0\x02\xac\x01\x04\x12\x04\xca\x17\x047\n\
    \x11\n\t\x06\0\x02\xac\x01\x04\xc3\xf3\x04\x12\x04\xca\x17\x047\n\x0e\n\
    \x06\x06\0\x02\xac\x01\x04\x12\x04\xcb\x17\x04?\n\x12\n\n\x06\0\x02\xac\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xcb\x17\x04?\n\x0e\n\x06\x06\0\x02\xac\
    \x01\x04\x12\x04\xcc\x17\x04E\n\x12\n\n\x06\0\x02\xac\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xcc\x17\x04E\n\x0e\n\x06\x06\0\x02\xac\x01\x04\x12\x04\
    \xcd\x17\x04E\n\x12\n\n\x06\0\x02\xac\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xcd\x17\x04E\n\x90\x01\n\x05\x06\0\x02\xad\x01\x12\x06\xd4\x17\x02\xe2\
    \x17\x03\x1a\x7f\x20Delete\x20multiple\x20collectors\x20in\x20one\x20req\
    uest.\n\x20This\x20call\x20is\x20asynchronous.\x20Use\x20DeleteCollector\
    \x20if\x20you\x20want\x20a\x20synchronous\x20version.\n\n\x0e\n\x06\x06\
    \0\x02\xad\x01\x01\x12\x04\xd4\x17\x06\x16\n\x0e\n\x06\x06\0\x02\xad\x01\
    \x02\x12\x04\xd4\x17\x18/\n\x0e\n\x06\x06\0\x02\xad\x01\x03\x12\x04\xd4\
    \x17:Z\n\x10\n\x06\x06\0\x02\xad\x01\x04\x12\x06\xd5\x17\x04\xdc\x17\x06\
    \n\x14\n\n\x06\0\x02\xad\x01\x04\xb0\xca\xbc\"\x12\x06\xd5\x17\x04\xdc\
    \x17\x06\n\x0e\n\x06\x06\0\x02\xad\x01\x04\x12\x04\xdd\x17\x047\n\x11\n\
    \t\x06\0\x02\xad\x01\x04\xc3\xf3\x04\x12\x04\xdd\x17\x047\n\x0e\n\x06\
    \x06\0\x02\xad\x01\x04\x12\x04\xde\x17\x04?\n\x12\n\n\x06\0\x02\xad\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xde\x17\x04?\n\x0e\n\x06\x06\0\x02\xad\x01\
    \x04\x12\x04\xdf\x17\x04E\n\x12\n\n\x06\0\x02\xad\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xdf\x17\x04E\n\x0e\n\x06\x06\0\x02\xad\x01\x04\x12\x04\xe0\
    \x17\x04H\n\x12\n\n\x06\0\x02\xad\x01\x04\xc2\xf3\x04\x02\x12\x04\xe0\
    \x17\x04H\n\x0e\n\x06\x06\0\x02\xad\x01\x04\x12\x04\xe1\x17\x04E\n\x12\n\
    \n\x06\0\x02\xad\x01\x04\xc2\xf3\x04\x03\x12\x04\xe1\x17\x04E\n!\n\x05\
    \x06\0\x02\xae\x01\x12\x06\xe5\x17\x02\xef\x17\x03\x1a\x10\x20PostStatVa\
    lues\n\n\x0e\n\x06\x06\0\x02\xae\x01\x01\x12\x04\xe5\x17\x06\x14\n\x0e\n\
    \x06\x06\0\x02\xae\x01\x02\x12\x04\xe5\x17\x16+\n\x0e\n\x06\x06\0\x02\
    \xae\x01\x03\x12\x04\xe5\x176L\n\x10\n\x06\x06\0\x02\xae\x01\x04\x12\x06\
    \xe6\x17\x04\xed\x17\x06\n\x14\n\n\x06\0\x02\xae\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xe6\x17\x04\xed\x17\x06\n\x0e\n\x06\x06\0\x02\xae\x01\x04\x12\
    \x04\xee\x17\x047\n\x11\n\t\x06\0\x02\xae\x01\x04\xc3\xf3\x04\x12\x04\
    \xee\x17\x047\n*\n\x05\x06\0\x02\xaf\x01\x12\x06\xf2\x17\x02\xfd\x17\x03\
    \x1a\x19\x20PostStatValuesAggregate\n\n\x0e\n\x06\x06\0\x02\xaf\x01\x01\
    \x12\x04\xf2\x17\x06\x1d\n\x0e\n\x06\x06\0\x02\xaf\x01\x02\x12\x04\xf2\
    \x17\x1f=\n\x0e\n\x06\x06\0\x02\xaf\x01\x03\x12\x04\xf2\x17Hg\n\x10\n\
    \x06\x06\0\x02\xaf\x01\x04\x12\x06\xf3\x17\x04\xfa\x17\x06\n\x14\n\n\x06\
    \0\x02\xaf\x01\x04\xb0\xca\xbc\"\x12\x06\xf3\x17\x04\xfa\x17\x06\n\x0e\n\
    \x06\x06\0\x02\xaf\x01\x04\x12\x04\xfb\x17\x047\n\x11\n\t\x06\0\x02\xaf\
    \x01\x04\xc3\xf3\x04\x12\x04\xfb\x17\x047\n\x0e\n\x06\x06\0\x02\xaf\x01\
    \x04\x12\x04\xfc\x17\x04?\n\x12\n\n\x06\0\x02\xaf\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xfc\x17\x04?\n=\n\x05\x06\0\x02\xb0\x01\x12\x06\x87\x18\x02\x8d\
    \x18\x03\x1a,\x20Increase\x20the\x20view\x20metric\x20for\x20a\x20detail\
    \x20view\n\n\x0e\n\x06\x06\0\x02\xb0\x01\x01\x12\x04\x87\x18\x06\x1d\n\
    \x0e\n\x06\x06\0\x02\xb0\x01\x02\x12\x04\x87\x18\x1f=\n\x0e\n\x06\x06\0\
    \x02\xb0\x01\x03\x12\x04\x87\x18Hh\n\x10\n\x06\x06\0\x02\xb0\x01\x04\x12\
    \x06\x88\x18\x04\x8b\x18\x06\n\x14\n\n\x06\0\x02\xb0\x01\x04\xb0\xca\xbc\
    \"\x12\x06\x88\x18\x04\x8b\x18\x06\n\x0e\n\x06\x06\0\x02\xb0\x01\x04\x12\
    \x04\x8c\x18\x047\n\x11\n\t\x06\0\x02\xb0\x01\x04\xc3\xf3\x04\x12\x04\
    \x8c\x18\x047\n:\n\x05\x06\0\x02\xb1\x01\x12\x06\x90\x18\x02\x98\x18\x03\
    \x1a)\x20List\x20the\x20view\x20metrics\x20for\x20a\x20detail\x20view\n\
    \n\x0e\n\x06\x06\0\x02\xb1\x01\x01\x12\x04\x90\x18\x06\x1e\n\x0e\n\x06\
    \x06\0\x02\xb1\x01\x02\x12\x04\x90\x18\x20?\n\x0e\n\x06\x06\0\x02\xb1\
    \x01\x03\x12\x04\x90\x18Jj\n\x10\n\x06\x06\0\x02\xb1\x01\x04\x12\x06\x91\
    \x18\x04\x96\x18\x06\n\x14\n\n\x06\0\x02\xb1\x01\x04\xb0\xca\xbc\"\x12\
    \x06\x91\x18\x04\x96\x18\x06\n\x0e\n\x06\x06\0\x02\xb1\x01\x04\x12\x04\
    \x97\x18\x047\n\x11\n\t\x06\0\x02\xb1\x01\x04\xc3\xf3\x04\x12\x04\x97\
    \x18\x047\n5\n\x05\x06\0\x02\xb2\x01\x12\x06\xa3\x18\x02\xaa\x18\x03\x1a\
    $\x20Get\x20a\x20specific\x20module\x20from\x20an\x20app.\n\n\x0e\n\x06\
    \x06\0\x02\xb2\x01\x01\x12\x04\xa3\x18\x06\x0f\n\x0e\n\x06\x06\0\x02\xb2\
    \x01\x02\x12\x04\xa3\x18\x11!\n\x0e\n\x06\x06\0\x02\xb2\x01\x03\x12\x04\
    \xa3\x18,@\n\x10\n\x06\x06\0\x02\xb2\x01\x04\x12\x06\xa4\x18\x04\xa6\x18\
    \x06\n\x14\n\n\x06\0\x02\xb2\x01\x04\xb0\xca\xbc\"\x12\x06\xa4\x18\x04\
    \xa6\x18\x06\n\x0e\n\x06\x06\0\x02\xb2\x01\x04\x12\x04\xa7\x18\x047\n\
    \x11\n\t\x06\0\x02\xb2\x01\x04\xc3\xf3\x04\x12\x04\xa7\x18\x047\n\x0e\n\
    \x06\x06\0\x02\xb2\x01\x04\x12\x04\xa8\x18\x04?\n\x12\n\n\x06\0\x02\xb2\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xa8\x18\x04?\n\x0e\n\x06\x06\0\x02\xb2\
    \x01\x04\x12\x04\xa9\x18\x04B\n\x12\n\n\x06\0\x02\xb2\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xa9\x18\x04B\nH\n\x05\x06\0\x02\xb3\x01\x12\x06\xad\x18\
    \x02\xba\x18\x03\x1a7\x20List\x20all\x20the\x20modules\x20in\x20communit\
    y,\x20by\x20user\x20or\x20by\x20app.\n\n\x0e\n\x06\x06\0\x02\xb3\x01\x01\
    \x12\x04\xad\x18\x06\x11\n\x0e\n\x06\x06\0\x02\xb3\x01\x02\x12\x04\xad\
    \x18\x13%\n\x0e\n\x06\x06\0\x02\xb3\x01\x03\x12\x04\xad\x180C\n\x10\n\
    \x06\x06\0\x02\xb3\x01\x04\x12\x06\xae\x18\x04\xb6\x18\x06\n\x14\n\n\x06\
    \0\x02\xb3\x01\x04\xb0\xca\xbc\"\x12\x06\xae\x18\x04\xb6\x18\x06\n\x0e\n\
    \x06\x06\0\x02\xb3\x01\x04\x12\x04\xb7\x18\x047\n\x11\n\t\x06\0\x02\xb3\
    \x01\x04\xc3\xf3\x04\x12\x04\xb7\x18\x047\n\x0e\n\x06\x06\0\x02\xb3\x01\
    \x04\x12\x04\xb8\x18\x04?\n\x12\n\n\x06\0\x02\xb3\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xb8\x18\x04?\n\x0e\n\x06\x06\0\x02\xb3\x01\x04\x12\x04\xb9\x18\
    \x04B\n\x12\n\n\x06\0\x02\xb3\x01\x04\xc2\xf3\x04\x01\x12\x04\xb9\x18\
    \x04B\n+\n\x05\x06\0\x02\xb4\x01\x12\x06\xbd\x18\x02\xc6\x18\x03\x1a\x1a\
    \x20Add\x20a\x20modules\x20to\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\xb4\
    \x01\x01\x12\x04\xbd\x18\x06\x11\n\x0e\n\x06\x06\0\x02\xb4\x01\x02\x12\
    \x04\xbd\x18\x13%\n\x0e\n\x06\x06\0\x02\xb4\x01\x03\x12\x04\xbd\x180C\n\
    \x10\n\x06\x06\0\x02\xb4\x01\x04\x12\x06\xbe\x18\x04\xc1\x18\x06\n\x14\n\
    \n\x06\0\x02\xb4\x01\x04\xb0\xca\xbc\"\x12\x06\xbe\x18\x04\xc1\x18\x06\n\
    \x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\xc2\x18\x047\n\x11\n\t\x06\0\
    \x02\xb4\x01\x04\xc3\xf3\x04\x12\x04\xc2\x18\x047\n\x0e\n\x06\x06\0\x02\
    \xb4\x01\x04\x12\x04\xc3\x18\x04?\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xc3\x18\x04?\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\
    \x04\xc4\x18\x04B\n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xc4\x18\x04B\n\x0e\n\x06\x06\0\x02\xb4\x01\x04\x12\x04\xc5\x18\x04B\
    \n\x12\n\n\x06\0\x02\xb4\x01\x04\xc2\xf3\x04\x02\x12\x04\xc5\x18\x04B\n-\
    \n\x05\x06\0\x02\xb5\x01\x12\x06\xc9\x18\x02\xd2\x18\x03\x1a\x1c\x20Patc\
    h\x20one\x20or\x20more\x20modules.\n\n\x0e\n\x06\x06\0\x02\xb5\x01\x01\
    \x12\x04\xc9\x18\x06\x12\n\x0e\n\x06\x06\0\x02\xb5\x01\x02\x12\x04\xc9\
    \x18\x14'\n\x0e\n\x06\x06\0\x02\xb5\x01\x03\x12\x04\xc9\x182E\n\x10\n\
    \x06\x06\0\x02\xb5\x01\x04\x12\x06\xca\x18\x04\xcd\x18\x06\n\x14\n\n\x06\
    \0\x02\xb5\x01\x04\xb0\xca\xbc\"\x12\x06\xca\x18\x04\xcd\x18\x06\n\x0e\n\
    \x06\x06\0\x02\xb5\x01\x04\x12\x04\xce\x18\x047\n\x11\n\t\x06\0\x02\xb5\
    \x01\x04\xc3\xf3\x04\x12\x04\xce\x18\x047\n\x0e\n\x06\x06\0\x02\xb5\x01\
    \x04\x12\x04\xcf\x18\x04?\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xcf\x18\x04?\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\xd0\x18\
    \x04B\n\x12\n\n\x06\0\x02\xb5\x01\x04\xc2\xf3\x04\x01\x12\x04\xd0\x18\
    \x04B\n\x0e\n\x06\x06\0\x02\xb5\x01\x04\x12\x04\xd1\x18\x04B\n\x12\n\n\
    \x06\0\x02\xb5\x01\x04\xc2\xf3\x04\x02\x12\x04\xd1\x18\x04B\n:\n\x05\x06\
    \0\x02\xb6\x01\x12\x06\xd5\x18\x02\xe5\x18\x03\x1a)\x20Delete\x20multipl\
    e\x20modules\x20in\x20one\x20request.\n\n\x0e\n\x06\x06\0\x02\xb6\x01\
    \x01\x12\x04\xd5\x18\x06\x13\n\x0e\n\x06\x06\0\x02\xb6\x01\x02\x12\x04\
    \xd5\x18\x15)\n\x0e\n\x06\x06\0\x02\xb6\x01\x03\x12\x04\xd5\x184T\n\x10\
    \n\x06\x06\0\x02\xb6\x01\x04\x12\x06\xd6\x18\x04\xd9\x18\x06\n\x14\n\n\
    \x06\0\x02\xb6\x01\x04\xb0\xca\xbc\"\x12\x06\xd6\x18\x04\xd9\x18\x06\n\
    \x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xda\x18\x047\n\x11\n\t\x06\0\
    \x02\xb6\x01\x04\xc3\xf3\x04\x12\x04\xda\x18\x047\n\x0e\n\x06\x06\0\x02\
    \xb6\x01\x04\x12\x04\xdb\x18\x04?\n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xdb\x18\x04?\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\
    \x04\xdc\x18\x04B\n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xdc\x18\x04B\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xdd\x18\x04E\
    \n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\xf3\x04\x02\x12\x04\xdd\x18\x04E\n\
    \x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xde\x18\x04B\n\x12\n\n\x06\0\
    \x02\xb6\x01\x04\xc2\xf3\x04\x03\x12\x04\xde\x18\x04B\n\x0e\n\x06\x06\0\
    \x02\xb6\x01\x04\x12\x04\xdf\x18\x04R\n5\n\n\x06\0\x02\xb6\x01\x04\xc2\
    \xf3\x04\x04\x12\x04\xdf\x18\x04R\"!\x20Needed\x20to\x20cascade\x20delet\
    e\x20to\x20IMV\n\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xe0\x18\x04R\
    \n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\xf3\x04\x05\x12\x04\xe0\x18\x04R\n\
    \x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xe1\x18\x04U\n\x12\n\n\x06\0\
    \x02\xb6\x01\x04\xc2\xf3\x04\x06\x12\x04\xe1\x18\x04U\n\x0e\n\x06\x06\0\
    \x02\xb6\x01\x04\x12\x04\xe2\x18\x04B\n\x12\n\n\x06\0\x02\xb6\x01\x04\
    \xc2\xf3\x04\x07\x12\x04\xe2\x18\x04B\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\
    \x12\x04\xe3\x18\x04?\n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\xf3\x04\x08\
    \x12\x04\xe3\x18\x04?\n\x0e\n\x06\x06\0\x02\xb6\x01\x04\x12\x04\xe4\x18\
    \x04?\n\x12\n\n\x06\0\x02\xb6\x01\x04\xc2\xf3\x04\t\x12\x04\xe4\x18\x04?\
    \n>\n\x05\x06\0\x02\xb7\x01\x12\x06\xe8\x18\x02\xef\x18\x03\x1a-\x20Get\
    \x20a\x20specific\x20module\x20version\x20for\x20a\x20module.\n\n\x0e\n\
    \x06\x06\0\x02\xb7\x01\x01\x12\x04\xe8\x18\x06\x16\n\x0e\n\x06\x06\0\x02\
    \xb7\x01\x02\x12\x04\xe8\x18\x18/\n\x0e\n\x06\x06\0\x02\xb7\x01\x03\x12\
    \x04\xe8\x18:U\n\x10\n\x06\x06\0\x02\xb7\x01\x04\x12\x06\xe9\x18\x04\xeb\
    \x18\x06\n\x14\n\n\x06\0\x02\xb7\x01\x04\xb0\xca\xbc\"\x12\x06\xe9\x18\
    \x04\xeb\x18\x06\n\x0e\n\x06\x06\0\x02\xb7\x01\x04\x12\x04\xec\x18\x047\
    \n\x11\n\t\x06\0\x02\xb7\x01\x04\xc3\xf3\x04\x12\x04\xec\x18\x047\n\x0e\
    \n\x06\x06\0\x02\xb7\x01\x04\x12\x04\xed\x18\x04?\n\x12\n\n\x06\0\x02\
    \xb7\x01\x04\xc2\xf3\x04\0\x12\x04\xed\x18\x04?\n\x0e\n\x06\x06\0\x02\
    \xb7\x01\x04\x12\x04\xee\x18\x04B\n\x12\n\n\x06\0\x02\xb7\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xee\x18\x04B\nD\n\x05\x06\0\x02\xb8\x01\x12\x06\xf2\
    \x18\x02\xf9\x18\x03\x1a3\x20List\x20all\x20the\x20modules\x20versions\
    \x20for\x20a\x20given\x20module.\n\n\x0e\n\x06\x06\0\x02\xb8\x01\x01\x12\
    \x04\xf2\x18\x06\x18\n\x0e\n\x06\x06\0\x02\xb8\x01\x02\x12\x04\xf2\x18\
    \x1a3\n\x0e\n\x06\x06\0\x02\xb8\x01\x03\x12\x04\xf2\x18>X\n\x10\n\x06\
    \x06\0\x02\xb8\x01\x04\x12\x06\xf3\x18\x04\xf5\x18\x06\n\x14\n\n\x06\0\
    \x02\xb8\x01\x04\xb0\xca\xbc\"\x12\x06\xf3\x18\x04\xf5\x18\x06\n\x0e\n\
    \x06\x06\0\x02\xb8\x01\x04\x12\x04\xf6\x18\x047\n\x11\n\t\x06\0\x02\xb8\
    \x01\x04\xc3\xf3\x04\x12\x04\xf6\x18\x047\n\x0e\n\x06\x06\0\x02\xb8\x01\
    \x04\x12\x04\xf7\x18\x04?\n\x12\n\n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xf7\x18\x04?\n\x0e\n\x06\x06\0\x02\xb8\x01\x04\x12\x04\xf8\x18\
    \x04B\n\x12\n\n\x06\0\x02\xb8\x01\x04\xc2\xf3\x04\x01\x12\x04\xf8\x18\
    \x04B\nQ\n\x05\x06\0\x02\xb9\x01\x12\x06\xfc\x18\x02\x85\x19\x03\x1a@\
    \x20Create\x20a\x20new\x20module\x20version\x20to\x20trigger\x20training\
    \x20of\x20the\x20module.\n\n\x0e\n\x06\x06\0\x02\xb9\x01\x01\x12\x04\xfc\
    \x18\x06\x18\n\x0e\n\x06\x06\0\x02\xb9\x01\x02\x12\x04\xfc\x18\x1a3\n\
    \x0e\n\x06\x06\0\x02\xb9\x01\x03\x12\x04\xfc\x18>X\n\x10\n\x06\x06\0\x02\
    \xb9\x01\x04\x12\x06\xfd\x18\x04\x80\x19\x06\n\x14\n\n\x06\0\x02\xb9\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xfd\x18\x04\x80\x19\x06\n\x0e\n\x06\x06\0\x02\
    \xb9\x01\x04\x12\x04\x81\x19\x047\n\x11\n\t\x06\0\x02\xb9\x01\x04\xc3\
    \xf3\x04\x12\x04\x81\x19\x047\n\x0e\n\x06\x06\0\x02\xb9\x01\x04\x12\x04\
    \x82\x19\x04?\n\x12\n\n\x06\0\x02\xb9\x01\x04\xc2\xf3\x04\0\x12\x04\x82\
    \x19\x04?\n\x0e\n\x06\x06\0\x02\xb9\x01\x04\x12\x04\x83\x19\x04B\n\x12\n\
    \n\x06\0\x02\xb9\x01\x04\xc2\xf3\x04\x01\x12\x04\x83\x19\x04B\n\x0e\n\
    \x06\x06\0\x02\xb9\x01\x04\x12\x04\x84\x19\x04B\n\x12\n\n\x06\0\x02\xb9\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\x84\x19\x04B\n@\n\x05\x06\0\x02\xba\x01\
    \x12\x06\x88\x19\x02\x91\x19\x03\x1a/\x20Modify\x20details\x20of\x20an\
    \x20existing\x20module\x20version.\n\n\x0e\n\x06\x06\0\x02\xba\x01\x01\
    \x12\x04\x88\x19\x06\x19\n\x0e\n\x06\x06\0\x02\xba\x01\x02\x12\x04\x88\
    \x19\x1b5\n\x0e\n\x06\x06\0\x02\xba\x01\x03\x12\x04\x88\x19@Z\n\x10\n\
    \x06\x06\0\x02\xba\x01\x04\x12\x06\x89\x19\x04\x8c\x19\x06\n\x14\n\n\x06\
    \0\x02\xba\x01\x04\xb0\xca\xbc\"\x12\x06\x89\x19\x04\x8c\x19\x06\n\x0e\n\
    \x06\x06\0\x02\xba\x01\x04\x12\x04\x8d\x19\x047\n\x11\n\t\x06\0\x02\xba\
    \x01\x04\xc3\xf3\x04\x12\x04\x8d\x19\x047\n\x0e\n\x06\x06\0\x02\xba\x01\
    \x04\x12\x04\x8e\x19\x04?\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\0\
    \x12\x04\x8e\x19\x04?\n\x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\x8f\x19\
    \x04B\n\x12\n\n\x06\0\x02\xba\x01\x04\xc2\xf3\x04\x01\x12\x04\x8f\x19\
    \x04B\n\x0e\n\x06\x06\0\x02\xba\x01\x04\x12\x04\x90\x19\x04B\n\x12\n\n\
    \x06\0\x02\xba\x01\x04\xc2\xf3\x04\x02\x12\x04\x90\x19\x04B\n4\n\x05\x06\
    \0\x02\xbb\x01\x12\x06\x94\x19\x02\xa4\x19\x03\x1a#\x20Delete\x20a\x20mu\
    ltiple\x20module\x20version.\n\n\x0e\n\x06\x06\0\x02\xbb\x01\x01\x12\x04\
    \x94\x19\x06\x1a\n\x0e\n\x06\x06\0\x02\xbb\x01\x02\x12\x04\x94\x19\x1c7\
    \n\x0e\n\x06\x06\0\x02\xbb\x01\x03\x12\x04\x94\x19Bb\n\x10\n\x06\x06\0\
    \x02\xbb\x01\x04\x12\x06\x95\x19\x04\x98\x19\x06\n\x14\n\n\x06\0\x02\xbb\
    \x01\x04\xb0\xca\xbc\"\x12\x06\x95\x19\x04\x98\x19\x06\n\x0e\n\x06\x06\0\
    \x02\xbb\x01\x04\x12\x04\x99\x19\x047\n\x11\n\t\x06\0\x02\xbb\x01\x04\
    \xc3\xf3\x04\x12\x04\x99\x19\x047\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\
    \x04\x9a\x19\x04?\n\x12\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\0\x12\x04\
    \x9a\x19\x04?\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\x9b\x19\x04B\n\
    \x12\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\x01\x12\x04\x9b\x19\x04B\n\
    \x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\x9c\x19\x04E\n\x12\n\n\x06\0\
    \x02\xbb\x01\x04\xc2\xf3\x04\x02\x12\x04\x9c\x19\x04E\n\x0e\n\x06\x06\0\
    \x02\xbb\x01\x04\x12\x04\x9d\x19\x04B\n\x12\n\n\x06\0\x02\xbb\x01\x04\
    \xc2\xf3\x04\x03\x12\x04\x9d\x19\x04B\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\
    \x12\x04\x9e\x19\x04R\n5\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\x04\x12\
    \x04\x9e\x19\x04R\"!\x20Needed\x20to\x20cascade\x20delete\x20to\x20IMV\n\
    \n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\x9f\x19\x04R\n\x12\n\n\x06\0\
    \x02\xbb\x01\x04\xc2\xf3\x04\x05\x12\x04\x9f\x19\x04R\n\x0e\n\x06\x06\0\
    \x02\xbb\x01\x04\x12\x04\xa0\x19\x04U\n\x12\n\n\x06\0\x02\xbb\x01\x04\
    \xc2\xf3\x04\x06\x12\x04\xa0\x19\x04U\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\
    \x12\x04\xa1\x19\x04B\n\x12\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\x07\
    \x12\x04\xa1\x19\x04B\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\xa2\x19\
    \x04?\n\x12\n\n\x06\0\x02\xbb\x01\x04\xc2\xf3\x04\x08\x12\x04\xa2\x19\
    \x04?\n\x0e\n\x06\x06\0\x02\xbb\x01\x04\x12\x04\xa3\x19\x04?\n\x12\n\n\
    \x06\0\x02\xbb\x01\x04\xc2\xf3\x04\t\x12\x04\xa3\x19\x04?\n?\n\x05\x06\0\
    \x02\xbc\x01\x12\x06\xa7\x19\x02\xaf\x19\x03\x1a.\x20Get\x20usage\x20cou\
    nt\x20for\x20specific\x20module\x20version.\n\n\x0e\n\x06\x06\0\x02\xbc\
    \x01\x01\x12\x04\xa7\x19\x06\x20\n\x0e\n\x06\x06\0\x02\xbc\x01\x02\x12\
    \x04\xa7\x19\"C\n\x0e\n\x06\x06\0\x02\xbc\x01\x03\x12\x04\xa7\x19Ns\n\
    \x10\n\x06\x06\0\x02\xbc\x01\x04\x12\x06\xa8\x19\x04\xaa\x19\x06\n\x14\n\
    \n\x06\0\x02\xbc\x01\x04\xb0\xca\xbc\"\x12\x06\xa8\x19\x04\xaa\x19\x06\n\
    \x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\x04\xab\x19\x047\n\x11\n\t\x06\0\
    \x02\xbc\x01\x04\xc3\xf3\x04\x12\x04\xab\x19\x047\n\x0e\n\x06\x06\0\x02\
    \xbc\x01\x04\x12\x04\xac\x19\x04?\n\x12\n\n\x06\0\x02\xbc\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xac\x19\x04?\n\x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\
    \x04\xad\x19\x04B\n\x12\n\n\x06\0\x02\xbc\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xad\x19\x04B\n\x0e\n\x06\x06\0\x02\xbc\x01\x04\x12\x04\xae\x19\x04R\
    \n\x12\n\n\x06\0\x02\xbc\x01\x04\xc2\xf3\x04\x02\x12\x04\xae\x19\x04R\n=\
    \n\x05\x06\0\x02\xbd\x01\x12\x06\xb2\x19\x02\xbb\x19\x03\x1a,\x20Get\x20\
    installed\x20modules\x20vesrions\x20for\x20an\x20app.\n\n\x0e\n\x06\x06\
    \0\x02\xbd\x01\x01\x12\x04\xb2\x19\x06\x1f\n\x0e\n\x06\x06\0\x02\xbd\x01\
    \x02\x12\x04\xb2\x19!A\n\x0e\n\x06\x06\0\x02\xbd\x01\x03\x12\x04\xb2\x19\
    Lp\n\x10\n\x06\x06\0\x02\xbd\x01\x04\x12\x06\xb3\x19\x04\xb5\x19\x06\n\
    \x14\n\n\x06\0\x02\xbd\x01\x04\xb0\xca\xbc\"\x12\x06\xb3\x19\x04\xb5\x19\
    \x06\n\x0e\n\x06\x06\0\x02\xbd\x01\x04\x12\x04\xb6\x19\x047\n\x11\n\t\
    \x06\0\x02\xbd\x01\x04\xc3\xf3\x04\x12\x04\xb6\x19\x047\n\x0e\n\x06\x06\
    \0\x02\xbd\x01\x04\x12\x04\xb7\x19\x04?\n\x12\n\n\x06\0\x02\xbd\x01\x04\
    \xc2\xf3\x04\0\x12\x04\xb7\x19\x04?\n\x0e\n\x06\x06\0\x02\xbd\x01\x04\
    \x12\x04\xb8\x19\x04R\n\x12\n\n\x06\0\x02\xbd\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\xb8\x19\x04R\n\x0e\n\x06\x06\0\x02\xbd\x01\x04\x12\x04\xb9\x19\
    \x04B\n\x12\n\n\x06\0\x02\xbd\x01\x04\xc2\xf3\x04\x02\x12\x04\xb9\x19\
    \x04B\n\x0e\n\x06\x06\0\x02\xbd\x01\x04\x12\x04\xba\x19\x04?\n\x12\n\n\
    \x06\0\x02\xbd\x01\x04\xc2\xf3\x04\x03\x12\x04\xba\x19\x04?\n>\n\x05\x06\
    \0\x02\xbe\x01\x12\x06\xbe\x19\x02\xc7\x19\x03\x1a-\x20List\x20installed\
    \x20modules\x20vesrions\x20for\x20an\x20app.\n\n\x0e\n\x06\x06\0\x02\xbe\
    \x01\x01\x12\x04\xbe\x19\x06!\n\x0e\n\x06\x06\0\x02\xbe\x01\x02\x12\x04\
    \xbe\x19#E\n\x0e\n\x06\x06\0\x02\xbe\x01\x03\x12\x04\xbe\x19Ps\n\x10\n\
    \x06\x06\0\x02\xbe\x01\x04\x12\x06\xbf\x19\x04\xc1\x19\x06\n\x14\n\n\x06\
    \0\x02\xbe\x01\x04\xb0\xca\xbc\"\x12\x06\xbf\x19\x04\xc1\x19\x06\n\x0e\n\
    \x06\x06\0\x02\xbe\x01\x04\x12\x04\xc2\x19\x047\n\x11\n\t\x06\0\x02\xbe\
    \x01\x04\xc3\xf3\x04\x12\x04\xc2\x19\x047\n\x0e\n\x06\x06\0\x02\xbe\x01\
    \x04\x12\x04\xc3\x19\x04?\n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xc3\x19\x04?\n\x0e\n\x06\x06\0\x02\xbe\x01\x04\x12\x04\xc4\x19\
    \x04R\n\x12\n\n\x06\0\x02\xbe\x01\x04\xc2\xf3\x04\x01\x12\x04\xc4\x19\
    \x04R\n\x0e\n\x06\x06\0\x02\xbe\x01\x04\x12\x04\xc5\x19\x04B\n\x12\n\n\
    \x06\0\x02\xbe\x01\x04\xc2\xf3\x04\x02\x12\x04\xc5\x19\x04B\n\x0e\n\x06\
    \x06\0\x02\xbe\x01\x04\x12\x04\xc6\x19\x04?\n\x12\n\n\x06\0\x02\xbe\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\xc6\x19\x04?\ns\n\x05\x06\0\x02\xbf\x01\x12\
    \x06\xca\x19\x02\xd4\x19\x03\x1ab\x20Install\x20a\x20new\x20module\x20ve\
    rsion\x20which\x20will\x20deploy\x20the\x20specific\x20ModuleVersion\x20\
    to\x20the\x20app\x20in\x20the\x20url.\n\n\x0e\n\x06\x06\0\x02\xbf\x01\
    \x01\x12\x04\xca\x19\x06!\n\x0e\n\x06\x06\0\x02\xbf\x01\x02\x12\x04\xca\
    \x19#E\n\x0e\n\x06\x06\0\x02\xbf\x01\x03\x12\x04\xca\x19Ps\n\x10\n\x06\
    \x06\0\x02\xbf\x01\x04\x12\x06\xcb\x19\x04\xce\x19\x06\n\x14\n\n\x06\0\
    \x02\xbf\x01\x04\xb0\xca\xbc\"\x12\x06\xcb\x19\x04\xce\x19\x06\n\x0e\n\
    \x06\x06\0\x02\xbf\x01\x04\x12\x04\xcf\x19\x047\n\x11\n\t\x06\0\x02\xbf\
    \x01\x04\xc3\xf3\x04\x12\x04\xcf\x19\x047\n\x0e\n\x06\x06\0\x02\xbf\x01\
    \x04\x12\x04\xd0\x19\x04R\n\x12\n\n\x06\0\x02\xbf\x01\x04\xc2\xf3\x04\0\
    \x12\x04\xd0\x19\x04R\n\x0e\n\x06\x06\0\x02\xbf\x01\x04\x12\x04\xd1\x19\
    \x04R\n\x12\n\n\x06\0\x02\xbf\x01\x04\xc2\xf3\x04\x01\x12\x04\xd1\x19\
    \x04R\n\x0e\n\x06\x06\0\x02\xbf\x01\x04\x12\x04\xd2\x19\x04B\n\x12\n\n\
    \x06\0\x02\xbf\x01\x04\xc2\xf3\x04\x02\x12\x04\xd2\x19\x04B\n\x0e\n\x06\
    \x06\0\x02\xbf\x01\x04\x12\x04\xd3\x19\x04?\n3\n\n\x06\0\x02\xbf\x01\x04\
    \xc2\xf3\x04\x03\x12\x04\xd3\x19\x04?\"\x1f\x20since\x20adding\x20Keys\
    \x20needs\x20that.\n\n\xca\x01\n\x05\x06\0\x02\xc0\x01\x12\x06\xd9\x19\
    \x02\xe7\x19\x03\x1a\xb8\x01\x20Uninstall\x20an\x20installed\x20module\
    \x20version\x20which\x20will\x20deploy\x20the\x20specific\x20ModuleVersi\
    on\x20to\x20the\x20app\n\x20in\x20the\x20url.\n\x20This\x20cleaned\x20up\
    \x20any\x20associated\x20caller\x20keys\x20so\x20needs\x20the\x20Keys_De\
    lete\x20scope.\n\n\x0e\n\x06\x06\0\x02\xc0\x01\x01\x12\x04\xd9\x19\x06#\
    \n\x0e\n\x06\x06\0\x02\xc0\x01\x02\x12\x04\xd9\x19%I\n\x0e\n\x06\x06\0\
    \x02\xc0\x01\x03\x12\x04\xd9\x19Tt\n\x10\n\x06\x06\0\x02\xc0\x01\x04\x12\
    \x06\xda\x19\x04\xdd\x19\x06\n\x14\n\n\x06\0\x02\xc0\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xda\x19\x04\xdd\x19\x06\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\
    \x04\xde\x19\x047\n\x11\n\t\x06\0\x02\xc0\x01\x04\xc3\xf3\x04\x12\x04\
    \xde\x19\x047\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xdf\x19\x04?\n\
    \x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\0\x12\x04\xdf\x19\x04?\n\x0e\
    \n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xe0\x19\x04B\n\x12\n\n\x06\0\x02\
    \xc0\x01\x04\xc2\xf3\x04\x01\x12\x04\xe0\x19\x04B\n\x0e\n\x06\x06\0\x02\
    \xc0\x01\x04\x12\x04\xe1\x19\x04R\n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xe1\x19\x04R\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\
    \x04\xe2\x19\x04R\n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xe2\x19\x04R\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xe3\x19\x04U\
    \n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\x04\x12\x04\xe3\x19\x04U\n\
    \x0e\n\x06\x06\0\x02\xc0\x01\x04\x12\x04\xe4\x19\x04B\n\x12\n\n\x06\0\
    \x02\xc0\x01\x04\xc2\xf3\x04\x05\x12\x04\xe4\x19\x04B\n\x0e\n\x06\x06\0\
    \x02\xc0\x01\x04\x12\x04\xe5\x19\x04?\n\x12\n\n\x06\0\x02\xc0\x01\x04\
    \xc2\xf3\x04\x06\x12\x04\xe5\x19\x04?\n\x0e\n\x06\x06\0\x02\xc0\x01\x04\
    \x12\x04\xe6\x19\x04?\n\x12\n\n\x06\0\x02\xc0\x01\x04\xc2\xf3\x04\x07\
    \x12\x04\xe6\x19\x04?\n\xc0\x01\n\x05\x06\0\x02\xc1\x01\x12\x06\xeb\x19\
    \x02\xf7\x19\x03\x1a\xae\x01\x20Assign\x20a\x20key\x20that\x20the\x20cal\
    ler\x20owns\x20to\x20be\x20used\x20when\x20accessing\x20this\x20installe\
    d\x20module\x20version\n\x20If\x20this\x20endpoint\x20is\x20called\x20wi\
    th\x20a\x20different\x20key\x20then\x20it\x20overwrites\x20what\x20is\
    \x20there.\n\n\x0e\n\x06\x06\0\x02\xc1\x01\x01\x12\x04\xeb\x19\x06$\n\
    \x0e\n\x06\x06\0\x02\xc1\x01\x02\x12\x04\xeb\x19&K\n\x0e\n\x06\x06\0\x02\
    \xc1\x01\x03\x12\x04\xeb\x19Vg\n\x10\n\x06\x06\0\x02\xc1\x01\x04\x12\x06\
    \xec\x19\x04\xef\x19\x06\n\x14\n\n\x06\0\x02\xc1\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xec\x19\x04\xef\x19\x06\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\
    \x04\xf0\x19\x047\n\x11\n\t\x06\0\x02\xc1\x01\x04\xc3\xf3\x04\x12\x04\
    \xf0\x19\x047\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xf1\x19\x04R\n\
    \x12\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\0\x12\x04\xf1\x19\x04R\n\x0e\
    \n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xf2\x19\x04R\n\x12\n\n\x06\0\x02\
    \xc1\x01\x04\xc2\xf3\x04\x01\x12\x04\xf2\x19\x04R\n\x0e\n\x06\x06\0\x02\
    \xc1\x01\x04\x12\x04\xf3\x19\x04B\n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xf3\x19\x04B\n\x0e\n\x06\x06\0\x02\xc1\x01\x04\x12\
    \x04\xf4\x19\x04?\n3\n\n\x06\0\x02\xc1\x01\x04\xc2\xf3\x04\x03\x12\x04\
    \xf4\x19\x04?\"\x1f\x20since\x20adding\x20Keys\x20needs\x20that.\n\n\x0e\
    \n\x06\x06\0\x02\xc1\x01\x04\x12\x04\xf5\x19\x04?\n\x12\n\n\x06\0\x02\
    \xc1\x01\x04\xc2\xf3\x04\x04\x12\x04\xf5\x19\x04?\n\x0e\n\x06\x06\0\x02\
    \xc1\x01\x04\x12\x04\xf6\x19\x04?\n\x12\n\n\x06\0\x02\xc1\x01\x04\xc2\
    \xf3\x04\x05\x12\x04\xf6\x19\x04?\n\x83\x02\n\x05\x06\0\x02\xc2\x01\x12\
    \x06\xfc\x19\x02\x8c\x1a\x03\x1a\xf1\x01\x20Perform\x20bulk\x20operation\
    s\x20on\x20a\x20list\x20of\x20inputs\x20based\x20on\x20input\x20source.\
    \n\x20Operation\x20include\x20add,\x20update,\x20delete\x20of\x20concept\
    s,\x20metadata\x20and\x20geo\x20data.\n\x20This\x20is\x20an\x20Asynchron\
    ous\x20process.\x20Use\x20ListBulkOperations\x20or\x20GetBulkOperation\
    \x20to\x20check\x20the\x20status.\n\n\x0e\n\x06\x06\0\x02\xc2\x01\x01\
    \x12\x04\xfc\x19\x06\x18\n\x0e\n\x06\x06\0\x02\xc2\x01\x02\x12\x04\xfc\
    \x19\x1a3\n\x0e\n\x06\x06\0\x02\xc2\x01\x03\x12\x04\xfc\x19>Y\n\x10\n\
    \x06\x06\0\x02\xc2\x01\x04\x12\x06\xfd\x19\x04\x84\x1a\x06\n\x14\n\n\x06\
    \0\x02\xc2\x01\x04\xb0\xca\xbc\"\x12\x06\xfd\x19\x04\x84\x1a\x06\n\x0e\n\
    \x06\x06\0\x02\xc2\x01\x04\x12\x04\x85\x1a\x047\n\x11\n\t\x06\0\x02\xc2\
    \x01\x04\xc3\xf3\x04\x12\x04\x85\x1a\x047\n\x0e\n\x06\x06\0\x02\xc2\x01\
    \x04\x12\x04\x86\x1a\x04?\n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\0\
    \x12\x04\x86\x1a\x04?\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\x04\x87\x1a\
    \x04H\n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\x01\x12\x04\x87\x1a\
    \x04H\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\x04\x88\x1a\x04H\n\x12\n\n\
    \x06\0\x02\xc2\x01\x04\xc2\xf3\x04\x02\x12\x04\x88\x1a\x04H\n\x0e\n\x06\
    \x06\0\x02\xc2\x01\x04\x12\x04\x89\x1a\x04F\n\x12\n\n\x06\0\x02\xc2\x01\
    \x04\xc2\xf3\x04\x03\x12\x04\x89\x1a\x04F\n\x0e\n\x06\x06\0\x02\xc2\x01\
    \x04\x12\x04\x8a\x1a\x04F\n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\
    \x04\x12\x04\x8a\x1a\x04F\n\x0e\n\x06\x06\0\x02\xc2\x01\x04\x12\x04\x8b\
    \x1a\x04I\n\x12\n\n\x06\0\x02\xc2\x01\x04\xc2\xf3\x04\x05\x12\x04\x8b\
    \x1a\x04I\n/\n\x05\x06\0\x02\xc3\x01\x12\x06\x8f\x1a\x02\x99\x1a\x03\x1a\
    \x1e\x20List\x20all\x20the\x20bulk\x20operations\n\n\x0e\n\x06\x06\0\x02\
    \xc3\x01\x01\x12\x04\x8f\x1a\x06\x18\n\x0e\n\x06\x06\0\x02\xc3\x01\x02\
    \x12\x04\x8f\x1a\x1a3\n\x0e\n\x06\x06\0\x02\xc3\x01\x03\x12\x04\x8f\x1a>\
    Y\n\x10\n\x06\x06\0\x02\xc3\x01\x04\x12\x06\x90\x1a\x04\x95\x1a\x06\n\
    \x14\n\n\x06\0\x02\xc3\x01\x04\xb0\xca\xbc\"\x12\x06\x90\x1a\x04\x95\x1a\
    \x06\n\x0e\n\x06\x06\0\x02\xc3\x01\x04\x12\x04\x96\x1a\x047\n\x11\n\t\
    \x06\0\x02\xc3\x01\x04\xc3\xf3\x04\x12\x04\x96\x1a\x047\n\x0e\n\x06\x06\
    \0\x02\xc3\x01\x04\x12\x04\x97\x1a\x04?\n\x12\n\n\x06\0\x02\xc3\x01\x04\
    \xc2\xf3\x04\0\x12\x04\x97\x1a\x04?\n\x0e\n\x06\x06\0\x02\xc3\x01\x04\
    \x12\x04\x98\x1a\x04H\n\x12\n\n\x06\0\x02\xc3\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\x98\x1a\x04H\n7\n\x05\x06\0\x02\xc4\x01\x12\x06\x9c\x1a\x02\xa6\
    \x1a\x03\x1a&\x20Get\x20the\x20bulk\x20operation\x20details\x20by\x20ID\
    \n\n\x0e\n\x06\x06\0\x02\xc4\x01\x01\x12\x04\x9c\x1a\x06\x16\n\x0e\n\x06\
    \x06\0\x02\xc4\x01\x02\x12\x04\x9c\x1a\x18/\n\x0e\n\x06\x06\0\x02\xc4\
    \x01\x03\x12\x04\x9c\x1a:V\n\x10\n\x06\x06\0\x02\xc4\x01\x04\x12\x06\x9d\
    \x1a\x04\xa2\x1a\x06\n\x14\n\n\x06\0\x02\xc4\x01\x04\xb0\xca\xbc\"\x12\
    \x06\x9d\x1a\x04\xa2\x1a\x06\n\x0e\n\x06\x06\0\x02\xc4\x01\x04\x12\x04\
    \xa3\x1a\x047\n\x11\n\t\x06\0\x02\xc4\x01\x04\xc3\xf3\x04\x12\x04\xa3\
    \x1a\x047\n\x0e\n\x06\x06\0\x02\xc4\x01\x04\x12\x04\xa4\x1a\x04?\n\x12\n\
    \n\x06\0\x02\xc4\x01\x04\xc2\xf3\x04\0\x12\x04\xa4\x1a\x04?\n\x0e\n\x06\
    \x06\0\x02\xc4\x01\x04\x12\x04\xa5\x1a\x04H\n\x12\n\n\x06\0\x02\xc4\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xa5\x1a\x04H\n5\n\x05\x06\0\x02\xc5\x01\x12\
    \x06\xa9\x1a\x02\xb6\x1a\x03\x1a$\x20Cancel\x20one\x20or\x20more\x20bulk\
    \x20operations\n\n\x0e\n\x06\x06\0\x02\xc5\x01\x01\x12\x04\xa9\x1a\x06\
    \x1a\n\x0e\n\x06\x06\0\x02\xc5\x01\x02\x12\x04\xa9\x1a\x1c6\n\x0e\n\x06\
    \x06\0\x02\xc5\x01\x03\x12\x04\xa9\x1aA\\\n\x10\n\x06\x06\0\x02\xc5\x01\
    \x04\x12\x06\xaa\x1a\x04\xb1\x1a\x06\n\x14\n\n\x06\0\x02\xc5\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xaa\x1a\x04\xb1\x1a\x06\n\x0e\n\x06\x06\0\x02\xc5\x01\
    \x04\x12\x04\xb2\x1a\x047\n\x11\n\t\x06\0\x02\xc5\x01\x04\xc3\xf3\x04\
    \x12\x04\xb2\x1a\x047\n\x0e\n\x06\x06\0\x02\xc5\x01\x04\x12\x04\xb3\x1a\
    \x04?\n\x12\n\n\x06\0\x02\xc5\x01\x04\xc2\xf3\x04\0\x12\x04\xb3\x1a\x04?\
    \n\x0e\n\x06\x06\0\x02\xc5\x01\x04\x12\x04\xb4\x1a\x04H\n\x12\n\n\x06\0\
    \x02\xc5\x01\x04\xc2\xf3\x04\x01\x12\x04\xb4\x1a\x04H\n\x0e\n\x06\x06\0\
    \x02\xc5\x01\x04\x12\x04\xb5\x1a\x04H\n\x12\n\n\x06\0\x02\xc5\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xb5\x1a\x04H\n@\n\x05\x06\0\x02\xc6\x01\x12\x06\
    \xb9\x1a\x02\xca\x1a\x03\x1a/\x20delete\x20one\x20or\x20more\x20terminat\
    ed\x20bulk\x20operations\n\n\x0e\n\x06\x06\0\x02\xc6\x01\x01\x12\x04\xb9\
    \x1a\x06\x1a\n\x0e\n\x06\x06\0\x02\xc6\x01\x02\x12\x04\xb9\x1a\x1c6\n\
    \x0e\n\x06\x06\0\x02\xc6\x01\x03\x12\x04\xb9\x1aAa\n\x10\n\x06\x06\0\x02\
    \xc6\x01\x04\x12\x06\xba\x1a\x04\xc1\x1a\x06\n\x14\n\n\x06\0\x02\xc6\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xba\x1a\x04\xc1\x1a\x06\n\x0e\n\x06\x06\0\x02\
    \xc6\x01\x04\x12\x04\xc2\x1a\x047\n\x11\n\t\x06\0\x02\xc6\x01\x04\xc3\
    \xf3\x04\x12\x04\xc2\x1a\x047\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\
    \xc3\x1a\x04?\n\x12\n\n\x06\0\x02\xc6\x01\x04\xc2\xf3\x04\0\x12\x04\xc3\
    \x1a\x04?\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\xc4\x1a\x04F\n\x12\n\
    \n\x06\0\x02\xc6\x01\x04\xc2\xf3\x04\x01\x12\x04\xc4\x1a\x04F\n\x0e\n\
    \x06\x06\0\x02\xc6\x01\x04\x12\x04\xc5\x1a\x04F\n\x12\n\n\x06\0\x02\xc6\
    \x01\x04\xc2\xf3\x04\x02\x12\x04\xc5\x1a\x04F\n\x0e\n\x06\x06\0\x02\xc6\
    \x01\x04\x12\x04\xc6\x1a\x04I\n\x12\n\n\x06\0\x02\xc6\x01\x04\xc2\xf3\
    \x04\x03\x12\x04\xc6\x1a\x04I\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\
    \xc7\x1a\x04H\n\x12\n\n\x06\0\x02\xc6\x01\x04\xc2\xf3\x04\x04\x12\x04\
    \xc7\x1a\x04H\n\x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\xc8\x1a\x04H\n\
    \x12\n\n\x06\0\x02\xc6\x01\x04\xc2\xf3\x04\x05\x12\x04\xc8\x1a\x04H\n\
    \x0e\n\x06\x06\0\x02\xc6\x01\x04\x12\x04\xc9\x1a\x04K\n\x12\n\n\x06\0\
    \x02\xc6\x01\x04\xc2\xf3\x04\x06\x12\x04\xc9\x1a\x04K\n\xeb\x02\n\x05\
    \x06\0\x02\xc7\x01\x12\x06\xd1\x1a\x02\xdf\x1a\x03\x1a\xd9\x02\x20Deprec\
    ated:\x20Use\x20PutTaskAssignments\x20with\x20action=LABEL_START.\n\x20\
    \x20\x20This\x20endpoint\x20has\x20initially\x20been\x20designed\x20as\
    \x20a\x20GET\x20request,\n\x20\x20\x20but\x20has\x20been\x20re-designed\
    \x20to\x20serve\x20a\x20PUT\x20logic.\n\x20\x20\x20In\x20order\x20to\x20\
    clearly\x20highlight\x20that\x20this\x20endpoint\x20serves\x20a\x20PUT\
    \x20request,\n\x20\x20\x20this\x20endpoint\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20PutTaskAssignments\x20with\x20action=LABEL_\
    START.\n\n\x0e\n\x06\x06\0\x02\xc7\x01\x01\x12\x04\xd1\x1a\x06\x1d\n\x0e\
    \n\x06\x06\0\x02\xc7\x01\x02\x12\x04\xd1\x1a\x1f=\n\x0e\n\x06\x06\0\x02\
    \xc7\x01\x03\x12\x04\xd1\x1aHZ\n\x10\n\x06\x06\0\x02\xc7\x01\x04\x12\x06\
    \xd2\x1a\x04\xd7\x1a\x06\n\x14\n\n\x06\0\x02\xc7\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xd2\x1a\x04\xd7\x1a\x06\n\x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\
    \x04\xd8\x1a\x047\n\x11\n\t\x06\0\x02\xc7\x01\x04\xc3\xf3\x04\x12\x04\
    \xd8\x1a\x047\n\x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\x04\xd9\x1a\x04?\n\
    \x12\n\n\x06\0\x02\xc7\x01\x04\xc2\xf3\x04\0\x12\x04\xd9\x1a\x04?\n\x0e\
    \n\x06\x06\0\x02\xc7\x01\x04\x12\x04\xda\x1a\x04F\n\x12\n\n\x06\0\x02\
    \xc7\x01\x04\xc2\xf3\x04\x01\x12\x04\xda\x1a\x04F\n\x0e\n\x06\x06\0\x02\
    \xc7\x01\x04\x12\x04\xdb\x1a\x04C\n\x12\n\n\x06\0\x02\xc7\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xdb\x1a\x04C\n\x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\
    \x04\xdc\x1a\x04A\n\x12\n\n\x06\0\x02\xc7\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xdc\x1a\x04A\n\x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\x04\xdd\x1a\x04@\
    \n\x12\n\n\x06\0\x02\xc7\x01\x04\xc2\xf3\x04\x04\x12\x04\xdd\x1a\x04@\n\
    \x0e\n\x06\x06\0\x02\xc7\x01\x04\x12\x04\xde\x1a\x04C\n\x12\n\n\x06\0\
    \x02\xc7\x01\x04\xc2\xf3\x04\x05\x12\x04\xde\x1a\x04C\n\xa2\x02\n\x05\
    \x06\0\x02\xc8\x01\x12\x06\xe4\x1a\x02\xf1\x1a\x03\x1a\x90\x02\x20PutTas\
    kAssignments\x20performs\x20an\x20action\x20for\x20the\x20task\x20assign\
    ments\x20in\x20given\x20task.\n\x20All\x20the\x20actions\x20are\x20theor\
    etically\x20idempotent,\x20but\x20practically,\x20in\x20the\x20current\
    \x20implementation,\n\x20the\x20REVIEW_START\x20action\x20is\x20not\x20i\
    dempotent.\x20See\x20PutTaskAssignmentsRequestAction\x20for\x20more\x20d\
    etails.\n\n\x0e\n\x06\x06\0\x02\xc8\x01\x01\x12\x04\xe4\x1a\x06\x18\n\
    \x0e\n\x06\x06\0\x02\xc8\x01\x02\x12\x04\xe4\x1a\x1a3\n\x0e\n\x06\x06\0\
    \x02\xc8\x01\x03\x12\x04\xe4\x1a>Y\n\x10\n\x06\x06\0\x02\xc8\x01\x04\x12\
    \x06\xe5\x1a\x04\xe8\x1a\x06\n\x14\n\n\x06\0\x02\xc8\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xe5\x1a\x04\xe8\x1a\x06\n\x0e\n\x06\x06\0\x02\xc8\x01\x04\x12\
    \x04\xe9\x1a\x047\n\x11\n\t\x06\0\x02\xc8\x01\x04\xc3\xf3\x04\x12\x04\
    \xe9\x1a\x047\n\x0e\n\x06\x06\0\x02\xc8\x01\x04\x12\x04\xea\x1a\x04?\n\
    \x12\n\n\x06\0\x02\xc8\x01\x04\xc2\xf3\x04\0\x12\x04\xea\x1a\x04?\n\x0e\
    \n\x06\x06\0\x02\xc8\x01\x04\x12\x04\xeb\x1a\x04F\n\x12\n\n\x06\0\x02\
    \xc8\x01\x04\xc2\xf3\x04\x01\x12\x04\xeb\x1a\x04F\n\x0e\n\x06\x06\0\x02\
    \xc8\x01\x04\x12\x04\xec\x1a\x04F\n\x12\n\n\x06\0\x02\xc8\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xec\x1a\x04F\n\x0e\n\x06\x06\0\x02\xc8\x01\x04\x12\
    \x04\xed\x1a\x04C\n\x12\n\n\x06\0\x02\xc8\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xed\x1a\x04C\n\x0e\n\x06\x06\0\x02\xc8\x01\x04\x12\x04\xee\x1a\x04A\
    \n\x12\n\n\x06\0\x02\xc8\x01\x04\xc2\xf3\x04\x04\x12\x04\xee\x1a\x04A\n\
    \x0e\n\x06\x06\0\x02\xc8\x01\x04\x12\x04\xef\x1a\x04@\n\x12\n\n\x06\0\
    \x02\xc8\x01\x04\xc2\xf3\x04\x05\x12\x04\xef\x1a\x04@\n\x0e\n\x06\x06\0\
    \x02\xc8\x01\x04\x12\x04\xf0\x1a\x04C\n\x12\n\n\x06\0\x02\xc8\x01\x04\
    \xc2\xf3\x04\x06\x12\x04\xf0\x1a\x04C\n/\n\x05\x06\0\x02\xc9\x01\x12\x06\
    \xf6\x1a\x02\x80\x1b\x03\x1a\x1e\x20List\x20all\x20the\x20inputs\x20add\
    \x20jobs\n\n\x0e\n\x06\x06\0\x02\xc9\x01\x01\x12\x04\xf6\x1a\x06\x17\n\
    \x0e\n\x06\x06\0\x02\xc9\x01\x02\x12\x04\xf6\x1a\x191\n\x0e\n\x06\x06\0\
    \x02\xc9\x01\x03\x12\x04\xf6\x1a<U\n\x10\n\x06\x06\0\x02\xc9\x01\x04\x12\
    \x06\xf7\x1a\x04\xfc\x1a\x06\n\x14\n\n\x06\0\x02\xc9\x01\x04\xb0\xca\xbc\
    \"\x12\x06\xf7\x1a\x04\xfc\x1a\x06\n\x0e\n\x06\x06\0\x02\xc9\x01\x04\x12\
    \x04\xfd\x1a\x047\n\x11\n\t\x06\0\x02\xc9\x01\x04\xc3\xf3\x04\x12\x04\
    \xfd\x1a\x047\n\x0e\n\x06\x06\0\x02\xc9\x01\x04\x12\x04\xfe\x1a\x04?\n\
    \x12\n\n\x06\0\x02\xc9\x01\x04\xc2\xf3\x04\0\x12\x04\xfe\x1a\x04?\n\x0e\
    \n\x06\x06\0\x02\xc9\x01\x04\x12\x04\xff\x1a\x04A\n\x12\n\n\x06\0\x02\
    \xc9\x01\x04\xc2\xf3\x04\x01\x12\x04\xff\x1a\x04A\n6\n\x05\x06\0\x02\xca\
    \x01\x12\x06\x83\x1b\x02\x8d\x1b\x03\x1a%\x20Get\x20the\x20input\x20add\
    \x20job\x20details\x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\xca\x01\x01\x12\
    \x04\x83\x1b\x06\x15\n\x0e\n\x06\x06\0\x02\xca\x01\x02\x12\x04\x83\x1b\
    \x17-\n\x0e\n\x06\x06\0\x02\xca\x01\x03\x12\x04\x83\x1b8R\n\x10\n\x06\
    \x06\0\x02\xca\x01\x04\x12\x06\x84\x1b\x04\x89\x1b\x06\n\x14\n\n\x06\0\
    \x02\xca\x01\x04\xb0\xca\xbc\"\x12\x06\x84\x1b\x04\x89\x1b\x06\n\x0e\n\
    \x06\x06\0\x02\xca\x01\x04\x12\x04\x8a\x1b\x047\n\x11\n\t\x06\0\x02\xca\
    \x01\x04\xc3\xf3\x04\x12\x04\x8a\x1b\x047\n\x0e\n\x06\x06\0\x02\xca\x01\
    \x04\x12\x04\x8b\x1b\x04?\n\x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\x04\0\
    \x12\x04\x8b\x1b\x04?\n\x0e\n\x06\x06\0\x02\xca\x01\x04\x12\x04\x8c\x1b\
    \x04A\n\x12\n\n\x06\0\x02\xca\x01\x04\xc2\xf3\x04\x01\x12\x04\x8c\x1b\
    \x04A\n1\n\x05\x06\0\x02\xcb\x01\x12\x06\x90\x1b\x02\x9d\x1b\x03\x1a\x20\
    \x20cancel\x20the\x20input\x20add\x20job\x20by\x20ID\n\n\x0e\n\x06\x06\0\
    \x02\xcb\x01\x01\x12\x04\x90\x1b\x06\x18\n\x0e\n\x06\x06\0\x02\xcb\x01\
    \x02\x12\x04\x90\x1b\x1a3\n\x0e\n\x06\x06\0\x02\xcb\x01\x03\x12\x04\x90\
    \x1b>X\n\x10\n\x06\x06\0\x02\xcb\x01\x04\x12\x06\x91\x1b\x04\x98\x1b\x06\
    \n\x14\n\n\x06\0\x02\xcb\x01\x04\xb0\xca\xbc\"\x12\x06\x91\x1b\x04\x98\
    \x1b\x06\n\x0e\n\x06\x06\0\x02\xcb\x01\x04\x12\x04\x99\x1b\x047\n\x11\n\
    \t\x06\0\x02\xcb\x01\x04\xc3\xf3\x04\x12\x04\x99\x1b\x047\n\x0e\n\x06\
    \x06\0\x02\xcb\x01\x04\x12\x04\x9a\x1b\x04?\n\x12\n\n\x06\0\x02\xcb\x01\
    \x04\xc2\xf3\x04\0\x12\x04\x9a\x1b\x04?\n\x0e\n\x06\x06\0\x02\xcb\x01\
    \x04\x12\x04\x9b\x1b\x04A\n\x12\n\n\x06\0\x02\xcb\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\x9b\x1b\x04A\n\x0e\n\x06\x06\0\x02\xcb\x01\x04\x12\x04\x9c\
    \x1b\x04A\n\x12\n\n\x06\0\x02\xcb\x01\x04\xc2\xf3\x04\x02\x12\x04\x9c\
    \x1b\x04A\n\x0f\n\x05\x06\0\x02\xcc\x01\x12\x06\x9f\x1b\x02\xac\x1b\x03\
    \n\x0e\n\x06\x06\0\x02\xcc\x01\x01\x12\x04\x9f\x1b\x06\x11\n\x0e\n\x06\
    \x06\0\x02\xcc\x01\x02\x12\x04\x9f\x1b\x13%\n\x0e\n\x06\x06\0\x02\xcc\
    \x01\x03\x12\x04\x9f\x1b0C\n\x10\n\x06\x06\0\x02\xcc\x01\x04\x12\x06\xa0\
    \x1b\x04\xa7\x1b\x06\n\x14\n\n\x06\0\x02\xcc\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xa0\x1b\x04\xa7\x1b\x06\n\x0e\n\x06\x06\0\x02\xcc\x01\x04\x12\x04\
    \xa8\x1b\x047\n\x11\n\t\x06\0\x02\xcc\x01\x04\xc3\xf3\x04\x12\x04\xa8\
    \x1b\x047\n\x0e\n\x06\x06\0\x02\xcc\x01\x04\x12\x04\xa9\x1b\x04?\n\x12\n\
    \n\x06\0\x02\xcc\x01\x04\xc2\xf3\x04\0\x12\x04\xa9\x1b\x04?\n\x0e\n\x06\
    \x06\0\x02\xcc\x01\x04\x12\x04\xaa\x1b\x04B\n\x12\n\n\x06\0\x02\xcc\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xaa\x1b\x04B\n\x0e\n\x06\x06\0\x02\xcc\x01\
    \x04\x12\x04\xab\x1b\x04B\n\x12\n\n\x06\0\x02\xcc\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xab\x1b\x04B\n\x8e\x01\n\x05\x06\0\x02\xcd\x01\x12\x06\xb0\
    \x1b\x02\xbc\x1b\x03\x1a}\x20Upload\x20a\x20part\x20of\x20a\x20multipart\
    \x20upload.\n\x20Behaviour\x20on\x20completion\x20depends\x20on\x20the\
    \x20endpoint\x20that\x20was\x20used\x20to\x20initiate\x20the\x20upload.\
    \n\n\x0e\n\x06\x06\0\x02\xcd\x01\x01\x12\x04\xb0\x1b\x06\x1b\n\x0e\n\x06\
    \x06\0\x02\xcd\x01\x02\x12\x04\xb0\x1b\x1d9\n\x0e\n\x06\x06\0\x02\xcd\
    \x01\x03\x12\x04\xb0\x1bDX\n\x10\n\x06\x06\0\x02\xcd\x01\x04\x12\x06\xb1\
    \x1b\x04\xb7\x1b\x06\n\x14\n\n\x06\0\x02\xcd\x01\x04\xb0\xca\xbc\"\x12\
    \x06\xb1\x1b\x04\xb7\x1b\x06\n\x0e\n\x06\x06\0\x02\xcd\x01\x04\x12\x04\
    \xb8\x1b\x047\n\x11\n\t\x06\0\x02\xcd\x01\x04\xc3\xf3\x04\x12\x04\xb8\
    \x1b\x047\n\x0e\n\x06\x06\0\x02\xcd\x01\x04\x12\x04\xb9\x1b\x04?\n\x12\n\
    \n\x06\0\x02\xcd\x01\x04\xc2\xf3\x04\0\x12\x04\xb9\x1b\x04?\n\x0e\n\x06\
    \x06\0\x02\xcd\x01\x04\x12\x04\xba\x1b\x04B\n\x12\n\n\x06\0\x02\xcd\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xba\x1b\x04B\n\x0e\n\x06\x06\0\x02\xcd\x01\
    \x04\x12\x04\xbb\x1b\x04B\n\x12\n\n\x06\0\x02\xcd\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xbb\x1b\x04B\n\x0f\n\x05\x06\0\x02\xce\x01\x12\x06\xbe\x1b\
    \x02\xc8\x1b\x03\n\x0e\n\x06\x06\0\x02\xce\x01\x01\x12\x04\xbe\x1b\x06\
    \x0f\n\x0e\n\x06\x06\0\x02\xce\x01\x02\x12\x04\xbe\x1b\x11!\n\x0e\n\x06\
    \x06\0\x02\xce\x01\x03\x12\x04\xbe\x1b,@\n\x10\n\x06\x06\0\x02\xce\x01\
    \x04\x12\x06\xbf\x1b\x04\xc4\x1b\x06\n\x14\n\n\x06\0\x02\xce\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xbf\x1b\x04\xc4\x1b\x06\n\x0e\n\x06\x06\0\x02\xce\x01\
    \x04\x12\x04\xc5\x1b\x047\n\x11\n\t\x06\0\x02\xce\x01\x04\xc3\xf3\x04\
    \x12\x04\xc5\x1b\x047\n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xc6\x1b\
    \x04?\n\x12\n\n\x06\0\x02\xce\x01\x04\xc2\xf3\x04\0\x12\x04\xc6\x1b\x04?\
    \n\x0e\n\x06\x06\0\x02\xce\x01\x04\x12\x04\xc7\x1b\x04B\n\x12\n\n\x06\0\
    \x02\xce\x01\x04\xc2\xf3\x04\x01\x12\x04\xc7\x1b\x04B\n\x0f\n\x05\x06\0\
    \x02\xcf\x01\x12\x06\xca\x1b\x02\xd4\x1b\x03\n\x0e\n\x06\x06\0\x02\xcf\
    \x01\x01\x12\x04\xca\x1b\x06\x11\n\x0e\n\x06\x06\0\x02\xcf\x01\x02\x12\
    \x04\xca\x1b\x13%\n\x0e\n\x06\x06\0\x02\xcf\x01\x03\x12\x04\xca\x1b0C\n\
    \x10\n\x06\x06\0\x02\xcf\x01\x04\x12\x06\xcb\x1b\x04\xd0\x1b\x06\n\x14\n\
    \n\x06\0\x02\xcf\x01\x04\xb0\xca\xbc\"\x12\x06\xcb\x1b\x04\xd0\x1b\x06\n\
    \x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\x04\xd1\x1b\x047\n\x11\n\t\x06\0\
    \x02\xcf\x01\x04\xc3\xf3\x04\x12\x04\xd1\x1b\x047\n\x0e\n\x06\x06\0\x02\
    \xcf\x01\x04\x12\x04\xd2\x1b\x04?\n\x12\n\n\x06\0\x02\xcf\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xd2\x1b\x04?\n\x0e\n\x06\x06\0\x02\xcf\x01\x04\x12\
    \x04\xd3\x1b\x04B\n\x12\n\n\x06\0\x02\xcf\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xd3\x1b\x04B\n\x0f\n\x05\x06\0\x02\xd0\x01\x12\x06\xd6\x1b\x02\xe4\
    \x1b\x03\n\x0e\n\x06\x06\0\x02\xd0\x01\x01\x12\x04\xd6\x1b\x06\x13\n\x0e\
    \n\x06\x06\0\x02\xd0\x01\x02\x12\x04\xd6\x1b\x15)\n\x0e\n\x06\x06\0\x02\
    \xd0\x01\x03\x12\x04\xd6\x1b4T\n\x10\n\x06\x06\0\x02\xd0\x01\x04\x12\x06\
    \xd7\x1b\x04\xde\x1b\x06\n\x14\n\n\x06\0\x02\xd0\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xd7\x1b\x04\xde\x1b\x06\n\x0e\n\x06\x06\0\x02\xd0\x01\x04\x12\
    \x04\xdf\x1b\x047\n\x11\n\t\x06\0\x02\xd0\x01\x04\xc3\xf3\x04\x12\x04\
    \xdf\x1b\x047\n\x0e\n\x06\x06\0\x02\xd0\x01\x04\x12\x04\xe0\x1b\x04?\n\
    \x12\n\n\x06\0\x02\xd0\x01\x04\xc2\xf3\x04\0\x12\x04\xe0\x1b\x04?\n\x0e\
    \n\x06\x06\0\x02\xd0\x01\x04\x12\x04\xe1\x1b\x04B\n\x12\n\n\x06\0\x02\
    \xd0\x01\x04\xc2\xf3\x04\x01\x12\x04\xe1\x1b\x04B\n\x0e\n\x06\x06\0\x02\
    \xd0\x01\x04\x12\x04\xe2\x1b\x04B\n\x12\n\n\x06\0\x02\xd0\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xe2\x1b\x04B\n\x0e\n\x06\x06\0\x02\xd0\x01\x04\x12\
    \x04\xe3\x1b\x04E\n\x12\n\n\x06\0\x02\xd0\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xe3\x1b\x04E\n\xaf\x06\n\x05\x06\0\x02\xd1\x01\x12\x06\xf3\x1b\x02\
    \x86\x1c\x03\x1a\x9d\x06\x20Initiates\x20retrieval\x20of\x20inputs\x20fr\
    om\x20cloud\x20storage\x20from\x20a\x20user\x20provided\x20data\x20sourc\
    e.\n\x20Will\x20create\x20and\x20return\x20an\x20inputs-add-job\x20for\
    \x20tracking\x20progress.\n\x20Archives\x20will\x20be\x20extracted\x20an\
    d\x20their\x20contents\x20will\x20be\x20processed\x20as\x20inputs.\n\n\
    \x20The\x20cloud\x20URL\x20will\x20be\x20treated\x20as\x20a\x20filter\
    \x20prefix.\x20For\x20example\x20s3:/bucket/images_folder/abc\x20will\
    \x20process\n\x20files\x20in\x20the\x20images_folder\x20beginning\x20wit\
    h\x20abc\x20or\x20in\x20a\x20subfolder\x20beginning\x20with\x20abc.\n\
    \x20For\x20example:\n\x20bucket/images_folder/abcImage.png\n\x20bucket/i\
    mages_folder/abc-1/Data.zip\n\n\x20If\x20given\x20URL\x20is\x20for\x20a\
    \x20private\x20bucket\x20or\x20file,\x20then\x20credentials\x20should\
    \x20be\x20provided\x20to\x20access\x20the\x20bucket.\n\x20Credentials\
    \x20should\x20include\x20rights\x20to\x20list\x20the\x20objects\x20in\
    \x20the\x20bucket,\x20except\x20when\x20pointed\x20directly\x20at\x20a\
    \x20file\x20archive,\n\x20in\x20which\x20case\x20it\x20only\x20requires\
    \x20rights\x20to\x20access\x20that\x20particular\x20file.\n\n\x0e\n\x06\
    \x06\0\x02\xd1\x01\x01\x12\x04\xf3\x1b\x06\x1b\n\x0e\n\x06\x06\0\x02\xd1\
    \x01\x02\x12\x04\xf3\x1b\x1d9\n\x0e\n\x06\x06\0\x02\xd1\x01\x03\x12\x04\
    \xf3\x1bD]\n\x10\n\x06\x06\0\x02\xd1\x01\x04\x12\x06\xf4\x1b\x04\xfb\x1b\
    \x06\n\x14\n\n\x06\0\x02\xd1\x01\x04\xb0\xca\xbc\"\x12\x06\xf4\x1b\x04\
    \xfb\x1b\x06\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\xfc\x1b\x047\n\
    \x11\n\t\x06\0\x02\xd1\x01\x04\xc3\xf3\x04\x12\x04\xfc\x1b\x047\n\x0e\n\
    \x06\x06\0\x02\xd1\x01\x04\x12\x04\xfd\x1b\x04?\n\x12\n\n\x06\0\x02\xd1\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xfd\x1b\x04?\n\x0e\n\x06\x06\0\x02\xd1\
    \x01\x04\x12\x04\xfe\x1b\x04F\n\x12\n\n\x06\0\x02\xd1\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xfe\x1b\x04F\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\
    \xff\x1b\x04F\n\x12\n\n\x06\0\x02\xd1\x01\x04\xc2\xf3\x04\x02\x12\x04\
    \xff\x1b\x04F\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\x80\x1c\x04C\n\
    \x12\n\n\x06\0\x02\xd1\x01\x04\xc2\xf3\x04\x03\x12\x04\x80\x1c\x04C\n\
    \x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\x81\x1c\x04A\n\x12\n\n\x06\0\
    \x02\xd1\x01\x04\xc2\xf3\x04\x04\x12\x04\x81\x1c\x04A\n\x0e\n\x06\x06\0\
    \x02\xd1\x01\x04\x12\x04\x82\x1c\x04A\n\x12\n\n\x06\0\x02\xd1\x01\x04\
    \xc2\xf3\x04\x05\x12\x04\x82\x1c\x04A\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\
    \x12\x04\x83\x1c\x04A\n\x12\n\n\x06\0\x02\xd1\x01\x04\xc2\xf3\x04\x06\
    \x12\x04\x83\x1c\x04A\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\x84\x1c\
    \x04>\n\x12\n\n\x06\0\x02\xd1\x01\x04\xc2\xf3\x04\x07\x12\x04\x84\x1c\
    \x04>\n\x0e\n\x06\x06\0\x02\xd1\x01\x04\x12\x04\x85\x1c\x04D\n\x12\n\n\
    \x06\0\x02\xd1\x01\x04\xc2\xf3\x04\x08\x12\x04\x85\x1c\x04D\n=\n\x05\x06\
    \0\x02\xd2\x01\x12\x06\x89\x1c\x02\x93\x1c\x03\x1a,\x20Get\x20the\x20inp\
    ut\x20extraction\x20job\x20details\x20by\x20ID\n\n\x0e\n\x06\x06\0\x02\
    \xd2\x01\x01\x12\x04\x89\x1c\x06\x1c\n\x0e\n\x06\x06\0\x02\xd2\x01\x02\
    \x12\x04\x89\x1c\x1e;\n\x0e\n\x06\x06\0\x02\xd2\x01\x03\x12\x04\x89\x1cF\
    g\n\x10\n\x06\x06\0\x02\xd2\x01\x04\x12\x06\x8a\x1c\x04\x8f\x1c\x06\n\
    \x14\n\n\x06\0\x02\xd2\x01\x04\xb0\xca\xbc\"\x12\x06\x8a\x1c\x04\x8f\x1c\
    \x06\n\x0e\n\x06\x06\0\x02\xd2\x01\x04\x12\x04\x90\x1c\x047\n\x11\n\t\
    \x06\0\x02\xd2\x01\x04\xc3\xf3\x04\x12\x04\x90\x1c\x047\n\x0e\n\x06\x06\
    \0\x02\xd2\x01\x04\x12\x04\x91\x1c\x04?\n\x12\n\n\x06\0\x02\xd2\x01\x04\
    \xc2\xf3\x04\0\x12\x04\x91\x1c\x04?\n\x0e\n\x06\x06\0\x02\xd2\x01\x04\
    \x12\x04\x92\x1c\x04A\n\x12\n\n\x06\0\x02\xd2\x01\x04\xc2\xf3\x04\x01\
    \x12\x04\x92\x1c\x04A\n5\n\x05\x06\0\x02\xd3\x01\x12\x06\x96\x1c\x02\xa0\
    \x1c\x03\x1a$\x20List\x20all\x20the\x20input\x20extraction\x20jobs\n\n\
    \x0e\n\x06\x06\0\x02\xd3\x01\x01\x12\x04\x96\x1c\x06\x1e\n\x0e\n\x06\x06\
    \0\x02\xd3\x01\x02\x12\x04\x96\x1c\x20?\n\x0e\n\x06\x06\0\x02\xd3\x01\
    \x03\x12\x04\x96\x1cJj\n\x10\n\x06\x06\0\x02\xd3\x01\x04\x12\x06\x97\x1c\
    \x04\x9c\x1c\x06\n\x14\n\n\x06\0\x02\xd3\x01\x04\xb0\xca\xbc\"\x12\x06\
    \x97\x1c\x04\x9c\x1c\x06\n\x0e\n\x06\x06\0\x02\xd3\x01\x04\x12\x04\x9d\
    \x1c\x047\n\x11\n\t\x06\0\x02\xd3\x01\x04\xc3\xf3\x04\x12\x04\x9d\x1c\
    \x047\n\x0e\n\x06\x06\0\x02\xd3\x01\x04\x12\x04\x9e\x1c\x04?\n\x12\n\n\
    \x06\0\x02\xd3\x01\x04\xc2\xf3\x04\0\x12\x04\x9e\x1c\x04?\n\x0e\n\x06\
    \x06\0\x02\xd3\x01\x04\x12\x04\x9f\x1c\x04A\n\x12\n\n\x06\0\x02\xd3\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\x9f\x1c\x04A\n\x0f\n\x05\x06\0\x02\xd4\x01\
    \x12\x06\xa2\x1c\x02\xaf\x1c\x03\n\x0e\n\x06\x06\0\x02\xd4\x01\x01\x12\
    \x04\xa2\x1c\x06\x20\n\x0e\n\x06\x06\0\x02\xd4\x01\x02\x12\x04\xa2\x1c\"\
    C\n\x0e\n\x06\x06\0\x02\xd4\x01\x03\x12\x04\xa2\x1cNn\n\x10\n\x06\x06\0\
    \x02\xd4\x01\x04\x12\x06\xa3\x1c\x04\xaa\x1c\x06\n\x14\n\n\x06\0\x02\xd4\
    \x01\x04\xb0\xca\xbc\"\x12\x06\xa3\x1c\x04\xaa\x1c\x06\n\x0e\n\x06\x06\0\
    \x02\xd4\x01\x04\x12\x04\xab\x1c\x047\n\x11\n\t\x06\0\x02\xd4\x01\x04\
    \xc3\xf3\x04\x12\x04\xab\x1c\x047\n\x0e\n\x06\x06\0\x02\xd4\x01\x04\x12\
    \x04\xac\x1c\x04?\n\x12\n\n\x06\0\x02\xd4\x01\x04\xc2\xf3\x04\0\x12\x04\
    \xac\x1c\x04?\n\x0e\n\x06\x06\0\x02\xd4\x01\x04\x12\x04\xad\x1c\x04A\n\
    \x12\n\n\x06\0\x02\xd4\x01\x04\xc2\xf3\x04\x01\x12\x04\xad\x1c\x04A\n\
    \x0e\n\x06\x06\0\x02\xd4\x01\x04\x12\x04\xae\x1c\x04A\n\x12\n\n\x06\0\
    \x02\xd4\x01\x04\xc2\xf3\x04\x02\x12\x04\xae\x1c\x04A\n\xe8\x02\n\x05\
    \x06\0\x02\xd5\x01\x12\x06\xb6\x1c\x02\xcb\x1c\x03\x1a\xd6\x02\x20Start\
    \x20uploading\x20a\x20file\x20archive\x20containing\x20inputs.\n\x20Will\
    \x20create\x20and\x20return\x20an\x20inputs-add-job\x20for\x20tracking\
    \x20progress.\n\n\x20Associated\x20inputs-add-job\x20contains\x20an\x20u\
    pload\x20id\x20which\x20should\x20be\x20completed\x20through\x20`PutUplo\
    adContentParts`\x20endpoint.\n\x20Completing\x20the\x20upload\x20will\
    \x20automatically\x20begin\x20unpacking\x20the\x20archive\x20and\x20uplo\
    ading\x20the\x20contents\x20as\x20inputs.\n\n\x0e\n\x06\x06\0\x02\xd5\
    \x01\x01\x12\x04\xb6\x1c\x06\x17\n\x0e\n\x06\x06\0\x02\xd5\x01\x02\x12\
    \x04\xb6\x1c\x191\n\x0e\n\x06\x06\0\x02\xd5\x01\x03\x12\x04\xb6\x1c<U\n\
    \x10\n\x06\x06\0\x02\xd5\x01\x04\x12\x06\xb7\x1c\x04\xbe\x1c\x06\n\x14\n\
    \n\x06\0\x02\xd5\x01\x04\xb0\xca\xbc\"\x12\x06\xb7\x1c\x04\xbe\x1c\x06\n\
    \x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\x04\xbf\x1c\x047\n\x11\n\t\x06\0\
    \x02\xd5\x01\x04\xc3\xf3\x04\x12\x04\xbf\x1c\x047\n\x0e\n\x06\x06\0\x02\
    \xd5\x01\x04\x12\x04\xc0\x1c\x04?\n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xc0\x1c\x04?\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\
    \x04\xc1\x1c\x04F\n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xc1\x1c\x04F\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\x04\xc2\x1c\x04F\
    \n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\xf3\x04\x02\x12\x04\xc2\x1c\x04F\n\
    \x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\x04\xc3\x1c\x04C\n\x12\n\n\x06\0\
    \x02\xd5\x01\x04\xc2\xf3\x04\x03\x12\x04\xc3\x1c\x04C\n\x0e\n\x06\x06\0\
    \x02\xd5\x01\x04\x12\x04\xc4\x1c\x04A\n\x12\n\n\x06\0\x02\xd5\x01\x04\
    \xc2\xf3\x04\x04\x12\x04\xc4\x1c\x04A\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\
    \x12\x04\xc5\x1c\x04A\n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\xf3\x04\x05\
    \x12\x04\xc5\x1c\x04A\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\x04\xc6\x1c\
    \x04A\n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\xf3\x04\x06\x12\x04\xc6\x1c\
    \x04A\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\x04\xc7\x1c\x04>\n\x12\n\n\
    \x06\0\x02\xd5\x01\x04\xc2\xf3\x04\x07\x12\x04\xc7\x1c\x04>\n\x0e\n\x06\
    \x06\0\x02\xd5\x01\x04\x12\x04\xc8\x1c\x04D\n\x12\n\n\x06\0\x02\xd5\x01\
    \x04\xc2\xf3\x04\x08\x12\x04\xc8\x1c\x04D\n\x0e\n\x06\x06\0\x02\xd5\x01\
    \x04\x12\x04\xc9\x1c\x04B\n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\xf3\x04\t\
    \x12\x04\xc9\x1c\x04B\n\x0e\n\x06\x06\0\x02\xd5\x01\x04\x12\x04\xca\x1c\
    \x04B\n\x12\n\n\x06\0\x02\xd5\x01\x04\xc2\xf3\x04\n\x12\x04\xca\x1c\x04B\
    \nj\n\x05\x06\0\x02\xd6\x01\x12\x06\xd1\x1c\x02\xdb\x1c\x03\x1aY\x20Get\
    \x20a\x20specific\x20runner.\n\x20TODO(zeiler):\x20runner_id\x20is\x20a\
    \x20UUID\x20so\x20can\x20list\x20globally\x20as\x20well.\n\n\x0e\n\x06\
    \x06\0\x02\xd6\x01\x01\x12\x04\xd1\x1c\x06\x0f\n\x0e\n\x06\x06\0\x02\xd6\
    \x01\x02\x12\x04\xd1\x1c\x11!\n\x0e\n\x06\x06\0\x02\xd6\x01\x03\x12\x04\
    \xd1\x1c,@\n\x10\n\x06\x06\0\x02\xd6\x01\x04\x12\x06\xd2\x1c\x04\xd7\x1c\
    \x06\n\x14\n\n\x06\0\x02\xd6\x01\x04\xb0\xca\xbc\"\x12\x06\xd2\x1c\x04\
    \xd7\x1c\x06\n\x0e\n\x06\x06\0\x02\xd6\x01\x04\x12\x04\xd8\x1c\x047\n\
    \x11\n\t\x06\0\x02\xd6\x01\x04\xc3\xf3\x04\x12\x04\xd8\x1c\x047\n\x0e\n\
    \x06\x06\0\x02\xd6\x01\x04\x12\x04\xd9\x1c\x04?\n\x12\n\n\x06\0\x02\xd6\
    \x01\x04\xc2\xf3\x04\0\x12\x04\xd9\x1c\x04?\n\x0e\n\x06\x06\0\x02\xd6\
    \x01\x04\x12\x04\xda\x1c\x04B\n\x12\n\n\x06\0\x02\xd6\x01\x04\xc2\xf3\
    \x04\x01\x12\x04\xda\x1c\x04B\n5\n\x05\x06\0\x02\xd7\x01\x12\x06\xde\x1c\
    \x02\xe8\x1c\x03\x1a$\x20List\x20all\x20the\x20runners\x20for\x20the\x20\
    user.\n\n\x0e\n\x06\x06\0\x02\xd7\x01\x01\x12\x04\xde\x1c\x06\x11\n\x0e\
    \n\x06\x06\0\x02\xd7\x01\x02\x12\x04\xde\x1c\x13%\n\x0e\n\x06\x06\0\x02\
    \xd7\x01\x03\x12\x04\xde\x1c0C\n\x10\n\x06\x06\0\x02\xd7\x01\x04\x12\x06\
    \xdf\x1c\x04\xe4\x1c\x06\n\x14\n\n\x06\0\x02\xd7\x01\x04\xb0\xca\xbc\"\
    \x12\x06\xdf\x1c\x04\xe4\x1c\x06\n\x0e\n\x06\x06\0\x02\xd7\x01\x04\x12\
    \x04\xe5\x1c\x047\n\x11\n\t\x06\0\x02\xd7\x01\x04\xc3\xf3\x04\x12\x04\
    \xe5\x1c\x047\n\x0e\n\x06\x06\0\x02\xd7\x01\x04\x12\x04\xe6\x1c\x04?\n\
    \x12\n\n\x06\0\x02\xd7\x01\x04\xc2\xf3\x04\0\x12\x04\xe6\x1c\x04?\n\x0e\
    \n\x06\x06\0\x02\xd7\x01\x04\x12\x04\xe7\x1c\x04B\n\x12\n\n\x06\0\x02\
    \xd7\x01\x04\xc2\xf3\x04\x01\x12\x04\xe7\x1c\x04B\n+\n\x05\x06\0\x02\xd8\
    \x01\x12\x06\xeb\x1c\x02\xf8\x1c\x03\x1a\x1a\x20Add\x20a\x20runners\x20t\
    o\x20a\x20user.\n\n\x0e\n\x06\x06\0\x02\xd8\x01\x01\x12\x04\xeb\x1c\x06\
    \x11\n\x0e\n\x06\x06\0\x02\xd8\x01\x02\x12\x04\xeb\x1c\x13%\n\x0e\n\x06\
    \x06\0\x02\xd8\x01\x03\x12\x04\xeb\x1c0C\n\x10\n\x06\x06\0\x02\xd8\x01\
    \x04\x12\x06\xec\x1c\x04\xf3\x1c\x06\n\x14\n\n\x06\0\x02\xd8\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xec\x1c\x04\xf3\x1c\x06\n\x0e\n\x06\x06\0\x02\xd8\x01\
    \x04\x12\x04\xf4\x1c\x047\n\x11\n\t\x06\0\x02\xd8\x01\x04\xc3\xf3\x04\
    \x12\x04\xf4\x1c\x047\n\x0e\n\x06\x06\0\x02\xd8\x01\x04\x12\x04\xf5\x1c\
    \x04?\n\x12\n\n\x06\0\x02\xd8\x01\x04\xc2\xf3\x04\0\x12\x04\xf5\x1c\x04?\
    \n\x0e\n\x06\x06\0\x02\xd8\x01\x04\x12\x04\xf6\x1c\x04B\n\x12\n\n\x06\0\
    \x02\xd8\x01\x04\xc2\xf3\x04\x01\x12\x04\xf6\x1c\x04B\n\x0e\n\x06\x06\0\
    \x02\xd8\x01\x04\x12\x04\xf7\x1c\x04B\n\x12\n\n\x06\0\x02\xd8\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\xf7\x1c\x04B\n:\n\x05\x06\0\x02\xd9\x01\x12\x06\
    \xfb\x1c\x02\x89\x1d\x03\x1a)\x20Delete\x20multiple\x20runners\x20in\x20\
    one\x20request.\n\n\x0e\n\x06\x06\0\x02\xd9\x01\x01\x12\x04\xfb\x1c\x06\
    \x13\n\x0e\n\x06\x06\0\x02\xd9\x01\x02\x12\x04\xfb\x1c\x15)\n\x0e\n\x06\
    \x06\0\x02\xd9\x01\x03\x12\x04\xfb\x1c4T\n\x10\n\x06\x06\0\x02\xd9\x01\
    \x04\x12\x06\xfc\x1c\x04\x83\x1d\x06\n\x14\n\n\x06\0\x02\xd9\x01\x04\xb0\
    \xca\xbc\"\x12\x06\xfc\x1c\x04\x83\x1d\x06\n\x0e\n\x06\x06\0\x02\xd9\x01\
    \x04\x12\x04\x84\x1d\x047\n\x11\n\t\x06\0\x02\xd9\x01\x04\xc3\xf3\x04\
    \x12\x04\x84\x1d\x047\n\x0e\n\x06\x06\0\x02\xd9\x01\x04\x12\x04\x85\x1d\
    \x04?\n\x12\n\n\x06\0\x02\xd9\x01\x04\xc2\xf3\x04\0\x12\x04\x85\x1d\x04?\
    \n\x0e\n\x06\x06\0\x02\xd9\x01\x04\x12\x04\x86\x1d\x04B\n\x12\n\n\x06\0\
    \x02\xd9\x01\x04\xc2\xf3\x04\x01\x12\x04\x86\x1d\x04B\n\x0e\n\x06\x06\0\
    \x02\xd9\x01\x04\x12\x04\x87\x1d\x04B\n\x12\n\n\x06\0\x02\xd9\x01\x04\
    \xc2\xf3\x04\x02\x12\x04\x87\x1d\x04B\n\x0e\n\x06\x06\0\x02\xd9\x01\x04\
    \x12\x04\x88\x1d\x04E\n\x12\n\n\x06\0\x02\xd9\x01\x04\xc2\xf3\x04\x03\
    \x12\x04\x88\x1d\x04E\n}\n\x05\x06\0\x02\xda\x01\x12\x06\x8d\x1d\x02\x98\
    \x1d\x03\x1al\x20List\x20items\x20for\x20the\x20remote\x20runner\x20to\
    \x20work\x20on.\n\x20since\x20the\x20runner_id\x20is\x20a\x20UUID\x20we\
    \x20can\x20access\x20it\x20directly\x20too.\n\n\x0e\n\x06\x06\0\x02\xda\
    \x01\x01\x12\x04\x8d\x1d\x06\x15\n\x0e\n\x06\x06\0\x02\xda\x01\x02\x12\
    \x04\x8d\x1d\x17-\n\x0e\n\x06\x06\0\x02\xda\x01\x03\x12\x04\x8d\x1d8O\n\
    \x10\n\x06\x06\0\x02\xda\x01\x04\x12\x06\x8e\x1d\x04\x93\x1d\x06\n\x14\n\
    \n\x06\0\x02\xda\x01\x04\xb0\xca\xbc\"\x12\x06\x8e\x1d\x04\x93\x1d\x06\n\
    \x0e\n\x06\x06\0\x02\xda\x01\x04\x12\x04\x94\x1d\x047\n\x11\n\t\x06\0\
    \x02\xda\x01\x04\xc3\xf3\x04\x12\x04\x94\x1d\x047\n\x0e\n\x06\x06\0\x02\
    \xda\x01\x04\x12\x04\x95\x1d\x04?\n\x12\n\n\x06\0\x02\xda\x01\x04\xc2\
    \xf3\x04\0\x12\x04\x95\x1d\x04?\n\x0e\n\x06\x06\0\x02\xda\x01\x04\x12\
    \x04\x96\x1d\x04B\n\x12\n\n\x06\0\x02\xda\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\x96\x1d\x04B\n\x0e\n\x06\x06\0\x02\xda\x01\x04\x12\x04\x97\x1d\x04F\
    \n\x12\n\n\x06\0\x02\xda\x01\x04\xc2\xf3\x04\x02\x12\x04\x97\x1d\x04F\nv\
    \n\x05\x06\0\x02\xdb\x01\x12\x06\x9c\x1d\x02\xaa\x1d\x03\x1ae\x20Post\
    \x20back\x20outputs\x20from\x20remote\x20runners\n\x20since\x20the\x20ru\
    nner_id\x20is\x20a\x20UUID\x20we\x20can\x20access\x20it\x20directly\x20t\
    oo.\n\n\x0e\n\x06\x06\0\x02\xdb\x01\x01\x12\x04\x9c\x1d\x06\x1b\n\x0e\n\
    \x06\x06\0\x02\xdb\x01\x02\x12\x04\x9c\x1d\x1d9\n\x0e\n\x06\x06\0\x02\
    \xdb\x01\x03\x12\x04\x9c\x1dDa\n\x10\n\x06\x06\0\x02\xdb\x01\x04\x12\x06\
    \x9d\x1d\x04\xa4\x1d\x06\n\x14\n\n\x06\0\x02\xdb\x01\x04\xb0\xca\xbc\"\
    \x12\x06\x9d\x1d\x04\xa4\x1d\x06\n\x0e\n\x06\x06\0\x02\xdb\x01\x04\x12\
    \x04\xa5\x1d\x047\n\x11\n\t\x06\0\x02\xdb\x01\x04\xc3\xf3\x04\x12\x04\
    \xa5\x1d\x047\n\x0e\n\x06\x06\0\x02\xdb\x01\x04\x12\x04\xa6\x1d\x04?\n\
    \x12\n\n\x06\0\x02\xdb\x01\x04\xc2\xf3\x04\0\x12\x04\xa6\x1d\x04?\n\x0e\
    \n\x06\x06\0\x02\xdb\x01\x04\x12\x04\xa7\x1d\x04B\n\x12\n\n\x06\0\x02\
    \xdb\x01\x04\xc2\xf3\x04\x01\x12\x04\xa7\x1d\x04B\n\x0e\n\x06\x06\0\x02\
    \xdb\x01\x04\x12\x04\xa8\x1d\x04F\n\x12\n\n\x06\0\x02\xdb\x01\x04\xc2\
    \xf3\x04\x02\x12\x04\xa8\x1d\x04F\n\x0e\n\x06\x06\0\x02\xdb\x01\x04\x12\
    \x04\xa9\x1d\x04F\n\x12\n\n\x06\0\x02\xdb\x01\x04\xc2\xf3\x04\x03\x12\
    \x04\xa9\x1d\x04F\n\xef\x03\n\x05\x06\0\x02\xdc\x01\x12\x06\xb2\x1d\x02\
    \xb8\x1d\x03\x1a\xdd\x03\x20This\x20maintains\x20a\x20single\x20request\
    \x20for\x20asking\x20the\x20API\x20if\x20there\x20is\x20any\x20work\x20t\
    o\x20be\x20done,\x20processing\n\x20it\x20and\x20streaming\x20back\x20re\
    sults.\n\x20To\x20do\x20that\x20first\x20handshake\x20the\x20MultiRunner\
    ItemOutputResponse\x20will\x20have\x20RUNNER_STREAM_START\n\x20status\
    \x20filled\x20in\x20so\x20that\x20the\x20API\x20knows\x20to\x20respond\
    \x20with\x20a\x20MultiRunnerItemResponse.\n\x20For\x20now\x20there\x20wi\
    ll\x20only\x20be\x20one\x20of\x20those\x20if\x20the\x20model\x20predicti\
    on\x20only\x20has\x20one\x20request.\n\x20NOTE(zeiler):\x20downside\x20o\
    f\x20this\x20is\x20you\x20can't\x20use\x20HTTP\x20REST\x20requests\x20to\
    \x20do\x20runner\x20work.\n\n\x0e\n\x06\x06\0\x02\xdc\x01\x01\x12\x04\
    \xb2\x1d\x06\x18\n\x0e\n\x06\x06\0\x02\xdc\x01\x05\x12\x04\xb2\x1d\x1a\
    \x20\n\x0e\n\x06\x06\0\x02\xdc\x01\x02\x12\x04\xb2\x1d!=\n\x0e\n\x06\x06\
    \0\x02\xdc\x01\x06\x12\x04\xb2\x1dHN\n\x0e\n\x06\x06\0\x02\xdc\x01\x03\
    \x12\x04\xb2\x1dOf\n\x0e\n\x06\x06\0\x02\xdc\x01\x04\x12\x04\xb3\x1d\x04\
    7\n\x11\n\t\x06\0\x02\xdc\x01\x04\xc3\xf3\x04\x12\x04\xb3\x1d\x047\n\x0e\
    \n\x06\x06\0\x02\xdc\x01\x04\x12\x04\xb4\x1d\x04?\n\x12\n\n\x06\0\x02\
    \xdc\x01\x04\xc2\xf3\x04\0\x12\x04\xb4\x1d\x04?\n\x0e\n\x06\x06\0\x02\
    \xdc\x01\x04\x12\x04\xb5\x1d\x04B\n\x12\n\n\x06\0\x02\xdc\x01\x04\xc2\
    \xf3\x04\x01\x12\x04\xb5\x1d\x04B\n\x0e\n\x06\x06\0\x02\xdc\x01\x04\x12\
    \x04\xb6\x1d\x04F\n\x12\n\n\x06\0\x02\xdc\x01\x04\xc2\xf3\x04\x02\x12\
    \x04\xb6\x1d\x04F\n\x0e\n\x06\x06\0\x02\xdc\x01\x04\x12\x04\xb7\x1d\x04F\
    \n\x12\n\n\x06\0\x02\xdc\x01\x04\xc2\xf3\x04\x03\x12\x04\xb7\x1d\x04F\nd\
    \n\x05\x06\0\x02\xdd\x01\x12\x06\xbb\x1d\x02\xc7\x1d\x03\x1aS\x20Get\x20\
    the\x20training\x20time\x20estimate\x20based\x20off\x20train\x20request\
    \x20and\x20estimated\x20input\x20count.\n\n\x0e\n\x06\x06\0\x02\xdd\x01\
    \x01\x12\x04\xbb\x1d\x06+\n\x0e\n\x06\x06\0\x02\xdd\x01\x02\x12\x04\xbb\
    \x1d-Y\n\x0f\n\x06\x06\0\x02\xdd\x01\x03\x12\x05\xbb\x1dd\x85\x01\n\x10\
    \n\x06\x06\0\x02\xdd\x01\x04\x12\x06\xbc\x1d\x04\xc3\x1d\x06\n\x14\n\n\
    \x06\0\x02\xdd\x01\x04\xb0\xca\xbc\"\x12\x06\xbc\x1d\x04\xc3\x1d\x06\n\
    \x0e\n\x06\x06\0\x02\xdd\x01\x04\x12\x04\xc4\x1d\x047\n\x11\n\t\x06\0\
    \x02\xdd\x01\x04\xc3\xf3\x04\x12\x04\xc4\x1d\x047\n\x0e\n\x06\x06\0\x02\
    \xdd\x01\x04\x12\x04\xc5\x1d\x04?\n\x12\n\n\x06\0\x02\xdd\x01\x04\xc2\
    \xf3\x04\0\x12\x04\xc5\x1d\x04?\n\x0e\n\x06\x06\0\x02\xdd\x01\x04\x12\
    \x04\xc6\x1d\x04A\n\x12\n\n\x06\0\x02\xdd\x01\x04\xc2\xf3\x04\x01\x12\
    \x04\xc6\x1d\x04A\n-\n\x02\x04\0\x12\x06\xdc\x1d\0\xe1\x1d\x01\x1a\x1f\
    \x20Split\x20the\x20results\x20into\x20pages.\n\n\x0b\n\x03\x04\0\x01\
    \x12\x04\xdc\x1d\x08\x12\n}\n\x04\x04\0\x02\0\x12\x04\xde\x1d\x02\x12\
    \x1ao\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xde\x1d\
    \x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xde\x1d\t\r\n\r\n\x05\x04\0\
    \x02\0\x03\x12\x04\xde\x1d\x10\x11\nt\n\x04\x04\0\x02\x01\x12\x04\xe0\
    \x1d\x02\x16\x1af\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\x20to\x20128.\n\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\xe0\x1d\
    \x02\x08\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xe0\x1d\t\x11\n\r\n\x05\x04\
    \0\x02\x01\x03\x12\x04\xe0\x1d\x14\x15\n$\n\x02\x04\x01\x12\x06\xe4\x1d\
    \0\xe8\x1d\x01\x1a\x16\x20GetAnnotationRequest\n\n\x0b\n\x03\x04\x01\x01\
    \x12\x04\xe4\x1d\x08\x1c\n\x0c\n\x04\x04\x01\x02\0\x12\x04\xe5\x1d\x02,\
    \n\r\n\x05\x04\x01\x02\0\x06\x12\x04\xe5\x1d\x02\x1b\n\r\n\x05\x04\x01\
    \x02\0\x01\x12\x04\xe5\x1d\x1c'\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xe5\
    \x1d*+\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\xe6\x1d\x02\x1b\n\r\n\x05\x04\
    \x01\x02\x01\x05\x12\x04\xe6\x1d\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\
    \x12\x04\xe6\x1d\t\x16\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xe6\x1d\x19\
    \x1a\n\x0c\n\x04\x04\x01\x02\x02\x12\x04\xe7\x1d\x02\x16\n\r\n\x05\x04\
    \x01\x02\x02\x05\x12\x04\xe7\x1d\x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\
    \x12\x04\xe7\x1d\t\x11\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\xe7\x1d\x14\
    \x15\n&\n\x02\x04\x02\x12\x06\xeb\x1d\0\xa2\x1e\x01\x1a\x18\x20ListAnnot\
    ationsRequest\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xeb\x1d\x08\x1e\n\x0b\n\
    \x03\x04\x02\t\x12\x04\xec\x1d\x02\r\n\x0c\n\x04\x04\x02\t\0\x12\x04\xec\
    \x1d\x0b\x0c\n\r\n\x05\x04\x02\t\0\x01\x12\x04\xec\x1d\x0b\x0c\n\r\n\x05\
    \x04\x02\t\0\x02\x12\x04\xec\x1d\x0b\x0c\n\x0c\n\x04\x04\x02\x02\0\x12\
    \x04\xee\x1d\x02,\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xee\x1d\x02\x1b\n\
    \r\n\x05\x04\x02\x02\0\x01\x12\x04\xee\x1d\x1c'\n\r\n\x05\x04\x02\x02\0\
    \x03\x12\x04\xee\x1d*+\n.\n\x04\x04\x02\x02\x01\x12\x04\xf1\x1d\x02\x1a\
    \x1a\x20\x20List\x20annotations\x20for\x20these\x20IDs\n\n\r\n\x05\x04\
    \x02\x02\x01\x04\x12\x04\xf1\x1d\x02\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\
    \x04\xf1\x1d\x0b\x11\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xf1\x1d\x12\
    \x15\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xf1\x1d\x18\x19\n\xd5\x02\n\
    \x04\x04\x02\x02\x02\x12\x04\xf8\x1d\x02\x20\x1a\xc6\x02\x20List\x20anno\
    tations\x20for\x20these\x20Input\x20IDs\n\x20Note\x20that\x20'ids'\x20ar\
    e\x20optional\x20but\x20if\x20the\x20are\x20provided\x20the\x20number\
    \x20and\x20order\x20in\n\x20'ids'\x20and\x20'input_ids'\x20should\x20mat\
    ch\n\x20If\x20you\x20do\x20not\x20specify\x20'ids'\x20all\x20the\x20anno\
    tations\x20for\x20'input_ids'\x20are\x20returned\n\x20If\x20a\x20you\x20\
    do\x20not\x20specify\x20both\x20'input_ids'\x20and\x20'ids'\x20all\x20th\
    e\x20annotations\x20in\x20the\x20app\x20are\x20returned\n\n\r\n\x05\x04\
    \x02\x02\x02\x04\x12\x04\xf8\x1d\x02\n\n\r\n\x05\x04\x02\x02\x02\x05\x12\
    \x04\xf8\x1d\x0b\x11\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xf8\x1d\x12\
    \x1b\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xf8\x1d\x1e\x1f\n\xb3\x03\n\
    \x04\x04\x02\x02\x03\x12\x04\xff\x1d\x02\x1f\x1a\xa4\x03\x20Only\x20retu\
    rn\x20the\x20annotations\x20that\x20has\x20one\x20of\x20these\x20user\
    \x20IDs,\x20effectively\x20operating\x20as\x20an\n\x20OR\x20among\x20the\
    m\x20to\x20filter\x20down\x20the\x20results.\n\x20If\x20model_version_id\
    s\x20or\x20workflow_version_ids\x20are\x20also\x20provided,\x20these\x20\
    user_ids\x20are\x20OR'd\x20with\x20them\x20as\x20well\x20because\n\x20we\
    \x20want\x20the\x20union\x20of\x20all\x20worker\x20(user,\x20model\x20or\
    \x20workflow)\x20annotations\x20in\x20the\x20results\x20of\x20ListAnnota\
    tions\x20request.\n\x20Setting\x20user_ids\x20does\x20also\x20set\x20lis\
    t_all_annotations=True.\n\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\xff\x1d\
    \x02\n\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\xff\x1d\x0b\x11\n\r\n\x05\
    \x04\x02\x02\x03\x01\x12\x04\xff\x1d\x12\x1a\n\r\n\x05\x04\x02\x02\x03\
    \x03\x12\x04\xff\x1d\x1d\x1e\n\xc5\x03\n\x04\x04\x02\x02\x04\x12\x04\x86\
    \x1e\x02)\x1a\xb6\x03\x20Only\x20return\x20the\x20annotations\x20that\
    \x20has\x20one\x20of\x20these\x20model\x20version\x20IDs,\x20effectively\
    \x20operating\x20as\x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20do\
    wn\x20the\x20results.\n\x20If\x20user_ids\x20or\x20workflow_version_ids\
    \x20are\x20also\x20provided,\x20these\x20model_version_ids\x20are\x20OR'\
    d\x20with\x20them\x20as\x20well\x20because\n\x20we\x20want\x20the\x20uni\
    on\x20of\x20all\x20worker\x20(user,\x20model\x20or\x20workflow)\x20annot\
    ations\x20in\x20the\x20results\x20of\x20ListAnnotations\x20request.\n\
    \x20Setting\x20model_version_ids\x20does\x20also\x20set\x20list_all_anno\
    tations=True.\n\n\r\n\x05\x04\x02\x02\x04\x04\x12\x04\x86\x1e\x02\n\n\r\
    \n\x05\x04\x02\x02\x04\x05\x12\x04\x86\x1e\x0b\x11\n\r\n\x05\x04\x02\x02\
    \x04\x01\x12\x04\x86\x1e\x12#\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\x86\
    \x1e&(\n\xcb\x03\n\x04\x04\x02\x02\x05\x12\x04\x8d\x1e\x02,\x1a\xbc\x03\
    \x20Only\x20return\x20the\x20annotations\x20that\x20has\x20one\x20of\x20\
    these\x20workflow\x20version\x20IDs,\x20effectively\x20operating\x20as\
    \x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20down\x20the\x20result\
    s.\n\x20If\x20user_ids\x20or\x20model_version_ids\x20are\x20also\x20prov\
    ided,\x20these\x20workflow_version_ids\x20are\x20OR'd\x20with\x20them\
    \x20as\x20well\x20because\n\x20we\x20want\x20the\x20union\x20of\x20all\
    \x20worker\x20(user,\x20model\x20or\x20workflow)\x20annotations\x20in\
    \x20the\x20results\x20of\x20ListAnnotations\x20request.\n\x20Setting\x20\
    workflow_version_ids\x20does\x20also\x20set\x20list_all_annotations=True\
    .\n\n\r\n\x05\x04\x02\x02\x05\x04\x12\x04\x8d\x1e\x02\n\n\r\n\x05\x04\
    \x02\x02\x05\x05\x12\x04\x8d\x1e\x0b\x11\n\r\n\x05\x04\x02\x02\x05\x01\
    \x12\x04\x8d\x1e\x12&\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\x8d\x1e)+\n\
    \x8b\x01\n\x04\x04\x02\x02\x06\x12\x04\x91\x1e\x023\x1a}\x20Set\x20statu\
    s\x20to\x20filter\x20by\x20a\x20list\x20of\x20statuses\n\x20If\x20not\
    \x20statuses\x20are\x20provided\x20then\x20annotations\x20with\x20any\
    \x20status\x20will\x20be\x20returned.\n\n\r\n\x05\x04\x02\x02\x06\x04\
    \x12\x04\x91\x1e\x02\n\n\r\n\x05\x04\x02\x02\x06\x06\x12\x04\x91\x1e\x0b\
    %\n\r\n\x05\x04\x02\x02\x06\x01\x12\x04\x91\x1e&.\n\r\n\x05\x04\x02\x02\
    \x06\x03\x12\x04\x91\x1e12\n\x80\x01\n\x04\x04\x02\x02\x07\x12\x04\x95\
    \x1e\x02\x20\x1ar\x20Set\x20this\x20flag\x20to\x20list\x20both\x20truste\
    d\x20and\x20not\x20trusted\x20annotations\n\x20by\x20default\x20it's\x20\
    listing\x20only\x20trusted\x20annotations\n\n\r\n\x05\x04\x02\x02\x07\
    \x05\x12\x04\x95\x1e\x02\x06\n\r\n\x05\x04\x02\x02\x07\x01\x12\x04\x95\
    \x1e\x07\x1b\n\r\n\x05\x04\x02\x02\x07\x03\x12\x04\x95\x1e\x1e\x1f\n_\n\
    \x04\x04\x02\x02\x08\x12\x04\x98\x1e\x02\x20\x1aQ\x20Set\x20this\x20flag\
    \x20to\x20return\x20the\x20model\x20output\x20for\x20model\x20annotation\
    s\x20in\x20the\x20response.\n\n\r\n\x05\x04\x02\x02\x08\x05\x12\x04\x98\
    \x1e\x02\x06\n\r\n\x05\x04\x02\x02\x08\x01\x12\x04\x98\x1e\x07\x1a\n\r\n\
    \x05\x04\x02\x02\x08\x03\x12\x04\x98\x1e\x1d\x1f\n~\n\x04\x04\x02\x02\t\
    \x12\x04\x9c\x1e\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\
    \x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\
    \x02\x02\t\x05\x12\x04\x9c\x1e\x02\x08\n\r\n\x05\x04\x02\x02\t\x01\x12\
    \x04\x9c\x1e\t\r\n\r\n\x05\x04\x02\x02\t\x03\x12\x04\x9c\x1e\x10\x11\nu\
    \n\x04\x04\x02\x02\n\x12\x04\x9f\x1e\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04\x02\x02\n\x05\x12\x04\x9f\x1e\x02\x08\n\r\n\x05\x04\x02\x02\n\
    \x01\x12\x04\x9f\x1e\t\x11\n\r\n\x05\x04\x02\x02\n\x03\x12\x04\x9f\x1e\
    \x14\x15\n5\n\x04\x04\x02\x02\x0b\x12\x04\xa1\x1e\x02\x16\x1a'\x20Flag\
    \x20to\x20filter\x20annotations\x20by\x20task_id\n\n\r\n\x05\x04\x02\x02\
    \x0b\x05\x12\x04\xa1\x1e\x02\x08\n\r\n\x05\x04\x02\x02\x0b\x01\x12\x04\
    \xa1\x1e\t\x10\n\r\n\x05\x04\x02\x02\x0b\x03\x12\x04\xa1\x1e\x13\x15\n&\
    \n\x02\x04\x03\x12\x06\xa5\x1e\0\xaa\x1e\x01\x1a\x18\x20PostAnnotationsR\
    equest\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xa5\x1e\x08\x1e\n\x0c\n\x04\x04\
    \x03\x02\0\x12\x04\xa7\x1e\x02,\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xa7\
    \x1e\x02\x1b\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xa7\x1e\x1c'\n\r\n\x05\
    \x04\x03\x02\0\x03\x12\x04\xa7\x1e*+\n\x0c\n\x04\x04\x03\x02\x01\x12\x04\
    \xa9\x1e\x02&\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\xa9\x1e\x02\n\n\r\n\
    \x05\x04\x03\x02\x01\x06\x12\x04\xa9\x1e\x0b\x15\n\r\n\x05\x04\x03\x02\
    \x01\x01\x12\x04\xa9\x1e\x16!\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xa9\
    \x1e$%\n'\n\x02\x04\x04\x12\x06\xad\x1e\0\xba\x1e\x01\x1a\x19\x20PatchAn\
    notationsRequest\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xad\x1e\x08\x1f\n\x0c\
    \n\x04\x04\x04\x02\0\x12\x04\xae\x1e\x02,\n\r\n\x05\x04\x04\x02\0\x06\
    \x12\x04\xae\x1e\x02\x1b\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xae\x1e\x1c\
    '\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xae\x1e*+\n\x0c\n\x04\x04\x04\x02\
    \x01\x12\x04\xb0\x1e\x02&\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xb0\x1e\
    \x02\n\n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\xb0\x1e\x0b\x15\n\r\n\x05\
    \x04\x04\x02\x01\x01\x12\x04\xb0\x1e\x16!\n\r\n\x05\x04\x04\x02\x01\x03\
    \x12\x04\xb0\x1e$%\n~\n\x04\x04\x04\x02\x02\x12\x04\xb4\x1e\x02\x14\x1ap\
    \x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\
    \x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\
    \x20are\x20supported\n\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xb4\x1e\x02\
    \x08\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\xb4\x1e\t\x0f\n\r\n\x05\x04\
    \x04\x02\x02\x03\x12\x04\xb4\x1e\x12\x13\n\xee\x01\n\x04\x04\x04\x02\x03\
    \x12\x04\xb9\x1e\x02\x20\x1a\xdf\x01\x20If\x20the\x20request\x20is\x20a\
    \x20\"remove\"\x20action\x20and\x20the\x20annotation\x20is\x20left\x20wi\
    th\x20empty\x20data,\n\x20then\x20setting\x20delete_if_empty_data\x20to\
    \x20true\x20will\x20delete\x20the\x20annotation,\n\x20if\x20possible\x20\
    (for\x20example,\x20will\x20not\x20delete\x20an\x20input-level\x20annota\
    tion).\n\n\r\n\x05\x04\x04\x02\x03\x05\x12\x04\xb9\x1e\x02\x06\n\r\n\x05\
    \x04\x04\x02\x03\x01\x12\x04\xb9\x1e\x07\x1b\n\r\n\x05\x04\x04\x02\x03\
    \x03\x12\x04\xb9\x1e\x1e\x1f\n-\n\x02\x04\x05\x12\x06\xbd\x1e\0\xcb\x1e\
    \x01\x1a\x1f\x20PatchAnnotationsStatusRequest\n\n\x0b\n\x03\x04\x05\x01\
    \x12\x04\xbd\x1e\x08%\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xbe\x1e\x02,\n\r\
    \n\x05\x04\x05\x02\0\x06\x12\x04\xbe\x1e\x02\x1b\n\r\n\x05\x04\x05\x02\0\
    \x01\x12\x04\xbe\x1e\x1c'\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xbe\x1e*+\
    \n\"\n\x04\x04\x05\x02\x01\x12\x04\xc0\x1e\x02\x1f\x1a\x14\x20Filter\x20\
    by\x20user\x20IDs\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\xc0\x1e\x02\n\
    \n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xc0\x1e\x0b\x11\n\r\n\x05\x04\x05\
    \x02\x01\x01\x12\x04\xc0\x1e\x12\x1a\n\r\n\x05\x04\x05\x02\x01\x03\x12\
    \x04\xc0\x1e\x1d\x1e\n!\n\x04\x04\x05\x02\x02\x12\x04\xc2\x1e\x02\x15\
    \x1a\x13\x20Filter\x20by\x20task\x20ID\n\n\r\n\x05\x04\x05\x02\x02\x05\
    \x12\x04\xc2\x1e\x02\x08\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xc2\x1e\t\
    \x10\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xc2\x1e\x13\x14\n&\n\x04\x04\
    \x05\x02\x03\x12\x04\xc4\x1e\x02;\x1a\x18\x20Filter\x20by\x20Status\x20c\
    odes\n\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04\xc4\x1e\x02\n\n\r\n\x05\x04\
    \x05\x02\x03\x06\x12\x04\xc4\x1e\x0b)\n\r\n\x05\x04\x05\x02\x03\x01\x12\
    \x04\xc4\x1e*6\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\xc4\x1e9:\n(\n\x04\
    \x04\x05\x02\x04\x12\x04\xc7\x1e\x02\x14\x1a\x1a\x20'overwrite'\x20is\
    \x20supported\n\n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\xc7\x1e\x02\x08\n\
    \r\n\x05\x04\x05\x02\x04\x01\x12\x04\xc7\x1e\t\x0f\n\r\n\x05\x04\x05\x02\
    \x04\x03\x12\x04\xc7\x1e\x12\x13\n:\n\x04\x04\x05\x02\x05\x12\x04\xca\
    \x1e\x021\x1a,\x20Update\x20filtered\x20annotations\x20to\x20this\x20sta\
    tus\n\n\r\n\x05\x04\x05\x02\x05\x06\x12\x04\xca\x1e\x02\x20\n\r\n\x05\
    \x04\x05\x02\x05\x01\x12\x04\xca\x1e!,\n\r\n\x05\x04\x05\x02\x05\x03\x12\
    \x04\xca\x1e/0\n.\n\x02\x04\x06\x12\x06\xce\x1e\0\xd2\x1e\x01\x1a\x20\
    \x20PatchAnnotationsStatusResponse\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xce\
    \x1e\x08&\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xcf\x1e\x02(\n\r\n\x05\x04\
    \x06\x02\0\x06\x12\x04\xcf\x1e\x02\x1c\n\r\n\x05\x04\x06\x02\0\x01\x12\
    \x04\xcf\x1e\x1d#\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xcf\x1e&'\n\x0c\n\
    \x04\x04\x06\x02\x01\x12\x04\xd0\x1e\x02\x1f\n\r\n\x05\x04\x06\x02\x01\
    \x04\x12\x04\xd0\x1e\x02\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xd0\x1e\
    \x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xd0\x1e\x12\x1a\n\r\n\x05\
    \x04\x06\x02\x01\x03\x12\x04\xd0\x1e\x1d\x1e\n\x0c\n\x04\x04\x06\x02\x02\
    \x12\x04\xd1\x1e\x02\x1b\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xd1\x1e\
    \x02\x08\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xd1\x1e\t\x16\n\r\n\x05\
    \x04\x06\x02\x02\x03\x12\x04\xd1\x1e\x19\x1a\n'\n\x02\x04\x07\x12\x06\
    \xd5\x1e\0\xdb\x1e\x01\x1a\x19\x20DeleteAnnotationRequest\n\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\xd5\x1e\x08\x1f\n\x0c\n\x04\x04\x07\x02\0\x12\x04\
    \xd6\x1e\x02,\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xd6\x1e\x02\x1b\n\r\n\
    \x05\x04\x07\x02\0\x01\x12\x04\xd6\x1e\x1c'\n\r\n\x05\x04\x07\x02\0\x03\
    \x12\x04\xd6\x1e*+\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xd8\x1e\x02\x16\n\
    \r\n\x05\x04\x07\x02\x01\x05\x12\x04\xd8\x1e\x02\x08\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xd8\x1e\t\x11\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\
    \xd8\x1e\x14\x15\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xda\x1e\x02\x1b\n\r\
    \n\x05\x04\x07\x02\x02\x05\x12\x04\xda\x1e\x02\x08\n\r\n\x05\x04\x07\x02\
    \x02\x01\x12\x04\xda\x1e\t\x16\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xda\
    \x1e\x19\x1a\nD\n\x02\x04\x08\x12\x06\xde\x1e\0\xeb\x1e\x01\x1a6\x20Requ\
    est\x20to\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20i\
    ds.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xde\x1e\x08\x20\n\x0c\n\x04\x04\
    \x08\x02\0\x12\x04\xdf\x1e\x02,\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xdf\
    \x1e\x02\x1b\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xdf\x1e\x1c'\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xdf\x1e*+\n+\n\x04\x04\x08\x02\x01\x12\x04\
    \xe2\x1e\x02\x1a\x1a\x1d\x20Delete\x20annotations\x20with\x20IDs\n\n\r\n\
    \x05\x04\x08\x02\x01\x04\x12\x04\xe2\x1e\x02\n\n\r\n\x05\x04\x08\x02\x01\
    \x05\x12\x04\xe2\x1e\x0b\x11\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xe2\
    \x1e\x12\x15\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xe2\x1e\x18\x19\n\xf0\
    \x02\n\x04\x04\x08\x02\x02\x12\x04\xea\x1e\x02\x20\x1a\xe1\x02\x20Delete\
    \x20annotations\x20for\x20these\x20Input\x20IDs\n\x20Note\x20that\x20'id\
    s'\x20are\x20optional\x20but\x20if\x20the\x20are\x20provided\x20the\x20n\
    umber\x20and\x20order\x20in\n\x20'ids'\x20and\x20'input_ids'\x20should\
    \x20match\n\x20If\x20you\x20do\x20not\x20specifiy\x20'ids'\x20all\x20the\
    \x20annotations\x20for\x20'input_ids'\x20are\x20deleted\n\x20However\x20\
    you\x20need\x20to\x20specify\x20at\x20least\x20one\x20value\x20for\x20'i\
    nput_ids'\n\x20i.e.\x20this\x20API\x20does\x20not\x20support\x20deleting\
    \x20all\x20annotations\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xea\x1e\
    \x02\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xea\x1e\x0b\x11\n\r\n\x05\
    \x04\x08\x02\x02\x01\x12\x04\xea\x1e\x12\x1b\n\r\n\x05\x04\x08\x02\x02\
    \x03\x12\x04\xea\x1e\x1e\x1f\n(\n\x02\x04\t\x12\x06\xee\x1e\0\xf1\x1e\
    \x01\x1a\x1a\x20SingleAnnotationResponse\n\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xee\x1e\x08\x20\n\x0c\n\x04\x04\t\x02\0\x12\x04\xef\x1e\x02(\n\r\n\x05\
    \x04\t\x02\0\x06\x12\x04\xef\x1e\x02\x1c\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xef\x1e\x1d#\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xef\x1e&'\n\x0c\n\
    \x04\x04\t\x02\x01\x12\x04\xf0\x1e\x02\x1c\n\r\n\x05\x04\t\x02\x01\x06\
    \x12\x04\xf0\x1e\x02\x0c\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xf0\x1e\r\
    \x17\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xf0\x1e\x1a\x1b\n'\n\x02\x04\n\
    \x12\x06\xf4\x1e\0\xf8\x1e\x01\x1a\x19\x20MultiAnnotationResponse\n\n\
    \x0b\n\x03\x04\n\x01\x12\x04\xf4\x1e\x08\x1f\n\x0c\n\x04\x04\n\x02\0\x12\
    \x04\xf5\x1e\x02(\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xf5\x1e\x02\x1c\n\r\
    \n\x05\x04\n\x02\0\x01\x12\x04\xf5\x1e\x1d#\n\r\n\x05\x04\n\x02\0\x03\
    \x12\x04\xf5\x1e&'\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xf7\x1e\x02U\n\r\n\
    \x05\x04\n\x02\x01\x04\x12\x04\xf7\x1e\x02\n\n\r\n\x05\x04\n\x02\x01\x06\
    \x12\x04\xf7\x1e\x0b\x15\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xf7\x1e\x16\
    !\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xf7\x1e$%\n\r\n\x05\x04\n\x02\x01\
    \x08\x12\x04\xf7\x1e&T\n\x10\n\x08\x04\n\x02\x01\x08\xd0\x86\x03\x12\x04\
    \xf7\x1e'S\n,\n\x02\x04\x0b\x12\x06\xfb\x1e\0\x8b\x1f\x01\x1a\x1e\x20Lis\
    tAnnotationWorkersRequest\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xfb\x1e\x08$\
    \n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xfc\x1e\x02,\n\r\n\x05\x04\x0b\x02\0\
    \x06\x12\x04\xfc\x1e\x02\x1b\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xfc\x1e\
    \x1c'\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xfc\x1e*+\n~\n\x04\x04\x0b\x02\
    \x01\x12\x04\x80\x1f\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20T\
    he\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\
    \x0b\x02\x01\x05\x12\x04\x80\x1f\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\x80\x1f\t\r\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x80\x1f\x10\
    \x11\nu\n\x04\x04\x0b\x02\x02\x12\x04\x83\x1f\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x83\x1f\x02\x08\n\r\n\x05\x04\x0b\
    \x02\x02\x01\x12\x04\x83\x1f\t\x11\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\
    \x83\x1f\x14\x15\n\x83\x01\n\x04\x04\x0b\x02\x03\x12\x04\x87\x1f\x02(\
    \x1au\x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20f\
    ields\x20to\x20be\x20included\x20in\x20the\x20response.\n\x20Currently\
    \x20supported:\x20all,\x20names\n\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\
    \x87\x1f\x02\n\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\x87\x1f\x0b\x11\n\r\
    \n\x05\x04\x0b\x02\x03\x01\x12\x04\x87\x1f\x12#\n\r\n\x05\x04\x0b\x02\
    \x03\x03\x12\x04\x87\x1f&'\na\n\x04\x04\x0b\x02\x04\x12\x04\x8a\x1f\x02\
    \x18\x1aS\x20(optional\x20URL\x20parameter)\x20Only\x20list\x20workers\
    \x20that\x20have\x20created\x20trusted\x20annotations.\n\n\r\n\x05\x04\
    \x0b\x02\x04\x05\x12\x04\x8a\x1f\x02\x06\n\r\n\x05\x04\x0b\x02\x04\x01\
    \x12\x04\x8a\x1f\x07\x13\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x8a\x1f\
    \x16\x17\n#\n\x02\x04\x0c\x12\x06\x8e\x1f\0\x92\x1f\x01\x1a\x15\x20Multi\
    WorkerResponse\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\x8e\x1f\x08\x1b\n\x0c\n\
    \x04\x04\x0c\x02\0\x12\x04\x8f\x1f\x02(\n\r\n\x05\x04\x0c\x02\0\x06\x12\
    \x04\x8f\x1f\x02\x1c\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x8f\x1f\x1d#\n\
    \r\n\x05\x04\x0c\x02\0\x03\x12\x04\x8f\x1f&'\n\x0c\n\x04\x04\x0c\x02\x01\
    \x12\x04\x91\x1f\x02M\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\x91\x1f\x02\
    \n\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\x91\x1f\x0b\x11\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\x91\x1f\x12\x19\n\r\n\x05\x04\x0c\x02\x01\x03\
    \x12\x04\x91\x1f\x1c\x1d\n\r\n\x05\x04\x0c\x02\x01\x08\x12\x04\x91\x1f\
    \x1eL\n\x10\n\x08\x04\x0c\x02\x01\x08\xd0\x86\x03\x12\x04\x91\x1f\x1fK\n\
    \x1d\n\x02\x04\r\x12\x06\x95\x1f\0\x99\x1f\x01\x1a\x0f\x20GetAppRequest\
    \n\n\x0b\n\x03\x04\r\x01\x12\x04\x95\x1f\x08\x15\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\x96\x1f\x02,\n\r\n\x05\x04\r\x02\0\x06\x12\x04\x96\x1f\x02\x1b\
    \n\r\n\x05\x04\r\x02\0\x01\x12\x04\x96\x1f\x1c'\n\r\n\x05\x04\r\x02\0\
    \x03\x12\x04\x96\x1f*+\n\x8a\x01\n\x04\x04\r\x02\x01\x12\x04\x98\x1f\x02\
    (\x1a|\x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20\
    fields\x20to\x20be\x20included\x20in\x20the\x20response.\x20Currently\
    \x20supported:\x20all,\x20stars,\x20counts\n\n\r\n\x05\x04\r\x02\x01\x04\
    \x12\x04\x98\x1f\x02\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x98\x1f\x0b\
    \x11\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x98\x1f\x12#\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\x98\x1f&'\n\x1f\n\x02\x04\x0e\x12\x06\x9c\x1f\0\xd7\
    \x1f\x01\x1a\x11\x20ListAppsRequest\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\
    \x9c\x1f\x08\x17\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x9d\x1f\x02,\n\r\n\
    \x05\x04\x0e\x02\0\x06\x12\x04\x9d\x1f\x02\x1b\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\x9d\x1f\x1c'\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9d\x1f*+\
    \n~\n\x04\x04\x0e\x02\x01\x12\x04\xa0\x1f\x02\x12\x1ap\x20(optional\x20U\
    RL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\
    \x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\
    \x201.\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xa0\x1f\x02\x08\n\r\n\x05\
    \x04\x0e\x02\x01\x01\x12\x04\xa0\x1f\t\r\n\r\n\x05\x04\x0e\x02\x01\x03\
    \x12\x04\xa0\x1f\x10\x11\nu\n\x04\x04\x0e\x02\x02\x12\x04\xa3\x1f\x02\
    \x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20re\
    sults\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defau\
    lts\n\x20to\x20128.\n\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xa3\x1f\x02\
    \x08\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xa3\x1f\t\x11\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\xa3\x1f\x14\x15\n\x8a\x01\n\x04\x04\x0e\x02\x03\
    \x12\x04\xa6\x1f\x02)\x1a|\x20(optional\x20URL\x20parameter)\x20List\x20\
    of\x20additional\x20fields\x20to\x20be\x20included\x20in\x20the\x20respo\
    nse.\x20Currently\x20supported:\x20all,\x20stars,\x20counts\n\n\r\n\x05\
    \x04\x0e\x02\x03\x04\x12\x04\xa6\x1f\x02\n\n\r\n\x05\x04\x0e\x02\x03\x05\
    \x12\x04\xa6\x1f\x0b\x11\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xa6\x1f\
    \x12#\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xa6\x1f&(\no\n\x04\x04\x0e\
    \x02\x04\x12\x04\xaa\x1f\x02\x1a\x1aa\x20Sorting\x20options:\n\x20Whethe\
    r\x20to\x20sort\x20in\x20ascending\x20order.\x20If\x20false,\x20will\x20\
    order\x20in\x20descending\x20order.\n\n\r\n\x05\x04\x0e\x02\x04\x05\x12\
    \x04\xaa\x1f\x02\x06\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xaa\x1f\x07\
    \x15\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xaa\x1f\x18\x19\n\x0e\n\x04\
    \x04\x0e\x08\0\x12\x06\xab\x1f\x02\xb5\x1f\x03\n\r\n\x05\x04\x0e\x08\0\
    \x01\x12\x04\xab\x1f\x08\x0f\n,\n\x04\x04\x0e\x02\x05\x12\x04\xad\x1f\
    \x04\x1a\x1a\x1e\x20Whether\x20to\x20order\x20by\x20the\x20name\n\n\r\n\
    \x05\x04\x0e\x02\x05\x05\x12\x04\xad\x1f\x04\x08\n\r\n\x05\x04\x0e\x02\
    \x05\x01\x12\x04\xad\x1f\t\x15\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\xad\
    \x1f\x18\x19\n\x80\x01\n\x04\x04\x0e\x02\x06\x12\x04\xb0\x1f\x04!\x1ar\
    \x20Whether\x20to\x20order\x20by\x20the\x20modified_at\x20time.\n\x20If\
    \x20none\x20of\x20the\x20sort\x20options\x20is\x20set\x20to\x20true,\x20\
    will\x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04\x0e\x02\x06\x05\x12\
    \x04\xb0\x1f\x04\x08\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\xb0\x1f\t\x1c\
    \n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xb0\x1f\x1f\x20\n8\n\x04\x04\x0e\
    \x02\x07\x12\x04\xb2\x1f\x04!\x1a*\x20Whether\x20to\x20order\x20by\x20th\
    e\x20created_at\x20time.\n\n\r\n\x05\x04\x0e\x02\x07\x05\x12\x04\xb2\x1f\
    \x04\x08\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xb2\x1f\t\x1b\n\r\n\x05\
    \x04\x0e\x02\x07\x03\x12\x04\xb2\x1f\x1e\x20\nF\n\x04\x04\x0e\x02\x08\
    \x12\x04\xb4\x1f\x04!\x1a8\x20Whether\x20to\x20order\x20by\x20the\x20num\
    ber\x20of\x20users\x20stared\x20the\x20app\n\n\r\n\x05\x04\x0e\x02\x08\
    \x05\x12\x04\xb4\x1f\x04\x08\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\xb4\
    \x1f\t\x1b\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\xb4\x1f\x1e\x20\nf\n\
    \x04\x04\x0e\x02\t\x12\x04\xb9\x1f\x02\x19\x1aX\x20Filtering\x20options:\
    \n\x20If\x20true,\x20we\x20only\x20return\x20apps\x20that\x20are\x20hand\
    picked\x20by\x20clarifai\x20staff\n\n\r\n\x05\x04\x0e\x02\t\x05\x12\x04\
    \xb9\x1f\x02\x06\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\xb9\x1f\x07\x14\n\r\
    \n\x05\x04\x0e\x02\t\x03\x12\x04\xb9\x1f\x17\x18\nT\n\x04\x04\x0e\x02\n\
    \x12\x04\xbb\x1f\x02\x19\x1aF\x20If\x20true,\x20we\x20only\x20return\x20\
    apps\x20that\x20are\x20starred\x20by\x20the\x20requesting\x20user\n\n\r\
    \n\x05\x04\x0e\x02\n\x05\x12\x04\xbb\x1f\x02\x06\n\r\n\x05\x04\x0e\x02\n\
    \x01\x12\x04\xbb\x1f\x07\x13\n\r\n\x05\x04\x0e\x02\n\x03\x12\x04\xbb\x1f\
    \x16\x18\n\\\n\x04\x04\x0e\x02\x0b\x12\x04\xbd\x1f\x02\x1a\x1aN\x20If\
    \x20true,\x20we\x20only\x20return\x20apps\x20that\x20are\x20marked\x20as\
    \x20a\x20template\x20by\x20the\x20app\x20owner.\n\n\r\n\x05\x04\x0e\x02\
    \x0b\x05\x12\x04\xbd\x1f\x02\x06\n\r\n\x05\x04\x0e\x02\x0b\x01\x12\x04\
    \xbd\x1f\x07\x14\n\r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\xbd\x1f\x17\x19\n\
    \xba\x04\n\x04\x04\x0e\x02\x0c\x12\x04\xcd\x1f\x02\x15\x1a\xab\x04\x20Se\
    arching\x20options:\n\x20Specify\x20a\x20search\x20parameter\x20in\x20or\
    der\x20to\x20perform\x20keyword\x20search\x20on\x20the\n\x20following\
    \x20fields\x20of\x20the\x20application:\n\x20\x20\x20-\x20id\n\x20\x20\
    \x20-\x20name\n\x20\x20\x20-\x20description\n\x20\x20\x20-\x20notes\n\
    \x20\x20\x20-\x20user_id\x20(unless\x20user_app_id.user_id\x20is\x20alre\
    ady\x20set)\n\n\x20Keywords\x20are\x20both\x20normalized\x20for\x20searc\
    h\x20(so\x20searching\x20for\x20\"satisfy\"\x20matches\x20\"satisfied\")\
    \n\x20and\x20used\x20for\x20partial\x20prefix-matching\x20(so\x20searchi\
    ng\x20for\x20\"clari\"\x20matches\x20\"clarifai\").\n\n\x20NOTE:\x20Both\
    \x20the\x20list\x20of\x20fields\x20searched\x20and\x20the\x20exact\x20ke\
    yword\x20matching\n\x20rules\x20are\x20subject\x20to\x20change\x20and\
    \x20not\x20guaranteed\x20to\x20be\x20backwards-compatible.\n\n\r\n\x05\
    \x04\x0e\x02\x0c\x05\x12\x04\xcd\x1f\x02\x08\n\r\n\x05\x04\x0e\x02\x0c\
    \x01\x12\x04\xcd\x1f\t\x0f\n\r\n\x05\x04\x0e\x02\x0c\x03\x12\x04\xcd\x1f\
    \x12\x14\n\x9d\x01\n\x04\x04\x0e\x02\r\x12\x04\xd0\x1f\x02'\x1a\x8e\x01\
    \x20Query\x20various\x20text\x20fields\x20(id,\x20name,\x20description,\
    \x20and\x20notes)\x20that\x20can\x20contain\x20the\x20words\x20in\x20the\
    \x20query\x20string\n\x20Deprecated:\x20use\x20search\x20instead.\n\n\r\
    \n\x05\x04\x0e\x02\r\x05\x12\x04\xd0\x1f\x02\x08\n\r\n\x05\x04\x0e\x02\r\
    \x01\x12\x04\xd0\x1f\t\x0e\n\r\n\x05\x04\x0e\x02\r\x03\x12\x04\xd0\x1f\
    \x11\x12\n\r\n\x05\x04\x0e\x02\r\x08\x12\x04\xd0\x1f\x13&\n\x0e\n\x06\
    \x04\x0e\x02\r\x08\x03\x12\x04\xd0\x1f\x14%\n\xaa\x01\n\x04\x04\x0e\x02\
    \x0e\x12\x04\xd3\x1f\x02&\x1a\x9b\x01\x20Filter\x20by\x20the\x20id,\x20n\
    ame\x20and\x20notes\x20of\x20the\x20app.\x20This\x20supports\x20wilcard\
    \x20queries\x20like\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20a\
    n\x20example.\n\x20Deprecated:\x20use\x20search\x20instead.\n\n\r\n\x05\
    \x04\x0e\x02\x0e\x05\x12\x04\xd3\x1f\x02\x08\n\r\n\x05\x04\x0e\x02\x0e\
    \x01\x12\x04\xd3\x1f\t\r\n\r\n\x05\x04\x0e\x02\x0e\x03\x12\x04\xd3\x1f\
    \x10\x11\n\r\n\x05\x04\x0e\x02\x0e\x08\x12\x04\xd3\x1f\x12%\n\x0e\n\x06\
    \x04\x0e\x02\x0e\x08\x03\x12\x04\xd3\x1f\x13$\n\xa6\x01\n\x04\x04\x0e\
    \x02\x0f\x12\x04\xd6\x1f\x02%\x1a\x97\x01\x20Filter\x20by\x20the\x20user\
    -unique-id\x20of\x20the\x20app.\x20This\x20supports\x20wilcard\x20querie\
    s\x20like\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20an\x20examp\
    le.\n\x20Deprecated:\x20use\x20search\x20instead.\n\n\r\n\x05\x04\x0e\
    \x02\x0f\x05\x12\x04\xd6\x1f\x02\x08\n\r\n\x05\x04\x0e\x02\x0f\x01\x12\
    \x04\xd6\x1f\t\x0b\n\r\n\x05\x04\x0e\x02\x0f\x03\x12\x04\xd6\x1f\x0e\x10\
    \n\r\n\x05\x04\x0e\x02\x0f\x08\x12\x04\xd6\x1f\x11$\n\x0e\n\x06\x04\x0e\
    \x02\x0f\x08\x03\x12\x04\xd6\x1f\x12#\n\x1f\n\x02\x04\x0f\x12\x06\xda\
    \x1f\0\xdd\x1f\x01\x1a\x11\x20PostAppsRequest\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xda\x1f\x08\x17\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xdb\x1f\x02,\
    \n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xdb\x1f\x02\x1b\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\xdb\x1f\x1c'\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xdb\
    \x1f*+\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xdc\x1f\x02\x18\n\r\n\x05\x04\
    \x0f\x02\x01\x04\x12\x04\xdc\x1f\x02\n\n\r\n\x05\x04\x0f\x02\x01\x06\x12\
    \x04\xdc\x1f\x0b\x0e\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xdc\x1f\x0f\
    \x13\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xdc\x1f\x16\x17\n\x20\n\x02\
    \x04\x10\x12\x06\xe0\x1f\0\xe2\x1f\x01\x1a\x12\x20DeleteAppRequest\n\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\xe0\x1f\x08\x18\n\x0c\n\x04\x04\x10\x02\0\
    \x12\x04\xe1\x1f\x02,\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xe1\x1f\x02\
    \x1b\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xe1\x1f\x1c'\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\xe1\x1f*+\n\x20\n\x02\x04\x11\x12\x06\xe5\x1f\0\xf5\
    \x1f\x01\x1a\x12\x20PatchAppsRequest\n\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xe5\x1f\x08\x18\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xe6\x1f\x02,\n\r\n\
    \x05\x04\x11\x02\0\x06\x12\x04\xe6\x1f\x02\x1b\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xe6\x1f\x1c'\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xe6\x1f*+\
    \n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xe7\x1f\x02\x18\n\r\n\x05\x04\x11\
    \x02\x01\x04\x12\x04\xe7\x1f\x02\n\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\
    \xe7\x1f\x0b\x0e\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe7\x1f\x0f\x13\n\
    \r\n\x05\x04\x11\x02\x01\x03\x12\x04\xe7\x1f\x16\x17\n\x93\x02\n\x04\x04\
    \x11\x02\x02\x12\x04\xee\x1f\x02\x14\x1a\x84\x02\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20App\x20objects\x20except\x20App.M\
    etadata\n\x20Supported\x20values:\x20'overwrite'\x20and\x20'remove'.\n\n\
    \x20Note\x20that\x20'remove'\x20can\x20only\x20be\x20used\x20to\x20remov\
    e\x20the\x20app\x20image\x20by\x20setting\n\x20'image.url'\x20in\x20the\
    \x20request\x20to\x20the\x20current\x20value\x20returned\x20for\x20that\
    \x20app.\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xee\x1f\x02\x08\n\r\n\
    \x05\x04\x11\x02\x02\x01\x12\x04\xee\x1f\t\x0f\n\r\n\x05\x04\x11\x02\x02\
    \x03\x12\x04\xee\x1f\x12\x13\nA\n\x04\x04\x11\x02\x03\x12\x04\xf1\x1f\
    \x02/\x1a3\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20\
    App.Metadata\n\n\r\n\x05\x04\x11\x02\x03\x06\x12\x04\xf1\x1f\x02\x1a\n\r\
    \n\x05\x04\x11\x02\x03\x01\x12\x04\xf1\x1f\x1b*\n\r\n\x05\x04\x11\x02\
    \x03\x03\x12\x04\xf1\x1f-.\na\n\x04\x04\x11\x02\x04\x12\x04\xf4\x1f\x02\
    \x13\x1aS\x20If\x20set,\x20the\x20app\x20will\x20be\x20automatically\x20\
    reindexed\x20upon\x20change\x20of\x20its\x20base\x20workflow.\n\n\r\n\
    \x05\x04\x11\x02\x04\x05\x12\x04\xf4\x1f\x02\x06\n\r\n\x05\x04\x11\x02\
    \x04\x01\x12\x04\xf4\x1f\x07\x0e\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\
    \xf4\x1f\x11\x12\n\x1f\n\x02\x04\x12\x12\x06\xf8\x1f\0\x88\x20\x01\x1a\
    \x11\x20PatchAppRequest\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xf8\x1f\x08\
    \x17\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xf9\x1f\x02,\n\r\n\x05\x04\x12\
    \x02\0\x06\x12\x04\xf9\x1f\x02\x1b\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xf9\x1f\x1c'\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xf9\x1f*+\n\x0c\n\x04\
    \x04\x12\x02\x01\x12\x04\xfa\x1f\x02\x0e\n\r\n\x05\x04\x12\x02\x01\x06\
    \x12\x04\xfa\x1f\x02\x05\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xfa\x1f\
    \x06\t\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xfa\x1f\x0c\r\n\x91\x02\n\
    \x04\x04\x12\x02\x02\x12\x04\x81\x20\x02\x14\x1a\x82\x02\x20The\x20actio\
    n\x20to\x20perform\x20on\x20the\x20patched\x20App\x20object\x20except\
    \x20App.Metadata\n\x20Supported\x20values:\x20'overwrite'\x20and\x20'rem\
    ove'.\n\n\x20Note\x20that\x20'remove'\x20can\x20only\x20be\x20used\x20to\
    \x20remove\x20the\x20app\x20image\x20by\x20setting\n\x20'image.url'\x20i\
    n\x20the\x20request\x20to\x20the\x20current\x20value\x20returned\x20for\
    \x20the\x20app.\n\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\x81\x20\x02\x08\
    \n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\x81\x20\t\x0f\n\r\n\x05\x04\x12\
    \x02\x02\x03\x12\x04\x81\x20\x12\x13\nA\n\x04\x04\x12\x02\x03\x12\x04\
    \x84\x20\x02/\x1a3\x20The\x20action\x20to\x20perform\x20on\x20the\x20pat\
    ched\x20App.Metadata\n\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\x84\x20\x02\
    \x1a\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\x84\x20\x1b*\n\r\n\x05\x04\
    \x12\x02\x03\x03\x12\x04\x84\x20-.\na\n\x04\x04\x12\x02\x04\x12\x04\x87\
    \x20\x02\x13\x1aS\x20If\x20set,\x20the\x20app\x20will\x20be\x20automatic\
    ally\x20reindexed\x20upon\x20change\x20of\x20its\x20base\x20workflow.\n\
    \n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\x87\x20\x02\x06\n\r\n\x05\x04\x12\
    \x02\x04\x01\x12\x04\x87\x20\x07\x0e\n\r\n\x05\x04\x12\x02\x04\x03\x12\
    \x04\x87\x20\x11\x12\n#\n\x02\x04\x13\x12\x06\x8c\x20\0\x95\x20\x01\x1a\
    \x15\x20PatchAppsIdsRequest\n\n\x0b\n\x03\x04\x13\x01\x12\x04\x8c\x20\
    \x08\x1b\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x8d\x20\x02,\n\r\n\x05\x04\
    \x13\x02\0\x06\x12\x04\x8d\x20\x02\x1b\n\r\n\x05\x04\x13\x02\0\x01\x12\
    \x04\x8d\x20\x1c'\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x8d\x20*+\n(\n\x04\
    \x04\x13\x02\x01\x12\x04\x90\x20\x02\"\x1a\x1a\x20Array\x20containing\
    \x201\x20entry\n\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\x90\x20\x02\n\n\r\
    \n\x05\x04\x13\x02\x01\x06\x12\x04\x90\x20\x0b\x19\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\x90\x20\x1a\x1d\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\
    \x90\x20\x20!\n[\n\x04\x04\x13\x02\x02\x12\x04\x94\x20\x02\x14\x1aM\x20T\
    he\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20On\
    ly\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\
    \x04\x94\x20\x02\x08\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\x94\x20\t\x0f\
    \n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x94\x20\x12\x13\n7\n\x02\x04\x14\
    \x12\x06\x98\x20\0\x9f\x20\x01\x1a)\x20Search\x20over\x20the\x20availabl\
    e\x20applications.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x98\x20\x08\x1f\n\
    \x0c\n\x04\x04\x14\x02\0\x12\x04\x99\x20\x02,\n\r\n\x05\x04\x14\x02\0\
    \x06\x12\x04\x99\x20\x02\x1b\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x99\x20\
    \x1c'\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x99\x20*+\n(\n\x04\x04\x14\x02\
    \x01\x12\x04\x9b\x20\x02\x19\x1a\x1a\x20The\x20body\x20of\x20the\x20requ\
    est.\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\x9b\x20\x02\n\n\r\n\x05\x04\
    \x14\x02\x01\x01\x12\x04\x9b\x20\x0b\x14\n\r\n\x05\x04\x14\x02\x01\x03\
    \x12\x04\x9b\x20\x17\x18\n]\n\x04\x04\x14\x02\x02\x12\x04\x9e\x20\x02\
    \x1c\x1aO\x20Pagination\x20parameters\x20here\x20since\x20there\x20are\
    \x20no\x20url\x20args\x20in\x20this\n\x20POST\x20request.\n\n\r\n\x05\
    \x04\x14\x02\x02\x06\x12\x04\x9e\x20\x02\x0c\n\r\n\x05\x04\x14\x02\x02\
    \x01\x12\x04\x9e\x20\r\x17\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x9e\x20\
    \x1a\x1b\n!\n\x02\x04\x15\x12\x06\xa2\x20\0\xa5\x20\x01\x1a\x13\x20Singl\
    eAppResponse\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xa2\x20\x08\x19\n\x0c\n\
    \x04\x04\x15\x02\0\x12\x04\xa3\x20\x02(\n\r\n\x05\x04\x15\x02\0\x06\x12\
    \x04\xa3\x20\x02\x1c\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xa3\x20\x1d#\n\
    \r\n\x05\x04\x15\x02\0\x03\x12\x04\xa3\x20&'\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\xa4\x20\x02\x0e\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\xa4\x20\
    \x02\x05\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xa4\x20\x06\t\n\r\n\x05\
    \x04\x15\x02\x01\x03\x12\x04\xa4\x20\x0c\r\n\x20\n\x02\x04\x16\x12\x06\
    \xa8\x20\0\xab\x20\x01\x1a\x12\x20MultiAppResponse\n\n\x0b\n\x03\x04\x16\
    \x01\x12\x04\xa8\x20\x08\x18\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xa9\x20\
    \x02(\n\r\n\x05\x04\x16\x02\0\x06\x12\x04\xa9\x20\x02\x1c\n\r\n\x05\x04\
    \x16\x02\0\x01\x12\x04\xa9\x20\x1d#\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\
    \xa9\x20&'\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xaa\x20\x02G\n\r\n\x05\
    \x04\x16\x02\x01\x04\x12\x04\xaa\x20\x02\n\n\r\n\x05\x04\x16\x02\x01\x06\
    \x12\x04\xaa\x20\x0b\x0e\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xaa\x20\
    \x0f\x13\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xaa\x20\x16\x17\n\r\n\x05\
    \x04\x16\x02\x01\x08\x12\x04\xaa\x20\x18F\n\x10\n\x08\x04\x16\x02\x01\
    \x08\xd0\x86\x03\x12\x04\xaa\x20\x19E\n(\n\x02\x04\x17\x12\x06\xae\x20\0\
    \xb9\x20\x01\x1a\x1a\x20ListCollaboratorsRequest\n\n\x0b\n\x03\x04\x17\
    \x01\x12\x04\xae\x20\x08\x20\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xaf\x20\
    \x02,\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xaf\x20\x02\x1b\n\r\n\x05\x04\
    \x17\x02\0\x01\x12\x04\xaf\x20\x1c'\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\
    \xaf\x20*+\n\x88\x01\n\x04\x04\x17\x02\x01\x12\x04\xb2\x20\x02\"\x1az\
    \x20Set\x20this\x20flag\x20to\x20list\x20both\x20deleted\x20and\x20not\
    \x20deleted\x20collaborators\n\x20by\x20default\x20it's\x20listing\x20on\
    ly\x20not\x20deleted\x20collaborators\n\n\r\n\x05\x04\x17\x02\x01\x05\
    \x12\x04\xb2\x20\x02\x06\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xb2\x20\
    \x07\x1d\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xb2\x20\x20!\n~\n\x04\x04\
    \x17\x02\x02\x12\x04\xb5\x20\x02\x12\x1ap\x20(optional\x20URL\x20paramet\
    er)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\
    \x05\x04\x17\x02\x02\x05\x12\x04\xb5\x20\x02\x08\n\r\n\x05\x04\x17\x02\
    \x02\x01\x12\x04\xb5\x20\t\r\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xb5\
    \x20\x10\x11\nu\n\x04\x04\x17\x02\x03\x12\x04\xb8\x20\x02\x16\x1ag\x20(o\
    ptional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xb8\x20\x02\x08\n\r\n\
    \x05\x04\x17\x02\x03\x01\x12\x04\xb8\x20\t\x11\n\r\n\x05\x04\x17\x02\x03\
    \x03\x12\x04\xb8\x20\x14\x15\n(\n\x02\x04\x18\x12\x06\xbc\x20\0\xbf\x20\
    \x01\x1a\x1a\x20PostCollaboratorsRequest\n\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xbc\x20\x08\x20\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xbd\x20\x02,\n\r\
    \n\x05\x04\x18\x02\0\x06\x12\x04\xbd\x20\x02\x1b\n\r\n\x05\x04\x18\x02\0\
    \x01\x12\x04\xbd\x20\x1c'\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xbd\x20*+\
    \n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xbe\x20\x02*\n\r\n\x05\x04\x18\x02\
    \x01\x04\x12\x04\xbe\x20\x02\n\n\r\n\x05\x04\x18\x02\x01\x06\x12\x04\xbe\
    \x20\x0b\x17\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xbe\x20\x18%\n\r\n\
    \x05\x04\x18\x02\x01\x03\x12\x04\xbe\x20()\n)\n\x02\x04\x19\x12\x06\xc2\
    \x20\0\xc9\x20\x01\x1a\x1b\x20PatchCollaboratorsRequest\n\n\x0b\n\x03\
    \x04\x19\x01\x12\x04\xc2\x20\x08!\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xc3\
    \x20\x02,\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xc3\x20\x02\x1b\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xc3\x20\x1c'\n\r\n\x05\x04\x19\x02\0\x03\x12\
    \x04\xc3\x20*+\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xc4\x20\x02*\n\r\n\
    \x05\x04\x19\x02\x01\x04\x12\x04\xc4\x20\x02\n\n\r\n\x05\x04\x19\x02\x01\
    \x06\x12\x04\xc4\x20\x0b\x17\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xc4\
    \x20\x18%\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xc4\x20()\nj\n\x04\x04\
    \x19\x02\x02\x12\x04\xc8\x20\x02\x14\x1a\\\x20The\x20action\x20to\x20per\
    form\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20only\x20actio\
    n\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\
    \x04\xc8\x20\x02\x08\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xc8\x20\t\x0f\
    \n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xc8\x20\x12\x13\n*\n\x02\x04\x1a\
    \x12\x06\xcc\x20\0\xd0\x20\x01\x1a\x1c\x20DeleteCollaboratorsRequest\n\n\
    \x0b\n\x03\x04\x1a\x01\x12\x04\xcc\x20\x08\"\n\x0c\n\x04\x04\x1a\x02\0\
    \x12\x04\xcd\x20\x02,\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xcd\x20\x02\
    \x1b\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xcd\x20\x1c'\n\r\n\x05\x04\x1a\
    \x02\0\x03\x12\x04\xcd\x20*+\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xce\x20\
    \x02'\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xce\x20\x02\n\n\r\n\x05\x04\
    \x1a\x02\x01\x05\x12\x04\xce\x20\x0b\x11\n\r\n\x05\x04\x1a\x02\x01\x01\
    \x12\x04\xce\x20\x12\"\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xce\x20%&\n\
    \x0c\n\x04\x04\x1a\x02\x02\x12\x04\xcf\x20\x02\"\n\r\n\x05\x04\x1a\x02\
    \x02\x04\x12\x04\xcf\x20\x02\n\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xcf\
    \x20\x0b\x11\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xcf\x20\x12\x1d\n\r\n\
    \x05\x04\x1a\x02\x02\x03\x12\x04\xcf\x20\x20!\n*\n\x02\x04\x1b\x12\x06\
    \xd3\x20\0\xe0\x20\x01\x1a\x1c\x20MultiCollaboratorsResponse\n\n\x0b\n\
    \x03\x04\x1b\x01\x12\x04\xd3\x20\x08\"\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\
    \xd4\x20\x02(\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xd4\x20\x02\x1c\n\r\n\
    \x05\x04\x1b\x02\0\x01\x12\x04\xd4\x20\x1d#\n\r\n\x05\x04\x1b\x02\0\x03\
    \x12\x04\xd4\x20&'\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xd5\x20\x02Y\n\r\
    \n\x05\x04\x1b\x02\x01\x04\x12\x04\xd5\x20\x02\n\n\r\n\x05\x04\x1b\x02\
    \x01\x06\x12\x04\xd5\x20\x0b\x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\
    \xd5\x20\x18%\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xd5\x20()\n\r\n\x05\
    \x04\x1b\x02\x01\x08\x12\x04\xd5\x20*X\n\x10\n\x08\x04\x1b\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xd5\x20+W\n\xe3\x02\n\x04\x04\x1b\x02\x02\x12\x04\
    \xdf\x20\x02\x15\x1a\xd4\x02\x20The\x20owner\x20of\x20the\x20application\
    .\n\n\x20When\x20listing\x20users\x20that\x20have\x20access\x20to\x20the\
    \x20application,\x20i.e.\x20collaborators,\n\x20it\x20is\x20often\x20rel\
    evant\x20to\x20also\x20include\x20the\x20application\x20owner,\x20so\x20\
    return\n\x20their\x20information\x20here\x20for\x20convenience.\n\n\x20N\
    ote:\x20app_owner\x20is\x20only\x20returned\x20by\x20ListCollaborators\
    \x20and\x20only\x20if\x20the\n\x20owner\x20is\x20a\x20regular\x20user,\
    \x20not\x20an\x20organization.\n\n\r\n\x05\x04\x1b\x02\x02\x06\x12\x04\
    \xdf\x20\x02\x06\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xdf\x20\x07\x10\n\
    \r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xdf\x20\x13\x14\n)\n\x02\x04\x1c\
    \x12\x06\xe3\x20\0\xef\x20\x01\x1a\x1b\x20ListCollaborationsRequest\n\n\
    \x0b\n\x03\x04\x1c\x01\x12\x04\xe3\x20\x08!\n\x0c\n\x04\x04\x1c\x02\0\
    \x12\x04\xe4\x20\x02,\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\xe4\x20\x02\
    \x1b\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xe4\x20\x1c'\n\r\n\x05\x04\x1c\
    \x02\0\x03\x12\x04\xe4\x20*+\n~\n\x04\x04\x1c\x02\x01\x12\x04\xe7\x20\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x1c\x02\x01\x05\
    \x12\x04\xe7\x20\x02\x08\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xe7\x20\t\
    \r\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xe7\x20\x10\x11\nu\n\x04\x04\
    \x1c\x02\x02\x12\x04\xea\x20\x02\x16\x1ag\x20(optional\x20URL\x20paramet\
    er)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\
    \x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x1c\
    \x02\x02\x05\x12\x04\xea\x20\x02\x08\n\r\n\x05\x04\x1c\x02\x02\x01\x12\
    \x04\xea\x20\t\x11\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xea\x20\x14\x15\
    \n\x82\x01\n\x04\x04\x1c\x02\x03\x12\x04\xee\x20\x02\x19\x1at\x20Filteri\
    ng\x20options:\n\x20If\x20true,\x20we\x20only\x20return\x20collaboration\
    s\x20on\x20apps\x20that\x20are\x20marked\x20as\x20a\x20template\x20by\
    \x20the\x20app\x20owner.\n\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xee\x20\
    \x02\x06\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xee\x20\x07\x14\n\r\n\x05\
    \x04\x1c\x02\x03\x03\x12\x04\xee\x20\x17\x18\n+\n\x02\x04\x1d\x12\x06\
    \xf2\x20\0\xf5\x20\x01\x1a\x1d\x20MultiCollaborationsResponse\n\n\x0b\n\
    \x03\x04\x1d\x01\x12\x04\xf2\x20\x08#\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\
    \xf3\x20\x02(\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xf3\x20\x02\x1c\n\r\n\
    \x05\x04\x1d\x02\0\x01\x12\x04\xf3\x20\x1d#\n\r\n\x05\x04\x1d\x02\0\x03\
    \x12\x04\xf3\x20&'\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xf4\x20\x02[\n\r\
    \n\x05\x04\x1d\x02\x01\x04\x12\x04\xf4\x20\x02\n\n\r\n\x05\x04\x1d\x02\
    \x01\x06\x12\x04\xf4\x20\x0b\x18\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\
    \xf4\x20\x19'\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xf4\x20*+\n\r\n\x05\
    \x04\x1d\x02\x01\x08\x12\x04\xf4\x20,Z\n\x10\n\x08\x04\x1d\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xf4\x20-Y\n$\n\x02\x04\x1e\x12\x06\x9f!\0\xa1!\x01\
    \x1a\x16\x20GetStatusCodeRequest\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\x9f!\
    \x08\x1c\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xa0!\x02\x1c\n\r\n\x05\x04\
    \x1e\x02\0\x05\x12\x04\xa0!\x02\x08\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\
    \xa0!\t\x17\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xa0!\x1a\x1b\n&\n\x02\
    \x04\x1f\x12\x06\xa4!\0\xa5!\x01\x1a\x18\x20ListStatusCodesRequest\n\n\
    \x0b\n\x03\x04\x1f\x01\x12\x04\xa4!\x08\x1e\n(\n\x02\x04\x20\x12\x06\xa8\
    !\0\xab!\x01\x1a\x1a\x20SingleStatusCodeResponse\n\n\x0b\n\x03\x04\x20\
    \x01\x12\x04\xa8!\x08\x20\n'\n\x04\x04\x20\x02\0\x12\x04\xaa!\x02(\x1a\
    \x19\x20Status\x20of\x20this\x20request.\n\n\r\n\x05\x04\x20\x02\0\x06\
    \x12\x04\xaa!\x02\x1c\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xaa!\x1d#\n\r\
    \n\x05\x04\x20\x02\0\x03\x12\x04\xaa!&'\n'\n\x02\x04!\x12\x06\xae!\0\xb1\
    !\x01\x1a\x19\x20MultiStatusCodeResponse\n\n\x0b\n\x03\x04!\x01\x12\x04\
    \xae!\x08\x1f\n\x0c\n\x04\x04!\x02\0\x12\x04\xaf!\x02(\n\r\n\x05\x04!\
    \x02\0\x06\x12\x04\xaf!\x02\x1c\n\r\n\x05\x04!\x02\0\x01\x12\x04\xaf!\
    \x1d#\n\r\n\x05\x04!\x02\0\x03\x12\x04\xaf!&'\n\x0c\n\x04\x04!\x02\x01\
    \x12\x04\xb0!\x023\n\r\n\x05\x04!\x02\x01\x04\x12\x04\xb0!\x02\n\n\r\n\
    \x05\x04!\x02\x01\x06\x12\x04\xb0!\x0b%\n\r\n\x05\x04!\x02\x01\x01\x12\
    \x04\xb0!&.\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xb0!12\n!\n\x02\x04\"\x12\
    \x06\xb4!\0\xb8!\x01\x1a\x13\x20GetConceptRequest\n\n\x0b\n\x03\x04\"\
    \x01\x12\x04\xb4!\x08\x19\n\x0c\n\x04\x04\"\x02\0\x12\x04\xb5!\x02,\n\r\
    \n\x05\x04\"\x02\0\x06\x12\x04\xb5!\x02\x1b\n\r\n\x05\x04\"\x02\0\x01\
    \x12\x04\xb5!\x1c'\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xb5!*+\n!\n\x04\x04\
    \"\x02\x01\x12\x04\xb7!\x02\x18\x1a\x13\x20The\x20concept's\x20id.\n\n\r\
    \n\x05\x04\"\x02\x01\x05\x12\x04\xb7!\x02\x08\n\r\n\x05\x04\"\x02\x01\
    \x01\x12\x04\xb7!\t\x13\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xb7!\x16\x17\
    \n#\n\x02\x04#\x12\x06\xbb!\0\xc5!\x01\x1a\x15\x20ListConceptsRequest\n\
    \n\x0b\n\x03\x04#\x01\x12\x04\xbb!\x08\x1b\n\x0c\n\x04\x04#\x02\0\x12\
    \x04\xbc!\x02,\n\r\n\x05\x04#\x02\0\x06\x12\x04\xbc!\x02\x1b\n\r\n\x05\
    \x04#\x02\0\x01\x12\x04\xbc!\x1c'\n\r\n\x05\x04#\x02\0\x03\x12\x04\xbc!*\
    +\n~\n\x04\x04#\x02\x01\x12\x04\xbf!\x02\x12\x1ap\x20(optional\x20URL\
    \x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20\
    to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x20\
    1.\n\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xbf!\x02\x08\n\r\n\x05\x04#\x02\
    \x01\x01\x12\x04\xbf!\t\r\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xbf!\x10\
    \x11\nu\n\x04\x04#\x02\x02\x12\x04\xc2!\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04#\x02\x02\x05\x12\x04\xc2!\x02\x08\n\r\n\x05\x04#\x02\x02\x01\
    \x12\x04\xc2!\t\x11\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xc2!\x14\x15\n)\n\
    \x04\x04#\x02\x03\x12\x04\xc4!\x02\x10\x1a\x1b\x20Fuzzy\x20match\x20on\
    \x20concept\x20ID\n\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xc4!\x02\x08\n\r\
    \n\x05\x04#\x02\x03\x01\x12\x04\xc4!\t\x0b\n\r\n\x05\x04#\x02\x03\x03\
    \x12\x04\xc4!\x0e\x0f\n(\n\x02\x04$\x12\x06\xc8!\0\xe1!\x01\x1a\x1a\x20L\
    istModelConceptsRequest\n\n\x0b\n\x03\x04$\x01\x12\x04\xc8!\x08\x20\n\
    \x0c\n\x04\x04$\x02\0\x12\x04\xc9!\x02,\n\r\n\x05\x04$\x02\0\x06\x12\x04\
    \xc9!\x02\x1b\n\r\n\x05\x04$\x02\0\x01\x12\x04\xc9!\x1c'\n\r\n\x05\x04$\
    \x02\0\x03\x12\x04\xc9!*+\n\x18\n\x04\x04$\x02\x01\x12\x04\xcb!\x02\x16\
    \x1a\n\x20Model\x20id\n\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xcb!\x02\x08\
    \n\r\n\x05\x04$\x02\x01\x01\x12\x04\xcb!\t\x11\n\r\n\x05\x04$\x02\x01\
    \x03\x12\x04\xcb!\x14\x15\nY\n\x04\x04$\x02\x02\x12\x04\xcd!\x02\x18\x1a\
    K\x20Model\x20version\x20Id.\x20Optional,\x20if\x20not\x20provided\x20la\
    test\x20model\x20version\x20is\x20used.\n\n\r\n\x05\x04$\x02\x02\x05\x12\
    \x04\xcd!\x02\x08\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xcd!\t\x13\n\r\n\
    \x05\x04$\x02\x02\x03\x12\x04\xcd!\x16\x17\n~\n\x04\x04$\x02\x03\x12\x04\
    \xd1!\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20n\
    umber.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20i\
    nto\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04$\x02\x03\x05\
    \x12\x04\xd1!\x02\x08\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xd1!\t\r\n\r\n\
    \x05\x04$\x02\x03\x03\x12\x04\xd1!\x10\x11\nu\n\x04\x04$\x02\x04\x12\x04\
    \xd4!\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\
    \x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20pa\
    ge.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04$\x02\x04\x05\x12\x04\xd4\
    !\x02\x08\n\r\n\x05\x04$\x02\x04\x01\x12\x04\xd4!\t\x11\n\r\n\x05\x04$\
    \x02\x04\x03\x12\x04\xd4!\x14\x15\n\x90\x03\n\x04\x04$\x02\x05\x12\x04\
    \xe0!\x02\x14\x1a\x81\x03\x20Searching\x20options:\n\x20Specify\x20a\x20\
    search\x20parameter\x20in\x20order\x20to\x20perform\x20keyword\x20search\
    \x20on\x20the\n\x20following\x20fields\x20of\x20the\x20concept:\n\x20\
    \x20\x20-\x20id\n\x20\x20\x20-\x20name\n\n\x20Keywords\x20are\x20used\
    \x20for\x20partial\x20prefix-matching\x20(so\x20searching\x20for\x20\"la\
    rif\"\x20matches\x20\"clarifai\").\n\n\x20NOTE:\x20Both\x20the\x20list\
    \x20of\x20fields\x20searched\x20and\x20the\x20exact\x20keyword\x20matchi\
    ng\n\x20rules\x20are\x20subject\x20to\x20change\x20and\x20not\x20guarant\
    eed\x20to\x20be\x20backwards-compatible.\n\n\r\n\x05\x04$\x02\x05\x05\
    \x12\x04\xe0!\x02\x08\n\r\n\x05\x04$\x02\x05\x01\x12\x04\xe0!\t\x0f\n\r\
    \n\x05\x04$\x02\x05\x03\x12\x04\xe0!\x12\x13\n+\n\x02\x04%\x12\x06\xe4!\
    \0\xf0!\x01\x1a\x1d\x20PostConceptsSearchesRequest\n\n\x0b\n\x03\x04%\
    \x01\x12\x04\xe4!\x08#\n6\n\x04\x04%\x02\0\x12\x04\xe6!\x02,\x1a(\x20Ids\
    \x20present\x20in\x20the\x20url\x20of\x20the\x20request.\n\n\r\n\x05\x04\
    %\x02\0\x06\x12\x04\xe6!\x02\x1b\n\r\n\x05\x04%\x02\0\x01\x12\x04\xe6!\
    \x1c'\n\r\n\x05\x04%\x02\0\x03\x12\x04\xe6!*+\n(\n\x04\x04%\x02\x01\x12\
    \x04\xe8!\x02!\x1a\x1a\x20The\x20body\x20of\x20the\x20request.\n\n\r\n\
    \x05\x04%\x02\x01\x06\x12\x04\xe8!\x02\x0e\n\r\n\x05\x04%\x02\x01\x01\
    \x12\x04\xe8!\x0f\x1c\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xe8!\x1f\x20\nY\
    \n\x04\x04%\x02\x02\x12\x04\xeb!\x02)\x1aK\x20Request\x20additional\x20i\
    nfo\x20to\x20be\x20retrieved\x20for\x20each\x20concept\x20in\x20the\x20r\
    esponse.\n\n\r\n\x05\x04%\x02\x02\x06\x12\x04\xeb!\x02\x19\n\r\n\x05\x04\
    %\x02\x02\x01\x12\x04\xeb!\x1a$\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xeb!'\
    (\n]\n\x04\x04%\x02\x03\x12\x04\xef!\x02\x1c\x1aO\x20Pagination\x20param\
    eters\x20here\x20since\x20there\x20are\x20no\x20url\x20args\x20in\x20thi\
    s\n\x20POST\x20request.\n\n\r\n\x05\x04%\x02\x03\x06\x12\x04\xef!\x02\
    \x0c\n\r\n\x05\x04%\x02\x03\x01\x12\x04\xef!\r\x17\n\r\n\x05\x04%\x02\
    \x03\x03\x12\x04\xef!\x1a\x1b\n\x0c\n\x02\x04&\x12\x06\xf2!\0\xfb!\x01\n\
    \x0b\n\x03\x04&\x01\x12\x04\xf2!\x08\x1f\n\xd8\x01\n\x04\x04&\x02\0\x12\
    \x04\xfa!\x02\x1b\x1a\xc9\x01\x20Determine\x20if\x20the\x20concept\x20is\
    \x20searchable\x20by\x20rank\x20using\x20this\x20model.\n\x20Currently,\
    \x20only\x20embedder\x20models\x20are\x20supported.\n\x20##########\x20S\
    upported\x20fields\x20##########\n\x20-\x20app_id\n\x20-\x20id\n\x20-\
    \x20model_version.id\n\x20-\x20user_id\n\n\r\n\x05\x04&\x02\0\x06\x12\
    \x04\xfa!\x02\x07\n\r\n\x05\x04&\x02\0\x01\x12\x04\xfa!\x08\x16\n\r\n\
    \x05\x04&\x02\0\x03\x12\x04\xfa!\x19\x1a\n#\n\x02\x04'\x12\x06\xfe!\0\
    \x82\"\x01\x1a\x15\x20PostConceptsRequest\n\n\x0b\n\x03\x04'\x01\x12\x04\
    \xfe!\x08\x1b\n\x0c\n\x04\x04'\x02\0\x12\x04\xff!\x02,\n\r\n\x05\x04'\
    \x02\0\x06\x12\x04\xff!\x02\x1b\n\r\n\x05\x04'\x02\0\x01\x12\x04\xff!\
    \x1c'\n\r\n\x05\x04'\x02\0\x03\x12\x04\xff!*+\n$\n\x04\x04'\x02\x01\x12\
    \x04\x81\"\x02\x20\x1a\x16\x20The\x20concepts\x20to\x20add.\n\n\r\n\x05\
    \x04'\x02\x01\x04\x12\x04\x81\"\x02\n\n\r\n\x05\x04'\x02\x01\x06\x12\x04\
    \x81\"\x0b\x12\n\r\n\x05\x04'\x02\x01\x01\x12\x04\x81\"\x13\x1b\n\r\n\
    \x05\x04'\x02\x01\x03\x12\x04\x81\"\x1e\x1f\n$\n\x02\x04(\x12\x06\x85\"\
    \0\x8d\"\x01\x1a\x16\x20PatchConceptsRequest\n\n\x0b\n\x03\x04(\x01\x12\
    \x04\x85\"\x08\x1c\n\x0c\n\x04\x04(\x02\0\x12\x04\x86\"\x02,\n\r\n\x05\
    \x04(\x02\0\x06\x12\x04\x86\"\x02\x1b\n\r\n\x05\x04(\x02\0\x01\x12\x04\
    \x86\"\x1c'\n\r\n\x05\x04(\x02\0\x03\x12\x04\x86\"*+\n&\n\x04\x04(\x02\
    \x01\x12\x04\x88\"\x02\x20\x1a\x18\x20The\x20concepts\x20to\x20patch.\n\
    \n\r\n\x05\x04(\x02\x01\x04\x12\x04\x88\"\x02\n\n\r\n\x05\x04(\x02\x01\
    \x06\x12\x04\x88\"\x0b\x12\n\r\n\x05\x04(\x02\x01\x01\x12\x04\x88\"\x13\
    \x1b\n\r\n\x05\x04(\x02\x01\x03\x12\x04\x88\"\x1e\x1f\ni\n\x04\x04(\x02\
    \x02\x12\x04\x8c\"\x02\x14\x1a[\x20The\x20action\x20to\x20perform\x20on\
    \x20the\x20patched\x20objects\n\x20For\x20now\x20ony\x20action\x20'overw\
    rite'\x20is\x20supported\n\n\r\n\x05\x04(\x02\x02\x05\x12\x04\x8c\"\x02\
    \x08\n\r\n\x05\x04(\x02\x02\x01\x12\x04\x8c\"\t\x0f\n\r\n\x05\x04(\x02\
    \x02\x03\x12\x04\x8c\"\x12\x13\n'\n\x02\x04)\x12\x06\x90\"\0\x98\"\x01\
    \x1a\x19\x20GetConceptCountsRequest\n\n\x0b\n\x03\x04)\x01\x12\x04\x90\"\
    \x08\x1f\n\x0c\n\x04\x04)\x02\0\x12\x04\x91\"\x02,\n\r\n\x05\x04)\x02\0\
    \x06\x12\x04\x91\"\x02\x1b\n\r\n\x05\x04)\x02\0\x01\x12\x04\x91\"\x1c'\n\
    \r\n\x05\x04)\x02\0\x03\x12\x04\x91\"*+\n~\n\x04\x04)\x02\x01\x12\x04\
    \x94\"\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20\
    number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20\
    into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04)\x02\x01\x05\
    \x12\x04\x94\"\x02\x08\n\r\n\x05\x04)\x02\x01\x01\x12\x04\x94\"\t\r\n\r\
    \n\x05\x04)\x02\x01\x03\x12\x04\x94\"\x10\x11\nu\n\x04\x04)\x02\x02\x12\
    \x04\x97\"\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20numb\
    er\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20\
    page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04)\x02\x02\x05\x12\x04\
    \x97\"\x02\x08\n\r\n\x05\x04)\x02\x02\x01\x12\x04\x97\"\t\x11\n\r\n\x05\
    \x04)\x02\x02\x03\x12\x04\x97\"\x14\x15\n%\n\x02\x04*\x12\x06\x9b\"\0\
    \xa0\"\x01\x1a\x17\x20SingleConceptResponse\n\n\x0b\n\x03\x04*\x01\x12\
    \x04\x9b\"\x08\x1d\n$\n\x04\x04*\x02\0\x12\x04\x9d\"\x02(\x1a\x16\x20The\
    \x20response\x20status.\n\n\r\n\x05\x04*\x02\0\x06\x12\x04\x9d\"\x02\x1c\
    \n\r\n\x05\x04*\x02\0\x01\x12\x04\x9d\"\x1d#\n\r\n\x05\x04*\x02\0\x03\
    \x12\x04\x9d\"&'\n%\n\x04\x04*\x02\x01\x12\x04\x9f\"\x02\x16\x1a\x17\x20\
    The\x20returned\x20concept.\n\n\r\n\x05\x04*\x02\x01\x06\x12\x04\x9f\"\
    \x02\t\n\r\n\x05\x04*\x02\x01\x01\x12\x04\x9f\"\n\x11\n\r\n\x05\x04*\x02\
    \x01\x03\x12\x04\x9f\"\x14\x15\n$\n\x02\x04+\x12\x06\xa3\"\0\xa8\"\x01\
    \x1a\x16\x20MultiConceptResponse\n\n\x0b\n\x03\x04+\x01\x12\x04\xa3\"\
    \x08\x1c\n$\n\x04\x04+\x02\0\x12\x04\xa5\"\x02(\x1a\x16\x20The\x20respon\
    se\x20status.\n\n\r\n\x05\x04+\x02\0\x06\x12\x04\xa5\"\x02\x1c\n\r\n\x05\
    \x04+\x02\0\x01\x12\x04\xa5\"\x1d#\n\r\n\x05\x04+\x02\0\x03\x12\x04\xa5\
    \"&'\n&\n\x04\x04+\x02\x01\x12\x04\xa7\"\x02O\x1a\x18\x20The\x20returned\
    \x20concepts.\n\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xa7\"\x02\n\n\r\n\x05\
    \x04+\x02\x01\x06\x12\x04\xa7\"\x0b\x12\n\r\n\x05\x04+\x02\x01\x01\x12\
    \x04\xa7\"\x13\x1b\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xa7\"\x1e\x1f\n\r\
    \n\x05\x04+\x02\x01\x08\x12\x04\xa7\"\x20N\n\x10\n\x08\x04+\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xa7\"!M\n)\n\x02\x04,\x12\x06\xab\"\0\xb0\"\x01\x1a\
    \x1b\x20MultiConceptCountResponse\n\n\x0b\n\x03\x04,\x01\x12\x04\xab\"\
    \x08!\n$\n\x04\x04,\x02\0\x12\x04\xad\"\x02(\x1a\x16\x20The\x20response\
    \x20status.\n\n\r\n\x05\x04,\x02\0\x06\x12\x04\xad\"\x02\x1c\n\r\n\x05\
    \x04,\x02\0\x01\x12\x04\xad\"\x1d#\n\r\n\x05\x04,\x02\0\x03\x12\x04\xad\
    \"&'\n,\n\x04\x04,\x02\x01\x12\x04\xaf\"\x02Z\x1a\x1e\x20The\x20returned\
    \x20concept\x20counts.\n\n\r\n\x05\x04,\x02\x01\x04\x12\x04\xaf\"\x02\n\
    \n\r\n\x05\x04,\x02\x01\x06\x12\x04\xaf\"\x0b\x17\n\r\n\x05\x04,\x02\x01\
    \x01\x12\x04\xaf\"\x18&\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xaf\")*\n\r\n\
    \x05\x04,\x02\x01\x08\x12\x04\xaf\"+Y\n\x10\n\x08\x04,\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xaf\",X\n`\n\x02\x04-\x12\x06\xb3\"\0\xdb\"\x01\x1aR\
    \x20GET\x20all\x20relations\x20such\x20that\x20the\x20concept_id\x20refe\
    rs\x20to\x20the\x20subject\x20of\x20the\x20relation\n\n\x0b\n\x03\x04-\
    \x01\x12\x04\xb3\"\x08#\n3\n\x04\x04-\x02\0\x12\x04\xb5\"\x02,\x1a%\x20T\
    he\x20user_id\x20and\x20app_id\x20information.\n\n\r\n\x05\x04-\x02\0\
    \x06\x12\x04\xb5\"\x02\x1b\n\r\n\x05\x04-\x02\0\x01\x12\x04\xb5\"\x1c'\n\
    \r\n\x05\x04-\x02\0\x03\x12\x04\xb5\"*+\n\xb9\x07\n\x04\x04-\x02\x01\x12\
    \x04\xc5\"\x02\x18\x1a\xaa\x07\x20The\x20subject\x20concept\x20id\x20in\
    \x20your\x20app\x20to\x20get\x20all\x20the\x20relationships\x20for.\n\
    \x20Leave\x20as\x20an\x20empty\x20string\x20(GET\x20/concepts/relations)\
    \x20to\x20list\x20ALL\x20the\x20relations\x20in\x20the\x20app.\n\n\x20Wh\
    en\x20listing\x20all\x20the\x20relations\x20it\x20will\x20only\x20return\
    \x20one\x20direction\x20of\x20the\x20relationship\n\x20with\x20the\x20pr\
    edicate\x20acting\x20on\x20the\x20subject\x20and\x20not\x20the\x20invers\
    e\x20like\x20is\x20done\x20when\x20providing\x20a\n\x20concept_id\x20so\
    \x20that\x20we\x20can\x20return\x20a\x20reliable\x20page\x20size\x20alwa\
    ys.\n\n\x20When\x20providing\x20a\x20concept_id,\x20if\x20a\x20hyponym\
    \x20is\x20present\x20in\x20the\x20DB\x20such\x20as:\n\x20'honey'\x20(sub\
    ject),\x20'hyponym'\x20(predicate\x20for\x20\"is\x20a\x20kind\x20of\"),\
    \x20'food'\x20(object)\n\x20then\x20you\x20can\x20list\x20the\x20concept\
    \x20relations\x20for\x20'honey'\x20and\x20get\x20hyponym\x20predicate\
    \x20with\x20'food'\n\x20object.\n\x20But\x20you\x20can\x20also\x20list\
    \x20the\x20concept\x20relations\x20for\x20'food'\x20and\x20it\x20will\
    \x20return\x20the\x20same\x20hyponym\n\x20relationship\x20with\x20'honey\
    '\x20as\x20object\x20and\x20'hypernym'\x20as\x20predicate.\n\x20Synonyms\
    \x20by\x20nature\x20are\x20symmetrical\x20relationships\x20so\x20either\
    \x20side\x20can\x20be\x20the\x20concept_id\x20(subject)\n\x20when\x20lis\
    ting\x20the\x20relations.\n\n\r\n\x05\x04-\x02\x01\x05\x12\x04\xc5\"\x02\
    \x08\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xc5\"\t\x13\n\r\n\x05\x04-\x02\
    \x01\x03\x12\x04\xc5\"\x16\x17\n\xed\x02\n\x04\x04-\x02\x02\x12\x04\xd0\
    \"\x02\x17\x1a\xde\x02\x20If\x20predicate\x20is\x20provided\x20then\x20o\
    nly\x20list\x20relations\x20with\x20that\x20predicate.\n\n\x20Note\x20th\
    at\x20if\x20no\x20subject\x20is\x20set\x20in\x20concept_id\x20and\x20pre\
    dicate\x20is\x20set\x20to\n\x20'hypernym',\x20then\x20it\x20will\x20retu\
    rn\x20any\x20stored\x20hyponyms\x20as\x20hypernyms\x20with\n\x20just\x20\
    the\x20subject\x20and\x20object\x20swapped\x20since\x20they\x20are\x20re\
    versed\x20relations.\n\n\x20Valid\x20predicates\x20are:\n\x20-\x20'hyper\
    nym'\n\x20-\x20'hyponym'\n\x20-\x20'synonym'\n\n\r\n\x05\x04-\x02\x02\
    \x05\x12\x04\xd0\"\x02\x08\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xd0\"\t\
    \x12\n\r\n\x05\x04-\x02\x02\x03\x12\x04\xd0\"\x15\x16\n\x8b\x02\n\x04\
    \x04-\x02\x03\x12\x04\xd4\"\x02\x20\x1a\xfc\x01\x20If\x20knowledge_graph\
    _id\x20is\x20provided\x20then\x20just\x20list\x20relations\x20from\x20th\
    at\x20knowledge\x20graph.\n\x20If\x20not\x20provided\x20then\x20list\x20\
    relations\x20from\x20all\x20knowledge\x20graphs\x20including\x20the\x20g\
    lobal\x20one\x20for\x20this\n\x20app\x20one\x20(ie.\x20knowledge_graph\
    \x20\"\")\x20and\x20any\x20specific\x20ones\x20in\x20the\x20app.\n\n\r\n\
    \x05\x04-\x02\x03\x05\x12\x04\xd4\"\x02\x08\n\r\n\x05\x04-\x02\x03\x01\
    \x12\x04\xd4\"\t\x1b\n\r\n\x05\x04-\x02\x03\x03\x12\x04\xd4\"\x1e\x1f\n~\
    \n\x04\x04-\x02\x04\x12\x04\xd7\"\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04-\x02\x04\x05\x12\x04\xd7\"\x02\x08\n\r\n\x05\x04-\x02\x04\
    \x01\x12\x04\xd7\"\t\r\n\r\n\x05\x04-\x02\x04\x03\x12\x04\xd7\"\x10\x11\
    \nu\n\x04\x04-\x02\x05\x12\x04\xda\"\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04-\x02\x05\x05\x12\x04\xda\"\x02\x08\n\r\n\x05\x04-\x02\x05\x01\
    \x12\x04\xda\"\t\x11\n\r\n\x05\x04-\x02\x05\x03\x12\x04\xda\"\x14\x15\n*\
    \n\x02\x04.\x12\x06\xde\"\0\xe5\"\x01\x1a\x1c\x20POST\x20new\x20concept\
    \x20relations\n\n\x0b\n\x03\x04.\x01\x12\x04\xde\"\x08#\n3\n\x04\x04.\
    \x02\0\x12\x04\xe0\"\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20inf\
    ormation.\n\n\r\n\x05\x04.\x02\0\x06\x12\x04\xe0\"\x02\x1b\n\r\n\x05\x04\
    .\x02\0\x01\x12\x04\xe0\"\x1c'\n\r\n\x05\x04.\x02\0\x03\x12\x04\xe0\"*+\
    \nI\n\x04\x04.\x02\x01\x12\x04\xe2\"\x02\x18\x1a;\x20The\x20subject\x20c\
    oncept\x20id\x20you're\x20going\x20to\x20add\x20relations\x20for.\n\n\r\
    \n\x05\x04.\x02\x01\x05\x12\x04\xe2\"\x02\x08\n\r\n\x05\x04.\x02\x01\x01\
    \x12\x04\xe2\"\t\x13\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xe2\"\x16\x17\n6\
    \n\x04\x04.\x02\x02\x12\x04\xe4\"\x021\x1a(\x20The\x20relationships\x20y\
    ou're\x20going\x20to\x20add.\n\n\r\n\x05\x04.\x02\x02\x04\x12\x04\xe4\"\
    \x02\n\n\r\n\x05\x04.\x02\x02\x06\x12\x04\xe4\"\x0b\x1a\n\r\n\x05\x04.\
    \x02\x02\x01\x12\x04\xe4\"\x1b,\n\r\n\x05\x04.\x02\x02\x03\x12\x04\xe4\"\
    /0\n(\n\x02\x04/\x12\x06\xe8\"\0\xef\"\x01\x1a\x1a\x20DELETE\x20concept\
    \x20relations\n\n\x0b\n\x03\x04/\x01\x12\x04\xe8\"\x08%\n3\n\x04\x04/\
    \x02\0\x12\x04\xea\"\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20inf\
    ormation.\n\n\r\n\x05\x04/\x02\0\x06\x12\x04\xea\"\x02\x1b\n\r\n\x05\x04\
    /\x02\0\x01\x12\x04\xea\"\x1c'\n\r\n\x05\x04/\x02\0\x03\x12\x04\xea\"*+\
    \n7\n\x04\x04/\x02\x01\x12\x04\xec\"\x02\x18\x1a)\x20The\x20concept\x20t\
    o\x20delete\x20relationship\x20for.\n\n\r\n\x05\x04/\x02\x01\x05\x12\x04\
    \xec\"\x02\x08\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xec\"\t\x13\n\r\n\x05\
    \x04/\x02\x01\x03\x12\x04\xec\"\x16\x17\n7\n\x04\x04/\x02\x02\x12\x04\
    \xee\"\x02\x1a\x1a)\x20The\x20concept\x20relationship\x20ids\x20to\x20de\
    lete.\n\n\r\n\x05\x04/\x02\x02\x04\x12\x04\xee\"\x02\n\n\r\n\x05\x04/\
    \x02\x02\x05\x12\x04\xee\"\x0b\x11\n\r\n\x05\x04/\x02\x02\x01\x12\x04\
    \xee\"\x12\x15\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xee\"\x18\x19\n(\n\x02\
    \x040\x12\x06\xf2\"\0\xf5\"\x01\x1a\x1a\x20GET\x20all\x20knowledge\x20gr\
    aphs\n\n\x0b\n\x03\x040\x01\x12\x04\xf2\"\x08\"\n3\n\x04\x040\x02\0\x12\
    \x04\xf4\"\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20information.\
    \n\n\r\n\x05\x040\x02\0\x06\x12\x04\xf4\"\x02\x1b\n\r\n\x05\x040\x02\0\
    \x01\x12\x04\xf4\"\x1c'\n\r\n\x05\x040\x02\0\x03\x12\x04\xf4\"*+\n)\n\
    \x02\x041\x12\x06\xf8\"\0\xfc\"\x01\x1a\x1b\x20POST\x20new\x20knowledge\
    \x20graphs\n\n\x0b\n\x03\x041\x01\x12\x04\xf8\"\x08\"\n3\n\x04\x041\x02\
    \0\x12\x04\xfa\"\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20informa\
    tion.\n\n\r\n\x05\x041\x02\0\x06\x12\x04\xfa\"\x02\x1b\n\r\n\x05\x041\
    \x02\0\x01\x12\x04\xfa\"\x1c'\n\r\n\x05\x041\x02\0\x03\x12\x04\xfa\"*+\n\
    \x0c\n\x04\x041\x02\x01\x12\x04\xfb\"\x02/\n\r\n\x05\x041\x02\x01\x04\
    \x12\x04\xfb\"\x02\n\n\r\n\x05\x041\x02\x01\x06\x12\x04\xfb\"\x0b\x19\n\
    \r\n\x05\x041\x02\x01\x01\x12\x04\xfb\"\x1a*\n\r\n\x05\x041\x02\x01\x03\
    \x12\x04\xfb\"-.\n*\n\x02\x042\x12\x06\x81#\0\x86#\x01\x1a\x1c\x20Start\
    \x20concept\x20mapping\x20jobs\n\n\x0b\n\x03\x042\x01\x12\x04\x81#\x08%\
    \n3\n\x04\x042\x02\0\x12\x04\x83#\x02,\x1a%\x20The\x20user_id\x20and\x20\
    app_id\x20information.\n\n\r\n\x05\x042\x02\0\x06\x12\x04\x83#\x02\x1b\n\
    \r\n\x05\x042\x02\0\x01\x12\x04\x83#\x1c'\n\r\n\x05\x042\x02\0\x03\x12\
    \x04\x83#*+\n?\n\x04\x042\x02\x01\x12\x04\x85#\x026\x1a1\x20The\x20conce\
    pt\x20mapping\x20jobs\x20that\x20are\x20being\x20started\n\n\r\n\x05\x04\
    2\x02\x01\x04\x12\x04\x85#\x02\n\n\r\n\x05\x042\x02\x01\x06\x12\x04\x85#\
    \x0b\x1c\n\r\n\x05\x042\x02\x01\x01\x12\x04\x85#\x1d1\n\r\n\x05\x042\x02\
    \x01\x03\x12\x04\x85#45\n,\n\x02\x043\x12\x06\x8a#\0\x8f#\x01\x1a\x1e\
    \x20MultiConceptRelationResponse\n\n\x0b\n\x03\x043\x01\x12\x04\x8a#\x08\
    $\n$\n\x04\x043\x02\0\x12\x04\x8c#\x02(\x1a\x16\x20The\x20response\x20st\
    atus.\n\n\r\n\x05\x043\x02\0\x06\x12\x04\x8c#\x02\x1c\n\r\n\x05\x043\x02\
    \0\x01\x12\x04\x8c#\x1d#\n\r\n\x05\x043\x02\0\x03\x12\x04\x8c#&'\n/\n\
    \x04\x043\x02\x01\x12\x04\x8e#\x02`\x1a!\x20The\x20returned\x20concept\
    \x20relations.\n\n\r\n\x05\x043\x02\x01\x04\x12\x04\x8e#\x02\n\n\r\n\x05\
    \x043\x02\x01\x06\x12\x04\x8e#\x0b\x1a\n\r\n\x05\x043\x02\x01\x01\x12\
    \x04\x8e#\x1b,\n\r\n\x05\x043\x02\x01\x03\x12\x04\x8e#/0\n\r\n\x05\x043\
    \x02\x01\x08\x12\x04\x8e#1_\n\x10\n\x08\x043\x02\x01\x08\xd0\x86\x03\x12\
    \x04\x8e#2^\n+\n\x02\x044\x12\x06\x93#\0\x98#\x01\x1a\x1d\x20MultiKnowle\
    dgeGraphResponse\n\n\x0b\n\x03\x044\x01\x12\x04\x93#\x08#\n$\n\x04\x044\
    \x02\0\x12\x04\x95#\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\
    \x05\x044\x02\0\x06\x12\x04\x95#\x02\x1c\n\r\n\x05\x044\x02\0\x01\x12\
    \x04\x95#\x1d#\n\r\n\x05\x044\x02\0\x03\x12\x04\x95#&'\n.\n\x04\x044\x02\
    \x01\x12\x04\x97#\x02^\x1a\x20\x20The\x20returned\x20knowledge\x20graphs\
    .\n\n\r\n\x05\x044\x02\x01\x04\x12\x04\x97#\x02\n\n\r\n\x05\x044\x02\x01\
    \x06\x12\x04\x97#\x0b\x19\n\r\n\x05\x044\x02\x01\x01\x12\x04\x97#\x1a*\n\
    \r\n\x05\x044\x02\x01\x03\x12\x04\x97#-.\n\r\n\x05\x044\x02\x01\x08\x12\
    \x04\x97#/]\n\x10\n\x08\x044\x02\x01\x08\xd0\x86\x03\x12\x04\x97#0\\\n.\
    \n\x02\x045\x12\x06\x9e#\0\xa3#\x01\x1a\x20\x20MultiConceptMappingJobRes\
    ponse\n\n\x0b\n\x03\x045\x01\x12\x04\x9e#\x08&\n$\n\x04\x045\x02\0\x12\
    \x04\xa0#\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\x05\x045\
    \x02\0\x06\x12\x04\xa0#\x02\x1c\n\r\n\x05\x045\x02\0\x01\x12\x04\xa0#\
    \x1d#\n\r\n\x05\x045\x02\0\x03\x12\x04\xa0#&'\n=\n\x04\x045\x02\x01\x12\
    \x04\xa2#\x02\x1a\x1a/\x20The\x20ids\x20of\x20the\x20concept\x20mapping\
    \x20jobs\x20underway.\n\n\r\n\x05\x045\x02\x01\x04\x12\x04\xa2#\x02\n\n\
    \r\n\x05\x045\x02\x01\x05\x12\x04\xa2#\x0b\x11\n\r\n\x05\x045\x02\x01\
    \x01\x12\x04\xa2#\x12\x15\n\r\n\x05\x045\x02\x01\x03\x12\x04\xa2#\x18\
    \x19\nB\n\x02\x046\x12\x06\xa6#\0\xab#\x01\x1a4\x20GET\x20single\x20conc\
    ept\x20language\x20for\x20the\x20given\x20concept.\n\n\x0b\n\x03\x046\
    \x01\x12\x04\xa6#\x08!\n\x0c\n\x04\x046\x02\0\x12\x04\xa7#\x02,\n\r\n\
    \x05\x046\x02\0\x06\x12\x04\xa7#\x02\x1b\n\r\n\x05\x046\x02\0\x01\x12\
    \x04\xa7#\x1c'\n\r\n\x05\x046\x02\0\x03\x12\x04\xa7#*+\n\x0c\n\x04\x046\
    \x02\x01\x12\x04\xa8#\x02\x18\n\r\n\x05\x046\x02\x01\x05\x12\x04\xa8#\
    \x02\x08\n\r\n\x05\x046\x02\x01\x01\x12\x04\xa8#\t\x13\n\r\n\x05\x046\
    \x02\x01\x03\x12\x04\xa8#\x16\x17\n0\n\x04\x046\x02\x02\x12\x04\xaa#\x02\
    \x16\x1a\"\x20This\x20is\x20the\x20language\x20identifier.\n\n\r\n\x05\
    \x046\x02\x02\x05\x12\x04\xaa#\x02\x08\n\r\n\x05\x046\x02\x02\x01\x12\
    \x04\xaa#\t\x11\n\r\n\x05\x046\x02\x02\x03\x12\x04\xaa#\x14\x15\nF\n\x02\
    \x047\x12\x06\xae#\0\xb7#\x01\x1a8\x20List\x20multiple\x20concept\x20lan\
    guages\x20for\x20the\x20given\x20concept.\n\n\x0b\n\x03\x047\x01\x12\x04\
    \xae#\x08#\n\x0c\n\x04\x047\x02\0\x12\x04\xaf#\x02,\n\r\n\x05\x047\x02\0\
    \x06\x12\x04\xaf#\x02\x1b\n\r\n\x05\x047\x02\0\x01\x12\x04\xaf#\x1c'\n\r\
    \n\x05\x047\x02\0\x03\x12\x04\xaf#*+\n\x0c\n\x04\x047\x02\x01\x12\x04\
    \xb0#\x02\x18\n\r\n\x05\x047\x02\x01\x05\x12\x04\xb0#\x02\x08\n\r\n\x05\
    \x047\x02\x01\x01\x12\x04\xb0#\t\x13\n\r\n\x05\x047\x02\x01\x03\x12\x04\
    \xb0#\x16\x17\n~\n\x04\x047\x02\x02\x12\x04\xb3#\x02\x12\x1ap\x20(option\
    al\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\
    \x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaul\
    ts\x20to\x201.\n\n\r\n\x05\x047\x02\x02\x05\x12\x04\xb3#\x02\x08\n\r\n\
    \x05\x047\x02\x02\x01\x12\x04\xb3#\t\r\n\r\n\x05\x047\x02\x02\x03\x12\
    \x04\xb3#\x10\x11\nu\n\x04\x047\x02\x03\x12\x04\xb6#\x02\x16\x1ag\x20(op\
    tional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x047\x02\x03\x05\x12\x04\xb6#\x02\x08\n\r\n\x05\x04\
    7\x02\x03\x01\x12\x04\xb6#\t\x11\n\r\n\x05\x047\x02\x03\x03\x12\x04\xb6#\
    \x14\x15\nG\n\x02\x048\x12\x06\xba#\0\xc0#\x01\x1a9\x20PATCH\x20multiple\
    \x20concept\x20languages\x20for\x20the\x20given\x20concept.\n\n\x0b\n\
    \x03\x048\x01\x12\x04\xba#\x08$\n\x0c\n\x04\x048\x02\0\x12\x04\xbb#\x02,\
    \n\r\n\x05\x048\x02\0\x06\x12\x04\xbb#\x02\x1b\n\r\n\x05\x048\x02\0\x01\
    \x12\x04\xbb#\x1c'\n\r\n\x05\x048\x02\0\x03\x12\x04\xbb#*+\n\x0c\n\x04\
    \x048\x02\x01\x12\x04\xbc#\x02\x18\n\r\n\x05\x048\x02\x01\x05\x12\x04\
    \xbc#\x02\x08\n\r\n\x05\x048\x02\x01\x01\x12\x04\xbc#\t\x13\n\r\n\x05\
    \x048\x02\x01\x03\x12\x04\xbc#\x16\x17\n\x0c\n\x04\x048\x02\x02\x12\x04\
    \xbd#\x021\n\r\n\x05\x048\x02\x02\x04\x12\x04\xbd#\x02\n\n\r\n\x05\x048\
    \x02\x02\x06\x12\x04\xbd#\x0b\x1a\n\r\n\x05\x048\x02\x02\x01\x12\x04\xbd\
    #\x1b,\n\r\n\x05\x048\x02\x02\x03\x12\x04\xbd#/0\nD\n\x04\x048\x02\x03\
    \x12\x04\xbf#\x02\x14\x1a6\x20The\x20action\x20to\x20perform\x20with\x20\
    the\x20objects\x20in\x20the\x20PATCH.\n\n\r\n\x05\x048\x02\x03\x05\x12\
    \x04\xbf#\x02\x08\n\r\n\x05\x048\x02\x03\x01\x12\x04\xbf#\t\x0f\n\r\n\
    \x05\x048\x02\x03\x03\x12\x04\xbf#\x12\x13\n\xb9\x04\n\x02\x049\x12\x06\
    \xd6#\0\xda#\x01\x1a8\x20POST\x20multiple\x20concept\x20languages\x20for\
    \x20the\x20given\x20concept.\n2\xeb\x01\x20//\x20DELETE\x20multiple\x20c\
    oncept\x20languages\x20for\x20the\x20given\x20concept.\n\x20message\x20D\
    eleteConceptLanguageRequest\x20{\n\x20\x20\x20clarifai.api.UserAppIDSet\
    \x20user_app_id\x20=\x201;\n\x20\x20\x20string\x20concept_id\x20=\x202;\
    \n\x20\x20\x20//\x20The\x20language\x20code\x20to\x20delete.\n\x20\x20\
    \x20string\x20language\x20=\x203;\n\x20}\n2\x82\x02\x20//\x20DELETE\x20m\
    ultiple\x20concept\x20languages\x20for\x20the\x20given\x20concept.\n\x20\
    message\x20DeleteConceptLanguagesRequest\x20{\n\x20\x20\x20clarifai.api.\
    UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20string\x20concept_id\
    \x20=\x202;\n\x20\x20\x20//\x20The\x20language\x20code(s)\x20to\x20delet\
    e.\n\x20\x20\x20string\x20ids\x20=\x203;\n\x20\x20\x20bool\x20delete_all\
    \x20=\x204;\n\x20}\n\n\x0b\n\x03\x049\x01\x12\x04\xd6#\x08#\n\x0c\n\x04\
    \x049\x02\0\x12\x04\xd7#\x02,\n\r\n\x05\x049\x02\0\x06\x12\x04\xd7#\x02\
    \x1b\n\r\n\x05\x049\x02\0\x01\x12\x04\xd7#\x1c'\n\r\n\x05\x049\x02\0\x03\
    \x12\x04\xd7#*+\n\x0c\n\x04\x049\x02\x01\x12\x04\xd8#\x02\x18\n\r\n\x05\
    \x049\x02\x01\x05\x12\x04\xd8#\x02\x08\n\r\n\x05\x049\x02\x01\x01\x12\
    \x04\xd8#\t\x13\n\r\n\x05\x049\x02\x01\x03\x12\x04\xd8#\x16\x17\n\x0c\n\
    \x04\x049\x02\x02\x12\x04\xd9#\x021\n\r\n\x05\x049\x02\x02\x04\x12\x04\
    \xd9#\x02\n\n\r\n\x05\x049\x02\x02\x06\x12\x04\xd9#\x0b\x1a\n\r\n\x05\
    \x049\x02\x02\x01\x12\x04\xd9#\x1b,\n\r\n\x05\x049\x02\x02\x03\x12\x04\
    \xd9#/0\n-\n\x02\x04:\x12\x06\xdd#\0\xe0#\x01\x1a\x1f\x20SingleConceptLa\
    nguageResponse\n\n\x0b\n\x03\x04:\x01\x12\x04\xdd#\x08%\n\x0c\n\x04\x04:\
    \x02\0\x12\x04\xde#\x02(\n\r\n\x05\x04:\x02\0\x06\x12\x04\xde#\x02\x1c\n\
    \r\n\x05\x04:\x02\0\x01\x12\x04\xde#\x1d#\n\r\n\x05\x04:\x02\0\x03\x12\
    \x04\xde#&'\n\x0c\n\x04\x04:\x02\x01\x12\x04\xdf#\x02'\n\r\n\x05\x04:\
    \x02\x01\x06\x12\x04\xdf#\x02\x11\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xdf\
    #\x12\"\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xdf#%&\n,\n\x02\x04;\x12\x06\
    \xe3#\0\xe6#\x01\x1a\x1e\x20MultiConceptLanguageResponse\n\n\x0b\n\x03\
    \x04;\x01\x12\x04\xe3#\x08$\n\x0c\n\x04\x04;\x02\0\x12\x04\xe4#\x02(\n\r\
    \n\x05\x04;\x02\0\x06\x12\x04\xe4#\x02\x1c\n\r\n\x05\x04;\x02\0\x01\x12\
    \x04\xe4#\x1d#\n\r\n\x05\x04;\x02\0\x03\x12\x04\xe4#&'\n\x0c\n\x04\x04;\
    \x02\x01\x12\x04\xe5#\x02`\n\r\n\x05\x04;\x02\x01\x04\x12\x04\xe5#\x02\n\
    \n\r\n\x05\x04;\x02\x01\x06\x12\x04\xe5#\x0b\x1a\n\r\n\x05\x04;\x02\x01\
    \x01\x12\x04\xe5#\x1b,\n\r\n\x05\x04;\x02\x01\x03\x12\x04\xe5#/0\n\r\n\
    \x05\x04;\x02\x01\x08\x12\x04\xe5#1_\n\x10\n\x08\x04;\x02\x01\x08\xd0\
    \x86\x03\x12\x04\xe5#2^\n\x1f\n\x02\x04<\x12\x06\xee#\0\xf1#\x01\x1a\x11\
    \x20GetInputRequest\n\n\x0b\n\x03\x04<\x01\x12\x04\xee#\x08\x17\n\x0c\n\
    \x04\x04<\x02\0\x12\x04\xef#\x02,\n\r\n\x05\x04<\x02\0\x06\x12\x04\xef#\
    \x02\x1b\n\r\n\x05\x04<\x02\0\x01\x12\x04\xef#\x1c'\n\r\n\x05\x04<\x02\0\
    \x03\x12\x04\xef#*+\n\x0c\n\x04\x04<\x02\x01\x12\x04\xf0#\x02\x16\n\r\n\
    \x05\x04<\x02\x01\x05\x12\x04\xf0#\x02\x08\n\r\n\x05\x04<\x02\x01\x01\
    \x12\x04\xf0#\t\x11\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xf0#\x14\x15\n\
    \x0c\n\x02\x04=\x12\x06\xf2#\0\xf5#\x01\n\x0b\n\x03\x04=\x01\x12\x04\xf2\
    #\x08\x1f\n\x0c\n\x04\x04=\x02\0\x12\x04\xf3#\x02,\n\r\n\x05\x04=\x02\0\
    \x06\x12\x04\xf3#\x02\x1b\n\r\n\x05\x04=\x02\0\x01\x12\x04\xf3#\x1c'\n\r\
    \n\x05\x04=\x02\0\x03\x12\x04\xf3#*+\n\x0c\n\x04\x04=\x02\x01\x12\x04\
    \xf4#\x02\x16\n\r\n\x05\x04=\x02\x01\x05\x12\x04\xf4#\x02\x08\n\r\n\x05\
    \x04=\x02\x01\x01\x12\x04\xf4#\t\x11\n\r\n\x05\x04=\x02\x01\x03\x12\x04\
    \xf4#\x14\x15\n&\n\x02\x04>\x12\x06\xf8#\0\xfd#\x01\x1a\x18\x20GetInputS\
    amplesRequest\n\n\x0b\n\x03\x04>\x01\x12\x04\xf8#\x08\x1e\n\x0c\n\x04\
    \x04>\x02\0\x12\x04\xf9#\x02,\n\r\n\x05\x04>\x02\0\x06\x12\x04\xf9#\x02\
    \x1b\n\r\n\x05\x04>\x02\0\x01\x12\x04\xf9#\x1c'\n\r\n\x05\x04>\x02\0\x03\
    \x12\x04\xf9#*+\n\x0c\n\x04\x04>\x02\x01\x12\x04\xfa#\x02\x15\n\r\n\x05\
    \x04>\x02\x01\x05\x12\x04\xfa#\x02\x08\n\r\n\x05\x04>\x02\x01\x01\x12\
    \x04\xfa#\t\x10\n\r\n\x05\x04>\x02\x01\x03\x12\x04\xfa#\x13\x14\nN\n\x04\
    \x04>\x02\x02\x12\x04\xfc#\x02\x1f\x1a@\x20URL\x20param.\x20If\x20zero\
    \x20ids\x20provided,\x20returns\x20for\x20all\x20task\x20labelers\n\n\r\
    \n\x05\x04>\x02\x02\x04\x12\x04\xfc#\x02\n\n\r\n\x05\x04>\x02\x02\x05\
    \x12\x04\xfc#\x0b\x11\n\r\n\x05\x04>\x02\x02\x01\x12\x04\xfc#\x12\x1a\n\
    \r\n\x05\x04>\x02\x02\x03\x12\x04\xfc#\x1d\x1e\n!\n\x02\x04?\x12\x06\x80\
    $\0\x8d$\x01\x1a\x13\x20ListInputsRequest\n\n\x0b\n\x03\x04?\x01\x12\x04\
    \x80$\x08\x19\n\x0c\n\x04\x04?\x02\0\x12\x04\x81$\x02,\n\r\n\x05\x04?\
    \x02\0\x06\x12\x04\x81$\x02\x1b\n\r\n\x05\x04?\x02\0\x01\x12\x04\x81$\
    \x1c'\n\r\n\x05\x04?\x02\0\x03\x12\x04\x81$*+\n~\n\x04\x04?\x02\x01\x12\
    \x04\x84$\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04?\x02\x01\
    \x05\x12\x04\x84$\x02\x08\n\r\n\x05\x04?\x02\x01\x01\x12\x04\x84$\t\r\n\
    \r\n\x05\x04?\x02\x01\x03\x12\x04\x84$\x10\x11\nu\n\x04\x04?\x02\x02\x12\
    \x04\x87$\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20numbe\
    r\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20p\
    age.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04?\x02\x02\x05\x12\x04\
    \x87$\x02\x08\n\r\n\x05\x04?\x02\x02\x01\x12\x04\x87$\t\x11\n\r\n\x05\
    \x04?\x02\x02\x03\x12\x04\x87$\x14\x15\n.\n\x04\x04?\x02\x03\x12\x04\x8a\
    $\x02(\x1a\x20\x20Set\x20status\x20to\x20filter\x20by\x20status\n\n\r\n\
    \x05\x04?\x02\x03\x06\x12\x04\x8a$\x02\x1c\n\r\n\x05\x04?\x02\x03\x01\
    \x12\x04\x8a$\x1d#\n\r\n\x05\x04?\x02\x03\x03\x12\x04\x8a$&'\n\x0c\n\x04\
    \x04?\x02\x04\x12\x04\x8c$\x02\x1a\n\r\n\x05\x04?\x02\x04\x04\x12\x04\
    \x8c$\x02\n\n\r\n\x05\x04?\x02\x04\x05\x12\x04\x8c$\x0b\x11\n\r\n\x05\
    \x04?\x02\x04\x01\x12\x04\x8c$\x12\x15\n\r\n\x05\x04?\x02\x04\x03\x12\
    \x04\x8c$\x18\x19\n#\n\x02\x04@\x12\x06\x90$\0\x9b$\x01\x1a\x15\x20Strea\
    mInputsRequest\n\n\x0b\n\x03\x04@\x01\x12\x04\x90$\x08\x1b\n\x0c\n\x04\
    \x04@\x02\0\x12\x04\x91$\x02,\n\r\n\x05\x04@\x02\0\x06\x12\x04\x91$\x02\
    \x1b\n\r\n\x05\x04@\x02\0\x01\x12\x04\x91$\x1c'\n\r\n\x05\x04@\x02\0\x03\
    \x12\x04\x91$*+\nt\n\x04\x04@\x02\x01\x12\x04\x94$\x02\x16\x1af\x20(opti\
    onal\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20w\
    ill\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x2020.\
    \n\n\r\n\x05\x04@\x02\x01\x05\x12\x04\x94$\x02\x08\n\r\n\x05\x04@\x02\
    \x01\x01\x12\x04\x94$\t\x11\n\r\n\x05\x04@\x02\x01\x03\x12\x04\x94$\x14\
    \x15\n\x0c\n\x04\x04@\x02\x02\x12\x04\x95$\x02\x15\n\r\n\x05\x04@\x02\
    \x02\x05\x12\x04\x95$\x02\x08\n\r\n\x05\x04@\x02\x02\x01\x12\x04\x95$\t\
    \x10\n\r\n\x05\x04@\x02\x02\x03\x12\x04\x95$\x13\x14\n\x8a\x01\n\x04\x04\
    @\x02\x03\x12\x04\x99$\x02\x17\x1a|\x20By\x20default,\x20the\x20endpoint\
    \x20return\x20inputs\x20by\x20the\x20time\x20when\x20it\x20is\x20added.\
    \n\x20If\x20this\x20is\x20set\x20to\x20true,\x20we\x20will\x20return\x20\
    inputs\x20by\x20id.\n\n\r\n\x05\x04@\x02\x03\x05\x12\x04\x99$\x02\x06\n\
    \r\n\x05\x04@\x02\x03\x01\x12\x04\x99$\x07\x12\n\r\n\x05\x04@\x02\x03\
    \x03\x12\x04\x99$\x15\x16\n\x0c\n\x04\x04@\x02\x04\x12\x04\x9a$\x02\x16\
    \n\r\n\x05\x04@\x02\x04\x05\x12\x04\x9a$\x02\x06\n\r\n\x05\x04@\x02\x04\
    \x01\x12\x04\x9a$\x07\x11\n\r\n\x05\x04@\x02\x04\x03\x12\x04\x9a$\x14\
    \x15\n!\n\x02\x04A\x12\x06\x9e$\0\xb0$\x01\x1a\x13\x20PostInputsRequest\
    \n\n\x0b\n\x03\x04A\x01\x12\x04\x9e$\x08\x19\n\x0c\n\x04\x04A\x02\0\x12\
    \x04\x9f$\x02,\n\r\n\x05\x04A\x02\0\x06\x12\x04\x9f$\x02\x1b\n\r\n\x05\
    \x04A\x02\0\x01\x12\x04\x9f$\x1c'\n\r\n\x05\x04A\x02\0\x03\x12\x04\x9f$*\
    +\nt\n\x04\x04A\x02\x01\x12\x04\xa6$\x02\x1c\x1af\x20List\x20of\x20input\
    s\x20to\x20post.\n\x20For\x20each\x20input,\x20the\x20following\x20field\
    s\x20are\x20used:\n\x20*\x20id\n\x20*\x20data\n\x20*\x20dataset_ids\n\n\
    \r\n\x05\x04A\x02\x01\x04\x12\x04\xa6$\x02\n\n\r\n\x05\x04A\x02\x01\x06\
    \x12\x04\xa6$\x0b\x10\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xa6$\x11\x17\n\
    \r\n\x05\x04A\x02\x01\x03\x12\x04\xa6$\x1a\x1b\n\xc9\x02\n\x04\x04A\x02\
    \x02\x12\x04\xac$\x02\x1f\x1a\xba\x02\x20Collect\x20statistics\x20about\
    \x20created\x20inputs\x20in\x20job\x20with\x20given\x20ID.\n\x20*\x20If\
    \x20job\x20ID\x20is\x20empty,\x20then\x20job\x20is\x20not\x20created.\n\
    \x20*\x20If\x20job\x20ID\x20is\x20non-empty\x20and\x20doesn't\x20already\
    \x20exist,\x20then\x20a\x20new\x20job\x20will\x20be\x20created\x20with\
    \x20given\x20ID.\n\x20*\x20If\x20job\x20ID\x20does\x20already\x20exist,\
    \x20then\x20new\x20inputs\x20statistics\x20are\x20merged\x20with\x20prev\
    ious\x20inputs\x20statistics.\n\n\r\n\x05\x04A\x02\x02\x05\x12\x04\xac$\
    \x02\x08\n\r\n\x05\x04A\x02\x02\x01\x12\x04\xac$\t\x1a\n\r\n\x05\x04A\
    \x02\x02\x03\x12\x04\xac$\x1d\x1e\n1\n\x04\x04A\x02\x03\x12\x04\xaf$\x02\
    =\x1a#\x20How\x20to\x20handle\x20input\x20ID\x20conflicts.\n\n\r\n\x05\
    \x04A\x02\x03\x06\x12\x04\xaf$\x02\x1b\n\r\n\x05\x04A\x02\x03\x01\x12\
    \x04\xaf$\x1c8\n\r\n\x05\x04A\x02\x03\x03\x12\x04\xaf$;<\n\"\n\x02\x04B\
    \x12\x06\xb6$\0\xc2$\x01\x1a\x14\x20PatchInputsRequest\n\n\x0b\n\x03\x04\
    B\x01\x12\x04\xb6$\x08\x1a\n\x0c\n\x04\x04B\x02\0\x12\x04\xb7$\x02,\n\r\
    \n\x05\x04B\x02\0\x06\x12\x04\xb7$\x02\x1b\n\r\n\x05\x04B\x02\0\x01\x12\
    \x04\xb7$\x1c'\n\r\n\x05\x04B\x02\0\x03\x12\x04\xb7$*+\n\x89\x01\n\x04\
    \x04B\x02\x01\x12\x04\xbd$\x02\x1c\x1a{\x20List\x20of\x20inputs\x20to\
    \x20patch.\n\x20Inputs\x20are\x20identified\x20by\x20id\x20field.\n\x20F\
    or\x20each\x20input,\x20the\x20following\x20fields\x20are\x20patchable:\
    \n\x20*\x20data\n\n\r\n\x05\x04B\x02\x01\x04\x12\x04\xbd$\x02\n\n\r\n\
    \x05\x04B\x02\x01\x06\x12\x04\xbd$\x0b\x10\n\r\n\x05\x04B\x02\x01\x01\
    \x12\x04\xbd$\x11\x17\n\r\n\x05\x04B\x02\x01\x03\x12\x04\xbd$\x1a\x1b\n~\
    \n\x04\x04B\x02\x02\x12\x04\xc1$\x02\x14\x1ap\x20The\x20action\x20to\x20\
    perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\
    \x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\
    \r\n\x05\x04B\x02\x02\x05\x12\x04\xc1$\x02\x08\n\r\n\x05\x04B\x02\x02\
    \x01\x12\x04\xc1$\t\x0f\n\r\n\x05\x04B\x02\x02\x03\x12\x04\xc1$\x12\x13\
    \n\"\n\x02\x04C\x12\x06\xc5$\0\xc8$\x01\x1a\x14\x20DeleteInputRequest\n\
    \n\x0b\n\x03\x04C\x01\x12\x04\xc5$\x08\x1a\n\x0c\n\x04\x04C\x02\0\x12\
    \x04\xc6$\x02,\n\r\n\x05\x04C\x02\0\x06\x12\x04\xc6$\x02\x1b\n\r\n\x05\
    \x04C\x02\0\x01\x12\x04\xc6$\x1c'\n\r\n\x05\x04C\x02\0\x03\x12\x04\xc6$*\
    +\n\x0c\n\x04\x04C\x02\x01\x12\x04\xc7$\x02\x16\n\r\n\x05\x04C\x02\x01\
    \x05\x12\x04\xc7$\x02\x08\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xc7$\t\x11\
    \n\r\n\x05\x04C\x02\x01\x03\x12\x04\xc7$\x14\x15\nD\n\x02\x04D\x12\x06\
    \xcb$\0\xd0$\x01\x1a6\x20Request\x20to\x20delete\x20several\x20things\
    \x20by\x20the\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04D\x01\x12\x04\xcb$\
    \x08\x1b\n\x0b\n\x03\x04D\t\x12\x04\xcc$\x02\r\n\x0c\n\x04\x04D\t\0\x12\
    \x04\xcc$\x0b\x0c\n\r\n\x05\x04D\t\0\x01\x12\x04\xcc$\x0b\x0c\n\r\n\x05\
    \x04D\t\0\x02\x12\x04\xcc$\x0b\x0c\n\x0c\n\x04\x04D\x02\0\x12\x04\xce$\
    \x02,\n\r\n\x05\x04D\x02\0\x06\x12\x04\xce$\x02\x1b\n\r\n\x05\x04D\x02\0\
    \x01\x12\x04\xce$\x1c'\n\r\n\x05\x04D\x02\0\x03\x12\x04\xce$*+\n\x0c\n\
    \x04\x04D\x02\x01\x12\x04\xcf$\x02\x1a\n\r\n\x05\x04D\x02\x01\x04\x12\
    \x04\xcf$\x02\n\n\r\n\x05\x04D\x02\x01\x05\x12\x04\xcf$\x0b\x11\n\r\n\
    \x05\x04D\x02\x01\x01\x12\x04\xcf$\x12\x15\n\r\n\x05\x04D\x02\x01\x03\
    \x12\x04\xcf$\x18\x19\n#\n\x02\x04E\x12\x06\xd3$\0\xd6$\x01\x1a\x15\x20S\
    ingleInputResponse\n\n\x0b\n\x03\x04E\x01\x12\x04\xd3$\x08\x1b\n\x0c\n\
    \x04\x04E\x02\0\x12\x04\xd4$\x02(\n\r\n\x05\x04E\x02\0\x06\x12\x04\xd4$\
    \x02\x1c\n\r\n\x05\x04E\x02\0\x01\x12\x04\xd4$\x1d#\n\r\n\x05\x04E\x02\0\
    \x03\x12\x04\xd4$&'\n\x0c\n\x04\x04E\x02\x01\x12\x04\xd5$\x02\x12\n\r\n\
    \x05\x04E\x02\x01\x06\x12\x04\xd5$\x02\x07\n\r\n\x05\x04E\x02\x01\x01\
    \x12\x04\xd5$\x08\r\n\r\n\x05\x04E\x02\x01\x03\x12\x04\xd5$\x10\x11\n\
    \x0c\n\x02\x04F\x12\x06\xd8$\0\xdf$\x01\n\x0b\n\x03\x04F\x01\x12\x04\xd8\
    $\x08\x20\n\x0c\n\x04\x04F\x02\0\x12\x04\xd9$\x02(\n\r\n\x05\x04F\x02\0\
    \x06\x12\x04\xd9$\x02\x1c\n\r\n\x05\x04F\x02\0\x01\x12\x04\xd9$\x1d#\n\r\
    \n\x05\x04F\x02\0\x03\x12\x04\xd9$&'\n\x95\x01\n\x04\x04F\x02\x01\x12\
    \x04\xde$\x02\x1a\x1a\x86\x01\x20MPEG-dash\x20manifest\x20as\x20data-URI\
    ,\x20base64-encoded\n\x20Can\x20be\x20empty\x20if\x20status\x20is\x20FAI\
    LED\n\x20Can\x20be\x20fallback\x20manifest\x20if\x20status\x20is\x20MIXE\
    D_STATUS\n\n\r\n\x05\x04F\x02\x01\x05\x12\x04\xde$\x02\x08\n\r\n\x05\x04\
    F\x02\x01\x01\x12\x04\xde$\t\x15\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xde$\
    \x18\x19\n\"\n\x02\x04G\x12\x06\xe2$\0\xe8$\x01\x1a\x14\x20MultiInputRes\
    ponse\n\n\x0b\n\x03\x04G\x01\x12\x04\xe2$\x08\x1a\n\x0c\n\x04\x04G\x02\0\
    \x12\x04\xe4$\x02(\n\r\n\x05\x04G\x02\0\x06\x12\x04\xe4$\x02\x1c\n\r\n\
    \x05\x04G\x02\0\x01\x12\x04\xe4$\x1d#\n\r\n\x05\x04G\x02\0\x03\x12\x04\
    \xe4$&'\n\x0c\n\x04\x04G\x02\x01\x12\x04\xe5$\x02K\n\r\n\x05\x04G\x02\
    \x01\x04\x12\x04\xe5$\x02\n\n\r\n\x05\x04G\x02\x01\x06\x12\x04\xe5$\x0b\
    \x10\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xe5$\x11\x17\n\r\n\x05\x04G\x02\
    \x01\x03\x12\x04\xe5$\x1a\x1b\n\r\n\x05\x04G\x02\x01\x08\x12\x04\xe5$\
    \x1cJ\n\x10\n\x08\x04G\x02\x01\x08\xd0\x86\x03\x12\x04\xe5$\x1dI\n\x0c\n\
    \x04\x04G\x02\x02\x12\x04\xe7$\x02\"\n\r\n\x05\x04G\x02\x02\x06\x12\x04\
    \xe7$\x02\x0e\n\r\n\x05\x04G\x02\x02\x01\x12\x04\xe7$\x0f\x1d\n\r\n\x05\
    \x04G\x02\x02\x03\x12\x04\xe7$\x20!\n,\n\x02\x04H\x12\x06\xeb$\0\xef$\
    \x01\x1a\x1e\x20MultiInputAnnotationResponse\n\n\x0b\n\x03\x04H\x01\x12\
    \x04\xeb$\x08$\n\x0c\n\x04\x04H\x02\0\x12\x04\xed$\x02(\n\r\n\x05\x04H\
    \x02\0\x06\x12\x04\xed$\x02\x1c\n\r\n\x05\x04H\x02\0\x01\x12\x04\xed$\
    \x1d#\n\r\n\x05\x04H\x02\0\x03\x12\x04\xed$&'\n\x0c\n\x04\x04H\x02\x01\
    \x12\x04\xee$\x02G\n\r\n\x05\x04H\x02\x01\x04\x12\x04\xee$\x02\n\n\r\n\
    \x05\x04H\x02\x01\x06\x12\x04\xee$\x0b\x0e\n\r\n\x05\x04H\x02\x01\x01\
    \x12\x04\xee$\x0f\x13\n\r\n\x05\x04H\x02\x01\x03\x12\x04\xee$\x16\x17\n\
    \r\n\x05\x04H\x02\x01\x08\x12\x04\xee$\x18F\n\x10\n\x08\x04H\x02\x01\x08\
    \xd0\x86\x03\x12\x04\xee$\x19E\n(\n\x02\x04I\x12\x06\xf2$\0\xf6$\x01\x1a\
    \x1a\x20SingleInputCountResponse\n\n\x0b\n\x03\x04I\x01\x12\x04\xf2$\x08\
    \x20\n\x0c\n\x04\x04I\x02\0\x12\x04\xf3$\x02(\n\r\n\x05\x04I\x02\0\x06\
    \x12\x04\xf3$\x02\x1c\n\r\n\x05\x04I\x02\0\x01\x12\x04\xf3$\x1d#\n\r\n\
    \x05\x04I\x02\0\x03\x12\x04\xf3$&'\n\x0c\n\x04\x04I\x02\x01\x12\x04\xf5$\
    \x02\x18\n\r\n\x05\x04I\x02\x01\x06\x12\x04\xf5$\x02\x0c\n\r\n\x05\x04I\
    \x02\x01\x01\x12\x04\xf5$\r\x13\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xf5$\
    \x16\x17\n$\n\x02\x04J\x12\x06\xf9$\0\xfb$\x01\x1a\x16\x20GetInputCountR\
    equest\n\n\x0b\n\x03\x04J\x01\x12\x04\xf9$\x08\x1c\n\x0c\n\x04\x04J\x02\
    \0\x12\x04\xfa$\x02,\n\r\n\x05\x04J\x02\0\x06\x12\x04\xfa$\x02\x1b\n\r\n\
    \x05\x04J\x02\0\x01\x12\x04\xfa$\x1c'\n\r\n\x05\x04J\x02\0\x03\x12\x04\
    \xfa$*+\n#\n\x02\x04K\x12\x06\xfe$\0\xad%\x01\x1a\x15\x20ListDatasetsReq\
    uest\n\n\x0b\n\x03\x04K\x01\x12\x04\xfe$\x08\x1b\n\x0c\n\x04\x04K\x02\0\
    \x12\x04\xff$\x02,\n\r\n\x05\x04K\x02\0\x06\x12\x04\xff$\x02\x1b\n\r\n\
    \x05\x04K\x02\0\x01\x12\x04\xff$\x1c'\n\r\n\x05\x04K\x02\0\x03\x12\x04\
    \xff$*+\n~\n\x04\x04K\x02\x01\x12\x04\x82%\x02\x12\x1ap\x20(optional\x20\
    URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\
    \x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\
    \x201.\n\n\r\n\x05\x04K\x02\x01\x05\x12\x04\x82%\x02\x08\n\r\n\x05\x04K\
    \x02\x01\x01\x12\x04\x82%\t\r\n\r\n\x05\x04K\x02\x01\x03\x12\x04\x82%\
    \x10\x11\nu\n\x04\x04K\x02\x02\x12\x04\x85%\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\r\n\x05\x04K\x02\x02\x05\x12\x04\x85%\x02\x08\n\r\n\x05\x04K\x02\x02\
    \x01\x12\x04\x85%\t\x11\n\r\n\x05\x04K\x02\x02\x03\x12\x04\x85%\x14\x15\
    \n\x0c\n\x04\x04K\x02\x03\x12\x04\x87%\x02(\n\r\n\x05\x04K\x02\x03\x04\
    \x12\x04\x87%\x02\n\n\r\n\x05\x04K\x02\x03\x05\x12\x04\x87%\x0b\x11\n\r\
    \n\x05\x04K\x02\x03\x01\x12\x04\x87%\x12#\n\r\n\x05\x04K\x02\x03\x03\x12\
    \x04\x87%&'\no\n\x04\x04K\x02\x04\x12\x04\x8b%\x02\x1a\x1aa\x20Sorting\
    \x20options:\n\x20Whether\x20to\x20sort\x20in\x20ascending\x20order.\x20\
    If\x20false,\x20will\x20order\x20in\x20descending\x20order.\n\n\r\n\x05\
    \x04K\x02\x04\x05\x12\x04\x8b%\x02\x06\n\r\n\x05\x04K\x02\x04\x01\x12\
    \x04\x8b%\x07\x15\n\r\n\x05\x04K\x02\x04\x03\x12\x04\x8b%\x18\x19\n\x0e\
    \n\x04\x04K\x08\0\x12\x06\x8c%\x02\x95%\x03\n\r\n\x05\x04K\x08\0\x01\x12\
    \x04\x8c%\x08\x0f\n8\n\x04\x04K\x02\x05\x12\x04\x8e%\x04\x20\x1a*\x20Whe\
    ther\x20to\x20order\x20by\x20the\x20created_at\x20time.\n\n\r\n\x05\x04K\
    \x02\x05\x05\x12\x04\x8e%\x04\x08\n\r\n\x05\x04K\x02\x05\x01\x12\x04\x8e\
    %\t\x1b\n\r\n\x05\x04K\x02\x05\x03\x12\x04\x8e%\x1e\x1f\nF\n\x04\x04K\
    \x02\x06\x12\x04\x90%\x04\x20\x1a8\x20Whether\x20to\x20order\x20by\x20th\
    e\x20number\x20of\x20users\x20stared\x20the\x20app\n\n\r\n\x05\x04K\x02\
    \x06\x05\x12\x04\x90%\x04\x08\n\r\n\x05\x04K\x02\x06\x01\x12\x04\x90%\t\
    \x1b\n\r\n\x05\x04K\x02\x06\x03\x12\x04\x90%\x1e\x1f\nP\n\x04\x04K\x02\
    \x07\x12\x04\x92%\x04!\x1aB\x20If\x20neither\x20sort\x20option\x20is\x20\
    set\x20to\x20true,\x20will\x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04\
    K\x02\x07\x05\x12\x04\x92%\x04\x08\n\r\n\x05\x04K\x02\x07\x01\x12\x04\
    \x92%\t\x1c\n\r\n\x05\x04K\x02\x07\x03\x12\x04\x92%\x1f\x20\n3\n\x04\x04\
    K\x02\x08\x12\x04\x94%\x04\x19\x1a%\x20Whether\x20to\x20order\x20by\x20t\
    he\x20external\x20id\n\n\r\n\x05\x04K\x02\x08\x05\x12\x04\x94%\x04\x08\n\
    \r\n\x05\x04K\x02\x08\x01\x12\x04\x94%\t\x13\n\r\n\x05\x04K\x02\x08\x03\
    \x12\x04\x94%\x16\x18\n\"\n\x04\x04K\x02\t\x12\x04\x98%\x02\x18\x1a\x14\
    \x20Filtering\x20options:\n\n\r\n\x05\x04K\x02\t\x05\x12\x04\x98%\x02\
    \x06\n\r\n\x05\x04K\x02\t\x01\x12\x04\x98%\x07\x13\n\r\n\x05\x04K\x02\t\
    \x03\x12\x04\x98%\x16\x17\n~\n\x04\x04K\x02\n\x12\x04\x9a%\x02\x15\x1ap\
    \x20Filter\x20datasets\x20by\x20bookmark.\x20If\x20set,\x20only\x20retur\
    n\x20bookmarked\x20datasets.\x20Otherwise\x20none\x20bookmarked\x20datas\
    ets\x20only.\n\n\r\n\x05\x04K\x02\n\x05\x12\x04\x9a%\x02\x06\n\r\n\x05\
    \x04K\x02\n\x01\x12\x04\x9a%\x07\x0f\n\r\n\x05\x04K\x02\n\x03\x12\x04\
    \x9a%\x12\x14\n\xac\x04\n\x04\x04K\x02\x0b\x12\x04\xa9%\x02\x15\x1a\x9d\
    \x04\x20Searching\x20options:\n\x20Specify\x20a\x20search\x20parameter\
    \x20in\x20order\x20to\x20perform\x20keyword\x20search\x20on\x20the\n\x20\
    following\x20fields\x20of\x20the\x20dataset:\n\x20\x20\x20-\x20id\n\x20\
    \x20\x20-\x20description\n\x20\x20\x20-\x20notes\n\x20\x20\x20-\x20user_\
    id\x20(unless\x20user_app_id.user_id\x20is\x20already\x20set)\n\n\x20Key\
    words\x20are\x20both\x20normalized\x20for\x20search\x20(so\x20searching\
    \x20for\x20\"satisfy\"\x20matches\x20\"satisfied\")\n\x20and\x20used\x20\
    for\x20partial\x20prefix-matching\x20(so\x20searching\x20for\x20\"clari\
    \"\x20matches\x20\"clarifai\").\n\n\x20NOTE:\x20Both\x20the\x20list\x20o\
    f\x20fields\x20searched\x20and\x20the\x20exact\x20keyword\x20matching\n\
    \x20rules\x20are\x20subject\x20to\x20change\x20and\x20not\x20guaranteed\
    \x20to\x20be\x20backwards-compatible.\n\n\r\n\x05\x04K\x02\x0b\x05\x12\
    \x04\xa9%\x02\x08\n\r\n\x05\x04K\x02\x0b\x01\x12\x04\xa9%\t\x0f\n\r\n\
    \x05\x04K\x02\x0b\x03\x12\x04\xa9%\x12\x14\nK\n\x04\x04K\x02\x0c\x12\x04\
    \xac%\x02%\x1a=\x20Fuzzy\x20filter\x20on\x20dataset\x20ID\n\x20Deprecate\
    d:\x20use\x20search\x20instead.\n\n\r\n\x05\x04K\x02\x0c\x05\x12\x04\xac\
    %\x02\x08\n\r\n\x05\x04K\x02\x0c\x01\x12\x04\xac%\t\x0b\n\r\n\x05\x04K\
    \x02\x0c\x03\x12\x04\xac%\x0e\x10\n\r\n\x05\x04K\x02\x0c\x08\x12\x04\xac\
    %\x11$\n\x0e\n\x06\x04K\x02\x0c\x08\x03\x12\x04\xac%\x12#\n!\n\x02\x04L\
    \x12\x06\xb0%\0\xb6%\x01\x1a\x13\x20GetDatasetRequest\n\n\x0b\n\x03\x04L\
    \x01\x12\x04\xb0%\x08\x19\n\x0c\n\x04\x04L\x02\0\x12\x04\xb1%\x02,\n\r\n\
    \x05\x04L\x02\0\x06\x12\x04\xb1%\x02\x1b\n\r\n\x05\x04L\x02\0\x01\x12\
    \x04\xb1%\x1c'\n\r\n\x05\x04L\x02\0\x03\x12\x04\xb1%*+\n'\n\x04\x04L\x02\
    \x01\x12\x04\xb4%\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\
    \n\r\n\x05\x04L\x02\x01\x05\x12\x04\xb4%\x02\x08\n\r\n\x05\x04L\x02\x01\
    \x01\x12\x04\xb4%\t\x13\n\r\n\x05\x04L\x02\x01\x03\x12\x04\xb4%\x16\x17\
    \n\x0c\n\x04\x04L\x02\x02\x12\x04\xb5%\x02(\n\r\n\x05\x04L\x02\x02\x04\
    \x12\x04\xb5%\x02\n\n\r\n\x05\x04L\x02\x02\x05\x12\x04\xb5%\x0b\x11\n\r\
    \n\x05\x04L\x02\x02\x01\x12\x04\xb5%\x12#\n\r\n\x05\x04L\x02\x02\x03\x12\
    \x04\xb5%&'\n4\n\x02\x04M\x12\x06\xb9%\0\xbe%\x01\x1a&\x20Request\x20to\
    \x20add\x20one\x20or\x20more\x20datasets.\n\n\x0b\n\x03\x04M\x01\x12\x04\
    \xb9%\x08\x1b\n\x0c\n\x04\x04M\x02\0\x12\x04\xba%\x02,\n\r\n\x05\x04M\
    \x02\0\x06\x12\x04\xba%\x02\x1b\n\r\n\x05\x04M\x02\0\x01\x12\x04\xba%\
    \x1c'\n\r\n\x05\x04M\x02\0\x03\x12\x04\xba%*+\n@\n\x04\x04M\x02\x01\x12\
    \x04\xbd%\x02\x20\x1a2\x20List\x20of\x20datasets\x20that\x20are\x20reque\
    sted\x20to\x20be\x20added.\n\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xbd%\x02\
    \n\n\r\n\x05\x04M\x02\x01\x06\x12\x04\xbd%\x0b\x12\n\r\n\x05\x04M\x02\
    \x01\x01\x12\x04\xbd%\x13\x1b\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xbd%\
    \x1e\x1f\n2\n\x02\x04N\x12\x06\xc1%\0\xcd%\x01\x1a$\x20Request\x20to\x20\
    patch\x20several\x20datasets.\n\n\x0b\n\x03\x04N\x01\x12\x04\xc1%\x08\
    \x1c\n\x0c\n\x04\x04N\x02\0\x12\x04\xc2%\x02,\n\r\n\x05\x04N\x02\0\x06\
    \x12\x04\xc2%\x02\x1b\n\r\n\x05\x04N\x02\0\x01\x12\x04\xc2%\x1c'\n\r\n\
    \x05\x04N\x02\0\x03\x12\x04\xc2%*+\nB\n\x04\x04N\x02\x01\x12\x04\xc5%\
    \x02\x20\x1a4\x20List\x20of\x20datasets\x20that\x20are\x20requested\x20t\
    o\x20be\x20updated.\n\n\r\n\x05\x04N\x02\x01\x04\x12\x04\xc5%\x02\n\n\r\
    \n\x05\x04N\x02\x01\x06\x12\x04\xc5%\x0b\x12\n\r\n\x05\x04N\x02\x01\x01\
    \x12\x04\xc5%\x13\x1b\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xc5%\x1e\x1f\n\
    \x8d\x02\n\x04\x04N\x02\x02\x12\x04\xcc%\x02\x14\x1a\xfe\x01\x20The\x20a\
    ction\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20Supported\
    \x20values:\x20'overwrite',\x20'merge',\x20and\x20'remove'.\n\n\x20Note\
    \x20that\x20'remove'\x20can\x20only\x20be\x20used\x20to\x20remove\x20the\
    \x20dataset\x20image\x20by\x20setting\n\x20'image.url'\x20in\x20the\x20r\
    equest\x20to\x20the\x20current\x20value\x20returned\x20for\x20that\x20da\
    taset.\n\n\r\n\x05\x04N\x02\x02\x05\x12\x04\xcc%\x02\x08\n\r\n\x05\x04N\
    \x02\x02\x01\x12\x04\xcc%\t\x0f\n\r\n\x05\x04N\x02\x02\x03\x12\x04\xcc%\
    \x12\x13\nB\n\x02\x04O\x12\x06\xd0%\0\xd3%\x01\x1a4\x20Request\x20to\x20\
    delete\x20several\x20datasets\x20by\x20list\x20of\x20ids.\n\n\x0b\n\x03\
    \x04O\x01\x12\x04\xd0%\x08\x1d\n\x0c\n\x04\x04O\x02\0\x12\x04\xd1%\x02,\
    \n\r\n\x05\x04O\x02\0\x06\x12\x04\xd1%\x02\x1b\n\r\n\x05\x04O\x02\0\x01\
    \x12\x04\xd1%\x1c'\n\r\n\x05\x04O\x02\0\x03\x12\x04\xd1%*+\n\x0c\n\x04\
    \x04O\x02\x01\x12\x04\xd2%\x02\"\n\r\n\x05\x04O\x02\x01\x04\x12\x04\xd2%\
    \x02\n\n\r\n\x05\x04O\x02\x01\x05\x12\x04\xd2%\x0b\x11\n\r\n\x05\x04O\
    \x02\x01\x01\x12\x04\xd2%\x12\x1d\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xd2\
    %\x20!\n$\n\x02\x04P\x12\x06\xd6%\0\xd9%\x01\x1a\x16\x20MultiDatasetResp\
    onse\n\n\x0b\n\x03\x04P\x01\x12\x04\xd6%\x08\x1c\n\x0c\n\x04\x04P\x02\0\
    \x12\x04\xd7%\x02(\n\r\n\x05\x04P\x02\0\x06\x12\x04\xd7%\x02\x1c\n\r\n\
    \x05\x04P\x02\0\x01\x12\x04\xd7%\x1d#\n\r\n\x05\x04P\x02\0\x03\x12\x04\
    \xd7%&'\n\x0c\n\x04\x04P\x02\x01\x12\x04\xd8%\x02O\n\r\n\x05\x04P\x02\
    \x01\x04\x12\x04\xd8%\x02\n\n\r\n\x05\x04P\x02\x01\x06\x12\x04\xd8%\x0b\
    \x12\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xd8%\x13\x1b\n\r\n\x05\x04P\x02\
    \x01\x03\x12\x04\xd8%\x1e\x1f\n\r\n\x05\x04P\x02\x01\x08\x12\x04\xd8%\
    \x20N\n\x10\n\x08\x04P\x02\x01\x08\xd0\x86\x03\x12\x04\xd8%!M\n%\n\x02\
    \x04Q\x12\x06\xdc%\0\xdf%\x01\x1a\x17\x20SingleDatasetResponse\n\n\x0b\n\
    \x03\x04Q\x01\x12\x04\xdc%\x08\x1d\n\x0c\n\x04\x04Q\x02\0\x12\x04\xdd%\
    \x02(\n\r\n\x05\x04Q\x02\0\x06\x12\x04\xdd%\x02\x1c\n\r\n\x05\x04Q\x02\0\
    \x01\x12\x04\xdd%\x1d#\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xdd%&'\n\x0c\n\
    \x04\x04Q\x02\x01\x12\x04\xde%\x02\x16\n\r\n\x05\x04Q\x02\x01\x06\x12\
    \x04\xde%\x02\t\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\xde%\n\x11\n\r\n\x05\
    \x04Q\x02\x01\x03\x12\x04\xde%\x14\x15\n(\n\x02\x04R\x12\x06\xe2%\0\xec%\
    \x01\x1a\x1a\x20ListDatasetInputsRequest\n\n\x0b\n\x03\x04R\x01\x12\x04\
    \xe2%\x08\x20\n\x0c\n\x04\x04R\x02\0\x12\x04\xe3%\x02,\n\r\n\x05\x04R\
    \x02\0\x06\x12\x04\xe3%\x02\x1b\n\r\n\x05\x04R\x02\0\x01\x12\x04\xe3%\
    \x1c'\n\r\n\x05\x04R\x02\0\x03\x12\x04\xe3%*+\n'\n\x04\x04R\x02\x01\x12\
    \x04\xe5%\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\
    \x05\x04R\x02\x01\x05\x12\x04\xe5%\x02\x08\n\r\n\x05\x04R\x02\x01\x01\
    \x12\x04\xe5%\t\x13\n\r\n\x05\x04R\x02\x01\x03\x12\x04\xe5%\x16\x17\n~\n\
    \x04\x04R\x02\x02\x12\x04\xe8%\x02\x12\x1ap\x20(optional\x20URL\x20param\
    eter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spl\
    it\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\
    \n\x05\x04R\x02\x02\x05\x12\x04\xe8%\x02\x08\n\r\n\x05\x04R\x02\x02\x01\
    \x12\x04\xe8%\t\r\n\r\n\x05\x04R\x02\x02\x03\x12\x04\xe8%\x10\x11\nu\n\
    \x04\x04R\x02\x03\x12\x04\xeb%\x02\x16\x1ag\x20(optional\x20URL\x20param\
    eter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contain\
    ed\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04R\
    \x02\x03\x05\x12\x04\xeb%\x02\x08\n\r\n\x05\x04R\x02\x03\x01\x12\x04\xeb\
    %\t\x11\n\r\n\x05\x04R\x02\x03\x03\x12\x04\xeb%\x14\x15\n&\n\x02\x04S\
    \x12\x06\xef%\0\xf7%\x01\x1a\x18\x20GetDatasetInputRequest\n\n\x0b\n\x03\
    \x04S\x01\x12\x04\xef%\x08\x1e\n\x0c\n\x04\x04S\x02\0\x12\x04\xf0%\x02,\
    \n\r\n\x05\x04S\x02\0\x06\x12\x04\xf0%\x02\x1b\n\r\n\x05\x04S\x02\0\x01\
    \x12\x04\xf0%\x1c'\n\r\n\x05\x04S\x02\0\x03\x12\x04\xf0%*+\n'\n\x04\x04S\
    \x02\x01\x12\x04\xf3%\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id\
    .\n\n\r\n\x05\x04S\x02\x01\x05\x12\x04\xf3%\x02\x08\n\r\n\x05\x04S\x02\
    \x01\x01\x12\x04\xf3%\t\x13\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xf3%\x16\
    \x17\n-\n\x04\x04S\x02\x02\x12\x04\xf6%\x02\x16\x1a\x1f\x20Identify\x20d\
    ataset\x20input\x20by\x20id.\n\n\r\n\x05\x04S\x02\x02\x05\x12\x04\xf6%\
    \x02\x08\n\r\n\x05\x04S\x02\x02\x01\x12\x04\xf6%\t\x11\n\r\n\x05\x04S\
    \x02\x02\x03\x12\x04\xf6%\x14\x15\n4\n\x02\x04T\x12\x06\xfa%\0\x86&\x01\
    \x1a&\x20Request\x20to\x20add\x20one\x20or\x20more\x20datasets.\n\n\x0b\
    \n\x03\x04T\x01\x12\x04\xfa%\x08\x20\n\x0c\n\x04\x04T\x02\0\x12\x04\xfb%\
    \x02,\n\r\n\x05\x04T\x02\0\x06\x12\x04\xfb%\x02\x1b\n\r\n\x05\x04T\x02\0\
    \x01\x12\x04\xfb%\x1c'\n\r\n\x05\x04T\x02\0\x03\x12\x04\xfb%*+\n'\n\x04\
    \x04T\x02\x01\x12\x04\xfe%\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\
    \x20id.\n\n\r\n\x05\x04T\x02\x01\x05\x12\x04\xfe%\x02\x08\n\r\n\x05\x04T\
    \x02\x01\x01\x12\x04\xfe%\t\x13\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xfe%\
    \x16\x17\n\x96\x01\n\x04\x04T\x02\x02\x12\x04\x82&\x02+\x1a\x87\x01\x20L\
    ist\x20of\x20inputs\x20that\x20are\x20requested\x20to\x20be\x20added\x20\
    to\x20this\x20dataset.\n\x20Identify\x20each\x20input\x20by\x20id\x20fie\
    ld.\x20All\x20other\x20inputs\x20fields\x20are\x20ignored.\n\n\r\n\x05\
    \x04T\x02\x02\x04\x12\x04\x82&\x02\n\n\r\n\x05\x04T\x02\x02\x06\x12\x04\
    \x82&\x0b\x17\n\r\n\x05\x04T\x02\x02\x01\x12\x04\x82&\x18&\n\r\n\x05\x04\
    T\x02\x02\x03\x12\x04\x82&)*\nC\n\x04\x04T\x02\x03\x12\x04\x85&\x02\x14\
    \x1a5\x20Query\x20to\x20search\x20inputs\x20to\x20be\x20added\x20to\x20t\
    his\x20dataset.\n\n\r\n\x05\x04T\x02\x03\x06\x12\x04\x85&\x02\x08\n\r\n\
    \x05\x04T\x02\x03\x01\x12\x04\x85&\t\x0f\n\r\n\x05\x04T\x02\x03\x03\x12\
    \x04\x85&\x12\x13\nH\n\x02\x04U\x12\x06\x89&\0\x91&\x01\x1a:\x20Request\
    \x20to\x20delete\x20several\x20dataset\x20inputs\x20by\x20list\x20of\x20\
    ids.\n\n\x0b\n\x03\x04U\x01\x12\x04\x89&\x08\"\n\x0c\n\x04\x04U\x02\0\
    \x12\x04\x8a&\x02,\n\r\n\x05\x04U\x02\0\x06\x12\x04\x8a&\x02\x1b\n\r\n\
    \x05\x04U\x02\0\x01\x12\x04\x8a&\x1c'\n\r\n\x05\x04U\x02\0\x03\x12\x04\
    \x8a&*+\n'\n\x04\x04U\x02\x01\x12\x04\x8d&\x02\x18\x1a\x19\x20Identify\
    \x20dataset\x20by\x20id.\n\n\r\n\x05\x04U\x02\x01\x05\x12\x04\x8d&\x02\
    \x08\n\r\n\x05\x04U\x02\x01\x01\x12\x04\x8d&\t\x13\n\r\n\x05\x04U\x02\
    \x01\x03\x12\x04\x8d&\x16\x17\n<\n\x04\x04U\x02\x02\x12\x04\x90&\x02\x20\
    \x1a.\x20Specify\x20which\x20inputs\x20to\x20delete\x20from\x20dataset.\
    \n\n\r\n\x05\x04U\x02\x02\x04\x12\x04\x90&\x02\n\n\r\n\x05\x04U\x02\x02\
    \x05\x12\x04\x90&\x0b\x11\n\r\n\x05\x04U\x02\x02\x01\x12\x04\x90&\x12\
    \x1b\n\r\n\x05\x04U\x02\x02\x03\x12\x04\x90&\x1e\x1f\n)\n\x02\x04V\x12\
    \x06\x94&\0\x99&\x01\x1a\x1b\x20MultiDatasetInputResponse\n\n\x0b\n\x03\
    \x04V\x01\x12\x04\x94&\x08!\n\x0b\n\x03\x04V\t\x12\x04\x95&\x02\r\n\x0c\
    \n\x04\x04V\t\0\x12\x04\x95&\x0b\x0c\n\r\n\x05\x04V\t\0\x01\x12\x04\x95&\
    \x0b\x0c\n\r\n\x05\x04V\t\0\x02\x12\x04\x95&\x0b\x0c\n\x0c\n\x04\x04V\
    \x02\0\x12\x04\x96&\x02(\n\r\n\x05\x04V\x02\0\x06\x12\x04\x96&\x02\x1c\n\
    \r\n\x05\x04V\x02\0\x01\x12\x04\x96&\x1d#\n\r\n\x05\x04V\x02\0\x03\x12\
    \x04\x96&&'\n\x0c\n\x04\x04V\x02\x01\x12\x04\x97&\x02Z\n\r\n\x05\x04V\
    \x02\x01\x04\x12\x04\x97&\x02\n\n\r\n\x05\x04V\x02\x01\x06\x12\x04\x97&\
    \x0b\x17\n\r\n\x05\x04V\x02\x01\x01\x12\x04\x97&\x18&\n\r\n\x05\x04V\x02\
    \x01\x03\x12\x04\x97&)*\n\r\n\x05\x04V\x02\x01\x08\x12\x04\x97&+Y\n\x10\
    \n\x08\x04V\x02\x01\x08\xd0\x86\x03\x12\x04\x97&,X\n\x0c\n\x04\x04V\x02\
    \x02\x12\x04\x98&\x02#\n\r\n\x05\x04V\x02\x02\x06\x12\x04\x98&\x02\x0f\n\
    \r\n\x05\x04V\x02\x02\x01\x12\x04\x98&\x10\x1e\n\r\n\x05\x04V\x02\x02\
    \x03\x12\x04\x98&!\"\n*\n\x02\x04W\x12\x06\x9c&\0\x9f&\x01\x1a\x1c\x20Si\
    ngleDatasetInputResponse\n\n\x0b\n\x03\x04W\x01\x12\x04\x9c&\x08\"\n\x0c\
    \n\x04\x04W\x02\0\x12\x04\x9d&\x02(\n\r\n\x05\x04W\x02\0\x06\x12\x04\x9d\
    &\x02\x1c\n\r\n\x05\x04W\x02\0\x01\x12\x04\x9d&\x1d#\n\r\n\x05\x04W\x02\
    \0\x03\x12\x04\x9d&&'\n\x0c\n\x04\x04W\x02\x01\x12\x04\x9e&\x02!\n\r\n\
    \x05\x04W\x02\x01\x06\x12\x04\x9e&\x02\x0e\n\r\n\x05\x04W\x02\x01\x01\
    \x12\x04\x9e&\x0f\x1c\n\r\n\x05\x04W\x02\x01\x03\x12\x04\x9e&\x1f\x20\n*\
    \n\x02\x04X\x12\x06\xa2&\0\xb2&\x01\x1a\x1c\x20ListDatasetVersionsReques\
    t\n\n\x0b\n\x03\x04X\x01\x12\x04\xa2&\x08\"\n\x0c\n\x04\x04X\x02\0\x12\
    \x04\xa3&\x02,\n\r\n\x05\x04X\x02\0\x06\x12\x04\xa3&\x02\x1b\n\r\n\x05\
    \x04X\x02\0\x01\x12\x04\xa3&\x1c'\n\r\n\x05\x04X\x02\0\x03\x12\x04\xa3&*\
    +\n'\n\x04\x04X\x02\x01\x12\x04\xa6&\x02\x18\x1a\x19\x20Identify\x20data\
    set\x20by\x20id.\n\n\r\n\x05\x04X\x02\x01\x05\x12\x04\xa6&\x02\x08\n\r\n\
    \x05\x04X\x02\x01\x01\x12\x04\xa6&\t\x13\n\r\n\x05\x04X\x02\x01\x03\x12\
    \x04\xa6&\x16\x17\n~\n\x04\x04X\x02\x02\x12\x04\xaa&\x02\x12\x1ap\x20(op\
    tional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20i\
    s\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defau\
    lts\x20to\x201.\n\n\r\n\x05\x04X\x02\x02\x05\x12\x04\xaa&\x02\x08\n\r\n\
    \x05\x04X\x02\x02\x01\x12\x04\xaa&\t\r\n\r\n\x05\x04X\x02\x02\x03\x12\
    \x04\xaa&\x10\x11\nu\n\x04\x04X\x02\x03\x12\x04\xae&\x02\x16\x1ag\x20(op\
    tional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x04X\x02\x03\x05\x12\x04\xae&\x02\x08\n\r\n\x05\x04\
    X\x02\x03\x01\x12\x04\xae&\t\x11\n\r\n\x05\x04X\x02\x03\x03\x12\x04\xae&\
    \x14\x15\nL\n\x04\x04X\x02\x04\x12\x04\xb1&\x02;\x1a>\x20(optional\x20UR\
    L\x20parameter)\x20Filter\x20by\x20origin\x20of\x20dataset\x20version\n\
    \n\r\n\x05\x04X\x02\x04\x04\x12\x04\xb1&\x02\n\n\r\n\x05\x04X\x02\x04\
    \x06\x12\x04\xb1&\x0b&\n\r\n\x05\x04X\x02\x04\x01\x12\x04\xb1&'6\n\r\n\
    \x05\x04X\x02\x04\x03\x12\x04\xb1&9:\n(\n\x02\x04Y\x12\x06\xb5&\0\xbd&\
    \x01\x1a\x1a\x20GetDatasetVersionRequest\n\n\x0b\n\x03\x04Y\x01\x12\x04\
    \xb5&\x08\x20\n\x0c\n\x04\x04Y\x02\0\x12\x04\xb6&\x02,\n\r\n\x05\x04Y\
    \x02\0\x06\x12\x04\xb6&\x02\x1b\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xb6&\
    \x1c'\n\r\n\x05\x04Y\x02\0\x03\x12\x04\xb6&*+\n'\n\x04\x04Y\x02\x01\x12\
    \x04\xb9&\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\
    \x05\x04Y\x02\x01\x05\x12\x04\xb9&\x02\x08\n\r\n\x05\x04Y\x02\x01\x01\
    \x12\x04\xb9&\t\x13\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\xb9&\x16\x17\n/\n\
    \x04\x04Y\x02\x02\x12\x04\xbc&\x02\x20\x1a!\x20Identify\x20dataset\x20ve\
    rsion\x20by\x20id.\n\n\r\n\x05\x04Y\x02\x02\x05\x12\x04\xbc&\x02\x08\n\r\
    \n\x05\x04Y\x02\x02\x01\x12\x04\xbc&\t\x1b\n\r\n\x05\x04Y\x02\x02\x03\
    \x12\x04\xbc&\x1e\x1f\n6\n\x02\x04Z\x12\x06\xc0&\0\xd8&\x01\x1a(\x20List\
    DatasetVersionMetricsGroupsRequest\n\n\x0b\n\x03\x04Z\x01\x12\x04\xc0&\
    \x08.\n\x0c\n\x04\x04Z\x02\0\x12\x04\xc1&\x02,\n\r\n\x05\x04Z\x02\0\x06\
    \x12\x04\xc1&\x02\x1b\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xc1&\x1c'\n\r\n\
    \x05\x04Z\x02\0\x03\x12\x04\xc1&*+\n'\n\x04\x04Z\x02\x01\x12\x04\xc4&\
    \x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\x05\x04Z\
    \x02\x01\x05\x12\x04\xc4&\x02\x08\n\r\n\x05\x04Z\x02\x01\x01\x12\x04\xc4\
    &\t\x13\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\xc4&\x16\x17\n/\n\x04\x04Z\
    \x02\x02\x12\x04\xc7&\x02\x20\x1a!\x20Identify\x20dataset\x20version\x20\
    by\x20id.\n\n\r\n\x05\x04Z\x02\x02\x05\x12\x04\xc7&\x02\x08\n\r\n\x05\
    \x04Z\x02\x02\x01\x12\x04\xc7&\t\x1b\n\r\n\x05\x04Z\x02\x02\x03\x12\x04\
    \xc7&\x1e\x1f\n~\n\x04\x04Z\x02\x03\x12\x04\xcb&\x02\x12\x1ap\x20(option\
    al\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\
    \x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaul\
    ts\x20to\x201.\n\n\r\n\x05\x04Z\x02\x03\x05\x12\x04\xcb&\x02\x08\n\r\n\
    \x05\x04Z\x02\x03\x01\x12\x04\xcb&\t\r\n\r\n\x05\x04Z\x02\x03\x03\x12\
    \x04\xcb&\x10\x11\nu\n\x04\x04Z\x02\x04\x12\x04\xce&\x02\x16\x1ag\x20(op\
    tional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x04Z\x02\x04\x05\x12\x04\xce&\x02\x08\n\r\n\x05\x04\
    Z\x02\x04\x01\x12\x04\xce&\t\x11\n\r\n\x05\x04Z\x02\x04\x03\x12\x04\xce&\
    \x14\x15\nh\n\x04\x04Z\x02\x05\x12\x04\xd1&\x02#\x1aZ\x20Filter\x20by\
    \x20parent\x20path.\x20Multiple\x20parent\x20paths\x20are\x20OR-ed.\x20E\
    mpty\x20list\x20results\x20in\x20no\x20filter.\n\n\r\n\x05\x04Z\x02\x05\
    \x04\x12\x04\xd1&\x02\n\n\r\n\x05\x04Z\x02\x05\x05\x12\x04\xd1&\x0b\x11\
    \n\r\n\x05\x04Z\x02\x05\x01\x12\x04\xd1&\x12\x1e\n\r\n\x05\x04Z\x02\x05\
    \x03\x12\x04\xd1&!\"\na\n\x04\x04Z\x02\x06\x12\x04\xd4&\x024\x1aS\x20Fil\
    ter\x20by\x20parent\x20type.\x20Multiple\x20types\x20are\x20OR-ed.\x20Em\
    pty\x20list\x20results\x20in\x20no\x20filter.\n\n\r\n\x05\x04Z\x02\x06\
    \x04\x12\x04\xd4&\x02\n\n\r\n\x05\x04Z\x02\x06\x06\x12\x04\xd4&\x0b)\n\r\
    \n\x05\x04Z\x02\x06\x01\x12\x04\xd4&*/\n\r\n\x05\x04Z\x02\x06\x03\x12\
    \x04\xd4&23\n\\\n\x04\x04Z\x02\x07\x12\x04\xd7&\x02,\x1aN\x20Filter\x20b\
    y\x20value.\x20Multiple\x20values\x20are\x20OR-ed.\x20Empty\x20list\x20r\
    esults\x20in\x20no\x20filter.\n\n\r\n\x05\x04Z\x02\x07\x04\x12\x04\xd7&\
    \x02\n\n\r\n\x05\x04Z\x02\x07\x06\x12\x04\xd7&\x0b\x20\n\r\n\x05\x04Z\
    \x02\x07\x01\x12\x04\xd7&!'\n\r\n\x05\x04Z\x02\x07\x03\x12\x04\xd7&*+\n<\
    \n\x02\x04[\x12\x06\xdb&\0\xe3&\x01\x1a.\x20Request\x20to\x20add\x20one\
    \x20or\x20more\x20dataset\x20versions.\n\n\x0b\n\x03\x04[\x01\x12\x04\
    \xdb&\x08\"\n\x0c\n\x04\x04[\x02\0\x12\x04\xdc&\x02,\n\r\n\x05\x04[\x02\
    \0\x06\x12\x04\xdc&\x02\x1b\n\r\n\x05\x04[\x02\0\x01\x12\x04\xdc&\x1c'\n\
    \r\n\x05\x04[\x02\0\x03\x12\x04\xdc&*+\n'\n\x04\x04[\x02\x01\x12\x04\xdf\
    &\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id.\n\n\r\n\x05\x04[\
    \x02\x01\x05\x12\x04\xdf&\x02\x08\n\r\n\x05\x04[\x02\x01\x01\x12\x04\xdf\
    &\t\x13\n\r\n\x05\x04[\x02\x01\x03\x12\x04\xdf&\x16\x17\nH\n\x04\x04[\
    \x02\x02\x12\x04\xe2&\x02/\x1a:\x20List\x20of\x20dataset\x20versions\x20\
    that\x20are\x20requested\x20to\x20be\x20added.\n\n\r\n\x05\x04[\x02\x02\
    \x04\x12\x04\xe2&\x02\n\n\r\n\x05\x04[\x02\x02\x06\x12\x04\xe2&\x0b\x19\
    \n\r\n\x05\x04[\x02\x02\x01\x12\x04\xe2&\x1a*\n\r\n\x05\x04[\x02\x02\x03\
    \x12\x04\xe2&-.\n:\n\x02\x04\\\x12\x06\xe6&\0\xf2&\x01\x1a,\x20Request\
    \x20to\x20patch\x20several\x20dataset\x20versions.\n\n\x0b\n\x03\x04\\\
    \x01\x12\x04\xe6&\x08#\n\x0c\n\x04\x04\\\x02\0\x12\x04\xe7&\x02,\n\r\n\
    \x05\x04\\\x02\0\x06\x12\x04\xe7&\x02\x1b\n\r\n\x05\x04\\\x02\0\x01\x12\
    \x04\xe7&\x1c'\n\r\n\x05\x04\\\x02\0\x03\x12\x04\xe7&*+\n'\n\x04\x04\\\
    \x02\x01\x12\x04\xea&\x02\x18\x1a\x19\x20Identify\x20dataset\x20by\x20id\
    .\n\n\r\n\x05\x04\\\x02\x01\x05\x12\x04\xea&\x02\x08\n\r\n\x05\x04\\\x02\
    \x01\x01\x12\x04\xea&\t\x13\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\xea&\x16\
    \x17\nJ\n\x04\x04\\\x02\x02\x12\x04\xed&\x02/\x1a<\x20List\x20of\x20data\
    set\x20versions\x20that\x20are\x20requested\x20to\x20be\x20updated.\n\n\
    \r\n\x05\x04\\\x02\x02\x04\x12\x04\xed&\x02\n\n\r\n\x05\x04\\\x02\x02\
    \x06\x12\x04\xed&\x0b\x19\n\r\n\x05\x04\\\x02\x02\x01\x12\x04\xed&\x1a*\
    \n\r\n\x05\x04\\\x02\x02\x03\x12\x04\xed&-.\nk\n\x04\x04\\\x02\x03\x12\
    \x04\xf1&\x02\x14\x1a]\x20The\x20action\x20to\x20perform\x20on\x20the\
    \x20patched\x20objects\n\x20For\x20now,\x20only\x20'overwrite'\x20action\
    \x20is\x20supported\n\n\r\n\x05\x04\\\x02\x03\x05\x12\x04\xf1&\x02\x08\n\
    \r\n\x05\x04\\\x02\x03\x01\x12\x04\xf1&\t\x0f\n\r\n\x05\x04\\\x02\x03\
    \x03\x12\x04\xf1&\x12\x13\nJ\n\x02\x04]\x12\x06\xf5&\0\xfc&\x01\x1a<\x20\
    Request\x20to\x20delete\x20several\x20dataset\x20versions\x20by\x20list\
    \x20of\x20ids.\n\n\x0b\n\x03\x04]\x01\x12\x04\xf5&\x08$\n\x0c\n\x04\x04]\
    \x02\0\x12\x04\xf6&\x02,\n\r\n\x05\x04]\x02\0\x06\x12\x04\xf6&\x02\x1b\n\
    \r\n\x05\x04]\x02\0\x01\x12\x04\xf6&\x1c'\n\r\n\x05\x04]\x02\0\x03\x12\
    \x04\xf6&*+\n'\n\x04\x04]\x02\x01\x12\x04\xf9&\x02\x18\x1a\x19\x20Identi\
    fy\x20dataset\x20by\x20id.\n\n\r\n\x05\x04]\x02\x01\x05\x12\x04\xf9&\x02\
    \x08\n\r\n\x05\x04]\x02\x01\x01\x12\x04\xf9&\t\x13\n\r\n\x05\x04]\x02\
    \x01\x03\x12\x04\xf9&\x16\x17\n\x0c\n\x04\x04]\x02\x02\x12\x04\xfb&\x02*\
    \n\r\n\x05\x04]\x02\x02\x04\x12\x04\xfb&\x02\n\n\r\n\x05\x04]\x02\x02\
    \x05\x12\x04\xfb&\x0b\x11\n\r\n\x05\x04]\x02\x02\x01\x12\x04\xfb&\x12%\n\
    \r\n\x05\x04]\x02\x02\x03\x12\x04\xfb&()\n?\n\x02\x04^\x12\x06\xff&\0\
    \x8b'\x01\x1a1\x20Request\x20to\x20create\x20exports\x20of\x20a\x20datas\
    et\x20version.\n\n\x0b\n\x03\x04^\x01\x12\x04\xff&\x08'\n\x0c\n\x04\x04^\
    \x02\0\x12\x04\x80'\x02,\n\r\n\x05\x04^\x02\0\x06\x12\x04\x80'\x02\x1b\n\
    \r\n\x05\x04^\x02\0\x01\x12\x04\x80'\x1c'\n\r\n\x05\x04^\x02\0\x03\x12\
    \x04\x80'*+\n'\n\x04\x04^\x02\x01\x12\x04\x83'\x02\x18\x1a\x19\x20Identi\
    fy\x20dataset\x20by\x20id.\n\n\r\n\x05\x04^\x02\x01\x05\x12\x04\x83'\x02\
    \x08\n\r\n\x05\x04^\x02\x01\x01\x12\x04\x83'\t\x13\n\r\n\x05\x04^\x02\
    \x01\x03\x12\x04\x83'\x16\x17\n/\n\x04\x04^\x02\x02\x12\x04\x86'\x02\x20\
    \x1a!\x20Identify\x20dataset\x20version\x20by\x20id.\n\n\r\n\x05\x04^\
    \x02\x02\x05\x12\x04\x86'\x02\x08\n\r\n\x05\x04^\x02\x02\x01\x12\x04\x86\
    '\t\x1b\n\r\n\x05\x04^\x02\x02\x03\x12\x04\x86'\x1e\x1f\n\x86\x01\n\x04\
    \x04^\x02\x03\x12\x04\x8a'\x02,\x1ax\x20exports\x20is\x20the\x20list\x20\
    of\x20requested\x20dataset\x20version\x20exports.\n\x20Only\x20setting\
    \x20the\x20'format'\x20field\x20of\x20the\x20export\x20is\x20supported.\
    \n\n\r\n\x05\x04^\x02\x03\x04\x12\x04\x8a'\x02\n\n\r\n\x05\x04^\x02\x03\
    \x06\x12\x04\x8a'\x0b\x1f\n\r\n\x05\x04^\x02\x03\x01\x12\x04\x8a'\x20'\n\
    \r\n\x05\x04^\x02\x03\x03\x12\x04\x8a'*+\n\x0c\n\x02\x04_\x12\x06\x8d'\0\
    \x90'\x01\n\x0b\n\x03\x04_\x01\x12\x04\x8d'\x08#\n\x0c\n\x04\x04_\x02\0\
    \x12\x04\x8e'\x02(\n\r\n\x05\x04_\x02\0\x06\x12\x04\x8e'\x02\x1c\n\r\n\
    \x05\x04_\x02\0\x01\x12\x04\x8e'\x1d#\n\r\n\x05\x04_\x02\0\x03\x12\x04\
    \x8e'&'\n\x0c\n\x04\x04_\x02\x01\x12\x04\x8f'\x02^\n\r\n\x05\x04_\x02\
    \x01\x04\x12\x04\x8f'\x02\n\n\r\n\x05\x04_\x02\x01\x06\x12\x04\x8f'\x0b\
    \x19\n\r\n\x05\x04_\x02\x01\x01\x12\x04\x8f'\x1a*\n\r\n\x05\x04_\x02\x01\
    \x03\x12\x04\x8f'-.\n\r\n\x05\x04_\x02\x01\x08\x12\x04\x8f'/]\n\x10\n\
    \x08\x04_\x02\x01\x08\xd0\x86\x03\x12\x04\x8f'0\\\n\x0c\n\x02\x04`\x12\
    \x06\x92'\0\x95'\x01\n\x0b\n\x03\x04`\x01\x12\x04\x92'\x08)\n\x0c\n\x04\
    \x04`\x02\0\x12\x04\x93'\x02(\n\r\n\x05\x04`\x02\0\x06\x12\x04\x93'\x02\
    \x1c\n\r\n\x05\x04`\x02\0\x01\x12\x04\x93'\x1d#\n\r\n\x05\x04`\x02\0\x03\
    \x12\x04\x93'&'\n\x0c\n\x04\x04`\x02\x01\x12\x04\x94'\x02[\n\r\n\x05\x04\
    `\x02\x01\x04\x12\x04\x94'\x02\n\n\r\n\x05\x04`\x02\x01\x06\x12\x04\x94'\
    \x0b\x1f\n\r\n\x05\x04`\x02\x01\x01\x12\x04\x94'\x20'\n\r\n\x05\x04`\x02\
    \x01\x03\x12\x04\x94'*+\n\r\n\x05\x04`\x02\x01\x08\x12\x04\x94',Z\n\x10\
    \n\x08\x04`\x02\x01\x08\xd0\x86\x03\x12\x04\x94'-Y\n\x0c\n\x02\x04a\x12\
    \x06\x97'\0\x9a'\x01\n\x0b\n\x03\x04a\x01\x12\x04\x97'\x08/\n\x0c\n\x04\
    \x04a\x02\0\x12\x04\x98'\x02(\n\r\n\x05\x04a\x02\0\x06\x12\x04\x98'\x02\
    \x1c\n\r\n\x05\x04a\x02\0\x01\x12\x04\x98'\x1d#\n\r\n\x05\x04a\x02\0\x03\
    \x12\x04\x98'&'\n\x0c\n\x04\x04a\x02\x01\x12\x04\x99'\x02x\n\r\n\x05\x04\
    a\x02\x01\x04\x12\x04\x99'\x02\n\n\r\n\x05\x04a\x02\x01\x06\x12\x04\x99'\
    \x0b%\n\r\n\x05\x04a\x02\x01\x01\x12\x04\x99'&D\n\r\n\x05\x04a\x02\x01\
    \x03\x12\x04\x99'GH\n\r\n\x05\x04a\x02\x01\x08\x12\x04\x99'Iw\n\x10\n\
    \x08\x04a\x02\x01\x08\xd0\x86\x03\x12\x04\x99'Jv\n\x0c\n\x02\x04b\x12\
    \x06\x9c'\0\x9f'\x01\n\x0b\n\x03\x04b\x01\x12\x04\x9c'\x08$\n\x0c\n\x04\
    \x04b\x02\0\x12\x04\x9d'\x02(\n\r\n\x05\x04b\x02\0\x06\x12\x04\x9d'\x02\
    \x1c\n\r\n\x05\x04b\x02\0\x01\x12\x04\x9d'\x1d#\n\r\n\x05\x04b\x02\0\x03\
    \x12\x04\x9d'&'\n\x0c\n\x04\x04b\x02\x01\x12\x04\x9e'\x02%\n\r\n\x05\x04\
    b\x02\x01\x06\x12\x04\x9e'\x02\x10\n\r\n\x05\x04b\x02\x01\x01\x12\x04\
    \x9e'\x11\x20\n\r\n\x05\x04b\x02\x01\x03\x12\x04\x9e'#$\n\xcb\x01\n\x02\
    \x04c\x12\x06\xa5'\0\xb0'\x01\x1a\xbc\x01///////////////////////////////\
    ///////////////////\n\x20Model\x20prediction\x20related\x20stuff\x20need\
    s\x20inputs\x20and\x20produces\x20outputs.\n////////////////////////////\
    //////////////////////\n\x20Model\x20prediction.\n\n\x0b\n\x03\x04c\x01\
    \x12\x04\xa5'\x08\x1f\n\x0c\n\x04\x04c\x02\0\x12\x04\xa6'\x02,\n\r\n\x05\
    \x04c\x02\0\x06\x12\x04\xa6'\x02\x1b\n\r\n\x05\x04c\x02\0\x01\x12\x04\
    \xa6'\x1c'\n\r\n\x05\x04c\x02\0\x03\x12\x04\xa6'*+\n\x0c\n\x04\x04c\x02\
    \x01\x12\x04\xa7'\x02\x16\n\r\n\x05\x04c\x02\x01\x05\x12\x04\xa7'\x02\
    \x08\n\r\n\x05\x04c\x02\x01\x01\x12\x04\xa7'\t\x11\n\r\n\x05\x04c\x02\
    \x01\x03\x12\x04\xa7'\x14\x15\n\x0c\n\x04\x04c\x02\x02\x12\x04\xa8'\x02\
    \x18\n\r\n\x05\x04c\x02\x02\x05\x12\x04\xa8'\x02\x08\n\r\n\x05\x04c\x02\
    \x02\x01\x12\x04\xa8'\t\x13\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xa8'\x16\
    \x17\n\x0c\n\x04\x04c\x02\x03\x12\x04\xa9'\x02\x1c\n\r\n\x05\x04c\x02\
    \x03\x04\x12\x04\xa9'\x02\n\n\r\n\x05\x04c\x02\x03\x06\x12\x04\xa9'\x0b\
    \x10\n\r\n\x05\x04c\x02\x03\x01\x12\x04\xa9'\x11\x17\n\r\n\x05\x04c\x02\
    \x03\x03\x12\x04\xa9'\x1a\x1b\n\x88\x01\n\x04\x04c\x02\x04\x12\x04\xac'\
    \x02\x12\x1az\x20This\x20allows\x20you\x20to\x20specify\x20config\x20opt\
    ions\x20for\x20the\x20model\x20such\x20as\n\x20the\x20language\x20which\
    \x20appear's\x20in\x20the\x20model's\x20output_info.\n\n\r\n\x05\x04c\
    \x02\x04\x06\x12\x04\xac'\x02\x07\n\r\n\x05\x04c\x02\x04\x01\x12\x04\xac\
    '\x08\r\n\r\n\x05\x04c\x02\x04\x03\x12\x04\xac'\x10\x11\ni\n\x04\x04c\
    \x02\x05\x12\x04\xaf'\x02%\x1a[\x20Allow\x20filtering\x20of\x20predictio\
    n\x20requests\x20down\x20to\x20specific\x20Nodepools,\x20Deploymetns\x20\
    or\x20Runners\n\n\r\n\x05\x04c\x02\x05\x06\x12\x04\xaf'\x02\x10\n\r\n\
    \x05\x04c\x02\x05\x01\x12\x04\xaf'\x11\x20\n\r\n\x05\x04c\x02\x05\x03\
    \x12\x04\xaf'#$\nF\n\x02\x04d\x12\x06\xb3'\0\xbd'\x01\x1a8\x20Listing\
    \x20the\x20inputs\x20that\x20went\x20into\x20training\x20this\x20model.\
    \n\n\x0b\n\x03\x04d\x01\x12\x04\xb3'\x08\x1e\n\x0c\n\x04\x04d\x02\0\x12\
    \x04\xb4'\x02,\n\r\n\x05\x04d\x02\0\x06\x12\x04\xb4'\x02\x1b\n\r\n\x05\
    \x04d\x02\0\x01\x12\x04\xb4'\x1c'\n\r\n\x05\x04d\x02\0\x03\x12\x04\xb4'*\
    +\n\x0c\n\x04\x04d\x02\x01\x12\x04\xb5'\x02\x16\n\r\n\x05\x04d\x02\x01\
    \x05\x12\x04\xb5'\x02\x08\n\r\n\x05\x04d\x02\x01\x01\x12\x04\xb5'\t\x11\
    \n\r\n\x05\x04d\x02\x01\x03\x12\x04\xb5'\x14\x15\n\x0c\n\x04\x04d\x02\
    \x02\x12\x04\xb6'\x02\x18\n\r\n\x05\x04d\x02\x02\x05\x12\x04\xb6'\x02\
    \x08\n\r\n\x05\x04d\x02\x02\x01\x12\x04\xb6'\t\x13\n\r\n\x05\x04d\x02\
    \x02\x03\x12\x04\xb6'\x16\x17\n~\n\x04\x04d\x02\x03\x12\x04\xb9'\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04d\x02\x03\x05\x12\x04\xb9'\
    \x02\x08\n\r\n\x05\x04d\x02\x03\x01\x12\x04\xb9'\t\r\n\r\n\x05\x04d\x02\
    \x03\x03\x12\x04\xb9'\x10\x11\nu\n\x04\x04d\x02\x04\x12\x04\xbc'\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\r\n\x05\x04d\x02\x04\x05\x12\x04\xbc'\x02\x08\n\r\n\
    \x05\x04d\x02\x04\x01\x12\x04\xbc'\t\x11\n\r\n\x05\x04d\x02\x04\x03\x12\
    \x04\xbc'\x14\x15\n\x1d\n\x02\x04e\x12\x06\xc0'\0\xc3'\x01\x1a\x0f\x20Ge\
    tKeyRequest\n\n\x0b\n\x03\x04e\x01\x12\x04\xc0'\x08\x15\n\x0c\n\x04\x04e\
    \x02\0\x12\x04\xc1'\x02,\n\r\n\x05\x04e\x02\0\x06\x12\x04\xc1'\x02\x1b\n\
    \r\n\x05\x04e\x02\0\x01\x12\x04\xc1'\x1c'\n\r\n\x05\x04e\x02\0\x03\x12\
    \x04\xc1'*+\n\x0c\n\x04\x04e\x02\x01\x12\x04\xc2'\x02\x14\n\r\n\x05\x04e\
    \x02\x01\x05\x12\x04\xc2'\x02\x08\n\r\n\x05\x04e\x02\x01\x01\x12\x04\xc2\
    '\t\x0f\n\r\n\x05\x04e\x02\x01\x03\x12\x04\xc2'\x12\x13\n\x1f\n\x02\x04f\
    \x12\x06\xc6'\0\xd1'\x01\x1a\x11\x20ListKeysRequest\n\n\x0b\n\x03\x04f\
    \x01\x12\x04\xc6'\x08\x17\n\x0c\n\x04\x04f\x02\0\x12\x04\xc7'\x02,\n\r\n\
    \x05\x04f\x02\0\x06\x12\x04\xc7'\x02\x1b\n\r\n\x05\x04f\x02\0\x01\x12\
    \x04\xc7'\x1c'\n\r\n\x05\x04f\x02\0\x03\x12\x04\xc7'*+\n~\n\x04\x04f\x02\
    \x01\x12\x04\xca'\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\
    \x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\
    f\x02\x01\x05\x12\x04\xca'\x02\x08\n\r\n\x05\x04f\x02\x01\x01\x12\x04\
    \xca'\t\r\n\r\n\x05\x04f\x02\x01\x03\x12\x04\xca'\x10\x11\nu\n\x04\x04f\
    \x02\x02\x12\x04\xcd'\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04f\x02\x02\
    \x05\x12\x04\xcd'\x02\x08\n\r\n\x05\x04f\x02\x02\x01\x12\x04\xcd'\t\x11\
    \n\r\n\x05\x04f\x02\x02\x03\x12\x04\xcd'\x14\x15\n\x0c\n\x04\x04f\x02\
    \x03\x12\x04\xce'\x02\x17\n\r\n\x05\x04f\x02\x03\x05\x12\x04\xce'\x02\
    \x06\n\r\n\x05\x04f\x02\x03\x01\x12\x04\xce'\x07\x12\n\r\n\x05\x04f\x02\
    \x03\x03\x12\x04\xce'\x15\x16\n\x0c\n\x04\x04f\x02\x04\x12\x04\xcf'\x02\
    \x1d\n\r\n\x05\x04f\x02\x04\x04\x12\x04\xcf'\x02\n\n\r\n\x05\x04f\x02\
    \x04\x05\x12\x04\xcf'\x0b\x11\n\r\n\x05\x04f\x02\x04\x01\x12\x04\xcf'\
    \x12\x18\n\r\n\x05\x04f\x02\x04\x03\x12\x04\xcf'\x1b\x1c\n\x0c\n\x04\x04\
    f\x02\x05\x12\x04\xd0'\x02\x20\n\r\n\x05\x04f\x02\x05\x04\x12\x04\xd0'\
    \x02\n\n\r\n\x05\x04f\x02\x05\x05\x12\x04\xd0'\x0b\x11\n\r\n\x05\x04f\
    \x02\x05\x01\x12\x04\xd0'\x12\x1b\n\r\n\x05\x04f\x02\x05\x03\x12\x04\xd0\
    '\x1e\x1f\n\"\n\x02\x04g\x12\x06\xd4'\0\xdc'\x01\x1a\x14\x20ListAppKeysR\
    equest\n\n\x0b\n\x03\x04g\x01\x12\x04\xd4'\x08\x1a\n\x0c\n\x04\x04g\x02\
    \0\x12\x04\xd5'\x02,\n\r\n\x05\x04g\x02\0\x06\x12\x04\xd5'\x02\x1b\n\r\n\
    \x05\x04g\x02\0\x01\x12\x04\xd5'\x1c'\n\r\n\x05\x04g\x02\0\x03\x12\x04\
    \xd5'*+\n~\n\x04\x04g\x02\x01\x12\x04\xd8'\x02\x12\x1ap\x20(optional\x20\
    URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\
    \x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\
    \x201.\n\n\r\n\x05\x04g\x02\x01\x05\x12\x04\xd8'\x02\x08\n\r\n\x05\x04g\
    \x02\x01\x01\x12\x04\xd8'\t\r\n\r\n\x05\x04g\x02\x01\x03\x12\x04\xd8'\
    \x10\x11\nu\n\x04\x04g\x02\x02\x12\x04\xdb'\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\r\n\x05\x04g\x02\x02\x05\x12\x04\xdb'\x02\x08\n\r\n\x05\x04g\x02\x02\
    \x01\x12\x04\xdb'\t\x11\n\r\n\x05\x04g\x02\x02\x03\x12\x04\xdb'\x14\x15\
    \n\x1f\n\x02\x04h\x12\x06\xdf'\0\xe2'\x01\x1a\x11\x20PostKeysRequest\n\n\
    \x0b\n\x03\x04h\x01\x12\x04\xdf'\x08\x17\n\x0c\n\x04\x04h\x02\0\x12\x04\
    \xe0'\x02,\n\r\n\x05\x04h\x02\0\x06\x12\x04\xe0'\x02\x1b\n\r\n\x05\x04h\
    \x02\0\x01\x12\x04\xe0'\x1c'\n\r\n\x05\x04h\x02\0\x03\x12\x04\xe0'*+\n\
    \x0c\n\x04\x04h\x02\x01\x12\x04\xe1'\x02\x18\n\r\n\x05\x04h\x02\x01\x04\
    \x12\x04\xe1'\x02\n\n\r\n\x05\x04h\x02\x01\x06\x12\x04\xe1'\x0b\x0e\n\r\
    \n\x05\x04h\x02\x01\x01\x12\x04\xe1'\x0f\x13\n\r\n\x05\x04h\x02\x01\x03\
    \x12\x04\xe1'\x16\x17\n\x20\n\x02\x04i\x12\x06\xe5'\0\xe8'\x01\x1a\x12\
    \x20DeleteKeyRequest\n\n\x0b\n\x03\x04i\x01\x12\x04\xe5'\x08\x18\n\x0c\n\
    \x04\x04i\x02\0\x12\x04\xe6'\x02,\n\r\n\x05\x04i\x02\0\x06\x12\x04\xe6'\
    \x02\x1b\n\r\n\x05\x04i\x02\0\x01\x12\x04\xe6'\x1c'\n\r\n\x05\x04i\x02\0\
    \x03\x12\x04\xe6'*+\n\x0c\n\x04\x04i\x02\x01\x12\x04\xe7'\x02\x14\n\r\n\
    \x05\x04i\x02\x01\x05\x12\x04\xe7'\x02\x08\n\r\n\x05\x04i\x02\x01\x01\
    \x12\x04\xe7'\t\x0f\n\r\n\x05\x04i\x02\x01\x03\x12\x04\xe7'\x12\x13\n\
    \x20\n\x02\x04j\x12\x06\xeb'\0\xf2'\x01\x1a\x12\x20PatchKeysRequest\n\n\
    \x0b\n\x03\x04j\x01\x12\x04\xeb'\x08\x18\n\x0c\n\x04\x04j\x02\0\x12\x04\
    \xec'\x02,\n\r\n\x05\x04j\x02\0\x06\x12\x04\xec'\x02\x1b\n\r\n\x05\x04j\
    \x02\0\x01\x12\x04\xec'\x1c'\n\r\n\x05\x04j\x02\0\x03\x12\x04\xec'*+\n\
    \x0c\n\x04\x04j\x02\x01\x12\x04\xed'\x02\x18\n\r\n\x05\x04j\x02\x01\x04\
    \x12\x04\xed'\x02\n\n\r\n\x05\x04j\x02\x01\x06\x12\x04\xed'\x0b\x0e\n\r\
    \n\x05\x04j\x02\x01\x01\x12\x04\xed'\x0f\x13\n\r\n\x05\x04j\x02\x01\x03\
    \x12\x04\xed'\x16\x17\nj\n\x04\x04j\x02\x02\x12\x04\xf1'\x02\x14\x1a\\\
    \x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\
    \x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20supported\n\n\r\
    \n\x05\x04j\x02\x02\x05\x12\x04\xf1'\x02\x08\n\r\n\x05\x04j\x02\x02\x01\
    \x12\x04\xf1'\t\x0f\n\r\n\x05\x04j\x02\x02\x03\x12\x04\xf1'\x12\x13\n!\n\
    \x02\x04k\x12\x06\xf5'\0\xf8'\x01\x1a\x13\x20SingleKeyResponse\n\n\x0b\n\
    \x03\x04k\x01\x12\x04\xf5'\x08\x19\n\x0c\n\x04\x04k\x02\0\x12\x04\xf6'\
    \x02(\n\r\n\x05\x04k\x02\0\x06\x12\x04\xf6'\x02\x1c\n\r\n\x05\x04k\x02\0\
    \x01\x12\x04\xf6'\x1d#\n\r\n\x05\x04k\x02\0\x03\x12\x04\xf6'&'\n\x0c\n\
    \x04\x04k\x02\x01\x12\x04\xf7'\x02\x0e\n\r\n\x05\x04k\x02\x01\x06\x12\
    \x04\xf7'\x02\x05\n\r\n\x05\x04k\x02\x01\x01\x12\x04\xf7'\x06\t\n\r\n\
    \x05\x04k\x02\x01\x03\x12\x04\xf7'\x0c\r\n\x20\n\x02\x04l\x12\x06\xfb'\0\
    \xfe'\x01\x1a\x12\x20MultiKeyResponse\n\n\x0b\n\x03\x04l\x01\x12\x04\xfb\
    '\x08\x18\n\x0c\n\x04\x04l\x02\0\x12\x04\xfc'\x02(\n\r\n\x05\x04l\x02\0\
    \x06\x12\x04\xfc'\x02\x1c\n\r\n\x05\x04l\x02\0\x01\x12\x04\xfc'\x1d#\n\r\
    \n\x05\x04l\x02\0\x03\x12\x04\xfc'&'\n\x0c\n\x04\x04l\x02\x01\x12\x04\
    \xfd'\x02G\n\r\n\x05\x04l\x02\x01\x04\x12\x04\xfd'\x02\n\n\r\n\x05\x04l\
    \x02\x01\x06\x12\x04\xfd'\x0b\x0e\n\r\n\x05\x04l\x02\x01\x01\x12\x04\xfd\
    '\x0f\x13\n\r\n\x05\x04l\x02\x01\x03\x12\x04\xfd'\x16\x17\n\r\n\x05\x04l\
    \x02\x01\x08\x12\x04\xfd'\x18F\n\x10\n\x08\x04l\x02\x01\x08\xd0\x86\x03\
    \x12\x04\xfd'\x19E\n\x1f\n\x02\x04m\x12\x06\x89(\0\x93(\x01\x1a\x11\x20G\
    etModelRequest\n\n\x0b\n\x03\x04m\x01\x12\x04\x89(\x08\x17\n\x0c\n\x04\
    \x04m\x02\0\x12\x04\x8a(\x02,\n\r\n\x05\x04m\x02\0\x06\x12\x04\x8a(\x02\
    \x1b\n\r\n\x05\x04m\x02\0\x01\x12\x04\x8a(\x1c'\n\r\n\x05\x04m\x02\0\x03\
    \x12\x04\x8a(*+\n\x0c\n\x04\x04m\x02\x01\x12\x04\x8b(\x02\x16\n\r\n\x05\
    \x04m\x02\x01\x05\x12\x04\x8b(\x02\x08\n\r\n\x05\x04m\x02\x01\x01\x12\
    \x04\x8b(\t\x11\n\r\n\x05\x04m\x02\x01\x03\x12\x04\x8b(\x14\x15\nw\n\x04\
    \x04m\x02\x02\x12\x04\x8e(\x02\x18\x1ai\x20This\x20is\x20included\x20so\
    \x20that\x20we\x20can\x20re-use\x20this\x20request\x20for\x20multiple\n\
    \x20rpcs\x20with\x20and\x20without\x20the\x20version_id.\n\n\r\n\x05\x04\
    m\x02\x02\x05\x12\x04\x8e(\x02\x08\n\r\n\x05\x04m\x02\x02\x01\x12\x04\
    \x8e(\t\x13\n\r\n\x05\x04m\x02\x02\x03\x12\x04\x8e(\x16\x17\n\x0c\n\x04\
    \x04m\x02\x03\x12\x04\x8f(\x02\x16\n\r\n\x05\x04m\x02\x03\x05\x12\x04\
    \x8f(\x02\x08\n\r\n\x05\x04m\x02\x03\x01\x12\x04\x8f(\t\x11\n\r\n\x05\
    \x04m\x02\x03\x03\x12\x04\x8f(\x14\x15\n\x0c\n\x04\x04m\x02\x04\x12\x04\
    \x90(\x02\x1a\n\r\n\x05\x04m\x02\x04\x05\x12\x04\x90(\x02\x06\n\r\n\x05\
    \x04m\x02\x04\x01\x12\x04\x90(\x07\x15\n\r\n\x05\x04m\x02\x04\x03\x12\
    \x04\x90(\x18\x19\n\x95\x01\n\x04\x04m\x02\x05\x12\x04\x92(\x02)\x1a\x86\
    \x01\x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fi\
    elds\x20to\x20be\x20included\x20in\x20the\x20response.\x20Currently\x20s\
    upported:\x20all,\x20stars,\x20outputs,\x20presets\n\n\r\n\x05\x04m\x02\
    \x05\x04\x12\x04\x92(\x02\n\n\r\n\x05\x04m\x02\x05\x05\x12\x04\x92(\x0b\
    \x11\n\r\n\x05\x04m\x02\x05\x01\x12\x04\x92(\x12#\n\r\n\x05\x04m\x02\x05\
    \x03\x12\x04\x92(&(\n!\n\x02\x04n\x12\x06\x96(\0\xec(\x01\x1a\x13\x20Lis\
    tModelsRequest\n\n\x0b\n\x03\x04n\x01\x12\x04\x96(\x08\x19\n\x0b\n\x03\
    \x04n\t\x12\x04\x97(\x02\r\n\x0c\n\x04\x04n\t\0\x12\x04\x97(\x0b\x0c\n\r\
    \n\x05\x04n\t\0\x01\x12\x04\x97(\x0b\x0c\n\r\n\x05\x04n\t\0\x02\x12\x04\
    \x97(\x0b\x0c\n\x0c\n\x04\x04n\x02\0\x12\x04\x98(\x02,\n\r\n\x05\x04n\
    \x02\0\x06\x12\x04\x98(\x02\x1b\n\r\n\x05\x04n\x02\0\x01\x12\x04\x98(\
    \x1c'\n\r\n\x05\x04n\x02\0\x03\x12\x04\x98(*+\n~\n\x04\x04n\x02\x01\x12\
    \x04\x9b(\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04n\x02\x01\
    \x05\x12\x04\x9b(\x02\x08\n\r\n\x05\x04n\x02\x01\x01\x12\x04\x9b(\t\r\n\
    \r\n\x05\x04n\x02\x01\x03\x12\x04\x9b(\x10\x11\nu\n\x04\x04n\x02\x02\x12\
    \x04\x9e(\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20numbe\
    r\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20p\
    age.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04n\x02\x02\x05\x12\x04\
    \x9e(\x02\x08\n\r\n\x05\x04n\x02\x02\x01\x12\x04\x9e(\t\x11\n\r\n\x05\
    \x04n\x02\x02\x03\x12\x04\x9e(\x14\x15\n\x95\x01\n\x04\x04n\x02\x03\x12\
    \x04\xa1(\x02)\x1a\x86\x01\x20(optional\x20URL\x20parameter)\x20List\x20\
    of\x20additional\x20fields\x20to\x20be\x20included\x20in\x20the\x20respo\
    nse.\x20Currently\x20supported:\x20all,\x20stars,\x20outputs,\x20presets\
    \n\n\r\n\x05\x04n\x02\x03\x04\x12\x04\xa1(\x02\n\n\r\n\x05\x04n\x02\x03\
    \x05\x12\x04\xa1(\x0b\x11\n\r\n\x05\x04n\x02\x03\x01\x12\x04\xa1(\x12#\n\
    \r\n\x05\x04n\x02\x03\x03\x12\x04\xa1(&(\no\n\x04\x04n\x02\x04\x12\x04\
    \xa5(\x02\x1b\x1aa\x20Sorting\x20options:\n\x20Whether\x20to\x20sort\x20\
    in\x20ascending\x20order.\x20If\x20false,\x20will\x20order\x20in\x20desc\
    ending\x20order.\n\n\r\n\x05\x04n\x02\x04\x05\x12\x04\xa5(\x02\x06\n\r\n\
    \x05\x04n\x02\x04\x01\x12\x04\xa5(\x07\x15\n\r\n\x05\x04n\x02\x04\x03\
    \x12\x04\xa5(\x18\x1a\n\x0e\n\x04\x04n\x08\0\x12\x06\xa6(\x02\xb2(\x03\n\
    \r\n\x05\x04n\x08\0\x01\x12\x04\xa6(\x08\x0f\n,\n\x04\x04n\x02\x05\x12\
    \x04\xa8(\x04\x1b\x1a\x1e\x20Whether\x20to\x20order\x20by\x20the\x20name\
    \n\n\r\n\x05\x04n\x02\x05\x05\x12\x04\xa8(\x04\x08\n\r\n\x05\x04n\x02\
    \x05\x01\x12\x04\xa8(\t\x15\n\r\n\x05\x04n\x02\x05\x03\x12\x04\xa8(\x18\
    \x1a\nA\n\x04\x04n\x02\x06\x12\x04\xaa(\x04!\x1a3\x20Whether\x20to\x20or\
    der\x20by\x20the\x20number\x20of\x20training\x20inputs\n\n\r\n\x05\x04n\
    \x02\x06\x05\x12\x04\xaa(\x04\x08\n\r\n\x05\x04n\x02\x06\x01\x12\x04\xaa\
    (\t\x1b\n\r\n\x05\x04n\x02\x06\x03\x12\x04\xaa(\x1e\x20\n\x9d\x01\n\x04\
    \x04n\x02\x07\x12\x04\xad(\x04\"\x1a\x8e\x01\x20Whether\x20to\x20order\
    \x20by\x20the\x20modified_at\x20time\x20of\x20the\x20latest\x20model\x20\
    version.\n\x20If\x20none\x20of\x20the\x20sort\x20options\x20is\x20set\
    \x20to\x20true,\x20will\x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04n\
    \x02\x07\x05\x12\x04\xad(\x04\x08\n\r\n\x05\x04n\x02\x07\x01\x12\x04\xad\
    (\t\x1c\n\r\n\x05\x04n\x02\x07\x03\x12\x04\xad(\x1f!\n2\n\x04\x04n\x02\
    \x08\x12\x04\xaf(\x04!\x1a$\x20Whether\x20to\x20order\x20by\x20the\x20cr\
    eated_at\n\n\r\n\x05\x04n\x02\x08\x05\x12\x04\xaf(\x04\x08\n\r\n\x05\x04\
    n\x02\x08\x01\x12\x04\xaf(\t\x1b\n\r\n\x05\x04n\x02\x08\x03\x12\x04\xaf(\
    \x1e\x20\n2\n\x04\x04n\x02\t\x12\x04\xb1(\x04!\x1a$\x20Whether\x20to\x20\
    order\x20by\x20count\x20of\x20stars\n\n\r\n\x05\x04n\x02\t\x05\x12\x04\
    \xb1(\x04\x08\n\r\n\x05\x04n\x02\t\x01\x12\x04\xb1(\t\x1b\n\r\n\x05\x04n\
    \x02\t\x03\x12\x04\xb1(\x1e\x20\n\x8f\x01\n\x04\x04n\x02\n\x12\x04\xb7(\
    \x02\x1b\x1a\x80\x01\x20Filtering\x20options:\n\x20Filter\x20models\x20b\
    y\x20the\x20specific\x20model_type_id.\x20See\x20ListModelTypes\x20for\
    \x20the\x20list\x20of\x20ModelType.Id's\n\x20supported.\n\n\r\n\x05\x04n\
    \x02\n\x05\x12\x04\xb7(\x02\x08\n\r\n\x05\x04n\x02\n\x01\x12\x04\xb7(\t\
    \x16\n\r\n\x05\x04n\x02\n\x03\x12\x04\xb7(\x19\x1a\n|\n\x04\x04n\x02\x0b\
    \x12\x04\xb9(\x02\x18\x1an\x20If\x20true,\x20we\x20only\x20return\x20mod\
    els\x20that\x20have\x20the\x20status\x20MODEL_TRAINED,\x20which\x20inclu\
    des\x20non-trainable\x20model\x20types.\n\n\r\n\x05\x04n\x02\x0b\x05\x12\
    \x04\xb9(\x02\x06\n\r\n\x05\x04n\x02\x0b\x01\x12\x04\xb9(\x07\x13\n\r\n\
    \x05\x04n\x02\x0b\x03\x12\x04\xb9(\x16\x17\n\xb5\x01\n\x04\x04n\x02\x0c\
    \x12\x04\xbc(\x02#\x1a\xa6\x01\x20The\x20list\x20of\x20input\x20fields\
    \x20to\x20the\x20model.\n\x20For\x20example,\x20you\x20can\x20specify\
    \x20'image',\x20which\x20will\x20return\x20models\x20that\x20make\x20inf\
    erences\x20on\x20images\x20like\x20visual-classifier\x20models.\n\n\r\n\
    \x05\x04n\x02\x0c\x04\x12\x04\xbc(\x02\n\n\r\n\x05\x04n\x02\x0c\x05\x12\
    \x04\xbc(\x0b\x11\n\r\n\x05\x04n\x02\x0c\x01\x12\x04\xbc(\x12\x1e\n\r\n\
    \x05\x04n\x02\x0c\x03\x12\x04\xbc(!\"\n\x9e\x01\n\x04\x04n\x02\r\x12\x04\
    \xbf(\x02$\x1a\x8f\x01\x20The\x20list\x20of\x20output\x20fields\x20to\
    \x20the\x20model.\n\x20For\x20example,\x20you\x20can\x20specify\x20'regi\
    ons[...].data.concepts',\x20which\x20will\x20return\x20visual-detector\
    \x20models.\n\n\r\n\x05\x04n\x02\r\x04\x12\x04\xbf(\x02\n\n\r\n\x05\x04n\
    \x02\r\x05\x12\x04\xbf(\x0b\x11\n\r\n\x05\x04n\x02\r\x01\x12\x04\xbf(\
    \x12\x1f\n\r\n\x05\x04n\x02\r\x03\x12\x04\xbf(\"#\n:\n\x04\x04n\x02\x0e\
    \x12\x04\xc1(\x02\x16\x1a,\x20Filter\x20by\x20the\x20license\x20of\x20th\
    e\x20model\x20version\n\n\r\n\x05\x04n\x02\x0e\x05\x12\x04\xc1(\x02\x08\
    \n\r\n\x05\x04n\x02\x0e\x01\x12\x04\xc1(\t\x10\n\r\n\x05\x04n\x02\x0e\
    \x03\x12\x04\xc1(\x13\x15\nT\n\x04\x04n\x02\x0f\x12\x04\xc3(\x02\x1a\x1a\
    F\x20If\x20true,\x20we\x20only\x20return\x20models\x20that\x20are\x20han\
    dpicked\x20by\x20clarifai\x20staff\n\n\r\n\x05\x04n\x02\x0f\x05\x12\x04\
    \xc3(\x02\x06\n\r\n\x05\x04n\x02\x0f\x01\x12\x04\xc3(\x07\x14\n\r\n\x05\
    \x04n\x02\x0f\x03\x12\x04\xc3(\x17\x19\nV\n\x04\x04n\x02\x10\x12\x04\xc5\
    (\x02\x19\x1aH\x20If\x20true,\x20we\x20only\x20return\x20models\x20that\
    \x20are\x20starred\x20by\x20the\x20requesting\x20user\n\n\r\n\x05\x04n\
    \x02\x10\x05\x12\x04\xc5(\x02\x06\n\r\n\x05\x04n\x02\x10\x01\x12\x04\xc5\
    (\x07\x13\n\r\n\x05\x04n\x02\x10\x03\x12\x04\xc5(\x16\x18\n1\n\x04\x04n\
    \x02\x11\x12\x04\xc7(\x02\x20\x1a#\x20List\x20of\x20toolkit\x20tags\x20t\
    o\x20filter\x20by\n\n\r\n\x05\x04n\x02\x11\x04\x12\x04\xc7(\x02\n\n\r\n\
    \x05\x04n\x02\x11\x05\x12\x04\xc7(\x0b\x11\n\r\n\x05\x04n\x02\x11\x01\
    \x12\x04\xc7(\x12\x1a\n\r\n\x05\x04n\x02\x11\x03\x12\x04\xc7(\x1d\x1f\n2\
    \n\x04\x04n\x02\x12\x12\x04\xc9(\x02!\x1a$\x20List\x20of\x20use_case\x20\
    tags\x20to\x20filter\x20by\n\n\r\n\x05\x04n\x02\x12\x04\x12\x04\xc9(\x02\
    \n\n\r\n\x05\x04n\x02\x12\x05\x12\x04\xc9(\x0b\x11\n\r\n\x05\x04n\x02\
    \x12\x01\x12\x04\xc9(\x12\x1b\n\r\n\x05\x04n\x02\x12\x03\x12\x04\xc9(\
    \x1e\x20\n2\n\x04\x04n\x02\x13\x12\x04\xcb(\x02!\x1a$\x20List\x20of\x20l\
    anguage\x20tags\x20to\x20filter\x20by\n\n\r\n\x05\x04n\x02\x13\x04\x12\
    \x04\xcb(\x02\n\n\r\n\x05\x04n\x02\x13\x05\x12\x04\xcb(\x0b\x11\n\r\n\
    \x05\x04n\x02\x13\x01\x12\x04\xcb(\x12\x1b\n\r\n\x05\x04n\x02\x13\x03\
    \x12\x04\xcb(\x1e\x20\n\x96\x02\n\x04\x04n\x02\x14\x12\x04\xce(\x02!\x1a\
    \x87\x02\x20Old\x20API\x20behavior\x20resulted\x20in\x20returning\x20cla\
    rifai\x20main\x20models\x20when\x20calling\x20ListModels\x20while\x20sco\
    ped\x20to\x20an\x20app.\x20While\x20we\x20transition\n\x20away\x20from\
    \x20that,\x20we\x20can\x20use\x20this\x20flag\x20to\x20not\x20always\x20\
    fetch\x20clarifai\x20main\x20models,\x20unless\x20that\x20is\x20the\x20a\
    pp\x20we\x20are\x20explicitly\x20listing\x20for.\n\n\r\n\x05\x04n\x02\
    \x14\x05\x12\x04\xce(\x02\x06\n\r\n\x05\x04n\x02\x14\x01\x12\x04\xce(\
    \x07\x1b\n\r\n\x05\x04n\x02\x14\x03\x12\x04\xce(\x1e\x20\n\x88\x02\n\x04\
    \x04n\x02\x15\x12\x04\xd2(\x02\x15\x1a\xf9\x01\x20Filter\x20models\x20by\
    \x20bookmark.\x20If\x20set,\x20only\x20return\x20bookmarked\x20models.\
    \x20Otherwise\x20none\x20bookmarked\x20models\x20only.\n\x20Note:\x20you\
    \x20can\x20not\x20filter\x20`trained_only`\x20and\x20bookmark\x20at\x20t\
    he\x20same\x20time.\n\x20When\x20filter\x20by\x20bookmark,\x20we\x20will\
    \x20return\x20trained\x20and\x20untrained\x20models.\n\n\r\n\x05\x04n\
    \x02\x15\x05\x12\x04\xd2(\x02\x06\n\r\n\x05\x04n\x02\x15\x01\x12\x04\xd2\
    (\x07\x0f\n\r\n\x05\x04n\x02\x15\x03\x12\x04\xd2(\x12\x14\n\xb4\x04\n\
    \x04\x04n\x02\x16\x12\x04\xe2(\x02\x15\x1a\xa5\x04\x20Searching\x20optio\
    ns:\n\x20Specify\x20a\x20search\x20parameter\x20in\x20order\x20to\x20per\
    form\x20keyword\x20search\x20on\x20the\n\x20following\x20fields\x20of\
    \x20the\x20model:\n\x20\x20\x20-\x20id\n\x20\x20\x20-\x20name\n\x20\x20\
    \x20-\x20description\n\x20\x20\x20-\x20notes\n\x20\x20\x20-\x20user_id\
    \x20(unless\x20user_app_id.user_id\x20is\x20already\x20set)\n\n\x20Keywo\
    rds\x20are\x20both\x20normalized\x20for\x20search\x20(so\x20searching\
    \x20for\x20\"satisfy\"\x20matches\x20\"satisfied\")\n\x20and\x20used\x20\
    for\x20partial\x20prefix-matching\x20(so\x20searching\x20for\x20\"clari\
    \"\x20matches\x20\"clarifai\").\n\n\x20NOTE:\x20Both\x20the\x20list\x20o\
    f\x20fields\x20searched\x20and\x20the\x20exact\x20keyword\x20matching\n\
    \x20rules\x20are\x20subject\x20to\x20change\x20and\x20not\x20guaranteed\
    \x20to\x20be\x20backwards-compatible.\n\n\r\n\x05\x04n\x02\x16\x05\x12\
    \x04\xe2(\x02\x08\n\r\n\x05\x04n\x02\x16\x01\x12\x04\xe2(\t\x0f\n\r\n\
    \x05\x04n\x02\x16\x03\x12\x04\xe2(\x12\x14\n\xde\x01\n\x04\x04n\x02\x17\
    \x12\x04\xe5(\x02(\x1a\xcf\x01\x20Query\x20name,\x20description\x20and\
    \x20id\x20fields,\x20that\x20can\x20contain\x20the\x20words\x20in\x20the\
    \x20query\x20string.\x20Does\x20NOT\x20support\x20wildcards\x20-\x20full\
    \x20words\x20only.\x20Supports\x20operators\x20\"OR\"\x20and\x20\"-\"\
    \x20as\x20NOT.\n\x20Deprecated:\x20use\x20search\x20instead.\n\n\r\n\x05\
    \x04n\x02\x17\x05\x12\x04\xe5(\x02\x08\n\r\n\x05\x04n\x02\x17\x01\x12\
    \x04\xe5(\t\x0e\n\r\n\x05\x04n\x02\x17\x03\x12\x04\xe5(\x11\x13\n\r\n\
    \x05\x04n\x02\x17\x08\x12\x04\xe5(\x14'\n\x0e\n\x06\x04n\x02\x17\x08\x03\
    \x12\x04\xe5(\x15&\n\xad\x01\n\x04\x04n\x02\x18\x12\x04\xe8(\x02&\x1a\
    \x9e\x01\x20Filter\x20by\x20the\x20description\x20and\x20id\x20of\x20the\
    \x20model.\x20This\x20supports\x20wildcard\x20queries\x20like\x20\"gen*\
    \"\x20to\x20match\x20\"general\"\x20as\x20an\x20example.\n\x20Deprecated\
    :\x20use\x20search\x20instead.\n\n\r\n\x05\x04n\x02\x18\x05\x12\x04\xe8(\
    \x02\x08\n\r\n\x05\x04n\x02\x18\x01\x12\x04\xe8(\t\r\n\r\n\x05\x04n\x02\
    \x18\x03\x12\x04\xe8(\x10\x11\n\r\n\x05\x04n\x02\x18\x08\x12\x04\xe8(\
    \x12%\n\x0e\n\x06\x04n\x02\x18\x08\x03\x12\x04\xe8(\x13$\n\x9c\x01\n\x04\
    \x04n\x02\x19\x12\x04\xeb(\x022\x1a\x8d\x01\x20Extends\x20the\x20name\
    \x20filter\x20to\x20include\x20the\x20user_id\x20of\x20the\x20applicatio\
    n\x20owner\x20that\x20the\x20model\x20belongs\x20to.\n\x20Deprecated:\
    \x20use\x20search\x20instead\x20of\x20name.\n\n\r\n\x05\x04n\x02\x19\x05\
    \x12\x04\xeb(\x02\x06\n\r\n\x05\x04n\x02\x19\x01\x12\x04\xeb(\x07\x18\n\
    \r\n\x05\x04n\x02\x19\x03\x12\x04\xeb(\x1b\x1d\n\r\n\x05\x04n\x02\x19\
    \x08\x12\x04\xeb(\x1e1\n\x0e\n\x06\x04n\x02\x19\x08\x03\x12\x04\xeb(\x1f\
    0\n$\n\x02\x04o\x12\x06\xef(\0\xf1(\x01\x1a\x16\x20ResourceCountRequest\
    \n\n\x0b\n\x03\x04o\x01\x12\x04\xef(\x08\x20\n\x0c\n\x04\x04o\x02\0\x12\
    \x04\xf0(\x02,\n\r\n\x05\x04o\x02\0\x06\x12\x04\xf0(\x02\x1b\n\r\n\x05\
    \x04o\x02\0\x01\x12\x04\xf0(\x1c'\n\r\n\x05\x04o\x02\0\x03\x12\x04\xf0(*\
    +\n%\n\x02\x04p\x12\x06\xf4(\0\xfb(\x01\x1a\x17\x20ResourceCountResponse\
    \n\n\x0b\n\x03\x04p\x01\x12\x04\xf4(\x08!\n\x0c\n\x04\x04p\x02\0\x12\x04\
    \xf5(\x02(\n\r\n\x05\x04p\x02\0\x06\x12\x04\xf5(\x02\x1c\n\r\n\x05\x04p\
    \x02\0\x01\x12\x04\xf5(\x1d#\n\r\n\x05\x04p\x02\0\x03\x12\x04\xf5(&'\n\
    \x0c\n\x04\x04p\x02\x01\x12\x04\xf6(\x02\x15\n\r\n\x05\x04p\x02\x01\x05\
    \x12\x04\xf6(\x02\x07\n\r\n\x05\x04p\x02\x01\x01\x12\x04\xf6(\x08\x10\n\
    \r\n\x05\x04p\x02\x01\x03\x12\x04\xf6(\x13\x14\n\x0c\n\x04\x04p\x02\x02\
    \x12\x04\xf7(\x02\x13\n\r\n\x05\x04p\x02\x02\x05\x12\x04\xf7(\x02\x07\n\
    \r\n\x05\x04p\x02\x02\x01\x12\x04\xf7(\x08\x0e\n\r\n\x05\x04p\x02\x02\
    \x03\x12\x04\xf7(\x11\x12\n\x0c\n\x04\x04p\x02\x03\x12\x04\xf8(\x02\x16\
    \n\r\n\x05\x04p\x02\x03\x05\x12\x04\xf8(\x02\x07\n\r\n\x05\x04p\x02\x03\
    \x01\x12\x04\xf8(\x08\x11\n\r\n\x05\x04p\x02\x03\x03\x12\x04\xf8(\x14\
    \x15\n\x0c\n\x04\x04p\x02\x04\x12\x04\xf9(\x02\x14\n\r\n\x05\x04p\x02\
    \x04\x05\x12\x04\xf9(\x02\x07\n\r\n\x05\x04p\x02\x04\x01\x12\x04\xf9(\
    \x08\x0f\n\r\n\x05\x04p\x02\x04\x03\x12\x04\xf9(\x12\x13\n\x0c\n\x04\x04\
    p\x02\x05\x12\x04\xfa(\x02\x13\n\r\n\x05\x04p\x02\x05\x05\x12\x04\xfa(\
    \x02\x07\n\r\n\x05\x04p\x02\x05\x01\x12\x04\xfa(\x08\x0e\n\r\n\x05\x04p\
    \x02\x05\x03\x12\x04\xfa(\x11\x12\n\x0c\n\x02\x04q\x12\x06\xfd(\0\x85)\
    \x01\n\x0b\n\x03\x04q\x01\x12\x04\xfd(\x08!\n\x0c\n\x04\x04q\x02\0\x12\
    \x04\xfe(\x02,\n\r\n\x05\x04q\x02\0\x06\x12\x04\xfe(\x02\x1b\n\r\n\x05\
    \x04q\x02\0\x01\x12\x04\xfe(\x1c'\n\r\n\x05\x04q\x02\0\x03\x12\x04\xfe(*\
    +\n\x0c\n\x04\x04q\x02\x01\x12\x04\x80)\x02\x16\n\r\n\x05\x04q\x02\x01\
    \x05\x12\x04\x80)\x02\x08\n\r\n\x05\x04q\x02\x01\x01\x12\x04\x80)\t\x11\
    \n\r\n\x05\x04q\x02\x01\x03\x12\x04\x80)\x14\x15\n\x0c\n\x04\x04q\x02\
    \x02\x12\x04\x82)\x02\x1f\n\r\n\x05\x04q\x02\x02\x04\x12\x04\x82)\x02\n\
    \n\r\n\x05\x04q\x02\x02\x05\x12\x04\x82)\x0b\x11\n\r\n\x05\x04q\x02\x02\
    \x01\x12\x04\x82)\x12\x1a\n\r\n\x05\x04q\x02\x02\x03\x12\x04\x82)\x1d\
    \x1e\n\"\n\x04\x04q\x02\x03\x12\x04\x84)\x02\x14\x1a\x14overwrite\x20sup\
    ported\n\n\r\n\x05\x04q\x02\x03\x05\x12\x04\x84)\x02\x08\n\r\n\x05\x04q\
    \x02\x03\x01\x12\x04\x84)\t\x0f\n\r\n\x05\x04q\x02\x03\x03\x12\x04\x84)\
    \x12\x13\n.\n\x02\x04r\x12\x06\x88)\0\x90)\x01\x1a\x20\x20PatchModelChec\
    kConsentsRequest\n\n\x0b\n\x03\x04r\x01\x12\x04\x88)\x08&\n\x0c\n\x04\
    \x04r\x02\0\x12\x04\x89)\x02,\n\r\n\x05\x04r\x02\0\x06\x12\x04\x89)\x02\
    \x1b\n\r\n\x05\x04r\x02\0\x01\x12\x04\x89)\x1c'\n\r\n\x05\x04r\x02\0\x03\
    \x12\x04\x89)*+\n\x1c\n\x04\x04r\x02\x01\x12\x04\x8b)\x02\x16\x1a\x0e\
    \x20the\x20model\x20id\n\n\r\n\x05\x04r\x02\x01\x05\x12\x04\x8b)\x02\x08\
    \n\r\n\x05\x04r\x02\x01\x01\x12\x04\x8b)\t\x11\n\r\n\x05\x04r\x02\x01\
    \x03\x12\x04\x8b)\x14\x15\n\x1c\n\x04\x04r\x02\x02\x12\x04\x8d)\x02%\x1a\
    \x0e\x20the\x20consents\n\n\r\n\x05\x04r\x02\x02\x04\x12\x04\x8d)\x02\n\
    \n\r\n\x05\x04r\x02\x02\x05\x12\x04\x8d)\x0b\x11\n\r\n\x05\x04r\x02\x02\
    \x01\x12\x04\x8d)\x12\x20\n\r\n\x05\x04r\x02\x02\x03\x12\x04\x8d)#$\n\"\
    \n\x04\x04r\x02\x03\x12\x04\x8f)\x02\x14\x1a\x14overwrite\x20supported\n\
    \n\r\n\x05\x04r\x02\x03\x05\x12\x04\x8f)\x02\x08\n\r\n\x05\x04r\x02\x03\
    \x01\x12\x04\x8f)\t\x0f\n\r\n\x05\x04r\x02\x03\x03\x12\x04\x8f)\x12\x13\
    \n\x0c\n\x02\x04s\x12\x06\x92)\0\x9a)\x01\n\x0b\n\x03\x04s\x01\x12\x04\
    \x92)\x08!\n\x0c\n\x04\x04s\x02\0\x12\x04\x93)\x02,\n\r\n\x05\x04s\x02\0\
    \x06\x12\x04\x93)\x02\x1b\n\r\n\x05\x04s\x02\0\x01\x12\x04\x93)\x1c'\n\r\
    \n\x05\x04s\x02\0\x03\x12\x04\x93)*+\n\x0c\n\x04\x04s\x02\x01\x12\x04\
    \x95)\x02\x16\n\r\n\x05\x04s\x02\x01\x05\x12\x04\x95)\x02\x08\n\r\n\x05\
    \x04s\x02\x01\x01\x12\x04\x95)\t\x11\n\r\n\x05\x04s\x02\x01\x03\x12\x04\
    \x95)\x14\x15\n\x0c\n\x04\x04s\x02\x02\x12\x04\x97)\x02\x1f\n\r\n\x05\
    \x04s\x02\x02\x04\x12\x04\x97)\x02\n\n\r\n\x05\x04s\x02\x02\x05\x12\x04\
    \x97)\x0b\x11\n\r\n\x05\x04s\x02\x02\x01\x12\x04\x97)\x12\x1a\n\r\n\x05\
    \x04s\x02\x02\x03\x12\x04\x97)\x1d\x1e\n\"\n\x04\x04s\x02\x03\x12\x04\
    \x99)\x02\x14\x1a\x14overwrite\x20supported\n\n\r\n\x05\x04s\x02\x03\x05\
    \x12\x04\x99)\x02\x08\n\r\n\x05\x04s\x02\x03\x01\x12\x04\x99)\t\x0f\n\r\
    \n\x05\x04s\x02\x03\x03\x12\x04\x99)\x12\x13\n\x0c\n\x02\x04t\x12\x06\
    \x9c)\0\xa4)\x01\n\x0b\n\x03\x04t\x01\x12\x04\x9c)\x08\"\n\x0c\n\x04\x04\
    t\x02\0\x12\x04\x9d)\x02,\n\r\n\x05\x04t\x02\0\x06\x12\x04\x9d)\x02\x1b\
    \n\r\n\x05\x04t\x02\0\x01\x12\x04\x9d)\x1c'\n\r\n\x05\x04t\x02\0\x03\x12\
    \x04\x9d)*+\n\x0c\n\x04\x04t\x02\x01\x12\x04\x9f)\x02\x16\n\r\n\x05\x04t\
    \x02\x01\x05\x12\x04\x9f)\x02\x08\n\r\n\x05\x04t\x02\x01\x01\x12\x04\x9f\
    )\t\x11\n\r\n\x05\x04t\x02\x01\x03\x12\x04\x9f)\x14\x15\n\x0c\n\x04\x04t\
    \x02\x02\x12\x04\xa1)\x02\x20\n\r\n\x05\x04t\x02\x02\x04\x12\x04\xa1)\
    \x02\n\n\r\n\x05\x04t\x02\x02\x05\x12\x04\xa1)\x0b\x11\n\r\n\x05\x04t\
    \x02\x02\x01\x12\x04\xa1)\x12\x1b\n\r\n\x05\x04t\x02\x02\x03\x12\x04\xa1\
    )\x1e\x1f\n(\n\x04\x04t\x02\x03\x12\x04\xa3)\x02\x14\x1a\x1a\x20Only\x20\
    overwrite\x20supported\n\n\r\n\x05\x04t\x02\x03\x05\x12\x04\xa3)\x02\x08\
    \n\r\n\x05\x04t\x02\x03\x01\x12\x04\xa3)\t\x0f\n\r\n\x05\x04t\x02\x03\
    \x03\x12\x04\xa3)\x12\x13\n\x0c\n\x02\x04u\x12\x06\xa8)\0\xab)\x01\n\x0b\
    \n\x03\x04u\x01\x12\x04\xa8)\x08!\n\x0c\n\x04\x04u\x02\0\x12\x04\xa9)\
    \x02(\n\r\n\x05\x04u\x02\0\x06\x12\x04\xa9)\x02\x1c\n\r\n\x05\x04u\x02\0\
    \x01\x12\x04\xa9)\x1d#\n\r\n\x05\x04u\x02\0\x03\x12\x04\xa9)&'\n\x0c\n\
    \x04\x04u\x02\x01\x12\x04\xaa)\x02\x1f\n\r\n\x05\x04u\x02\x01\x04\x12\
    \x04\xaa)\x02\n\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xaa)\x0b\x11\n\r\n\
    \x05\x04u\x02\x01\x01\x12\x04\xaa)\x12\x1a\n\r\n\x05\x04u\x02\x01\x03\
    \x12\x04\xaa)\x1d\x1e\n\x0c\n\x02\x04v\x12\x06\xad)\0\xb0)\x01\n\x0b\n\
    \x03\x04v\x01\x12\x04\xad)\x08&\n\x0c\n\x04\x04v\x02\0\x12\x04\xae)\x02(\
    \n\r\n\x05\x04v\x02\0\x06\x12\x04\xae)\x02\x1c\n\r\n\x05\x04v\x02\0\x01\
    \x12\x04\xae)\x1d#\n\r\n\x05\x04v\x02\0\x03\x12\x04\xae)&'\n\x0c\n\x04\
    \x04v\x02\x01\x12\x04\xaf)\x02%\n\r\n\x05\x04v\x02\x01\x04\x12\x04\xaf)\
    \x02\n\n\r\n\x05\x04v\x02\x01\x05\x12\x04\xaf)\x0b\x11\n\r\n\x05\x04v\
    \x02\x01\x01\x12\x04\xaf)\x12\x20\n\r\n\x05\x04v\x02\x01\x03\x12\x04\xaf\
    )#$\n\x0c\n\x02\x04w\x12\x06\xb2)\0\xb5)\x01\n\x0b\n\x03\x04w\x01\x12\
    \x04\xb2)\x08!\n\x0c\n\x04\x04w\x02\0\x12\x04\xb3)\x02(\n\r\n\x05\x04w\
    \x02\0\x06\x12\x04\xb3)\x02\x1c\n\r\n\x05\x04w\x02\0\x01\x12\x04\xb3)\
    \x1d#\n\r\n\x05\x04w\x02\0\x03\x12\x04\xb3)&'\n\x0c\n\x04\x04w\x02\x01\
    \x12\x04\xb4)\x02\x1f\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xb4)\x02\n\n\r\
    \n\x05\x04w\x02\x01\x05\x12\x04\xb4)\x0b\x11\n\r\n\x05\x04w\x02\x01\x01\
    \x12\x04\xb4)\x12\x1a\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xb4)\x1d\x1e\n\
    \x0c\n\x02\x04x\x12\x06\xb7)\0\xba)\x01\n\x0b\n\x03\x04x\x01\x12\x04\xb7\
    )\x08\"\n\x0c\n\x04\x04x\x02\0\x12\x04\xb8)\x02(\n\r\n\x05\x04x\x02\0\
    \x06\x12\x04\xb8)\x02\x1c\n\r\n\x05\x04x\x02\0\x01\x12\x04\xb8)\x1d#\n\r\
    \n\x05\x04x\x02\0\x03\x12\x04\xb8)&'\n\x0c\n\x04\x04x\x02\x01\x12\x04\
    \xb9)\x02\x20\n\r\n\x05\x04x\x02\x01\x04\x12\x04\xb9)\x02\n\n\r\n\x05\
    \x04x\x02\x01\x05\x12\x04\xb9)\x0b\x11\n\r\n\x05\x04x\x02\x01\x01\x12\
    \x04\xb9)\x12\x1b\n\r\n\x05\x04x\x02\x01\x03\x12\x04\xb9)\x1e\x1f\n!\n\
    \x02\x04y\x12\x06\xbd)\0\xc7)\x01\x1a\x13\x20PostModelsRequest\n\n\x0b\n\
    \x03\x04y\x01\x12\x04\xbd)\x08\x19\n\x0c\n\x04\x04y\x02\0\x12\x04\xbe)\
    \x02,\n\r\n\x05\x04y\x02\0\x06\x12\x04\xbe)\x02\x1b\n\r\n\x05\x04y\x02\0\
    \x01\x12\x04\xbe)\x1c'\n\r\n\x05\x04y\x02\0\x03\x12\x04\xbe)*+\n\x91\x02\
    \n\x04\x04y\x02\x01\x12\x04\xc4)\x02&\x1a\x82\x02\x20NOTE:\x20inconsiste\
    nt\x20since\x20\"model\"\x20is\x20not\x20plural,\x20please\x20use\x20\"m\
    odels\"\x20below.\n\x20Previously\x20you\x20could\x20only\x20create\x20o\
    ne\x20model\x20at\x20a\x20time.\n\x20We\x20still\x20support\x20this\x20b\
    ut\x20you\x20should\x20pass\x20it\x20as\x20models=[model]\x20so\n\x20tha\
    t\x20this\x20endpoint\x20is\x20consistent\x20with\x20the\x20rest\x20of\
    \x20our\x20API.\n\n\r\n\x05\x04y\x02\x01\x06\x12\x04\xc4)\x02\x07\n\r\n\
    \x05\x04y\x02\x01\x01\x12\x04\xc4)\x08\r\n\r\n\x05\x04y\x02\x01\x03\x12\
    \x04\xc4)\x10\x11\n\r\n\x05\x04y\x02\x01\x08\x12\x04\xc4)\x12%\n\x0e\n\
    \x06\x04y\x02\x01\x08\x03\x12\x04\xc4)\x13$\nU\n\x04\x04y\x02\x02\x12\
    \x04\xc6)\x02\x1c\x1aG\x20This\x20allows\x20you\x20to\x20create\x20one\
    \x20or\x20more\x20model\x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\
    \r\n\x05\x04y\x02\x02\x04\x12\x04\xc6)\x02\n\n\r\n\x05\x04y\x02\x02\x06\
    \x12\x04\xc6)\x0b\x10\n\r\n\x05\x04y\x02\x02\x01\x12\x04\xc6)\x11\x17\n\
    \r\n\x05\x04y\x02\x02\x03\x12\x04\xc6)\x1a\x1b\n\"\n\x02\x04z\x12\x06\
    \xca)\0\xd5)\x01\x1a\x14\x20PatchModelsRequest\n\n\x0b\n\x03\x04z\x01\
    \x12\x04\xca)\x08\x1a\n\x0c\n\x04\x04z\x02\0\x12\x04\xcb)\x02,\n\r\n\x05\
    \x04z\x02\0\x06\x12\x04\xcb)\x02\x1b\n\r\n\x05\x04z\x02\0\x01\x12\x04\
    \xcb)\x1c'\n\r\n\x05\x04z\x02\0\x03\x12\x04\xcb)*+\n\x0c\n\x04\x04z\x02\
    \x01\x12\x04\xcc)\x02\x1c\n\r\n\x05\x04z\x02\x01\x04\x12\x04\xcc)\x02\n\
    \n\r\n\x05\x04z\x02\x01\x06\x12\x04\xcc)\x0b\x10\n\r\n\x05\x04z\x02\x01\
    \x01\x12\x04\xcc)\x11\x17\n\r\n\x05\x04z\x02\x01\x03\x12\x04\xcc)\x1a\
    \x1b\n\xd8\x02\n\x04\x04z\x02\x02\x12\x04\xd4)\x02\x14\x1a\xc9\x02\x20Th\
    e\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\
    \x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\
    \x20supported\n\n\x20Note\x20that\x20'remove'\x20can\x20be\x20used\x20to\
    \x20remove\x20the\x20model\x20image\x20by\x20setting\n\x20'image.url'\
    \x20in\x20the\x20request\x20to\x20the\x20current\x20value\x20returned\
    \x20for\x20that\x20model.\n\x20This\x20cannot\x20be\x20used\x20in\x20a\
    \x20request\x20that\x20is\x20patching\x20other\x20fields\x20as\x20well.\
    \n\n\r\n\x05\x04z\x02\x02\x05\x12\x04\xd4)\x02\x08\n\r\n\x05\x04z\x02\
    \x02\x01\x12\x04\xd4)\t\x0f\n\r\n\x05\x04z\x02\x02\x03\x12\x04\xd4)\x12\
    \x13\n\x0c\n\x02\x04{\x12\x06\xd7)\0\xdc)\x01\n\x0b\n\x03\x04{\x01\x12\
    \x04\xd7)\x08\x16\n\x15\n\x04\x04{\x02\0\x12\x04\xd9)\x02\x10\x1a\x07old\
    \x20id\n\n\r\n\x05\x04{\x02\0\x05\x12\x04\xd9)\x02\x08\n\r\n\x05\x04{\
    \x02\0\x01\x12\x04\xd9)\t\x0b\n\r\n\x05\x04{\x02\0\x03\x12\x04\xd9)\x0e\
    \x0f\n\x15\n\x04\x04{\x02\x01\x12\x04\xdb)\x02\x14\x1a\x07new\x20id\n\n\
    \r\n\x05\x04{\x02\x01\x05\x12\x04\xdb)\x02\x08\n\r\n\x05\x04{\x02\x01\
    \x01\x12\x04\xdb)\t\x0f\n\r\n\x05\x04{\x02\x01\x03\x12\x04\xdb)\x12\x13\
    \n$\n\x02\x04|\x12\x06\xdf)\0\xe8)\x01\x1a\x16\x20PatchModelIdsRequest\n\
    \n\x0b\n\x03\x04|\x01\x12\x04\xdf)\x08\x1c\n\x0c\n\x04\x04|\x02\0\x12\
    \x04\xe0)\x02,\n\r\n\x05\x04|\x02\0\x06\x12\x04\xe0)\x02\x1b\n\r\n\x05\
    \x04|\x02\0\x01\x12\x04\xe0)\x1c'\n\r\n\x05\x04|\x02\0\x03\x12\x04\xe0)*\
    +\n(\n\x04\x04|\x02\x01\x12\x04\xe3)\x02\"\x1a\x1a\x20Array\x20containin\
    g\x201\x20entry\n\n\r\n\x05\x04|\x02\x01\x04\x12\x04\xe3)\x02\n\n\r\n\
    \x05\x04|\x02\x01\x06\x12\x04\xe3)\x0b\x19\n\r\n\x05\x04|\x02\x01\x01\
    \x12\x04\xe3)\x1a\x1d\n\r\n\x05\x04|\x02\x01\x03\x12\x04\xe3)\x20!\n[\n\
    \x04\x04|\x02\x02\x12\x04\xe7)\x02\x14\x1aM\x20The\x20action\x20to\x20pe\
    rform\x20on\x20the\x20patched\x20objects\n\x20Only\x20'overwrite'\x20is\
    \x20supported\n\n\r\n\x05\x04|\x02\x02\x05\x12\x04\xe7)\x02\x08\n\r\n\
    \x05\x04|\x02\x02\x01\x12\x04\xe7)\t\x0f\n\r\n\x05\x04|\x02\x02\x03\x12\
    \x04\xe7)\x12\x13\n\"\n\x02\x04}\x12\x06\xeb)\0\xee)\x01\x1a\x14\x20Dele\
    teModelRequest\n\n\x0b\n\x03\x04}\x01\x12\x04\xeb)\x08\x1a\n\x0c\n\x04\
    \x04}\x02\0\x12\x04\xec)\x02,\n\r\n\x05\x04}\x02\0\x06\x12\x04\xec)\x02\
    \x1b\n\r\n\x05\x04}\x02\0\x01\x12\x04\xec)\x1c'\n\r\n\x05\x04}\x02\0\x03\
    \x12\x04\xec)*+\n\x0c\n\x04\x04}\x02\x01\x12\x04\xed)\x02\x16\n\r\n\x05\
    \x04}\x02\x01\x05\x12\x04\xed)\x02\x08\n\r\n\x05\x04}\x02\x01\x01\x12\
    \x04\xed)\t\x11\n\r\n\x05\x04}\x02\x01\x03\x12\x04\xed)\x14\x15\nD\n\x02\
    \x04~\x12\x06\xf1)\0\xf5)\x01\x1a6\x20Request\x20to\x20delete\x20several\
    \x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04~\x01\x12\
    \x04\xf1)\x08\x1b\n\x0c\n\x04\x04~\x02\0\x12\x04\xf2)\x02,\n\r\n\x05\x04\
    ~\x02\0\x06\x12\x04\xf2)\x02\x1b\n\r\n\x05\x04~\x02\0\x01\x12\x04\xf2)\
    \x1c'\n\r\n\x05\x04~\x02\0\x03\x12\x04\xf2)*+\n\x0c\n\x04\x04~\x02\x01\
    \x12\x04\xf3)\x02\x1a\n\r\n\x05\x04~\x02\x01\x04\x12\x04\xf3)\x02\n\n\r\
    \n\x05\x04~\x02\x01\x05\x12\x04\xf3)\x0b\x11\n\r\n\x05\x04~\x02\x01\x01\
    \x12\x04\xf3)\x12\x15\n\r\n\x05\x04~\x02\x01\x03\x12\x04\xf3)\x18\x19\n\
    \x0c\n\x04\x04~\x02\x02\x12\x04\xf4)\x02\x16\n\r\n\x05\x04~\x02\x02\x05\
    \x12\x04\xf4)\x02\x06\n\r\n\x05\x04~\x02\x02\x01\x12\x04\xf4)\x07\x11\n\
    \r\n\x05\x04~\x02\x02\x03\x12\x04\xf4)\x14\x15\n1\n\x02\x04\x7f\x12\x06\
    \xf8)\0\x80*\x01\x1a#\x20Search\x20over\x20the\x20available\x20models.\n\
    \n\x0b\n\x03\x04\x7f\x01\x12\x04\xf8)\x08!\n6\n\x04\x04\x7f\x02\0\x12\
    \x04\xfa)\x02,\x1a(\x20Ids\x20present\x20in\x20the\x20url\x20of\x20the\
    \x20request.\n\n\r\n\x05\x04\x7f\x02\0\x06\x12\x04\xfa)\x02\x1b\n\r\n\
    \x05\x04\x7f\x02\0\x01\x12\x04\xfa)\x1c'\n\r\n\x05\x04\x7f\x02\0\x03\x12\
    \x04\xfa)*+\n(\n\x04\x04\x7f\x02\x01\x12\x04\xfc)\x02\x1d\x1a\x1a\x20The\
    \x20body\x20of\x20the\x20request.\n\n\r\n\x05\x04\x7f\x02\x01\x06\x12\
    \x04\xfc)\x02\x0c\n\r\n\x05\x04\x7f\x02\x01\x01\x12\x04\xfc)\r\x18\n\r\n\
    \x05\x04\x7f\x02\x01\x03\x12\x04\xfc)\x1b\x1c\n]\n\x04\x04\x7f\x02\x02\
    \x12\x04\xff)\x02\x1c\x1aO\x20Pagination\x20parameters\x20here\x20since\
    \x20there\x20are\x20no\x20url\x20args\x20in\x20this\n\x20POST\x20request\
    .\n\n\r\n\x05\x04\x7f\x02\x02\x06\x12\x04\xff)\x02\x0c\n\r\n\x05\x04\x7f\
    \x02\x02\x01\x12\x04\xff)\r\x17\n\r\n\x05\x04\x7f\x02\x02\x03\x12\x04\
    \xff)\x1a\x1b\n$\n\x03\x04\x80\x01\x12\x06\x83*\0\x86*\x01\x1a\x15\x20Si\
    ngleModelResponse\n\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\x83*\x08\x1b\n\r\
    \n\x05\x04\x80\x01\x02\0\x12\x04\x84*\x02(\n\x0e\n\x06\x04\x80\x01\x02\0\
    \x06\x12\x04\x84*\x02\x1c\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\x84*\
    \x1d#\n\x0e\n\x06\x04\x80\x01\x02\0\x03\x12\x04\x84*&'\n\r\n\x05\x04\x80\
    \x01\x02\x01\x12\x04\x85*\x02\x12\n\x0e\n\x06\x04\x80\x01\x02\x01\x06\
    \x12\x04\x85*\x02\x07\n\x0e\n\x06\x04\x80\x01\x02\x01\x01\x12\x04\x85*\
    \x08\r\n\x0e\n\x06\x04\x80\x01\x02\x01\x03\x12\x04\x85*\x10\x11\n#\n\x03\
    \x04\x81\x01\x12\x06\x89*\0\x8c*\x01\x1a\x14\x20MultiModelResponse\n\n\
    \x0c\n\x04\x04\x81\x01\x01\x12\x04\x89*\x08\x1a\n\r\n\x05\x04\x81\x01\
    \x02\0\x12\x04\x8a*\x02(\n\x0e\n\x06\x04\x81\x01\x02\0\x06\x12\x04\x8a*\
    \x02\x1c\n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\x04\x8a*\x1d#\n\x0e\n\x06\
    \x04\x81\x01\x02\0\x03\x12\x04\x8a*&'\n\r\n\x05\x04\x81\x01\x02\x01\x12\
    \x04\x8b*\x02K\n\x0e\n\x06\x04\x81\x01\x02\x01\x04\x12\x04\x8b*\x02\n\n\
    \x0e\n\x06\x04\x81\x01\x02\x01\x06\x12\x04\x8b*\x0b\x10\n\x0e\n\x06\x04\
    \x81\x01\x02\x01\x01\x12\x04\x8b*\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\
    \x01\x03\x12\x04\x8b*\x1a\x1b\n\x0e\n\x06\x04\x81\x01\x02\x01\x08\x12\
    \x04\x8b*\x1cJ\n\x11\n\t\x04\x81\x01\x02\x01\x08\xd0\x86\x03\x12\x04\x8b\
    *\x1dI\n*\n\x03\x04\x82\x01\x12\x06\x8f*\0\x96*\x01\x1a\x1b\x20PatchMode\
    lVersionsRequest\n\n\x0c\n\x04\x04\x82\x01\x01\x12\x04\x8f*\x08!\n\r\n\
    \x05\x04\x82\x01\x02\0\x12\x04\x90*\x02,\n\x0e\n\x06\x04\x82\x01\x02\0\
    \x06\x12\x04\x90*\x02\x1b\n\x0e\n\x06\x04\x82\x01\x02\0\x01\x12\x04\x90*\
    \x1c'\n\x0e\n\x06\x04\x82\x01\x02\0\x03\x12\x04\x90**+\n\r\n\x05\x04\x82\
    \x01\x02\x01\x12\x04\x91*\x02\x16\n\x0e\n\x06\x04\x82\x01\x02\x01\x05\
    \x12\x04\x91*\x02\x08\n\x0e\n\x06\x04\x82\x01\x02\x01\x01\x12\x04\x91*\t\
    \x11\n\x0e\n\x06\x04\x82\x01\x02\x01\x03\x12\x04\x91*\x14\x15\n\r\n\x05\
    \x04\x82\x01\x02\x02\x12\x04\x92*\x02+\n\x0e\n\x06\x04\x82\x01\x02\x02\
    \x04\x12\x04\x92*\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x02\x06\x12\x04\x92*\
    \x0b\x17\n\x0e\n\x06\x04\x82\x01\x02\x02\x01\x12\x04\x92*\x18&\n\x0e\n\
    \x06\x04\x82\x01\x02\x02\x03\x12\x04\x92*)*\n\x7f\n\x05\x04\x82\x01\x02\
    \x03\x12\x04\x95*\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\
    \x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge',\x20\
    'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\
    \x82\x01\x02\x03\x05\x12\x04\x95*\x02\x08\n\x0e\n\x06\x04\x82\x01\x02\
    \x03\x01\x12\x04\x95*\t\x0f\n\x0e\n\x06\x04\x82\x01\x02\x03\x03\x12\x04\
    \x95*\x12\x13\n;\n\x03\x04\x83\x01\x12\x06\x99*\0\x9d*\x01\x1a,\x20reque\
    st\x20for\x20different\x20endpoints\x20currently.\n\n\x0c\n\x04\x04\x83\
    \x01\x01\x12\x04\x99*\x08\x1e\n\r\n\x05\x04\x83\x01\x02\0\x12\x04\x9a*\
    \x02,\n\x0e\n\x06\x04\x83\x01\x02\0\x06\x12\x04\x9a*\x02\x1b\n\x0e\n\x06\
    \x04\x83\x01\x02\0\x01\x12\x04\x9a*\x1c'\n\x0e\n\x06\x04\x83\x01\x02\0\
    \x03\x12\x04\x9a**+\n\r\n\x05\x04\x83\x01\x02\x01\x12\x04\x9b*\x02\x16\n\
    \x0e\n\x06\x04\x83\x01\x02\x01\x05\x12\x04\x9b*\x02\x08\n\x0e\n\x06\x04\
    \x83\x01\x02\x01\x01\x12\x04\x9b*\t\x11\n\x0e\n\x06\x04\x83\x01\x02\x01\
    \x03\x12\x04\x9b*\x14\x15\n\r\n\x05\x04\x83\x01\x02\x02\x12\x04\x9c*\x02\
    \x18\n\x0e\n\x06\x04\x83\x01\x02\x02\x05\x12\x04\x9c*\x02\x08\n\x0e\n\
    \x06\x04\x83\x01\x02\x02\x01\x12\x04\x9c*\t\x13\n\x0e\n\x06\x04\x83\x01\
    \x02\x02\x03\x12\x04\x9c*\x16\x17\n)\n\x03\x04\x84\x01\x12\x06\xa0*\0\
    \xbe*\x01\x1a\x1a\x20ListModelVersionsRequest\n\n\x0c\n\x04\x04\x84\x01\
    \x01\x12\x04\xa0*\x08\x20\n\r\n\x05\x04\x84\x01\x02\0\x12\x04\xa1*\x02,\
    \n\x0e\n\x06\x04\x84\x01\x02\0\x06\x12\x04\xa1*\x02\x1b\n\x0e\n\x06\x04\
    \x84\x01\x02\0\x01\x12\x04\xa1*\x1c'\n\x0e\n\x06\x04\x84\x01\x02\0\x03\
    \x12\x04\xa1**+\n\r\n\x05\x04\x84\x01\x02\x01\x12\x04\xa2*\x02\x16\n\x0e\
    \n\x06\x04\x84\x01\x02\x01\x05\x12\x04\xa2*\x02\x08\n\x0e\n\x06\x04\x84\
    \x01\x02\x01\x01\x12\x04\xa2*\t\x11\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\
    \x12\x04\xa2*\x14\x15\n\x7f\n\x05\x04\x84\x01\x02\x02\x12\x04\xa5*\x02\
    \x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\
    \x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x84\x01\x02\x02\
    \x05\x12\x04\xa5*\x02\x08\n\x0e\n\x06\x04\x84\x01\x02\x02\x01\x12\x04\
    \xa5*\t\r\n\x0e\n\x06\x04\x84\x01\x02\x02\x03\x12\x04\xa5*\x10\x11\nv\n\
    \x05\x04\x84\x01\x02\x03\x12\x04\xa8*\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\
    \n\x06\x04\x84\x01\x02\x03\x05\x12\x04\xa8*\x02\x08\n\x0e\n\x06\x04\x84\
    \x01\x02\x03\x01\x12\x04\xa8*\t\x11\n\x0e\n\x06\x04\x84\x01\x02\x03\x03\
    \x12\x04\xa8*\x14\x15\nq\n\x05\x04\x84\x01\x02\x04\x12\x04\xac*\x02\"\
    \x1ab\x20Filtering\x20options:\n\x20To\x20list\x20only\x20the\x20model\
    \x20versions\x20that\x20have\x20these\x20concept\x20ids\x20present\x20in\
    \x20them.\n\n\x0e\n\x06\x04\x84\x01\x02\x04\x04\x12\x04\xac*\x02\n\n\x0e\
    \n\x06\x04\x84\x01\x02\x04\x05\x12\x04\xac*\x0b\x11\n\x0e\n\x06\x04\x84\
    \x01\x02\x04\x01\x12\x04\xac*\x12\x1d\n\x0e\n\x06\x04\x84\x01\x02\x04\
    \x03\x12\x04\xac*\x20!\nH\n\x05\x04\x84\x01\x02\x05\x12\x04\xae*\x02\x18\
    \x1a9\x20To\x20list\x20only\x20the\x20model\x20versions\x20that\x20have\
    \x20been\x20trained.\n\n\x0e\n\x06\x04\x84\x01\x02\x05\x05\x12\x04\xae*\
    \x02\x06\n\x0e\n\x06\x04\x84\x01\x02\x05\x01\x12\x04\xae*\x07\x13\n\x0e\
    \n\x06\x04\x84\x01\x02\x05\x03\x12\x04\xae*\x16\x17\np\n\x05\x04\x84\x01\
    \x02\x06\x12\x04\xb2*\x02\x1a\x1aa\x20Sorting\x20options:\n\x20Whether\
    \x20to\x20sort\x20in\x20ascending\x20order.\x20If\x20false,\x20will\x20o\
    rder\x20in\x20descending\x20order.\n\n\x0e\n\x06\x04\x84\x01\x02\x06\x05\
    \x12\x04\xb2*\x02\x06\n\x0e\n\x06\x04\x84\x01\x02\x06\x01\x12\x04\xb2*\
    \x07\x15\n\x0e\n\x06\x04\x84\x01\x02\x06\x03\x12\x04\xb2*\x18\x19\n\x0f\
    \n\x05\x04\x84\x01\x08\0\x12\x06\xb3*\x02\xbd*\x03\n\x0e\n\x06\x04\x84\
    \x01\x08\0\x01\x12\x04\xb3*\x08\x0f\n4\n\x05\x04\x84\x01\x02\x07\x12\x04\
    \xb5*\x04!\x1a%\x20Whether\x20to\x20order\x20by\x20the\x20status\x20code\
    \n\n\x0e\n\x06\x04\x84\x01\x02\x07\x05\x12\x04\xb5*\x04\x08\n\x0e\n\x06\
    \x04\x84\x01\x02\x07\x01\x12\x04\xb5*\t\x1c\n\x0e\n\x06\x04\x84\x01\x02\
    \x07\x03\x12\x04\xb5*\x1f\x20\nB\n\x05\x04\x84\x01\x02\x08\x12\x04\xb7*\
    \x04\x20\x1a3\x20Whether\x20to\x20order\x20by\x20the\x20number\x20of\x20\
    training\x20inputs\n\n\x0e\n\x06\x04\x84\x01\x02\x08\x05\x12\x04\xb7*\
    \x04\x08\n\x0e\n\x06\x04\x84\x01\x02\x08\x01\x12\x04\xb7*\t\x1b\n\x0e\n\
    \x06\x04\x84\x01\x02\x08\x03\x12\x04\xb7*\x1e\x1f\n3\n\x05\x04\x84\x01\
    \x02\t\x12\x04\xb9*\x04\"\x1a$\x20Whether\x20to\x20sort\x20by\x20the\x20\
    description\n\n\x0e\n\x06\x04\x84\x01\x02\t\x05\x12\x04\xb9*\x04\x08\n\
    \x0e\n\x06\x04\x84\x01\x02\t\x01\x12\x04\xb9*\t\x1c\n\x0e\n\x06\x04\x84\
    \x01\x02\t\x03\x12\x04\xb9*\x1f!\ny\n\x05\x04\x84\x01\x02\n\x12\x04\xbc*\
    \x04!\x1aj\x20Whether\x20to\x20order\x20by\x20the\x20created_at\x20time\
    \n\x20If\x20neither\x20sort\x20option\x20is\x20set\x20to\x20true,\x20wil\
    l\x20sort\x20by\x20created_at.\n\n\x0e\n\x06\x04\x84\x01\x02\n\x05\x12\
    \x04\xbc*\x04\x08\n\x0e\n\x06\x04\x84\x01\x02\n\x01\x12\x04\xbc*\t\x1b\n\
    \x0e\n\x06\x04\x84\x01\x02\n\x03\x12\x04\xbc*\x1e\x20\n*\n\x03\x04\x85\
    \x01\x12\x06\xc1*\0\xc5*\x01\x1a\x1b\x20DeleteModelVersionRequest\n\n\
    \x0c\n\x04\x04\x85\x01\x01\x12\x04\xc1*\x08!\n\r\n\x05\x04\x85\x01\x02\0\
    \x12\x04\xc2*\x02,\n\x0e\n\x06\x04\x85\x01\x02\0\x06\x12\x04\xc2*\x02\
    \x1b\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\xc2*\x1c'\n\x0e\n\x06\x04\
    \x85\x01\x02\0\x03\x12\x04\xc2**+\n\r\n\x05\x04\x85\x01\x02\x01\x12\x04\
    \xc3*\x02\x16\n\x0e\n\x06\x04\x85\x01\x02\x01\x05\x12\x04\xc3*\x02\x08\n\
    \x0e\n\x06\x04\x85\x01\x02\x01\x01\x12\x04\xc3*\t\x11\n\x0e\n\x06\x04\
    \x85\x01\x02\x01\x03\x12\x04\xc3*\x14\x15\n\r\n\x05\x04\x85\x01\x02\x02\
    \x12\x04\xc4*\x02\x18\n\x0e\n\x06\x04\x85\x01\x02\x02\x05\x12\x04\xc4*\
    \x02\x08\n\x0e\n\x06\x04\x85\x01\x02\x02\x01\x12\x04\xc4*\t\x13\n\x0e\n\
    \x06\x04\x85\x01\x02\x02\x03\x12\x04\xc4*\x16\x17\n+\n\x03\x04\x86\x01\
    \x12\x06\xc8*\0\xcb*\x01\x1a\x1c\x20SingleModelVersionResponse\n\n\x0c\n\
    \x04\x04\x86\x01\x01\x12\x04\xc8*\x08\"\n\r\n\x05\x04\x86\x01\x02\0\x12\
    \x04\xc9*\x02(\n\x0e\n\x06\x04\x86\x01\x02\0\x06\x12\x04\xc9*\x02\x1c\n\
    \x0e\n\x06\x04\x86\x01\x02\0\x01\x12\x04\xc9*\x1d#\n\x0e\n\x06\x04\x86\
    \x01\x02\0\x03\x12\x04\xc9*&'\n\r\n\x05\x04\x86\x01\x02\x01\x12\x04\xca*\
    \x02!\n\x0e\n\x06\x04\x86\x01\x02\x01\x06\x12\x04\xca*\x02\x0e\n\x0e\n\
    \x06\x04\x86\x01\x02\x01\x01\x12\x04\xca*\x0f\x1c\n\x0e\n\x06\x04\x86\
    \x01\x02\x01\x03\x12\x04\xca*\x1f\x20\n*\n\x03\x04\x87\x01\x12\x06\xce*\
    \0\xd1*\x01\x1a\x1b\x20MultiModelVersionResponse\n\n\x0c\n\x04\x04\x87\
    \x01\x01\x12\x04\xce*\x08!\n\r\n\x05\x04\x87\x01\x02\0\x12\x04\xcf*\x02(\
    \n\x0e\n\x06\x04\x87\x01\x02\0\x06\x12\x04\xcf*\x02\x1c\n\x0e\n\x06\x04\
    \x87\x01\x02\0\x01\x12\x04\xcf*\x1d#\n\x0e\n\x06\x04\x87\x01\x02\0\x03\
    \x12\x04\xcf*&'\n\r\n\x05\x04\x87\x01\x02\x01\x12\x04\xd0*\x02Z\n\x0e\n\
    \x06\x04\x87\x01\x02\x01\x04\x12\x04\xd0*\x02\n\n\x0e\n\x06\x04\x87\x01\
    \x02\x01\x06\x12\x04\xd0*\x0b\x17\n\x0e\n\x06\x04\x87\x01\x02\x01\x01\
    \x12\x04\xd0*\x18&\n\x0e\n\x06\x04\x87\x01\x02\x01\x03\x12\x04\xd0*)*\n\
    \x0e\n\x06\x04\x87\x01\x02\x01\x08\x12\x04\xd0*+Y\n\x11\n\t\x04\x87\x01\
    \x02\x01\x08\xd0\x86\x03\x12\x04\xd0*,X\n4\n\x03\x04\x88\x01\x12\x06\xd4\
    *\0\xe1*\x01\x1a%\x20Create\x20(train)\x20a\x20new\x20model\x20version.\
    \n\n\x0c\n\x04\x04\x88\x01\x01\x12\x04\xd4*\x08\x20\n\x0c\n\x04\x04\x88\
    \x01\t\x12\x04\xd5*\x02\x19\n\r\n\x05\x04\x88\x01\t\0\x12\x04\xd5*\x0b\
    \x0c\n\x0e\n\x06\x04\x88\x01\t\0\x01\x12\x04\xd5*\x0b\x0c\n\x0e\n\x06\
    \x04\x88\x01\t\0\x02\x12\x04\xd5*\x0b\x0c\n\r\n\x05\x04\x88\x01\t\x01\
    \x12\x04\xd5*\x0e\x0f\n\x0e\n\x06\x04\x88\x01\t\x01\x01\x12\x04\xd5*\x0e\
    \x0f\n\x0e\n\x06\x04\x88\x01\t\x01\x02\x12\x04\xd5*\x0e\x0f\n\r\n\x05\
    \x04\x88\x01\t\x02\x12\x04\xd5*\x11\x12\n\x0e\n\x06\x04\x88\x01\t\x02\
    \x01\x12\x04\xd5*\x11\x12\n\x0e\n\x06\x04\x88\x01\t\x02\x02\x12\x04\xd5*\
    \x11\x12\n\r\n\x05\x04\x88\x01\t\x03\x12\x04\xd5*\x14\x15\n\x0e\n\x06\
    \x04\x88\x01\t\x03\x01\x12\x04\xd5*\x14\x15\n\x0e\n\x06\x04\x88\x01\t\
    \x03\x02\x12\x04\xd5*\x14\x15\n\r\n\x05\x04\x88\x01\t\x04\x12\x04\xd5*\
    \x17\x18\n\x0e\n\x06\x04\x88\x01\t\x04\x01\x12\x04\xd5*\x17\x18\n\x0e\n\
    \x06\x04\x88\x01\t\x04\x02\x12\x04\xd5*\x17\x18\n\r\n\x05\x04\x88\x01\
    \x02\0\x12\x04\xd6*\x02,\n\x0e\n\x06\x04\x88\x01\x02\0\x06\x12\x04\xd6*\
    \x02\x1b\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\x04\xd6*\x1c'\n\x0e\n\x06\
    \x04\x88\x01\x02\0\x03\x12\x04\xd6**+\n\r\n\x05\x04\x88\x01\x02\x01\x12\
    \x04\xd7*\x02\x16\n\x0e\n\x06\x04\x88\x01\x02\x01\x05\x12\x04\xd7*\x02\
    \x08\n\x0e\n\x06\x04\x88\x01\x02\x01\x01\x12\x04\xd7*\t\x11\n\x0e\n\x06\
    \x04\x88\x01\x02\x01\x03\x12\x04\xd7*\x14\x15\n\r\n\x05\x04\x88\x01\x02\
    \x02\x12\x04\xd9*\x02+\n\x0e\n\x06\x04\x88\x01\x02\x02\x04\x12\x04\xd9*\
    \x02\n\n\x0e\n\x06\x04\x88\x01\x02\x02\x06\x12\x04\xd9*\x0b\x17\n\x0e\n\
    \x06\x04\x88\x01\x02\x02\x01\x12\x04\xd9*\x18&\n\x0e\n\x06\x04\x88\x01\
    \x02\x02\x03\x12\x04\xd9*)*\n4\n\x05\x04\x88\x01\x02\x03\x12\x04\xdc*\
    \x02\x19\x1a%\x20Description\x20about\x20this\x20training\x20run\n\n\x0e\
    \n\x06\x04\x88\x01\x02\x03\x05\x12\x04\xdc*\x02\x08\n\x0e\n\x06\x04\x88\
    \x01\x02\x03\x01\x12\x04\xdc*\t\x14\n\x0e\n\x06\x04\x88\x01\x02\x03\x03\
    \x12\x04\xdc*\x17\x18\n\xa2\x01\n\x05\x04\x88\x01\x02\x04\x12\x04\xe0*\
    \x02\x1a\x1a\x92\x01\x20When\x20evaluate_after_training\x20set\x20to\x20\
    true,\x20we\x20will\x20do\x20evaluation\x20immediately\x20after\x20train\
    ing\x20finishes.\n\x20We\x20will\x20merge\x20this\x20with\x20default_eva\
    l_info.\n\n\x0e\n\x06\x04\x88\x01\x02\x04\x06\x12\x04\xe0*\x02\n\n\x0e\n\
    \x06\x04\x88\x01\x02\x04\x01\x12\x04\xe0*\x0b\x14\n\x0e\n\x06\x04\x88\
    \x01\x02\x04\x03\x12\x04\xe0*\x17\x19\n\r\n\x03\x04\x89\x01\x12\x06\xe3*\
    \0\xe8*\x01\n\x0c\n\x04\x04\x89\x01\x01\x12\x04\xe3*\x08&\n\x0f\n\x05\
    \x04\x89\x01\x08\0\x12\x06\xe4*\x03\xe7*\x03\n\x0e\n\x06\x04\x89\x01\x08\
    \0\x01\x12\x04\xe4*\t\x14\n\r\n\x05\x04\x89\x01\x02\0\x12\x04\xe5*\x044\
    \n\x0e\n\x06\x04\x89\x01\x02\0\x06\x12\x04\xe5*\x04!\n\x0e\n\x06\x04\x89\
    \x01\x02\0\x01\x12\x04\xe5*\"/\n\x0e\n\x06\x04\x89\x01\x02\0\x03\x12\x04\
    \xe5*23\n\r\n\x05\x04\x89\x01\x02\x01\x12\x04\xe6*\x04'\n\x0e\n\x06\x04\
    \x89\x01\x02\x01\x06\x12\x04\xe6*\x04\x15\n\x0e\n\x06\x04\x89\x01\x02\
    \x01\x01\x12\x04\xe6*\x16\"\n\x0e\n\x06\x04\x89\x01\x02\x01\x03\x12\x04\
    \xe6*%&\n\r\n\x03\x04\x8a\x01\x12\x06\xea*\0\xee*\x01\n\x0c\n\x04\x04\
    \x8a\x01\x01\x12\x04\xea*\x08'\n\r\n\x05\x04\x8a\x01\x02\0\x12\x04\xeb*\
    \x02(\n\x0e\n\x06\x04\x8a\x01\x02\0\x06\x12\x04\xeb*\x02\x1c\n\x0e\n\x06\
    \x04\x8a\x01\x02\0\x01\x12\x04\xeb*\x1d#\n\x0e\n\x06\x04\x8a\x01\x02\0\
    \x03\x12\x04\xeb*&'\n\r\n\x05\x04\x8a\x01\x02\x01\x12\x04\xec*\x02\x1d\n\
    \x0e\n\x06\x04\x8a\x01\x02\x01\x05\x12\x04\xec*\x02\x08\n\x0e\n\x06\x04\
    \x8a\x01\x02\x01\x01\x12\x04\xec*\t\x18\n\x0e\n\x06\x04\x8a\x01\x02\x01\
    \x03\x12\x04\xec*\x1b\x1c\n7\n\x05\x04\x8a\x01\x02\x02\x12\x04\xed*\x02\
    \x1e\"(\x20ID\x20of\x20the\x20model\x20version\x20being\x20uploaded\n\n\
    \x0e\n\x06\x04\x8a\x01\x02\x02\x05\x12\x04\xed*\x02\x08\n\x0e\n\x06\x04\
    \x8a\x01\x02\x02\x01\x12\x04\xed*\t\x19\n\x0e\n\x06\x04\x8a\x01\x02\x02\
    \x03\x12\x04\xed*\x1c\x1d\n\r\n\x03\x04\x8b\x01\x12\x06\xf0*\0\xf5*\x01\
    \n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\xf0*\x08%\n\r\n\x05\x04\x8b\x01\x02\
    \0\x12\x04\xf1*\x02,\n\x0e\n\x06\x04\x8b\x01\x02\0\x06\x12\x04\xf1*\x02\
    \x1b\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\x04\xf1*\x1c'\n\x0e\n\x06\x04\
    \x8b\x01\x02\0\x03\x12\x04\xf1**+\n+\n\x05\x04\x8b\x01\x02\x01\x12\x04\
    \xf2*\x02\x16\"\x1c\x20model\x20to\x20create\x20version\x20of\n\n\x0e\n\
    \x06\x04\x8b\x01\x02\x01\x05\x12\x04\xf2*\x02\x08\n\x0e\n\x06\x04\x8b\
    \x01\x02\x01\x01\x12\x04\xf2*\t\x11\n\x0e\n\x06\x04\x8b\x01\x02\x01\x03\
    \x12\x04\xf2*\x14\x15\nC\n\x05\x04\x8b\x01\x02\x02\x12\x04\xf3*\x02!\"4\
    \x20specification\x20for\x20the\x20model\x20version\x20to\x20be\x20uploa\
    ded\n\n\x0e\n\x06\x04\x8b\x01\x02\x02\x06\x12\x04\xf3*\x02\x0e\n\x0e\n\
    \x06\x04\x8b\x01\x02\x02\x01\x12\x04\xf3*\x0f\x1c\n\x0e\n\x06\x04\x8b\
    \x01\x02\x02\x03\x12\x04\xf3*\x1f\x20\nB\n\x05\x04\x8b\x01\x02\x03\x12\
    \x04\xf4*\x02\x18\"3\x20number\x20of\x20bytes\x20in\x20the\x20model\x20f\
    iles\x20to\x20be\x20uploaded\n\n\x0e\n\x06\x04\x8b\x01\x02\x03\x05\x12\
    \x04\xf4*\x02\x08\n\x0e\n\x06\x04\x8b\x01\x02\x03\x01\x12\x04\xf4*\t\x13\
    \n\x0e\n\x06\x04\x8b\x01\x02\x03\x03\x12\x04\xf4*\x16\x17\n.\n\x03\x04\
    \x8c\x01\x12\x06\xf8*\0\xfc*\x01\x1a\x1f\x20PutModelVersionExportsReques\
    t\n\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xf8*\x08%\n\r\n\x05\x04\x8c\x01\
    \x02\0\x12\x04\xf9*\x02,\n\x0e\n\x06\x04\x8c\x01\x02\0\x06\x12\x04\xf9*\
    \x02\x1b\n\x0e\n\x06\x04\x8c\x01\x02\0\x01\x12\x04\xf9*\x1c'\n\x0e\n\x06\
    \x04\x8c\x01\x02\0\x03\x12\x04\xf9**+\n\r\n\x05\x04\x8c\x01\x02\x01\x12\
    \x04\xfa*\x02\x16\n\x0e\n\x06\x04\x8c\x01\x02\x01\x05\x12\x04\xfa*\x02\
    \x08\n\x0e\n\x06\x04\x8c\x01\x02\x01\x01\x12\x04\xfa*\t\x11\n\x0e\n\x06\
    \x04\x8c\x01\x02\x01\x03\x12\x04\xfa*\x14\x15\n\r\n\x05\x04\x8c\x01\x02\
    \x02\x12\x04\xfb*\x02\x18\n\x0e\n\x06\x04\x8c\x01\x02\x02\x05\x12\x04\
    \xfb*\x02\x08\n\x0e\n\x06\x04\x8c\x01\x02\x02\x01\x12\x04\xfb*\t\x13\n\
    \x0e\n\x06\x04\x8c\x01\x02\x02\x03\x12\x04\xfb*\x16\x17\n-\n\x03\x04\x8d\
    \x01\x12\x06\xff*\0\x83+\x01\x1a\x1e\x20GetModelVersionExportRequest\n\n\
    \x0c\n\x04\x04\x8d\x01\x01\x12\x04\xff*\x08$\n\r\n\x05\x04\x8d\x01\x02\0\
    \x12\x04\x80+\x02,\n\x0e\n\x06\x04\x8d\x01\x02\0\x06\x12\x04\x80+\x02\
    \x1b\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\x80+\x1c'\n\x0e\n\x06\x04\
    \x8d\x01\x02\0\x03\x12\x04\x80+*+\n\r\n\x05\x04\x8d\x01\x02\x01\x12\x04\
    \x81+\x02\x16\n\x0e\n\x06\x04\x8d\x01\x02\x01\x05\x12\x04\x81+\x02\x08\n\
    \x0e\n\x06\x04\x8d\x01\x02\x01\x01\x12\x04\x81+\t\x11\n\x0e\n\x06\x04\
    \x8d\x01\x02\x01\x03\x12\x04\x81+\x14\x15\n\r\n\x05\x04\x8d\x01\x02\x02\
    \x12\x04\x82+\x02\x18\n\x0e\n\x06\x04\x8d\x01\x02\x02\x05\x12\x04\x82+\
    \x02\x08\n\x0e\n\x06\x04\x8d\x01\x02\x02\x01\x12\x04\x82+\t\x13\n\x0e\n\
    \x06\x04\x8d\x01\x02\x02\x03\x12\x04\x82+\x16\x17\n1\n\x03\x04\x8e\x01\
    \x12\x06\x86+\0\x89+\x01\x1a\"\x20SingleModelVersionExportResponse\n\n\
    \x0c\n\x04\x04\x8e\x01\x01\x12\x04\x86+\x08(\n\r\n\x05\x04\x8e\x01\x02\0\
    \x12\x04\x87+\x02(\n\x0e\n\x06\x04\x8e\x01\x02\0\x06\x12\x04\x87+\x02\
    \x1c\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\x04\x87+\x1d#\n\x0e\n\x06\x04\
    \x8e\x01\x02\0\x03\x12\x04\x87+&'\n\r\n\x05\x04\x8e\x01\x02\x01\x12\x04\
    \x88+\x02O\n\x0e\n\x06\x04\x8e\x01\x02\x01\x06\x12\x04\x88+\x02\x14\n\
    \x0e\n\x06\x04\x8e\x01\x02\x01\x01\x12\x04\x88+\x15\x1b\n\x0e\n\x06\x04\
    \x8e\x01\x02\x01\x03\x12\x04\x88+\x1e\x1f\n\x0e\n\x06\x04\x8e\x01\x02\
    \x01\x08\x12\x04\x88+\x20N\n\x11\n\t\x04\x8e\x01\x02\x01\x08\xd0\x86\x03\
    \x12\x04\x88+!M\n\r\n\x03\x04\x8f\x01\x12\x06\x8b+\0\x8f+\x01\n\x0c\n\
    \x04\x04\x8f\x01\x01\x12\x04\x8b+\x08,\n\r\n\x05\x04\x8f\x01\x02\0\x12\
    \x04\x8c+\x02,\n\x0e\n\x06\x04\x8f\x01\x02\0\x06\x12\x04\x8c+\x02\x1b\n\
    \x0e\n\x06\x04\x8f\x01\x02\0\x01\x12\x04\x8c+\x1c'\n\x0e\n\x06\x04\x8f\
    \x01\x02\0\x03\x12\x04\x8c+*+\n\r\n\x05\x04\x8f\x01\x02\x01\x12\x04\x8d+\
    \x02\x19\n\x0e\n\x06\x04\x8f\x01\x02\x01\x05\x12\x04\x8d+\x02\x08\n\x0e\
    \n\x06\x04\x8f\x01\x02\x01\x01\x12\x04\x8d+\t\x14\n\x0e\n\x06\x04\x8f\
    \x01\x02\x01\x03\x12\x04\x8d+\x17\x18\n\r\n\x05\x04\x8f\x01\x02\x02\x12\
    \x04\x8e+\x02<\n\x0e\n\x06\x04\x8f\x01\x02\x02\x04\x12\x04\x8e+\x02\n\n\
    \x0e\n\x06\x04\x8f\x01\x02\x02\x06\x12\x04\x8e+\x0b*\n\x0e\n\x06\x04\x8f\
    \x01\x02\x02\x01\x12\x04\x8e++7\n\x0e\n\x06\x04\x8f\x01\x02\x02\x03\x12\
    \x04\x8e+:;\n\r\n\x03\x04\x90\x01\x12\x06\x93+\0\x97+\x01\n\x0c\n\x04\
    \x04\x90\x01\x01\x12\x04\x93+\x08*\n\r\n\x05\x04\x90\x01\x02\0\x12\x04\
    \x94+\x02,\n\x0e\n\x06\x04\x90\x01\x02\0\x06\x12\x04\x94+\x02\x1b\n\x0e\
    \n\x06\x04\x90\x01\x02\0\x01\x12\x04\x94+\x1c'\n\x0e\n\x06\x04\x90\x01\
    \x02\0\x03\x12\x04\x94+*+\n\r\n\x05\x04\x90\x01\x02\x01\x12\x04\x95+\x02\
    \x19\n\x0e\n\x06\x04\x90\x01\x02\x01\x05\x12\x04\x95+\x02\x08\n\x0e\n\
    \x06\x04\x90\x01\x02\x01\x01\x12\x04\x95+\t\x14\n\x0e\n\x06\x04\x90\x01\
    \x02\x01\x03\x12\x04\x95+\x17\x18\n\r\n\x05\x04\x90\x01\x02\x02\x12\x04\
    \x96+\x02:\n\x0e\n\x06\x04\x90\x01\x02\x02\x04\x12\x04\x96+\x02\n\n\x0e\
    \n\x06\x04\x90\x01\x02\x02\x06\x12\x04\x96+\x0b(\n\x0e\n\x06\x04\x90\x01\
    \x02\x02\x01\x12\x04\x96+)5\n\x0e\n\x06\x04\x90\x01\x02\x02\x03\x12\x04\
    \x96+89\n\r\n\x03\x04\x91\x01\x12\x06\x99+\0\x9b+\x01\n\x0c\n\x04\x04\
    \x91\x01\x01\x12\x04\x99+\x08%\n\r\n\x05\x04\x91\x01\x02\0\x12\x04\x9a+\
    \x02\x18\n\x0e\n\x06\x04\x91\x01\x02\0\x05\x12\x04\x9a+\x02\x08\n\x0e\n\
    \x06\x04\x91\x01\x02\0\x01\x12\x04\x9a+\t\x13\n\x0e\n\x06\x04\x91\x01\
    \x02\0\x03\x12\x04\x9a+\x16\x17\n\r\n\x03\x04\x92\x01\x12\x06\x9d+\0\x9f\
    +\x01\n\x0c\n\x04\x04\x92\x01\x01\x12\x04\x9d+\x08'\n\r\n\x05\x04\x92\
    \x01\x02\0\x12\x04\x9e+\x02\x18\n\x0e\n\x06\x04\x92\x01\x02\0\x05\x12\
    \x04\x9e+\x02\x08\n\x0e\n\x06\x04\x92\x01\x02\0\x01\x12\x04\x9e+\t\x13\n\
    \x0e\n\x06\x04\x92\x01\x02\0\x03\x12\x04\x9e+\x16\x17\n+\n\x03\x04\x93\
    \x01\x12\x06\xa2+\0\xa4+\x01\x1a\x1c\x20ModelVersionPublishRequest\n\n\
    \x0c\n\x04\x04\x93\x01\x01\x12\x04\xa2+\x08\"\n\r\n\x05\x04\x93\x01\x02\
    \0\x12\x04\xa3+\x02\x18\n\x0e\n\x06\x04\x93\x01\x02\0\x05\x12\x04\xa3+\
    \x02\x08\n\x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\xa3+\t\x13\n\x0e\n\
    \x06\x04\x93\x01\x02\0\x03\x12\x04\xa3+\x16\x17\n0\n\x03\x04\x94\x01\x12\
    \x06\xa7+\0\xab+\x01\x1a!\x20PostModelVersionsPublishRequest\n\n\x0c\n\
    \x04\x04\x94\x01\x01\x12\x04\xa7+\x08'\n\r\n\x05\x04\x94\x01\x02\0\x12\
    \x04\xa8+\x02,\n\x0e\n\x06\x04\x94\x01\x02\0\x06\x12\x04\xa8+\x02\x1b\n\
    \x0e\n\x06\x04\x94\x01\x02\0\x01\x12\x04\xa8+\x1c'\n\x0e\n\x06\x04\x94\
    \x01\x02\0\x03\x12\x04\xa8+*+\n\r\n\x05\x04\x94\x01\x02\x01\x12\x04\xa9+\
    \x02\x16\n\x0e\n\x06\x04\x94\x01\x02\x01\x05\x12\x04\xa9+\x02\x08\n\x0e\
    \n\x06\x04\x94\x01\x02\x01\x01\x12\x04\xa9+\t\x11\n\x0e\n\x06\x04\x94\
    \x01\x02\x01\x03\x12\x04\xa9+\x14\x15\n\r\n\x05\x04\x94\x01\x02\x02\x12\
    \x04\xaa+\x027\n\x0e\n\x06\x04\x94\x01\x02\x02\x04\x12\x04\xaa+\x02\n\n\
    \x0e\n\x06\x04\x94\x01\x02\x02\x06\x12\x04\xaa+\x0b%\n\x0e\n\x06\x04\x94\
    \x01\x02\x02\x01\x12\x04\xaa+&2\n\x0e\n\x06\x04\x94\x01\x02\x02\x03\x12\
    \x04\xaa+56\n-\n\x03\x04\x95\x01\x12\x06\xae+\0\xb0+\x01\x1a\x1e\x20Mode\
    lVersionUnpublishRequest\n\n\x0c\n\x04\x04\x95\x01\x01\x12\x04\xae+\x08$\
    \n\r\n\x05\x04\x95\x01\x02\0\x12\x04\xaf+\x02\x18\n\x0e\n\x06\x04\x95\
    \x01\x02\0\x05\x12\x04\xaf+\x02\x08\n\x0e\n\x06\x04\x95\x01\x02\0\x01\
    \x12\x04\xaf+\t\x13\n\x0e\n\x06\x04\x95\x01\x02\0\x03\x12\x04\xaf+\x16\
    \x17\n2\n\x03\x04\x96\x01\x12\x06\xb3+\0\xb7+\x01\x1a#\x20PostModelVersi\
    onsUnPublishRequest\n\n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xb3+\x08)\n\r\
    \n\x05\x04\x96\x01\x02\0\x12\x04\xb4+\x02,\n\x0e\n\x06\x04\x96\x01\x02\0\
    \x06\x12\x04\xb4+\x02\x1b\n\x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\xb4+\
    \x1c'\n\x0e\n\x06\x04\x96\x01\x02\0\x03\x12\x04\xb4+*+\n\r\n\x05\x04\x96\
    \x01\x02\x01\x12\x04\xb5+\x02\x16\n\x0e\n\x06\x04\x96\x01\x02\x01\x05\
    \x12\x04\xb5+\x02\x08\n\x0e\n\x06\x04\x96\x01\x02\x01\x01\x12\x04\xb5+\t\
    \x11\n\x0e\n\x06\x04\x96\x01\x02\x01\x03\x12\x04\xb5+\x14\x15\n\r\n\x05\
    \x04\x96\x01\x02\x02\x12\x04\xb6+\x029\n\x0e\n\x06\x04\x96\x01\x02\x02\
    \x04\x12\x04\xb6+\x02\n\n\x0e\n\x06\x04\x96\x01\x02\x02\x06\x12\x04\xb6+\
    \x0b'\n\x0e\n\x06\x04\x96\x01\x02\x02\x01\x12\x04\xb6+(4\n\x0e\n\x06\x04\
    \x96\x01\x02\x02\x03\x12\x04\xb6+78\n+\n\x03\x04\x97\x01\x12\x06\xba+\0\
    \xbf+\x01\x1a\x1c\x20Evaluate\x20this\x20model\x20vesion\n\n\x0c\n\x04\
    \x04\x97\x01\x01\x12\x04\xba+\x08\x1e\n\r\n\x05\x04\x97\x01\x02\0\x12\
    \x04\xbb+\x02,\n\x0e\n\x06\x04\x97\x01\x02\0\x06\x12\x04\xbb+\x02\x1b\n\
    \x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\xbb+\x1c'\n\x0e\n\x06\x04\x97\
    \x01\x02\0\x03\x12\x04\xbb+*+\n\xd0\x01\n\x05\x04\x97\x01\x02\x01\x12\
    \x04\xbe+\x02(\x1a\xc0\x01\x20eval_info,\x20id,\x20model,\x20and\x20grou\
    nd_truth_dataset\x20will\x20be\x20used\x20when\x20creating\x20the\x20eva\
    luation\n\x20If\x20no\x20dataset\x20is\x20provided,\x20all\x20app\x20dat\
    a\x20that\x20is\x20annotated\x20with\x20concepts\x20from\x20the\x20model\
    \x20will\x20be\x20used.\n\n\x0e\n\x06\x04\x97\x01\x02\x01\x04\x12\x04\
    \xbe+\x02\n\n\x0e\n\x06\x04\x97\x01\x02\x01\x06\x12\x04\xbe+\x0b\x16\n\
    \x0e\n\x06\x04\x97\x01\x02\x01\x01\x12\x04\xbe+\x17#\n\x0e\n\x06\x04\x97\
    \x01\x02\x01\x03\x12\x04\xbe+&'\n\r\n\x03\x04\x98\x01\x12\x06\xc1+\0\xe8\
    +\x01\n\x0c\n\x04\x04\x98\x01\x01\x12\x04\xc1+\x08\x1e\n\r\n\x05\x04\x98\
    \x01\x02\0\x12\x04\xc2+\x02,\n\x0e\n\x06\x04\x98\x01\x02\0\x06\x12\x04\
    \xc2+\x02\x1b\n\x0e\n\x06\x04\x98\x01\x02\0\x01\x12\x04\xc2+\x1c'\n\x0e\
    \n\x06\x04\x98\x01\x02\0\x03\x12\x04\xc2+*+\n\x7f\n\x05\x04\x98\x01\x02\
    \x01\x12\x04\xc5+\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\
    \x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\
    \x04\x98\x01\x02\x01\x05\x12\x04\xc5+\x02\x08\n\x0e\n\x06\x04\x98\x01\
    \x02\x01\x01\x12\x04\xc5+\t\r\n\x0e\n\x06\x04\x98\x01\x02\x01\x03\x12\
    \x04\xc5+\x10\x11\nv\n\x05\x04\x98\x01\x02\x02\x12\x04\xc8+\x02\x16\x1ag\
    \x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20\
    that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20\
    to\x20128.\n\n\x0e\n\x06\x04\x98\x01\x02\x02\x05\x12\x04\xc8+\x02\x08\n\
    \x0e\n\x06\x04\x98\x01\x02\x02\x01\x12\x04\xc8+\t\x11\n\x0e\n\x06\x04\
    \x98\x01\x02\x02\x03\x12\x04\xc8+\x14\x15\nV\n\x05\x04\x98\x01\x02\x03\
    \x12\x04\xca+\x02\x1a\x1aG\x20If\x20true,\x20sort\x20in\x20ascending\x20\
    order,\x20otherwise\x20sort\x20in\x20descending\x20order.\n\n\x0e\n\x06\
    \x04\x98\x01\x02\x03\x05\x12\x04\xca+\x02\x06\n\x0e\n\x06\x04\x98\x01\
    \x02\x03\x01\x12\x04\xca+\x07\x15\n\x0e\n\x06\x04\x98\x01\x02\x03\x03\
    \x12\x04\xca+\x18\x19\n\x0f\n\x05\x04\x98\x01\x08\0\x12\x06\xcb+\x02\xdd\
    +\x03\n\x0e\n\x06\x04\x98\x01\x08\0\x01\x12\x04\xcb+\x08\x0f\n3\n\x05\
    \x04\x98\x01\x02\x04\x12\x04\xcd+\x04\x1c\x1a$\x20Whether\x20to\x20order\
    \x20by\x20application\x20id\n\n\x0e\n\x06\x04\x98\x01\x02\x04\x05\x12\
    \x04\xcd+\x04\x08\n\x0e\n\x06\x04\x98\x01\x02\x04\x01\x12\x04\xcd+\t\x17\
    \n\x0e\n\x06\x04\x98\x01\x02\x04\x03\x12\x04\xcd+\x1a\x1b\nJ\n\x05\x04\
    \x98\x01\x02\x05\x12\x04\xcf+\x04\x1d\x1a;\x20Whether\x20to\x20order\x20\
    by\x20eval\x20metric\x20summary.macro_avg_roc_auc\n\n\x0e\n\x06\x04\x98\
    \x01\x02\x05\x05\x12\x04\xcf+\x04\x08\n\x0e\n\x06\x04\x98\x01\x02\x05\
    \x01\x12\x04\xcf+\t\x18\n\x0e\n\x06\x04\x98\x01\x02\x05\x03\x12\x04\xcf+\
    \x1b\x1c\n;\n\x05\x04\x98\x01\x02\x06\x12\x04\xd1+\x04\x18\x1a,\x20Wheth\
    er\x20to\x20order\x20by\x20eval\x20metric\x20summary.f1\n\n\x0e\n\x06\
    \x04\x98\x01\x02\x06\x05\x12\x04\xd1+\x04\x08\n\x0e\n\x06\x04\x98\x01\
    \x02\x06\x01\x12\x04\xd1+\t\x13\n\x0e\n\x06\x04\x98\x01\x02\x06\x03\x12\
    \x04\xd1+\x16\x17\n@\n\x05\x04\x98\x01\x02\x07\x12\x04\xd3+\x04\x20\x1a1\
    \x20Whether\x20to\x20order\x20by\x20when\x20the\x20metric\x20was\x20crea\
    ted\n\n\x0e\n\x06\x04\x98\x01\x02\x07\x05\x12\x04\xd3+\x04\x08\n\x0e\n\
    \x06\x04\x98\x01\x02\x07\x01\x12\x04\xd3+\t\x1b\n\x0e\n\x06\x04\x98\x01\
    \x02\x07\x03\x12\x04\xd3+\x1e\x1f\nR\n\x05\x04\x98\x01\x02\x08\x12\x04\
    \xd5+\x04(\x1aC\x20Whether\x20to\x20order\x20by\x20eval\x20metric\x20sum\
    mary.mean_avg_precision_iou_50\n\n\x0e\n\x06\x04\x98\x01\x02\x08\x05\x12\
    \x04\xd5+\x04\x08\n\x0e\n\x06\x04\x98\x01\x02\x08\x01\x12\x04\xd5+\t#\n\
    \x0e\n\x06\x04\x98\x01\x02\x08\x03\x12\x04\xd5+&'\nL\n\x05\x04\x98\x01\
    \x02\t\x12\x04\xd7+\x04\x20\x1a=\x20Whether\x20to\x20order\x20by\x20eval\
    \x20metric\x20summary.macro_avg_precision\n\n\x0e\n\x06\x04\x98\x01\x02\
    \t\x05\x12\x04\xd7+\x04\x08\n\x0e\n\x06\x04\x98\x01\x02\t\x01\x12\x04\
    \xd7+\t\x1a\n\x0e\n\x06\x04\x98\x01\x02\t\x03\x12\x04\xd7+\x1d\x1f\nI\n\
    \x05\x04\x98\x01\x02\n\x12\x04\xd9+\x04\x1d\x1a:\x20Whether\x20to\x20ord\
    er\x20by\x20eval\x20metric\x20summary.macro_avg_recall\n\n\x0e\n\x06\x04\
    \x98\x01\x02\n\x05\x12\x04\xd9+\x04\x08\n\x0e\n\x06\x04\x98\x01\x02\n\
    \x01\x12\x04\xd9+\t\x17\n\x0e\n\x06\x04\x98\x01\x02\n\x03\x12\x04\xd9+\
    \x1a\x1c\n\r\n\x05\x04\x98\x01\x02\x0b\x12\x04\xda+\x04\x1f\n\x0e\n\x06\
    \x04\x98\x01\x02\x0b\x05\x12\x04\xda+\x04\x08\n\x0e\n\x06\x04\x98\x01\
    \x02\x0b\x01\x12\x04\xda+\t\x19\n\x0e\n\x06\x04\x98\x01\x02\x0b\x03\x12\
    \x04\xda+\x1c\x1e\n\r\n\x05\x04\x98\x01\x02\x0c\x12\x04\xdb+\x04&\n\x0e\
    \n\x06\x04\x98\x01\x02\x0c\x05\x12\x04\xdb+\x04\x08\n\x0e\n\x06\x04\x98\
    \x01\x02\x0c\x01\x12\x04\xdb+\t\x20\n\x0e\n\x06\x04\x98\x01\x02\x0c\x03\
    \x12\x04\xdb+#%\n\r\n\x05\x04\x98\x01\x02\r\x12\x04\xdc+\x04'\n\x0e\n\
    \x06\x04\x98\x01\x02\r\x05\x12\x04\xdc+\x04\x08\n\x0e\n\x06\x04\x98\x01\
    \x02\r\x01\x12\x04\xdc+\t!\n\x0e\n\x06\x04\x98\x01\x02\r\x03\x12\x04\xdc\
    +$&\n(\n\x05\x04\x98\x01\x02\x0e\x12\x04\xdf+\x02\x1c\x1a\x19\x20Filter\
    \x20on\x20model\x20type\x20id\n\n\x0e\n\x06\x04\x98\x01\x02\x0e\x05\x12\
    \x04\xdf+\x02\x08\n\x0e\n\x06\x04\x98\x01\x02\x0e\x01\x12\x04\xdf+\t\x16\
    \n\x0e\n\x06\x04\x98\x01\x02\x0e\x03\x12\x04\xdf+\x19\x1b\n\\\n\x05\x04\
    \x98\x01\x02\x0f\x12\x04\xe1+\x02(\x1aM\x20Filter\x20on\x20dataset\x20ID\
    \x20of\x20the\x20dataset\x20version\x20specified\x20in\x20the\x20metric\
    \x20version\n\n\x0e\n\x06\x04\x98\x01\x02\x0f\x04\x12\x04\xe1+\x02\n\n\
    \x0e\n\x06\x04\x98\x01\x02\x0f\x05\x12\x04\xe1+\x0b\x11\n\x0e\n\x06\x04\
    \x98\x01\x02\x0f\x01\x12\x04\xe1+\x12\"\n\x0e\n\x06\x04\x98\x01\x02\x0f\
    \x03\x12\x04\xe1+%'\n[\n\x05\x04\x98\x01\x02\x10\x12\x04\xe3+\x02)\x1aL\
    \x20Filter\x20on\x20dataset\x20ID\x20of\x20the\x20dataset\x20version\x20\
    specified\x20by\x20the\x20model\x20version\n\n\x0e\n\x06\x04\x98\x01\x02\
    \x10\x04\x12\x04\xe3+\x02\n\n\x0e\n\x06\x04\x98\x01\x02\x10\x05\x12\x04\
    \xe3+\x0b\x11\n\x0e\n\x06\x04\x98\x01\x02\x10\x01\x12\x04\xe3+\x12#\n\
    \x0e\n\x06\x04\x98\x01\x02\x10\x03\x12\x04\xe3+&(\nT\n\x05\x04\x98\x01\
    \x02\x11\x12\x04\xe5+\x02#\x1aE\x20Filter\x20on\x20concept\x20IDs\x20spe\
    cified\x20in\x20the\x20modele\x20version's\x20output_info\n\n\x0e\n\x06\
    \x04\x98\x01\x02\x11\x04\x12\x04\xe5+\x02\n\n\x0e\n\x06\x04\x98\x01\x02\
    \x11\x05\x12\x04\xe5+\x0b\x11\n\x0e\n\x06\x04\x98\x01\x02\x11\x01\x12\
    \x04\xe5+\x12\x1d\n\x0e\n\x06\x04\x98\x01\x02\x11\x03\x12\x04\xe5+\x20\"\
    \nB\n\x05\x04\x98\x01\x02\x12\x12\x04\xe7+\x02\x20\x1a3\x20Whether\x20to\
    \x20show\x20failed\x20metrics,\x20defaults\x20to\x20false\n\n\x0e\n\x06\
    \x04\x98\x01\x02\x12\x05\x12\x04\xe7+\x02\x06\n\x0e\n\x06\x04\x98\x01\
    \x02\x12\x01\x12\x04\xe7+\x07\x1a\n\x0e\n\x06\x04\x98\x01\x02\x12\x03\
    \x12\x04\xe7+\x1d\x1f\n\r\n\x03\x04\x99\x01\x12\x06\xea+\0\xf0+\x01\n\
    \x0c\n\x04\x04\x99\x01\x01\x12\x04\xea+\x08\x1c\n\r\n\x05\x04\x99\x01\
    \x02\0\x12\x04\xeb+\x02,\n\x0e\n\x06\x04\x99\x01\x02\0\x06\x12\x04\xeb+\
    \x02\x1b\n\x0e\n\x06\x04\x99\x01\x02\0\x01\x12\x04\xeb+\x1c'\n\x0e\n\x06\
    \x04\x99\x01\x02\0\x03\x12\x04\xeb+*+\n\r\n\x05\x04\x99\x01\x02\x01\x12\
    \x04\xec+\x02\x1b\n\x0e\n\x06\x04\x99\x01\x02\x01\x05\x12\x04\xec+\x02\
    \x08\n\x0e\n\x06\x04\x99\x01\x02\x01\x01\x12\x04\xec+\t\x16\n\x0e\n\x06\
    \x04\x99\x01\x02\x01\x03\x12\x04\xec+\x19\x1a\no\n\x05\x04\x99\x01\x02\
    \x02\x12\x04\xef+\x02\x19\x1a`\x20Any\x20of\x20the\x20fields\x20you\x20w\
    ish\x20to\x20return\x20in\x20the\x20metrics\n\x20By\x20default,\x20only\
    \x20the\x20summary\x20is\x20returned.\n\n\x0e\n\x06\x04\x99\x01\x02\x02\
    \x06\x12\x04\xef+\x02\r\n\x0e\n\x06\x04\x99\x01\x02\x02\x01\x12\x04\xef+\
    \x0e\x14\n\x0e\n\x06\x04\x99\x01\x02\x02\x03\x12\x04\xef+\x17\x18\n+\n\
    \x03\x04\x9a\x01\x12\x06\xf5+\0\xfb+\x01\x1a\x1c\x20Evaluate\x20this\x20\
    model\x20vesion\n\n\x0c\n\x04\x04\x9a\x01\x01\x12\x04\xf5+\x08*\n\r\n\
    \x05\x04\x9a\x01\x02\0\x12\x04\xf6+\x02,\n\x0e\n\x06\x04\x9a\x01\x02\0\
    \x06\x12\x04\xf6+\x02\x1b\n\x0e\n\x06\x04\x9a\x01\x02\0\x01\x12\x04\xf6+\
    \x1c'\n\x0e\n\x06\x04\x9a\x01\x02\0\x03\x12\x04\xf6+*+\n\r\n\x05\x04\x9a\
    \x01\x02\x01\x12\x04\xf7+\x02\x16\n\x0e\n\x06\x04\x9a\x01\x02\x01\x05\
    \x12\x04\xf7+\x02\x08\n\x0e\n\x06\x04\x9a\x01\x02\x01\x01\x12\x04\xf7+\t\
    \x11\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\x12\x04\xf7+\x14\x15\n\r\n\x05\
    \x04\x9a\x01\x02\x02\x12\x04\xf8+\x02\x1e\n\x0e\n\x06\x04\x9a\x01\x02\
    \x02\x05\x12\x04\xf8+\x02\x08\n\x0e\n\x06\x04\x9a\x01\x02\x02\x01\x12\
    \x04\xf8+\t\x19\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\x12\x04\xf8+\x1c\x1d\
    \nJ\n\x05\x04\x9a\x01\x02\x03\x12\x04\xfa+\x02(\x1a;\x20EvalInfo\x20and\
    \x20ID\x20will\x20be\x20used\x20when\x20creating\x20the\x20evaluation\n\
    \n\x0e\n\x06\x04\x9a\x01\x02\x03\x04\x12\x04\xfa+\x02\n\n\x0e\n\x06\x04\
    \x9a\x01\x02\x03\x06\x12\x04\xfa+\x0b\x16\n\x0e\n\x06\x04\x9a\x01\x02\
    \x03\x01\x12\x04\xfa+\x17#\n\x0e\n\x06\x04\x9a\x01\x02\x03\x03\x12\x04\
    \xfa+&'\n\r\n\x03\x04\x9b\x01\x12\x06\xfd+\0\x89,\x01\n\x0c\n\x04\x04\
    \x9b\x01\x01\x12\x04\xfd+\x08*\n\r\n\x05\x04\x9b\x01\x02\0\x12\x04\xfe+\
    \x02,\n\x0e\n\x06\x04\x9b\x01\x02\0\x06\x12\x04\xfe+\x02\x1b\n\x0e\n\x06\
    \x04\x9b\x01\x02\0\x01\x12\x04\xfe+\x1c'\n\x0e\n\x06\x04\x9b\x01\x02\0\
    \x03\x12\x04\xfe+*+\n\r\n\x05\x04\x9b\x01\x02\x01\x12\x04\xff+\x02\x16\n\
    \x0e\n\x06\x04\x9b\x01\x02\x01\x05\x12\x04\xff+\x02\x08\n\x0e\n\x06\x04\
    \x9b\x01\x02\x01\x01\x12\x04\xff+\t\x11\n\x0e\n\x06\x04\x9b\x01\x02\x01\
    \x03\x12\x04\xff+\x14\x15\n\r\n\x05\x04\x9b\x01\x02\x02\x12\x04\x80,\x02\
    \x1e\n\x0e\n\x06\x04\x9b\x01\x02\x02\x05\x12\x04\x80,\x02\x08\n\x0e\n\
    \x06\x04\x9b\x01\x02\x02\x01\x12\x04\x80,\t\x19\n\x0e\n\x06\x04\x9b\x01\
    \x02\x02\x03\x12\x04\x80,\x1c\x1d\n\x7f\n\x05\x04\x9b\x01\x02\x03\x12\
    \x04\x84,\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x9b\x01\
    \x02\x03\x05\x12\x04\x84,\x02\x08\n\x0e\n\x06\x04\x9b\x01\x02\x03\x01\
    \x12\x04\x84,\t\r\n\x0e\n\x06\x04\x9b\x01\x02\x03\x03\x12\x04\x84,\x10\
    \x11\nv\n\x05\x04\x9b\x01\x02\x04\x12\x04\x88,\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\x0e\n\x06\x04\x9b\x01\x02\x04\x05\x12\x04\x88,\x02\x08\n\x0e\n\x06\
    \x04\x9b\x01\x02\x04\x01\x12\x04\x88,\t\x11\n\x0e\n\x06\x04\x9b\x01\x02\
    \x04\x03\x12\x04\x88,\x14\x15\n\r\n\x03\x04\x9c\x01\x12\x06\x8b,\0\x94,\
    \x01\n\x0c\n\x04\x04\x9c\x01\x01\x12\x04\x8b,\x08(\n\r\n\x05\x04\x9c\x01\
    \x02\0\x12\x04\x8c,\x02,\n\x0e\n\x06\x04\x9c\x01\x02\0\x06\x12\x04\x8c,\
    \x02\x1b\n\x0e\n\x06\x04\x9c\x01\x02\0\x01\x12\x04\x8c,\x1c'\n\x0e\n\x06\
    \x04\x9c\x01\x02\0\x03\x12\x04\x8c,*+\n\r\n\x05\x04\x9c\x01\x02\x01\x12\
    \x04\x8d,\x02\x16\n\x0e\n\x06\x04\x9c\x01\x02\x01\x05\x12\x04\x8d,\x02\
    \x08\n\x0e\n\x06\x04\x9c\x01\x02\x01\x01\x12\x04\x8d,\t\x11\n\x0e\n\x06\
    \x04\x9c\x01\x02\x01\x03\x12\x04\x8d,\x14\x15\n\r\n\x05\x04\x9c\x01\x02\
    \x02\x12\x04\x8e,\x02\x1e\n\x0e\n\x06\x04\x9c\x01\x02\x02\x05\x12\x04\
    \x8e,\x02\x08\n\x0e\n\x06\x04\x9c\x01\x02\x02\x01\x12\x04\x8e,\t\x19\n\
    \x0e\n\x06\x04\x9c\x01\x02\x02\x03\x12\x04\x8e,\x1c\x1d\n\r\n\x05\x04\
    \x9c\x01\x02\x03\x12\x04\x8f,\x02\x1b\n\x0e\n\x06\x04\x9c\x01\x02\x03\
    \x05\x12\x04\x8f,\x02\x08\n\x0e\n\x06\x04\x9c\x01\x02\x03\x01\x12\x04\
    \x8f,\t\x16\n\x0e\n\x06\x04\x9c\x01\x02\x03\x03\x12\x04\x8f,\x19\x1a\nx\
    \n\x05\x04\x9c\x01\x02\x04\x12\x04\x93,\x02\x19\x1ai\x20Any\x20of\x20the\
    \x20fields\x20you\x20wish\x20to\x20return\x20from\x20multiclass_metrics\
    \n\x20By\x20default,\x20only\x20the\x20summary\x20is\x20returned.\n\n\
    \x0e\n\x06\x04\x9c\x01\x02\x04\x06\x12\x04\x93,\x02\r\n\x0e\n\x06\x04\
    \x9c\x01\x02\x04\x01\x12\x04\x93,\x0e\x14\n\x0e\n\x06\x04\x9c\x01\x02\
    \x04\x03\x12\x04\x93,\x17\x18\n\r\n\x03\x04\x9d\x01\x12\x06\x96,\0\x99,\
    \x01\n\x0c\n\x04\x04\x9d\x01\x01\x12\x04\x96,\x08!\n\r\n\x05\x04\x9d\x01\
    \x02\0\x12\x04\x97,\x02(\n\x0e\n\x06\x04\x9d\x01\x02\0\x06\x12\x04\x97,\
    \x02\x1c\n\x0e\n\x06\x04\x9d\x01\x02\0\x01\x12\x04\x97,\x1d#\n\x0e\n\x06\
    \x04\x9d\x01\x02\0\x03\x12\x04\x97,&'\n\r\n\x05\x04\x9d\x01\x02\x01\x12\
    \x04\x98,\x02\x1f\n\x0e\n\x06\x04\x9d\x01\x02\x01\x06\x12\x04\x98,\x02\r\
    \n\x0e\n\x06\x04\x9d\x01\x02\x01\x01\x12\x04\x98,\x0e\x1a\n\x0e\n\x06\
    \x04\x9d\x01\x02\x01\x03\x12\x04\x98,\x1d\x1e\n\r\n\x03\x04\x9e\x01\x12\
    \x06\x9b,\0\x9e,\x01\n\x0c\n\x04\x04\x9e\x01\x01\x12\x04\x9b,\x08\x20\n\
    \r\n\x05\x04\x9e\x01\x02\0\x12\x04\x9c,\x02(\n\x0e\n\x06\x04\x9e\x01\x02\
    \0\x06\x12\x04\x9c,\x02\x1c\n\x0e\n\x06\x04\x9e\x01\x02\0\x01\x12\x04\
    \x9c,\x1d#\n\x0e\n\x06\x04\x9e\x01\x02\0\x03\x12\x04\x9c,&'\n\r\n\x05\
    \x04\x9e\x01\x02\x01\x12\x04\x9d,\x02(\n\x0e\n\x06\x04\x9e\x01\x02\x01\
    \x04\x12\x04\x9d,\x02\n\n\x0e\n\x06\x04\x9e\x01\x02\x01\x06\x12\x04\x9d,\
    \x0b\x16\n\x0e\n\x06\x04\x9e\x01\x02\x01\x01\x12\x04\x9d,\x17#\n\x0e\n\
    \x06\x04\x9e\x01\x02\x01\x03\x12\x04\x9d,&'\n-\n\x03\x04\x9f\x01\x12\x06\
    \xa1,\0\xac,\x01\x1a\x1e\x20Evaluate\x20this\x20model\x20version.\n\n\
    \x0c\n\x04\x04\x9f\x01\x01\x12\x04\xa1,\x08&\n\x0c\n\x04\x04\x9f\x01\t\
    \x12\x04\xa2,\x02\r\n\r\n\x05\x04\x9f\x01\t\0\x12\x04\xa2,\x0b\x0c\n\x0e\
    \n\x06\x04\x9f\x01\t\0\x01\x12\x04\xa2,\x0b\x0c\n\x0e\n\x06\x04\x9f\x01\
    \t\0\x02\x12\x04\xa2,\x0b\x0c\n\r\n\x05\x04\x9f\x01\x02\0\x12\x04\xa3,\
    \x02,\n\x0e\n\x06\x04\x9f\x01\x02\0\x06\x12\x04\xa3,\x02\x1b\n\x0e\n\x06\
    \x04\x9f\x01\x02\0\x01\x12\x04\xa3,\x1c'\n\x0e\n\x06\x04\x9f\x01\x02\0\
    \x03\x12\x04\xa3,*+\n\r\n\x05\x04\x9f\x01\x02\x01\x12\x04\xa4,\x02\x16\n\
    \x0e\n\x06\x04\x9f\x01\x02\x01\x05\x12\x04\xa4,\x02\x08\n\x0e\n\x06\x04\
    \x9f\x01\x02\x01\x01\x12\x04\xa4,\t\x11\n\x0e\n\x06\x04\x9f\x01\x02\x01\
    \x03\x12\x04\xa4,\x14\x15\n\r\n\x05\x04\x9f\x01\x02\x02\x12\x04\xa5,\x02\
    \x18\n\x0e\n\x06\x04\x9f\x01\x02\x02\x05\x12\x04\xa5,\x02\x08\n\x0e\n\
    \x06\x04\x9f\x01\x02\x02\x01\x12\x04\xa5,\t\x13\n\x0e\n\x06\x04\x9f\x01\
    \x02\x02\x03\x12\x04\xa5,\x16\x17\nF\n\x05\x04\x9f\x01\x02\x03\x12\x04\
    \xa8,\x02&\x1a7\x20Use\x20this\x20to\x20filter\x20inputs\x20that\x20are\
    \x20used\x20in\x20evaluation\n\n\x0e\n\x06\x04\x9f\x01\x02\x03\x06\x12\
    \x04\xa8,\x02\x15\n\x0e\n\x06\x04\x9f\x01\x02\x03\x01\x12\x04\xa8,\x16!\
    \n\x0e\n\x06\x04\x9f\x01\x02\x03\x03\x12\x04\xa8,$%\nF\n\x05\x04\x9f\x01\
    \x02\x04\x12\x04\xab,\x02\x1a\x1a7\x20evaluation\x20info.\x20Such\x20as\
    \x20dataset\x20used\x20for\x20evaluation.\n\n\x0e\n\x06\x04\x9f\x01\x02\
    \x04\x06\x12\x04\xab,\x02\n\n\x0e\n\x06\x04\x9f\x01\x02\x04\x01\x12\x04\
    \xab,\x0b\x14\n\x0e\n\x06\x04\x9f\x01\x02\x04\x03\x12\x04\xab,\x17\x19\n\
    U\n\x03\x04\xa0\x01\x12\x06\xb0,\0\xb8,\x01\x1aF\x20Get\x20the\x20alread\
    y\x20computed\x20evaluation\x20metrics\x20for\x20this\x20model\n\x20vers\
    ion.\n\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\xb0,\x08%\n\r\n\x05\x04\xa0\
    \x01\x02\0\x12\x04\xb1,\x02,\n\x0e\n\x06\x04\xa0\x01\x02\0\x06\x12\x04\
    \xb1,\x02\x1b\n\x0e\n\x06\x04\xa0\x01\x02\0\x01\x12\x04\xb1,\x1c'\n\x0e\
    \n\x06\x04\xa0\x01\x02\0\x03\x12\x04\xb1,*+\n\r\n\x05\x04\xa0\x01\x02\
    \x01\x12\x04\xb2,\x02\x16\n\x0e\n\x06\x04\xa0\x01\x02\x01\x05\x12\x04\
    \xb2,\x02\x08\n\x0e\n\x06\x04\xa0\x01\x02\x01\x01\x12\x04\xb2,\t\x11\n\
    \x0e\n\x06\x04\xa0\x01\x02\x01\x03\x12\x04\xb2,\x14\x15\n\r\n\x05\x04\
    \xa0\x01\x02\x02\x12\x04\xb3,\x02\x18\n\x0e\n\x06\x04\xa0\x01\x02\x02\
    \x05\x12\x04\xb3,\x02\x08\n\x0e\n\x06\x04\xa0\x01\x02\x02\x01\x12\x04\
    \xb3,\t\x13\n\x0e\n\x06\x04\xa0\x01\x02\x02\x03\x12\x04\xb3,\x16\x17\n|\
    \n\x05\x04\xa0\x01\x02\x03\x12\x04\xb7,\x02\x19\x1am\x20Any\x20of\x20the\
    \x20fields\x20you\x20wish\x20to\x20return\x20from\x20multiclass_metrics\
    \n\x20By\x20default,\x20only\x20the\x20summary\x20will\x20be\x20returned\
    \n\n\x0e\n\x06\x04\xa0\x01\x02\x03\x06\x12\x04\xb7,\x02\r\n\x0e\n\x06\
    \x04\xa0\x01\x02\x03\x01\x12\x04\xb7,\x0e\x14\n\x0e\n\x06\x04\xa0\x01\
    \x02\x03\x03\x12\x04\xb7,\x17\x18\n\xeb\x01\n\x03\x04\xa1\x01\x12\x06\
    \xc5,\0\xca,\x01\x1a\x15\x20GetModelTypeRequest\n2\xc4\x01\x20//\x20Requ\
    est\x20to\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20i\
    ds.\n\x20message\x20DeleteModelVersionsRequest\x20{\n\x20\x20\x20clarifa\
    i.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20repeated\x20st\
    ring\x20ids\x20=\x202;\n\x20\x20\x20bool\x20delete_all\x20=\x203;\n\x20}\
    \n\n\x0c\n\x04\x04\xa1\x01\x01\x12\x04\xc5,\x08\x1b\nl\n\x05\x04\xa1\x01\
    \x02\0\x12\x04\xc7,\x02,\x1a]\x20use\x20and\x20app\x20combo.\x20Not\x20r\
    eally\x20used\x20for\x20this\x20endpoint\x20at\x20this\x20time\x20so\x20\
    may\x20go\x20away\x20in\x20future.\n\n\x0e\n\x06\x04\xa1\x01\x02\0\x06\
    \x12\x04\xc7,\x02\x1b\n\x0e\n\x06\x04\xa1\x01\x02\0\x01\x12\x04\xc7,\x1c\
    '\n\x0e\n\x06\x04\xa1\x01\x02\0\x03\x12\x04\xc7,*+\n@\n\x05\x04\xa1\x01\
    \x02\x01\x12\x04\xc9,\x02\x1b\x1a1\x20The\x20specific\x20ModelType.Id\
    \x20you\x20want\x20to\x20retrieve.\n\n\x0e\n\x06\x04\xa1\x01\x02\x01\x05\
    \x12\x04\xc9,\x02\x08\n\x0e\n\x06\x04\xa1\x01\x02\x01\x01\x12\x04\xc9,\t\
    \x16\n\x0e\n\x06\x04\xa1\x01\x02\x01\x03\x12\x04\xc9,\x19\x1a\n&\n\x03\
    \x04\xa2\x01\x12\x06\xcd,\0\xd6,\x01\x1a\x17\x20ListModelTypesRequest\n\
    \n\x0c\n\x04\x04\xa2\x01\x01\x12\x04\xcd,\x08\x1d\nl\n\x05\x04\xa2\x01\
    \x02\0\x12\x04\xcf,\x02,\x1a]\x20use\x20and\x20app\x20combo.\x20Not\x20r\
    eally\x20used\x20for\x20this\x20endpoint\x20at\x20this\x20time\x20so\x20\
    may\x20go\x20away\x20in\x20future.\n\n\x0e\n\x06\x04\xa2\x01\x02\0\x06\
    \x12\x04\xcf,\x02\x1b\n\x0e\n\x06\x04\xa2\x01\x02\0\x01\x12\x04\xcf,\x1c\
    '\n\x0e\n\x06\x04\xa2\x01\x02\0\x03\x12\x04\xcf,*+\n\x7f\n\x05\x04\xa2\
    \x01\x02\x01\x12\x04\xd2,\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\
    \x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\xa2\x01\x02\x01\x05\x12\x04\xd2,\x02\x08\n\x0e\n\x06\x04\xa2\
    \x01\x02\x01\x01\x12\x04\xd2,\t\r\n\x0e\n\x06\x04\xa2\x01\x02\x01\x03\
    \x12\x04\xd2,\x10\x11\nv\n\x05\x04\xa2\x01\x02\x02\x12\x04\xd5,\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\xa2\x01\x02\x02\x05\x12\x04\xd5,\x02\
    \x08\n\x0e\n\x06\x04\xa2\x01\x02\x02\x01\x12\x04\xd5,\t\x11\n\x0e\n\x06\
    \x04\xa2\x01\x02\x02\x03\x12\x04\xd5,\x14\x15\n,\n\x03\x04\xa3\x01\x12\
    \x04\xd9,\0(\x1a\x1f\x20ListOpenSourceLicensesRequest\n\n\x0c\n\x04\x04\
    \xa3\x01\x01\x12\x04\xd9,\x08%\n/\n\x03\x04\xa4\x01\x12\x06\xdc,\0\xdf,\
    \x01\x1a\x20\x20ListOpenSourceLicensesResponse\n\n\x0c\n\x04\x04\xa4\x01\
    \x01\x12\x04\xdc,\x08&\n\r\n\x05\x04\xa4\x01\x02\0\x12\x04\xdd,\x02(\n\
    \x0e\n\x06\x04\xa4\x01\x02\0\x06\x12\x04\xdd,\x02\x1c\n\x0e\n\x06\x04\
    \xa4\x01\x02\0\x01\x12\x04\xdd,\x1d#\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\
    \x12\x04\xdd,&'\n\r\n\x05\x04\xa4\x01\x02\x01\x12\x04\xde,\x02\x1f\n\x0e\
    \n\x06\x04\xa4\x01\x02\x01\x04\x12\x04\xde,\x02\n\n\x0e\n\x06\x04\xa4\
    \x01\x02\x01\x05\x12\x04\xde,\x0b\x11\n\x0e\n\x06\x04\xa4\x01\x02\x01\
    \x01\x12\x04\xde,\x12\x1a\n\x0e\n\x06\x04\xa4\x01\x02\x01\x03\x12\x04\
    \xde,\x1d\x1e\n(\n\x03\x04\xa5\x01\x12\x06\xe2,\0\xe7,\x01\x1a\x19\x20Si\
    ngleModelTypeResponse\n\n\x0c\n\x04\x04\xa5\x01\x01\x12\x04\xe2,\x08\x1f\
    \n(\n\x05\x04\xa5\x01\x02\0\x12\x04\xe4,\x02(\x1a\x19\x20Status\x20of\
    \x20the\x20response.\n\n\x0e\n\x06\x04\xa5\x01\x02\0\x06\x12\x04\xe4,\
    \x02\x1c\n\x0e\n\x06\x04\xa5\x01\x02\0\x01\x12\x04\xe4,\x1d#\n\x0e\n\x06\
    \x04\xa5\x01\x02\0\x03\x12\x04\xe4,&'\n2\n\x05\x04\xa5\x01\x02\x01\x12\
    \x04\xe6,\x02J\x1a#\x20The\x20retrieved\x20ModelType\x20object.\x20.\n\n\
    \x0e\n\x06\x04\xa5\x01\x02\x01\x06\x12\x04\xe6,\x02\x0b\n\x0e\n\x06\x04\
    \xa5\x01\x02\x01\x01\x12\x04\xe6,\x0c\x16\n\x0e\n\x06\x04\xa5\x01\x02\
    \x01\x03\x12\x04\xe6,\x19\x1a\n\x0e\n\x06\x04\xa5\x01\x02\x01\x08\x12\
    \x04\xe6,\x1bI\n\x11\n\t\x04\xa5\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xe6\
    ,\x1cH\n'\n\x03\x04\xa6\x01\x12\x06\xea,\0\xf3,\x01\x1a\x18\x20MultiMode\
    lTypeResponse\n\n\x0c\n\x04\x04\xa6\x01\x01\x12\x04\xea,\x08\x1e\n(\n\
    \x05\x04\xa6\x01\x02\0\x12\x04\xec,\x02(\x1a\x19\x20Status\x20of\x20the\
    \x20response.\n\n\x0e\n\x06\x04\xa6\x01\x02\0\x06\x12\x04\xec,\x02\x1c\n\
    \x0e\n\x06\x04\xa6\x01\x02\0\x01\x12\x04\xec,\x1d#\n\x0e\n\x06\x04\xa6\
    \x01\x02\0\x03\x12\x04\xec,&'\n+\n\x05\x04\xa6\x01\x02\x01\x12\x04\xee,\
    \x02T\x1a\x1c\x20List\x20of\x20ModelType\x20objects.\n\n\x0e\n\x06\x04\
    \xa6\x01\x02\x01\x04\x12\x04\xee,\x02\n\n\x0e\n\x06\x04\xa6\x01\x02\x01\
    \x06\x12\x04\xee,\x0b\x14\n\x0e\n\x06\x04\xa6\x01\x02\x01\x01\x12\x04\
    \xee,\x15\x20\n\x0e\n\x06\x04\xa6\x01\x02\x01\x03\x12\x04\xee,#$\n\x0e\n\
    \x06\x04\xa6\x01\x02\x01\x08\x12\x04\xee,%S\n\x11\n\t\x04\xa6\x01\x02\
    \x01\x08\xd0\x86\x03\x12\x04\xee,&R\n(\n\x05\x04\xa6\x01\x02\x02\x12\x04\
    \xf0,\x02%\x1a\x19\x20List\x20of\x20model\x20importers\n\n\x0e\n\x06\x04\
    \xa6\x01\x02\x02\x06\x12\x04\xf0,\x02\x10\n\x0e\n\x06\x04\xa6\x01\x02\
    \x02\x01\x12\x04\xf0,\x11\x20\n\x0e\n\x06\x04\xa6\x01\x02\x02\x03\x12\
    \x04\xf0,#$\nD\n\x05\x04\xa6\x01\x02\x03\x12\x04\xf2,\x028\x1a5\x20Trito\
    n\x20model\x20envs\x20that\x20can\x20be\x20used\x20for\x20model\x20uploa\
    d\n\n\x0e\n\x06\x04\xa6\x01\x02\x03\x04\x12\x04\xf2,\x02\n\n\x0e\n\x06\
    \x04\xa6\x01\x02\x03\x06\x12\x04\xf2,\x0b\x1d\n\x0e\n\x06\x04\xa6\x01\
    \x02\x03\x01\x12\x04\xf2,\x1e4\n\x0e\n\x06\x04\xa6\x01\x02\x03\x03\x12\
    \x04\xf2,67\n3\n\x03\x04\xa7\x01\x12\x06\xf6,\0\xff,\x01\x1a$\x20GetMode\
    lVersionInputExampleRequest\n\n\x0c\n\x04\x04\xa7\x01\x01\x12\x04\xf6,\
    \x08*\nA\n\x05\x04\xa7\x01\x02\0\x12\x04\xf8,\x02,\x1a2\x20authorization\
    \x20field\x20\x20(contains\x20app/user\x20id\x20info)\n\n\x0e\n\x06\x04\
    \xa7\x01\x02\0\x06\x12\x04\xf8,\x02\x1b\n\x0e\n\x06\x04\xa7\x01\x02\0\
    \x01\x12\x04\xf8,\x1c'\n\x0e\n\x06\x04\xa7\x01\x02\0\x03\x12\x04\xf8,*+\
    \n3\n\x05\x04\xa7\x01\x02\x01\x12\x04\xfa,\x02\x16\x1a$\x20id\x20of\x20m\
    odel\x20the\x20example\x20belongs\x20to\n\n\x0e\n\x06\x04\xa7\x01\x02\
    \x01\x05\x12\x04\xfa,\x02\x08\n\x0e\n\x06\x04\xa7\x01\x02\x01\x01\x12\
    \x04\xfa,\t\x11\n\x0e\n\x06\x04\xa7\x01\x02\x01\x03\x12\x04\xfa,\x14\x15\
    \n8\n\x05\x04\xa7\x01\x02\x02\x12\x04\xfc,\x02\x1e\x1a)\x20specific\x20v\
    ersion\x20the\x20example\x20belongs\x20to\n\n\x0e\n\x06\x04\xa7\x01\x02\
    \x02\x05\x12\x04\xfc,\x02\x08\n\x0e\n\x06\x04\xa7\x01\x02\x02\x01\x12\
    \x04\xfc,\t\x19\n\x0e\n\x06\x04\xa7\x01\x02\x02\x03\x12\x04\xfc,\x1c\x1d\
    \n'\n\x05\x04\xa7\x01\x02\x03\x12\x04\xfe,\x02\x18\x1a\x18\x20Id\x20of\
    \x20example\x20to\x20fetch\n\n\x0e\n\x06\x04\xa7\x01\x02\x03\x05\x12\x04\
    \xfe,\x02\x08\n\x0e\n\x06\x04\xa7\x01\x02\x03\x01\x12\x04\xfe,\t\x13\n\
    \x0e\n\x06\x04\xa7\x01\x02\x03\x03\x12\x04\xfe,\x16\x17\n5\n\x03\x04\xa8\
    \x01\x12\x06\x82-\0\x8d-\x01\x1a&\x20ListModelVersionInputExamplesReques\
    t\n\n\x0c\n\x04\x04\xa8\x01\x01\x12\x04\x82-\x08,\nA\n\x05\x04\xa8\x01\
    \x02\0\x12\x04\x84-\x02,\x1a2\x20authorization\x20field\x20\x20(contains\
    \x20app/user\x20id\x20info)\n\n\x0e\n\x06\x04\xa8\x01\x02\0\x06\x12\x04\
    \x84-\x02\x1b\n\x0e\n\x06\x04\xa8\x01\x02\0\x01\x12\x04\x84-\x1c'\n\x0e\
    \n\x06\x04\xa8\x01\x02\0\x03\x12\x04\x84-*+\n3\n\x05\x04\xa8\x01\x02\x01\
    \x12\x04\x86-\x02\x16\x1a$\x20id\x20of\x20model\x20the\x20example\x20bel\
    ongs\x20to\n\n\x0e\n\x06\x04\xa8\x01\x02\x01\x05\x12\x04\x86-\x02\x08\n\
    \x0e\n\x06\x04\xa8\x01\x02\x01\x01\x12\x04\x86-\t\x11\n\x0e\n\x06\x04\
    \xa8\x01\x02\x01\x03\x12\x04\x86-\x14\x15\n8\n\x05\x04\xa8\x01\x02\x02\
    \x12\x04\x88-\x02\x1e\x1a)\x20specific\x20version\x20the\x20example\x20b\
    elongs\x20to\n\n\x0e\n\x06\x04\xa8\x01\x02\x02\x05\x12\x04\x88-\x02\x08\
    \n\x0e\n\x06\x04\xa8\x01\x02\x02\x01\x12\x04\x88-\t\x19\n\x0e\n\x06\x04\
    \xa8\x01\x02\x02\x03\x12\x04\x88-\x1c\x1d\n)\n\x05\x04\xa8\x01\x02\x03\
    \x12\x04\x8a-\x02\x12\x1a\x1a\x20Optional,\x20defaults\x20to\x201.\n\n\
    \x0e\n\x06\x04\xa8\x01\x02\x03\x05\x12\x04\x8a-\x02\x08\n\x0e\n\x06\x04\
    \xa8\x01\x02\x03\x01\x12\x04\x8a-\t\r\n\x0e\n\x06\x04\xa8\x01\x02\x03\
    \x03\x12\x04\x8a-\x10\x11\n?\n\x05\x04\xa8\x01\x02\x04\x12\x04\x8c-\x02\
    \x16\x1a0\x20Optional,\x20defaults\x20to\x20128\x20references\x20per\x20\
    page.\n\n\x0e\n\x06\x04\xa8\x01\x02\x04\x05\x12\x04\x8c-\x02\x08\n\x0e\n\
    \x06\x04\xa8\x01\x02\x04\x01\x12\x04\x8c-\t\x11\n\x0e\n\x06\x04\xa8\x01\
    \x02\x04\x03\x12\x04\x8c-\x14\x15\n7\n\x03\x04\xa9\x01\x12\x06\x92-\0\
    \x97-\x01\x1a(\x20SingleModelVersionInputExampleResponse\n\n\x0c\n\x04\
    \x04\xa9\x01\x01\x12\x04\x92-\x08.\n#\n\x05\x04\xa9\x01\x02\0\x12\x04\
    \x94-\x02(\x1a\x14\x20status\x20of\x20response\n\n\x0e\n\x06\x04\xa9\x01\
    \x02\0\x06\x12\x04\x94-\x02\x1c\n\x0e\n\x06\x04\xa9\x01\x02\0\x01\x12\
    \x04\x94-\x1d#\n\x0e\n\x06\x04\xa9\x01\x02\0\x03\x12\x04\x94-&'\n,\n\x05\
    \x04\xa9\x01\x02\x01\x12\x04\x96-\x02;\x1a\x1d\x20model\x20input\x20exam\
    ple\x20message\n\n\x0e\n\x06\x04\xa9\x01\x02\x01\x06\x12\x04\x96-\x02\
    \x1a\n\x0e\n\x06\x04\xa9\x01\x02\x01\x01\x12\x04\x96-\x1b6\n\x0e\n\x06\
    \x04\xa9\x01\x02\x01\x03\x12\x04\x96-9:\n6\n\x03\x04\xaa\x01\x12\x06\x9a\
    -\0\x9f-\x01\x1a'\x20MultiModelVersionInputExampleResponse\n\n\x0c\n\x04\
    \x04\xaa\x01\x01\x12\x04\x9a-\x08-\n#\n\x05\x04\xaa\x01\x02\0\x12\x04\
    \x9c-\x02(\x1a\x14\x20status\x20of\x20response\n\n\x0e\n\x06\x04\xaa\x01\
    \x02\0\x06\x12\x04\x9c-\x02\x1c\n\x0e\n\x06\x04\xaa\x01\x02\0\x01\x12\
    \x04\x9c-\x1d#\n\x0e\n\x06\x04\xaa\x01\x02\0\x03\x12\x04\x9c-&'\n-\n\x05\
    \x04\xaa\x01\x02\x01\x12\x04\x9e-\x02E\x1a\x1e\x20model\x20input\x20exam\
    ple\x20messages\n\n\x0e\n\x06\x04\xaa\x01\x02\x01\x04\x12\x04\x9e-\x02\n\
    \n\x0e\n\x06\x04\xaa\x01\x02\x01\x06\x12\x04\x9e-\x0b#\n\x0e\n\x06\x04\
    \xaa\x01\x02\x01\x01\x12\x04\x9e-$@\n\x0e\n\x06\x04\xaa\x01\x02\x01\x03\
    \x12\x04\x9e-CD\n+\n\x03\x04\xab\x01\x12\x06\xa2-\0\xaa-\x01\x1a\x1c\x20\
    ListModelReferencesRequest\n\n\x0c\n\x04\x04\xab\x01\x01\x12\x04\xa2-\
    \x08\"\n\r\n\x05\x04\xab\x01\x02\0\x12\x04\xa3-\x02,\n\x0e\n\x06\x04\xab\
    \x01\x02\0\x06\x12\x04\xa3-\x02\x1b\n\x0e\n\x06\x04\xab\x01\x02\0\x01\
    \x12\x04\xa3-\x1c'\n\x0e\n\x06\x04\xab\x01\x02\0\x03\x12\x04\xa3-*+\n\r\
    \n\x05\x04\xab\x01\x02\x01\x12\x04\xa5-\x02\x16\n\x0e\n\x06\x04\xab\x01\
    \x02\x01\x05\x12\x04\xa5-\x02\x08\n\x0e\n\x06\x04\xab\x01\x02\x01\x01\
    \x12\x04\xa5-\t\x11\n\x0e\n\x06\x04\xab\x01\x02\x01\x03\x12\x04\xa5-\x14\
    \x15\n)\n\x05\x04\xab\x01\x02\x02\x12\x04\xa7-\x02\x12\x1a\x1a\x20Option\
    al,\x20defaults\x20to\x201.\n\n\x0e\n\x06\x04\xab\x01\x02\x02\x05\x12\
    \x04\xa7-\x02\x08\n\x0e\n\x06\x04\xab\x01\x02\x02\x01\x12\x04\xa7-\t\r\n\
    \x0e\n\x06\x04\xab\x01\x02\x02\x03\x12\x04\xa7-\x10\x11\n?\n\x05\x04\xab\
    \x01\x02\x03\x12\x04\xa9-\x02\x16\x1a0\x20Optional,\x20defaults\x20to\
    \x20128\x20references\x20per\x20page.\n\n\x0e\n\x06\x04\xab\x01\x02\x03\
    \x05\x12\x04\xa9-\x02\x08\n\x0e\n\x06\x04\xab\x01\x02\x03\x01\x12\x04\
    \xa9-\t\x11\n\x0e\n\x06\x04\xab\x01\x02\x03\x03\x12\x04\xa9-\x14\x15\n,\
    \n\x03\x04\xac\x01\x12\x06\xaf-\0\xb2-\x01\x1a\x1d\x20MultiModelReferenc\
    eResponse\n\n\x0c\n\x04\x04\xac\x01\x01\x12\x04\xaf-\x08#\n\r\n\x05\x04\
    \xac\x01\x02\0\x12\x04\xb0-\x02(\n\x0e\n\x06\x04\xac\x01\x02\0\x06\x12\
    \x04\xb0-\x02\x1c\n\x0e\n\x06\x04\xac\x01\x02\0\x01\x12\x04\xb0-\x1d#\n\
    \x0e\n\x06\x04\xac\x01\x02\0\x03\x12\x04\xb0-&'\n\r\n\x05\x04\xac\x01\
    \x02\x01\x12\x04\xb1-\x02/\n\x0e\n\x06\x04\xac\x01\x02\x01\x04\x12\x04\
    \xb1-\x02\n\n\x0e\n\x06\x04\xac\x01\x02\x01\x06\x12\x04\xb1-\x0b\x19\n\
    \x0e\n\x06\x04\xac\x01\x02\x01\x01\x12\x04\xb1-\x1a*\n\x0e\n\x06\x04\xac\
    \x01\x02\x01\x03\x12\x04\xb1--.\n$\n\x03\x04\xad\x01\x12\x06\xb5-\0\xb9-\
    \x01\x1a\x15\x20MultiOutputResponse\n\n\x0c\n\x04\x04\xad\x01\x01\x12\
    \x04\xb5-\x08\x1b\n\r\n\x05\x04\xad\x01\x02\0\x12\x04\xb6-\x02(\n\x0e\n\
    \x06\x04\xad\x01\x02\0\x06\x12\x04\xb6-\x02\x1c\n\x0e\n\x06\x04\xad\x01\
    \x02\0\x01\x12\x04\xb6-\x1d#\n\x0e\n\x06\x04\xad\x01\x02\0\x03\x12\x04\
    \xb6-&'\nW\n\x05\x04\xad\x01\x02\x01\x12\x04\xb8-\x02M\x1aH\x20For\x20ea\
    ch\x20input\x20processed\x20during\x20model\x20prediction\x20we\x20creat\
    e\x20one\x20output.\n\n\x0e\n\x06\x04\xad\x01\x02\x01\x04\x12\x04\xb8-\
    \x02\n\n\x0e\n\x06\x04\xad\x01\x02\x01\x06\x12\x04\xb8-\x0b\x11\n\x0e\n\
    \x06\x04\xad\x01\x02\x01\x01\x12\x04\xb8-\x12\x19\n\x0e\n\x06\x04\xad\
    \x01\x02\x01\x03\x12\x04\xb8-\x1c\x1d\n\x0e\n\x06\x04\xad\x01\x02\x01\
    \x08\x12\x04\xb8-\x1eL\n\x11\n\t\x04\xad\x01\x02\x01\x08\xd0\x86\x03\x12\
    \x04\xb8-\x1fK\n\"\n\x03\x04\xae\x01\x12\x06\xbc-\0\xc3-\x01\x1a\x13\x20\
    ListScopesRequest\n\n\x0c\n\x04\x04\xae\x01\x01\x12\x04\xbc-\x08\x19\n\
    \xcc\x01\n\x05\x04\xae\x01\x02\0\x12\x04\xbf-\x02\x16\x1a\xbc\x01\x20If\
    \x20\"personal_access_token\"\x20include\x20scopes\x20and\x20endpoints\
    \x20available\x20to\x20personal\x20access\x20tokens.\n\x20If\x20\"app_sp\
    ecific_key\"\x20include\x20scopes\x20and\x20endpoints\x20available\x20to\
    \x20app-specific\x20keys.\x20(default)\n\n\x0e\n\x06\x04\xae\x01\x02\0\
    \x05\x12\x04\xbf-\x02\x08\n\x0e\n\x06\x04\xae\x01\x02\0\x01\x12\x04\xbf-\
    \t\x11\n\x0e\n\x06\x04\xae\x01\x02\0\x03\x12\x04\xbf-\x14\x15\np\n\x05\
    \x04\xae\x01\x02\x01\x12\x04\xc2-\x02,\x1aa\x20For\x20all\x20user\x20spe\
    cific\x20information\x20we\x20include\x20user_app_id\x20to\x20get\x20the\
    \x20user_id\x20in\x20a\x20consistent\x20way\n\n\x0e\n\x06\x04\xae\x01\
    \x02\x01\x06\x12\x04\xc2-\x02\x1b\n\x0e\n\x06\x04\xae\x01\x02\x01\x01\
    \x12\x04\xc2-\x1c'\n\x0e\n\x06\x04\xae\x01\x02\x01\x03\x12\x04\xc2-*+\n\
    \x20\n\x03\x04\xaf\x01\x12\x06\xc6-\0\xc8-\x01\x1a\x11\x20MyScopesReques\
    t\n\n\x0c\n\x04\x04\xaf\x01\x01\x12\x04\xc6-\x08\x17\n\r\n\x05\x04\xaf\
    \x01\x02\0\x12\x04\xc7-\x02,\n\x0e\n\x06\x04\xaf\x01\x02\0\x06\x12\x04\
    \xc7-\x02\x1b\n\x0e\n\x06\x04\xaf\x01\x02\0\x01\x12\x04\xc7-\x1c'\n\x0e\
    \n\x06\x04\xaf\x01\x02\0\x03\x12\x04\xc7-*+\n$\n\x03\x04\xb0\x01\x12\x06\
    \xcb-\0\xcd-\x01\x1a\x15\x20MyScopesUserRequest\n\n\x0c\n\x04\x04\xb0\
    \x01\x01\x12\x04\xcb-\x08\x1b\n\r\n\x05\x04\xb0\x01\x02\0\x12\x04\xcc-\
    \x02,\n\x0e\n\x06\x04\xb0\x01\x02\0\x06\x12\x04\xcc-\x02\x1b\n\x0e\n\x06\
    \x04\xb0\x01\x02\0\x01\x12\x04\xcc-\x1c'\n\x0e\n\x06\x04\xb0\x01\x02\0\
    \x03\x12\x04\xcc-*+\n$\n\x03\x04\xb1\x01\x12\x06\xd0-\0\xd1-\x01\x1a\x15\
    \x20MyScopesRootRequest\n\n\x0c\n\x04\x04\xb1\x01\x01\x12\x04\xd0-\x08\
    \x1b\n'\n\x03\x04\xb2\x01\x12\x06\xd4-\0\xdd-\x01\x1a\x18\x20MultiScopeD\
    epsResponse\n\n\x0c\n\x04\x04\xb2\x01\x01\x12\x04\xd4-\x08\x1e\n+\n\x05\
    \x04\xb2\x01\x02\0\x12\x04\xd6-\x02(\x1a\x1c\x20The\x20status\x20of\x20t\
    he\x20request.\n\n\x0e\n\x06\x04\xb2\x01\x02\0\x06\x12\x04\xd6-\x02\x1c\
    \n\x0e\n\x06\x04\xb2\x01\x02\0\x01\x12\x04\xd6-\x1d#\n\x0e\n\x06\x04\xb2\
    \x01\x02\0\x03\x12\x04\xd6-&'\nM\n\x05\x04\xb2\x01\x02\x01\x12\x04\xd8-\
    \x02$\x1a>\x20scopes\x20is\x20a\x20list\x20of\x20low-level\x20scopes\x20\
    and\x20their\x20dependencies.\n\n\x0e\n\x06\x04\xb2\x01\x02\x01\x04\x12\
    \x04\xd8-\x02\n\n\x0e\n\x06\x04\xb2\x01\x02\x01\x06\x12\x04\xd8-\x0b\x14\
    \n\x0e\n\x06\x04\xb2\x01\x02\x01\x01\x12\x04\xd8-\x15\x1f\n\x0e\n\x06\
    \x04\xb2\x01\x02\x01\x03\x12\x04\xd8-\"#\n\xc3\x01\n\x05\x04\xb2\x01\x02\
    \x02\x12\x04\xdc-\x02*\x1a\xb3\x01\x20endpoint_scopes\x20is\x20a\x20list\
    of\x20all\x20the\x20publicly\x20available\x20endponts\x20which\x20can\
    \x20be\n\x20used\x20as\x20scopes\x20as\x20well.\x20A\x20call\x20to\x20ea\
    ch\x20of\x20those\x20endpoint\x20depends\x20on\x20a\x20subset\n\x20of\
    \x20the\x20above\x20\"scopes\"\n\n\x0e\n\x06\x04\xb2\x01\x02\x02\x04\x12\
    \x04\xdc-\x02\n\n\x0e\n\x06\x04\xb2\x01\x02\x02\x06\x12\x04\xdc-\x0b\x17\
    \n\x0e\n\x06\x04\xb2\x01\x02\x02\x01\x12\x04\xdc-\x18%\n\x0e\n\x06\x04\
    \xb2\x01\x02\x02\x03\x12\x04\xdc-()\n#\n\x03\x04\xb3\x01\x12\x06\xe0-\0\
    \xea-\x01\x1a\x14\x20MultiScopeResponse\n\n\x0c\n\x04\x04\xb3\x01\x01\
    \x12\x04\xe0-\x08\x1a\n+\n\x05\x04\xb3\x01\x02\0\x12\x04\xe2-\x02(\x1a\
    \x1c\x20The\x20status\x20of\x20the\x20request.\n\n\x0e\n\x06\x04\xb3\x01\
    \x02\0\x06\x12\x04\xe2-\x02\x1c\n\x0e\n\x06\x04\xb3\x01\x02\0\x01\x12\
    \x04\xe2-\x1d#\n\x0e\n\x06\x04\xb3\x01\x02\0\x03\x12\x04\xe2-&'\n@\n\x05\
    \x04\xb3\x01\x02\x01\x12\x04\xe4-\x02\x1d\x1a1\x20This\x20is\x20a\x20lis\
    t\x20of\x20the\x20scopes\x20that\x20your\x20key\x20has.\n\n\x0e\n\x06\
    \x04\xb3\x01\x02\x01\x04\x12\x04\xe4-\x02\n\n\x0e\n\x06\x04\xb3\x01\x02\
    \x01\x05\x12\x04\xe4-\x0b\x11\n\x0e\n\x06\x04\xb3\x01\x02\x01\x01\x12\
    \x04\xe4-\x12\x18\n\x0e\n\x06\x04\xb3\x01\x02\x01\x03\x12\x04\xe4-\x1b\
    \x1c\n4\n\x05\x04\xb3\x01\x02\x02\x12\x04\xe6-\x02\x0e\x1a%\x20The\x20ap\
    p\x20that\x20the\x20key\x20has\x20access\x20to.\n\n\x0e\n\x06\x04\xb3\
    \x01\x02\x02\x06\x12\x04\xe6-\x02\x05\n\x0e\n\x06\x04\xb3\x01\x02\x02\
    \x01\x12\x04\xe6-\x06\t\n\x0e\n\x06\x04\xb3\x01\x02\x02\x03\x12\x04\xe6-\
    \x0c\r\nJ\n\x05\x04\xb3\x01\x02\x03\x12\x04\xe8-\x02\x20\x1a;\x20This\
    \x20is\x20a\x20list\x20of\x20endpoint\x20permissions\x20that\x20your\x20\
    key\x20has.\n\n\x0e\n\x06\x04\xb3\x01\x02\x03\x04\x12\x04\xe8-\x02\n\n\
    \x0e\n\x06\x04\xb3\x01\x02\x03\x05\x12\x04\xe8-\x0b\x11\n\x0e\n\x06\x04\
    \xb3\x01\x02\x03\x01\x12\x04\xe8-\x12\x1b\n\x0e\n\x06\x04\xb3\x01\x02\
    \x03\x03\x12\x04\xe8-\x1e\x1f\n\r\n\x05\x04\xb3\x01\x02\x04\x12\x04\xe9-\
    \x02\x20\n\x0e\n\x06\x04\xb3\x01\x02\x04\x05\x12\x04\xe9-\x02\x08\n\x0e\
    \n\x06\x04\xb3\x01\x02\x04\x01\x12\x04\xe9-\t\x1b\n\x0e\n\x06\x04\xb3\
    \x01\x02\x04\x03\x12\x04\xe9-\x1e\x1f\n'\n\x03\x04\xb4\x01\x12\x06\xed-\
    \0\xf5-\x01\x1a\x18\x20MultiScopeUserResponse\n\n\x0c\n\x04\x04\xb4\x01\
    \x01\x12\x04\xed-\x08\x1e\n+\n\x05\x04\xb4\x01\x02\0\x12\x04\xef-\x02(\
    \x1a\x1c\x20The\x20status\x20of\x20the\x20request.\n\n\x0e\n\x06\x04\xb4\
    \x01\x02\0\x06\x12\x04\xef-\x02\x1c\n\x0e\n\x06\x04\xb4\x01\x02\0\x01\
    \x12\x04\xef-\x1d#\n\x0e\n\x06\x04\xb4\x01\x02\0\x03\x12\x04\xef-&'\n@\n\
    \x05\x04\xb4\x01\x02\x01\x12\x04\xf1-\x02\x1d\x1a1\x20This\x20is\x20a\
    \x20list\x20of\x20the\x20scopes\x20that\x20your\x20key\x20has.\n\n\x0e\n\
    \x06\x04\xb4\x01\x02\x01\x04\x12\x04\xf1-\x02\n\n\x0e\n\x06\x04\xb4\x01\
    \x02\x01\x05\x12\x04\xf1-\x0b\x11\n\x0e\n\x06\x04\xb4\x01\x02\x01\x01\
    \x12\x04\xf1-\x12\x18\n\x0e\n\x06\x04\xb4\x01\x02\x01\x03\x12\x04\xf1-\
    \x1b\x1c\nJ\n\x05\x04\xb4\x01\x02\x02\x12\x04\xf3-\x02\x20\x1a;\x20This\
    \x20is\x20a\x20list\x20of\x20endpoint\x20permissions\x20that\x20your\x20\
    key\x20has.\n\n\x0e\n\x06\x04\xb4\x01\x02\x02\x04\x12\x04\xf3-\x02\n\n\
    \x0e\n\x06\x04\xb4\x01\x02\x02\x05\x12\x04\xf3-\x0b\x11\n\x0e\n\x06\x04\
    \xb4\x01\x02\x02\x01\x12\x04\xf3-\x12\x1b\n\x0e\n\x06\x04\xb4\x01\x02\
    \x02\x03\x12\x04\xf3-\x1e\x1f\n\r\n\x05\x04\xb4\x01\x02\x03\x12\x04\xf4-\
    \x02\x20\n\x0e\n\x06\x04\xb4\x01\x02\x03\x05\x12\x04\xf4-\x02\x08\n\x0e\
    \n\x06\x04\xb4\x01\x02\x03\x01\x12\x04\xf4-\t\x1b\n\x0e\n\x06\x04\xb4\
    \x01\x02\x03\x03\x12\x04\xf4-\x1e\x1f\n'\n\x03\x04\xb5\x01\x12\x06\xf8-\
    \0\x80.\x01\x1a\x18\x20MultiScopeRootResponse\n\n\x0c\n\x04\x04\xb5\x01\
    \x01\x12\x04\xf8-\x08\x1e\n+\n\x05\x04\xb5\x01\x02\0\x12\x04\xfa-\x02(\
    \x1a\x1c\x20The\x20status\x20of\x20the\x20request.\n\n\x0e\n\x06\x04\xb5\
    \x01\x02\0\x06\x12\x04\xfa-\x02\x1c\n\x0e\n\x06\x04\xb5\x01\x02\0\x01\
    \x12\x04\xfa-\x1d#\n\x0e\n\x06\x04\xb5\x01\x02\0\x03\x12\x04\xfa-&'\n@\n\
    \x05\x04\xb5\x01\x02\x01\x12\x04\xfc-\x02\x1d\x1a1\x20This\x20is\x20a\
    \x20list\x20of\x20the\x20scopes\x20that\x20your\x20key\x20has.\n\n\x0e\n\
    \x06\x04\xb5\x01\x02\x01\x04\x12\x04\xfc-\x02\n\n\x0e\n\x06\x04\xb5\x01\
    \x02\x01\x05\x12\x04\xfc-\x0b\x11\n\x0e\n\x06\x04\xb5\x01\x02\x01\x01\
    \x12\x04\xfc-\x12\x18\n\x0e\n\x06\x04\xb5\x01\x02\x01\x03\x12\x04\xfc-\
    \x1b\x1c\nJ\n\x05\x04\xb5\x01\x02\x02\x12\x04\xfe-\x02\x20\x1a;\x20This\
    \x20is\x20a\x20list\x20of\x20endpoint\x20permissions\x20that\x20your\x20\
    key\x20has.\n\n\x0e\n\x06\x04\xb5\x01\x02\x02\x04\x12\x04\xfe-\x02\n\n\
    \x0e\n\x06\x04\xb5\x01\x02\x02\x05\x12\x04\xfe-\x0b\x11\n\x0e\n\x06\x04\
    \xb5\x01\x02\x02\x01\x12\x04\xfe-\x12\x1b\n\x0e\n\x06\x04\xb5\x01\x02\
    \x02\x03\x12\x04\xfe-\x1e\x1f\n\r\n\x05\x04\xb5\x01\x02\x03\x12\x04\xff-\
    \x02\x20\n\x0e\n\x06\x04\xb5\x01\x02\x03\x05\x12\x04\xff-\x02\x08\n\x0e\
    \n\x06\x04\xb5\x01\x02\x03\x01\x12\x04\xff-\t\x1b\n\x0e\n\x06\x04\xb5\
    \x01\x02\x03\x03\x12\x04\xff-\x1e\x1f\n!\n\x03\x04\xb6\x01\x12\x06\x83.\
    \0\x86.\x01\x1a\x12\x20GetSearchRequest\n\n\x0c\n\x04\x04\xb6\x01\x01\
    \x12\x04\x83.\x08\x18\n\r\n\x05\x04\xb6\x01\x02\0\x12\x04\x84.\x02,\n\
    \x0e\n\x06\x04\xb6\x01\x02\0\x06\x12\x04\x84.\x02\x1b\n\x0e\n\x06\x04\
    \xb6\x01\x02\0\x01\x12\x04\x84.\x1c'\n\x0e\n\x06\x04\xb6\x01\x02\0\x03\
    \x12\x04\x84.*+\n\r\n\x05\x04\xb6\x01\x02\x01\x12\x04\x85.\x02\x10\n\x0e\
    \n\x06\x04\xb6\x01\x02\x01\x05\x12\x04\x85.\x02\x08\n\x0e\n\x06\x04\xb6\
    \x01\x02\x01\x01\x12\x04\x85.\t\x0b\n\x0e\n\x06\x04\xb6\x01\x02\x01\x03\
    \x12\x04\x85.\x0e\x0f\n$\n\x03\x04\xb7\x01\x12\x06\x89.\0\x91.\x01\x1a\
    \x15\x20ListSearchesRequest\n\n\x0c\n\x04\x04\xb7\x01\x01\x12\x04\x89.\
    \x08\x1b\n\r\n\x05\x04\xb7\x01\x02\0\x12\x04\x8a.\x02,\n\x0e\n\x06\x04\
    \xb7\x01\x02\0\x06\x12\x04\x8a.\x02\x1b\n\x0e\n\x06\x04\xb7\x01\x02\0\
    \x01\x12\x04\x8a.\x1c'\n\x0e\n\x06\x04\xb7\x01\x02\0\x03\x12\x04\x8a.*+\
    \n\x7f\n\x05\x04\xb7\x01\x02\x01\x12\x04\x8d.\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xb7\x01\x02\x01\x05\x12\x04\x8d.\x02\x08\
    \n\x0e\n\x06\x04\xb7\x01\x02\x01\x01\x12\x04\x8d.\t\r\n\x0e\n\x06\x04\
    \xb7\x01\x02\x01\x03\x12\x04\x8d.\x10\x11\nv\n\x05\x04\xb7\x01\x02\x02\
    \x12\x04\x90.\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xb7\x01\x02\x02\
    \x05\x12\x04\x90.\x02\x08\n\x0e\n\x06\x04\xb7\x01\x02\x02\x01\x12\x04\
    \x90.\t\x11\n\x0e\n\x06\x04\xb7\x01\x02\x02\x03\x12\x04\x90.\x14\x15\n$\
    \n\x03\x04\xb8\x01\x12\x06\x94.\0\xa2.\x01\x1a\x15\x20PostSearchesReques\
    t\n\n\x0c\n\x04\x04\xb8\x01\x01\x12\x04\x94.\x08\x1b\n6\n\x05\x04\xb8\
    \x01\x02\0\x12\x04\x96.\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20\
    to\x20query\x20from.\n\n\x0e\n\x06\x04\xb8\x01\x02\0\x06\x12\x04\x96.\
    \x02\x1b\n\x0e\n\x06\x04\xb8\x01\x02\0\x01\x12\x04\x96.\x1c'\n\x0e\n\x06\
    \x04\xb8\x01\x02\0\x03\x12\x04\x96.*+\nk\n\x05\x04\xb8\x01\x02\x01\x12\
    \x04\x9a.\x02$\x1a\\\x20The\x20query;\x20this\x20specifies\x20how\x20the\
    \x20data\x20to\x20be\x20searched\n\x20this\x20will\x20be\x20replaced\x20\
    by\x20\"Searches\"\n\n\x0e\n\x06\x04\xb8\x01\x02\x01\x06\x12\x04\x9a.\
    \x02\x07\n\x0e\n\x06\x04\xb8\x01\x02\x01\x01\x12\x04\x9a.\x08\r\n\x0e\n\
    \x06\x04\xb8\x01\x02\x01\x03\x12\x04\x9a.\x10\x11\n\x0e\n\x06\x04\xb8\
    \x01\x02\x01\x08\x12\x04\x9a.\x12#\n\x0f\n\x07\x04\xb8\x01\x02\x01\x08\
    \x03\x12\x04\x9a.\x13\"\n\x85\x01\n\x05\x04\xb8\x01\x02\x02\x12\x04\x9e.\
    \x02\x1f\x1av\x20The\x20searched\x20to\x20be\x20executed\x20or\x20saved\
    \n\x20Eventually\x20the\x20request\x20level\x20fields\x20will\x20be\x20d\
    eprecated\x20in\x20favor\x20of\x20this\x20object\n\n\x0e\n\x06\x04\xb8\
    \x01\x02\x02\x04\x12\x04\x9e.\x02\n\n\x0e\n\x06\x04\xb8\x01\x02\x02\x06\
    \x12\x04\x9e.\x0b\x11\n\x0e\n\x06\x04\xb8\x01\x02\x02\x01\x12\x04\x9e.\
    \x12\x1a\n\x0e\n\x06\x04\xb8\x01\x02\x02\x03\x12\x04\x9e.\x1d\x1e\nO\n\
    \x05\x04\xb8\x01\x02\x03\x12\x04\xa1.\x02\x1c\x1a@\x20Pagination\x20info\
    rmation\x20to\x20paginate\x20through\x20search\x20result\x20Hits.\n\n\
    \x0e\n\x06\x04\xb8\x01\x02\x03\x06\x12\x04\xa1.\x02\x0c\n\x0e\n\x06\x04\
    \xb8\x01\x02\x03\x01\x12\x04\xa1.\r\x17\n\x0e\n\x06\x04\xb8\x01\x02\x03\
    \x03\x12\x04\xa1.\x1a\x1b\n\r\n\x03\x04\xb9\x01\x12\x06\xa4.\0\xae.\x01\
    \n\x0c\n\x04\x04\xb9\x01\x01\x12\x04\xa4.\x08\"\n6\n\x05\x04\xb9\x01\x02\
    \0\x12\x04\xa6.\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20qu\
    ery\x20from.\n\n\x0e\n\x06\x04\xb9\x01\x02\0\x06\x12\x04\xa6.\x02\x1b\n\
    \x0e\n\x06\x04\xb9\x01\x02\0\x01\x12\x04\xa6.\x1c'\n\x0e\n\x06\x04\xb9\
    \x01\x02\0\x03\x12\x04\xa6.*+\n+\n\x05\x04\xb9\x01\x02\x01\x12\x04\xa9.\
    \x02\x1f\x1a\x1c\x20The\x20searches\x20to\x20be\x20patched\n\n\x0e\n\x06\
    \x04\xb9\x01\x02\x01\x04\x12\x04\xa9.\x02\n\n\x0e\n\x06\x04\xb9\x01\x02\
    \x01\x06\x12\x04\xa9.\x0b\x11\n\x0e\n\x06\x04\xb9\x01\x02\x01\x01\x12\
    \x04\xa9.\x12\x1a\n\x0e\n\x06\x04\xb9\x01\x02\x01\x03\x12\x04\xa9.\x1d\
    \x1e\nr\n\x05\x04\xb9\x01\x02\x02\x12\x04\xad.\x02\x14\x1ac\x20The\x20ac\
    tion\x20to\x20perform\x20on\x20the\x20patched\x20Search\x20objects\n\x20\
    For\x20now\x20only\x20action\x20'overwrite'\x20is\x20supported\n\n\x0e\n\
    \x06\x04\xb9\x01\x02\x02\x05\x12\x04\xad.\x02\x08\n\x0e\n\x06\x04\xb9\
    \x01\x02\x02\x01\x12\x04\xad.\t\x0f\n\x0e\n\x06\x04\xb9\x01\x02\x02\x03\
    \x12\x04\xad.\x12\x13\n\r\n\x03\x04\xba\x01\x12\x06\xb0.\0\xba.\x01\n\
    \x0c\n\x04\x04\xba\x01\x01\x12\x04\xb0.\x08'\n6\n\x05\x04\xba\x01\x02\0\
    \x12\x04\xb2.\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20quer\
    y\x20from.\n\n\x0e\n\x06\x04\xba\x01\x02\0\x06\x12\x04\xb2.\x02\x1b\n\
    \x0e\n\x06\x04\xba\x01\x02\0\x01\x12\x04\xb2.\x1c'\n\x0e\n\x06\x04\xba\
    \x01\x02\0\x03\x12\x04\xb2.*+\n+\n\x05\x04\xba\x01\x02\x01\x12\x04\xb5.\
    \x02\x1f\x1a\x1c\x20The\x20searches\x20to\x20be\x20patched\n\n\x0e\n\x06\
    \x04\xba\x01\x02\x01\x04\x12\x04\xb5.\x02\n\n\x0e\n\x06\x04\xba\x01\x02\
    \x01\x06\x12\x04\xb5.\x0b\x11\n\x0e\n\x06\x04\xba\x01\x02\x01\x01\x12\
    \x04\xb5.\x12\x1a\n\x0e\n\x06\x04\xba\x01\x02\x01\x03\x12\x04\xb5.\x1d\
    \x1e\nr\n\x05\x04\xba\x01\x02\x02\x12\x04\xb9.\x02\x14\x1ac\x20The\x20ac\
    tion\x20to\x20perform\x20on\x20the\x20patched\x20Search\x20objects\n\x20\
    For\x20now\x20only\x20action\x20'overwrite'\x20is\x20supported\n\n\x0e\n\
    \x06\x04\xba\x01\x02\x02\x05\x12\x04\xb9.\x02\x08\n\x0e\n\x06\x04\xba\
    \x01\x02\x02\x01\x12\x04\xb9.\t\x0f\n\x0e\n\x06\x04\xba\x01\x02\x02\x03\
    \x12\x04\xb9.\x12\x13\n%\n\x03\x04\xbb\x01\x12\x06\xbd.\0\xc7.\x01\x1a\
    \x16\x20PatchSearchesRequest\n\n\x0c\n\x04\x04\xbb\x01\x01\x12\x04\xbd.\
    \x08\x1c\n6\n\x05\x04\xbb\x01\x02\0\x12\x04\xbf.\x02,\x1a'\x20The\x20use\
    r_id\x20and\x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\xbb\x01\
    \x02\0\x06\x12\x04\xbf.\x02\x1b\n\x0e\n\x06\x04\xbb\x01\x02\0\x01\x12\
    \x04\xbf.\x1c'\n\x0e\n\x06\x04\xbb\x01\x02\0\x03\x12\x04\xbf.*+\n+\n\x05\
    \x04\xbb\x01\x02\x01\x12\x04\xc2.\x02\x1f\x1a\x1c\x20The\x20searches\x20\
    to\x20be\x20patched\n\n\x0e\n\x06\x04\xbb\x01\x02\x01\x04\x12\x04\xc2.\
    \x02\n\n\x0e\n\x06\x04\xbb\x01\x02\x01\x06\x12\x04\xc2.\x0b\x11\n\x0e\n\
    \x06\x04\xbb\x01\x02\x01\x01\x12\x04\xc2.\x12\x1a\n\x0e\n\x06\x04\xbb\
    \x01\x02\x01\x03\x12\x04\xc2.\x1d\x1e\nr\n\x05\x04\xbb\x01\x02\x02\x12\
    \x04\xc6.\x02\x14\x1ac\x20The\x20action\x20to\x20perform\x20on\x20the\
    \x20patched\x20Search\x20objects\n\x20For\x20now\x20only\x20action\x20'o\
    verwrite'\x20is\x20supported\n\n\x0e\n\x06\x04\xbb\x01\x02\x02\x05\x12\
    \x04\xc6.\x02\x08\n\x0e\n\x06\x04\xbb\x01\x02\x02\x01\x12\x04\xc6.\t\x0f\
    \n\x0e\n\x06\x04\xbb\x01\x02\x02\x03\x12\x04\xc6.\x12\x13\n`\n\x03\x04\
    \xbc\x01\x12\x06\xca.\0\xd2.\x01\x1aQ\x20PostSearchesByIDRequest\x20perf\
    orms\x20returns\x20results\x20of\x20a\x20saved\x20search\x20given\x20its\
    \x20ID\n\n\x0c\n\x04\x04\xbc\x01\x01\x12\x04\xca.\x08\x1f\n\r\n\x05\x04\
    \xbc\x01\x02\0\x12\x04\xcb.\x02,\n\x0e\n\x06\x04\xbc\x01\x02\0\x06\x12\
    \x04\xcb.\x02\x1b\n\x0e\n\x06\x04\xbc\x01\x02\0\x01\x12\x04\xcb.\x1c'\n\
    \x0e\n\x06\x04\xbc\x01\x02\0\x03\x12\x04\xcb.*+\n3\n\x05\x04\xbc\x01\x02\
    \x01\x12\x04\xce.\x02\x10\x1a$\x20ID\x20for\x20saves\x20search\x20to\x20\
    be\x20executed\n\n\x0e\n\x06\x04\xbc\x01\x02\x01\x05\x12\x04\xce.\x02\
    \x08\n\x0e\n\x06\x04\xbc\x01\x02\x01\x01\x12\x04\xce.\t\x0b\n\x0e\n\x06\
    \x04\xbc\x01\x02\x01\x03\x12\x04\xce.\x0e\x0f\nO\n\x05\x04\xbc\x01\x02\
    \x02\x12\x04\xd1.\x02\x1c\x1a@\x20Pagination\x20information\x20to\x20pag\
    inate\x20through\x20search\x20result\x20Hits.\n\n\x0e\n\x06\x04\xbc\x01\
    \x02\x02\x06\x12\x04\xd1.\x02\x0c\n\x0e\n\x06\x04\xbc\x01\x02\x02\x01\
    \x12\x04\xd1.\r\x17\n\x0e\n\x06\x04\xbc\x01\x02\x02\x03\x12\x04\xd1.\x1a\
    \x1b\n$\n\x03\x04\xbd\x01\x12\x06\xd5.\0\xd8.\x01\x1a\x15\x20DeleteSearc\
    hRequest\n\n\x0c\n\x04\x04\xbd\x01\x01\x12\x04\xd5.\x08\x1b\n\r\n\x05\
    \x04\xbd\x01\x02\0\x12\x04\xd6.\x02,\n\x0e\n\x06\x04\xbd\x01\x02\0\x06\
    \x12\x04\xd6.\x02\x1b\n\x0e\n\x06\x04\xbd\x01\x02\0\x01\x12\x04\xd6.\x1c\
    '\n\x0e\n\x06\x04\xbd\x01\x02\0\x03\x12\x04\xd6.*+\n\r\n\x05\x04\xbd\x01\
    \x02\x01\x12\x04\xd7.\x02\x10\n\x0e\n\x06\x04\xbd\x01\x02\x01\x05\x12\
    \x04\xd7.\x02\x08\n\x0e\n\x06\x04\xbd\x01\x02\x01\x01\x12\x04\xd7.\t\x0b\
    \n\x0e\n\x06\x04\xbd\x01\x02\x01\x03\x12\x04\xd7.\x0e\x0f\n\x87\x01\n\
    \x03\x04\xbe\x01\x12\x06\xde.\0\xe7.\x01\x1ax\x20Execute\x20a\x20new\x20\
    annotation\x20search\x20and\x20optionally\x20save\x20it\n\x20annotation\
    \x20search\x20over\x20annotations\x20using\x20rank\x20and\x20filter\x20p\
    roto\n\n\x0c\n\x04\x04\xbe\x01\x01\x12\x04\xde.\x08&\n6\n\x05\x04\xbe\
    \x01\x02\0\x12\x04\xe0.\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20\
    to\x20query\x20from.\n\n\x0e\n\x06\x04\xbe\x01\x02\0\x06\x12\x04\xe0.\
    \x02\x1b\n\x0e\n\x06\x04\xbe\x01\x02\0\x01\x12\x04\xe0.\x1c'\n\x0e\n\x06\
    \x04\xbe\x01\x02\0\x03\x12\x04\xe0.*+\n5\n\x05\x04\xbe\x01\x02\x01\x12\
    \x04\xe3.\x02\x1f\x1a&\x20The\x20searched\x20to\x20be\x20executed\x20or\
    \x20saved\n\n\x0e\n\x06\x04\xbe\x01\x02\x01\x04\x12\x04\xe3.\x02\n\n\x0e\
    \n\x06\x04\xbe\x01\x02\x01\x06\x12\x04\xe3.\x0b\x11\n\x0e\n\x06\x04\xbe\
    \x01\x02\x01\x01\x12\x04\xe3.\x12\x1a\n\x0e\n\x06\x04\xbe\x01\x02\x01\
    \x03\x12\x04\xe3.\x1d\x1e\nO\n\x05\x04\xbe\x01\x02\x02\x12\x04\xe6.\x02\
    \x1c\x1a@\x20Pagination\x20information\x20to\x20paginate\x20through\x20s\
    earch\x20result\x20Hits.\n\n\x0e\n\x06\x04\xbe\x01\x02\x02\x06\x12\x04\
    \xe6.\x02\x0c\n\x0e\n\x06\x04\xbe\x01\x02\x02\x01\x12\x04\xe6.\r\x17\n\
    \x0e\n\x06\x04\xbe\x01\x02\x02\x03\x12\x04\xe6.\x1a\x1b\n5\n\x03\x04\xbf\
    \x01\x12\x06\xea.\0\xed.\x01\x1a&\x20DeleteAnnotationSearchMetricsReques\
    t\n\n\x0c\n\x04\x04\xbf\x01\x01\x12\x04\xea.\x08,\n\r\n\x05\x04\xbf\x01\
    \x02\0\x12\x04\xeb.\x02,\n\x0e\n\x06\x04\xbf\x01\x02\0\x06\x12\x04\xeb.\
    \x02\x1b\n\x0e\n\x06\x04\xbf\x01\x02\0\x01\x12\x04\xeb.\x1c'\n\x0e\n\x06\
    \x04\xbf\x01\x02\0\x03\x12\x04\xeb.*+\n\r\n\x05\x04\xbf\x01\x02\x01\x12\
    \x04\xec.\x02\x10\n\x0e\n\x06\x04\xbf\x01\x02\x01\x05\x12\x04\xec.\x02\
    \x08\n\x0e\n\x06\x04\xbf\x01\x02\x01\x01\x12\x04\xec.\t\x0b\n\x0e\n\x06\
    \x04\xbf\x01\x02\x01\x03\x12\x04\xec.\x0e\x0f\nB\n\x03\x04\xc0\x01\x12\
    \x06\xf0.\0\xfd.\x01\x1a3\x20Execute\x20a\x20new\x20input\x20search\x20a\
    nd\x20optionally\x20save\x20it\n\n\x0c\n\x04\x04\xc0\x01\x01\x12\x04\xf0\
    .\x08!\n6\n\x05\x04\xc0\x01\x02\0\x12\x04\xf2.\x02,\x1a'\x20The\x20user_\
    id\x20and\x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\xc0\x01\
    \x02\0\x06\x12\x04\xf2.\x02\x1b\n\x0e\n\x06\x04\xc0\x01\x02\0\x01\x12\
    \x04\xf2.\x1c'\n\x0e\n\x06\x04\xc0\x01\x02\0\x03\x12\x04\xf2.*+\n5\n\x05\
    \x04\xc0\x01\x02\x01\x12\x04\xf5.\x02\x1f\x1a&\x20The\x20searched\x20to\
    \x20be\x20executed\x20or\x20saved\n\n\x0e\n\x06\x04\xc0\x01\x02\x01\x04\
    \x12\x04\xf5.\x02\n\n\x0e\n\x06\x04\xc0\x01\x02\x01\x06\x12\x04\xf5.\x0b\
    \x11\n\x0e\n\x06\x04\xc0\x01\x02\x01\x01\x12\x04\xf5.\x12\x1a\n\x0e\n\
    \x06\x04\xc0\x01\x02\x01\x03\x12\x04\xf5.\x1d\x1e\nO\n\x05\x04\xc0\x01\
    \x02\x02\x12\x04\xf8.\x02\x1c\x1a@\x20Pagination\x20information\x20to\
    \x20paginate\x20through\x20search\x20result\x20Hits.\n\n\x0e\n\x06\x04\
    \xc0\x01\x02\x02\x06\x12\x04\xf8.\x02\x0c\n\x0e\n\x06\x04\xc0\x01\x02\
    \x02\x01\x12\x04\xf8.\r\x17\n\x0e\n\x06\x04\xc0\x01\x02\x02\x03\x12\x04\
    \xf8.\x1a\x1b\nh\n\x05\x04\xc0\x01\x02\x03\x12\x04\xfc.\x02\x16\x1aY\x20\
    If\x20only_count\x20is\x20set,\x20then\x20the\x20response\x20will\x20not\
    \x20contain\x20hits,\n\x20but\x20hit_counts\x20instead.\n\n\x0e\n\x06\
    \x04\xc0\x01\x02\x03\x05\x12\x04\xfc.\x02\x06\n\x0e\n\x06\x04\xc0\x01\
    \x02\x03\x01\x12\x04\xfc.\x07\x11\n\x0e\n\x06\x04\xc0\x01\x02\x03\x03\
    \x12\x04\xfc.\x14\x15\nZ\n\x03\x04\xc1\x01\x12\x06\x80/\0\x84/\x01\x1aK\
    \x20SingleSearchResponse\x20returns\x20saved\x20search\x20in\x20response\
    \x20to\x20GetSearchRequest\n\n\x0c\n\x04\x04\xc1\x01\x01\x12\x04\x80/\
    \x08\x1c\n=\n\x05\x04\xc1\x01\x02\0\x12\x04\x82/\x02(\x1a.\x20Status\x20\
    of\x20whether\x20the\x20search\x20was\x20successful.\n\n\x0e\n\x06\x04\
    \xc1\x01\x02\0\x06\x12\x04\x82/\x02\x1c\n\x0e\n\x06\x04\xc1\x01\x02\0\
    \x01\x12\x04\x82/\x1d#\n\x0e\n\x06\x04\xc1\x01\x02\0\x03\x12\x04\x82/&'\
    \n\r\n\x05\x04\xc1\x01\x02\x01\x12\x04\x83/\x02\x14\n\x0e\n\x06\x04\xc1\
    \x01\x02\x01\x06\x12\x04\x83/\x02\x08\n\x0e\n\x06\x04\xc1\x01\x02\x01\
    \x01\x12\x04\x83/\t\x0f\n\x0e\n\x06\x04\xc1\x01\x02\x01\x03\x12\x04\x83/\
    \x12\x13\n$\n\x03\x04\xc2\x01\x12\x06\x87/\0\x9a/\x01\x1a\x15\x20MultiSe\
    archResponse\n\n\x0c\n\x04\x04\xc2\x01\x01\x12\x04\x87/\x08\x1b\n=\n\x05\
    \x04\xc2\x01\x02\0\x12\x04\x89/\x02(\x1a.\x20Status\x20of\x20whether\x20\
    the\x20search\x20was\x20successful.\n\n\x0e\n\x06\x04\xc2\x01\x02\0\x06\
    \x12\x04\x89/\x02\x1c\n\x0e\n\x06\x04\xc2\x01\x02\0\x01\x12\x04\x89/\x1d\
    #\n\x0e\n\x06\x04\xc2\x01\x02\0\x03\x12\x04\x89/&'\n?\n\x05\x04\xc2\x01\
    \x02\x01\x12\x04\x8c/\x02\x10\x1a0\x20A\x20unique\x20id\x20which\x20uniq\
    uely\x20identifies\x20a\x20search\n\n\x0e\n\x06\x04\xc2\x01\x02\x01\x05\
    \x12\x04\x8c/\x02\x08\n\x0e\n\x06\x04\xc2\x01\x02\x01\x01\x12\x04\x8c/\t\
    \x0b\n\x0e\n\x06\x04\xc2\x01\x02\x01\x03\x12\x04\x8c/\x0e\x0f\n0\n\x05\
    \x04\xc2\x01\x02\x02\x12\x04\x8f/\x02G\x1a!\x20The\x20list\x20of\x20sear\
    ch\x20result\x20Hits.\n\n\x0e\n\x06\x04\xc2\x01\x02\x02\x04\x12\x04\x8f/\
    \x02\n\n\x0e\n\x06\x04\xc2\x01\x02\x02\x06\x12\x04\x8f/\x0b\x0e\n\x0e\n\
    \x06\x04\xc2\x01\x02\x02\x01\x12\x04\x8f/\x0f\x13\n\x0e\n\x06\x04\xc2\
    \x01\x02\x02\x03\x12\x04\x8f/\x16\x17\n\x0e\n\x06\x04\xc2\x01\x02\x02\
    \x08\x12\x04\x8f/\x18F\n\x11\n\t\x04\xc2\x01\x02\x02\x08\xd0\x86\x03\x12\
    \x04\x8f/\x19E\n<\n\x05\x04\xc2\x01\x02\x03\x12\x04\x92/\x02\x12\x1a-\
    \x20The\x20original\x20query\x20provided\x20in\x20the\x20request.\n\n\
    \x0e\n\x06\x04\xc2\x01\x02\x03\x06\x12\x04\x92/\x02\x07\n\x0e\n\x06\x04\
    \xc2\x01\x02\x03\x01\x12\x04\x92/\x08\r\n\x0e\n\x06\x04\xc2\x01\x02\x03\
    \x03\x12\x04\x92/\x10\x11\n?\n\x05\x04\xc2\x01\x02\x04\x12\x04\x95/\x02\
    \x1f\x1a0\x20The\x20original\x20Searches\x20provided\x20in\x20the\x20req\
    uest.\n\n\x0e\n\x06\x04\xc2\x01\x02\x04\x04\x12\x04\x95/\x02\n\n\x0e\n\
    \x06\x04\xc2\x01\x02\x04\x06\x12\x04\x95/\x0b\x11\n\x0e\n\x06\x04\xc2\
    \x01\x02\x04\x01\x12\x04\x95/\x12\x1a\n\x0e\n\x06\x04\xc2\x01\x02\x04\
    \x03\x12\x04\x95/\x1d\x1e\n\x81\x01\n\x05\x04\xc2\x01\x02\x05\x12\x04\
    \x99/\x02#\x1ar\x20The\x20counts\x20of\x20hits\x20for\x20each\x20search,\
    \x20in\x20the\x20same\x20order\x20as\x20searches.\n\x20Only\x20returned\
    \x20if\x20the\x20request\x20set\x20only_count.\n\n\x0e\n\x06\x04\xc2\x01\
    \x02\x05\x04\x12\x04\x99/\x02\n\n\x0e\n\x06\x04\xc2\x01\x02\x05\x06\x12\
    \x04\x99/\x0b\x13\n\x0e\n\x06\x04\xc2\x01\x02\x05\x01\x12\x04\x99/\x14\
    \x1e\n\x0e\n\x06\x04\xc2\x01\x02\x05\x03\x12\x04\x99/!\"\n3\n\x03\x04\
    \xc3\x01\x12\x06\x9d/\0\xaf/\x01\x1a$\x20PostAnnotationSearchMetricsRequ\
    est\n\n\x0c\n\x04\x04\xc3\x01\x01\x12\x04\x9d/\x08*\n\r\n\x05\x04\xc3\
    \x01\x02\0\x12\x04\x9e/\x02,\n\x0e\n\x06\x04\xc3\x01\x02\0\x06\x12\x04\
    \x9e/\x02\x1b\n\x0e\n\x06\x04\xc3\x01\x02\0\x01\x12\x04\x9e/\x1c'\n\x0e\
    \n\x06\x04\xc3\x01\x02\0\x03\x12\x04\x9e/*+\nJ\n\x05\x04\xc3\x01\x02\x01\
    \x12\x04\xa1/\x02\x10\x1a;\x20A\x20unique\x20customer\x20facing\x20id\
    \x20to\x20identify\x20this\x20eval\x20request\n\n\x0e\n\x06\x04\xc3\x01\
    \x02\x01\x05\x12\x04\xa1/\x02\x08\n\x0e\n\x06\x04\xc3\x01\x02\x01\x01\
    \x12\x04\xa1/\t\x0b\n\x0e\n\x06\x04\xc3\x01\x02\x01\x03\x12\x04\xa1/\x0e\
    \x0f\n;\n\x05\x04\xc3\x01\x02\x02\x12\x04\xa4/\x02'\x1a,\x20The\x20groun\
    d\x20truth\x20we\x20are\x20evaluating\x20against\n\n\x0e\n\x06\x04\xc3\
    \x01\x02\x02\x06\x12\x04\xa4/\x02\x15\n\x0e\n\x06\x04\xc3\x01\x02\x02\
    \x01\x12\x04\xa4/\x16\"\n\x0e\n\x06\x04\xc3\x01\x02\x02\x03\x12\x04\xa4/\
    %&\n*\n\x05\x04\xc3\x01\x02\x03\x12\x04\xa7/\x02)\x1a\x1b\x20The\x20set\
    \x20we\x20are\x20evaluating\n\n\x0e\n\x06\x04\xc3\x01\x02\x03\x06\x12\
    \x04\xa7/\x02\x15\n\x0e\n\x06\x04\xc3\x01\x02\x03\x01\x12\x04\xa7/\x16$\
    \n\x0e\n\x06\x04\xc3\x01\x02\x03\x03\x12\x04\xa7/'(\ny\n\x05\x04\xc3\x01\
    \x02\x04\x12\x04\xab/\x02\x10\x1aj\x20List\x20of\x20concepts\x20to\x20ev\
    aluate\x20are\x20expected\x20to\x20be\x20in\x20data.concepts\n\x20If\x20\
    nil,\x20then\x20all\x20app\x20concepts\x20are\x20used\n\n\x0e\n\x06\x04\
    \xc3\x01\x02\x04\x06\x12\x04\xab/\x02\x06\n\x0e\n\x06\x04\xc3\x01\x02\
    \x04\x01\x12\x04\xab/\x07\x0b\n\x0e\n\x06\x04\xc3\x01\x02\x04\x03\x12\
    \x04\xab/\x0e\x0f\n.\n\x05\x04\xc3\x01\x02\x05\x12\x04\xae/\x02%\x1a\x1f\
    \x20The\x20type\x20of\x20evaluation\x20to\x20use\n\n\x0e\n\x06\x04\xc3\
    \x01\x02\x05\x06\x12\x04\xae/\x02\x10\n\x0e\n\x06\x04\xc3\x01\x02\x05\
    \x01\x12\x04\xae/\x11\x20\n\x0e\n\x06\x04\xc3\x01\x02\x05\x03\x12\x04\
    \xae/#$\n2\n\x03\x04\xc4\x01\x12\x06\xb2/\0\xb7/\x01\x1a#\x20GetAnnotati\
    onSearchMetricsRequest\n\n\x0c\n\x04\x04\xc4\x01\x01\x12\x04\xb2/\x08)\n\
    \r\n\x05\x04\xc4\x01\x02\0\x12\x04\xb3/\x02,\n\x0e\n\x06\x04\xc4\x01\x02\
    \0\x06\x12\x04\xb3/\x02\x1b\n\x0e\n\x06\x04\xc4\x01\x02\0\x01\x12\x04\
    \xb3/\x1c'\n\x0e\n\x06\x04\xc4\x01\x02\0\x03\x12\x04\xb3/*+\nH\n\x05\x04\
    \xc4\x01\x02\x01\x12\x04\xb6/\x02\x10\x1a9\x20Unique\x20custom\x20facing\
    \x20id\x20that\x20identifies\x20the\x20eval\x20to\x20get\n\n\x0e\n\x06\
    \x04\xc4\x01\x02\x01\x05\x12\x04\xb6/\x02\x08\n\x0e\n\x06\x04\xc4\x01\
    \x02\x01\x01\x12\x04\xb6/\t\x0b\n\x0e\n\x06\x04\xc4\x01\x02\x01\x03\x12\
    \x04\xb6/\x0e\x0f\n3\n\x03\x04\xc5\x01\x12\x06\xba/\0\xbc/\x01\x1a$\x20L\
    istAnnotationSearchMetricsRequest\n\n\x0c\n\x04\x04\xc5\x01\x01\x12\x04\
    \xba/\x08*\n\r\n\x05\x04\xc5\x01\x02\0\x12\x04\xbb/\x02,\n\x0e\n\x06\x04\
    \xc5\x01\x02\0\x06\x12\x04\xbb/\x02\x1b\n\x0e\n\x06\x04\xc5\x01\x02\0\
    \x01\x12\x04\xbb/\x1c'\n\x0e\n\x06\x04\xc5\x01\x02\0\x03\x12\x04\xbb/*+\
    \n5\n\x03\x04\xc6\x01\x12\x06\xbf/\0\xc3/\x01\x1a&\x20MultiAnnotationSea\
    rchMetricsResponse\n\n\x0c\n\x04\x04\xc6\x01\x01\x12\x04\xbf/\x08,\n&\n\
    \x05\x04\xc6\x01\x02\0\x12\x04\xc1/\x02(\x1a\x17\x20Status\x20of\x20the\
    \x20request\n\n\x0e\n\x06\x04\xc6\x01\x02\0\x06\x12\x04\xc1/\x02\x1c\n\
    \x0e\n\x06\x04\xc6\x01\x02\0\x01\x12\x04\xc1/\x1d#\n\x0e\n\x06\x04\xc6\
    \x01\x02\0\x03\x12\x04\xc1/&'\n\r\n\x05\x04\xc6\x01\x02\x01\x12\x04\xc2/\
    \x02A\n\x0e\n\x06\x04\xc6\x01\x02\x01\x04\x12\x04\xc2/\x02\n\n\x0e\n\x06\
    \x04\xc6\x01\x02\x01\x06\x12\x04\xc2/\x0b\"\n\x0e\n\x06\x04\xc6\x01\x02\
    \x01\x01\x12\x04\xc2/#<\n\x0e\n\x06\x04\xc6\x01\x02\x01\x03\x12\x04\xc2/\
    ?@\n-\n\x03\x04\xc7\x01\x12\x06\xc6/\0\xce/\x01\x1a\x1e\x20ListAnnotatio\
    nFiltersRequest\n\n\x0c\n\x04\x04\xc7\x01\x01\x12\x04\xc6/\x08$\n\r\n\
    \x05\x04\xc7\x01\x02\0\x12\x04\xc7/\x02,\n\x0e\n\x06\x04\xc7\x01\x02\0\
    \x06\x12\x04\xc7/\x02\x1b\n\x0e\n\x06\x04\xc7\x01\x02\0\x01\x12\x04\xc7/\
    \x1c'\n\x0e\n\x06\x04\xc7\x01\x02\0\x03\x12\x04\xc7/*+\n\x7f\n\x05\x04\
    \xc7\x01\x02\x01\x12\x04\xca/\x02\x12\x1ap\x20(optional\x20URL\x20parame\
    ter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spli\
    t\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\xc7\x01\x02\x01\x05\x12\x04\xca/\x02\x08\n\x0e\n\x06\x04\xc7\
    \x01\x02\x01\x01\x12\x04\xca/\t\r\n\x0e\n\x06\x04\xc7\x01\x02\x01\x03\
    \x12\x04\xca/\x10\x11\nv\n\x05\x04\xc7\x01\x02\x02\x12\x04\xcd/\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\xc7\x01\x02\x02\x05\x12\x04\xcd/\x02\
    \x08\n\x0e\n\x06\x04\xc7\x01\x02\x02\x01\x12\x04\xcd/\t\x11\n\x0e\n\x06\
    \x04\xc7\x01\x02\x02\x03\x12\x04\xcd/\x14\x15\n+\n\x03\x04\xc8\x01\x12\
    \x06\xd1/\0\xd6/\x01\x1a\x1c\x20GetAnnotationFilterRequest\n\n\x0c\n\x04\
    \x04\xc8\x01\x01\x12\x04\xd1/\x08\"\n\r\n\x05\x04\xc8\x01\x02\0\x12\x04\
    \xd2/\x02,\n\x0e\n\x06\x04\xc8\x01\x02\0\x06\x12\x04\xd2/\x02\x1b\n\x0e\
    \n\x06\x04\xc8\x01\x02\0\x01\x12\x04\xd2/\x1c'\n\x0e\n\x06\x04\xc8\x01\
    \x02\0\x03\x12\x04\xd2/*+\n2\n\x05\x04\xc8\x01\x02\x01\x12\x04\xd5/\x02\
    \"\x1a#\x20Identify\x20annotation\x20filter\x20by\x20id.\n\n\x0e\n\x06\
    \x04\xc8\x01\x02\x01\x05\x12\x04\xd5/\x02\x08\n\x0e\n\x06\x04\xc8\x01\
    \x02\x01\x01\x12\x04\xd5/\t\x1d\n\x0e\n\x06\x04\xc8\x01\x02\x01\x03\x12\
    \x04\xd5/\x20!\n?\n\x03\x04\xc9\x01\x12\x06\xd9/\0\xde/\x01\x1a0\x20Requ\
    est\x20to\x20add\x20one\x20or\x20more\x20annotation\x20filters.\n\n\x0c\
    \n\x04\x04\xc9\x01\x01\x12\x04\xd9/\x08$\n\r\n\x05\x04\xc9\x01\x02\0\x12\
    \x04\xda/\x02,\n\x0e\n\x06\x04\xc9\x01\x02\0\x06\x12\x04\xda/\x02\x1b\n\
    \x0e\n\x06\x04\xc9\x01\x02\0\x01\x12\x04\xda/\x1c'\n\x0e\n\x06\x04\xc9\
    \x01\x02\0\x03\x12\x04\xda/*+\nK\n\x05\x04\xc9\x01\x02\x01\x12\x04\xdd/\
    \x023\x1a<\x20List\x20of\x20annotation\x20filters\x20that\x20are\x20requ\
    ested\x20to\x20be\x20added.\n\n\x0e\n\x06\x04\xc9\x01\x02\x01\x04\x12\
    \x04\xdd/\x02\n\n\x0e\n\x06\x04\xc9\x01\x02\x01\x06\x12\x04\xdd/\x0b\x1b\
    \n\x0e\n\x06\x04\xc9\x01\x02\x01\x01\x12\x04\xdd/\x1c.\n\x0e\n\x06\x04\
    \xc9\x01\x02\x01\x03\x12\x04\xdd/12\n=\n\x03\x04\xca\x01\x12\x06\xe1/\0\
    \xea/\x01\x1a.\x20Request\x20to\x20patch\x20several\x20annotation\x20fil\
    ters.\n\n\x0c\n\x04\x04\xca\x01\x01\x12\x04\xe1/\x08%\n\r\n\x05\x04\xca\
    \x01\x02\0\x12\x04\xe2/\x02,\n\x0e\n\x06\x04\xca\x01\x02\0\x06\x12\x04\
    \xe2/\x02\x1b\n\x0e\n\x06\x04\xca\x01\x02\0\x01\x12\x04\xe2/\x1c'\n\x0e\
    \n\x06\x04\xca\x01\x02\0\x03\x12\x04\xe2/*+\nM\n\x05\x04\xca\x01\x02\x01\
    \x12\x04\xe5/\x023\x1a>\x20List\x20of\x20annotation\x20filters\x20that\
    \x20are\x20requested\x20to\x20be\x20updated.\n\n\x0e\n\x06\x04\xca\x01\
    \x02\x01\x04\x12\x04\xe5/\x02\n\n\x0e\n\x06\x04\xca\x01\x02\x01\x06\x12\
    \x04\xe5/\x0b\x1b\n\x0e\n\x06\x04\xca\x01\x02\x01\x01\x12\x04\xe5/\x1c.\
    \n\x0e\n\x06\x04\xca\x01\x02\x01\x03\x12\x04\xe5/12\nl\n\x05\x04\xca\x01\
    \x02\x02\x12\x04\xe9/\x02\x14\x1a]\x20The\x20action\x20to\x20perform\x20\
    on\x20the\x20patched\x20objects\n\x20For\x20now,\x20only\x20'overwrite'\
    \x20action\x20is\x20supported\n\n\x0e\n\x06\x04\xca\x01\x02\x02\x05\x12\
    \x04\xe9/\x02\x08\n\x0e\n\x06\x04\xca\x01\x02\x02\x01\x12\x04\xe9/\t\x0f\
    \n\x0e\n\x06\x04\xca\x01\x02\x02\x03\x12\x04\xe9/\x12\x13\nM\n\x03\x04\
    \xcb\x01\x12\x06\xed/\0\xf2/\x01\x1a>\x20Request\x20to\x20delete\x20seve\
    ral\x20annotation\x20filters\x20by\x20list\x20of\x20ids.\n\n\x0c\n\x04\
    \x04\xcb\x01\x01\x12\x04\xed/\x08&\n\r\n\x05\x04\xcb\x01\x02\0\x12\x04\
    \xee/\x02,\n\x0e\n\x06\x04\xcb\x01\x02\0\x06\x12\x04\xee/\x02\x1b\n\x0e\
    \n\x06\x04\xcb\x01\x02\0\x01\x12\x04\xee/\x1c'\n\x0e\n\x06\x04\xcb\x01\
    \x02\0\x03\x12\x04\xee/*+\n1\n\x05\x04\xcb\x01\x02\x01\x12\x04\xf1/\x02,\
    \x1a\"\x20Specify\x20which\x20filters\x20to\x20delete.\n\n\x0e\n\x06\x04\
    \xcb\x01\x02\x01\x04\x12\x04\xf1/\x02\n\n\x0e\n\x06\x04\xcb\x01\x02\x01\
    \x05\x12\x04\xf1/\x0b\x11\n\x0e\n\x06\x04\xcb\x01\x02\x01\x01\x12\x04\
    \xf1/\x12'\n\x0e\n\x06\x04\xcb\x01\x02\x01\x03\x12\x04\xf1/*+\n.\n\x03\
    \x04\xcc\x01\x12\x06\xf5/\0\xf9/\x01\x1a\x1f\x20MultiAnnotationFilterRes\
    ponse\n\n\x0c\n\x04\x04\xcc\x01\x01\x12\x04\xf5/\x08%\n\r\n\x05\x04\xcc\
    \x01\x02\0\x12\x04\xf6/\x02(\n\x0e\n\x06\x04\xcc\x01\x02\0\x06\x12\x04\
    \xf6/\x02\x1c\n\x0e\n\x06\x04\xcc\x01\x02\0\x01\x12\x04\xf6/\x1d#\n\x0e\
    \n\x06\x04\xcc\x01\x02\0\x03\x12\x04\xf6/&'\n\r\n\x05\x04\xcc\x01\x02\
    \x01\x12\x04\xf8/\x02b\n\x0e\n\x06\x04\xcc\x01\x02\x01\x04\x12\x04\xf8/\
    \x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x01\x06\x12\x04\xf8/\x0b\x1b\n\x0e\n\
    \x06\x04\xcc\x01\x02\x01\x01\x12\x04\xf8/\x1c.\n\x0e\n\x06\x04\xcc\x01\
    \x02\x01\x03\x12\x04\xf8/12\n\x0e\n\x06\x04\xcc\x01\x02\x01\x08\x12\x04\
    \xf8/3a\n\x11\n\t\x04\xcc\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xf8/4`\n/\
    \n\x03\x04\xcd\x01\x12\x06\xfc/\0\x800\x01\x1a\x20\x20SingleAnnotationFi\
    lterResponse\n\n\x0c\n\x04\x04\xcd\x01\x01\x12\x04\xfc/\x08&\n\r\n\x05\
    \x04\xcd\x01\x02\0\x12\x04\xfd/\x02(\n\x0e\n\x06\x04\xcd\x01\x02\0\x06\
    \x12\x04\xfd/\x02\x1c\n\x0e\n\x06\x04\xcd\x01\x02\0\x01\x12\x04\xfd/\x1d\
    #\n\x0e\n\x06\x04\xcd\x01\x02\0\x03\x12\x04\xfd/&'\n\r\n\x05\x04\xcd\x01\
    \x02\x01\x12\x04\xff/\x02)\n\x0e\n\x06\x04\xcd\x01\x02\x01\x06\x12\x04\
    \xff/\x02\x12\n\x0e\n\x06\x04\xcd\x01\x02\x01\x01\x12\x04\xff/\x13$\n\
    \x0e\n\x06\x04\xcd\x01\x02\x01\x03\x12\x04\xff/'(\n\x1f\n\x03\x04\xce\
    \x01\x12\x06\xa30\0\xaa0\x01\x1a\x10\x20GetUserRequest\n\n\x0c\n\x04\x04\
    \xce\x01\x01\x12\x04\xa30\x08\x16\n\xbe\x01\n\x05\x04\xce\x01\x02\0\x12\
    \x04\xa60\x02,\x1a\xae\x01\x20we\x20used\x20to\x20have\x20user_id\x20but\
    \x20moved\x20to\x20the\x20standard\x20convention.\x20Since\x20this\x20en\
    dpoint\n\x20hasn't\x20been\x20exposed\x20and\x20only\x20used\x20by\x20po\
    rtal\x20as\x20a\x20url\x20this\x20won't\x20effect\x20anything\x20externa\
    l.\n\n\x0e\n\x06\x04\xce\x01\x02\0\x06\x12\x04\xa60\x02\x1b\n\x0e\n\x06\
    \x04\xce\x01\x02\0\x01\x12\x04\xa60\x1c'\n\x0e\n\x06\x04\xce\x01\x02\0\
    \x03\x12\x04\xa60*+\n\x83\x01\n\x05\x04\xce\x01\x02\x01\x12\x04\xa90\x02\
    (\x1at\x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20\
    fields\x20to\x20be\x20included\x20in\x20the\x20response.\x20Currently\
    \x20supported:\x20all,\x20stars\n\n\x0e\n\x06\x04\xce\x01\x02\x01\x04\
    \x12\x04\xa90\x02\n\n\x0e\n\x06\x04\xce\x01\x02\x01\x05\x12\x04\xa90\x0b\
    \x11\n\x0e\n\x06\x04\xce\x01\x02\x01\x01\x12\x04\xa90\x12#\n\x0e\n\x06\
    \x04\xce\x01\x02\x01\x03\x12\x04\xa90&'\n#\n\x03\x04\xcf\x01\x12\x06\xaf\
    0\0\xb20\x01\x1a\x14\x20SingleUserResponse\n\n\x0c\n\x04\x04\xcf\x01\x01\
    \x12\x04\xaf0\x08\x1a\n\r\n\x05\x04\xcf\x01\x02\0\x12\x04\xb00\x02(\n\
    \x0e\n\x06\x04\xcf\x01\x02\0\x06\x12\x04\xb00\x02\x1c\n\x0e\n\x06\x04\
    \xcf\x01\x02\0\x01\x12\x04\xb00\x1d#\n\x0e\n\x06\x04\xcf\x01\x02\0\x03\
    \x12\x04\xb00&'\n\r\n\x05\x04\xcf\x01\x02\x01\x12\x04\xb10\x02\x10\n\x0e\
    \n\x06\x04\xcf\x01\x02\x01\x06\x12\x04\xb10\x02\x06\n\x0e\n\x06\x04\xcf\
    \x01\x02\x01\x01\x12\x04\xb10\x07\x0b\n\x0e\n\x06\x04\xcf\x01\x02\x01\
    \x03\x12\x04\xb10\x0e\x0f\n,\n\x03\x04\xd0\x01\x12\x06\xbf0\0\xc30\x01\
    \x1a\x1d\x20PostValidatePasswordRequest\n\n\x0c\n\x04\x04\xd0\x01\x01\
    \x12\x04\xbf0\x08#\n\r\n\x05\x04\xd0\x01\x02\0\x12\x04\xc00\x02,\n\x0e\n\
    \x06\x04\xd0\x01\x02\0\x06\x12\x04\xc00\x02\x1b\n\x0e\n\x06\x04\xd0\x01\
    \x02\0\x01\x12\x04\xc00\x1c'\n\x0e\n\x06\x04\xd0\x01\x02\0\x03\x12\x04\
    \xc00*+\n)\n\x05\x04\xd0\x01\x02\x01\x12\x04\xc20\x02\x18\x1a\x1a\x20pas\
    sword\x20to\x20be\x20validated\n\n\x0e\n\x06\x04\xd0\x01\x02\x01\x06\x12\
    \x04\xc20\x02\n\n\x0e\n\x06\x04\xd0\x01\x02\x01\x01\x12\x04\xc20\x0b\x13\
    \n\x0e\n\x06\x04\xd0\x01\x02\x01\x03\x12\x04\xc20\x16\x17\n1\n\x03\x04\
    \xd1\x01\x12\x06\xc60\0\xca0\x01\x1a\"\x20SinglePasswordValidationRespon\
    se\n\n\x0c\n\x04\x04\xd1\x01\x01\x12\x04\xc60\x08(\n.\n\x05\x04\xd1\x01\
    \x02\0\x12\x04\xc80\x02(\x1a\x1f\x20Standard\x20clarifai\x20status\x20co\
    de\n\n\x0e\n\x06\x04\xd1\x01\x02\0\x06\x12\x04\xc80\x02\x1c\n\x0e\n\x06\
    \x04\xd1\x01\x02\0\x01\x12\x04\xc80\x1d#\n\x0e\n\x06\x04\xd1\x01\x02\0\
    \x03\x12\x04\xc80&'\n\r\n\x05\x04\xd1\x01\x02\x01\x12\x04\xc90\x02-\n\
    \x0e\n\x06\x04\xd1\x01\x02\x01\x06\x12\x04\xc90\x02\x14\n\x0e\n\x06\x04\
    \xd1\x01\x02\x01\x01\x12\x04\xc90\x15(\n\x0e\n\x06\x04\xd1\x01\x02\x01\
    \x03\x12\x04\xc90+,\n\x0c\n\x02\x05\0\x12\x06\xe50\0\xec0\x01\n\x0b\n\
    \x03\x05\0\x01\x12\x04\xe50\x05!\n\x0c\n\x04\x05\0\x02\0\x12\x04\xe60\
    \x02\x0e\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xe60\x02\t\n\r\n\x05\x05\0\
    \x02\0\x02\x12\x04\xe60\x0c\r\n\x0c\n\x04\x05\0\x02\x01\x12\x04\xe70\x02\
    \x0e\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xe70\x02\t\n\r\n\x05\x05\0\x02\
    \x01\x02\x12\x04\xe70\x0c\r\n\x0c\n\x04\x05\0\x02\x02\x12\x04\xe80\x02\
    \x0f\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xe80\x02\n\n\r\n\x05\x05\0\x02\
    \x02\x02\x12\x04\xe80\r\x0e\n\x0c\n\x04\x05\0\x02\x03\x12\x04\xe90\x02\
    \x10\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\xe90\x02\x0b\n\r\n\x05\x05\0\
    \x02\x03\x02\x12\x04\xe90\x0e\x0f\n\x0c\n\x04\x05\0\x02\x04\x12\x04\xea0\
    \x02\x0f\n\r\n\x05\x05\0\x02\x04\x01\x12\x04\xea0\x02\n\n\r\n\x05\x05\0\
    \x02\x04\x02\x12\x04\xea0\r\x0e\n\x0c\n\x04\x05\0\x02\x05\x12\x04\xeb0\
    \x02\x0e\n\r\n\x05\x05\0\x02\x05\x01\x12\x04\xeb0\x02\t\n\r\n\x05\x05\0\
    \x02\x05\x02\x12\x04\xeb0\x0c\r\n#\n\x03\x04\xd2\x01\x12\x06\xa21\0\xb11\
    \x01\x1a\x14\x20GetWorkflowRequest\n\n\x0c\n\x04\x04\xd2\x01\x01\x12\x04\
    \xa21\x08\x1a\n\r\n\x05\x04\xd2\x01\x02\0\x12\x04\xa31\x02,\n\x0e\n\x06\
    \x04\xd2\x01\x02\0\x06\x12\x04\xa31\x02\x1b\n\x0e\n\x06\x04\xd2\x01\x02\
    \0\x01\x12\x04\xa31\x1c'\n\x0e\n\x06\x04\xd2\x01\x02\0\x03\x12\x04\xa31*\
    +\n\xc9\x01\n\x05\x04\xd2\x01\x02\x01\x12\x04\xa81\x02\x19\x1a\xb9\x01\
    \x20Workflow\x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\x20is\x20specif\
    ied\x20we\x20return\x20default\x20workflow\x20of\x20the\x20application\n\
    \x20If\x20an\x20ID\x20is\x20specified\x20by\x20default\x20we\x20first\
    \x20looks\x20into\x20Clarifai\x20workflows\x20for\x20a\x20Workflow\x20ID\
    \n\n\x0e\n\x06\x04\xd2\x01\x02\x01\x05\x12\x04\xa81\x02\x08\n\x0e\n\x06\
    \x04\xd2\x01\x02\x01\x01\x12\x04\xa81\t\x14\n\x0e\n\x06\x04\xd2\x01\x02\
    \x01\x03\x12\x04\xa81\x17\x18\n`\n\x05\x04\xd2\x01\x02\x02\x12\x04\xab1\
    \x02$\x1aQ\x20Use\x20this\x20flag\x20to\x20look\x20into\x20clarifai\x20p\
    ublished\x20workflows\x20first\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\
    \x06\x04\xd2\x01\x02\x02\x05\x12\x04\xab1\x02\x06\n\x0e\n\x06\x04\xd2\
    \x01\x02\x02\x01\x12\x04\xab1\x07\x1f\n\x0e\n\x06\x04\xd2\x01\x02\x02\
    \x03\x12\x04\xab1\"#\n\x83\x01\n\x05\x04\xd2\x01\x02\x03\x12\x04\xad1\
    \x02(\x1at\x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\
    \x20fields\x20to\x20be\x20included\x20in\x20the\x20response.\x20Currentl\
    y\x20supported:\x20all,\x20stars\n\n\x0e\n\x06\x04\xd2\x01\x02\x03\x04\
    \x12\x04\xad1\x02\n\n\x0e\n\x06\x04\xd2\x01\x02\x03\x05\x12\x04\xad1\x0b\
    \x11\n\x0e\n\x06\x04\xd2\x01\x02\x03\x01\x12\x04\xad1\x12#\n\x0e\n\x06\
    \x04\xd2\x01\x02\x03\x03\x12\x04\xad1&'\nE\n\x05\x04\xd2\x01\x02\x04\x12\
    \x04\xb01\x02&\x1a6\x20if\x20true\x20will\x20not\x20expand\x20search\x20\
    to\x20clarifai\x20workflows\n\n\x0e\n\x06\x04\xd2\x01\x02\x04\x05\x12\
    \x04\xb01\x02\x06\n\x0e\n\x06\x04\xd2\x01\x02\x04\x01\x12\x04\xb01\x07!\
    \n\x0e\n\x06\x04\xd2\x01\x02\x04\x03\x12\x04\xb01$%\n%\n\x03\x04\xd3\x01\
    \x12\x06\xb41\0\xef1\x01\x1a\x16\x20ListWorkflowsRequest\n\n\x0c\n\x04\
    \x04\xd3\x01\x01\x12\x04\xb41\x08\x1c\n\r\n\x05\x04\xd3\x01\x02\0\x12\
    \x04\xb51\x02,\n\x0e\n\x06\x04\xd3\x01\x02\0\x06\x12\x04\xb51\x02\x1b\n\
    \x0e\n\x06\x04\xd3\x01\x02\0\x01\x12\x04\xb51\x1c'\n\x0e\n\x06\x04\xd3\
    \x01\x02\0\x03\x12\x04\xb51*+\n\x7f\n\x05\x04\xd3\x01\x02\x01\x12\x04\
    \xb81\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20n\
    umber.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20i\
    nto\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xd3\x01\x02\
    \x01\x05\x12\x04\xb81\x02\x08\n\x0e\n\x06\x04\xd3\x01\x02\x01\x01\x12\
    \x04\xb81\t\r\n\x0e\n\x06\x04\xd3\x01\x02\x01\x03\x12\x04\xb81\x10\x11\n\
    v\n\x05\x04\xd3\x01\x02\x02\x12\x04\xbb1\x02\x16\x1ag\x20(optional\x20UR\
    L\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\
    \n\x06\x04\xd3\x01\x02\x02\x05\x12\x04\xbb1\x02\x08\n\x0e\n\x06\x04\xd3\
    \x01\x02\x02\x01\x12\x04\xbb1\t\x11\n\x0e\n\x06\x04\xd3\x01\x02\x02\x03\
    \x12\x04\xbb1\x14\x15\n\x83\x01\n\x05\x04\xd3\x01\x02\x03\x12\x04\xbe1\
    \x02)\x1at\x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\
    \x20fields\x20to\x20be\x20included\x20in\x20the\x20response.\x20Currentl\
    y\x20supported:\x20all,\x20stars\n\n\x0e\n\x06\x04\xd3\x01\x02\x03\x04\
    \x12\x04\xbe1\x02\n\n\x0e\n\x06\x04\xd3\x01\x02\x03\x05\x12\x04\xbe1\x0b\
    \x11\n\x0e\n\x06\x04\xd3\x01\x02\x03\x01\x12\x04\xbe1\x12#\n\x0e\n\x06\
    \x04\xd3\x01\x02\x03\x03\x12\x04\xbe1&(\np\n\x05\x04\xd3\x01\x02\x04\x12\
    \x04\xc21\x02\x1a\x1aa\x20Sorting\x20options:\n\x20Whether\x20to\x20sort\
    \x20in\x20ascending\x20order.\x20If\x20false,\x20will\x20order\x20in\x20\
    descending\x20order.\n\n\x0e\n\x06\x04\xd3\x01\x02\x04\x05\x12\x04\xc21\
    \x02\x06\n\x0e\n\x06\x04\xd3\x01\x02\x04\x01\x12\x04\xc21\x07\x15\n\x0e\
    \n\x06\x04\xd3\x01\x02\x04\x03\x12\x04\xc21\x18\x19\n\x0f\n\x05\x04\xd3\
    \x01\x08\0\x12\x06\xc31\x02\xce1\x03\n\x0e\n\x06\x04\xd3\x01\x08\0\x01\
    \x12\x04\xc31\x08\x0f\n-\n\x05\x04\xd3\x01\x02\x05\x12\x04\xc51\x04\x18\
    \x1a\x1e\x20Whether\x20to\x20order\x20by\x20the\x20name\n\n\x0e\n\x06\
    \x04\xd3\x01\x02\x05\x05\x12\x04\xc51\x04\x08\n\x0e\n\x06\x04\xd3\x01\
    \x02\x05\x01\x12\x04\xc51\t\x13\n\x0e\n\x06\x04\xd3\x01\x02\x05\x03\x12\
    \x04\xc51\x16\x17\n\x81\x01\n\x05\x04\xd3\x01\x02\x06\x12\x04\xc81\x04!\
    \x1ar\x20Whether\x20to\x20order\x20by\x20the\x20modified_at\x20time.\n\
    \x20If\x20none\x20of\x20the\x20sort\x20options\x20is\x20set\x20to\x20tru\
    e,\x20will\x20sort\x20by\x20modified_at.\n\n\x0e\n\x06\x04\xd3\x01\x02\
    \x06\x05\x12\x04\xc81\x04\x08\n\x0e\n\x06\x04\xd3\x01\x02\x06\x01\x12\
    \x04\xc81\t\x1c\n\x0e\n\x06\x04\xd3\x01\x02\x06\x03\x12\x04\xc81\x1f\x20\
    \n9\n\x05\x04\xd3\x01\x02\x07\x12\x04\xcb1\x04!\x1a*\x20Whether\x20to\
    \x20order\x20by\x20the\x20created_at\x20time.\n\n\x0e\n\x06\x04\xd3\x01\
    \x02\x07\x05\x12\x04\xcb1\x04\x08\n\x0e\n\x06\x04\xd3\x01\x02\x07\x01\
    \x12\x04\xcb1\t\x1b\n\x0e\n\x06\x04\xd3\x01\x02\x07\x03\x12\x04\xcb1\x1e\
    \x20\nL\n\x05\x04\xd3\x01\x02\x08\x12\x04\xcd1\x04!\x1a=\x20Whether\x20t\
    o\x20order\x20by\x20the\x20number\x20of\x20users\x20stared\x20the\x20wor\
    kflow\n\n\x0e\n\x06\x04\xd3\x01\x02\x08\x05\x12\x04\xcd1\x04\x08\n\x0e\n\
    \x06\x04\xd3\x01\x02\x08\x01\x12\x04\xcd1\t\x1b\n\x0e\n\x06\x04\xd3\x01\
    \x02\x08\x03\x12\x04\xcd1\x1e\x20\nl\n\x05\x04\xd3\x01\x02\t\x12\x04\xd2\
    1\x02\x19\x1a]\x20Filtering\x20options:\n\x20If\x20true,\x20we\x20only\
    \x20return\x20workflows\x20that\x20are\x20handpicked\x20by\x20clarifai\
    \x20staff\n\n\x0e\n\x06\x04\xd3\x01\x02\t\x05\x12\x04\xd21\x02\x06\n\x0e\
    \n\x06\x04\xd3\x01\x02\t\x01\x12\x04\xd21\x07\x14\n\x0e\n\x06\x04\xd3\
    \x01\x02\t\x03\x12\x04\xd21\x17\x18\nZ\n\x05\x04\xd3\x01\x02\n\x12\x04\
    \xd41\x02\x19\x1aK\x20If\x20true,\x20we\x20only\x20return\x20workflows\
    \x20that\x20are\x20starred\x20by\x20the\x20requesting\x20user\n\n\x0e\n\
    \x06\x04\xd3\x01\x02\n\x05\x12\x04\xd41\x02\x06\n\x0e\n\x06\x04\xd3\x01\
    \x02\n\x01\x12\x04\xd41\x07\x13\n\x0e\n\x06\x04\xd3\x01\x02\n\x03\x12\
    \x04\xd41\x16\x18\n\x82\x01\n\x05\x04\xd3\x01\x02\x0b\x12\x04\xd61\x02\
    \x15\x1as\x20Filter\x20workflows\x20by\x20bookmark.\x20If\x20set,\x20onl\
    y\x20return\x20bookmarked\x20workflows.\x20Otherwise\x20none\x20bookmark\
    ed\x20workflows\x20only.\n\n\x0e\n\x06\x04\xd3\x01\x02\x0b\x05\x12\x04\
    \xd61\x02\x06\n\x0e\n\x06\x04\xd3\x01\x02\x0b\x01\x12\x04\xd61\x07\x0f\n\
    \x0e\n\x06\x04\xd3\x01\x02\x0b\x03\x12\x04\xd61\x12\x14\n\xae\x04\n\x05\
    \x04\xd3\x01\x02\x0c\x12\x04\xe51\x02\x15\x1a\x9e\x04\x20Searching\x20op\
    tions:\n\x20Specify\x20a\x20search\x20parameter\x20in\x20order\x20to\x20\
    perform\x20keyword\x20search\x20on\x20the\n\x20following\x20fields\x20of\
    \x20the\x20workflow:\n\x20\x20\x20-\x20id\n\x20\x20\x20-\x20description\
    \n\x20\x20\x20-\x20notes\n\x20\x20\x20-\x20user_id\x20(unless\x20user_ap\
    p_id.user_id\x20is\x20already\x20set)\n\n\x20Keywords\x20are\x20both\x20\
    normalized\x20for\x20search\x20(so\x20searching\x20for\x20\"satisfy\"\
    \x20matches\x20\"satisfied\")\n\x20and\x20used\x20for\x20partial\x20pref\
    ix-matching\x20(so\x20searching\x20for\x20\"clari\"\x20matches\x20\"clar\
    ifai\").\n\n\x20NOTE:\x20Both\x20the\x20list\x20of\x20fields\x20searched\
    \x20and\x20the\x20exact\x20keyword\x20matching\n\x20rules\x20are\x20subj\
    ect\x20to\x20change\x20and\x20not\x20guaranteed\x20to\x20be\x20backwards\
    -compatible.\n\n\x0e\n\x06\x04\xd3\x01\x02\x0c\x05\x12\x04\xe51\x02\x08\
    \n\x0e\n\x06\x04\xd3\x01\x02\x0c\x01\x12\x04\xe51\t\x0f\n\x0e\n\x06\x04\
    \xd3\x01\x02\x0c\x03\x12\x04\xe51\x12\x14\n\x98\x01\n\x05\x04\xd3\x01\
    \x02\r\x12\x04\xe81\x02'\x1a\x88\x01\x20Query\x20various\x20text\x20fiel\
    ds\x20(id,\x20description\x20and\x20notes)\x20that\x20can\x20contain\x20\
    the\x20words\x20in\x20the\x20query\x20string.\n\x20Deprecated:\x20use\
    \x20search\x20instead.\n\n\x0e\n\x06\x04\xd3\x01\x02\r\x05\x12\x04\xe81\
    \x02\x08\n\x0e\n\x06\x04\xd3\x01\x02\r\x01\x12\x04\xe81\t\x0e\n\x0e\n\
    \x06\x04\xd3\x01\x02\r\x03\x12\x04\xe81\x11\x12\n\x0e\n\x06\x04\xd3\x01\
    \x02\r\x08\x12\x04\xe81\x13&\n\x0f\n\x07\x04\xd3\x01\x02\r\x08\x03\x12\
    \x04\xe81\x14%\n\xa0\x01\n\x05\x04\xd3\x01\x02\x0e\x12\x04\xeb1\x02$\x1a\
    \x90\x01\x20Filter\x20by\x20the\x20id\x20of\x20the\x20workflow.\x20This\
    \x20supports\x20wilcard\x20queries\x20like\x20\"gen*\"\x20to\x20match\
    \x20\"general\"\x20as\x20an\x20example.\n\x20Deprecated:\x20use\x20searc\
    h\x20instead.\n\n\x0e\n\x06\x04\xd3\x01\x02\x0e\x05\x12\x04\xeb1\x02\x08\
    \n\x0e\n\x06\x04\xd3\x01\x02\x0e\x01\x12\x04\xeb1\t\x0b\n\x0e\n\x06\x04\
    \xd3\x01\x02\x0e\x03\x12\x04\xeb1\x0e\x0f\n\x0e\n\x06\x04\xd3\x01\x02\
    \x0e\x08\x12\x04\xeb1\x10#\n\x0f\n\x07\x04\xd3\x01\x02\x0e\x08\x03\x12\
    \x04\xeb1\x11\"\n\x97\x01\n\x05\x04\xd3\x01\x02\x0f\x12\x04\xee1\x02.\
    \x1a\x87\x01\x20Full\x20text\x20and\x20prefix\x20matching\x20on\x20id,\
    \x20owner\x20id,\x20description\x20and\x20notes.\x20Searchable\x20fields\
    \x20may\x20be\x20added\n\x20Deprecated:\x20use\x20search\x20instead.\n\n\
    \x0e\n\x06\x04\xd3\x01\x02\x0f\x05\x12\x04\xee1\x02\x08\n\x0e\n\x06\x04\
    \xd3\x01\x02\x0f\x01\x12\x04\xee1\t\x14\n\x0e\n\x06\x04\xd3\x01\x02\x0f\
    \x03\x12\x04\xee1\x17\x19\n\x0e\n\x06\x04\xd3\x01\x02\x0f\x08\x12\x04\
    \xee1\x1a-\n\x0f\n\x07\x04\xd3\x01\x02\x0f\x08\x03\x12\x04\xee1\x1b,\n%\
    \n\x03\x04\xd4\x01\x12\x06\xf31\0\xf61\x01\x1a\x16\x20PostWorkflowsReque\
    st\n\n\x0c\n\x04\x04\xd4\x01\x01\x12\x04\xf31\x08\x1c\n\r\n\x05\x04\xd4\
    \x01\x02\0\x12\x04\xf41\x02,\n\x0e\n\x06\x04\xd4\x01\x02\0\x06\x12\x04\
    \xf41\x02\x1b\n\x0e\n\x06\x04\xd4\x01\x02\0\x01\x12\x04\xf41\x1c'\n\x0e\
    \n\x06\x04\xd4\x01\x02\0\x03\x12\x04\xf41*+\n\r\n\x05\x04\xd4\x01\x02\
    \x01\x12\x04\xf51\x02\"\n\x0e\n\x06\x04\xd4\x01\x02\x01\x04\x12\x04\xf51\
    \x02\n\n\x0e\n\x06\x04\xd4\x01\x02\x01\x06\x12\x04\xf51\x0b\x13\n\x0e\n\
    \x06\x04\xd4\x01\x02\x01\x01\x12\x04\xf51\x14\x1d\n\x0e\n\x06\x04\xd4\
    \x01\x02\x01\x03\x12\x04\xf51\x20!\n&\n\x03\x04\xd5\x01\x12\x06\xf91\0\
    \x842\x01\x1a\x17\x20PatchWorkflowsRequest\n\n\x0c\n\x04\x04\xd5\x01\x01\
    \x12\x04\xf91\x08\x1d\n\r\n\x05\x04\xd5\x01\x02\0\x12\x04\xfa1\x02,\n\
    \x0e\n\x06\x04\xd5\x01\x02\0\x06\x12\x04\xfa1\x02\x1b\n\x0e\n\x06\x04\
    \xd5\x01\x02\0\x01\x12\x04\xfa1\x1c'\n\x0e\n\x06\x04\xd5\x01\x02\0\x03\
    \x12\x04\xfa1*+\n\r\n\x05\x04\xd5\x01\x02\x01\x12\x04\xfb1\x02\"\n\x0e\n\
    \x06\x04\xd5\x01\x02\x01\x04\x12\x04\xfb1\x02\n\n\x0e\n\x06\x04\xd5\x01\
    \x02\x01\x06\x12\x04\xfb1\x0b\x13\n\x0e\n\x06\x04\xd5\x01\x02\x01\x01\
    \x12\x04\xfb1\x14\x1d\n\x0e\n\x06\x04\xd5\x01\x02\x01\x03\x12\x04\xfb1\
    \x20!\n\xdf\x02\n\x05\x04\xd5\x01\x02\x02\x12\x04\x832\x02\x14\x1a\xcf\
    \x02\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20object\
    s\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'remo\
    ve'\x20are\x20supported\n\n\x20Note\x20that\x20'remove'\x20can\x20be\x20\
    used\x20to\x20remove\x20the\x20workflow\x20image\x20by\x20setting\n\x20'\
    image.url'\x20in\x20the\x20request\x20to\x20the\x20current\x20value\x20r\
    eturned\x20for\x20that\x20workflow.\n\x20This\x20cannot\x20be\x20used\
    \x20in\x20a\x20request\x20that\x20is\x20patching\x20other\x20fields\x20a\
    s\x20well.\n\n\x0e\n\x06\x04\xd5\x01\x02\x02\x05\x12\x04\x832\x02\x08\n\
    \x0e\n\x06\x04\xd5\x01\x02\x02\x01\x12\x04\x832\t\x0f\n\x0e\n\x06\x04\
    \xd5\x01\x02\x02\x03\x12\x04\x832\x12\x13\n(\n\x03\x04\xd6\x01\x12\x06\
    \x872\0\x902\x01\x1a\x19\x20PatchWorkflowIdsRequest\n\n\x0c\n\x04\x04\
    \xd6\x01\x01\x12\x04\x872\x08\x1f\n\r\n\x05\x04\xd6\x01\x02\0\x12\x04\
    \x882\x02,\n\x0e\n\x06\x04\xd6\x01\x02\0\x06\x12\x04\x882\x02\x1b\n\x0e\
    \n\x06\x04\xd6\x01\x02\0\x01\x12\x04\x882\x1c'\n\x0e\n\x06\x04\xd6\x01\
    \x02\0\x03\x12\x04\x882*+\n)\n\x05\x04\xd6\x01\x02\x01\x12\x04\x8b2\x02\
    \"\x1a\x1a\x20Array\x20containing\x201\x20entry\n\n\x0e\n\x06\x04\xd6\
    \x01\x02\x01\x04\x12\x04\x8b2\x02\n\n\x0e\n\x06\x04\xd6\x01\x02\x01\x06\
    \x12\x04\x8b2\x0b\x19\n\x0e\n\x06\x04\xd6\x01\x02\x01\x01\x12\x04\x8b2\
    \x1a\x1d\n\x0e\n\x06\x04\xd6\x01\x02\x01\x03\x12\x04\x8b2\x20!\n\\\n\x05\
    \x04\xd6\x01\x02\x02\x12\x04\x8f2\x02\x14\x1aM\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20objects\n\x20Only\x20'overwrite'\
    \x20is\x20supported\n\n\x0e\n\x06\x04\xd6\x01\x02\x02\x05\x12\x04\x8f2\
    \x02\x08\n\x0e\n\x06\x04\xd6\x01\x02\x02\x01\x12\x04\x8f2\t\x0f\n\x0e\n\
    \x06\x04\xd6\x01\x02\x02\x03\x12\x04\x8f2\x12\x13\n&\n\x03\x04\xd7\x01\
    \x12\x06\x932\0\x962\x01\x1a\x17\x20DeleteWorkflowRequest\n\n\x0c\n\x04\
    \x04\xd7\x01\x01\x12\x04\x932\x08\x1d\n\r\n\x05\x04\xd7\x01\x02\0\x12\
    \x04\x942\x02,\n\x0e\n\x06\x04\xd7\x01\x02\0\x06\x12\x04\x942\x02\x1b\n\
    \x0e\n\x06\x04\xd7\x01\x02\0\x01\x12\x04\x942\x1c'\n\x0e\n\x06\x04\xd7\
    \x01\x02\0\x03\x12\x04\x942*+\n\r\n\x05\x04\xd7\x01\x02\x01\x12\x04\x952\
    \x02\x19\n\x0e\n\x06\x04\xd7\x01\x02\x01\x05\x12\x04\x952\x02\x08\n\x0e\
    \n\x06\x04\xd7\x01\x02\x01\x01\x12\x04\x952\t\x14\n\x0e\n\x06\x04\xd7\
    \x01\x02\x01\x03\x12\x04\x952\x17\x18\nE\n\x03\x04\xd8\x01\x12\x06\x992\
    \0\x9d2\x01\x1a6\x20Request\x20to\x20delete\x20several\x20things\x20by\
    \x20the\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\xd8\x01\x01\x12\x04\x992\
    \x08\x1e\n\r\n\x05\x04\xd8\x01\x02\0\x12\x04\x9a2\x02,\n\x0e\n\x06\x04\
    \xd8\x01\x02\0\x06\x12\x04\x9a2\x02\x1b\n\x0e\n\x06\x04\xd8\x01\x02\0\
    \x01\x12\x04\x9a2\x1c'\n\x0e\n\x06\x04\xd8\x01\x02\0\x03\x12\x04\x9a2*+\
    \n\r\n\x05\x04\xd8\x01\x02\x01\x12\x04\x9b2\x02\x1a\n\x0e\n\x06\x04\xd8\
    \x01\x02\x01\x04\x12\x04\x9b2\x02\n\n\x0e\n\x06\x04\xd8\x01\x02\x01\x05\
    \x12\x04\x9b2\x0b\x11\n\x0e\n\x06\x04\xd8\x01\x02\x01\x01\x12\x04\x9b2\
    \x12\x15\n\x0e\n\x06\x04\xd8\x01\x02\x01\x03\x12\x04\x9b2\x18\x19\n\r\n\
    \x05\x04\xd8\x01\x02\x02\x12\x04\x9c2\x02\x16\n\x0e\n\x06\x04\xd8\x01\
    \x02\x02\x05\x12\x04\x9c2\x02\x06\n\x0e\n\x06\x04\xd8\x01\x02\x02\x01\
    \x12\x04\x9c2\x07\x11\n\x0e\n\x06\x04\xd8\x01\x02\x02\x03\x12\x04\x9c2\
    \x14\x15\n'\n\x03\x04\xd9\x01\x12\x06\xa02\0\xa32\x01\x1a\x18\x20SingleW\
    orkflowResponse\n\n\x0c\n\x04\x04\xd9\x01\x01\x12\x04\xa02\x08\x1e\n\r\n\
    \x05\x04\xd9\x01\x02\0\x12\x04\xa12\x02(\n\x0e\n\x06\x04\xd9\x01\x02\0\
    \x06\x12\x04\xa12\x02\x1c\n\x0e\n\x06\x04\xd9\x01\x02\0\x01\x12\x04\xa12\
    \x1d#\n\x0e\n\x06\x04\xd9\x01\x02\0\x03\x12\x04\xa12&'\n\r\n\x05\x04\xd9\
    \x01\x02\x01\x12\x04\xa22\x02\x18\n\x0e\n\x06\x04\xd9\x01\x02\x01\x06\
    \x12\x04\xa22\x02\n\n\x0e\n\x06\x04\xd9\x01\x02\x01\x01\x12\x04\xa22\x0b\
    \x13\n\x0e\n\x06\x04\xd9\x01\x02\x01\x03\x12\x04\xa22\x16\x17\n&\n\x03\
    \x04\xda\x01\x12\x06\xa62\0\xa92\x01\x1a\x17\x20MultiWorkflowResponse\n\
    \n\x0c\n\x04\x04\xda\x01\x01\x12\x04\xa62\x08\x1d\n\r\n\x05\x04\xda\x01\
    \x02\0\x12\x04\xa72\x02(\n\x0e\n\x06\x04\xda\x01\x02\0\x06\x12\x04\xa72\
    \x02\x1c\n\x0e\n\x06\x04\xda\x01\x02\0\x01\x12\x04\xa72\x1d#\n\x0e\n\x06\
    \x04\xda\x01\x02\0\x03\x12\x04\xa72&'\n\r\n\x05\x04\xda\x01\x02\x01\x12\
    \x04\xa82\x02Q\n\x0e\n\x06\x04\xda\x01\x02\x01\x04\x12\x04\xa82\x02\n\n\
    \x0e\n\x06\x04\xda\x01\x02\x01\x06\x12\x04\xa82\x0b\x13\n\x0e\n\x06\x04\
    \xda\x01\x02\x01\x01\x12\x04\xa82\x14\x1d\n\x0e\n\x06\x04\xda\x01\x02\
    \x01\x03\x12\x04\xa82\x20!\n\x0e\n\x06\x04\xda\x01\x02\x01\x08\x12\x04\
    \xa82\"P\n\x11\n\t\x04\xda\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xa82#O\n+\
    \n\x03\x04\xdb\x01\x12\x06\xac2\0\xc82\x01\x1a\x1c\x20PostWorkflowResult\
    sRequest\n\n\x0c\n\x04\x04\xdb\x01\x01\x12\x04\xac2\x08\"\n\r\n\x05\x04\
    \xdb\x01\x02\0\x12\x04\xad2\x02,\n\x0e\n\x06\x04\xdb\x01\x02\0\x06\x12\
    \x04\xad2\x02\x1b\n\x0e\n\x06\x04\xdb\x01\x02\0\x01\x12\x04\xad2\x1c'\n\
    \x0e\n\x06\x04\xdb\x01\x02\0\x03\x12\x04\xad2*+\n\xc9\x01\n\x05\x04\xdb\
    \x01\x02\x01\x12\x04\xb22\x02\x19\x1a\xb9\x01\x20Workflow\x20ID\x20to\
    \x20retrieve\n\x20If\x20no\x20ID\x20is\x20specified\x20we\x20return\x20d\
    efault\x20workflow\x20of\x20the\x20application\n\x20If\x20an\x20ID\x20is\
    \x20specified\x20by\x20default\x20we\x20first\x20looks\x20into\x20Clarif\
    ai\x20workflows\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\xdb\x01\
    \x02\x01\x05\x12\x04\xb22\x02\x08\n\x0e\n\x06\x04\xdb\x01\x02\x01\x01\
    \x12\x04\xb22\t\x14\n\x0e\n\x06\x04\xdb\x01\x02\x01\x03\x12\x04\xb22\x17\
    \x18\nh\n\x05\x04\xdb\x01\x02\x02\x12\x04\xb62\x02\x18\x1aY\x20Workflow\
    \x20version\x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\x20is\x20specifi\
    ed,\x20latest\x20workflow\x20version\x20is\x20used\n\n\x0e\n\x06\x04\xdb\
    \x01\x02\x02\x05\x12\x04\xb62\x02\x08\n\x0e\n\x06\x04\xdb\x01\x02\x02\
    \x01\x12\x04\xb62\t\x13\n\x0e\n\x06\x04\xdb\x01\x02\x02\x03\x12\x04\xb62\
    \x16\x17\n\r\n\x05\x04\xdb\x01\x02\x03\x12\x04\xb82\x02\x1c\n\x0e\n\x06\
    \x04\xdb\x01\x02\x03\x04\x12\x04\xb82\x02\n\n\x0e\n\x06\x04\xdb\x01\x02\
    \x03\x06\x12\x04\xb82\x0b\x10\n\x0e\n\x06\x04\xdb\x01\x02\x03\x01\x12\
    \x04\xb82\x11\x17\n\x0e\n\x06\x04\xdb\x01\x02\x03\x03\x12\x04\xb82\x1a\
    \x1b\n\xb4\x04\n\x05\x04\xdb\x01\x02\x04\x12\x04\xbf2\x02!\x1a\xa4\x04\
    \x20FIXME(zeiler):\x20the\x20request\x20for\x20post\x20workflows\x20is\
    \x20using\x20an\x20outputconfig\x20object\x20that\x20is\x20supposed\n\
    \x20to\x20be\x20within\x20models.\x20This\x20is\x20not\x20consistent\x20\
    with\x20setting\x20this\x20on\x20the\x20request\x20for\x20post\x20model\
    \n\x20outputs\x20where\x20it\x20is\x20inside\x20a\x20model\x20object.\
    \x20To\x20make\x20this\x20consistent\x20we\x20would\x20send\x20in\x20the\
    \n\x20workflow\x20object\x20so\x20that\x20each\x20model\x20can\x20have\
    \x20it's\x20own\x20output\x20config.\x20If\x20nobody\x20is\x20setting\n\
    \x20this\x20OutputConfig\x20it\x20would\x20probably\x20be\x20easier\x20t\
    o\x20just\x20remove\x20it\x20for\x20now\x20to\x20keep\x20things\x20simpl\
    er\n\x20and\x20then\x20it's\x20more\x20consistent\x20we\x20just\x20don't\
    \x20support\x20the\x20OutputConfig\x20on\x20workflows.\n\n\x0e\n\x06\x04\
    \xdb\x01\x02\x04\x06\x12\x04\xbf2\x02\x0e\n\x0e\n\x06\x04\xdb\x01\x02\
    \x04\x01\x12\x04\xbf2\x0f\x1c\n\x0e\n\x06\x04\xdb\x01\x02\x04\x03\x12\
    \x04\xbf2\x1f\x20\n`\n\x05\x04\xdb\x01\x02\x05\x12\x04\xc22\x02$\x1aQ\
    \x20Use\x20this\x20flag\x20to\x20look\x20into\x20clarifai\x20published\
    \x20workflows\x20first\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\
    \xdb\x01\x02\x05\x05\x12\x04\xc22\x02\x06\n\x0e\n\x06\x04\xdb\x01\x02\
    \x05\x01\x12\x04\xc22\x07\x1f\n\x0e\n\x06\x04\xdb\x01\x02\x05\x03\x12\
    \x04\xc22\"#\n\xf5\x01\n\x05\x04\xdb\x01\x02\x06\x12\x04\xc72\x02#\x1a\
    \xe5\x01\x20A\x20workflow\x20state\x20to\x20be\x20maintained\x20across\
    \x20PostWorkflowResults\x20requests/responses.\n\x20If\x20it\x20is\x20no\
    t\x20sent\x20in\x20the\x20initial\x20request\x20with\x20workflow_state.i\
    d\x20=\x20\"init\"\x20then\x20no\n\x20state\x20will\x20be\x20saved\x20or\
    \x20returned\x20in\x20PostWorkflowResultsResponse.\n\n\x0e\n\x06\x04\xdb\
    \x01\x02\x06\x06\x12\x04\xc72\x02\x0f\n\x0e\n\x06\x04\xdb\x01\x02\x06\
    \x01\x12\x04\xc72\x10\x1e\n\x0e\n\x06\x04\xdb\x01\x02\x06\x03\x12\x04\
    \xc72!\"\n,\n\x03\x04\xdc\x01\x12\x06\xcb2\0\xd82\x01\x1a\x1d\x20PostWor\
    kflowResultsResponse\n\n\x0c\n\x04\x04\xdc\x01\x01\x12\x04\xcb2\x08#\n+\
    \n\x05\x04\xdc\x01\x02\0\x12\x04\xcd2\x02(\x1a\x1c\x20The\x20status\x20o\
    f\x20the\x20request.\n\n\x0e\n\x06\x04\xdc\x01\x02\0\x06\x12\x04\xcd2\
    \x02\x1c\n\x0e\n\x06\x04\xdc\x01\x02\0\x01\x12\x04\xcd2\x1d#\n\x0e\n\x06\
    \x04\xdc\x01\x02\0\x03\x12\x04\xcd2&'\nS\n\x05\x04\xdc\x01\x02\x01\x12\
    \x04\xcf2\x02\x18\x1aD\x20The\x20workflow\x20that\x20was\x20used\x20in\
    \x20predictions\x20with\x20PostWorkflowResults\n\n\x0e\n\x06\x04\xdc\x01\
    \x02\x01\x06\x12\x04\xcf2\x02\n\n\x0e\n\x06\x04\xdc\x01\x02\x01\x01\x12\
    \x04\xcf2\x0b\x13\n\x0e\n\x06\x04\xdc\x01\x02\x01\x03\x12\x04\xcf2\x16\
    \x17\nI\n\x05\x04\xdc\x01\x02\x02\x12\x04\xd12\x02&\x1a:\x20The\x20resul\
    ting\x20predictions\x20of\x20all\x20models\x20in\x20the\x20workflow.\n\n\
    \x0e\n\x06\x04\xdc\x01\x02\x02\x04\x12\x04\xd12\x02\n\n\x0e\n\x06\x04\
    \xdc\x01\x02\x02\x06\x12\x04\xd12\x0b\x19\n\x0e\n\x06\x04\xdc\x01\x02\
    \x02\x01\x12\x04\xd12\x1a!\n\x0e\n\x06\x04\xdc\x01\x02\x02\x03\x12\x04\
    \xd12$%\n\xd3\x02\n\x05\x04\xdc\x01\x02\x03\x12\x04\xd72\x02#\x1a\xc3\
    \x02\x20A\x20workflow\x20state\x20to\x20be\x20maintained\x20across\x20Po\
    stWorkflowResults\x20requests/responses.\n\x20This\x20WorkflowState\x20s\
    hould\x20be\x20passed\x20in\x20to\x20subsequent\x20PostWorkflowResults\
    \x20calls\n\x20if\x20you\x20want\x20to\x20keep\x20track\x20of\x20state\
    \x20across\x20requests.\n\x20If\x20no\x20WorkflowState\x20was\x20initial\
    ized\x20in\x20a\x20request\x20then\x20no\x20WorkflowState\x20will\x20be\
    \x20returned\x20in\x20this\n\x20response.\n\n\x0e\n\x06\x04\xdc\x01\x02\
    \x03\x06\x12\x04\xd72\x02\x0f\n\x0e\n\x06\x04\xdc\x01\x02\x03\x01\x12\
    \x04\xd72\x10\x1e\n\x0e\n\x06\x04\xdc\x01\x02\x03\x03\x12\x04\xd72!\"\n5\
    \n\x03\x04\xdd\x01\x12\x06\xdb2\0\xe92\x01\x1a&\x20PostWorkflowResultsSi\
    milarityRequest\n\n\x0c\n\x04\x04\xdd\x01\x01\x12\x04\xdb2\x08,\n\r\n\
    \x05\x04\xdd\x01\x02\0\x12\x04\xdc2\x02,\n\x0e\n\x06\x04\xdd\x01\x02\0\
    \x06\x12\x04\xdc2\x02\x1b\n\x0e\n\x06\x04\xdd\x01\x02\0\x01\x12\x04\xdc2\
    \x1c'\n\x0e\n\x06\x04\xdd\x01\x02\0\x03\x12\x04\xdc2*+\n\r\n\x05\x04\xdd\
    \x01\x02\x01\x12\x04\xdd2\x02\x19\n\x0e\n\x06\x04\xdd\x01\x02\x01\x05\
    \x12\x04\xdd2\x02\x08\n\x0e\n\x06\x04\xdd\x01\x02\x01\x01\x12\x04\xdd2\t\
    \x14\n\x0e\n\x06\x04\xdd\x01\x02\x01\x03\x12\x04\xdd2\x17\x18\nh\n\x05\
    \x04\xdd\x01\x02\x02\x12\x04\xe02\x02\x18\x1aY\x20Workflow\x20version\
    \x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\x20is\x20specified,\x20late\
    st\x20workflow\x20version\x20is\x20used\n\n\x0e\n\x06\x04\xdd\x01\x02\
    \x02\x05\x12\x04\xe02\x02\x08\n\x0e\n\x06\x04\xdd\x01\x02\x02\x01\x12\
    \x04\xe02\t\x13\n\x0e\n\x06\x04\xdd\x01\x02\x02\x03\x12\x04\xe02\x16\x17\
    \nJ\n\x05\x04\xdd\x01\x02\x03\x12\x04\xe22\x02\x1e\x1a;\x20The\x20specif\
    ic\x20model\x20version\x20whose\x20outputs\x20we\x20are\x20comparing\n\n\
    \x0e\n\x06\x04\xdd\x01\x02\x03\x05\x12\x04\xe22\x02\x08\n\x0e\n\x06\x04\
    \xdd\x01\x02\x03\x01\x12\x04\xe22\t\x19\n\x0e\n\x06\x04\xdd\x01\x02\x03\
    \x03\x12\x04\xe22\x1c\x1d\n@\n\x05\x04\xdd\x01\x02\x04\x12\x04\xe42\x02\
    \"\x1a1\x20Each\x20probe\x20is\x20compared\x20against\x20every\x20pool\
    \x20input\n\n\x0e\n\x06\x04\xdd\x01\x02\x04\x04\x12\x04\xe42\x02\n\n\x0e\
    \n\x06\x04\xdd\x01\x02\x04\x06\x12\x04\xe42\x0b\x10\n\x0e\n\x06\x04\xdd\
    \x01\x02\x04\x01\x12\x04\xe42\x11\x1d\n\x0e\n\x06\x04\xdd\x01\x02\x04\
    \x03\x12\x04\xe42\x20!\nE\n\x05\x04\xdd\x01\x02\x05\x12\x04\xe62\x02!\
    \x1a6\x20Each\x20pool\x20input\x20is\x20compared\x20against\x20ever\x20p\
    robe\x20input\n\n\x0e\n\x06\x04\xdd\x01\x02\x05\x04\x12\x04\xe62\x02\n\n\
    \x0e\n\x06\x04\xdd\x01\x02\x05\x06\x12\x04\xe62\x0b\x10\n\x0e\n\x06\x04\
    \xdd\x01\x02\x05\x01\x12\x04\xe62\x11\x1c\n\x0e\n\x06\x04\xdd\x01\x02\
    \x05\x03\x12\x04\xe62\x1f\x20\n`\n\x05\x04\xdd\x01\x02\x06\x12\x04\xe82\
    \x02$\x1aQ\x20Use\x20this\x20flag\x20to\x20look\x20into\x20clarifai\x20p\
    ublished\x20workflows\x20first\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\
    \x06\x04\xdd\x01\x02\x06\x05\x12\x04\xe82\x02\x06\n\x0e\n\x06\x04\xdd\
    \x01\x02\x06\x01\x12\x04\xe82\x07\x1f\n\x0e\n\x06\x04\xdd\x01\x02\x06\
    \x03\x12\x04\xe82\"#\n6\n\x03\x04\xde\x01\x12\x06\xec2\0\xef2\x01\x1a'\
    \x20PostWorkflowResultsSimilarityResponse\n\n\x0c\n\x04\x04\xde\x01\x01\
    \x12\x04\xec2\x08-\n\r\n\x05\x04\xde\x01\x02\0\x12\x04\xed2\x02(\n\x0e\n\
    \x06\x04\xde\x01\x02\0\x06\x12\x04\xed2\x02\x1c\n\x0e\n\x06\x04\xde\x01\
    \x02\0\x01\x12\x04\xed2\x1d#\n\x0e\n\x06\x04\xde\x01\x02\0\x03\x12\x04\
    \xed2&'\n\r\n\x05\x04\xde\x01\x02\x01\x12\x04\xee2\x021\n\x0e\n\x06\x04\
    \xde\x01\x02\x01\x04\x12\x04\xee2\x02\n\n\x0e\n\x06\x04\xde\x01\x02\x01\
    \x06\x12\x04\xee2\x0b$\n\x0e\n\x06\x04\xde\x01\x02\x01\x01\x12\x04\xee2%\
    ,\n\x0e\n\x06\x04\xde\x01\x02\x01\x03\x12\x04\xee2/0\n,\n\x03\x04\xdf\
    \x01\x12\x06\xf22\0\xfc2\x01\x1a\x1d\x20ListWorkflowVersionsRequest\n\n\
    \x0c\n\x04\x04\xdf\x01\x01\x12\x04\xf22\x08#\n\r\n\x05\x04\xdf\x01\x02\0\
    \x12\x04\xf32\x02,\n\x0e\n\x06\x04\xdf\x01\x02\0\x06\x12\x04\xf32\x02\
    \x1b\n\x0e\n\x06\x04\xdf\x01\x02\0\x01\x12\x04\xf32\x1c'\n\x0e\n\x06\x04\
    \xdf\x01\x02\0\x03\x12\x04\xf32*+\nE\n\x05\x04\xdf\x01\x02\x01\x12\x04\
    \xf52\x02\x19\x1a6\x20List\x20versions\x20for\x20the\x20workflow\x20iden\
    tified\x20by\x20this\x20id\n\n\x0e\n\x06\x04\xdf\x01\x02\x01\x05\x12\x04\
    \xf52\x02\x08\n\x0e\n\x06\x04\xdf\x01\x02\x01\x01\x12\x04\xf52\t\x14\n\
    \x0e\n\x06\x04\xdf\x01\x02\x01\x03\x12\x04\xf52\x17\x18\n\x7f\n\x05\x04\
    \xdf\x01\x02\x02\x12\x04\xf82\x02\x12\x1ap\x20(optional\x20URL\x20parame\
    ter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spli\
    t\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\xdf\x01\x02\x02\x05\x12\x04\xf82\x02\x08\n\x0e\n\x06\x04\xdf\
    \x01\x02\x02\x01\x12\x04\xf82\t\r\n\x0e\n\x06\x04\xdf\x01\x02\x02\x03\
    \x12\x04\xf82\x10\x11\nv\n\x05\x04\xdf\x01\x02\x03\x12\x04\xfb2\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\xdf\x01\x02\x03\x05\x12\x04\xfb2\x02\
    \x08\n\x0e\n\x06\x04\xdf\x01\x02\x03\x01\x12\x04\xfb2\t\x11\n\x0e\n\x06\
    \x04\xdf\x01\x02\x03\x03\x12\x04\xfb2\x14\x15\n*\n\x03\x04\xe0\x01\x12\
    \x06\xff2\0\x853\x01\x1a\x1b\x20GetWorkflowVersionRequest\n\n\x0c\n\x04\
    \x04\xe0\x01\x01\x12\x04\xff2\x08!\n\r\n\x05\x04\xe0\x01\x02\0\x12\x04\
    \x803\x04.\n\x0e\n\x06\x04\xe0\x01\x02\0\x06\x12\x04\x803\x04\x1d\n\x0e\
    \n\x06\x04\xe0\x01\x02\0\x01\x12\x04\x803\x1e)\n\x0e\n\x06\x04\xe0\x01\
    \x02\0\x03\x12\x04\x803,-\nG\n\x05\x04\xe0\x01\x02\x01\x12\x04\x823\x04\
    \x1b\x1a8\x20The\x20id\x20of\x20the\x20workflow\x20that\x20has\x20the\
    \x20requested\x20version.\n\n\x0e\n\x06\x04\xe0\x01\x02\x01\x05\x12\x04\
    \x823\x04\n\n\x0e\n\x06\x04\xe0\x01\x02\x01\x01\x12\x04\x823\x0b\x16\n\
    \x0e\n\x06\x04\xe0\x01\x02\x01\x03\x12\x04\x823\x19\x1a\n.\n\x05\x04\xe0\
    \x01\x02\x02\x12\x04\x843\x04#\x1a\x1f\x20Get\x20the\x20identified\x20by\
    \x20this\x20id\n\n\x0e\n\x06\x04\xe0\x01\x02\x02\x05\x12\x04\x843\x04\n\
    \n\x0e\n\x06\x04\xe0\x01\x02\x02\x01\x12\x04\x843\x0b\x1e\n\x0e\n\x06\
    \x04\xe0\x01\x02\x02\x03\x12\x04\x843!\"\n.\n\x03\x04\xe1\x01\x12\x06\
    \x883\0\x8e3\x01\x1a\x1f\x20DeleteWorkflowVersionsRequest\n\n\x0c\n\x04\
    \x04\xe1\x01\x01\x12\x04\x883\x08%\n\r\n\x05\x04\xe1\x01\x02\0\x12\x04\
    \x893\x04.\n\x0e\n\x06\x04\xe1\x01\x02\0\x06\x12\x04\x893\x04\x1d\n\x0e\
    \n\x06\x04\xe1\x01\x02\0\x01\x12\x04\x893\x1e)\n\x0e\n\x06\x04\xe1\x01\
    \x02\0\x03\x12\x04\x893,-\nR\n\x05\x04\xe1\x01\x02\x01\x12\x04\x8b3\x04\
    \x1b\x1aC\x20The\x20id\x20of\x20the\x20workflow\x20that\x20has\x20the\
    \x20requested\x20versions\x20to\x20delete.\n\n\x0e\n\x06\x04\xe1\x01\x02\
    \x01\x05\x12\x04\x8b3\x04\n\n\x0e\n\x06\x04\xe1\x01\x02\x01\x01\x12\x04\
    \x8b3\x0b\x16\n\x0e\n\x06\x04\xe1\x01\x02\x01\x03\x12\x04\x8b3\x19\x1a\n\
    <\n\x05\x04\xe1\x01\x02\x02\x12\x04\x8d3\x04-\x1a-\x20Delete\x20the\x20v\
    ersions\x20identified\x20by\x20these\x20ids\n\n\x0e\n\x06\x04\xe1\x01\
    \x02\x02\x04\x12\x04\x8d3\x04\x0c\n\x0e\n\x06\x04\xe1\x01\x02\x02\x05\
    \x12\x04\x8d3\r\x13\n\x0e\n\x06\x04\xe1\x01\x02\x02\x01\x12\x04\x8d3\x14\
    (\n\x0e\n\x06\x04\xe1\x01\x02\x02\x03\x12\x04\x8d3+,\n-\n\x03\x04\xe2\
    \x01\x12\x06\x913\0\x9a3\x01\x1a\x1e\x20PatchWorkflowVersionsRequest\n\n\
    \x0c\n\x04\x04\xe2\x01\x01\x12\x04\x913\x08$\n\r\n\x05\x04\xe2\x01\x02\0\
    \x12\x04\x923\x04.\n\x0e\n\x06\x04\xe2\x01\x02\0\x06\x12\x04\x923\x04\
    \x1d\n\x0e\n\x06\x04\xe2\x01\x02\0\x01\x12\x04\x923\x1e)\n\x0e\n\x06\x04\
    \xe2\x01\x02\0\x03\x12\x04\x923,-\nQ\n\x05\x04\xe2\x01\x02\x01\x12\x04\
    \x943\x04\x1b\x1aB\x20The\x20id\x20of\x20the\x20workflow\x20that\x20has\
    \x20the\x20requested\x20versions\x20to\x20patch.\n\n\x0e\n\x06\x04\xe2\
    \x01\x02\x01\x05\x12\x04\x943\x04\n\n\x0e\n\x06\x04\xe2\x01\x02\x01\x01\
    \x12\x04\x943\x0b\x16\n\x0e\n\x06\x04\xe2\x01\x02\x01\x03\x12\x04\x943\
    \x19\x1a\n&\n\x05\x04\xe2\x01\x02\x02\x12\x04\x963\x043\x1a\x17\x20Patch\
    \x20these\x20versions.\n\n\x0e\n\x06\x04\xe2\x01\x02\x02\x04\x12\x04\x96\
    3\x04\x0c\n\x0e\n\x06\x04\xe2\x01\x02\x02\x06\x12\x04\x963\r\x1c\n\x0e\n\
    \x06\x04\xe2\x01\x02\x02\x01\x12\x04\x963\x1d.\n\x0e\n\x06\x04\xe2\x01\
    \x02\x02\x03\x12\x04\x96312\n\x7f\n\x05\x04\xe2\x01\x02\x03\x12\x04\x993\
    \x04\x16\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\
    \x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20an\
    d\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\xe2\x01\x02\x03\x05\
    \x12\x04\x993\x04\n\n\x0e\n\x06\x04\xe2\x01\x02\x03\x01\x12\x04\x993\x0b\
    \x11\n\x0e\n\x06\x04\xe2\x01\x02\x03\x03\x12\x04\x993\x14\x15\n-\n\x03\
    \x04\xe3\x01\x12\x06\x9d3\0\xa03\x01\x1a\x1e\x20MultiWorkflowVersionResp\
    onse\n\n\x0c\n\x04\x04\xe3\x01\x01\x12\x04\x9d3\x08$\n\r\n\x05\x04\xe3\
    \x01\x02\0\x12\x04\x9e3\x04*\n\x0e\n\x06\x04\xe3\x01\x02\0\x06\x12\x04\
    \x9e3\x04\x1e\n\x0e\n\x06\x04\xe3\x01\x02\0\x01\x12\x04\x9e3\x1f%\n\x0e\
    \n\x06\x04\xe3\x01\x02\0\x03\x12\x04\x9e3()\n\r\n\x05\x04\xe3\x01\x02\
    \x01\x12\x04\x9f3\x04b\n\x0e\n\x06\x04\xe3\x01\x02\x01\x04\x12\x04\x9f3\
    \x04\x0c\n\x0e\n\x06\x04\xe3\x01\x02\x01\x06\x12\x04\x9f3\r\x1c\n\x0e\n\
    \x06\x04\xe3\x01\x02\x01\x01\x12\x04\x9f3\x1d.\n\x0e\n\x06\x04\xe3\x01\
    \x02\x01\x03\x12\x04\x9f312\n\x0e\n\x06\x04\xe3\x01\x02\x01\x08\x12\x04\
    \x9f33a\n\x11\n\t\x04\xe3\x01\x02\x01\x08\xd0\x86\x03\x12\x04\x9f34`\n.\
    \n\x03\x04\xe4\x01\x12\x06\xa33\0\xa63\x01\x1a\x1f\x20SingleWorkflowVers\
    ionResponse\n\n\x0c\n\x04\x04\xe4\x01\x01\x12\x04\xa33\x08%\n\r\n\x05\
    \x04\xe4\x01\x02\0\x12\x04\xa43\x04*\n\x0e\n\x06\x04\xe4\x01\x02\0\x06\
    \x12\x04\xa43\x04\x1e\n\x0e\n\x06\x04\xe4\x01\x02\0\x01\x12\x04\xa43\x1f\
    %\n\x0e\n\x06\x04\xe4\x01\x02\0\x03\x12\x04\xa43()\n\r\n\x05\x04\xe4\x01\
    \x02\x01\x12\x04\xa53\x04)\n\x0e\n\x06\x04\xe4\x01\x02\x01\x06\x12\x04\
    \xa53\x04\x13\n\x0e\n\x06\x04\xe4\x01\x02\x01\x01\x12\x04\xa53\x14$\n\
    \x0e\n\x06\x04\xe4\x01\x02\x01\x03\x12\x04\xa53'(\n7\n\x03\x04\xe5\x01\
    \x12\x06\xb13\0\xb53\x01\x1a(\x20Request\x20to\x20start\x20app\x20duplic\
    ation\x20jobs.\n\n\x0c\n\x04\x04\xe5\x01\x01\x12\x04\xb13\x08\"\nT\n\x05\
    \x04\xe5\x01\x02\0\x12\x04\xb33\x02,\x1aE\x20The\x20user\x20and\x20appli\
    cation\x20ID\x20of\x20the\x20source\x20application\x20to\x20duplicate.\n\
    \n\x0e\n\x06\x04\xe5\x01\x02\0\x06\x12\x04\xb33\x02\x1b\n\x0e\n\x06\x04\
    \xe5\x01\x02\0\x01\x12\x04\xb33\x1c'\n\x0e\n\x06\x04\xe5\x01\x02\0\x03\
    \x12\x04\xb33*+\n\r\n\x05\x04\xe5\x01\x02\x01\x12\x04\xb43\x02/\n\x0e\n\
    \x06\x04\xe5\x01\x02\x01\x04\x12\x04\xb43\x02\n\n\x0e\n\x06\x04\xe5\x01\
    \x02\x01\x06\x12\x04\xb43\x0b\x19\n\x0e\n\x06\x04\xe5\x01\x02\x01\x01\
    \x12\x04\xb43\x1a*\n\x0e\n\x06\x04\xe5\x01\x02\x01\x03\x12\x04\xb43-.\n7\
    \n\x03\x04\xe6\x01\x12\x06\xb83\0\xbc3\x01\x1a(\x20Request\x20to\x20get\
    \x20an\x20app\x20duplication\x20job.\n\n\x0c\n\x04\x04\xe6\x01\x01\x12\
    \x04\xb83\x08\x20\nI\n\x05\x04\xe6\x01\x02\0\x12\x04\xba3\x02,\x1a:\x20T\
    he\x20ID\x20of\x20the\x20user\x20that\x20created\x20the\x20app\x20duplic\
    ation\x20job.\n\n\x0e\n\x06\x04\xe6\x01\x02\0\x06\x12\x04\xba3\x02\x1b\n\
    \x0e\n\x06\x04\xe6\x01\x02\0\x01\x12\x04\xba3\x1c'\n\x0e\n\x06\x04\xe6\
    \x01\x02\0\x03\x12\x04\xba3*+\n\r\n\x05\x04\xe6\x01\x02\x01\x12\x04\xbb3\
    \x02\x20\n\x0e\n\x06\x04\xe6\x01\x02\x01\x05\x12\x04\xbb3\x02\x08\n\x0e\
    \n\x06\x04\xe6\x01\x02\x01\x01\x12\x04\xbb3\t\x1b\n\x0e\n\x06\x04\xe6\
    \x01\x02\x01\x03\x12\x04\xbb3\x1e\x1f\nR\n\x03\x04\xe7\x01\x12\x06\xbf3\
    \0\xc83\x01\x1aC\x20Request\x20to\x20list\x20all\x20the\x20app\x20duplic\
    ation\x20jobs\x20that\x20a\x20user\x20created.\n\n\x0c\n\x04\x04\xe7\x01\
    \x01\x12\x04\xbf3\x08\"\nG\n\x05\x04\xe7\x01\x02\0\x12\x04\xc13\x02,\x1a\
    8\x20The\x20ID\x20of\x20the\x20user\x20whose\x20app\x20duplication\x20jo\
    bs\x20to\x20list.\n\n\x0e\n\x06\x04\xe7\x01\x02\0\x06\x12\x04\xc13\x02\
    \x1b\n\x0e\n\x06\x04\xe7\x01\x02\0\x01\x12\x04\xc13\x1c'\n\x0e\n\x06\x04\
    \xe7\x01\x02\0\x03\x12\x04\xc13*+\n\x7f\n\x05\x04\xe7\x01\x02\x01\x12\
    \x04\xc43\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xe7\x01\
    \x02\x01\x05\x12\x04\xc43\x02\x08\n\x0e\n\x06\x04\xe7\x01\x02\x01\x01\
    \x12\x04\xc43\t\r\n\x0e\n\x06\x04\xe7\x01\x02\x01\x03\x12\x04\xc43\x10\
    \x11\nv\n\x05\x04\xe7\x01\x02\x02\x12\x04\xc73\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\x0e\n\x06\x04\xe7\x01\x02\x02\x05\x12\x04\xc73\x02\x08\n\x0e\n\x06\
    \x04\xe7\x01\x02\x02\x01\x12\x04\xc73\t\x11\n\x0e\n\x06\x04\xe7\x01\x02\
    \x02\x03\x12\x04\xc73\x14\x15\n-\n\x03\x04\xe8\x01\x12\x06\xcb3\0\xce3\
    \x01\x1a\x1e\x20MultiAppDuplicationsResponse\n\n\x0c\n\x04\x04\xe8\x01\
    \x01\x12\x04\xcb3\x08$\n\r\n\x05\x04\xe8\x01\x02\0\x12\x04\xcc3\x02(\n\
    \x0e\n\x06\x04\xe8\x01\x02\0\x06\x12\x04\xcc3\x02\x1c\n\x0e\n\x06\x04\
    \xe8\x01\x02\0\x01\x12\x04\xcc3\x1d#\n\x0e\n\x06\x04\xe8\x01\x02\0\x03\
    \x12\x04\xcc3&'\n\r\n\x05\x04\xe8\x01\x02\x01\x12\x04\xcd3\x02/\n\x0e\n\
    \x06\x04\xe8\x01\x02\x01\x04\x12\x04\xcd3\x02\n\n\x0e\n\x06\x04\xe8\x01\
    \x02\x01\x06\x12\x04\xcd3\x0b\x19\n\x0e\n\x06\x04\xe8\x01\x02\x01\x01\
    \x12\x04\xcd3\x1a*\n\x0e\n\x06\x04\xe8\x01\x02\x01\x03\x12\x04\xcd3-.\n-\
    \n\x03\x04\xe9\x01\x12\x06\xd13\0\xd43\x01\x1a\x1e\x20SingleAppDuplicati\
    onResponse\n\n\x0c\n\x04\x04\xe9\x01\x01\x12\x04\xd13\x08$\n\r\n\x05\x04\
    \xe9\x01\x02\0\x12\x04\xd23\x02(\n\x0e\n\x06\x04\xe9\x01\x02\0\x06\x12\
    \x04\xd23\x02\x1c\n\x0e\n\x06\x04\xe9\x01\x02\0\x01\x12\x04\xd23\x1d#\n\
    \x0e\n\x06\x04\xe9\x01\x02\0\x03\x12\x04\xd23&'\n\r\n\x05\x04\xe9\x01\
    \x02\x01\x12\x04\xd33\x02%\n\x0e\n\x06\x04\xe9\x01\x02\x01\x06\x12\x04\
    \xd33\x02\x10\n\x0e\n\x06\x04\xe9\x01\x02\x01\x01\x12\x04\xd33\x11\x20\n\
    \x0e\n\x06\x04\xe9\x01\x02\x01\x03\x12\x04\xd33#$\n)\n\x03\x04\xea\x01\
    \x12\x06\xd73\0\xda3\x01\x1a\x1a\x20Request\x20to\x20create\x20Tasks.\n\
    \n\x0c\n\x04\x04\xea\x01\x01\x12\x04\xd73\x08\x18\n\r\n\x05\x04\xea\x01\
    \x02\0\x12\x04\xd83\x02,\n\x0e\n\x06\x04\xea\x01\x02\0\x06\x12\x04\xd83\
    \x02\x1b\n\x0e\n\x06\x04\xea\x01\x02\0\x01\x12\x04\xd83\x1c'\n\x0e\n\x06\
    \x04\xea\x01\x02\0\x03\x12\x04\xd83*+\n\r\n\x05\x04\xea\x01\x02\x01\x12\
    \x04\xd93\x02\x1a\n\x0e\n\x06\x04\xea\x01\x02\x01\x04\x12\x04\xd93\x02\n\
    \n\x0e\n\x06\x04\xea\x01\x02\x01\x06\x12\x04\xd93\x0b\x0f\n\x0e\n\x06\
    \x04\xea\x01\x02\x01\x01\x12\x04\xd93\x10\x15\n\x0e\n\x06\x04\xea\x01\
    \x02\x01\x03\x12\x04\xd93\x18\x19\n)\n\x03\x04\xeb\x01\x12\x06\xdd3\0\
    \xe93\x01\x1a\x1a\x20Request\x20to\x20get\x20one\x20task.\n\n\x0c\n\x04\
    \x04\xeb\x01\x01\x12\x04\xdd3\x08\x16\n\r\n\x05\x04\xeb\x01\x02\0\x12\
    \x04\xde3\x02,\n\x0e\n\x06\x04\xeb\x01\x02\0\x06\x12\x04\xde3\x02\x1b\n\
    \x0e\n\x06\x04\xeb\x01\x02\0\x01\x12\x04\xde3\x1c'\n\x0e\n\x06\x04\xeb\
    \x01\x02\0\x03\x12\x04\xde3*+\n\r\n\x05\x04\xeb\x01\x02\x01\x12\x04\xdf3\
    \x02\x15\n\x0e\n\x06\x04\xeb\x01\x02\x01\x05\x12\x04\xdf3\x02\x08\n\x0e\
    \n\x06\x04\xeb\x01\x02\x01\x01\x12\x04\xdf3\t\x10\n\x0e\n\x06\x04\xeb\
    \x01\x02\x01\x03\x12\x04\xdf3\x13\x14\n\x83\x02\n\x05\x04\xeb\x01\x02\
    \x02\x12\x04\xe83\x02(\x1a\xf3\x01\x20(optional\x20URL\x20parameter)\x20\
    List\x20of\x20additional\x20fields\x20to\x20be\x20included\x20in\x20the\
    \x20response.\n\x20Currently\x20supported\x20additional\x20fields:\n\x20\
    -\x20all\n\x20-\x20worker.users\n\x20-\x20review.users\n\x20-\x20metrics\
    .work.inputs_count_estimated\n\x20-\x20metrics.work.inputs_percent_estim\
    ated\n\n\x0e\n\x06\x04\xeb\x01\x02\x02\x04\x12\x04\xe83\x02\n\n\x0e\n\
    \x06\x04\xeb\x01\x02\x02\x05\x12\x04\xe83\x0b\x11\n\x0e\n\x06\x04\xeb\
    \x01\x02\x02\x01\x12\x04\xe83\x12#\n\x0e\n\x06\x04\xeb\x01\x02\x02\x03\
    \x12\x04\xe83&'\n0\n\x03\x04\xec\x01\x12\x06\xec3\0\x8a4\x01\x1a!\x20Req\
    uest\x20to\x20list\x20multiple\x20tasks.\n\n\x0c\n\x04\x04\xec\x01\x01\
    \x12\x04\xec3\x08\x18\n\r\n\x05\x04\xec\x01\x02\0\x12\x04\xed3\x02,\n\
    \x0e\n\x06\x04\xec\x01\x02\0\x06\x12\x04\xed3\x02\x1b\n\x0e\n\x06\x04\
    \xec\x01\x02\0\x01\x12\x04\xed3\x1c'\n\x0e\n\x06\x04\xec\x01\x02\0\x03\
    \x12\x04\xed3*+\n\x7f\n\x05\x04\xec\x01\x02\x01\x12\x04\xf03\x02\x12\x1a\
    p\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginat\
    ion\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xec\x01\x02\x01\x05\x12\x04\
    \xf03\x02\x08\n\x0e\n\x06\x04\xec\x01\x02\x01\x01\x12\x04\xf03\t\r\n\x0e\
    \n\x06\x04\xec\x01\x02\x01\x03\x12\x04\xf03\x10\x11\nv\n\x05\x04\xec\x01\
    \x02\x02\x12\x04\xf33\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xec\x01\
    \x02\x02\x05\x12\x04\xf33\x02\x08\n\x0e\n\x06\x04\xec\x01\x02\x02\x01\
    \x12\x04\xf33\t\x11\n\x0e\n\x06\x04\xec\x01\x02\x02\x03\x12\x04\xf33\x14\
    \x15\nP\n\x05\x04\xec\x01\x02\x03\x12\x04\xf53\x02&\x1aA\x20Get\x20tasks\
    \x20that\x20have\x20ANY\x20user\x20from\x20this\x20list\x20assigned\x20a\
    s\x20worker.\n\n\x0e\n\x06\x04\xec\x01\x02\x03\x04\x12\x04\xf53\x02\n\n\
    \x0e\n\x06\x04\xec\x01\x02\x03\x05\x12\x04\xf53\x0b\x11\n\x0e\n\x06\x04\
    \xec\x01\x02\x03\x01\x12\x04\xf53\x12!\n\x0e\n\x06\x04\xec\x01\x02\x03\
    \x03\x12\x04\xf53$%\nR\n\x05\x04\xec\x01\x02\x04\x12\x04\xf73\x02&\x1aC\
    \x20Get\x20tasks\x20that\x20have\x20ANY\x20user\x20from\x20this\x20list\
    \x20assigned\x20as\x20reviewer.\n\n\x0e\n\x06\x04\xec\x01\x02\x04\x04\
    \x12\x04\xf73\x02\n\n\x0e\n\x06\x04\xec\x01\x02\x04\x05\x12\x04\xf73\x0b\
    \x11\n\x0e\n\x06\x04\xec\x01\x02\x04\x01\x12\x04\xf73\x12!\n\x0e\n\x06\
    \x04\xec\x01\x02\x04\x03\x12\x04\xf73$%\nQ\n\x05\x04\xec\x01\x02\x05\x12\
    \x04\xf93\x02&\x1aB\x20Get\x20tasks\x20that\x20are\x20associated\x20to\
    \x20ANY\x20label\x20order\x20from\x20this\x20list.\n\n\x0e\n\x06\x04\xec\
    \x01\x02\x05\x04\x12\x04\xf93\x02\n\n\x0e\n\x06\x04\xec\x01\x02\x05\x05\
    \x12\x04\xf93\x0b\x11\n\x0e\n\x06\x04\xec\x01\x02\x05\x01\x12\x04\xf93\
    \x12!\n\x0e\n\x06\x04\xec\x01\x02\x05\x03\x12\x04\xf93$%\nj\n\x05\x04\
    \xec\x01\x02\x06\x12\x04\xfd3\x02'\x1a[\x20Get\x20label\x20order\x20task\
    s\x20as\x20well\n\x20It\x20is\x20automatically\x20set\x20to\x20true\x20i\
    f\x20label_order_ids\x20is\x20set.\n\n\x0e\n\x06\x04\xec\x01\x02\x06\x05\
    \x12\x04\xfd3\x02\x06\n\x0e\n\x06\x04\xec\x01\x02\x06\x01\x12\x04\xfd3\
    \x07\"\n\x0e\n\x06\x04\xec\x01\x02\x06\x03\x12\x04\xfd3%&\n\x83\x02\n\
    \x05\x04\xec\x01\x02\x07\x12\x04\x864\x02(\x1a\xf3\x01\x20(optional\x20U\
    RL\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\x20in\
    cluded\x20in\x20the\x20response.\n\x20Currently\x20supported\x20addition\
    al\x20fields:\n\x20-\x20all\n\x20-\x20worker.users\n\x20-\x20review.user\
    s\n\x20-\x20metrics.work.inputs_count_estimated\n\x20-\x20metrics.work.i\
    nputs_percent_estimated\n\n\x0e\n\x06\x04\xec\x01\x02\x07\x04\x12\x04\
    \x864\x02\n\n\x0e\n\x06\x04\xec\x01\x02\x07\x05\x12\x04\x864\x0b\x11\n\
    \x0e\n\x06\x04\xec\x01\x02\x07\x01\x12\x04\x864\x12#\n\x0e\n\x06\x04\xec\
    \x01\x02\x07\x03\x12\x04\x864&'\n1\n\x05\x04\xec\x01\x02\x08\x12\x04\x89\
    4\x02\x1a\x1a\"\x20(optional)\x20task\x20IDs\x20to\x20filter\x20on\n\n\
    \x0e\n\x06\x04\xec\x01\x02\x08\x04\x12\x04\x894\x02\n\n\x0e\n\x06\x04\
    \xec\x01\x02\x08\x05\x12\x04\x894\x0b\x11\n\x0e\n\x06\x04\xec\x01\x02\
    \x08\x01\x12\x04\x894\x12\x15\n\x0e\n\x06\x04\xec\x01\x02\x08\x03\x12\
    \x04\x894\x18\x19\n2\n\x03\x04\xed\x01\x12\x06\x8d4\0\x934\x01\x1a#\x20R\
    equest\x20to\x20patch\x20a\x20list\x20of\x20tasks.\n\n\x0c\n\x04\x04\xed\
    \x01\x01\x12\x04\x8d4\x08\x19\n\r\n\x05\x04\xed\x01\x02\0\x12\x04\x8e4\
    \x02,\n\x0e\n\x06\x04\xed\x01\x02\0\x06\x12\x04\x8e4\x02\x1b\n\x0e\n\x06\
    \x04\xed\x01\x02\0\x01\x12\x04\x8e4\x1c'\n\x0e\n\x06\x04\xed\x01\x02\0\
    \x03\x12\x04\x8e4*+\n\r\n\x05\x04\xed\x01\x02\x01\x12\x04\x8f4\x02\x1a\n\
    \x0e\n\x06\x04\xed\x01\x02\x01\x04\x12\x04\x8f4\x02\n\n\x0e\n\x06\x04\
    \xed\x01\x02\x01\x06\x12\x04\x8f4\x0b\x0f\n\x0e\n\x06\x04\xed\x01\x02\
    \x01\x01\x12\x04\x8f4\x10\x15\n\x0e\n\x06\x04\xed\x01\x02\x01\x03\x12\
    \x04\x8f4\x18\x19\n\x7f\n\x05\x04\xed\x01\x02\x02\x12\x04\x924\x02\x14\
    \x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objec\
    ts\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'rem\
    ove'\x20are\x20supported\n\n\x0e\n\x06\x04\xed\x01\x02\x02\x05\x12\x04\
    \x924\x02\x08\n\x0e\n\x06\x04\xed\x01\x02\x02\x01\x12\x04\x924\t\x0f\n\
    \x0e\n\x06\x04\xed\x01\x02\x02\x03\x12\x04\x924\x12\x13\n3\n\x03\x04\xee\
    \x01\x12\x06\x964\0\x994\x01\x1a$\x20Request\x20to\x20delete\x20a\x20lis\
    t\x20of\x20tasks.\n\n\x0c\n\x04\x04\xee\x01\x01\x12\x04\x964\x08\x1a\n\r\
    \n\x05\x04\xee\x01\x02\0\x12\x04\x974\x02,\n\x0e\n\x06\x04\xee\x01\x02\0\
    \x06\x12\x04\x974\x02\x1b\n\x0e\n\x06\x04\xee\x01\x02\0\x01\x12\x04\x974\
    \x1c'\n\x0e\n\x06\x04\xee\x01\x02\0\x03\x12\x04\x974*+\n\r\n\x05\x04\xee\
    \x01\x02\x01\x12\x04\x984\x02\x1a\n\x0e\n\x06\x04\xee\x01\x02\x01\x04\
    \x12\x04\x984\x02\n\n\x0e\n\x06\x04\xee\x01\x02\x01\x05\x12\x04\x984\x0b\
    \x11\n\x0e\n\x06\x04\xee\x01\x02\x01\x01\x12\x04\x984\x12\x15\n\x0e\n\
    \x06\x04\xee\x01\x02\x01\x03\x12\x04\x984\x18\x19\n.\n\x03\x04\xef\x01\
    \x12\x06\x9c4\0\x9f4\x01\x1a\x1f\x20Response\x20with\x20multiple\x20Task\
    s.\n\n\x0c\n\x04\x04\xef\x01\x01\x12\x04\x9c4\x08\x19\n\r\n\x05\x04\xef\
    \x01\x02\0\x12\x04\x9d4\x02(\n\x0e\n\x06\x04\xef\x01\x02\0\x06\x12\x04\
    \x9d4\x02\x1c\n\x0e\n\x06\x04\xef\x01\x02\0\x01\x12\x04\x9d4\x1d#\n\x0e\
    \n\x06\x04\xef\x01\x02\0\x03\x12\x04\x9d4&'\n\r\n\x05\x04\xef\x01\x02\
    \x01\x12\x04\x9e4\x02I\n\x0e\n\x06\x04\xef\x01\x02\x01\x04\x12\x04\x9e4\
    \x02\n\n\x0e\n\x06\x04\xef\x01\x02\x01\x06\x12\x04\x9e4\x0b\x0f\n\x0e\n\
    \x06\x04\xef\x01\x02\x01\x01\x12\x04\x9e4\x10\x15\n\x0e\n\x06\x04\xef\
    \x01\x02\x01\x03\x12\x04\x9e4\x18\x19\n\x0e\n\x06\x04\xef\x01\x02\x01\
    \x08\x12\x04\x9e4\x1aH\n\x11\n\t\x04\xef\x01\x02\x01\x08\xd0\x86\x03\x12\
    \x04\x9e4\x1bG\n-\n\x03\x04\xf0\x01\x12\x06\xa24\0\xa54\x01\x1a\x1e\x20R\
    esponse\x20with\x20a\x20single\x20Task.\n\n\x0c\n\x04\x04\xf0\x01\x01\
    \x12\x04\xa24\x08\x1a\n\r\n\x05\x04\xf0\x01\x02\0\x12\x04\xa34\x02(\n\
    \x0e\n\x06\x04\xf0\x01\x02\0\x06\x12\x04\xa34\x02\x1c\n\x0e\n\x06\x04\
    \xf0\x01\x02\0\x01\x12\x04\xa34\x1d#\n\x0e\n\x06\x04\xf0\x01\x02\0\x03\
    \x12\x04\xa34&'\n\r\n\x05\x04\xf0\x01\x02\x01\x12\x04\xa44\x02\x10\n\x0e\
    \n\x06\x04\xf0\x01\x02\x01\x06\x12\x04\xa44\x02\x06\n\x0e\n\x06\x04\xf0\
    \x01\x02\x01\x01\x12\x04\xa44\x07\x0b\n\x0e\n\x06\x04\xf0\x01\x02\x01\
    \x03\x12\x04\xa44\x0e\x0f\n\xb6\x01\n\x03\x04\xf1\x01\x12\x06\xaa4\0\xc1\
    4\x01\x1a\xa6\x01\x20GetTaskCountRequest\x20can\x20be\x20used\x20for\x20\
    fetching\x20-\n\x201.\x20Task\x20annotation\x20count\x20per\x20user,\x20\
    per\x20status\n\x201.\x20Task\x20input\x20count\x20per\x20user\x20(i.e.\
    \x20task\x20assignment\x20count),\x20per\x20status\n\n\x0c\n\x04\x04\xf1\
    \x01\x01\x12\x04\xaa4\x08\x1b\n\r\n\x05\x04\xf1\x01\x02\0\x12\x04\xab4\
    \x02,\n\x0e\n\x06\x04\xf1\x01\x02\0\x06\x12\x04\xab4\x02\x1b\n\x0e\n\x06\
    \x04\xf1\x01\x02\0\x01\x12\x04\xab4\x1c'\n\x0e\n\x06\x04\xf1\x01\x02\0\
    \x03\x12\x04\xab4*+\nF\n\x05\x04\xf1\x01\x02\x01\x12\x04\xae4\x02\x15\
    \x1a7\x20task_id\x20for\x20which\x20count\x20per\x20user\x20per\x20statu\
    s\x20is\x20needed\n\n\x0e\n\x06\x04\xf1\x01\x02\x01\x05\x12\x04\xae4\x02\
    \x08\n\x0e\n\x06\x04\xf1\x01\x02\x01\x01\x12\x04\xae4\t\x10\n\x0e\n\x06\
    \x04\xf1\x01\x02\x01\x03\x12\x04\xae4\x13\x14\n\xc4\x02\n\x05\x04\xf1\
    \x01\x02\x02\x12\x04\xb44\x02\x1f\x1a\xb4\x02\x20Only\x20return\x20count\
    s\x20for\x20these\x20user\x20IDs,\x20effectively\x20operating\x20as\x20a\
    n\n\x20OR\x20among\x20them\x20to\x20filter\x20down\x20the\x20results.\n\
    \x20If\x20model_version_ids\x20or\x20workflow_version_ids\x20are\x20also\
    \x20provided,\x20these\x20user_ids\x20are\x20OR'd\x20with\x20them\x20as\
    \x20well\x20because\n\x20we\x20want\x20the\x20union\x20of\x20all\x20work\
    er\x20(user,\x20model\x20or\x20workflow)\x20counts\x20in\x20the\x20resul\
    ts.\n\n\x0e\n\x06\x04\xf1\x01\x02\x02\x04\x12\x04\xb44\x02\n\n\x0e\n\x06\
    \x04\xf1\x01\x02\x02\x05\x12\x04\xb44\x0b\x11\n\x0e\n\x06\x04\xf1\x01\
    \x02\x02\x01\x12\x04\xb44\x12\x1a\n\x0e\n\x06\x04\xf1\x01\x02\x02\x03\
    \x12\x04\xb44\x1d\x1e\n\xcd\x02\n\x05\x04\xf1\x01\x02\x03\x12\x04\xba4\
    \x02(\x1a\xbd\x02\x20Only\x20return\x20counts\x20for\x20these\x20model\
    \x20version\x20IDs,\x20effectively\x20operating\x20as\x20an\n\x20OR\x20a\
    mong\x20them\x20to\x20filter\x20down\x20the\x20results.\n\x20If\x20user_\
    ids\x20or\x20workflow_version_ids\x20are\x20also\x20provided,\x20these\
    \x20model_version_ids\x20are\x20OR'd\x20with\x20them\x20as\x20well\x20be\
    cause\n\x20we\x20want\x20the\x20union\x20of\x20all\x20worker\x20(user,\
    \x20model\x20or\x20workflow)\x20counts\x20in\x20the\x20results.\n\n\x0e\
    \n\x06\x04\xf1\x01\x02\x03\x04\x12\x04\xba4\x02\n\n\x0e\n\x06\x04\xf1\
    \x01\x02\x03\x05\x12\x04\xba4\x0b\x11\n\x0e\n\x06\x04\xf1\x01\x02\x03\
    \x01\x12\x04\xba4\x12#\n\x0e\n\x06\x04\xf1\x01\x02\x03\x03\x12\x04\xba4&\
    '\n\xd0\x02\n\x05\x04\xf1\x01\x02\x04\x12\x04\xc04\x02+\x1a\xc0\x02\x20O\
    nly\x20return\x20counts\x20for\x20these\x20workflow\x20version\x20IDs,\
    \x20effectively\x20operating\x20as\x20an\n\x20OR\x20among\x20them\x20to\
    \x20filter\x20down\x20the\x20results.\n\x20If\x20user_ids\x20or\x20model\
    _version_ids\x20are\x20also\x20provided,\x20these\x20workflow_version_id\
    s\x20are\x20OR'd\x20with\x20them\x20as\x20well\x20because\n\x20we\x20wan\
    t\x20the\x20union\x20of\x20all\x20worker\x20(user,\x20model\x20or\x20wor\
    kflow)\x20counts\x20in\x20the\x20results.\n\n\x0e\n\x06\x04\xf1\x01\x02\
    \x04\x04\x12\x04\xc04\x02\n\n\x0e\n\x06\x04\xf1\x01\x02\x04\x05\x12\x04\
    \xc04\x0b\x11\n\x0e\n\x06\x04\xf1\x01\x02\x04\x01\x12\x04\xc04\x12&\n\
    \x0e\n\x06\x04\xf1\x01\x02\x04\x03\x12\x04\xc04)*\n\x8b\x01\n\x03\x04\
    \xf2\x01\x12\x06\xc44\0\xc94\x01\x1a|\x20SingleTaskCountResponse\x20repr\
    esents\x20counts\x20of\x20task\x20annotations\x20or\x20inputs\x20(i.e.\
    \x20task\x20assignments)\x20for\x20labelers\x20in\x20given\x20task\n\n\
    \x0c\n\x04\x04\xf2\x01\x01\x12\x04\xc44\x08\x1f\n\r\n\x05\x04\xf2\x01\
    \x02\0\x12\x04\xc54\x02(\n\x0e\n\x06\x04\xf2\x01\x02\0\x06\x12\x04\xc54\
    \x02\x1c\n\x0e\n\x06\x04\xf2\x01\x02\0\x01\x12\x04\xc54\x1d#\n\x0e\n\x06\
    \x04\xf2\x01\x02\0\x03\x12\x04\xc54&'\n\r\n\x05\x04\xf2\x01\x02\x01\x12\
    \x04\xc64\x02\x14\n\x0e\n\x06\x04\xf2\x01\x02\x01\x05\x12\x04\xc64\x02\
    \x08\n\x0e\n\x06\x04\xf2\x01\x02\x01\x01\x12\x04\xc64\t\x0f\n\x0e\n\x06\
    \x04\xf2\x01\x02\x01\x03\x12\x04\xc64\x12\x13\n\r\n\x05\x04\xf2\x01\x02\
    \x02\x12\x04\xc74\x02\x15\n\x0e\n\x06\x04\xf2\x01\x02\x02\x05\x12\x04\
    \xc74\x02\x08\n\x0e\n\x06\x04\xf2\x01\x02\x02\x01\x12\x04\xc74\t\x10\n\
    \x0e\n\x06\x04\xf2\x01\x02\x02\x03\x12\x04\xc74\x13\x14\n\r\n\x05\x04\
    \xf2\x01\x02\x03\x12\x04\xc84\x02-\n\x0e\n\x06\x04\xf2\x01\x02\x03\x04\
    \x12\x04\xc84\x02\n\n\x0e\n\x06\x04\xf2\x01\x02\x03\x06\x12\x04\xc84\x0b\
    !\n\x0e\n\x06\x04\xf2\x01\x02\x03\x01\x12\x04\xc84\"(\n\x0e\n\x06\x04\
    \xf2\x01\x02\x03\x03\x12\x04\xc84+,\n\xdf\x01\n\x03\x04\xf3\x01\x12\x06\
    \xd44\0\xd74\x01\x1a!\x20Request\x20to\x20create\x20label\x20orders.\n2\
    \xac\x01////////////////////////////////////////////////////////////////\
    //////////////\n\x20Label\x20Orders\n///////////////////////////////////\
    ///////////////////////////////////////////\n\n\x0c\n\x04\x04\xf3\x01\
    \x01\x12\x04\xd44\x08\x1e\n\r\n\x05\x04\xf3\x01\x02\0\x12\x04\xd54\x02,\
    \n\x0e\n\x06\x04\xf3\x01\x02\0\x06\x12\x04\xd54\x02\x1b\n\x0e\n\x06\x04\
    \xf3\x01\x02\0\x01\x12\x04\xd54\x1c'\n\x0e\n\x06\x04\xf3\x01\x02\0\x03\
    \x12\x04\xd54*+\n\r\n\x05\x04\xf3\x01\x02\x01\x12\x04\xd64\x02'\n\x0e\n\
    \x06\x04\xf3\x01\x02\x01\x04\x12\x04\xd64\x02\n\n\x0e\n\x06\x04\xf3\x01\
    \x02\x01\x06\x12\x04\xd64\x0b\x15\n\x0e\n\x06\x04\xf3\x01\x02\x01\x01\
    \x12\x04\xd64\x16\"\n\x0e\n\x06\x04\xf3\x01\x02\x01\x03\x12\x04\xd64%&\n\
    0\n\x03\x04\xf4\x01\x12\x06\xda4\0\xdd4\x01\x1a!\x20Request\x20to\x20get\
    \x20one\x20label\x20order.\n\n\x0c\n\x04\x04\xf4\x01\x01\x12\x04\xda4\
    \x08\x1c\n\r\n\x05\x04\xf4\x01\x02\0\x12\x04\xdb4\x02,\n\x0e\n\x06\x04\
    \xf4\x01\x02\0\x06\x12\x04\xdb4\x02\x1b\n\x0e\n\x06\x04\xf4\x01\x02\0\
    \x01\x12\x04\xdb4\x1c'\n\x0e\n\x06\x04\xf4\x01\x02\0\x03\x12\x04\xdb4*+\
    \n\r\n\x05\x04\xf4\x01\x02\x01\x12\x04\xdc4\x02\x1c\n\x0e\n\x06\x04\xf4\
    \x01\x02\x01\x05\x12\x04\xdc4\x02\x08\n\x0e\n\x06\x04\xf4\x01\x02\x01\
    \x01\x12\x04\xdc4\t\x17\n\x0e\n\x06\x04\xf4\x01\x02\x01\x03\x12\x04\xdc4\
    \x1a\x1b\n7\n\x03\x04\xf5\x01\x12\x06\xe04\0\xe84\x01\x1a(\x20Request\
    \x20to\x20list\x20multiple\x20label\x20orders.\n\n\x0c\n\x04\x04\xf5\x01\
    \x01\x12\x04\xe04\x08\x1e\n\r\n\x05\x04\xf5\x01\x02\0\x12\x04\xe14\x02,\
    \n\x0e\n\x06\x04\xf5\x01\x02\0\x06\x12\x04\xe14\x02\x1b\n\x0e\n\x06\x04\
    \xf5\x01\x02\0\x01\x12\x04\xe14\x1c'\n\x0e\n\x06\x04\xf5\x01\x02\0\x03\
    \x12\x04\xe14*+\n\x7f\n\x05\x04\xf5\x01\x02\x01\x12\x04\xe44\x02\x12\x1a\
    p\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginat\
    ion\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xf5\x01\x02\x01\x05\x12\x04\
    \xe44\x02\x08\n\x0e\n\x06\x04\xf5\x01\x02\x01\x01\x12\x04\xe44\t\r\n\x0e\
    \n\x06\x04\xf5\x01\x02\x01\x03\x12\x04\xe44\x10\x11\nv\n\x05\x04\xf5\x01\
    \x02\x02\x12\x04\xe74\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xf5\x01\
    \x02\x02\x05\x12\x04\xe74\x02\x08\n\x0e\n\x06\x04\xf5\x01\x02\x02\x01\
    \x12\x04\xe74\t\x11\n\x0e\n\x06\x04\xf5\x01\x02\x02\x03\x12\x04\xe74\x14\
    \x15\n9\n\x03\x04\xf6\x01\x12\x06\xeb4\0\xf34\x01\x1a*\x20Request\x20to\
    \x20patch\x20a\x20list\x20of\x20label\x20orders.\n\n\x0c\n\x04\x04\xf6\
    \x01\x01\x12\x04\xeb4\x08\x1f\n\r\n\x05\x04\xf6\x01\x02\0\x12\x04\xec4\
    \x02,\n\x0e\n\x06\x04\xf6\x01\x02\0\x06\x12\x04\xec4\x02\x1b\n\x0e\n\x06\
    \x04\xf6\x01\x02\0\x01\x12\x04\xec4\x1c'\n\x0e\n\x06\x04\xf6\x01\x02\0\
    \x03\x12\x04\xec4*+\n\r\n\x05\x04\xf6\x01\x02\x01\x12\x04\xee4\x02'\n\
    \x0e\n\x06\x04\xf6\x01\x02\x01\x04\x12\x04\xee4\x02\n\n\x0e\n\x06\x04\
    \xf6\x01\x02\x01\x06\x12\x04\xee4\x0b\x15\n\x0e\n\x06\x04\xf6\x01\x02\
    \x01\x01\x12\x04\xee4\x16\"\n\x0e\n\x06\x04\xf6\x01\x02\x01\x03\x12\x04\
    \xee4%&\n\x7f\n\x05\x04\xf6\x01\x02\x02\x12\x04\xf24\x02\x14\x1ap\x20The\
    \x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\
    \x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\
    \x20supported\n\n\x0e\n\x06\x04\xf6\x01\x02\x02\x05\x12\x04\xf24\x02\x08\
    \n\x0e\n\x06\x04\xf6\x01\x02\x02\x01\x12\x04\xf24\t\x0f\n\x0e\n\x06\x04\
    \xf6\x01\x02\x02\x03\x12\x04\xf24\x12\x13\n:\n\x03\x04\xf7\x01\x12\x06\
    \xf64\0\xf94\x01\x1a+\x20Request\x20to\x20delete\x20a\x20list\x20of\x20l\
    abel\x20orders.\n\n\x0c\n\x04\x04\xf7\x01\x01\x12\x04\xf64\x08\x20\n\r\n\
    \x05\x04\xf7\x01\x02\0\x12\x04\xf74\x02,\n\x0e\n\x06\x04\xf7\x01\x02\0\
    \x06\x12\x04\xf74\x02\x1b\n\x0e\n\x06\x04\xf7\x01\x02\0\x01\x12\x04\xf74\
    \x1c'\n\x0e\n\x06\x04\xf7\x01\x02\0\x03\x12\x04\xf74*+\n\r\n\x05\x04\xf7\
    \x01\x02\x01\x12\x04\xf84\x02\x1a\n\x0e\n\x06\x04\xf7\x01\x02\x01\x04\
    \x12\x04\xf84\x02\n\n\x0e\n\x06\x04\xf7\x01\x02\x01\x05\x12\x04\xf84\x0b\
    \x11\n\x0e\n\x06\x04\xf7\x01\x02\x01\x01\x12\x04\xf84\x12\x15\n\x0e\n\
    \x06\x04\xf7\x01\x02\x01\x03\x12\x04\xf84\x18\x19\n4\n\x03\x04\xf8\x01\
    \x12\x06\xfc4\0\xff4\x01\x1a%\x20Response\x20with\x20multiple\x20label\
    \x20order.\n\n\x0c\n\x04\x04\xf8\x01\x01\x12\x04\xfc4\x08\x1f\n\r\n\x05\
    \x04\xf8\x01\x02\0\x12\x04\xfd4\x02(\n\x0e\n\x06\x04\xf8\x01\x02\0\x06\
    \x12\x04\xfd4\x02\x1c\n\x0e\n\x06\x04\xf8\x01\x02\0\x01\x12\x04\xfd4\x1d\
    #\n\x0e\n\x06\x04\xf8\x01\x02\0\x03\x12\x04\xfd4&'\n\r\n\x05\x04\xf8\x01\
    \x02\x01\x12\x04\xfe4\x02V\n\x0e\n\x06\x04\xf8\x01\x02\x01\x04\x12\x04\
    \xfe4\x02\n\n\x0e\n\x06\x04\xf8\x01\x02\x01\x06\x12\x04\xfe4\x0b\x15\n\
    \x0e\n\x06\x04\xf8\x01\x02\x01\x01\x12\x04\xfe4\x16\"\n\x0e\n\x06\x04\
    \xf8\x01\x02\x01\x03\x12\x04\xfe4%&\n\x0e\n\x06\x04\xf8\x01\x02\x01\x08\
    \x12\x04\xfe4'U\n\x11\n\t\x04\xf8\x01\x02\x01\x08\xd0\x86\x03\x12\x04\
    \xfe4(T\n-\n\x03\x04\xf9\x01\x12\x06\x825\0\x855\x01\x1a\x1e\x20Response\
    \x20with\x20a\x20label\x20order.\n\n\x0c\n\x04\x04\xf9\x01\x01\x12\x04\
    \x825\x08\x20\n\r\n\x05\x04\xf9\x01\x02\0\x12\x04\x835\x02(\n\x0e\n\x06\
    \x04\xf9\x01\x02\0\x06\x12\x04\x835\x02\x1c\n\x0e\n\x06\x04\xf9\x01\x02\
    \0\x01\x12\x04\x835\x1d#\n\x0e\n\x06\x04\xf9\x01\x02\0\x03\x12\x04\x835&\
    '\n\r\n\x05\x04\xf9\x01\x02\x01\x12\x04\x845\x02\x1d\n\x0e\n\x06\x04\xf9\
    \x01\x02\x01\x06\x12\x04\x845\x02\x0c\n\x0e\n\x06\x04\xf9\x01\x02\x01\
    \x01\x12\x04\x845\r\x18\n\x0e\n\x06\x04\xf9\x01\x02\x01\x03\x12\x04\x845\
    \x1b\x1c\n.\n\x03\x04\xfa\x01\x12\x06\x885\0\x8b5\x01\x1a\x1f\x20Request\
    \x20to\x20create\x20Collectors.\n\n\x0c\n\x04\x04\xfa\x01\x01\x12\x04\
    \x885\x08\x1d\n\r\n\x05\x04\xfa\x01\x02\0\x12\x04\x895\x02,\n\x0e\n\x06\
    \x04\xfa\x01\x02\0\x06\x12\x04\x895\x02\x1b\n\x0e\n\x06\x04\xfa\x01\x02\
    \0\x01\x12\x04\x895\x1c'\n\x0e\n\x06\x04\xfa\x01\x02\0\x03\x12\x04\x895*\
    +\n\r\n\x05\x04\xfa\x01\x02\x01\x12\x04\x8a5\x02$\n\x0e\n\x06\x04\xfa\
    \x01\x02\x01\x04\x12\x04\x8a5\x02\n\n\x0e\n\x06\x04\xfa\x01\x02\x01\x06\
    \x12\x04\x8a5\x0b\x14\n\x0e\n\x06\x04\xfa\x01\x02\x01\x01\x12\x04\x8a5\
    \x15\x1f\n\x0e\n\x06\x04\xfa\x01\x02\x01\x03\x12\x04\x8a5\"#\n'\n\x03\
    \x04\xfb\x01\x12\x06\x8e5\0\x965\x01\x1a\x18\x20PatchCollectorsRequest\n\
    \n\x0c\n\x04\x04\xfb\x01\x01\x12\x04\x8e5\x08\x1e\n\r\n\x05\x04\xfb\x01\
    \x02\0\x12\x04\x8f5\x02,\n\x0e\n\x06\x04\xfb\x01\x02\0\x06\x12\x04\x8f5\
    \x02\x1b\n\x0e\n\x06\x04\xfb\x01\x02\0\x01\x12\x04\x8f5\x1c'\n\x0e\n\x06\
    \x04\xfb\x01\x02\0\x03\x12\x04\x8f5*+\n\r\n\x05\x04\xfb\x01\x02\x01\x12\
    \x04\x915\x02$\n\x0e\n\x06\x04\xfb\x01\x02\x01\x04\x12\x04\x915\x02\n\n\
    \x0e\n\x06\x04\xfb\x01\x02\x01\x06\x12\x04\x915\x0b\x14\n\x0e\n\x06\x04\
    \xfb\x01\x02\x01\x01\x12\x04\x915\x15\x1f\n\x0e\n\x06\x04\xfb\x01\x02\
    \x01\x03\x12\x04\x915\"#\n\\\n\x05\x04\xfb\x01\x02\x02\x12\x04\x955\x02\
    \x14\x1aM\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20o\
    bjects\n\x20Only\x20'overwrite'\x20is\x20supported\n\n\x0e\n\x06\x04\xfb\
    \x01\x02\x02\x05\x12\x04\x955\x02\x08\n\x0e\n\x06\x04\xfb\x01\x02\x02\
    \x01\x12\x04\x955\t\x0f\n\x0e\n\x06\x04\xfb\x01\x02\x02\x03\x12\x04\x955\
    \x12\x13\nE\n\x03\x04\xfc\x01\x12\x06\x995\0\x9d5\x01\x1a6\x20Request\
    \x20to\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\
    \n\n\x0c\n\x04\x04\xfc\x01\x01\x12\x04\x995\x08\x1f\n\r\n\x05\x04\xfc\
    \x01\x02\0\x12\x04\x9a5\x02,\n\x0e\n\x06\x04\xfc\x01\x02\0\x06\x12\x04\
    \x9a5\x02\x1b\n\x0e\n\x06\x04\xfc\x01\x02\0\x01\x12\x04\x9a5\x1c'\n\x0e\
    \n\x06\x04\xfc\x01\x02\0\x03\x12\x04\x9a5*+\n\r\n\x05\x04\xfc\x01\x02\
    \x01\x12\x04\x9b5\x02\x1a\n\x0e\n\x06\x04\xfc\x01\x02\x01\x04\x12\x04\
    \x9b5\x02\n\n\x0e\n\x06\x04\xfc\x01\x02\x01\x05\x12\x04\x9b5\x0b\x11\n\
    \x0e\n\x06\x04\xfc\x01\x02\x01\x01\x12\x04\x9b5\x12\x15\n\x0e\n\x06\x04\
    \xfc\x01\x02\x01\x03\x12\x04\x9b5\x18\x19\n\r\n\x05\x04\xfc\x01\x02\x02\
    \x12\x04\x9c5\x02\x16\n\x0e\n\x06\x04\xfc\x01\x02\x02\x05\x12\x04\x9c5\
    \x02\x06\n\x0e\n\x06\x04\xfc\x01\x02\x02\x01\x12\x04\x9c5\x07\x11\n\x0e\
    \n\x06\x04\xfc\x01\x02\x02\x03\x12\x04\x9c5\x14\x15\n3\n\x03\x04\xfd\x01\
    \x12\x06\xa05\0\xa35\x01\x1a$\x20Request\x20to\x20GET\x20a\x20single\x20\
    Collector.\n\n\x0c\n\x04\x04\xfd\x01\x01\x12\x04\xa05\x08\x1b\n\r\n\x05\
    \x04\xfd\x01\x02\0\x12\x04\xa15\x02,\n\x0e\n\x06\x04\xfd\x01\x02\0\x06\
    \x12\x04\xa15\x02\x1b\n\x0e\n\x06\x04\xfd\x01\x02\0\x01\x12\x04\xa15\x1c\
    '\n\x0e\n\x06\x04\xfd\x01\x02\0\x03\x12\x04\xa15*+\n\r\n\x05\x04\xfd\x01\
    \x02\x01\x12\x04\xa25\x02\x1a\n\x0e\n\x06\x04\xfd\x01\x02\x01\x05\x12\
    \x04\xa25\x02\x08\n\x0e\n\x06\x04\xfd\x01\x02\x01\x01\x12\x04\xa25\t\x15\
    \n\x0e\n\x06\x04\xfd\x01\x02\x01\x03\x12\x04\xa25\x18\x19\n3\n\x03\x04\
    \xfe\x01\x12\x06\xa65\0\xae5\x01\x1a$\x20Request\x20to\x20GET\x20all\x20\
    the\x20Collectors.\n\n\x0c\n\x04\x04\xfe\x01\x01\x12\x04\xa65\x08\x1d\n\
    \r\n\x05\x04\xfe\x01\x02\0\x12\x04\xa75\x02,\n\x0e\n\x06\x04\xfe\x01\x02\
    \0\x06\x12\x04\xa75\x02\x1b\n\x0e\n\x06\x04\xfe\x01\x02\0\x01\x12\x04\
    \xa75\x1c'\n\x0e\n\x06\x04\xfe\x01\x02\0\x03\x12\x04\xa75*+\n\x7f\n\x05\
    \x04\xfe\x01\x02\x01\x12\x04\xaa5\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \x0e\n\x06\x04\xfe\x01\x02\x01\x05\x12\x04\xaa5\x02\x08\n\x0e\n\x06\x04\
    \xfe\x01\x02\x01\x01\x12\x04\xaa5\t\r\n\x0e\n\x06\x04\xfe\x01\x02\x01\
    \x03\x12\x04\xaa5\x10\x11\nv\n\x05\x04\xfe\x01\x02\x02\x12\x04\xad5\x02\
    \x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20re\
    sults\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defau\
    lts\n\x20to\x20128.\n\n\x0e\n\x06\x04\xfe\x01\x02\x02\x05\x12\x04\xad5\
    \x02\x08\n\x0e\n\x06\x04\xfe\x01\x02\x02\x01\x12\x04\xad5\t\x11\n\x0e\n\
    \x06\x04\xfe\x01\x02\x02\x03\x12\x04\xad5\x14\x15\n3\n\x03\x04\xff\x01\
    \x12\x06\xb15\0\xb45\x01\x1a$\x20Response\x20with\x20multiple\x20Collect\
    ors.\n\n\x0c\n\x04\x04\xff\x01\x01\x12\x04\xb15\x08\x1e\n\r\n\x05\x04\
    \xff\x01\x02\0\x12\x04\xb25\x02(\n\x0e\n\x06\x04\xff\x01\x02\0\x06\x12\
    \x04\xb25\x02\x1c\n\x0e\n\x06\x04\xff\x01\x02\0\x01\x12\x04\xb25\x1d#\n\
    \x0e\n\x06\x04\xff\x01\x02\0\x03\x12\x04\xb25&'\n\r\n\x05\x04\xff\x01\
    \x02\x01\x12\x04\xb35\x02$\n\x0e\n\x06\x04\xff\x01\x02\x01\x04\x12\x04\
    \xb35\x02\n\n\x0e\n\x06\x04\xff\x01\x02\x01\x06\x12\x04\xb35\x0b\x14\n\
    \x0e\n\x06\x04\xff\x01\x02\x01\x01\x12\x04\xb35\x15\x1f\n\x0e\n\x06\x04\
    \xff\x01\x02\x01\x03\x12\x04\xb35\"#\n2\n\x03\x04\x80\x02\x12\x06\xb75\0\
    \xba5\x01\x1a#\x20Response\x20with\x20a\x20single\x20Collector.\n\n\x0c\
    \n\x04\x04\x80\x02\x01\x12\x04\xb75\x08\x1f\n\r\n\x05\x04\x80\x02\x02\0\
    \x12\x04\xb85\x02(\n\x0e\n\x06\x04\x80\x02\x02\0\x06\x12\x04\xb85\x02\
    \x1c\n\x0e\n\x06\x04\x80\x02\x02\0\x01\x12\x04\xb85\x1d#\n\x0e\n\x06\x04\
    \x80\x02\x02\0\x03\x12\x04\xb85&'\n\r\n\x05\x04\x80\x02\x02\x01\x12\x04\
    \xb95\x02\x1a\n\x0e\n\x06\x04\x80\x02\x02\x01\x06\x12\x04\xb95\x02\x0b\n\
    \x0e\n\x06\x04\x80\x02\x02\x01\x01\x12\x04\xb95\x0c\x15\n\x0e\n\x06\x04\
    \x80\x02\x02\x01\x03\x12\x04\xb95\x18\x19\n&\n\x03\x04\x81\x02\x12\x06\
    \xbd5\0\xc25\x01\x1a\x17\x20PostStatValuesRequest\n\n\x0c\n\x04\x04\x81\
    \x02\x01\x12\x04\xbd5\x08\x1d\n>\n\x05\x04\x81\x02\x02\0\x12\x04\xbf5\
    \x02,\x1a/\x20The\x20user\x20and\x20app\x20information\x20for\x20the\x20\
    request.\n\n\x0e\n\x06\x04\x81\x02\x02\0\x06\x12\x04\xbf5\x02\x1b\n\x0e\
    \n\x06\x04\x81\x02\x02\0\x01\x12\x04\xbf5\x1c'\n\x0e\n\x06\x04\x81\x02\
    \x02\0\x03\x12\x04\xbf5*+\nE\n\x05\x04\x81\x02\x02\x01\x12\x04\xc15\x02%\
    \x1a6\x20The\x20stats\x20to\x20post,\x20can\x20post\x20more\x20than\x20o\
    ne\x20at\x20a\x20time.\n\n\x0e\n\x06\x04\x81\x02\x02\x01\x04\x12\x04\xc1\
    5\x02\n\n\x0e\n\x06\x04\x81\x02\x02\x01\x06\x12\x04\xc15\x0b\x14\n\x0e\n\
    \x06\x04\x81\x02\x02\x01\x01\x12\x04\xc15\x15\x20\n\x0e\n\x06\x04\x81\
    \x02\x02\x01\x03\x12\x04\xc15#$\n'\n\x03\x04\x82\x02\x12\x06\xc55\0\xca5\
    \x01\x1a\x18\x20MultiStatValueResponse\n\n\x0c\n\x04\x04\x82\x02\x01\x12\
    \x04\xc55\x08\x1e\n%\n\x05\x04\x82\x02\x02\0\x12\x04\xc75\x02(\x1a\x16\
    \x20The\x20response\x20status.\n\n\x0e\n\x06\x04\x82\x02\x02\0\x06\x12\
    \x04\xc75\x02\x1c\n\x0e\n\x06\x04\x82\x02\x02\0\x01\x12\x04\xc75\x1d#\n\
    \x0e\n\x06\x04\x82\x02\x02\0\x03\x12\x04\xc75&'\n+\n\x05\x04\x82\x02\x02\
    \x01\x12\x04\xc95\x02T\x1a\x1c\x20The\x20returned\x20stats\x20values.\n\
    \n\x0e\n\x06\x04\x82\x02\x02\x01\x04\x12\x04\xc95\x02\n\n\x0e\n\x06\x04\
    \x82\x02\x02\x01\x06\x12\x04\xc95\x0b\x14\n\x0e\n\x06\x04\x82\x02\x02\
    \x01\x01\x12\x04\xc95\x15\x20\n\x0e\n\x06\x04\x82\x02\x02\x01\x03\x12\
    \x04\xc95#$\n\x0e\n\x06\x04\x82\x02\x02\x01\x08\x12\x04\xc95%S\n\x11\n\t\
    \x04\x82\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xc95&R\n/\n\x03\x04\x83\x02\
    \x12\x06\xcd5\0\xd35\x01\x1a\x20\x20PostStatValuesAggregateRequest\n\n\
    \x0c\n\x04\x04\x83\x02\x01\x12\x04\xcd5\x08&\n7\n\x05\x04\x83\x02\x02\0\
    \x12\x04\xcf5\x02,\x1a(\x20Ids\x20present\x20in\x20the\x20url\x20of\x20t\
    he\x20request.\n\n\x0e\n\x06\x04\x83\x02\x02\0\x06\x12\x04\xcf5\x02\x1b\
    \n\x0e\n\x06\x04\x83\x02\x02\0\x01\x12\x04\xcf5\x1c'\n\x0e\n\x06\x04\x83\
    \x02\x02\0\x03\x12\x04\xcf5*+\n4\n\x05\x04\x83\x02\x02\x01\x12\x04\xd25\
    \x02D\x1a%\x20Query\x20to\x20retrieve\x20aggregate\x20values.\n\n\x0e\n\
    \x06\x04\x83\x02\x02\x01\x04\x12\x04\xd25\x02\n\n\x0e\n\x06\x04\x83\x02\
    \x02\x01\x06\x12\x04\xd25\x0b\"\n\x0e\n\x06\x04\x83\x02\x02\x01\x01\x12\
    \x04\xd25#?\n\x0e\n\x06\x04\x83\x02\x02\x01\x03\x12\x04\xd25BC\n0\n\x03\
    \x04\x84\x02\x12\x06\xd65\0\xdc5\x01\x1a!\x20MultiStatValueAggregateResp\
    onse\n\n\x0c\n\x04\x04\x84\x02\x01\x12\x04\xd65\x08'\n%\n\x05\x04\x84\
    \x02\x02\0\x12\x04\xd85\x02(\x1a\x16\x20The\x20response\x20status.\n\n\
    \x0e\n\x06\x04\x84\x02\x02\0\x06\x12\x04\xd85\x02\x1c\n\x0e\n\x06\x04\
    \x84\x02\x02\0\x01\x12\x04\xd85\x1d#\n\x0e\n\x06\x04\x84\x02\x02\0\x03\
    \x12\x04\xd85&'\n?\n\x05\x04\x84\x02\x02\x01\x12\x04\xdb5\x02E\x1a0\x20T\
    he\x20aggregate\x20results\x20for\x20each\x20query\x20passedin.\n\n\x0e\
    \n\x06\x04\x84\x02\x02\x01\x04\x12\x04\xdb5\x02\n\n\x0e\n\x06\x04\x84\
    \x02\x02\x01\x06\x12\x04\xdb5\x0b#\n\x0e\n\x06\x04\x84\x02\x02\x01\x01\
    \x12\x04\xdb5$@\n\x0e\n\x06\x04\x84\x02\x02\x01\x03\x12\x04\xdb5CD\n/\n\
    \x03\x04\x85\x02\x12\x06\xe95\0\xf05\x01\x1a\x20\x20PostTrendingMetricsV\
    iewRequest\n\n\x0c\n\x04\x04\x85\x02\x01\x12\x04\xe95\x08&\n4\n\x05\x04\
    \x85\x02\x02\0\x12\x04\xeb5\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\
    \x20information.\n\n\x0e\n\x06\x04\x85\x02\x02\0\x06\x12\x04\xeb5\x02\
    \x1b\n\x0e\n\x06\x04\x85\x02\x02\0\x01\x12\x04\xeb5\x1c'\n\x0e\n\x06\x04\
    \x85\x02\x02\0\x03\x12\x04\xeb5*+\nT\n\x05\x04\x85\x02\x02\x01\x12\x04\
    \xed5\x02\x17\x1aE\x20For\x20now\x20view\x20types\x20'apps',\x20'workflo\
    ws',\x20and\x20'models'\x20are\x20supported.\n\n\x0e\n\x06\x04\x85\x02\
    \x02\x01\x05\x12\x04\xed5\x02\x08\n\x0e\n\x06\x04\x85\x02\x02\x01\x01\
    \x12\x04\xed5\t\x12\n\x0e\n\x06\x04\x85\x02\x02\x01\x03\x12\x04\xed5\x15\
    \x16\n(\n\x05\x04\x85\x02\x02\x02\x12\x04\xef5\x02\x17\x1a\x19\x20ID\x20\
    of\x20the\x20views\x20object.\n\n\x0e\n\x06\x04\x85\x02\x02\x02\x05\x12\
    \x04\xef5\x02\x08\n\x0e\n\x06\x04\x85\x02\x02\x02\x01\x12\x04\xef5\t\x12\
    \n\x0e\n\x06\x04\x85\x02\x02\x02\x03\x12\x04\xef5\x15\x16\n0\n\x03\x04\
    \x86\x02\x12\x06\xf35\0\xfe5\x01\x1a!\x20ListTrendingMetricsViewsRequest\
    \n\n\x0c\n\x04\x04\x86\x02\x01\x12\x04\xf35\x08'\n4\n\x05\x04\x86\x02\
    \x02\0\x12\x04\xf55\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20info\
    rmation.\n\n\x0e\n\x06\x04\x86\x02\x02\0\x06\x12\x04\xf55\x02\x1b\n\x0e\
    \n\x06\x04\x86\x02\x02\0\x01\x12\x04\xf55\x1c'\n\x0e\n\x06\x04\x86\x02\
    \x02\0\x03\x12\x04\xf55*+\nT\n\x05\x04\x86\x02\x02\x01\x12\x04\xf75\x02\
    \x17\x1aE\x20For\x20now\x20view\x20types\x20'apps',\x20'workflows',\x20a\
    nd\x20'models'\x20are\x20supported.\n\n\x0e\n\x06\x04\x86\x02\x02\x01\
    \x05\x12\x04\xf75\x02\x08\n\x0e\n\x06\x04\x86\x02\x02\x01\x01\x12\x04\
    \xf75\t\x12\n\x0e\n\x06\x04\x86\x02\x02\x01\x03\x12\x04\xf75\x15\x16\n\
    \x7f\n\x05\x04\x86\x02\x02\x02\x12\x04\xfa5\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\x86\x02\x02\x02\x05\x12\x04\xfa5\x02\x08\
    \n\x0e\n\x06\x04\x86\x02\x02\x02\x01\x12\x04\xfa5\t\r\n\x0e\n\x06\x04\
    \x86\x02\x02\x02\x03\x12\x04\xfa5\x10\x11\nv\n\x05\x04\x86\x02\x02\x03\
    \x12\x04\xfd5\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x86\x02\x02\x03\
    \x05\x12\x04\xfd5\x02\x08\n\x0e\n\x06\x04\x86\x02\x02\x03\x01\x12\x04\
    \xfd5\t\x11\n\x0e\n\x06\x04\x86\x02\x02\x03\x03\x12\x04\xfd5\x14\x15\n1\
    \n\x03\x04\x87\x02\x12\x06\x816\0\x846\x01\x1a\"\x20MultiTrendingMetrics\
    ViewResponse\n\n\x0c\n\x04\x04\x87\x02\x01\x12\x04\x816\x08(\n\r\n\x05\
    \x04\x87\x02\x02\0\x12\x04\x826\x02(\n\x0e\n\x06\x04\x87\x02\x02\0\x06\
    \x12\x04\x826\x02\x1c\n\x0e\n\x06\x04\x87\x02\x02\0\x01\x12\x04\x826\x1d\
    #\n\x0e\n\x06\x04\x87\x02\x02\0\x03\x12\x04\x826&'\n\r\n\x05\x04\x87\x02\
    \x02\x01\x12\x04\x836\x02&\n\x0e\n\x06\x04\x87\x02\x02\x01\x04\x12\x04\
    \x836\x02\n\n\x0e\n\x06\x04\x87\x02\x02\x01\x06\x12\x04\x836\x0b\x19\n\
    \x0e\n\x06\x04\x87\x02\x02\x01\x01\x12\x04\x836\x1a!\n\x0e\n\x06\x04\x87\
    \x02\x02\x01\x03\x12\x04\x836$%\n!\n\x03\x04\x88\x02\x12\x06\xb36\0\xb76\
    \x01\x1a\x12\x20GetModuleRequest\n\n\x0c\n\x04\x04\x88\x02\x01\x12\x04\
    \xb36\x08\x18\n\r\n\x05\x04\x88\x02\x02\0\x12\x04\xb46\x02,\n\x0e\n\x06\
    \x04\x88\x02\x02\0\x06\x12\x04\xb46\x02\x1b\n\x0e\n\x06\x04\x88\x02\x02\
    \0\x01\x12\x04\xb46\x1c'\n\x0e\n\x06\x04\x88\x02\x02\0\x03\x12\x04\xb46*\
    +\n\r\n\x05\x04\x88\x02\x02\x01\x12\x04\xb56\x02\x17\n\x0e\n\x06\x04\x88\
    \x02\x02\x01\x05\x12\x04\xb56\x02\x08\n\x0e\n\x06\x04\x88\x02\x02\x01\
    \x01\x12\x04\xb56\t\x12\n\x0e\n\x06\x04\x88\x02\x02\x01\x03\x12\x04\xb56\
    \x15\x16\n\r\n\x05\x04\x88\x02\x02\x02\x12\x04\xb66\x02(\n\x0e\n\x06\x04\
    \x88\x02\x02\x02\x04\x12\x04\xb66\x02\n\n\x0e\n\x06\x04\x88\x02\x02\x02\
    \x05\x12\x04\xb66\x0b\x11\n\x0e\n\x06\x04\x88\x02\x02\x02\x01\x12\x04\
    \xb66\x12#\n\x0e\n\x06\x04\x88\x02\x02\x02\x03\x12\x04\xb66&'\n#\n\x03\
    \x04\x89\x02\x12\x06\xba6\0\xeb6\x01\x1a\x14\x20ListModulesRequest\n\n\
    \x0c\n\x04\x04\x89\x02\x01\x12\x04\xba6\x08\x1a\n\r\n\x05\x04\x89\x02\
    \x02\0\x12\x04\xbb6\x02,\n\x0e\n\x06\x04\x89\x02\x02\0\x06\x12\x04\xbb6\
    \x02\x1b\n\x0e\n\x06\x04\x89\x02\x02\0\x01\x12\x04\xbb6\x1c'\n\x0e\n\x06\
    \x04\x89\x02\x02\0\x03\x12\x04\xbb6*+\n\x7f\n\x05\x04\x89\x02\x02\x01\
    \x12\x04\xbe6\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20p\
    age\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20resu\
    lts\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x89\
    \x02\x02\x01\x05\x12\x04\xbe6\x02\x08\n\x0e\n\x06\x04\x89\x02\x02\x01\
    \x01\x12\x04\xbe6\t\r\n\x0e\n\x06\x04\x89\x02\x02\x01\x03\x12\x04\xbe6\
    \x10\x11\nv\n\x05\x04\x89\x02\x02\x02\x12\x04\xc16\x02\x16\x1ag\x20(opti\
    onal\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20w\
    ill\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128\
    .\n\n\x0e\n\x06\x04\x89\x02\x02\x02\x05\x12\x04\xc16\x02\x08\n\x0e\n\x06\
    \x04\x89\x02\x02\x02\x01\x12\x04\xc16\t\x11\n\x0e\n\x06\x04\x89\x02\x02\
    \x02\x03\x12\x04\xc16\x14\x15\n\r\n\x05\x04\x89\x02\x02\x03\x12\x04\xc36\
    \x02(\n\x0e\n\x06\x04\x89\x02\x02\x03\x04\x12\x04\xc36\x02\n\n\x0e\n\x06\
    \x04\x89\x02\x02\x03\x05\x12\x04\xc36\x0b\x11\n\x0e\n\x06\x04\x89\x02\
    \x02\x03\x01\x12\x04\xc36\x12#\n\x0e\n\x06\x04\x89\x02\x02\x03\x03\x12\
    \x04\xc36&'\np\n\x05\x04\x89\x02\x02\x04\x12\x04\xc76\x02\x1a\x1aa\x20So\
    rting\x20options:\n\x20Whether\x20to\x20sort\x20in\x20ascending\x20order\
    .\x20If\x20false,\x20will\x20order\x20in\x20descending\x20order.\n\n\x0e\
    \n\x06\x04\x89\x02\x02\x04\x05\x12\x04\xc76\x02\x06\n\x0e\n\x06\x04\x89\
    \x02\x02\x04\x01\x12\x04\xc76\x07\x15\n\x0e\n\x06\x04\x89\x02\x02\x04\
    \x03\x12\x04\xc76\x18\x19\n\x0f\n\x05\x04\x89\x02\x08\0\x12\x06\xc86\x02\
    \xd16\x03\n\x0e\n\x06\x04\x89\x02\x08\0\x01\x12\x04\xc86\x08\x0f\n9\n\
    \x05\x04\x89\x02\x02\x05\x12\x04\xca6\x04\x20\x1a*\x20Whether\x20to\x20o\
    rder\x20by\x20the\x20created_at\x20time.\n\n\x0e\n\x06\x04\x89\x02\x02\
    \x05\x05\x12\x04\xca6\x04\x08\n\x0e\n\x06\x04\x89\x02\x02\x05\x01\x12\
    \x04\xca6\t\x1b\n\x0e\n\x06\x04\x89\x02\x02\x05\x03\x12\x04\xca6\x1e\x1f\
    \nG\n\x05\x04\x89\x02\x02\x06\x12\x04\xcc6\x04\x20\x1a8\x20Whether\x20to\
    \x20order\x20by\x20the\x20number\x20of\x20users\x20stared\x20the\x20app\
    \n\n\x0e\n\x06\x04\x89\x02\x02\x06\x05\x12\x04\xcc6\x04\x08\n\x0e\n\x06\
    \x04\x89\x02\x02\x06\x01\x12\x04\xcc6\t\x1b\n\x0e\n\x06\x04\x89\x02\x02\
    \x06\x03\x12\x04\xcc6\x1e\x1f\nQ\n\x05\x04\x89\x02\x02\x07\x12\x04\xce6\
    \x04!\x1aB\x20If\x20neither\x20sort\x20option\x20is\x20set\x20to\x20true\
    ,\x20will\x20sort\x20by\x20modified_at.\n\n\x0e\n\x06\x04\x89\x02\x02\
    \x07\x05\x12\x04\xce6\x04\x08\n\x0e\n\x06\x04\x89\x02\x02\x07\x01\x12\
    \x04\xce6\t\x1c\n\x0e\n\x06\x04\x89\x02\x02\x07\x03\x12\x04\xce6\x1f\x20\
    \n4\n\x05\x04\x89\x02\x02\x08\x12\x04\xd06\x04\x19\x1a%\x20Whether\x20to\
    \x20order\x20by\x20the\x20external\x20id\n\n\x0e\n\x06\x04\x89\x02\x02\
    \x08\x05\x12\x04\xd06\x04\x08\n\x0e\n\x06\x04\x89\x02\x02\x08\x01\x12\
    \x04\xd06\t\x13\n\x0e\n\x06\x04\x89\x02\x02\x08\x03\x12\x04\xd06\x16\x18\
    \n#\n\x05\x04\x89\x02\x02\t\x12\x04\xd46\x02\x18\x1a\x14\x20Filtering\
    \x20options:\n\n\x0e\n\x06\x04\x89\x02\x02\t\x05\x12\x04\xd46\x02\x06\n\
    \x0e\n\x06\x04\x89\x02\x02\t\x01\x12\x04\xd46\x07\x13\n\x0e\n\x06\x04\
    \x89\x02\x02\t\x03\x12\x04\xd46\x16\x17\n|\n\x05\x04\x89\x02\x02\n\x12\
    \x04\xd66\x02\x15\x1am\x20Filter\x20modules\x20by\x20bookmark.\x20If\x20\
    set,\x20only\x20return\x20bookmarked\x20modules.\x20Otherwise\x20none\
    \x20bookmarked\x20modules\x20only.\n\n\x0e\n\x06\x04\x89\x02\x02\n\x05\
    \x12\x04\xd66\x02\x06\n\x0e\n\x06\x04\x89\x02\x02\n\x01\x12\x04\xd66\x07\
    \x0f\n\x0e\n\x06\x04\x89\x02\x02\n\x03\x12\x04\xd66\x12\x14\n\xa1\x04\n\
    \x05\x04\x89\x02\x02\x0b\x12\x04\xe46\x02\x15\x1a\x91\x04\x20Searching\
    \x20options:\n\x20Specify\x20a\x20search\x20parameter\x20in\x20order\x20\
    to\x20perform\x20keyword\x20search\x20on\x20the\n\x20following\x20fields\
    \x20of\x20the\x20module:\n\x20\x20\x20-\x20id\n\x20\x20\x20-\x20descript\
    ion\n\x20\x20\x20-\x20user_id\x20(unless\x20user_app_id.user_id\x20is\
    \x20already\x20set)\n\n\x20Keywords\x20are\x20both\x20normalized\x20for\
    \x20search\x20(so\x20searching\x20for\x20\"satisfy\"\x20matches\x20\"sat\
    isfied\")\n\x20and\x20used\x20for\x20partial\x20prefix-matching\x20(so\
    \x20searching\x20for\x20\"clari\"\x20matches\x20\"clarifai\").\n\n\x20NO\
    TE:\x20Both\x20the\x20list\x20of\x20fields\x20searched\x20and\x20the\x20\
    exact\x20keyword\x20matching\n\x20rules\x20are\x20subject\x20to\x20chang\
    e\x20and\x20not\x20guaranteed\x20to\x20be\x20backwards-compatible.\n\n\
    \x0e\n\x06\x04\x89\x02\x02\x0b\x05\x12\x04\xe46\x02\x08\n\x0e\n\x06\x04\
    \x89\x02\x02\x0b\x01\x12\x04\xe46\t\x0f\n\x0e\n\x06\x04\x89\x02\x02\x0b\
    \x03\x12\x04\xe46\x12\x14\n\xaf\x01\n\x05\x04\x89\x02\x02\x0c\x12\x04\
    \xe76\x02'\x1a\x9f\x01\x20Filter\x20by\x20the\x20id\x20and\x20descriptio\
    n\x20of\x20the\x20module.\x20This\x20supports\x20wildcard\x20queries\x20\
    like\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20an\x20example.\n\
    \x20Deprecated:\x20use\x20search\x20instead.\n\n\x0e\n\x06\x04\x89\x02\
    \x02\x0c\x05\x12\x04\xe76\x02\x08\n\x0e\n\x06\x04\x89\x02\x02\x0c\x01\
    \x12\x04\xe76\t\r\n\x0e\n\x06\x04\x89\x02\x02\x0c\x03\x12\x04\xe76\x10\
    \x12\n\x0e\n\x06\x04\x89\x02\x02\x0c\x08\x12\x04\xe76\x13&\n\x0f\n\x07\
    \x04\x89\x02\x02\x0c\x08\x03\x12\x04\xe76\x14%\nv\n\x05\x04\x89\x02\x02\
    \r\x12\x04\xea6\x022\x1ag\x20Filter\x20by\x20the\x20application\x20owner\
    \x20whose\x20this\x20module\x20belongs\x20to\n\x20Deprecated:\x20use\x20\
    search\x20instead\x20of\x20name.\n\n\x0e\n\x06\x04\x89\x02\x02\r\x05\x12\
    \x04\xea6\x02\x06\n\x0e\n\x06\x04\x89\x02\x02\r\x01\x12\x04\xea6\x07\x18\
    \n\x0e\n\x06\x04\x89\x02\x02\r\x03\x12\x04\xea6\x1b\x1d\n\x0e\n\x06\x04\
    \x89\x02\x02\r\x08\x12\x04\xea6\x1e1\n\x0f\n\x07\x04\x89\x02\x02\r\x08\
    \x03\x12\x04\xea6\x1f0\n#\n\x03\x04\x8a\x02\x12\x06\xee6\0\xf26\x01\x1a\
    \x14\x20PostModulesRequest\n\n\x0c\n\x04\x04\x8a\x02\x01\x12\x04\xee6\
    \x08\x1a\n\r\n\x05\x04\x8a\x02\x02\0\x12\x04\xef6\x02,\n\x0e\n\x06\x04\
    \x8a\x02\x02\0\x06\x12\x04\xef6\x02\x1b\n\x0e\n\x06\x04\x8a\x02\x02\0\
    \x01\x12\x04\xef6\x1c'\n\x0e\n\x06\x04\x8a\x02\x02\0\x03\x12\x04\xef6*+\
    \nW\n\x05\x04\x8a\x02\x02\x01\x12\x04\xf16\x02\x1e\x1aH\x20This\x20allow\
    s\x20you\x20to\x20create\x20one\x20or\x20more\x20module\x20by\x20posting\
    \x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\x8a\x02\x02\x01\x04\x12\
    \x04\xf16\x02\n\n\x0e\n\x06\x04\x8a\x02\x02\x01\x06\x12\x04\xf16\x0b\x11\
    \n\x0e\n\x06\x04\x8a\x02\x02\x01\x01\x12\x04\xf16\x12\x19\n\x0e\n\x06\
    \x04\x8a\x02\x02\x01\x03\x12\x04\xf16\x1c\x1d\n$\n\x03\x04\x8b\x02\x12\
    \x06\xf56\0\xff6\x01\x1a\x15\x20PatchModulesRequest\n\n\x0c\n\x04\x04\
    \x8b\x02\x01\x12\x04\xf56\x08\x1b\n\r\n\x05\x04\x8b\x02\x02\0\x12\x04\
    \xf66\x02,\n\x0e\n\x06\x04\x8b\x02\x02\0\x06\x12\x04\xf66\x02\x1b\n\x0e\
    \n\x06\x04\x8b\x02\x02\0\x01\x12\x04\xf66\x1c'\n\x0e\n\x06\x04\x8b\x02\
    \x02\0\x03\x12\x04\xf66*+\n\r\n\x05\x04\x8b\x02\x02\x01\x12\x04\xf76\x02\
    \x1e\n\x0e\n\x06\x04\x8b\x02\x02\x01\x04\x12\x04\xf76\x02\n\n\x0e\n\x06\
    \x04\x8b\x02\x02\x01\x06\x12\x04\xf76\x0b\x11\n\x0e\n\x06\x04\x8b\x02\
    \x02\x01\x01\x12\x04\xf76\x12\x19\n\x0e\n\x06\x04\x8b\x02\x02\x01\x03\
    \x12\x04\xf76\x1c\x1d\n\x82\x02\n\x05\x04\x8b\x02\x02\x02\x12\x04\xfe6\
    \x02\x14\x1a\xf2\x01\x20The\x20action\x20to\x20perform\x20on\x20the\x20p\
    atched\x20objects\n\x20Supported\x20values:\x20'overwrite'\x20and\x20're\
    move'.\n\n\x20Note\x20that\x20'remove'\x20can\x20only\x20be\x20used\x20t\
    o\x20remove\x20the\x20module\x20image\x20by\x20setting\n\x20'image.url'\
    \x20in\x20the\x20request\x20to\x20the\x20current\x20value\x20returned\
    \x20for\x20that\x20module.\n\n\x0e\n\x06\x04\x8b\x02\x02\x02\x05\x12\x04\
    \xfe6\x02\x08\n\x0e\n\x06\x04\x8b\x02\x02\x02\x01\x12\x04\xfe6\t\x0f\n\
    \x0e\n\x06\x04\x8b\x02\x02\x02\x03\x12\x04\xfe6\x12\x13\nE\n\x03\x04\x8c\
    \x02\x12\x06\x827\0\x857\x01\x1a6\x20Request\x20to\x20delete\x20several\
    \x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\x8c\x02\
    \x01\x12\x04\x827\x08\x1c\n\r\n\x05\x04\x8c\x02\x02\0\x12\x04\x837\x02,\
    \n\x0e\n\x06\x04\x8c\x02\x02\0\x06\x12\x04\x837\x02\x1b\n\x0e\n\x06\x04\
    \x8c\x02\x02\0\x01\x12\x04\x837\x1c'\n\x0e\n\x06\x04\x8c\x02\x02\0\x03\
    \x12\x04\x837*+\n\r\n\x05\x04\x8c\x02\x02\x01\x12\x04\x847\x02\x1a\n\x0e\
    \n\x06\x04\x8c\x02\x02\x01\x04\x12\x04\x847\x02\n\n\x0e\n\x06\x04\x8c\
    \x02\x02\x01\x05\x12\x04\x847\x0b\x11\n\x0e\n\x06\x04\x8c\x02\x02\x01\
    \x01\x12\x04\x847\x12\x15\n\x0e\n\x06\x04\x8c\x02\x02\x01\x03\x12\x04\
    \x847\x18\x19\n%\n\x03\x04\x8d\x02\x12\x06\x887\0\x8b7\x01\x1a\x16\x20Si\
    ngleModuleResponse\n\n\x0c\n\x04\x04\x8d\x02\x01\x12\x04\x887\x08\x1c\n\
    \r\n\x05\x04\x8d\x02\x02\0\x12\x04\x897\x02(\n\x0e\n\x06\x04\x8d\x02\x02\
    \0\x06\x12\x04\x897\x02\x1c\n\x0e\n\x06\x04\x8d\x02\x02\0\x01\x12\x04\
    \x897\x1d#\n\x0e\n\x06\x04\x8d\x02\x02\0\x03\x12\x04\x897&'\n\r\n\x05\
    \x04\x8d\x02\x02\x01\x12\x04\x8a7\x02\x14\n\x0e\n\x06\x04\x8d\x02\x02\
    \x01\x06\x12\x04\x8a7\x02\x08\n\x0e\n\x06\x04\x8d\x02\x02\x01\x01\x12\
    \x04\x8a7\t\x0f\n\x0e\n\x06\x04\x8d\x02\x02\x01\x03\x12\x04\x8a7\x12\x13\
    \n$\n\x03\x04\x8e\x02\x12\x06\x8e7\0\x917\x01\x1a\x15\x20MultiModuleResp\
    onse\n\n\x0c\n\x04\x04\x8e\x02\x01\x12\x04\x8e7\x08\x1b\n\r\n\x05\x04\
    \x8e\x02\x02\0\x12\x04\x8f7\x02(\n\x0e\n\x06\x04\x8e\x02\x02\0\x06\x12\
    \x04\x8f7\x02\x1c\n\x0e\n\x06\x04\x8e\x02\x02\0\x01\x12\x04\x8f7\x1d#\n\
    \x0e\n\x06\x04\x8e\x02\x02\0\x03\x12\x04\x8f7&'\n\r\n\x05\x04\x8e\x02\
    \x02\x01\x12\x04\x907\x02M\n\x0e\n\x06\x04\x8e\x02\x02\x01\x04\x12\x04\
    \x907\x02\n\n\x0e\n\x06\x04\x8e\x02\x02\x01\x06\x12\x04\x907\x0b\x11\n\
    \x0e\n\x06\x04\x8e\x02\x02\x01\x01\x12\x04\x907\x12\x19\n\x0e\n\x06\x04\
    \x8e\x02\x02\x01\x03\x12\x04\x907\x1c\x1d\n\x0e\n\x06\x04\x8e\x02\x02\
    \x01\x08\x12\x04\x907\x1eL\n\x11\n\t\x04\x8e\x02\x02\x01\x08\xd0\x86\x03\
    \x12\x04\x907\x1fK\n;\n\x03\x04\x8f\x02\x12\x06\x947\0\x987\x01\x1a,\x20\
    request\x20for\x20different\x20endpoints\x20currently.\n\n\x0c\n\x04\x04\
    \x8f\x02\x01\x12\x04\x947\x08\x1f\n\r\n\x05\x04\x8f\x02\x02\0\x12\x04\
    \x957\x02,\n\x0e\n\x06\x04\x8f\x02\x02\0\x06\x12\x04\x957\x02\x1b\n\x0e\
    \n\x06\x04\x8f\x02\x02\0\x01\x12\x04\x957\x1c'\n\x0e\n\x06\x04\x8f\x02\
    \x02\0\x03\x12\x04\x957*+\n\r\n\x05\x04\x8f\x02\x02\x01\x12\x04\x967\x02\
    \x17\n\x0e\n\x06\x04\x8f\x02\x02\x01\x05\x12\x04\x967\x02\x08\n\x0e\n\
    \x06\x04\x8f\x02\x02\x01\x01\x12\x04\x967\t\x12\n\x0e\n\x06\x04\x8f\x02\
    \x02\x01\x03\x12\x04\x967\x15\x16\n\r\n\x05\x04\x8f\x02\x02\x02\x12\x04\
    \x977\x02\x1f\n\x0e\n\x06\x04\x8f\x02\x02\x02\x05\x12\x04\x977\x02\x08\n\
    \x0e\n\x06\x04\x8f\x02\x02\x02\x01\x12\x04\x977\t\x1a\n\x0e\n\x06\x04\
    \x8f\x02\x02\x02\x03\x12\x04\x977\x1d\x1e\n*\n\x03\x04\x90\x02\x12\x06\
    \x9b7\0\xa47\x01\x1a\x1b\x20ListModuleVersionsRequest\n\n\x0c\n\x04\x04\
    \x90\x02\x01\x12\x04\x9b7\x08!\n\r\n\x05\x04\x90\x02\x02\0\x12\x04\x9c7\
    \x02,\n\x0e\n\x06\x04\x90\x02\x02\0\x06\x12\x04\x9c7\x02\x1b\n\x0e\n\x06\
    \x04\x90\x02\x02\0\x01\x12\x04\x9c7\x1c'\n\x0e\n\x06\x04\x90\x02\x02\0\
    \x03\x12\x04\x9c7*+\n\r\n\x05\x04\x90\x02\x02\x01\x12\x04\x9d7\x02\x17\n\
    \x0e\n\x06\x04\x90\x02\x02\x01\x05\x12\x04\x9d7\x02\x08\n\x0e\n\x06\x04\
    \x90\x02\x02\x01\x01\x12\x04\x9d7\t\x12\n\x0e\n\x06\x04\x90\x02\x02\x01\
    \x03\x12\x04\x9d7\x15\x16\n\x7f\n\x05\x04\x90\x02\x02\x02\x12\x04\xa07\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x90\x02\x02\x02\
    \x05\x12\x04\xa07\x02\x08\n\x0e\n\x06\x04\x90\x02\x02\x02\x01\x12\x04\
    \xa07\t\r\n\x0e\n\x06\x04\x90\x02\x02\x02\x03\x12\x04\xa07\x10\x11\nv\n\
    \x05\x04\x90\x02\x02\x03\x12\x04\xa37\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\
    \n\x06\x04\x90\x02\x02\x03\x05\x12\x04\xa37\x02\x08\n\x0e\n\x06\x04\x90\
    \x02\x02\x03\x01\x12\x04\xa37\t\x11\n\x0e\n\x06\x04\x90\x02\x02\x03\x03\
    \x12\x04\xa37\x14\x15\n*\n\x03\x04\x91\x02\x12\x06\xa77\0\xac7\x01\x1a\
    \x1b\x20PostModuleVersionsRequest\n\n\x0c\n\x04\x04\x91\x02\x01\x12\x04\
    \xa77\x08!\n\r\n\x05\x04\x91\x02\x02\0\x12\x04\xa87\x02,\n\x0e\n\x06\x04\
    \x91\x02\x02\0\x06\x12\x04\xa87\x02\x1b\n\x0e\n\x06\x04\x91\x02\x02\0\
    \x01\x12\x04\xa87\x1c'\n\x0e\n\x06\x04\x91\x02\x02\0\x03\x12\x04\xa87*+\
    \n\r\n\x05\x04\x91\x02\x02\x01\x12\x04\xa97\x02\x17\n\x0e\n\x06\x04\x91\
    \x02\x02\x01\x05\x12\x04\xa97\x02\x08\n\x0e\n\x06\x04\x91\x02\x02\x01\
    \x01\x12\x04\xa97\t\x12\n\x0e\n\x06\x04\x91\x02\x02\x01\x03\x12\x04\xa97\
    \x15\x16\nW\n\x05\x04\x91\x02\x02\x02\x12\x04\xab7\x02-\x1aH\x20This\x20\
    allows\x20you\x20to\x20create\x20one\x20or\x20more\x20module\x20by\x20po\
    sting\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\x91\x02\x02\x02\x04\
    \x12\x04\xab7\x02\n\n\x0e\n\x06\x04\x91\x02\x02\x02\x06\x12\x04\xab7\x0b\
    \x18\n\x0e\n\x06\x04\x91\x02\x02\x02\x01\x12\x04\xab7\x19(\n\x0e\n\x06\
    \x04\x91\x02\x02\x02\x03\x12\x04\xab7+,\n+\n\x03\x04\x92\x02\x12\x06\xaf\
    7\0\xc17\x01\x1a\x1c\x20PatchModuleVersionsRequest\n\n\x0c\n\x04\x04\x92\
    \x02\x01\x12\x04\xaf7\x08\"\n\r\n\x05\x04\x92\x02\x02\0\x12\x04\xb07\x02\
    ,\n\x0e\n\x06\x04\x92\x02\x02\0\x06\x12\x04\xb07\x02\x1b\n\x0e\n\x06\x04\
    \x92\x02\x02\0\x01\x12\x04\xb07\x1c'\n\x0e\n\x06\x04\x92\x02\x02\0\x03\
    \x12\x04\xb07*+\n\r\n\x05\x04\x92\x02\x02\x01\x12\x04\xb17\x02\x17\n\x0e\
    \n\x06\x04\x92\x02\x02\x01\x05\x12\x04\xb17\x02\x08\n\x0e\n\x06\x04\x92\
    \x02\x02\x01\x01\x12\x04\xb17\t\x12\n\x0e\n\x06\x04\x92\x02\x02\x01\x03\
    \x12\x04\xb17\x15\x16\n\xc7\x02\n\x05\x04\x92\x02\x02\x02\x12\x04\xbd7\
    \x02-\x1a\xb7\x02\x20This\x20allows\x20you\x20to\x20modify\x20the\x20mod\
    ule\x20version\x20details.\n\x20##########\x20Supported\x20fields\x20###\
    #######\n\x20-\x20description\n\x20-\x20id\n\x20-\x20metadata.fields\n\
    \x20-\x20module_nav.module_sub_navs[].query_key\n\x20-\x20module_nav.mod\
    ule_sub_navs[].query_value\n\x20-\x20module_nav.module_sub_navs[].title\
    \n\x20-\x20module_nav.title\n\x20-\x20notes\n\x20-\x20visibility.gettabl\
    e\n\n\x0e\n\x06\x04\x92\x02\x02\x02\x04\x12\x04\xbd7\x02\n\n\x0e\n\x06\
    \x04\x92\x02\x02\x02\x06\x12\x04\xbd7\x0b\x18\n\x0e\n\x06\x04\x92\x02\
    \x02\x02\x01\x12\x04\xbd7\x19(\n\x0e\n\x06\x04\x92\x02\x02\x02\x03\x12\
    \x04\xbd7+,\ng\n\x05\x04\x92\x02\x02\x03\x12\x04\xc07\x02\x14\x1aX\x20Th\
    e\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\
    \x20now\x20only\x20action\x20'merge'\x20is\x20supported\n\n\x0e\n\x06\
    \x04\x92\x02\x02\x03\x05\x12\x04\xc07\x02\x08\n\x0e\n\x06\x04\x92\x02\
    \x02\x03\x01\x12\x04\xc07\t\x0f\n\x0e\n\x06\x04\x92\x02\x02\x03\x03\x12\
    \x04\xc07\x12\x13\nN\n\x03\x04\x93\x02\x12\x06\xc47\0\xc87\x01\x1a?\x20R\
    equest\x20to\x20delete\x20several\x20module\x20versions\x20by\x20the\x20\
    list\x20of\x20ids.\n\n\x0c\n\x04\x04\x93\x02\x01\x12\x04\xc47\x08#\n\r\n\
    \x05\x04\x93\x02\x02\0\x12\x04\xc57\x02,\n\x0e\n\x06\x04\x93\x02\x02\0\
    \x06\x12\x04\xc57\x02\x1b\n\x0e\n\x06\x04\x93\x02\x02\0\x01\x12\x04\xc57\
    \x1c'\n\x0e\n\x06\x04\x93\x02\x02\0\x03\x12\x04\xc57*+\n\r\n\x05\x04\x93\
    \x02\x02\x01\x12\x04\xc67\x02\x17\n\x0e\n\x06\x04\x93\x02\x02\x01\x05\
    \x12\x04\xc67\x02\x08\n\x0e\n\x06\x04\x93\x02\x02\x01\x01\x12\x04\xc67\t\
    \x12\n\x0e\n\x06\x04\x93\x02\x02\x01\x03\x12\x04\xc67\x15\x16\n\r\n\x05\
    \x04\x93\x02\x02\x02\x12\x04\xc77\x02\x1a\n\x0e\n\x06\x04\x93\x02\x02\
    \x02\x04\x12\x04\xc77\x02\n\n\x0e\n\x06\x04\x93\x02\x02\x02\x05\x12\x04\
    \xc77\x0b\x11\n\x0e\n\x06\x04\x93\x02\x02\x02\x01\x12\x04\xc77\x12\x15\n\
    \x0e\n\x06\x04\x93\x02\x02\x02\x03\x12\x04\xc77\x18\x19\na\n\x03\x04\x94\
    \x02\x12\x06\xcb7\0\xcf7\x01\x1aR\x20Request\x20to\x20get\x20the\x20numb\
    er\x20of\x20installations\x20(by\x20all\x20users)\x20for\x20the\x20modul\
    e\x20version\n\n\x0c\n\x04\x04\x94\x02\x01\x12\x04\xcb7\x08)\n\r\n\x05\
    \x04\x94\x02\x02\0\x12\x04\xcc7\x02,\n\x0e\n\x06\x04\x94\x02\x02\0\x06\
    \x12\x04\xcc7\x02\x1b\n\x0e\n\x06\x04\x94\x02\x02\0\x01\x12\x04\xcc7\x1c\
    '\n\x0e\n\x06\x04\x94\x02\x02\0\x03\x12\x04\xcc7*+\n\r\n\x05\x04\x94\x02\
    \x02\x01\x12\x04\xcd7\x02\x17\n\x0e\n\x06\x04\x94\x02\x02\x01\x05\x12\
    \x04\xcd7\x02\x08\n\x0e\n\x06\x04\x94\x02\x02\x01\x01\x12\x04\xcd7\t\x12\
    \n\x0e\n\x06\x04\x94\x02\x02\x01\x03\x12\x04\xcd7\x15\x16\n\r\n\x05\x04\
    \x94\x02\x02\x02\x12\x04\xce7\x02\x1f\n\x0e\n\x06\x04\x94\x02\x02\x02\
    \x05\x12\x04\xce7\x02\x08\n\x0e\n\x06\x04\x94\x02\x02\x02\x01\x12\x04\
    \xce7\t\x1a\n\x0e\n\x06\x04\x94\x02\x02\x02\x03\x12\x04\xce7\x1d\x1e\n,\
    \n\x03\x04\x95\x02\x12\x06\xd27\0\xd57\x01\x1a\x1d\x20SingleModuleVersio\
    nResponse\n\n\x0c\n\x04\x04\x95\x02\x01\x12\x04\xd27\x08#\n\r\n\x05\x04\
    \x95\x02\x02\0\x12\x04\xd37\x02(\n\x0e\n\x06\x04\x95\x02\x02\0\x06\x12\
    \x04\xd37\x02\x1c\n\x0e\n\x06\x04\x95\x02\x02\0\x01\x12\x04\xd37\x1d#\n\
    \x0e\n\x06\x04\x95\x02\x02\0\x03\x12\x04\xd37&'\n\r\n\x05\x04\x95\x02\
    \x02\x01\x12\x04\xd47\x02#\n\x0e\n\x06\x04\x95\x02\x02\x01\x06\x12\x04\
    \xd47\x02\x0f\n\x0e\n\x06\x04\x95\x02\x02\x01\x01\x12\x04\xd47\x10\x1e\n\
    \x0e\n\x06\x04\x95\x02\x02\x01\x03\x12\x04\xd47!\"\n+\n\x03\x04\x96\x02\
    \x12\x06\xd87\0\xdb7\x01\x1a\x1c\x20MultiModuleVersionResponse\n\n\x0c\n\
    \x04\x04\x96\x02\x01\x12\x04\xd87\x08\"\n\r\n\x05\x04\x96\x02\x02\0\x12\
    \x04\xd97\x02(\n\x0e\n\x06\x04\x96\x02\x02\0\x06\x12\x04\xd97\x02\x1c\n\
    \x0e\n\x06\x04\x96\x02\x02\0\x01\x12\x04\xd97\x1d#\n\x0e\n\x06\x04\x96\
    \x02\x02\0\x03\x12\x04\xd97&'\n\r\n\x05\x04\x96\x02\x02\x01\x12\x04\xda7\
    \x02\\\n\x0e\n\x06\x04\x96\x02\x02\x01\x04\x12\x04\xda7\x02\n\n\x0e\n\
    \x06\x04\x96\x02\x02\x01\x06\x12\x04\xda7\x0b\x18\n\x0e\n\x06\x04\x96\
    \x02\x02\x01\x01\x12\x04\xda7\x19(\n\x0e\n\x06\x04\x96\x02\x02\x01\x03\
    \x12\x04\xda7+,\n\x0e\n\x06\x04\x96\x02\x02\x01\x08\x12\x04\xda7-[\n\x11\
    \n\t\x04\x96\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xda7.Z\n6\n\x03\x04\x97\
    \x02\x12\x06\xde7\0\xe17\x01\x1a'\x20SingleModuleVersionUsageCountRespon\
    se\n\n\x0c\n\x04\x04\x97\x02\x01\x12\x04\xde7\x08-\n\r\n\x05\x04\x97\x02\
    \x02\0\x12\x04\xdf7\x02(\n\x0e\n\x06\x04\x97\x02\x02\0\x06\x12\x04\xdf7\
    \x02\x1c\n\x0e\n\x06\x04\x97\x02\x02\0\x01\x12\x04\xdf7\x1d#\n\x0e\n\x06\
    \x04\x97\x02\x02\0\x03\x12\x04\xdf7&'\n\r\n\x05\x04\x97\x02\x02\x01\x12\
    \x04\xe07\x02\x19\n\x0e\n\x06\x04\x97\x02\x02\x01\x05\x12\x04\xe07\x02\
    \x08\n\x0e\n\x06\x04\x97\x02\x02\x01\x01\x12\x04\xe07\t\x14\n\x0e\n\x06\
    \x04\x97\x02\x02\x01\x03\x12\x04\xe07\x17\x18\n1\n\x03\x04\x98\x02\x12\
    \x06\xe47\0\xe87\x01\x1a\"\x20GetInstalledModuleVersionRequest\n\n\x0c\n\
    \x04\x04\x98\x02\x01\x12\x04\xe47\x08(\n\r\n\x05\x04\x98\x02\x02\0\x12\
    \x04\xe57\x02,\n\x0e\n\x06\x04\x98\x02\x02\0\x06\x12\x04\xe57\x02\x1b\n\
    \x0e\n\x06\x04\x98\x02\x02\0\x01\x12\x04\xe57\x1c'\n\x0e\n\x06\x04\x98\
    \x02\x02\0\x03\x12\x04\xe57*+\n=\n\x05\x04\x98\x02\x02\x01\x12\x04\xe77\
    \x02)\x1a.\x20the\x20ID\x20to\x20get\x20of\x20the\x20install\x20module\
    \x20version.\n\n\x0e\n\x06\x04\x98\x02\x02\x01\x05\x12\x04\xe77\x02\x08\
    \n\x0e\n\x06\x04\x98\x02\x02\x01\x01\x12\x04\xe77\t$\n\x0e\n\x06\x04\x98\
    \x02\x02\x01\x03\x12\x04\xe77'(\n3\n\x03\x04\x99\x02\x12\x06\xeb7\0\xf37\
    \x01\x1a$\x20ListInstalledModuleVersionsRequest\n\n\x0c\n\x04\x04\x99\
    \x02\x01\x12\x04\xeb7\x08*\n\r\n\x05\x04\x99\x02\x02\0\x12\x04\xec7\x02,\
    \n\x0e\n\x06\x04\x99\x02\x02\0\x06\x12\x04\xec7\x02\x1b\n\x0e\n\x06\x04\
    \x99\x02\x02\0\x01\x12\x04\xec7\x1c'\n\x0e\n\x06\x04\x99\x02\x02\0\x03\
    \x12\x04\xec7*+\n\x7f\n\x05\x04\x99\x02\x02\x01\x12\x04\xef7\x02\x12\x1a\
    p\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Paginat\
    ion\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\
    \x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\x99\x02\x02\x01\x05\x12\x04\
    \xef7\x02\x08\n\x0e\n\x06\x04\x99\x02\x02\x01\x01\x12\x04\xef7\t\r\n\x0e\
    \n\x06\x04\x99\x02\x02\x01\x03\x12\x04\xef7\x10\x11\nv\n\x05\x04\x99\x02\
    \x02\x02\x12\x04\xf27\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20\
    The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x99\x02\
    \x02\x02\x05\x12\x04\xf27\x02\x08\n\x0e\n\x06\x04\x99\x02\x02\x02\x01\
    \x12\x04\xf27\t\x11\n\x0e\n\x06\x04\x99\x02\x02\x02\x03\x12\x04\xf27\x14\
    \x15\ng\n\x03\x04\x9a\x02\x12\x06\xf67\0\xfa7\x01\x1aX\x20PostInstalledM\
    oduleVersionsRequest\x20to\x20install\x20a\x20module\x20version\x20into\
    \x20the\x20app\x20in\x20the\x20URL\n\n\x0c\n\x04\x04\x9a\x02\x01\x12\x04\
    \xf67\x08*\n\r\n\x05\x04\x9a\x02\x02\0\x12\x04\xf77\x02,\n\x0e\n\x06\x04\
    \x9a\x02\x02\0\x06\x12\x04\xf77\x02\x1b\n\x0e\n\x06\x04\x9a\x02\x02\0\
    \x01\x12\x04\xf77\x1c'\n\x0e\n\x06\x04\x9a\x02\x02\0\x03\x12\x04\xf77*+\
    \nW\n\x05\x04\x9a\x02\x02\x01\x12\x04\xf97\x02@\x1aH\x20This\x20allows\
    \x20you\x20to\x20create\x20one\x20or\x20more\x20module\x20by\x20posting\
    \x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\x9a\x02\x02\x01\x04\x12\
    \x04\xf97\x02\n\n\x0e\n\x06\x04\x9a\x02\x02\x01\x06\x12\x04\xf97\x0b!\n\
    \x0e\n\x06\x04\x9a\x02\x02\x01\x01\x12\x04\xf97\";\n\x0e\n\x06\x04\x9a\
    \x02\x02\x01\x03\x12\x04\xf97>?\n{\n\x03\x04\x9b\x02\x12\x06\xfe7\0\x868\
    \x01\x1al\x20PostInstalledModuleVersionsKeyRequest\x20to\x20associate\
    \x20a\x20key\x20of\x20the\x20caller's\x20to\x20the\x20installed\x20modul\
    e\n\x20version.\n\n\x0c\n\x04\x04\x9b\x02\x01\x12\x04\xfe7\x08-\n\r\n\
    \x05\x04\x9b\x02\x02\0\x12\x04\xff7\x02,\n\x0e\n\x06\x04\x9b\x02\x02\0\
    \x06\x12\x04\xff7\x02\x1b\n\x0e\n\x06\x04\x9b\x02\x02\0\x01\x12\x04\xff7\
    \x1c'\n\x0e\n\x06\x04\x9b\x02\x02\0\x03\x12\x04\xff7*+\n\xf6\x02\n\x05\
    \x04\x9b\x02\x02\x01\x12\x04\x818\x02)\x1a.\x20the\x20ID\x20to\x20get\
    \x20of\x20the\x20install\x20module\x20version.\n\"\xb6\x02\x20Note(zeile\
    r):\x20we\x20don't\x20provide\x20a\x20key\x20to\x20create\x20since\x20it\
    's\x20always\x20deterministic.\n\x20we'll\x20create\x20a\x20PAT,\x20owne\
    d\x20by\x20the\x20caller\x20with\x20the\x20scopes\x20that\x20the\x20modu\
    le\x20requests.\n\x20in\x20the\x20future\x20if\x20we\x20want\x20we\x20ca\
    n\x20pass\x20in\x20a\x20Key\x20key\x20=\x203;\x20field\x20so\x20that\x20\
    the\x20caller\n\x20can\x20adjust\x20the\x20scopes,\x20but\x20for\x20now\
    \x20that\x20doesn't\x20seem\x20necessary.\n\n\x0e\n\x06\x04\x9b\x02\x02\
    \x01\x05\x12\x04\x818\x02\x08\n\x0e\n\x06\x04\x9b\x02\x02\x01\x01\x12\
    \x04\x818\t$\n\x0e\n\x06\x04\x9b\x02\x02\x01\x03\x12\x04\x818'(\nX\n\x03\
    \x04\x9c\x02\x12\x06\x898\0\x8c8\x01\x1aI\x20Request\x20to\x20delete\x20\
    several\x20installed\x20module\x20versions\x20by\x20the\x20list\x20of\
    \x20ids.\n\n\x0c\n\x04\x04\x9c\x02\x01\x12\x04\x898\x08,\n\r\n\x05\x04\
    \x9c\x02\x02\0\x12\x04\x8a8\x02,\n\x0e\n\x06\x04\x9c\x02\x02\0\x06\x12\
    \x04\x8a8\x02\x1b\n\x0e\n\x06\x04\x9c\x02\x02\0\x01\x12\x04\x8a8\x1c'\n\
    \x0e\n\x06\x04\x9c\x02\x02\0\x03\x12\x04\x8a8*+\n\r\n\x05\x04\x9c\x02\
    \x02\x01\x12\x04\x8b8\x02\x1a\n\x0e\n\x06\x04\x9c\x02\x02\x01\x04\x12\
    \x04\x8b8\x02\n\n\x0e\n\x06\x04\x9c\x02\x02\x01\x05\x12\x04\x8b8\x0b\x11\
    \n\x0e\n\x06\x04\x9c\x02\x02\x01\x01\x12\x04\x8b8\x12\x15\n\x0e\n\x06\
    \x04\x9c\x02\x02\x01\x03\x12\x04\x8b8\x18\x19\n5\n\x03\x04\x9d\x02\x12\
    \x06\x8f8\0\x928\x01\x1a&\x20SingleInstalledModuleVersionResponse\n\n\
    \x0c\n\x04\x04\x9d\x02\x01\x12\x04\x8f8\x08,\n\r\n\x05\x04\x9d\x02\x02\0\
    \x12\x04\x908\x02(\n\x0e\n\x06\x04\x9d\x02\x02\0\x06\x12\x04\x908\x02\
    \x1c\n\x0e\n\x06\x04\x9d\x02\x02\0\x01\x12\x04\x908\x1d#\n\x0e\n\x06\x04\
    \x9d\x02\x02\0\x03\x12\x04\x908&'\n\r\n\x05\x04\x9d\x02\x02\x01\x12\x04\
    \x918\x026\n\x0e\n\x06\x04\x9d\x02\x02\x01\x06\x12\x04\x918\x02\x18\n\
    \x0e\n\x06\x04\x9d\x02\x02\x01\x01\x12\x04\x918\x191\n\x0e\n\x06\x04\x9d\
    \x02\x02\x01\x03\x12\x04\x91845\n4\n\x03\x04\x9e\x02\x12\x06\x958\0\x988\
    \x01\x1a%\x20MultiInstalledModuleVersionResponse\n\n\x0c\n\x04\x04\x9e\
    \x02\x01\x12\x04\x958\x08+\n\r\n\x05\x04\x9e\x02\x02\0\x12\x04\x968\x02(\
    \n\x0e\n\x06\x04\x9e\x02\x02\0\x06\x12\x04\x968\x02\x1c\n\x0e\n\x06\x04\
    \x9e\x02\x02\0\x01\x12\x04\x968\x1d#\n\x0e\n\x06\x04\x9e\x02\x02\0\x03\
    \x12\x04\x968&'\n\r\n\x05\x04\x9e\x02\x02\x01\x12\x04\x978\x02o\n\x0e\n\
    \x06\x04\x9e\x02\x02\x01\x04\x12\x04\x978\x02\n\n\x0e\n\x06\x04\x9e\x02\
    \x02\x01\x06\x12\x04\x978\x0b!\n\x0e\n\x06\x04\x9e\x02\x02\x01\x01\x12\
    \x04\x978\";\n\x0e\n\x06\x04\x9e\x02\x02\x01\x03\x12\x04\x978>?\n\x0e\n\
    \x06\x04\x9e\x02\x02\x01\x08\x12\x04\x978@n\n\x11\n\t\x04\x9e\x02\x02\
    \x01\x08\xd0\x86\x03\x12\x04\x978Am\n/\n\x03\x04\x9f\x02\x12\x06\x9b8\0\
    \x9e8\x01\x1a\x20\x20ListNextTaskAssignmentsRequest\n\n\x0c\n\x04\x04\
    \x9f\x02\x01\x12\x04\x9b8\x08&\n\r\n\x05\x04\x9f\x02\x02\0\x12\x04\x9c8\
    \x02,\n\x0e\n\x06\x04\x9f\x02\x02\0\x06\x12\x04\x9c8\x02\x1b\n\x0e\n\x06\
    \x04\x9f\x02\x02\0\x01\x12\x04\x9c8\x1c'\n\x0e\n\x06\x04\x9f\x02\x02\0\
    \x03\x12\x04\x9c8*+\n\r\n\x05\x04\x9f\x02\x02\x01\x12\x04\x9d8\x02\x15\n\
    \x0e\n\x06\x04\x9f\x02\x02\x01\x05\x12\x04\x9d8\x02\x08\n\x0e\n\x06\x04\
    \x9f\x02\x02\x01\x01\x12\x04\x9d8\t\x10\n\x0e\n\x06\x04\x9f\x02\x02\x01\
    \x03\x12\x04\x9d8\x13\x14\n^\n\x03\x04\xa0\x02\x12\x06\xa18\0\xa58\x01\
    \x1aO\x20Request\x20to\x20perform\x20bulk\x20operations\x20on\x20a\x20li\
    st\x20of\x20inputs\x20based\x20on\x20input\x20source.\n\n\x0c\n\x04\x04\
    \xa0\x02\x01\x12\x04\xa18\x08!\n\r\n\x05\x04\xa0\x02\x02\0\x12\x04\xa28\
    \x02,\n\x0e\n\x06\x04\xa0\x02\x02\0\x06\x12\x04\xa28\x02\x1b\n\x0e\n\x06\
    \x04\xa0\x02\x02\0\x01\x12\x04\xa28\x1c'\n\x0e\n\x06\x04\xa0\x02\x02\0\
    \x03\x12\x04\xa28*+\nj\n\x05\x04\xa0\x02\x02\x01\x12\x04\xa48\x02:\x1a[\
    \x20List\x20of\x20bulk\x20operation(s)\x20to\x20be\x20performed\x20e.g\
    \x20bulk\x20update\x20metadata\x20or\x20tags\x20or\x20labels\x20etc.\n\n\
    \x0e\n\x06\x04\xa0\x02\x02\x01\x04\x12\x04\xa48\x02\n\n\x0e\n\x06\x04\
    \xa0\x02\x02\x01\x06\x12\x04\xa48\x0b%\n\x0e\n\x06\x04\xa0\x02\x02\x01\
    \x01\x12\x04\xa48&5\n\x0e\n\x06\x04\xa0\x02\x02\x01\x03\x12\x04\xa4889\n\
    9\n\x03\x04\xa1\x02\x12\x06\xa88\0\xb08\x01\x1a*\x20Request\x20to\x20lis\
    t\x20all\x20the\x20bulk\x20operations.\n\n\x0c\n\x04\x04\xa1\x02\x01\x12\
    \x04\xa88\x08!\n\r\n\x05\x04\xa1\x02\x02\0\x12\x04\xa98\x02,\n\x0e\n\x06\
    \x04\xa1\x02\x02\0\x06\x12\x04\xa98\x02\x1b\n\x0e\n\x06\x04\xa1\x02\x02\
    \0\x01\x12\x04\xa98\x1c'\n\x0e\n\x06\x04\xa1\x02\x02\0\x03\x12\x04\xa98*\
    +\n\x7f\n\x05\x04\xa1\x02\x02\x01\x12\x04\xac8\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xa1\x02\x02\x01\x05\x12\x04\xac8\x02\x08\
    \n\x0e\n\x06\x04\xa1\x02\x02\x01\x01\x12\x04\xac8\t\r\n\x0e\n\x06\x04\
    \xa1\x02\x02\x01\x03\x12\x04\xac8\x10\x11\nv\n\x05\x04\xa1\x02\x02\x02\
    \x12\x04\xaf8\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xa1\x02\x02\x02\
    \x05\x12\x04\xaf8\x02\x08\n\x0e\n\x06\x04\xa1\x02\x02\x02\x01\x12\x04\
    \xaf8\t\x11\n\x0e\n\x06\x04\xa1\x02\x02\x02\x03\x12\x04\xaf8\x14\x15\nF\
    \n\x03\x04\xa2\x02\x12\x06\xb38\0\xb78\x01\x1a7\x20Request\x20to\x20get\
    \x20the\x20details\x20of\x20a\x20bulk\x20operation\x20by\x20ID.\n\n\x0c\
    \n\x04\x04\xa2\x02\x01\x12\x04\xb38\x08\x1f\n\r\n\x05\x04\xa2\x02\x02\0\
    \x12\x04\xb48\x02,\n\x0e\n\x06\x04\xa2\x02\x02\0\x06\x12\x04\xb48\x02\
    \x1b\n\x0e\n\x06\x04\xa2\x02\x02\0\x01\x12\x04\xb48\x1c'\n\x0e\n\x06\x04\
    \xa2\x02\x02\0\x03\x12\x04\xb48*+\n&\n\x05\x04\xa2\x02\x02\x01\x12\x04\
    \xb68\x02\x10\x1a\x17\x20The\x20bulk\x20operation\x20id\n\n\x0e\n\x06\
    \x04\xa2\x02\x02\x01\x05\x12\x04\xb68\x02\x08\n\x0e\n\x06\x04\xa2\x02\
    \x02\x01\x01\x12\x04\xb68\t\x0b\n\x0e\n\x06\x04\xa2\x02\x02\x01\x03\x12\
    \x04\xb68\x0e\x0f\n4\n\x03\x04\xa3\x02\x12\x06\xba8\0\xbe8\x01\x1a%\x20C\
    ancel\x20a\x20list\x20of\x20bulk\x20operation\x20ids\n\n\x0c\n\x04\x04\
    \xa3\x02\x01\x12\x04\xba8\x08\"\n\r\n\x05\x04\xa3\x02\x02\0\x12\x04\xbb8\
    \x02,\n\x0e\n\x06\x04\xa3\x02\x02\0\x06\x12\x04\xbb8\x02\x1b\n\x0e\n\x06\
    \x04\xa3\x02\x02\0\x01\x12\x04\xbb8\x1c'\n\x0e\n\x06\x04\xa3\x02\x02\0\
    \x03\x12\x04\xbb8*+\n;\n\x05\x04\xa3\x02\x02\x01\x12\x04\xbd8\x02\x1a\
    \x1a,\x20List\x20of\x20bulk\x20operation\x20ids\x20to\x20be\x20cancelled\
    \n\n\x0e\n\x06\x04\xa3\x02\x02\x01\x04\x12\x04\xbd8\x02\n\n\x0e\n\x06\
    \x04\xa3\x02\x02\x01\x05\x12\x04\xbd8\x0b\x11\n\x0e\n\x06\x04\xa3\x02\
    \x02\x01\x01\x12\x04\xbd8\x12\x15\n\x0e\n\x06\x04\xa3\x02\x02\x01\x03\
    \x12\x04\xbd8\x18\x19\n|\n\x03\x04\xa4\x02\x12\x06\xc28\0\xc68\x01\x1am\
    \x20Request\x20to\x20delete\x20the\x20terminated\x20bulk\x20operations\
    \x20by\x20ID\n\x20Only\x20operations\x20in\x20terminated\x20state\x20can\
    \x20be\x20deleted.\n\n\x0c\n\x04\x04\xa4\x02\x01\x12\x04\xc28\x08\"\n\r\
    \n\x05\x04\xa4\x02\x02\0\x12\x04\xc38\x02,\n\x0e\n\x06\x04\xa4\x02\x02\0\
    \x06\x12\x04\xc38\x02\x1b\n\x0e\n\x06\x04\xa4\x02\x02\0\x01\x12\x04\xc38\
    \x1c'\n\x0e\n\x06\x04\xa4\x02\x02\0\x03\x12\x04\xc38*+\n9\n\x05\x04\xa4\
    \x02\x02\x01\x12\x04\xc58\x02\x1a\x1a*\x20List\x20of\x20bulk\x20operatio\
    n\x20ids\x20to\x20be\x20deleted\n\n\x0e\n\x06\x04\xa4\x02\x02\x01\x04\
    \x12\x04\xc58\x02\n\n\x0e\n\x06\x04\xa4\x02\x02\x01\x05\x12\x04\xc58\x0b\
    \x11\n\x0e\n\x06\x04\xa4\x02\x02\x01\x01\x12\x04\xc58\x12\x15\n\x0e\n\
    \x06\x04\xa4\x02\x02\x01\x03\x12\x04\xc58\x18\x19\n-\n\x03\x04\xa5\x02\
    \x12\x06\xc98\0\xcc8\x01\x1a\x1e\x20SingleBulkOperationsResponse\n\n\x0c\
    \n\x04\x04\xa5\x02\x01\x12\x04\xc98\x08$\n\r\n\x05\x04\xa5\x02\x02\0\x12\
    \x04\xca8\x02(\n\x0e\n\x06\x04\xa5\x02\x02\0\x06\x12\x04\xca8\x02\x1c\n\
    \x0e\n\x06\x04\xa5\x02\x02\0\x01\x12\x04\xca8\x1d#\n\x0e\n\x06\x04\xa5\
    \x02\x02\0\x03\x12\x04\xca8&'\n\r\n\x05\x04\xa5\x02\x02\x01\x12\x04\xcb8\
    \x020\n\x0e\n\x06\x04\xa5\x02\x02\x01\x06\x12\x04\xcb8\x02\x1c\n\x0e\n\
    \x06\x04\xa5\x02\x02\x01\x01\x12\x04\xcb8\x1d+\n\x0e\n\x06\x04\xa5\x02\
    \x02\x01\x03\x12\x04\xcb8./\n,\n\x03\x04\xa6\x02\x12\x06\xcf8\0\xd28\x01\
    \x1a\x1d\x20MultiBulkOperationsResponse\n\n\x0c\n\x04\x04\xa6\x02\x01\
    \x12\x04\xcf8\x08#\n\r\n\x05\x04\xa6\x02\x02\0\x12\x04\xd08\x02(\n\x0e\n\
    \x06\x04\xa6\x02\x02\0\x06\x12\x04\xd08\x02\x1c\n\x0e\n\x06\x04\xa6\x02\
    \x02\0\x01\x12\x04\xd08\x1d#\n\x0e\n\x06\x04\xa6\x02\x02\0\x03\x12\x04\
    \xd08&'\n\r\n\x05\x04\xa6\x02\x02\x01\x12\x04\xd18\x029\n\x0e\n\x06\x04\
    \xa6\x02\x02\x01\x04\x12\x04\xd18\x02\n\n\x0e\n\x06\x04\xa6\x02\x02\x01\
    \x06\x12\x04\xd18\x0b%\n\x0e\n\x06\x04\xa6\x02\x02\x01\x01\x12\x04\xd18&\
    4\n\x0e\n\x06\x04\xa6\x02\x02\x01\x03\x12\x04\xd1878\n*\n\x03\x04\xa7\
    \x02\x12\x06\xd98\0\xed8\x01\x1a\x1b\x20PutTaskAssignmentsRequest\n\n\
    \x0c\n\x04\x04\xa7\x02\x01\x12\x04\xd98\x08!\n\r\n\x05\x04\xa7\x02\x02\0\
    \x12\x04\xda8\x02,\n\x0e\n\x06\x04\xa7\x02\x02\0\x06\x12\x04\xda8\x02\
    \x1b\n\x0e\n\x06\x04\xa7\x02\x02\0\x01\x12\x04\xda8\x1c'\n\x0e\n\x06\x04\
    \xa7\x02\x02\0\x03\x12\x04\xda8*+\n\r\n\x05\x04\xa7\x02\x02\x01\x12\x04\
    \xdc8\x02\x15\n\x0e\n\x06\x04\xa7\x02\x02\x01\x05\x12\x04\xdc8\x02\x08\n\
    \x0e\n\x06\x04\xa7\x02\x02\x01\x01\x12\x04\xdc8\t\x10\n\x0e\n\x06\x04\
    \xa7\x02\x02\x01\x03\x12\x04\xdc8\x13\x14\n\x88\x02\n\x05\x04\xa7\x02\
    \x02\x02\x12\x04\xe28\x02\x16\x1a\xf8\x01\x20Deprecated:\x20use\x20actio\
    n\x20and\x20action_config\x20instead.\n\x20Supported\x20for\x20backwards\
    \x20compatibility:\x20setting\x20this\x20field\x20is\x20equivalent\x20wi\
    th\n\x20*\x20action\x20=\x20LABEL_SUBMIT\n\x20*\x20label_submit_config\
    \x20=\x20[{\"task_assignments\":\x20{{\"id\":\x20\"<task-assignment-id-f\
    or-input-id>\"}}]\n\n\x0e\n\x06\x04\xa7\x02\x02\x02\x05\x12\x04\xe28\x02\
    \x08\n\x0e\n\x06\x04\xa7\x02\x02\x02\x01\x12\x04\xe28\t\x11\n\x0e\n\x06\
    \x04\xa7\x02\x02\x02\x03\x12\x04\xe28\x14\x15\n4\n\x05\x04\xa7\x02\x02\
    \x03\x12\x04\xe58\x02-\x1a%\x20Action\x20to\x20perform\x20on\x20selected\
    \x20task.\n\n\x0e\n\x06\x04\xa7\x02\x02\x03\x06\x12\x04\xe58\x02!\n\x0e\
    \n\x06\x04\xa7\x02\x02\x03\x01\x12\x04\xe58\"(\n\x0e\n\x06\x04\xa7\x02\
    \x02\x03\x03\x12\x04\xe58+,\n\x0f\n\x05\x04\xa7\x02\x08\0\x12\x06\xe78\
    \x02\xec8\x03\n\x0e\n\x06\x04\xa7\x02\x08\0\x01\x12\x04\xe78\x08\x15\n\r\
    \n\x05\x04\xa7\x02\x02\x04\x12\x04\xe88\x04.\n\x0e\n\x06\x04\xa7\x02\x02\
    \x04\x06\x12\x04\xe88\x04\x15\n\x0e\n\x06\x04\xa7\x02\x02\x04\x01\x12\
    \x04\xe88\x16)\n\x0e\n\x06\x04\xa7\x02\x02\x04\x03\x12\x04\xe88,-\n\r\n\
    \x05\x04\xa7\x02\x02\x05\x12\x04\xe98\x042\n\x0e\n\x06\x04\xa7\x02\x02\
    \x05\x06\x12\x04\xe98\x04\x17\n\x0e\n\x06\x04\xa7\x02\x02\x05\x01\x12\
    \x04\xe98\x18-\n\x0e\n\x06\x04\xa7\x02\x02\x05\x03\x12\x04\xe9801\n\r\n\
    \x05\x04\xa7\x02\x02\x06\x12\x04\xea8\x04A\n\x0e\n\x06\x04\xa7\x02\x02\
    \x06\x06\x12\x04\xea8\x04\x1e\n\x0e\n\x06\x04\xa7\x02\x02\x06\x01\x12\
    \x04\xea8\x1f<\n\x0e\n\x06\x04\xa7\x02\x02\x06\x03\x12\x04\xea8?@\n\r\n\
    \x05\x04\xa7\x02\x02\x07\x12\x04\xeb8\x040\n\x0e\n\x06\x04\xa7\x02\x02\
    \x07\x06\x12\x04\xeb8\x04\x16\n\x0e\n\x06\x04\xa7\x02\x02\x07\x01\x12\
    \x04\xeb8\x17+\n\x0e\n\x06\x04\xa7\x02\x02\x07\x03\x12\x04\xeb8./\n\x0c\
    \n\x02\x05\x01\x12\x06\xee8\0\xa89\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\
    \xee8\x05$\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xef8\x022\n\r\n\x05\x05\x01\
    \x02\0\x01\x12\x04\xef8\x02-\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xef801\
    \n\xd1\x01\n\x04\x05\x01\x02\x01\x12\x04\xf48\x02\x12\x1a\xc2\x01\x20Cre\
    ate\x20a\x20list\x20of\x20task\x20assignments\x20for\x20labeler\x20=>\
    \x2010\x20inputs\x20are\x20assigned\x20to\x20the\x20labeler.\n\x20This\
    \x20is\x20a\x20fully\x20sync\x20action.\n\x20If\x20task\x20assignments\
    \x20already\x20exist,\x20then\x20return\x20existing\x20task\x20assignmen\
    ts.\n\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xf48\x02\r\n\r\n\x05\x05\x01\
    \x02\x01\x02\x12\x04\xf48\x10\x11\n\xb9\x07\n\x04\x05\x01\x02\x02\x12\
    \x04\x819\x02\x13\x1a\xaa\x07\x20Submit\x20task\x20assignments\x20=>\x20\
    mark\x20task\x20assignment\x20work\x20as\x20completed.\n\x20This\x20is\
    \x20a\x20partially\x20sync\x20action.\n\x20Sync:\x20task\x20assignments\
    \x20are\x20updated\x20as\x20follows:\n\x20*\x20when\x20review_strategy\
    \x20is\x20NONE,\x20then\x20task\x20assignment\x20status\x20is\x20updated\
    \x20to\x20SUCCESS.\n\x20*\x20when\x20review\x20strategy\x20is\x20CONSENS\
    US,\x20then\x20task\x20assignment\x20status\x20is\x20updated\x20to\x20AW\
    AITING_CONSENSUS_REVIEW.\n\x20*\x20when\x20review\x20strategy\x20is\x20M\
    ANUAL,\x20then\x20task\x20assignment\x20status\x20is\x20updated\x20to\
    \x20AWAITING_REVIEW.\n\x20If\x20task\x20assignments\x20are\x20already\
    \x20submitted,\x20then\x20no\x20update\x20is\x20performed\x20on\x20them.\
    \n\x20Async:\x20annotations\x20added\x20for\x20the\x20same\x20input\x20a\
    s\x20the\x20task\x20assignment\x20are\x20updated\x20as\x20follows:\n\x20\
    *\x20when\x20review_strategy\x20is\x20NONE,\x20then\x20annotation\x20sta\
    tus\x20is\x20updated\x20to\x20SUCCESS.\n\x20*\x20when\x20review\x20strat\
    egy\x20is\x20CONSENSUS,\x20then\x20annotation\x20status\x20is\x20updated\
    \x20to\x20SUCCESS\x20(if\x20it\x20reaches\x20consensus)\x20or\x20AWAITIN\
    G_REVIEW\x20(if\x20it\x20does\x20not\x20reach\x20consensus).\n\x20*\x20w\
    hen\x20review\x20strategy\x20is\x20MANUAL,\x20then\x20annotation\x20stat\
    us\x20is\x20updated\x20to\x20AWAITING_REVIEW.\n\n\r\n\x05\x05\x01\x02\
    \x02\x01\x12\x04\x819\x02\x0e\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\x819\
    \x11\x12\n\x9b\x05\n\x04\x05\x01\x02\x03\x12\x04\x8c9\x02\x14\x1a\x8c\
    \x05\x20Return\x20a\x20list\x20of\x20task\x20assignments\x20for\x20revie\
    wer\x20to\x20review\x20=>\x2010\x20inputs\x20are\x20assigned\x20to\x20th\
    e\x20reviewer.\n\x20This\x20is\x20a\x20fully\x20sync\x20action.\n\x20NOT\
    \x20idempotent:\n\x20\x20In\x20the\x20current\x20implementation,\x20we\
    \x20don't\x20actually\x20store\x20the\x20reviewer\x20in\x20the\x20task\
    \x20assignment,\n\x20\x20as\x20the\x20task\x20assignment\x20still\x20sta\
    ys\x20assigned\x20to\x20the\x20labeler.\n\x20\x20Therefore,\x20multiple\
    \x20calls\x20to\x20this\x20endpoint\x20may\x20result\x20in\x20different\
    \x20set\x20of\x20task\x20assignments\x20to\x20review.\n\x20\x20For\x20no\
    w,\x20this\x20action\x20is\x20practically\x20not\x20idempotent.\n\x20\
    \x20In\x20the\x20future,\x20we\x20could\x20however\x20store\x20the\x20re\
    viewer\x20in\x20the\x20task\x20assignment\x20and\n\x20\x20return\x20exis\
    ting\x20task\x20assignments\x20already\x20assigned\x20to\x20the\x20revie\
    wer\x20=>\x20this\x20will\x20make\x20this\x20action\x20idempotent.\n\n\r\
    \n\x05\x05\x01\x02\x03\x01\x12\x04\x8c9\x02\x0e\n\r\n\x05\x05\x01\x02\
    \x03\x02\x12\x04\x8c9\x11\x13\n\xfd\x02\n\x04\x05\x01\x02\x04\x12\x04\
    \x959\x02\x16\x1a\xee\x02\x20Approve\x20task\x20assignments.\n\x20There\
    \x20are\x20two\x20types\x20of\x20configurations:\n\x20*\x20Batch\x20appr\
    ove:\x20approve\x20a\x20list\x20of\x20task\x20assignment\x20IDs;\n\x20*\
    \x20Bulk\x20approve:\x20approve\x20all\x20task\x20assignments\x20from\
    \x20a\x20list\x20of\x20workers.\n\x20This\x20is\x20a\x20partially\x20syn\
    c\x20action.\n\x20Sync:\x20task\x20assignments\x20are\x20updated\x20to\
    \x20SUCCESS\n\x20Async:\x20annotations\x20added\x20for\x20the\x20same\
    \x20input\x20as\x20the\x20task\x20assignment\x20are\x20updated\x20to\x20\
    SUCCESS\n\n\r\n\x05\x05\x01\x02\x04\x01\x12\x04\x959\x02\x10\n\r\n\x05\
    \x05\x01\x02\x04\x02\x12\x04\x959\x13\x15\n\xb1\x03\n\x04\x05\x01\x02\
    \x05\x12\x04\x9e9\x02\x1e\x1a\xa2\x03\x20Request\x20changes\x20for\x20ta\
    sk\x20assignments.\n\x20There\x20are\x20two\x20types\x20of\x20configurat\
    ions:\n\x20*\x20Batch\x20request\x20changes:\x20request\x20changes\x20fo\
    r\x20a\x20list\x20of\x20task\x20assignment\x20IDs;\n\x20*\x20Bulk\x20req\
    uest\x20changes:\x20request\x20changes\x20for\x20all\x20task\x20assignme\
    nts\x20from\x20a\x20list\x20of\x20workers.\n\x20This\x20is\x20a\x20parti\
    ally\x20sync\x20action.\n\x20Sync:\x20task\x20assignments\x20are\x20upda\
    ted\x20to\x20PENDING\n\x20Async:\x20annotations\x20added\x20for\x20the\
    \x20same\x20input\x20as\x20the\x20task\x20assignment\x20are\x20updated\
    \x20to\x20PENDING\n\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\x9e9\x02\x18\n\
    \r\n\x05\x05\x01\x02\x05\x02\x12\x04\x9e9\x1b\x1d\n\x84\x03\n\x04\x05\
    \x01\x02\x06\x12\x04\xa79\x02\x15\x1a\xf5\x02\x20Reject\x20task\x20assig\
    nments.\n\x20There\x20are\x20two\x20types\x20of\x20configurations:\n\x20\
    *\x20Batch\x20reject:\x20reject\x20a\x20list\x20of\x20task\x20assignment\
    \x20IDs;\n\x20*\x20Bulk\x20reject:\x20reject\x20all\x20task\x20assignmen\
    ts\x20from\x20a\x20list\x20of\x20workers.\n\x20This\x20is\x20a\x20partia\
    lly\x20sync\x20action.\n\x20Sync:\x20task\x20assignments\x20are\x20updat\
    ed\x20to\x20REVIEW_DENIED\n\x20Async:\x20annotations\x20added\x20for\x20\
    the\x20same\x20input\x20as\x20the\x20task\x20assignment\x20are\x20update\
    d\x20to\x20REVIEW_DENIED\n\n\r\n\x05\x05\x01\x02\x06\x01\x12\x04\xa79\
    \x02\x0f\n\r\n\x05\x05\x01\x02\x06\x02\x12\x04\xa79\x12\x14\n\r\n\x03\
    \x04\xa8\x02\x12\x06\xab9\0\xad9\x01\n\x0c\n\x04\x04\xa8\x02\x01\x12\x04\
    \xab9\x08\x19\n\r\n\x05\x04\xa8\x02\x02\0\x12\x04\xac9\x02/\n\x0e\n\x06\
    \x04\xa8\x02\x02\0\x04\x12\x04\xac9\x02\n\n\x0e\n\x06\x04\xa8\x02\x02\0\
    \x06\x12\x04\xac9\x0b\x19\n\x0e\n\x06\x04\xa8\x02\x02\0\x01\x12\x04\xac9\
    \x1a*\n\x0e\n\x06\x04\xa8\x02\x02\0\x03\x12\x04\xac9-.\n\r\n\x03\x04\xa9\
    \x02\x12\x06\xaf9\0\xb29\x01\n\x0c\n\x04\x04\xa9\x02\x01\x12\x04\xaf9\
    \x08\x1b\n\r\n\x05\x04\xa9\x02\x02\0\x12\x04\xb09\x02/\n\x0e\n\x06\x04\
    \xa9\x02\x02\0\x04\x12\x04\xb09\x02\n\n\x0e\n\x06\x04\xa9\x02\x02\0\x06\
    \x12\x04\xb09\x0b\x19\n\x0e\n\x06\x04\xa9\x02\x02\0\x01\x12\x04\xb09\x1a\
    *\n\x0e\n\x06\x04\xa9\x02\x02\0\x03\x12\x04\xb09-.\n\r\n\x05\x04\xa9\x02\
    \x02\x01\x12\x04\xb19\x02\x1e\n\x0e\n\x06\x04\xa9\x02\x02\x01\x04\x12\
    \x04\xb19\x02\n\n\x0e\n\x06\x04\xa9\x02\x02\x01\x06\x12\x04\xb19\x0b\x11\
    \n\x0e\n\x06\x04\xa9\x02\x02\x01\x01\x12\x04\xb19\x12\x19\n\x0e\n\x06\
    \x04\xa9\x02\x02\x01\x03\x12\x04\xb19\x1c\x1d\n\r\n\x03\x04\xaa\x02\x12\
    \x06\xb49\0\xb79\x01\n\x0c\n\x04\x04\xaa\x02\x01\x12\x04\xb49\x08\"\n\r\
    \n\x05\x04\xaa\x02\x02\0\x12\x04\xb59\x02/\n\x0e\n\x06\x04\xaa\x02\x02\0\
    \x04\x12\x04\xb59\x02\n\n\x0e\n\x06\x04\xaa\x02\x02\0\x06\x12\x04\xb59\
    \x0b\x19\n\x0e\n\x06\x04\xaa\x02\x02\0\x01\x12\x04\xb59\x1a*\n\x0e\n\x06\
    \x04\xaa\x02\x02\0\x03\x12\x04\xb59-.\n\r\n\x05\x04\xaa\x02\x02\x01\x12\
    \x04\xb69\x02\x1e\n\x0e\n\x06\x04\xaa\x02\x02\x01\x04\x12\x04\xb69\x02\n\
    \n\x0e\n\x06\x04\xaa\x02\x02\x01\x06\x12\x04\xb69\x0b\x11\n\x0e\n\x06\
    \x04\xaa\x02\x02\x01\x01\x12\x04\xb69\x12\x19\n\x0e\n\x06\x04\xaa\x02\
    \x02\x01\x03\x12\x04\xb69\x1c\x1d\n\r\n\x03\x04\xab\x02\x12\x06\xb99\0\
    \xbc9\x01\n\x0c\n\x04\x04\xab\x02\x01\x12\x04\xb99\x08\x1a\n\r\n\x05\x04\
    \xab\x02\x02\0\x12\x04\xba9\x02/\n\x0e\n\x06\x04\xab\x02\x02\0\x04\x12\
    \x04\xba9\x02\n\n\x0e\n\x06\x04\xab\x02\x02\0\x06\x12\x04\xba9\x0b\x19\n\
    \x0e\n\x06\x04\xab\x02\x02\0\x01\x12\x04\xba9\x1a*\n\x0e\n\x06\x04\xab\
    \x02\x02\0\x03\x12\x04\xba9-.\n\r\n\x05\x04\xab\x02\x02\x01\x12\x04\xbb9\
    \x02\x1e\n\x0e\n\x06\x04\xab\x02\x02\x01\x04\x12\x04\xbb9\x02\n\n\x0e\n\
    \x06\x04\xab\x02\x02\x01\x06\x12\x04\xbb9\x0b\x11\n\x0e\n\x06\x04\xab\
    \x02\x02\x01\x01\x12\x04\xbb9\x12\x19\n\x0e\n\x06\x04\xab\x02\x02\x01\
    \x03\x12\x04\xbb9\x1c\x1d\n\r\n\x03\x04\xac\x02\x12\x06\xbe9\0\xc19\x01\
    \n\x0c\n\x04\x04\xac\x02\x01\x12\x04\xbe9\x08#\n\r\n\x05\x04\xac\x02\x02\
    \0\x12\x04\xbf9\x02(\n\x0e\n\x06\x04\xac\x02\x02\0\x06\x12\x04\xbf9\x02\
    \x1c\n\x0e\n\x06\x04\xac\x02\x02\0\x01\x12\x04\xbf9\x1d#\n\x0e\n\x06\x04\
    \xac\x02\x02\0\x03\x12\x04\xbf9&'\n\r\n\x05\x04\xac\x02\x02\x01\x12\x04\
    \xc09\x02^\n\x0e\n\x06\x04\xac\x02\x02\x01\x04\x12\x04\xc09\x02\n\n\x0e\
    \n\x06\x04\xac\x02\x02\x01\x06\x12\x04\xc09\x0b\x19\n\x0e\n\x06\x04\xac\
    \x02\x02\x01\x01\x12\x04\xc09\x1a*\n\x0e\n\x06\x04\xac\x02\x02\x01\x03\
    \x12\x04\xc09-.\n\x0e\n\x06\x04\xac\x02\x02\x01\x08\x12\x04\xc09/]\n\x11\
    \n\t\x04\xac\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xc090\\\n2\n\x03\x04\
    \xad\x02\x12\x06\xc99\0\xd19\x01\x1a#\x20List\x20all\x20the\x20input\x20\
    ingestion\x20jobs\n\n\x0c\n\x04\x04\xad\x02\x01\x12\x04\xc99\x08\x20\n\r\
    \n\x05\x04\xad\x02\x02\0\x12\x04\xca9\x02,\n\x0e\n\x06\x04\xad\x02\x02\0\
    \x06\x12\x04\xca9\x02\x1b\n\x0e\n\x06\x04\xad\x02\x02\0\x01\x12\x04\xca9\
    \x1c'\n\x0e\n\x06\x04\xad\x02\x02\0\x03\x12\x04\xca9*+\n\x7f\n\x05\x04\
    \xad\x02\x02\x01\x12\x04\xcd9\x02\x12\x1ap\x20(optional\x20URL\x20parame\
    ter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spli\
    t\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\xad\x02\x02\x01\x05\x12\x04\xcd9\x02\x08\n\x0e\n\x06\x04\xad\
    \x02\x02\x01\x01\x12\x04\xcd9\t\r\n\x0e\n\x06\x04\xad\x02\x02\x01\x03\
    \x12\x04\xcd9\x10\x11\nv\n\x05\x04\xad\x02\x02\x02\x12\x04\xd09\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\x0e\n\x06\x04\xad\x02\x02\x02\x05\x12\x04\xd09\x02\
    \x08\n\x0e\n\x06\x04\xad\x02\x02\x02\x01\x12\x04\xd09\t\x11\n\x0e\n\x06\
    \x04\xad\x02\x02\x02\x03\x12\x04\xd09\x14\x15\n\r\n\x03\x04\xae\x02\x12\
    \x06\xd39\0\xd79\x01\n\x0c\n\x04\x04\xae\x02\x01\x12\x04\xd39\x08\x1e\n\
    \r\n\x05\x04\xae\x02\x02\0\x12\x04\xd49\x02,\n\x0e\n\x06\x04\xae\x02\x02\
    \0\x06\x12\x04\xd49\x02\x1b\n\x0e\n\x06\x04\xae\x02\x02\0\x01\x12\x04\
    \xd49\x1c'\n\x0e\n\x06\x04\xae\x02\x02\0\x03\x12\x04\xd49*+\n%\n\x05\x04\
    \xae\x02\x02\x01\x12\x04\xd69\x02\x10\x1a\x16\x20id\x20of\x20add\x20inpu\
    ts\x20job\n\n\x0e\n\x06\x04\xae\x02\x02\x01\x05\x12\x04\xd69\x02\x08\n\
    \x0e\n\x06\x04\xae\x02\x02\x01\x01\x12\x04\xd69\t\x0b\n\x0e\n\x06\x04\
    \xae\x02\x02\x01\x03\x12\x04\xd69\x0e\x0f\n\r\n\x03\x04\xaf\x02\x12\x06\
    \xd99\0\xdd9\x01\n\x0c\n\x04\x04\xaf\x02\x01\x12\x04\xd99\x08!\n\r\n\x05\
    \x04\xaf\x02\x02\0\x12\x04\xda9\x02,\n\x0e\n\x06\x04\xaf\x02\x02\0\x06\
    \x12\x04\xda9\x02\x1b\n\x0e\n\x06\x04\xaf\x02\x02\0\x01\x12\x04\xda9\x1c\
    '\n\x0e\n\x06\x04\xaf\x02\x02\0\x03\x12\x04\xda9*+\n5\n\x05\x04\xaf\x02\
    \x02\x01\x12\x04\xdc9\x02\x10\x1a&\x20id\x20of\x20add\x20inputs\x20job\
    \x20to\x20be\x20cancelled\n\n\x0e\n\x06\x04\xaf\x02\x02\x01\x05\x12\x04\
    \xdc9\x02\x08\n\x0e\n\x06\x04\xaf\x02\x02\x01\x01\x12\x04\xdc9\t\x0b\n\
    \x0e\n\x06\x04\xaf\x02\x02\x01\x03\x12\x04\xdc9\x0e\x0f\n*\n\x03\x04\xb0\
    \x02\x12\x06\xe09\0\xe39\x01\x1a\x1b\x20MultiInputsAddJobResponse\n\n\
    \x0c\n\x04\x04\xb0\x02\x01\x12\x04\xe09\x08!\n\r\n\x05\x04\xb0\x02\x02\0\
    \x12\x04\xe19\x02(\n\x0e\n\x06\x04\xb0\x02\x02\0\x06\x12\x04\xe19\x02\
    \x1c\n\x0e\n\x06\x04\xb0\x02\x02\0\x01\x12\x04\xe19\x1d#\n\x0e\n\x06\x04\
    \xb0\x02\x02\0\x03\x12\x04\xe19&'\n\r\n\x05\x04\xb0\x02\x02\x01\x12\x04\
    \xe29\x02h\n\x0e\n\x06\x04\xb0\x02\x02\x01\x04\x12\x04\xe29\x02\n\n\x0e\
    \n\x06\x04\xb0\x02\x02\x01\x06\x12\x04\xe29\x0b$\n\x0e\n\x06\x04\xb0\x02\
    \x02\x01\x01\x12\x04\xe29%4\n\x0e\n\x06\x04\xb0\x02\x02\x01\x03\x12\x04\
    \xe2978\n\x0e\n\x06\x04\xb0\x02\x02\x01\x08\x12\x04\xe299g\n\x11\n\t\x04\
    \xb0\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xe29:f\n+\n\x03\x04\xb1\x02\x12\
    \x06\xe69\0\xe99\x01\x1a\x1c\x20SingleInputsAddJobResponse\n\n\x0c\n\x04\
    \x04\xb1\x02\x01\x12\x04\xe69\x08\"\n\r\n\x05\x04\xb1\x02\x02\0\x12\x04\
    \xe79\x02(\n\x0e\n\x06\x04\xb1\x02\x02\0\x06\x12\x04\xe79\x02\x1c\n\x0e\
    \n\x06\x04\xb1\x02\x02\0\x01\x12\x04\xe79\x1d#\n\x0e\n\x06\x04\xb1\x02\
    \x02\0\x03\x12\x04\xe79&'\n\r\n\x05\x04\xb1\x02\x02\x01\x12\x04\xe89\x02\
    /\n\x0e\n\x06\x04\xb1\x02\x02\x01\x06\x12\x04\xe89\x02\x1b\n\x0e\n\x06\
    \x04\xb1\x02\x02\x01\x01\x12\x04\xe89\x1c*\n\x0e\n\x06\x04\xb1\x02\x02\
    \x01\x03\x12\x04\xe89-.\n)\n\x03\x04\xb2\x02\x12\x06\xec9\0\xef9\x01\x1a\
    \x1a\x20Start\x20a\x20multipart\x20upload\n\n\x0c\n\x04\x04\xb2\x02\x01\
    \x12\x04\xec9\x08\x1a\n\r\n\x05\x04\xb2\x02\x02\0\x12\x04\xed9\x02,\n\
    \x0e\n\x06\x04\xb2\x02\x02\0\x06\x12\x04\xed9\x02\x1b\n\x0e\n\x06\x04\
    \xb2\x02\x02\0\x01\x12\x04\xed9\x1c'\n\x0e\n\x06\x04\xb2\x02\x02\0\x03\
    \x12\x04\xed9*+\n\r\n\x05\x04\xb2\x02\x02\x01\x12\x04\xee9\x02+\n\x0e\n\
    \x06\x04\xb2\x02\x02\x01\x04\x12\x04\xee9\x02\n\n\x0e\n\x06\x04\xb2\x02\
    \x02\x01\x06\x12\x04\xee9\x0b\x1e\n\x0e\n\x06\x04\xb2\x02\x02\x01\x01\
    \x12\x04\xee9\x1f&\n\x0e\n\x06\x04\xb2\x02\x02\x01\x03\x12\x04\xee9)*\n2\
    \n\x03\x04\xb3\x02\x12\x06\xf29\0\xf59\x01\x1a#\x20Stops\x20or\x20delete\
    s\x20multipart\x20upload\n\n\x0c\n\x04\x04\xb3\x02\x01\x12\x04\xf29\x08\
    \x1c\n\r\n\x05\x04\xb3\x02\x02\0\x12\x04\xf39\x02,\n\x0e\n\x06\x04\xb3\
    \x02\x02\0\x06\x12\x04\xf39\x02\x1b\n\x0e\n\x06\x04\xb3\x02\x02\0\x01\
    \x12\x04\xf39\x1c'\n\x0e\n\x06\x04\xb3\x02\x02\0\x03\x12\x04\xf39*+\n\r\
    \n\x05\x04\xb3\x02\x02\x01\x12\x04\xf49\x02\x1a\n\x0e\n\x06\x04\xb3\x02\
    \x02\x01\x04\x12\x04\xf49\x02\n\n\x0e\n\x06\x04\xb3\x02\x02\x01\x05\x12\
    \x04\xf49\x0b\x11\n\x0e\n\x06\x04\xb3\x02\x02\x01\x01\x12\x04\xf49\x12\
    \x15\n\x0e\n\x06\x04\xb3\x02\x02\x01\x03\x12\x04\xf49\x18\x19\n\r\n\x03\
    \x04\xb4\x02\x12\x06\xf79\0\xff9\x01\n\x0c\n\x04\x04\xb4\x02\x01\x12\x04\
    \xf79\x08\x1a\n\r\n\x05\x04\xb4\x02\x02\0\x12\x04\xf89\x02,\n\x0e\n\x06\
    \x04\xb4\x02\x02\0\x06\x12\x04\xf89\x02\x1b\n\x0e\n\x06\x04\xb4\x02\x02\
    \0\x01\x12\x04\xf89\x1c'\n\x0e\n\x06\x04\xb4\x02\x02\0\x03\x12\x04\xf89*\
    +\n\x7f\n\x05\x04\xb4\x02\x02\x01\x12\x04\xfb9\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xb4\x02\x02\x01\x05\x12\x04\xfb9\x02\x08\
    \n\x0e\n\x06\x04\xb4\x02\x02\x01\x01\x12\x04\xfb9\t\r\n\x0e\n\x06\x04\
    \xb4\x02\x02\x01\x03\x12\x04\xfb9\x10\x11\nv\n\x05\x04\xb4\x02\x02\x02\
    \x12\x04\xfe9\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xb4\x02\x02\x02\
    \x05\x12\x04\xfe9\x02\x08\n\x0e\n\x06\x04\xb4\x02\x02\x02\x01\x12\x04\
    \xfe9\t\x11\n\x0e\n\x06\x04\xb4\x02\x02\x02\x03\x12\x04\xfe9\x14\x15\n\r\
    \n\x03\x04\xb5\x02\x12\x06\x81:\0\x86:\x01\n\x0c\n\x04\x04\xb5\x02\x01\
    \x12\x04\x81:\x08\x18\n\r\n\x05\x04\xb5\x02\x02\0\x12\x04\x82:\x02,\n\
    \x0e\n\x06\x04\xb5\x02\x02\0\x06\x12\x04\x82:\x02\x1b\n\x0e\n\x06\x04\
    \xb5\x02\x02\0\x01\x12\x04\x82:\x1c'\n\x0e\n\x06\x04\xb5\x02\x02\0\x03\
    \x12\x04\x82:*+\n\x1a\n\x05\x04\xb5\x02\x02\x01\x12\x04\x85:\x02\x17\x1a\
    \x0b\x20Upload\x20ID\n\n\x0e\n\x06\x04\xb5\x02\x02\x01\x05\x12\x04\x85:\
    \x02\x08\n\x0e\n\x06\x04\xb5\x02\x02\x01\x01\x12\x04\x85:\t\x12\n\x0e\n\
    \x06\x04\xb5\x02\x02\x01\x03\x12\x04\x85:\x15\x16\n\r\n\x03\x04\xb6\x02\
    \x12\x06\x88:\0\x8b:\x01\n\x0c\n\x04\x04\xb6\x02\x01\x12\x04\x88:\x08\
    \x1c\n\r\n\x05\x04\xb6\x02\x02\0\x12\x04\x89:\x02(\n\x0e\n\x06\x04\xb6\
    \x02\x02\0\x06\x12\x04\x89:\x02\x1c\n\x0e\n\x06\x04\xb6\x02\x02\0\x01\
    \x12\x04\x89:\x1d#\n\x0e\n\x06\x04\xb6\x02\x02\0\x03\x12\x04\x89:&'\n\r\
    \n\x05\x04\xb6\x02\x02\x01\x12\x04\x8a:\x02!\n\x0e\n\x06\x04\xb6\x02\x02\
    \x01\x06\x12\x04\x8a:\x02\x15\n\x0e\n\x06\x04\xb6\x02\x02\x01\x01\x12\
    \x04\x8a:\x16\x1c\n\x0e\n\x06\x04\xb6\x02\x02\x01\x03\x12\x04\x8a:\x1f\
    \x20\n\r\n\x03\x04\xb7\x02\x12\x06\x8d:\0\x90:\x01\n\x0c\n\x04\x04\xb7\
    \x02\x01\x12\x04\x8d:\x08\x1b\n\r\n\x05\x04\xb7\x02\x02\0\x12\x04\x8e:\
    \x02(\n\x0e\n\x06\x04\xb7\x02\x02\0\x06\x12\x04\x8e:\x02\x1c\n\x0e\n\x06\
    \x04\xb7\x02\x02\0\x01\x12\x04\x8e:\x1d#\n\x0e\n\x06\x04\xb7\x02\x02\0\
    \x03\x12\x04\x8e:&'\n\r\n\x05\x04\xb7\x02\x02\x01\x12\x04\x8f:\x02+\n\
    \x0e\n\x06\x04\xb7\x02\x02\x01\x04\x12\x04\x8f:\x02\n\n\x0e\n\x06\x04\
    \xb7\x02\x02\x01\x06\x12\x04\x8f:\x0b\x1e\n\x0e\n\x06\x04\xb7\x02\x02\
    \x01\x01\x12\x04\x8f:\x1f&\n\x0e\n\x06\x04\xb7\x02\x02\x01\x03\x12\x04\
    \x8f:)*\n\x8c\x01\n\x03\x04\xb8\x02\x12\x06\x94:\0\x98:\x01\x1a}\x20Uplo\
    ad\x20a\x20part\x20of\x20a\x20multipart\x20upload.\n\x20Behaviour\x20on\
    \x20completion\x20depends\x20on\x20the\x20endpoint\x20that\x20was\x20use\
    d\x20to\x20initiate\x20the\x20upload.\n\n\x0c\n\x04\x04\xb8\x02\x01\x12\
    \x04\x94:\x08$\n\r\n\x05\x04\xb8\x02\x02\0\x12\x04\x95:\x02,\n\x0e\n\x06\
    \x04\xb8\x02\x02\0\x06\x12\x04\x95:\x02\x1b\n\x0e\n\x06\x04\xb8\x02\x02\
    \0\x01\x12\x04\x95:\x1c'\n\x0e\n\x06\x04\xb8\x02\x02\0\x03\x12\x04\x95:*\
    +\n\r\n\x05\x04\xb8\x02\x02\x01\x12\x04\x96:\x02\x17\n\x0e\n\x06\x04\xb8\
    \x02\x02\x01\x05\x12\x04\x96:\x02\x08\n\x0e\n\x06\x04\xb8\x02\x02\x01\
    \x01\x12\x04\x96:\t\x12\n\x0e\n\x06\x04\xb8\x02\x02\x01\x03\x12\x04\x96:\
    \x15\x16\n\r\n\x05\x04\xb8\x02\x02\x02\x12\x04\x97:\x02/\n\x0e\n\x06\x04\
    \xb8\x02\x02\x02\x04\x12\x04\x97:\x02\n\n\x0e\n\x06\x04\xb8\x02\x02\x02\
    \x06\x12\x04\x97:\x0b\x1c\n\x0e\n\x06\x04\xb8\x02\x02\x02\x01\x12\x04\
    \x97:\x1d*\n\x0e\n\x06\x04\xb8\x02\x02\x02\x03\x12\x04\x97:-.\n\xad\x06\
    \n\x03\x04\xb9\x02\x12\x06\xa7:\0\xb1:\x01\x1a\x9d\x06\x20Initiates\x20r\
    etrieval\x20of\x20inputs\x20from\x20cloud\x20storage\x20from\x20a\x20use\
    r\x20provided\x20data\x20source.\n\x20Will\x20create\x20and\x20return\
    \x20an\x20inputs-add-job\x20for\x20tracking\x20progress.\n\x20Archives\
    \x20will\x20be\x20extracted\x20and\x20their\x20contents\x20will\x20be\
    \x20processed\x20as\x20inputs.\n\n\x20The\x20cloud\x20URL\x20will\x20be\
    \x20treated\x20as\x20a\x20filter\x20prefix.\x20For\x20example\x20s3:/buc\
    ket/images_folder/abc\x20will\x20process\n\x20files\x20in\x20the\x20imag\
    es_folder\x20beginning\x20with\x20abc\x20or\x20in\x20a\x20subfolder\x20b\
    eginning\x20with\x20abc.\n\x20For\x20example:\n\x20bucket/images_folder/\
    abcImage.png\n\x20bucket/images_folder/abc-1/Data.zip\n\n\x20If\x20given\
    \x20URL\x20is\x20for\x20a\x20private\x20bucket\x20or\x20file,\x20then\
    \x20credentials\x20should\x20be\x20provided\x20to\x20access\x20the\x20bu\
    cket.\n\x20Credentials\x20should\x20include\x20rights\x20to\x20list\x20t\
    he\x20objects\x20in\x20the\x20bucket,\x20except\x20when\x20pointed\x20di\
    rectly\x20at\x20a\x20file\x20archive,\n\x20in\x20which\x20case\x20it\x20\
    only\x20requires\x20rights\x20to\x20access\x20that\x20particular\x20file\
    .\n\n\x0c\n\x04\x04\xb9\x02\x01\x12\x04\xa7:\x08$\n\r\n\x05\x04\xb9\x02\
    \x02\0\x12\x04\xa8:\x02,\n\x0e\n\x06\x04\xb9\x02\x02\0\x06\x12\x04\xa8:\
    \x02\x1b\n\x0e\n\x06\x04\xb9\x02\x02\0\x01\x12\x04\xa8:\x1c'\n\x0e\n\x06\
    \x04\xb9\x02\x02\0\x03\x12\x04\xa8:*+\n\r\n\x05\x04\xb9\x02\x02\x01\x12\
    \x04\xaa:\x02-\n\x0e\n\x06\x04\xb9\x02\x02\x01\x04\x12\x04\xaa:\x02\n\n\
    \x0e\n\x06\x04\xb9\x02\x02\x01\x06\x12\x04\xaa:\x0b\x1b\n\x0e\n\x06\x04\
    \xb9\x02\x02\x01\x01\x12\x04\xaa:\x1c(\n\x0e\n\x06\x04\xb9\x02\x02\x01\
    \x03\x12\x04\xaa:+,\ng\n\x05\x04\xb9\x02\x02\x02\x12\x04\xad:\x02\x1b\
    \x1aX\x20If\x20call\x20back\x20url\x20is\x20set,\x20we\x20will\x20send\
    \x20a\x20Post\x20request\x20to\x20this\x20endpoint\x20with\x20job\x20sta\
    tus.\n\n\x0e\n\x06\x04\xb9\x02\x02\x02\x05\x12\x04\xad:\x02\x08\n\x0e\n\
    \x06\x04\xb9\x02\x02\x02\x01\x12\x04\xad:\t\x16\n\x0e\n\x06\x04\xb9\x02\
    \x02\x02\x03\x12\x04\xad:\x19\x1a\nS\n\x05\x04\xb9\x02\x02\x03\x12\x04\
    \xb0:\x02\x15\x1aD\x20Personal\x20Access\x20Token\x20to\x20the\x20applic\
    ation\x20to\x20which\x20inputs\x20are\x20added\n\n\x0e\n\x06\x04\xb9\x02\
    \x02\x03\x05\x12\x04\xb0:\x02\x08\n\x0e\n\x06\x04\xb9\x02\x02\x03\x01\
    \x12\x04\xb0:\t\x10\n\x0e\n\x06\x04\xb9\x02\x02\x03\x03\x12\x04\xb0:\x13\
    \x14\n\r\n\x03\x04\xba\x02\x12\x06\xb3:\0\xb7:\x01\n\x0c\n\x04\x04\xba\
    \x02\x01\x12\x04\xb3:\x08%\n\r\n\x05\x04\xba\x02\x02\0\x12\x04\xb4:\x02,\
    \n\x0e\n\x06\x04\xba\x02\x02\0\x06\x12\x04\xb4:\x02\x1b\n\x0e\n\x06\x04\
    \xba\x02\x02\0\x01\x12\x04\xb4:\x1c'\n\x0e\n\x06\x04\xba\x02\x02\0\x03\
    \x12\x04\xb4:*+\n\r\n\x05\x04\xba\x02\x02\x01\x12\x04\xb6:\x02&\n\x0e\n\
    \x06\x04\xba\x02\x02\x01\x05\x12\x04\xb6:\x02\x08\n\x0e\n\x06\x04\xba\
    \x02\x02\x01\x01\x12\x04\xb6:\t!\n\x0e\n\x06\x04\xba\x02\x02\x01\x03\x12\
    \x04\xb6:$%\n\r\n\x03\x04\xbb\x02\x12\x06\xb9:\0\xc1:\x01\n\x0c\n\x04\
    \x04\xbb\x02\x01\x12\x04\xb9:\x08'\n\r\n\x05\x04\xbb\x02\x02\0\x12\x04\
    \xba:\x02,\n\x0e\n\x06\x04\xbb\x02\x02\0\x06\x12\x04\xba:\x02\x1b\n\x0e\
    \n\x06\x04\xbb\x02\x02\0\x01\x12\x04\xba:\x1c'\n\x0e\n\x06\x04\xbb\x02\
    \x02\0\x03\x12\x04\xba:*+\n\x7f\n\x05\x04\xbb\x02\x02\x01\x12\x04\xbd:\
    \x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number\
    .\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xbb\x02\x02\x01\
    \x05\x12\x04\xbd:\x02\x08\n\x0e\n\x06\x04\xbb\x02\x02\x01\x01\x12\x04\
    \xbd:\t\r\n\x0e\n\x06\x04\xbb\x02\x02\x01\x03\x12\x04\xbd:\x10\x11\nv\n\
    \x05\x04\xbb\x02\x02\x02\x12\x04\xc0:\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\
    \n\x06\x04\xbb\x02\x02\x02\x05\x12\x04\xc0:\x02\x08\n\x0e\n\x06\x04\xbb\
    \x02\x02\x02\x01\x12\x04\xc0:\t\x11\n\x0e\n\x06\x04\xbb\x02\x02\x02\x03\
    \x12\x04\xc0:\x14\x15\n\r\n\x03\x04\xbc\x02\x12\x06\xc3:\0\xc6:\x01\n\
    \x0c\n\x04\x04\xbc\x02\x01\x12\x04\xc3:\x08)\n\r\n\x05\x04\xbc\x02\x02\0\
    \x12\x04\xc4:\x02(\n\x0e\n\x06\x04\xbc\x02\x02\0\x06\x12\x04\xc4:\x02\
    \x1c\n\x0e\n\x06\x04\xbc\x02\x02\0\x01\x12\x04\xc4:\x1d#\n\x0e\n\x06\x04\
    \xbc\x02\x02\0\x03\x12\x04\xc4:&'\n\r\n\x05\x04\xbc\x02\x02\x01\x12\x04\
    \xc5:\x02=\n\x0e\n\x06\x04\xbc\x02\x02\x01\x06\x12\x04\xc5:\x02\"\n\x0e\
    \n\x06\x04\xbc\x02\x02\x01\x01\x12\x04\xc5:#8\n\x0e\n\x06\x04\xbc\x02\
    \x02\x01\x03\x12\x04\xc5:;<\n\r\n\x03\x04\xbd\x02\x12\x06\xc8:\0\xcb:\
    \x01\n\x0c\n\x04\x04\xbd\x02\x01\x12\x04\xc8:\x08(\n\r\n\x05\x04\xbd\x02\
    \x02\0\x12\x04\xc9:\x02(\n\x0e\n\x06\x04\xbd\x02\x02\0\x06\x12\x04\xc9:\
    \x02\x1c\n\x0e\n\x06\x04\xbd\x02\x02\0\x01\x12\x04\xc9:\x1d#\n\x0e\n\x06\
    \x04\xbd\x02\x02\0\x03\x12\x04\xc9:&'\n\r\n\x05\x04\xbd\x02\x02\x01\x12\
    \x04\xca:\x02G\n\x0e\n\x06\x04\xbd\x02\x02\x01\x04\x12\x04\xca:\x02\n\n\
    \x0e\n\x06\x04\xbd\x02\x02\x01\x06\x12\x04\xca:\x0b+\n\x0e\n\x06\x04\xbd\
    \x02\x02\x01\x01\x12\x04\xca:,B\n\x0e\n\x06\x04\xbd\x02\x02\x01\x03\x12\
    \x04\xca:EF\n4\n\x03\x04\xbe\x02\x12\x06\xce:\0\xd2:\x01\x1a%\x20Cancel\
    \x20a\x20list\x20of\x20extraction\x20job\x20ids\n\n\x0c\n\x04\x04\xbe\
    \x02\x01\x12\x04\xce:\x08)\n\r\n\x05\x04\xbe\x02\x02\0\x12\x04\xcf:\x02,\
    \n\x0e\n\x06\x04\xbe\x02\x02\0\x06\x12\x04\xcf:\x02\x1b\n\x0e\n\x06\x04\
    \xbe\x02\x02\0\x01\x12\x04\xcf:\x1c'\n\x0e\n\x06\x04\xbe\x02\x02\0\x03\
    \x12\x04\xcf:*+\n;\n\x05\x04\xbe\x02\x02\x01\x12\x04\xd1:\x02\x1a\x1a,\
    \x20List\x20of\x20extraction\x20job\x20ids\x20to\x20be\x20cancelled\n\n\
    \x0e\n\x06\x04\xbe\x02\x02\x01\x04\x12\x04\xd1:\x02\n\n\x0e\n\x06\x04\
    \xbe\x02\x02\x01\x05\x12\x04\xd1:\x0b\x11\n\x0e\n\x06\x04\xbe\x02\x02\
    \x01\x01\x12\x04\xd1:\x12\x15\n\x0e\n\x06\x04\xbe\x02\x02\x01\x03\x12\
    \x04\xd1:\x18\x19\n\xe6\x02\n\x03\x04\xbf\x02\x12\x06\xd9:\0\xdc:\x01\
    \x1a\xd6\x02\x20Start\x20uploading\x20a\x20file\x20archive\x20containing\
    \x20inputs.\n\x20Will\x20create\x20and\x20return\x20an\x20inputs-add-job\
    \x20for\x20tracking\x20progress.\n\n\x20Associated\x20inputs-add-job\x20\
    contains\x20an\x20upload\x20id\x20which\x20should\x20be\x20completed\x20\
    through\x20`PutUploadContentParts`\x20endpoint.\n\x20Completing\x20the\
    \x20upload\x20will\x20automatically\x20begin\x20unpacking\x20the\x20arch\
    ive\x20and\x20uploading\x20the\x20contents\x20as\x20inputs.\n\n\x0c\n\
    \x04\x04\xbf\x02\x01\x12\x04\xd9:\x08\x20\n\r\n\x05\x04\xbf\x02\x02\0\
    \x12\x04\xda:\x02,\n\x0e\n\x06\x04\xbf\x02\x02\0\x06\x12\x04\xda:\x02\
    \x1b\n\x0e\n\x06\x04\xbf\x02\x02\0\x01\x12\x04\xda:\x1c'\n\x0e\n\x06\x04\
    \xbf\x02\x02\0\x03\x12\x04\xda:*+\n\r\n\x05\x04\xbf\x02\x02\x01\x12\x04\
    \xdb:\x028\n\x0e\n\x06\x04\xbf\x02\x02\x01\x04\x12\x04\xdb:\x02\n\n\x0e\
    \n\x06\x04\xbf\x02\x02\x01\x06\x12\x04\xdb:\x0b$\n\x0e\n\x06\x04\xbf\x02\
    \x02\x01\x01\x12\x04\xdb:%3\n\x0e\n\x06\x04\xbf\x02\x02\x01\x03\x12\x04\
    \xdb:67\n!\n\x03\x04\xc0\x02\x12\x06\xdf:\0\xe2:\x01\x1a\x12\x20GetRunne\
    rRequest\n\n\x0c\n\x04\x04\xc0\x02\x01\x12\x04\xdf:\x08\x18\n\r\n\x05\
    \x04\xc0\x02\x02\0\x12\x04\xe0:\x02,\n\x0e\n\x06\x04\xc0\x02\x02\0\x06\
    \x12\x04\xe0:\x02\x1b\n\x0e\n\x06\x04\xc0\x02\x02\0\x01\x12\x04\xe0:\x1c\
    '\n\x0e\n\x06\x04\xc0\x02\x02\0\x03\x12\x04\xe0:*+\n\r\n\x05\x04\xc0\x02\
    \x02\x01\x12\x04\xe1:\x02\x17\n\x0e\n\x06\x04\xc0\x02\x02\x01\x05\x12\
    \x04\xe1:\x02\x08\n\x0e\n\x06\x04\xc0\x02\x02\x01\x01\x12\x04\xe1:\t\x12\
    \n\x0e\n\x06\x04\xc0\x02\x02\x01\x03\x12\x04\xe1:\x15\x16\n#\n\x03\x04\
    \xc1\x02\x12\x06\xe5:\0\xed:\x01\x1a\x14\x20ListRunnersRequest\n\n\x0c\n\
    \x04\x04\xc1\x02\x01\x12\x04\xe5:\x08\x1a\n\r\n\x05\x04\xc1\x02\x02\0\
    \x12\x04\xe6:\x02,\n\x0e\n\x06\x04\xc1\x02\x02\0\x06\x12\x04\xe6:\x02\
    \x1b\n\x0e\n\x06\x04\xc1\x02\x02\0\x01\x12\x04\xe6:\x1c'\n\x0e\n\x06\x04\
    \xc1\x02\x02\0\x03\x12\x04\xe6:*+\n\x7f\n\x05\x04\xc1\x02\x02\x01\x12\
    \x04\xe9:\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xc1\x02\
    \x02\x01\x05\x12\x04\xe9:\x02\x08\n\x0e\n\x06\x04\xc1\x02\x02\x01\x01\
    \x12\x04\xe9:\t\r\n\x0e\n\x06\x04\xc1\x02\x02\x01\x03\x12\x04\xe9:\x10\
    \x11\nv\n\x05\x04\xc1\x02\x02\x02\x12\x04\xec:\x02\x16\x1ag\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\
    \n\x0e\n\x06\x04\xc1\x02\x02\x02\x05\x12\x04\xec:\x02\x08\n\x0e\n\x06\
    \x04\xc1\x02\x02\x02\x01\x12\x04\xec:\t\x11\n\x0e\n\x06\x04\xc1\x02\x02\
    \x02\x03\x12\x04\xec:\x14\x15\n#\n\x03\x04\xc2\x02\x12\x06\xf4:\0\xf8:\
    \x01\x1a\x14\x20PostRunnersRequest\n\n\x0c\n\x04\x04\xc2\x02\x01\x12\x04\
    \xf4:\x08\x1a\n\r\n\x05\x04\xc2\x02\x02\0\x12\x04\xf5:\x02,\n\x0e\n\x06\
    \x04\xc2\x02\x02\0\x06\x12\x04\xf5:\x02\x1b\n\x0e\n\x06\x04\xc2\x02\x02\
    \0\x01\x12\x04\xf5:\x1c'\n\x0e\n\x06\x04\xc2\x02\x02\0\x03\x12\x04\xf5:*\
    +\nW\n\x05\x04\xc2\x02\x02\x01\x12\x04\xf7:\x02\x1e\x1aH\x20This\x20allo\
    ws\x20you\x20to\x20create\x20one\x20or\x20more\x20runner\x20by\x20postin\
    g\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\xc2\x02\x02\x01\x04\x12\
    \x04\xf7:\x02\n\n\x0e\n\x06\x04\xc2\x02\x02\x01\x06\x12\x04\xf7:\x0b\x11\
    \n\x0e\n\x06\x04\xc2\x02\x02\x01\x01\x12\x04\xf7:\x12\x19\n\x0e\n\x06\
    \x04\xc2\x02\x02\x01\x03\x12\x04\xf7:\x1c\x1d\nE\n\x03\x04\xc3\x02\x12\
    \x06\xfb:\0\xfe:\x01\x1a6\x20Request\x20to\x20delete\x20several\x20thing\
    s\x20by\x20the\x20list\x20of\x20ids.\n\n\x0c\n\x04\x04\xc3\x02\x01\x12\
    \x04\xfb:\x08\x1c\n\r\n\x05\x04\xc3\x02\x02\0\x12\x04\xfc:\x02,\n\x0e\n\
    \x06\x04\xc3\x02\x02\0\x06\x12\x04\xfc:\x02\x1b\n\x0e\n\x06\x04\xc3\x02\
    \x02\0\x01\x12\x04\xfc:\x1c'\n\x0e\n\x06\x04\xc3\x02\x02\0\x03\x12\x04\
    \xfc:*+\n\r\n\x05\x04\xc3\x02\x02\x01\x12\x04\xfd:\x02\x1a\n\x0e\n\x06\
    \x04\xc3\x02\x02\x01\x04\x12\x04\xfd:\x02\n\n\x0e\n\x06\x04\xc3\x02\x02\
    \x01\x05\x12\x04\xfd:\x0b\x11\n\x0e\n\x06\x04\xc3\x02\x02\x01\x01\x12\
    \x04\xfd:\x12\x15\n\x0e\n\x06\x04\xc3\x02\x02\x01\x03\x12\x04\xfd:\x18\
    \x19\n%\n\x03\x04\xc4\x02\x12\x06\x83;\0\x86;\x01\x1a\x16\x20SingleRunne\
    rResponse\n\n\x0c\n\x04\x04\xc4\x02\x01\x12\x04\x83;\x08\x1c\n\r\n\x05\
    \x04\xc4\x02\x02\0\x12\x04\x84;\x02(\n\x0e\n\x06\x04\xc4\x02\x02\0\x06\
    \x12\x04\x84;\x02\x1c\n\x0e\n\x06\x04\xc4\x02\x02\0\x01\x12\x04\x84;\x1d\
    #\n\x0e\n\x06\x04\xc4\x02\x02\0\x03\x12\x04\x84;&'\n\r\n\x05\x04\xc4\x02\
    \x02\x01\x12\x04\x85;\x02\x14\n\x0e\n\x06\x04\xc4\x02\x02\x01\x06\x12\
    \x04\x85;\x02\x08\n\x0e\n\x06\x04\xc4\x02\x02\x01\x01\x12\x04\x85;\t\x0f\
    \n\x0e\n\x06\x04\xc4\x02\x02\x01\x03\x12\x04\x85;\x12\x13\n$\n\x03\x04\
    \xc5\x02\x12\x06\x89;\0\x8c;\x01\x1a\x15\x20MultiRunnerResponse\n\n\x0c\
    \n\x04\x04\xc5\x02\x01\x12\x04\x89;\x08\x1b\n\r\n\x05\x04\xc5\x02\x02\0\
    \x12\x04\x8a;\x02(\n\x0e\n\x06\x04\xc5\x02\x02\0\x06\x12\x04\x8a;\x02\
    \x1c\n\x0e\n\x06\x04\xc5\x02\x02\0\x01\x12\x04\x8a;\x1d#\n\x0e\n\x06\x04\
    \xc5\x02\x02\0\x03\x12\x04\x8a;&'\n\r\n\x05\x04\xc5\x02\x02\x01\x12\x04\
    \x8b;\x02M\n\x0e\n\x06\x04\xc5\x02\x02\x01\x04\x12\x04\x8b;\x02\n\n\x0e\
    \n\x06\x04\xc5\x02\x02\x01\x06\x12\x04\x8b;\x0b\x11\n\x0e\n\x06\x04\xc5\
    \x02\x02\x01\x01\x12\x04\x8b;\x12\x19\n\x0e\n\x06\x04\xc5\x02\x02\x01\
    \x03\x12\x04\x8b;\x1c\x1d\n\x0e\n\x06\x04\xc5\x02\x02\x01\x08\x12\x04\
    \x8b;\x1eL\n\x11\n\t\x04\xc5\x02\x02\x01\x08\xd0\x86\x03\x12\x04\x8b;\
    \x1fK\n\r\n\x03\x04\xc6\x02\x12\x06\x92;\0\x95;\x01\n\x0c\n\x04\x04\xc6\
    \x02\x01\x12\x04\x92;\x08\x1e\n\r\n\x05\x04\xc6\x02\x02\0\x12\x04\x93;\
    \x02,\n\x0e\n\x06\x04\xc6\x02\x02\0\x06\x12\x04\x93;\x02\x1b\n\x0e\n\x06\
    \x04\xc6\x02\x02\0\x01\x12\x04\x93;\x1c'\n\x0e\n\x06\x04\xc6\x02\x02\0\
    \x03\x12\x04\x93;*+\n\r\n\x05\x04\xc6\x02\x02\x01\x12\x04\x94;\x02\x17\n\
    \x0e\n\x06\x04\xc6\x02\x02\x01\x05\x12\x04\x94;\x02\x08\n\x0e\n\x06\x04\
    \xc6\x02\x02\x01\x01\x12\x04\x94;\t\x12\n\x0e\n\x06\x04\xc6\x02\x02\x01\
    \x03\x12\x04\x94;\x15\x16\n-\n\x03\x04\xc7\x02\x12\x06\x98;\0\xa5;\x01\
    \x1a\x1e\x20PostRunnerItemOutputsRequest\n\n\x0c\n\x04\x04\xc7\x02\x01\
    \x12\x04\x98;\x08$\n\r\n\x05\x04\xc7\x02\x02\0\x12\x04\x99;\x02,\n\x0e\n\
    \x06\x04\xc7\x02\x02\0\x06\x12\x04\x99;\x02\x1b\n\x0e\n\x06\x04\xc7\x02\
    \x02\0\x01\x12\x04\x99;\x1c'\n\x0e\n\x06\x04\xc7\x02\x02\0\x03\x12\x04\
    \x99;*+\n?\n\x05\x04\xc7\x02\x02\x01\x12\x04\x9b;\x02\x17\x1a0\x20The\
    \x20particular\x20runner\x20that\x20processed\x20the\x20work.\n\n\x0e\n\
    \x06\x04\xc7\x02\x02\x01\x05\x12\x04\x9b;\x02\x08\n\x0e\n\x06\x04\xc7\
    \x02\x02\x01\x01\x12\x04\x9b;\t\x12\n\x0e\n\x06\x04\xc7\x02\x02\x01\x03\
    \x12\x04\x9b;\x15\x16\n7\n\x05\x04\xc7\x02\x02\x02\x12\x04\x9d;\x02\x1c\
    \x1a(\x20The\x20particular\x20item\x20of\x20work\x20processed.\n\n\x0e\n\
    \x06\x04\xc7\x02\x02\x02\x05\x12\x04\x9d;\x02\x08\n\x0e\n\x06\x04\xc7\
    \x02\x02\x02\x01\x12\x04\x9d;\t\x17\n\x0e\n\x06\x04\xc7\x02\x02\x02\x03\
    \x12\x04\x9d;\x1a\x1b\nW\n\x05\x04\xc7\x02\x02\x03\x12\x04\x9f;\x024\x1a\
    H\x20This\x20allows\x20you\x20to\x20create\x20one\x20or\x20more\x20runne\
    r\x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\x0e\n\x06\x04\xc7\x02\
    \x02\x03\x04\x12\x04\x9f;\x02\n\n\x0e\n\x06\x04\xc7\x02\x02\x03\x06\x12\
    \x04\x9f;\x0b\x1b\n\x0e\n\x06\x04\xc7\x02\x02\x03\x01\x12\x04\x9f;\x1c/\
    \n\x0e\n\x06\x04\xc7\x02\x02\x03\x03\x12\x04\x9f;23\n\xc9\x01\n\x05\x04\
    \xc7\x02\x02\x04\x12\x04\xa4;\x02(\x1a\xb9\x01\x20This\x20request\x20has\
    \x20a\x20status\x20so\x20that\x20it\x20can\x20communicate\x20to\x20the\
    \x20API\x20from\x20runners\x20and\n\x20communicate\x20status,\x20errors,\
    \x20etc.\x20This\x20is\x20on\x20the\x20request\x20since\x20runners\x20op\
    erate\n\x20in\x20a\x20reverse\x20protocol.\n\n\x0e\n\x06\x04\xc7\x02\x02\
    \x04\x06\x12\x04\xa4;\x02\x1c\n\x0e\n\x06\x04\xc7\x02\x02\x04\x01\x12\
    \x04\xa4;\x1d#\n\x0e\n\x06\x04\xc7\x02\x02\x04\x03\x12\x04\xa4;&'\n(\n\
    \x03\x04\xc8\x02\x12\x06\xac;\0\xaf;\x01\x1a\x19\x20MultiRunnerItemRespo\
    nse\n\n\x0c\n\x04\x04\xc8\x02\x01\x12\x04\xac;\x08\x1f\n\r\n\x05\x04\xc8\
    \x02\x02\0\x12\x04\xad;\x02(\n\x0e\n\x06\x04\xc8\x02\x02\0\x06\x12\x04\
    \xad;\x02\x1c\n\x0e\n\x06\x04\xc8\x02\x02\0\x01\x12\x04\xad;\x1d#\n\x0e\
    \n\x06\x04\xc8\x02\x02\0\x03\x12\x04\xad;&'\n\r\n\x05\x04\xc8\x02\x02\
    \x01\x12\x04\xae;\x02V\n\x0e\n\x06\x04\xc8\x02\x02\x01\x04\x12\x04\xae;\
    \x02\n\n\x0e\n\x06\x04\xc8\x02\x02\x01\x06\x12\x04\xae;\x0b\x15\n\x0e\n\
    \x06\x04\xc8\x02\x02\x01\x01\x12\x04\xae;\x16\"\n\x0e\n\x06\x04\xc8\x02\
    \x02\x01\x03\x12\x04\xae;%&\n\x0e\n\x06\x04\xc8\x02\x02\x01\x08\x12\x04\
    \xae;'U\n\x11\n\t\x04\xc8\x02\x02\x01\x08\xd0\x86\x03\x12\x04\xae;(T\nA\
    \n\x03\x04\xc9\x02\x12\x06\xb2;\0\xc2;\x01\x1a2\x20This\x20is\x20a\x20pi\
    ece\x20of\x20work\x20for\x20a\x20runner\x20to\x20process.\n\n\x0c\n\x04\
    \x04\xc9\x02\x01\x12\x04\xb2;\x08\x12\n0\n\x05\x04\xc9\x02\x02\0\x12\x04\
    \xb4;\x02\x10\x1a!\x20A\x20UUID\x20hash\x20for\x20this\x20work\x20item.\
    \n\n\x0e\n\x06\x04\xc9\x02\x02\0\x05\x12\x04\xb4;\x02\x08\n\x0e\n\x06\
    \x04\xc9\x02\x02\0\x01\x12\x04\xb4;\t\x0b\n\x0e\n\x06\x04\xc9\x02\x02\0\
    \x03\x12\x04\xb4;\x0e\x0f\nM\n\x05\x04\xc9\x02\x02\x01\x12\x04\xb7;\x02\
    \x19\x1a>\x20A\x20description\x20of\x20the\x20work\x20to\x20be\x20done\
    \x20in\x20case\x20needed\x20for\x20UIs.\n\n\x0e\n\x06\x04\xc9\x02\x02\
    \x01\x05\x12\x04\xb7;\x02\x08\n\x0e\n\x06\x04\xc9\x02\x02\x01\x01\x12\
    \x04\xb7;\t\x14\n\x0e\n\x06\x04\xc9\x02\x02\x01\x03\x12\x04\xb7;\x17\x18\
    \nD\n\x05\x04\xc9\x02\x02\x02\x12\x04\xba;\x02%\x1a5\x20Information\x20o\
    n\x20how\x20to\x20process\x20the\x20given\x20RunnerItem.\n\n\x0e\n\x06\
    \x04\xc9\x02\x02\x02\x06\x12\x04\xba;\x02\x10\n\x0e\n\x06\x04\xc9\x02\
    \x02\x02\x01\x12\x04\xba;\x11\x20\n\x0e\n\x06\x04\xc9\x02\x02\x02\x03\
    \x12\x04\xba;#$\n\x0f\n\x05\x04\xc9\x02\x08\0\x12\x06\xbc;\x02\xc1;\x03\
    \n\x0e\n\x06\x04\xc9\x02\x08\0\x01\x12\x04\xbc;\x08\x0f\n\x7f\n\x05\x04\
    \xc9\x02\x02\x03\x12\x04\xbe;\x04;\x1a'\x20Model\x20prediction\x20reques\
    t\x20from\x20a\x20user.\n\"G\x20Workflow\x20request\x20from\x20a\x20user\
    .\x20\x20//\x20FUTURE\n\x20training\x20request\x20next,\x20etc.\n\n\x0e\
    \n\x06\x04\xc9\x02\x02\x03\x06\x12\x04\xbe;\x04\x1b\n\x0e\n\x06\x04\xc9\
    \x02\x02\x03\x01\x12\x04\xbe;\x1c6\n\x0e\n\x06\x04\xc9\x02\x02\x03\x03\
    \x12\x04\xbe;9:\n\r\n\x03\x04\xca\x02\x12\x06\xc6;\0\xcd;\x01\n\x0c\n\
    \x04\x04\xca\x02\x01\x12\x04\xc6;\x08\x18\n\x0f\n\x05\x04\xca\x02\x08\0\
    \x12\x06\xc7;\x02\xcc;\x03\n\x0e\n\x06\x04\xca\x02\x08\0\x01\x12\x04\xc7\
    ;\x08\x10\nq\n\x05\x04\xca\x02\x02\0\x12\x04\xc9;\x042\x1a+\x20The\x20ou\
    tput\x20of\x20a\x20model\x20prediction\x20request.\n\"5\x20Workflow\x20r\
    esponse.\x20//\x20FUTURE\n\x20training\x20response\x20???\n\n\x0e\n\x06\
    \x04\xca\x02\x02\0\x06\x12\x04\xc9;\x04\x17\n\x0e\n\x06\x04\xca\x02\x02\
    \0\x01\x12\x04\xc9;\x18-\n\x0e\n\x06\x04\xca\x02\x02\0\x03\x12\x04\xc9;0\
    1\n\r\n\x03\x04\xcb\x02\x12\x06\xd1;\0\xd4;\x01\n\x0c\n\x04\x04\xcb\x02\
    \x01\x12\x04\xd1;\x08%\n\r\n\x05\x04\xcb\x02\x02\0\x12\x04\xd2;\x02(\n\
    \x0e\n\x06\x04\xcb\x02\x02\0\x06\x12\x04\xd2;\x02\x1c\n\x0e\n\x06\x04\
    \xcb\x02\x02\0\x01\x12\x04\xd2;\x1d#\n\x0e\n\x06\x04\xcb\x02\x02\0\x03\
    \x12\x04\xd2;&'\n\r\n\x05\x04\xcb\x02\x02\x01\x12\x04\xd3;\x02c\n\x0e\n\
    \x06\x04\xcb\x02\x02\x01\x04\x12\x04\xd3;\x02\n\n\x0e\n\x06\x04\xcb\x02\
    \x02\x01\x06\x12\x04\xd3;\x0b\x1b\n\x0e\n\x06\x04\xcb\x02\x02\x01\x01\
    \x12\x04\xd3;\x1c/\n\x0e\n\x06\x04\xcb\x02\x02\x01\x03\x12\x04\xd3;23\n\
    \x0e\n\x06\x04\xcb\x02\x02\x01\x08\x12\x04\xd3;4b\n\x11\n\t\x04\xcb\x02\
    \x02\x01\x08\xd0\x86\x03\x12\x04\xd3;5a\nD\n\x03\x04\xcc\x02\x12\x06\xd7\
    ;\0\xdc;\x01\x1a5\x20Get\x20the\x20estimated\x20training\x20time\x20for\
    \x20a\x20model\x20version\n\n\x0c\n\x04\x04\xcc\x02\x01\x12\x04\xd7;\x08\
    4\n\r\n\x05\x04\xcc\x02\x02\0\x12\x04\xd8;\x02,\n\x0e\n\x06\x04\xcc\x02\
    \x02\0\x06\x12\x04\xd8;\x02\x1b\n\x0e\n\x06\x04\xcc\x02\x02\0\x01\x12\
    \x04\xd8;\x1c'\n\x0e\n\x06\x04\xcc\x02\x02\0\x03\x12\x04\xd8;*+\n\r\n\
    \x05\x04\xcc\x02\x02\x01\x12\x04\xd9;\x02\x16\n\x0e\n\x06\x04\xcc\x02\
    \x02\x01\x05\x12\x04\xd9;\x02\x08\n\x0e\n\x06\x04\xcc\x02\x02\x01\x01\
    \x12\x04\xd9;\t\x11\n\x0e\n\x06\x04\xcc\x02\x02\x01\x03\x12\x04\xd9;\x14\
    \x15\n\r\n\x05\x04\xcc\x02\x02\x02\x12\x04\xda;\x02+\n\x0e\n\x06\x04\xcc\
    \x02\x02\x02\x04\x12\x04\xda;\x02\n\n\x0e\n\x06\x04\xcc\x02\x02\x02\x06\
    \x12\x04\xda;\x0b\x17\n\x0e\n\x06\x04\xcc\x02\x02\x02\x01\x12\x04\xda;\
    \x18&\n\x0e\n\x06\x04\xcc\x02\x02\x02\x03\x12\x04\xda;)*\n\r\n\x05\x04\
    \xcc\x02\x02\x03\x12\x04\xdb;\x02#\n\x0e\n\x06\x04\xcc\x02\x02\x03\x05\
    \x12\x04\xdb;\x02\x08\n\x0e\n\x06\x04\xcc\x02\x02\x03\x01\x12\x04\xdb;\t\
    \x1e\n\x0e\n\x06\x04\xcc\x02\x02\x03\x03\x12\x04\xdb;!\"\n3\n\x03\x04\
    \xcd\x02\x12\x06\xdf;\0\xe2;\x01\x1a$\x20Estimated\x20training\x20time\
    \x20in\x20seconds\n\n\x0c\n\x04\x04\xcd\x02\x01\x12\x04\xdf;\x08)\n\r\n\
    \x05\x04\xcd\x02\x02\0\x12\x04\xe0;\x02(\n\x0e\n\x06\x04\xcd\x02\x02\0\
    \x06\x12\x04\xe0;\x02\x1c\n\x0e\n\x06\x04\xcd\x02\x02\0\x01\x12\x04\xe0;\
    \x1d#\n\x0e\n\x06\x04\xcd\x02\x02\0\x03\x12\x04\xe0;&'\n\r\n\x05\x04\xcd\
    \x02\x02\x01\x12\x04\xe1;\x02@\n\x0e\n\x06\x04\xcd\x02\x02\x01\x04\x12\
    \x04\xe1;\x02\n\n\x0e\n\x06\x04\xcd\x02\x02\x01\x06\x12\x04\xe1;\x0b#\n\
    \x0e\n\x06\x04\xcd\x02\x02\x01\x01\x12\x04\xe1;$;\n\x0e\n\x06\x04\xcd\
    \x02\x02\x01\x03\x12\x04\xe1;>?b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(10);
            deps.push(super::resources::file_descriptor().clone());
            deps.push(super::status::file_descriptor().clone());
            deps.push(super::extensions::file_descriptor().clone());
            deps.push(super::scope::file_descriptor().clone());
            deps.push(super::extension::file_descriptor().clone());
            deps.push(super::status_code::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::struct_::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(334);
            messages.push(Pagination::generated_message_descriptor_data());
            messages.push(GetAnnotationRequest::generated_message_descriptor_data());
            messages.push(ListAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsStatusRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsStatusResponse::generated_message_descriptor_data());
            messages.push(DeleteAnnotationRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationsRequest::generated_message_descriptor_data());
            messages.push(SingleAnnotationResponse::generated_message_descriptor_data());
            messages.push(MultiAnnotationResponse::generated_message_descriptor_data());
            messages.push(ListAnnotationWorkersRequest::generated_message_descriptor_data());
            messages.push(MultiWorkerResponse::generated_message_descriptor_data());
            messages.push(GetAppRequest::generated_message_descriptor_data());
            messages.push(ListAppsRequest::generated_message_descriptor_data());
            messages.push(PostAppsRequest::generated_message_descriptor_data());
            messages.push(DeleteAppRequest::generated_message_descriptor_data());
            messages.push(PatchAppsRequest::generated_message_descriptor_data());
            messages.push(PatchAppRequest::generated_message_descriptor_data());
            messages.push(PatchAppsIdsRequest::generated_message_descriptor_data());
            messages.push(PostAppsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleAppResponse::generated_message_descriptor_data());
            messages.push(MultiAppResponse::generated_message_descriptor_data());
            messages.push(ListCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(PostCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(PatchCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(DeleteCollaboratorsRequest::generated_message_descriptor_data());
            messages.push(MultiCollaboratorsResponse::generated_message_descriptor_data());
            messages.push(ListCollaborationsRequest::generated_message_descriptor_data());
            messages.push(MultiCollaborationsResponse::generated_message_descriptor_data());
            messages.push(GetStatusCodeRequest::generated_message_descriptor_data());
            messages.push(ListStatusCodesRequest::generated_message_descriptor_data());
            messages.push(SingleStatusCodeResponse::generated_message_descriptor_data());
            messages.push(MultiStatusCodeResponse::generated_message_descriptor_data());
            messages.push(GetConceptRequest::generated_message_descriptor_data());
            messages.push(ListConceptsRequest::generated_message_descriptor_data());
            messages.push(ListModelConceptsRequest::generated_message_descriptor_data());
            messages.push(PostConceptsSearchesRequest::generated_message_descriptor_data());
            messages.push(ConceptExtraInfoRequest::generated_message_descriptor_data());
            messages.push(PostConceptsRequest::generated_message_descriptor_data());
            messages.push(PatchConceptsRequest::generated_message_descriptor_data());
            messages.push(GetConceptCountsRequest::generated_message_descriptor_data());
            messages.push(SingleConceptResponse::generated_message_descriptor_data());
            messages.push(MultiConceptResponse::generated_message_descriptor_data());
            messages.push(MultiConceptCountResponse::generated_message_descriptor_data());
            messages.push(ListConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(PostConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(DeleteConceptRelationsRequest::generated_message_descriptor_data());
            messages.push(ListKnowledgeGraphsRequest::generated_message_descriptor_data());
            messages.push(PostKnowledgeGraphsRequest::generated_message_descriptor_data());
            messages.push(PostConceptMappingJobsRequest::generated_message_descriptor_data());
            messages.push(MultiConceptRelationResponse::generated_message_descriptor_data());
            messages.push(MultiKnowledgeGraphResponse::generated_message_descriptor_data());
            messages.push(MultiConceptMappingJobResponse::generated_message_descriptor_data());
            messages.push(GetConceptLanguageRequest::generated_message_descriptor_data());
            messages.push(ListConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(PatchConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(PostConceptLanguagesRequest::generated_message_descriptor_data());
            messages.push(SingleConceptLanguageResponse::generated_message_descriptor_data());
            messages.push(MultiConceptLanguageResponse::generated_message_descriptor_data());
            messages.push(GetInputRequest::generated_message_descriptor_data());
            messages.push(GetVideoManifestRequest::generated_message_descriptor_data());
            messages.push(GetInputSamplesRequest::generated_message_descriptor_data());
            messages.push(ListInputsRequest::generated_message_descriptor_data());
            messages.push(StreamInputsRequest::generated_message_descriptor_data());
            messages.push(PostInputsRequest::generated_message_descriptor_data());
            messages.push(PatchInputsRequest::generated_message_descriptor_data());
            messages.push(DeleteInputRequest::generated_message_descriptor_data());
            messages.push(DeleteInputsRequest::generated_message_descriptor_data());
            messages.push(SingleInputResponse::generated_message_descriptor_data());
            messages.push(GetVideoManifestResponse::generated_message_descriptor_data());
            messages.push(MultiInputResponse::generated_message_descriptor_data());
            messages.push(MultiInputAnnotationResponse::generated_message_descriptor_data());
            messages.push(SingleInputCountResponse::generated_message_descriptor_data());
            messages.push(GetInputCountRequest::generated_message_descriptor_data());
            messages.push(ListDatasetsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetRequest::generated_message_descriptor_data());
            messages.push(PostDatasetsRequest::generated_message_descriptor_data());
            messages.push(PatchDatasetsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetResponse::generated_message_descriptor_data());
            messages.push(ListDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetInputRequest::generated_message_descriptor_data());
            messages.push(PostDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetInputsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetInputResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetInputResponse::generated_message_descriptor_data());
            messages.push(ListDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(GetDatasetVersionRequest::generated_message_descriptor_data());
            messages.push(ListDatasetVersionMetricsGroupsRequest::generated_message_descriptor_data());
            messages.push(PostDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(PatchDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteDatasetVersionsRequest::generated_message_descriptor_data());
            messages.push(PutDatasetVersionExportsRequest::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionResponse::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionExportResponse::generated_message_descriptor_data());
            messages.push(MultiDatasetVersionMetricsGroupResponse::generated_message_descriptor_data());
            messages.push(SingleDatasetVersionResponse::generated_message_descriptor_data());
            messages.push(PostModelOutputsRequest::generated_message_descriptor_data());
            messages.push(ListModelInputsRequest::generated_message_descriptor_data());
            messages.push(GetKeyRequest::generated_message_descriptor_data());
            messages.push(ListKeysRequest::generated_message_descriptor_data());
            messages.push(ListAppKeysRequest::generated_message_descriptor_data());
            messages.push(PostKeysRequest::generated_message_descriptor_data());
            messages.push(DeleteKeyRequest::generated_message_descriptor_data());
            messages.push(PatchKeysRequest::generated_message_descriptor_data());
            messages.push(SingleKeyResponse::generated_message_descriptor_data());
            messages.push(MultiKeyResponse::generated_message_descriptor_data());
            messages.push(GetModelRequest::generated_message_descriptor_data());
            messages.push(ListModelsRequest::generated_message_descriptor_data());
            messages.push(GetResourceCountsRequest::generated_message_descriptor_data());
            messages.push(GetResourceCountsResponse::generated_message_descriptor_data());
            messages.push(PatchModelToolkitsRequest::generated_message_descriptor_data());
            messages.push(PatchModelCheckConsentsRequest::generated_message_descriptor_data());
            messages.push(PatchModelUseCasesRequest::generated_message_descriptor_data());
            messages.push(PatchModelLanguagesRequest::generated_message_descriptor_data());
            messages.push(MultiModelToolkitResponse::generated_message_descriptor_data());
            messages.push(MultiModelCheckConsentResponse::generated_message_descriptor_data());
            messages.push(MultiModelUseCaseResponse::generated_message_descriptor_data());
            messages.push(MultiModelLanguageResponse::generated_message_descriptor_data());
            messages.push(PostModelsRequest::generated_message_descriptor_data());
            messages.push(PatchModelsRequest::generated_message_descriptor_data());
            messages.push(IdUpdateSource::generated_message_descriptor_data());
            messages.push(PatchModelIdsRequest::generated_message_descriptor_data());
            messages.push(DeleteModelRequest::generated_message_descriptor_data());
            messages.push(DeleteModelsRequest::generated_message_descriptor_data());
            messages.push(PostModelsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleModelResponse::generated_message_descriptor_data());
            messages.push(MultiModelResponse::generated_message_descriptor_data());
            messages.push(PatchModelVersionsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteModelVersionRequest::generated_message_descriptor_data());
            messages.push(SingleModelVersionResponse::generated_message_descriptor_data());
            messages.push(MultiModelVersionResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionsRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionsUploadRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionsUploadResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionsUploadConfig::generated_message_descriptor_data());
            messages.push(PutModelVersionExportsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionExportRequest::generated_message_descriptor_data());
            messages.push(SingleModelVersionExportResponse::generated_message_descriptor_data());
            messages.push(PostWorkflowVersionsUnPublishRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowVersionsPublishRequest::generated_message_descriptor_data());
            messages.push(WorkflowVersionPublishRequest::generated_message_descriptor_data());
            messages.push(WorkflowVersionUnPublishRequest::generated_message_descriptor_data());
            messages.push(ModelVersionPublishRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionsPublishRequest::generated_message_descriptor_data());
            messages.push(ModelVersionUnpublishRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionsUnPublishRequest::generated_message_descriptor_data());
            messages.push(PostEvaluationsRequest::generated_message_descriptor_data());
            messages.push(ListEvaluationsRequest::generated_message_descriptor_data());
            messages.push(GetEvaluationRequest::generated_message_descriptor_data());
            messages.push(PostModelVersionEvaluationsRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionEvaluationsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionEvaluationRequest::generated_message_descriptor_data());
            messages.push(SingleEvalMetricsResponse::generated_message_descriptor_data());
            messages.push(MultiEvalMetricsResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionMetricsRequest::generated_message_descriptor_data());
            messages.push(GetModelVersionMetricsRequest::generated_message_descriptor_data());
            messages.push(GetModelTypeRequest::generated_message_descriptor_data());
            messages.push(ListModelTypesRequest::generated_message_descriptor_data());
            messages.push(ListOpenSourceLicensesRequest::generated_message_descriptor_data());
            messages.push(ListOpenSourceLicensesResponse::generated_message_descriptor_data());
            messages.push(SingleModelTypeResponse::generated_message_descriptor_data());
            messages.push(MultiModelTypeResponse::generated_message_descriptor_data());
            messages.push(GetModelVersionInputExampleRequest::generated_message_descriptor_data());
            messages.push(ListModelVersionInputExamplesRequest::generated_message_descriptor_data());
            messages.push(SingleModelVersionInputExampleResponse::generated_message_descriptor_data());
            messages.push(MultiModelVersionInputExampleResponse::generated_message_descriptor_data());
            messages.push(ListModelReferencesRequest::generated_message_descriptor_data());
            messages.push(MultiModelReferenceResponse::generated_message_descriptor_data());
            messages.push(MultiOutputResponse::generated_message_descriptor_data());
            messages.push(ListScopesRequest::generated_message_descriptor_data());
            messages.push(MyScopesRequest::generated_message_descriptor_data());
            messages.push(MyScopesUserRequest::generated_message_descriptor_data());
            messages.push(MyScopesRootRequest::generated_message_descriptor_data());
            messages.push(MultiScopeDepsResponse::generated_message_descriptor_data());
            messages.push(MultiScopeResponse::generated_message_descriptor_data());
            messages.push(MultiScopeUserResponse::generated_message_descriptor_data());
            messages.push(MultiScopeRootResponse::generated_message_descriptor_data());
            messages.push(GetSearchRequest::generated_message_descriptor_data());
            messages.push(ListSearchesRequest::generated_message_descriptor_data());
            messages.push(PostSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchInputsSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationsSearchesRequest::generated_message_descriptor_data());
            messages.push(PatchSearchesRequest::generated_message_descriptor_data());
            messages.push(PostSearchesByIDRequest::generated_message_descriptor_data());
            messages.push(DeleteSearchRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationsSearchesRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(PostInputsSearchesRequest::generated_message_descriptor_data());
            messages.push(SingleSearchResponse::generated_message_descriptor_data());
            messages.push(MultiSearchResponse::generated_message_descriptor_data());
            messages.push(PostAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(GetAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(ListAnnotationSearchMetricsRequest::generated_message_descriptor_data());
            messages.push(MultiAnnotationSearchMetricsResponse::generated_message_descriptor_data());
            messages.push(ListAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(GetAnnotationFilterRequest::generated_message_descriptor_data());
            messages.push(PostAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(PatchAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(DeleteAnnotationFiltersRequest::generated_message_descriptor_data());
            messages.push(MultiAnnotationFilterResponse::generated_message_descriptor_data());
            messages.push(SingleAnnotationFilterResponse::generated_message_descriptor_data());
            messages.push(GetUserRequest::generated_message_descriptor_data());
            messages.push(SingleUserResponse::generated_message_descriptor_data());
            messages.push(PostValidatePasswordRequest::generated_message_descriptor_data());
            messages.push(SinglePasswordValidationResponse::generated_message_descriptor_data());
            messages.push(GetWorkflowRequest::generated_message_descriptor_data());
            messages.push(ListWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowIdsRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowsRequest::generated_message_descriptor_data());
            messages.push(SingleWorkflowResponse::generated_message_descriptor_data());
            messages.push(MultiWorkflowResponse::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsResponse::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsSimilarityRequest::generated_message_descriptor_data());
            messages.push(PostWorkflowResultsSimilarityResponse::generated_message_descriptor_data());
            messages.push(ListWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(GetWorkflowVersionRequest::generated_message_descriptor_data());
            messages.push(DeleteWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(PatchWorkflowVersionsRequest::generated_message_descriptor_data());
            messages.push(MultiWorkflowVersionResponse::generated_message_descriptor_data());
            messages.push(SingleWorkflowVersionResponse::generated_message_descriptor_data());
            messages.push(PostAppDuplicationsRequest::generated_message_descriptor_data());
            messages.push(GetAppDuplicationRequest::generated_message_descriptor_data());
            messages.push(ListAppDuplicationsRequest::generated_message_descriptor_data());
            messages.push(MultiAppDuplicationsResponse::generated_message_descriptor_data());
            messages.push(SingleAppDuplicationResponse::generated_message_descriptor_data());
            messages.push(PostTasksRequest::generated_message_descriptor_data());
            messages.push(GetTaskRequest::generated_message_descriptor_data());
            messages.push(ListTasksRequest::generated_message_descriptor_data());
            messages.push(PatchTasksRequest::generated_message_descriptor_data());
            messages.push(DeleteTasksRequest::generated_message_descriptor_data());
            messages.push(MultiTaskResponse::generated_message_descriptor_data());
            messages.push(SingleTaskResponse::generated_message_descriptor_data());
            messages.push(GetTaskCountRequest::generated_message_descriptor_data());
            messages.push(SingleTaskCountResponse::generated_message_descriptor_data());
            messages.push(PostLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(GetLabelOrderRequest::generated_message_descriptor_data());
            messages.push(ListLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(PatchLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(DeleteLabelOrdersRequest::generated_message_descriptor_data());
            messages.push(MultiLabelOrderResponse::generated_message_descriptor_data());
            messages.push(SingleLabelOrderResponse::generated_message_descriptor_data());
            messages.push(PostCollectorsRequest::generated_message_descriptor_data());
            messages.push(PatchCollectorsRequest::generated_message_descriptor_data());
            messages.push(DeleteCollectorsRequest::generated_message_descriptor_data());
            messages.push(GetCollectorRequest::generated_message_descriptor_data());
            messages.push(ListCollectorsRequest::generated_message_descriptor_data());
            messages.push(MultiCollectorResponse::generated_message_descriptor_data());
            messages.push(SingleCollectorResponse::generated_message_descriptor_data());
            messages.push(PostStatValuesRequest::generated_message_descriptor_data());
            messages.push(MultiStatValueResponse::generated_message_descriptor_data());
            messages.push(PostStatValuesAggregateRequest::generated_message_descriptor_data());
            messages.push(MultiStatValueAggregateResponse::generated_message_descriptor_data());
            messages.push(PostTrendingMetricsViewRequest::generated_message_descriptor_data());
            messages.push(ListTrendingMetricsViewsRequest::generated_message_descriptor_data());
            messages.push(MultiTrendingMetricsViewResponse::generated_message_descriptor_data());
            messages.push(GetModuleRequest::generated_message_descriptor_data());
            messages.push(ListModulesRequest::generated_message_descriptor_data());
            messages.push(PostModulesRequest::generated_message_descriptor_data());
            messages.push(PatchModulesRequest::generated_message_descriptor_data());
            messages.push(DeleteModulesRequest::generated_message_descriptor_data());
            messages.push(SingleModuleResponse::generated_message_descriptor_data());
            messages.push(MultiModuleResponse::generated_message_descriptor_data());
            messages.push(GetModuleVersionRequest::generated_message_descriptor_data());
            messages.push(ListModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PatchModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(DeleteModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(GetModuleVersionUsageCountRequest::generated_message_descriptor_data());
            messages.push(SingleModuleVersionResponse::generated_message_descriptor_data());
            messages.push(MultiModuleVersionResponse::generated_message_descriptor_data());
            messages.push(SingleModuleVersionUsageCountResponse::generated_message_descriptor_data());
            messages.push(GetInstalledModuleVersionRequest::generated_message_descriptor_data());
            messages.push(ListInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(PostInstalledModuleVersionsKeyRequest::generated_message_descriptor_data());
            messages.push(DeleteInstalledModuleVersionsRequest::generated_message_descriptor_data());
            messages.push(SingleInstalledModuleVersionResponse::generated_message_descriptor_data());
            messages.push(MultiInstalledModuleVersionResponse::generated_message_descriptor_data());
            messages.push(ListNextTaskAssignmentsRequest::generated_message_descriptor_data());
            messages.push(PostBulkOperationsRequest::generated_message_descriptor_data());
            messages.push(ListBulkOperationsRequest::generated_message_descriptor_data());
            messages.push(GetBulkOperationRequest::generated_message_descriptor_data());
            messages.push(CancelBulkOperationRequest::generated_message_descriptor_data());
            messages.push(DeleteBulkOperationRequest::generated_message_descriptor_data());
            messages.push(SingleBulkOperationsResponse::generated_message_descriptor_data());
            messages.push(MultiBulkOperationsResponse::generated_message_descriptor_data());
            messages.push(PutTaskAssignmentsRequest::generated_message_descriptor_data());
            messages.push(LabelSubmitConfig::generated_message_descriptor_data());
            messages.push(ReviewApproveConfig::generated_message_descriptor_data());
            messages.push(ReviewRequestChangesConfig::generated_message_descriptor_data());
            messages.push(ReviewRejectConfig::generated_message_descriptor_data());
            messages.push(MultiTaskAssignmentResponse::generated_message_descriptor_data());
            messages.push(ListInputsAddJobsRequest::generated_message_descriptor_data());
            messages.push(GetInputsAddJobRequest::generated_message_descriptor_data());
            messages.push(CancelInputsAddJobRequest::generated_message_descriptor_data());
            messages.push(MultiInputsAddJobResponse::generated_message_descriptor_data());
            messages.push(SingleInputsAddJobResponse::generated_message_descriptor_data());
            messages.push(PostUploadsRequest::generated_message_descriptor_data());
            messages.push(DeleteUploadsRequest::generated_message_descriptor_data());
            messages.push(ListUploadsRequest::generated_message_descriptor_data());
            messages.push(GetUploadRequest::generated_message_descriptor_data());
            messages.push(SingleUploadResponse::generated_message_descriptor_data());
            messages.push(MultiUploadResponse::generated_message_descriptor_data());
            messages.push(PutUploadContentPartsRequest::generated_message_descriptor_data());
            messages.push(PostInputsDataSourcesRequest::generated_message_descriptor_data());
            messages.push(GetInputsExtractionJobRequest::generated_message_descriptor_data());
            messages.push(ListInputsExtractionJobsRequest::generated_message_descriptor_data());
            messages.push(SingleInputsExtractionJobResponse::generated_message_descriptor_data());
            messages.push(MultiInputsExtractionJobResponse::generated_message_descriptor_data());
            messages.push(CancelInputsExtractionJobsRequest::generated_message_descriptor_data());
            messages.push(PostInputsUploadsRequest::generated_message_descriptor_data());
            messages.push(GetRunnerRequest::generated_message_descriptor_data());
            messages.push(ListRunnersRequest::generated_message_descriptor_data());
            messages.push(PostRunnersRequest::generated_message_descriptor_data());
            messages.push(DeleteRunnersRequest::generated_message_descriptor_data());
            messages.push(SingleRunnerResponse::generated_message_descriptor_data());
            messages.push(MultiRunnerResponse::generated_message_descriptor_data());
            messages.push(ListRunnerItemsRequest::generated_message_descriptor_data());
            messages.push(PostRunnerItemOutputsRequest::generated_message_descriptor_data());
            messages.push(MultiRunnerItemResponse::generated_message_descriptor_data());
            messages.push(RunnerItem::generated_message_descriptor_data());
            messages.push(RunnerItemOutput::generated_message_descriptor_data());
            messages.push(MultiRunnerItemOutputResponse::generated_message_descriptor_data());
            messages.push(PostModelVersionsTrainingTimeEstimateRequest::generated_message_descriptor_data());
            messages.push(MultiTrainingTimeEstimateResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(OrganizationInvitationStatus::generated_enum_descriptor_data());
            enums.push(PutTaskAssignmentsRequestAction::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
