// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/clarifai/api/service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct Pagination {
    // message fields
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    // uint32 page = 1;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 2;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for Pagination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(1, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page != 0 {
            os.write_uint32(1, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &Pagination| { &m.page },
                |m: &mut Pagination| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &Pagination| { &m.per_page },
                |m: &mut Pagination| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pagination>(
                "Pagination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pagination {
        static instance: ::protobuf::rt::LazyV2<Pagination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pagination::new)
    }
}

impl ::protobuf::Clear for Pagination {
    fn clear(&mut self) {
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAnnotationRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub annotation_id: ::std::string::String,
    pub input_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAnnotationRequest {
    fn default() -> &'a GetAnnotationRequest {
        <GetAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationRequest {
    pub fn new() -> GetAnnotationRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string annotation_id = 2;


    pub fn get_annotation_id(&self) -> &str {
        &self.annotation_id
    }
    pub fn clear_annotation_id(&mut self) {
        self.annotation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_id(&mut self, v: ::std::string::String) {
        self.annotation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation_id(&mut self) -> &mut ::std::string::String {
        &mut self.annotation_id
    }

    // Take field
    pub fn take_annotation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.annotation_id, ::std::string::String::new())
    }

    // string input_id = 3;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAnnotationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.annotation_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.annotation_id);
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(2, &self.annotation_id)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(3, &self.input_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAnnotationRequest {
        GetAnnotationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetAnnotationRequest| { &m.user_app_id },
                |m: &mut GetAnnotationRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotation_id",
                |m: &GetAnnotationRequest| { &m.annotation_id },
                |m: &mut GetAnnotationRequest| { &mut m.annotation_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &GetAnnotationRequest| { &m.input_id },
                |m: &mut GetAnnotationRequest| { &mut m.input_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAnnotationRequest>(
                "GetAnnotationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAnnotationRequest {
        static instance: ::protobuf::rt::LazyV2<GetAnnotationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAnnotationRequest::new)
    }
}

impl ::protobuf::Clear for GetAnnotationRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotation_id.clear();
        self.input_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAnnotationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub input_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub model_version_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub statuses: ::protobuf::RepeatedField<super::status::Status>,
    pub list_all_annotations: bool,
    pub return_model_output: bool,
    pub page: u32,
    pub per_page: u32,
    pub task_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAnnotationsRequest {
    fn default() -> &'a ListAnnotationsRequest {
        <ListAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationsRequest {
    pub fn new() -> ListAnnotationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // repeated string input_ids = 3;


    pub fn get_input_ids(&self) -> &[::std::string::String] {
        &self.input_ids
    }
    pub fn clear_input_ids(&mut self) {
        self.input_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input_ids
    }

    // Take field
    pub fn take_input_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string user_ids = 9;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string model_version_ids = 10;


    pub fn get_model_version_ids(&self) -> &[::std::string::String] {
        &self.model_version_ids
    }
    pub fn clear_model_version_ids(&mut self) {
        self.model_version_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.model_version_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_version_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.model_version_ids
    }

    // Take field
    pub fn take_model_version_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.model_version_ids, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.status.Status statuses = 5;


    pub fn get_statuses(&self) -> &[super::status::Status] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<super::status::Status>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<super::status::Status> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<super::status::Status> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }

    // bool list_all_annotations = 6;


    pub fn get_list_all_annotations(&self) -> bool {
        self.list_all_annotations
    }
    pub fn clear_list_all_annotations(&mut self) {
        self.list_all_annotations = false;
    }

    // Param is passed by value, moved
    pub fn set_list_all_annotations(&mut self, v: bool) {
        self.list_all_annotations = v;
    }

    // bool return_model_output = 12;


    pub fn get_return_model_output(&self) -> bool {
        self.return_model_output
    }
    pub fn clear_return_model_output(&mut self) {
        self.return_model_output = false;
    }

    // Param is passed by value, moved
    pub fn set_return_model_output(&mut self, v: bool) {
        self.return_model_output = v;
    }

    // uint32 page = 7;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 8;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // string task_id = 11;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAnnotationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input_ids)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.model_version_ids)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.list_all_annotations = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_model_output = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.model_version_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.list_all_annotations != false {
            my_size += 2;
        }
        if self.return_model_output != false {
            my_size += 2;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(7, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(8, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.user_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.model_version_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.statuses {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.list_all_annotations != false {
            os.write_bool(6, self.list_all_annotations)?;
        }
        if self.return_model_output != false {
            os.write_bool(12, self.return_model_output)?;
        }
        if self.page != 0 {
            os.write_uint32(7, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(8, self.per_page)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(11, &self.task_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAnnotationsRequest {
        ListAnnotationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAnnotationsRequest| { &m.user_app_id },
                |m: &mut ListAnnotationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &ListAnnotationsRequest| { &m.ids },
                |m: &mut ListAnnotationsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_ids",
                |m: &ListAnnotationsRequest| { &m.input_ids },
                |m: &mut ListAnnotationsRequest| { &mut m.input_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &ListAnnotationsRequest| { &m.user_ids },
                |m: &mut ListAnnotationsRequest| { &mut m.user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_ids",
                |m: &ListAnnotationsRequest| { &m.model_version_ids },
                |m: &mut ListAnnotationsRequest| { &mut m.model_version_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "statuses",
                |m: &ListAnnotationsRequest| { &m.statuses },
                |m: &mut ListAnnotationsRequest| { &mut m.statuses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "list_all_annotations",
                |m: &ListAnnotationsRequest| { &m.list_all_annotations },
                |m: &mut ListAnnotationsRequest| { &mut m.list_all_annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "return_model_output",
                |m: &ListAnnotationsRequest| { &m.return_model_output },
                |m: &mut ListAnnotationsRequest| { &mut m.return_model_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListAnnotationsRequest| { &m.page },
                |m: &mut ListAnnotationsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListAnnotationsRequest| { &m.per_page },
                |m: &mut ListAnnotationsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &ListAnnotationsRequest| { &m.task_id },
                |m: &mut ListAnnotationsRequest| { &mut m.task_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAnnotationsRequest>(
                "ListAnnotationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAnnotationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAnnotationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAnnotationsRequest::new)
    }
}

impl ::protobuf::Clear for ListAnnotationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.user_ids.clear();
        self.model_version_ids.clear();
        self.statuses.clear();
        self.list_all_annotations = false;
        self.return_model_output = false;
        self.page = 0;
        self.per_page = 0;
        self.task_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAnnotationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub annotations: ::protobuf::RepeatedField<super::resources::Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsRequest {
    fn default() -> &'a PostAnnotationsRequest {
        <PostAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsRequest {
    pub fn new() -> PostAnnotationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Annotation annotations = 2;


    pub fn get_annotations(&self) -> &[super::resources::Annotation] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<super::resources::Annotation>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Annotation> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<super::resources::Annotation> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostAnnotationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAnnotationsRequest {
        PostAnnotationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAnnotationsRequest| { &m.user_app_id },
                |m: &mut PostAnnotationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Annotation>>(
                "annotations",
                |m: &PostAnnotationsRequest| { &m.annotations },
                |m: &mut PostAnnotationsRequest| { &mut m.annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAnnotationsRequest>(
                "PostAnnotationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAnnotationsRequest {
        static instance: ::protobuf::rt::LazyV2<PostAnnotationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAnnotationsRequest::new)
    }
}

impl ::protobuf::Clear for PostAnnotationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAnnotationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub annotations: ::protobuf::RepeatedField<super::resources::Annotation>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsRequest {
    fn default() -> &'a PatchAnnotationsRequest {
        <PatchAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsRequest {
    pub fn new() -> PatchAnnotationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Annotation annotations = 2;


    pub fn get_annotations(&self) -> &[super::resources::Annotation] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<super::resources::Annotation>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Annotation> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<super::resources::Annotation> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchAnnotationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotations)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAnnotationsRequest {
        PatchAnnotationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchAnnotationsRequest| { &m.user_app_id },
                |m: &mut PatchAnnotationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Annotation>>(
                "annotations",
                |m: &PatchAnnotationsRequest| { &m.annotations },
                |m: &mut PatchAnnotationsRequest| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchAnnotationsRequest| { &m.action },
                |m: &mut PatchAnnotationsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAnnotationsRequest>(
                "PatchAnnotationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAnnotationsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchAnnotationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAnnotationsRequest::new)
    }
}

impl ::protobuf::Clear for PatchAnnotationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.annotations.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAnnotationsStatusRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub status_code: super::status_code::StatusCode,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub task_id: ::std::string::String,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusRequest {
    fn default() -> &'a PatchAnnotationsStatusRequest {
        <PatchAnnotationsStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusRequest {
    pub fn new() -> PatchAnnotationsStatusRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.status.StatusCode status_code = 2;


    pub fn get_status_code(&self) -> super::status_code::StatusCode {
        self.status_code
    }
    pub fn clear_status_code(&mut self) {
        self.status_code = super::status_code::StatusCode::ZERO;
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: super::status_code::StatusCode) {
        self.status_code = v;
    }

    // repeated string user_ids = 3;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    // string task_id = 4;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    // string action = 5;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status_code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.status_code != super::status_code::StatusCode::ZERO {
            my_size += ::protobuf::rt::enum_size(2, self.status_code);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.task_id);
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.status_code != super::status_code::StatusCode::ZERO {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.status_code))?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        if !self.task_id.is_empty() {
            os.write_string(4, &self.task_id)?;
        }
        if !self.action.is_empty() {
            os.write_string(5, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAnnotationsStatusRequest {
        PatchAnnotationsStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchAnnotationsStatusRequest| { &m.user_app_id },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::status_code::StatusCode>>(
                "status_code",
                |m: &PatchAnnotationsStatusRequest| { &m.status_code },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.status_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &PatchAnnotationsStatusRequest| { &m.user_ids },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &PatchAnnotationsStatusRequest| { &m.task_id },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchAnnotationsStatusRequest| { &m.action },
                |m: &mut PatchAnnotationsStatusRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAnnotationsStatusRequest>(
                "PatchAnnotationsStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAnnotationsStatusRequest {
        static instance: ::protobuf::rt::LazyV2<PatchAnnotationsStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAnnotationsStatusRequest::new)
    }
}

impl ::protobuf::Clear for PatchAnnotationsStatusRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.status_code = super::status_code::StatusCode::ZERO;
        self.user_ids.clear();
        self.task_id.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAnnotationsStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAnnotationsStatusResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub updated_count: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsStatusResponse {
    fn default() -> &'a PatchAnnotationsStatusResponse {
        <PatchAnnotationsStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsStatusResponse {
    pub fn new() -> PatchAnnotationsStatusResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string user_ids = 2;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }

    // uint32 updated_count = 3;


    pub fn get_updated_count(&self) -> u32 {
        self.updated_count
    }
    pub fn clear_updated_count(&mut self) {
        self.updated_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_count(&mut self, v: u32) {
        self.updated_count = v;
    }
}

impl ::protobuf::Message for PatchAnnotationsStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.updated_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.updated_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.updated_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.user_ids {
            os.write_string(2, &v)?;
        };
        if self.updated_count != 0 {
            os.write_uint32(3, self.updated_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAnnotationsStatusResponse {
        PatchAnnotationsStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &PatchAnnotationsStatusResponse| { &m.status },
                |m: &mut PatchAnnotationsStatusResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &PatchAnnotationsStatusResponse| { &m.user_ids },
                |m: &mut PatchAnnotationsStatusResponse| { &mut m.user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "updated_count",
                |m: &PatchAnnotationsStatusResponse| { &m.updated_count },
                |m: &mut PatchAnnotationsStatusResponse| { &mut m.updated_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAnnotationsStatusResponse>(
                "PatchAnnotationsStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAnnotationsStatusResponse {
        static instance: ::protobuf::rt::LazyV2<PatchAnnotationsStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAnnotationsStatusResponse::new)
    }
}

impl ::protobuf::Clear for PatchAnnotationsStatusResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.user_ids.clear();
        self.updated_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAnnotationsStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAnnotationRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub input_id: ::std::string::String,
    pub annotation_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationRequest {
    fn default() -> &'a DeleteAnnotationRequest {
        <DeleteAnnotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationRequest {
    pub fn new() -> DeleteAnnotationRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string input_id = 2;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }

    // string annotation_id = 3;


    pub fn get_annotation_id(&self) -> &str {
        &self.annotation_id
    }
    pub fn clear_annotation_id(&mut self) {
        self.annotation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_id(&mut self, v: ::std::string::String) {
        self.annotation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation_id(&mut self) -> &mut ::std::string::String {
        &mut self.annotation_id
    }

    // Take field
    pub fn take_annotation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.annotation_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteAnnotationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.annotation_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        if !self.annotation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.annotation_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        if !self.annotation_id.is_empty() {
            os.write_string(3, &self.annotation_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAnnotationRequest {
        DeleteAnnotationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteAnnotationRequest| { &m.user_app_id },
                |m: &mut DeleteAnnotationRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &DeleteAnnotationRequest| { &m.input_id },
                |m: &mut DeleteAnnotationRequest| { &mut m.input_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "annotation_id",
                |m: &DeleteAnnotationRequest| { &m.annotation_id },
                |m: &mut DeleteAnnotationRequest| { &mut m.annotation_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAnnotationRequest>(
                "DeleteAnnotationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAnnotationRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAnnotationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAnnotationRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAnnotationRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.annotation_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAnnotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAnnotationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub input_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationsRequest {
    fn default() -> &'a DeleteAnnotationsRequest {
        <DeleteAnnotationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationsRequest {
    pub fn new() -> DeleteAnnotationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // repeated string input_ids = 3;


    pub fn get_input_ids(&self) -> &[::std::string::String] {
        &self.input_ids
    }
    pub fn clear_input_ids(&mut self) {
        self.input_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input_ids
    }

    // Take field
    pub fn take_input_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteAnnotationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.input_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        for v in &self.input_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAnnotationsRequest {
        DeleteAnnotationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteAnnotationsRequest| { &m.user_app_id },
                |m: &mut DeleteAnnotationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteAnnotationsRequest| { &m.ids },
                |m: &mut DeleteAnnotationsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_ids",
                |m: &DeleteAnnotationsRequest| { &m.input_ids },
                |m: &mut DeleteAnnotationsRequest| { &mut m.input_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAnnotationsRequest>(
                "DeleteAnnotationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAnnotationsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAnnotationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAnnotationsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAnnotationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.input_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAnnotationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleAnnotationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub annotation: ::protobuf::SingularPtrField<super::resources::Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleAnnotationResponse {
    fn default() -> &'a SingleAnnotationResponse {
        <SingleAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAnnotationResponse {
    pub fn new() -> SingleAnnotationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Annotation annotation = 2;


    pub fn get_annotation(&self) -> &super::resources::Annotation {
        self.annotation.as_ref().unwrap_or_else(|| <super::resources::Annotation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_annotation(&mut self) {
        self.annotation.clear();
    }

    pub fn has_annotation(&self) -> bool {
        self.annotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: super::resources::Annotation) {
        self.annotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_annotation(&mut self) -> &mut super::resources::Annotation {
        if self.annotation.is_none() {
            self.annotation.set_default();
        }
        self.annotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_annotation(&mut self) -> super::resources::Annotation {
        self.annotation.take().unwrap_or_else(|| super::resources::Annotation::new())
    }
}

impl ::protobuf::Message for SingleAnnotationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.annotation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleAnnotationResponse {
        SingleAnnotationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleAnnotationResponse| { &m.status },
                |m: &mut SingleAnnotationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Annotation>>(
                "annotation",
                |m: &SingleAnnotationResponse| { &m.annotation },
                |m: &mut SingleAnnotationResponse| { &mut m.annotation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleAnnotationResponse>(
                "SingleAnnotationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleAnnotationResponse {
        static instance: ::protobuf::rt::LazyV2<SingleAnnotationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleAnnotationResponse::new)
    }
}

impl ::protobuf::Clear for SingleAnnotationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.annotation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAnnotationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiAnnotationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub annotations: ::protobuf::RepeatedField<super::resources::Annotation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationResponse {
    fn default() -> &'a MultiAnnotationResponse {
        <MultiAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationResponse {
    pub fn new() -> MultiAnnotationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Annotation annotations = 2;


    pub fn get_annotations(&self) -> &[super::resources::Annotation] {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::protobuf::RepeatedField<super::resources::Annotation>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Annotation> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::protobuf::RepeatedField<super::resources::Annotation> {
        ::std::mem::replace(&mut self.annotations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiAnnotationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiAnnotationResponse {
        MultiAnnotationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiAnnotationResponse| { &m.status },
                |m: &mut MultiAnnotationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Annotation>>(
                "annotations",
                |m: &MultiAnnotationResponse| { &m.annotations },
                |m: &mut MultiAnnotationResponse| { &mut m.annotations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiAnnotationResponse>(
                "MultiAnnotationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiAnnotationResponse {
        static instance: ::protobuf::rt::LazyV2<MultiAnnotationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiAnnotationResponse::new)
    }
}

impl ::protobuf::Clear for MultiAnnotationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.annotations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAppRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub additional_fields: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAppRequest {
    fn default() -> &'a GetAppRequest {
        <GetAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppRequest {
    pub fn new() -> GetAppRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string additional_fields = 2;


    pub fn get_additional_fields(&self) -> &[::std::string::String] {
        &self.additional_fields
    }
    pub fn clear_additional_fields(&mut self) {
        self.additional_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.additional_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.additional_fields
    }

    // Take field
    pub fn take_additional_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.additional_fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetAppRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.additional_fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.additional_fields {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAppRequest {
        GetAppRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetAppRequest| { &m.user_app_id },
                |m: &mut GetAppRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "additional_fields",
                |m: &GetAppRequest| { &m.additional_fields },
                |m: &mut GetAppRequest| { &mut m.additional_fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAppRequest>(
                "GetAppRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAppRequest {
        static instance: ::protobuf::rt::LazyV2<GetAppRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAppRequest::new)
    }
}

impl ::protobuf::Clear for GetAppRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.additional_fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAppsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    pub sort_ascending: bool,
    pub query: ::std::string::String,
    pub name: ::std::string::String,
    pub featured_only: bool,
    pub starred_only: bool,
    pub additional_fields: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub sort_by: ::std::option::Option<ListAppsRequest_oneof_sort_by>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAppsRequest {
    fn default() -> &'a ListAppsRequest {
        <ListAppsRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ListAppsRequest_oneof_sort_by {
    sort_by_name(bool),
    sort_by_modified_at(bool),
}

impl ListAppsRequest {
    pub fn new() -> ListAppsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // bool sort_ascending = 5;


    pub fn get_sort_ascending(&self) -> bool {
        self.sort_ascending
    }
    pub fn clear_sort_ascending(&mut self) {
        self.sort_ascending = false;
    }

    // Param is passed by value, moved
    pub fn set_sort_ascending(&mut self, v: bool) {
        self.sort_ascending = v;
    }

    // bool sort_by_name = 6;


    pub fn get_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListAppsRequest_oneof_sort_by::sort_by_name(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sort_by_name(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListAppsRequest_oneof_sort_by::sort_by_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_name(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(ListAppsRequest_oneof_sort_by::sort_by_name(v))
    }

    // bool sort_by_modified_at = 7;


    pub fn get_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListAppsRequest_oneof_sort_by::sort_by_modified_at(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListAppsRequest_oneof_sort_by::sort_by_modified_at(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(ListAppsRequest_oneof_sort_by::sort_by_modified_at(v))
    }

    // string query = 8;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool featured_only = 9;


    pub fn get_featured_only(&self) -> bool {
        self.featured_only
    }
    pub fn clear_featured_only(&mut self) {
        self.featured_only = false;
    }

    // Param is passed by value, moved
    pub fn set_featured_only(&mut self, v: bool) {
        self.featured_only = v;
    }

    // bool starred_only = 11;


    pub fn get_starred_only(&self) -> bool {
        self.starred_only
    }
    pub fn clear_starred_only(&mut self) {
        self.starred_only = false;
    }

    // Param is passed by value, moved
    pub fn set_starred_only(&mut self, v: bool) {
        self.starred_only = v;
    }

    // repeated string additional_fields = 10;


    pub fn get_additional_fields(&self) -> &[::std::string::String] {
        &self.additional_fields
    }
    pub fn clear_additional_fields(&mut self) {
        self.additional_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.additional_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.additional_fields
    }

    // Take field
    pub fn take_additional_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.additional_fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListAppsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sort_ascending = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sort_by = ::std::option::Option::Some(ListAppsRequest_oneof_sort_by::sort_by_name(is.read_bool()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sort_by = ::std::option::Option::Some(ListAppsRequest_oneof_sort_by::sort_by_modified_at(is.read_bool()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.featured_only = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.starred_only = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.additional_fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sort_ascending != false {
            my_size += 2;
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.query);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if self.featured_only != false {
            my_size += 2;
        }
        if self.starred_only != false {
            my_size += 2;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &ListAppsRequest_oneof_sort_by::sort_by_name(v) => {
                    my_size += 2;
                },
                &ListAppsRequest_oneof_sort_by::sort_by_modified_at(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(5, self.sort_ascending)?;
        }
        if !self.query.is_empty() {
            os.write_string(8, &self.query)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if self.featured_only != false {
            os.write_bool(9, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(11, self.starred_only)?;
        }
        for v in &self.additional_fields {
            os.write_string(10, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &ListAppsRequest_oneof_sort_by::sort_by_name(v) => {
                    os.write_bool(6, v)?;
                },
                &ListAppsRequest_oneof_sort_by::sort_by_modified_at(v) => {
                    os.write_bool(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAppsRequest {
        ListAppsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAppsRequest| { &m.user_app_id },
                |m: &mut ListAppsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListAppsRequest| { &m.page },
                |m: &mut ListAppsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListAppsRequest| { &m.per_page },
                |m: &mut ListAppsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sort_ascending",
                |m: &ListAppsRequest| { &m.sort_ascending },
                |m: &mut ListAppsRequest| { &mut m.sort_ascending },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sort_by_name",
                ListAppsRequest::has_sort_by_name,
                ListAppsRequest::get_sort_by_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sort_by_modified_at",
                ListAppsRequest::has_sort_by_modified_at,
                ListAppsRequest::get_sort_by_modified_at,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &ListAppsRequest| { &m.query },
                |m: &mut ListAppsRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListAppsRequest| { &m.name },
                |m: &mut ListAppsRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "featured_only",
                |m: &ListAppsRequest| { &m.featured_only },
                |m: &mut ListAppsRequest| { &mut m.featured_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "starred_only",
                |m: &ListAppsRequest| { &m.starred_only },
                |m: &mut ListAppsRequest| { &mut m.starred_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "additional_fields",
                |m: &ListAppsRequest| { &m.additional_fields },
                |m: &mut ListAppsRequest| { &mut m.additional_fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAppsRequest>(
                "ListAppsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAppsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAppsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAppsRequest::new)
    }
}

impl ::protobuf::Clear for ListAppsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.query.clear();
        self.name.clear();
        self.featured_only = false;
        self.starred_only = false;
        self.additional_fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAppsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub apps: ::protobuf::RepeatedField<super::resources::App>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAppsRequest {
    fn default() -> &'a PostAppsRequest {
        <PostAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsRequest {
    pub fn new() -> PostAppsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.App apps = 2;


    pub fn get_apps(&self) -> &[super::resources::App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<super::resources::App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<super::resources::App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostAppsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.apps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAppsRequest {
        PostAppsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAppsRequest| { &m.user_app_id },
                |m: &mut PostAppsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "apps",
                |m: &PostAppsRequest| { &m.apps },
                |m: &mut PostAppsRequest| { &mut m.apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAppsRequest>(
                "PostAppsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAppsRequest {
        static instance: ::protobuf::rt::LazyV2<PostAppsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAppsRequest::new)
    }
}

impl ::protobuf::Clear for PostAppsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAppRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAppRequest {
    fn default() -> &'a DeleteAppRequest {
        <DeleteAppRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAppRequest {
    pub fn new() -> DeleteAppRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for DeleteAppRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAppRequest {
        DeleteAppRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteAppRequest| { &m.user_app_id },
                |m: &mut DeleteAppRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAppRequest>(
                "DeleteAppRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAppRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAppRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAppRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAppRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAppRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAppRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAppsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub apps: ::protobuf::RepeatedField<super::resources::App>,
    pub action: ::std::string::String,
    pub metadata_action: ::protobuf::SingularPtrField<super::resources::PatchAction>,
    pub reindex: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAppsRequest {
    fn default() -> &'a PatchAppsRequest {
        <PatchAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAppsRequest {
    pub fn new() -> PatchAppsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.App apps = 2;


    pub fn get_apps(&self) -> &[super::resources::App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<super::resources::App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<super::resources::App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }

    // .clarifai.api.PatchAction metadata_action = 4;


    pub fn get_metadata_action(&self) -> &super::resources::PatchAction {
        self.metadata_action.as_ref().unwrap_or_else(|| <super::resources::PatchAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_action(&mut self) {
        self.metadata_action.clear();
    }

    pub fn has_metadata_action(&self) -> bool {
        self.metadata_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_action(&mut self, v: super::resources::PatchAction) {
        self.metadata_action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_action(&mut self) -> &mut super::resources::PatchAction {
        if self.metadata_action.is_none() {
            self.metadata_action.set_default();
        }
        self.metadata_action.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_action(&mut self) -> super::resources::PatchAction {
        self.metadata_action.take().unwrap_or_else(|| super::resources::PatchAction::new())
    }

    // bool reindex = 5;


    pub fn get_reindex(&self) -> bool {
        self.reindex
    }
    pub fn clear_reindex(&mut self) {
        self.reindex = false;
    }

    // Param is passed by value, moved
    pub fn set_reindex(&mut self, v: bool) {
        self.reindex = v;
    }
}

impl ::protobuf::Message for PatchAppsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata_action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_action)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reindex = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        if let Some(ref v) = self.metadata_action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.reindex != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.apps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        if let Some(ref v) = self.metadata_action.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.reindex != false {
            os.write_bool(5, self.reindex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAppsRequest {
        PatchAppsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchAppsRequest| { &m.user_app_id },
                |m: &mut PatchAppsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "apps",
                |m: &PatchAppsRequest| { &m.apps },
                |m: &mut PatchAppsRequest| { &mut m.apps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchAppsRequest| { &m.action },
                |m: &mut PatchAppsRequest| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::PatchAction>>(
                "metadata_action",
                |m: &PatchAppsRequest| { &m.metadata_action },
                |m: &mut PatchAppsRequest| { &mut m.metadata_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reindex",
                |m: &PatchAppsRequest| { &m.reindex },
                |m: &mut PatchAppsRequest| { &mut m.reindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAppsRequest>(
                "PatchAppsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAppsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchAppsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAppsRequest::new)
    }
}

impl ::protobuf::Clear for PatchAppsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.apps.clear();
        self.action.clear();
        self.metadata_action.clear();
        self.reindex = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAppsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAppsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub app_query: ::protobuf::SingularPtrField<super::resources::AppQuery>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAppsSearchesRequest {
    fn default() -> &'a PostAppsSearchesRequest {
        <PostAppsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppsSearchesRequest {
    pub fn new() -> PostAppsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.AppQuery app_query = 2;


    pub fn get_app_query(&self) -> &super::resources::AppQuery {
        self.app_query.as_ref().unwrap_or_else(|| <super::resources::AppQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app_query(&mut self) {
        self.app_query.clear();
    }

    pub fn has_app_query(&self) -> bool {
        self.app_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_query(&mut self, v: super::resources::AppQuery) {
        self.app_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_query(&mut self) -> &mut super::resources::AppQuery {
        if self.app_query.is_none() {
            self.app_query.set_default();
        }
        self.app_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_query(&mut self) -> super::resources::AppQuery {
        self.app_query.take().unwrap_or_else(|| super::resources::AppQuery::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostAppsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.app_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.app_query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAppsSearchesRequest {
        PostAppsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAppsSearchesRequest| { &m.user_app_id },
                |m: &mut PostAppsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AppQuery>>(
                "app_query",
                |m: &PostAppsSearchesRequest| { &m.app_query },
                |m: &mut PostAppsSearchesRequest| { &mut m.app_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostAppsSearchesRequest| { &m.pagination },
                |m: &mut PostAppsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAppsSearchesRequest>(
                "PostAppsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAppsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostAppsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAppsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostAppsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_query.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAppsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleAppResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub app: ::protobuf::SingularPtrField<super::resources::App>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleAppResponse {
    fn default() -> &'a SingleAppResponse {
        <SingleAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppResponse {
    pub fn new() -> SingleAppResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.App app = 2;


    pub fn get_app(&self) -> &super::resources::App {
        self.app.as_ref().unwrap_or_else(|| <super::resources::App as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: super::resources::App) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut super::resources::App {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> super::resources::App {
        self.app.take().unwrap_or_else(|| super::resources::App::new())
    }
}

impl ::protobuf::Message for SingleAppResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleAppResponse {
        SingleAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleAppResponse| { &m.status },
                |m: &mut SingleAppResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "app",
                |m: &SingleAppResponse| { &m.app },
                |m: &mut SingleAppResponse| { &mut m.app },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleAppResponse>(
                "SingleAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleAppResponse {
        static instance: ::protobuf::rt::LazyV2<SingleAppResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleAppResponse::new)
    }
}

impl ::protobuf::Clear for SingleAppResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.app.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiAppResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub apps: ::protobuf::RepeatedField<super::resources::App>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiAppResponse {
    fn default() -> &'a MultiAppResponse {
        <MultiAppResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppResponse {
    pub fn new() -> MultiAppResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.App apps = 2;


    pub fn get_apps(&self) -> &[super::resources::App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<super::resources::App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<super::resources::App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiAppResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.apps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiAppResponse {
        MultiAppResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiAppResponse| { &m.status },
                |m: &mut MultiAppResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "apps",
                |m: &MultiAppResponse| { &m.apps },
                |m: &mut MultiAppResponse| { &mut m.apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiAppResponse>(
                "MultiAppResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiAppResponse {
        static instance: ::protobuf::rt::LazyV2<MultiAppResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiAppResponse::new)
    }
}

impl ::protobuf::Clear for MultiAppResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCollaboratorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub list_all_collaborators: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCollaboratorsRequest {
    fn default() -> &'a ListCollaboratorsRequest {
        <ListCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaboratorsRequest {
    pub fn new() -> ListCollaboratorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // bool list_all_collaborators = 2;


    pub fn get_list_all_collaborators(&self) -> bool {
        self.list_all_collaborators
    }
    pub fn clear_list_all_collaborators(&mut self) {
        self.list_all_collaborators = false;
    }

    // Param is passed by value, moved
    pub fn set_list_all_collaborators(&mut self, v: bool) {
        self.list_all_collaborators = v;
    }
}

impl ::protobuf::Message for ListCollaboratorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.list_all_collaborators = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.list_all_collaborators != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.list_all_collaborators != false {
            os.write_bool(2, self.list_all_collaborators)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCollaboratorsRequest {
        ListCollaboratorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListCollaboratorsRequest| { &m.user_app_id },
                |m: &mut ListCollaboratorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "list_all_collaborators",
                |m: &ListCollaboratorsRequest| { &m.list_all_collaborators },
                |m: &mut ListCollaboratorsRequest| { &mut m.list_all_collaborators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCollaboratorsRequest>(
                "ListCollaboratorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCollaboratorsRequest {
        static instance: ::protobuf::rt::LazyV2<ListCollaboratorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCollaboratorsRequest::new)
    }
}

impl ::protobuf::Clear for ListCollaboratorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.list_all_collaborators = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaboratorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostCollaboratorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collaborators: ::protobuf::RepeatedField<super::resources::Collaborator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostCollaboratorsRequest {
    fn default() -> &'a PostCollaboratorsRequest {
        <PostCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollaboratorsRequest {
    pub fn new() -> PostCollaboratorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Collaborator collaborators = 2;


    pub fn get_collaborators(&self) -> &[super::resources::Collaborator] {
        &self.collaborators
    }
    pub fn clear_collaborators(&mut self) {
        self.collaborators.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborators(&mut self, v: ::protobuf::RepeatedField<super::resources::Collaborator>) {
        self.collaborators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborators(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collaborator> {
        &mut self.collaborators
    }

    // Take field
    pub fn take_collaborators(&mut self) -> ::protobuf::RepeatedField<super::resources::Collaborator> {
        ::std::mem::replace(&mut self.collaborators, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostCollaboratorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collaborators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collaborators)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostCollaboratorsRequest {
        PostCollaboratorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostCollaboratorsRequest| { &m.user_app_id },
                |m: &mut PostCollaboratorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collaborator>>(
                "collaborators",
                |m: &PostCollaboratorsRequest| { &m.collaborators },
                |m: &mut PostCollaboratorsRequest| { &mut m.collaborators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostCollaboratorsRequest>(
                "PostCollaboratorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostCollaboratorsRequest {
        static instance: ::protobuf::rt::LazyV2<PostCollaboratorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostCollaboratorsRequest::new)
    }
}

impl ::protobuf::Clear for PostCollaboratorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollaboratorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchCollaboratorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collaborators: ::protobuf::RepeatedField<super::resources::Collaborator>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchCollaboratorsRequest {
    fn default() -> &'a PatchCollaboratorsRequest {
        <PatchCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollaboratorsRequest {
    pub fn new() -> PatchCollaboratorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Collaborator collaborators = 2;


    pub fn get_collaborators(&self) -> &[super::resources::Collaborator] {
        &self.collaborators
    }
    pub fn clear_collaborators(&mut self) {
        self.collaborators.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborators(&mut self, v: ::protobuf::RepeatedField<super::resources::Collaborator>) {
        self.collaborators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborators(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collaborator> {
        &mut self.collaborators
    }

    // Take field
    pub fn take_collaborators(&mut self) -> ::protobuf::RepeatedField<super::resources::Collaborator> {
        ::std::mem::replace(&mut self.collaborators, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchCollaboratorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collaborators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collaborators)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchCollaboratorsRequest {
        PatchCollaboratorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchCollaboratorsRequest| { &m.user_app_id },
                |m: &mut PatchCollaboratorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collaborator>>(
                "collaborators",
                |m: &PatchCollaboratorsRequest| { &m.collaborators },
                |m: &mut PatchCollaboratorsRequest| { &mut m.collaborators },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchCollaboratorsRequest| { &m.action },
                |m: &mut PatchCollaboratorsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchCollaboratorsRequest>(
                "PatchCollaboratorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchCollaboratorsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchCollaboratorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchCollaboratorsRequest::new)
    }
}

impl ::protobuf::Clear for PatchCollaboratorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborators.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollaboratorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteCollaboratorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collaborator_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub user_emails: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteCollaboratorsRequest {
    fn default() -> &'a DeleteCollaboratorsRequest {
        <DeleteCollaboratorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollaboratorsRequest {
    pub fn new() -> DeleteCollaboratorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string collaborator_ids = 2;


    pub fn get_collaborator_ids(&self) -> &[::std::string::String] {
        &self.collaborator_ids
    }
    pub fn clear_collaborator_ids(&mut self) {
        self.collaborator_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborator_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.collaborator_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborator_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.collaborator_ids
    }

    // Take field
    pub fn take_collaborator_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.collaborator_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string user_emails = 3;


    pub fn get_user_emails(&self) -> &[::std::string::String] {
        &self.user_emails
    }
    pub fn clear_user_emails(&mut self) {
        self.user_emails.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_emails(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_emails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_emails(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_emails
    }

    // Take field
    pub fn take_user_emails(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_emails, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteCollaboratorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.collaborator_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_emails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborator_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.user_emails {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborator_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.user_emails {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteCollaboratorsRequest {
        DeleteCollaboratorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteCollaboratorsRequest| { &m.user_app_id },
                |m: &mut DeleteCollaboratorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "collaborator_ids",
                |m: &DeleteCollaboratorsRequest| { &m.collaborator_ids },
                |m: &mut DeleteCollaboratorsRequest| { &mut m.collaborator_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_emails",
                |m: &DeleteCollaboratorsRequest| { &m.user_emails },
                |m: &mut DeleteCollaboratorsRequest| { &mut m.user_emails },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteCollaboratorsRequest>(
                "DeleteCollaboratorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteCollaboratorsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteCollaboratorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteCollaboratorsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteCollaboratorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collaborator_ids.clear();
        self.user_emails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteCollaboratorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollaboratorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiCollaboratorsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub collaborators: ::protobuf::RepeatedField<super::resources::Collaborator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiCollaboratorsResponse {
    fn default() -> &'a MultiCollaboratorsResponse {
        <MultiCollaboratorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaboratorsResponse {
    pub fn new() -> MultiCollaboratorsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Collaborator collaborators = 2;


    pub fn get_collaborators(&self) -> &[super::resources::Collaborator] {
        &self.collaborators
    }
    pub fn clear_collaborators(&mut self) {
        self.collaborators.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborators(&mut self, v: ::protobuf::RepeatedField<super::resources::Collaborator>) {
        self.collaborators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborators(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collaborator> {
        &mut self.collaborators
    }

    // Take field
    pub fn take_collaborators(&mut self) -> ::protobuf::RepeatedField<super::resources::Collaborator> {
        ::std::mem::replace(&mut self.collaborators, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiCollaboratorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collaborators {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collaborators)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborators {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiCollaboratorsResponse {
        MultiCollaboratorsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiCollaboratorsResponse| { &m.status },
                |m: &mut MultiCollaboratorsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collaborator>>(
                "collaborators",
                |m: &MultiCollaboratorsResponse| { &m.collaborators },
                |m: &mut MultiCollaboratorsResponse| { &mut m.collaborators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiCollaboratorsResponse>(
                "MultiCollaboratorsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiCollaboratorsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiCollaboratorsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiCollaboratorsResponse::new)
    }
}

impl ::protobuf::Clear for MultiCollaboratorsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.collaborators.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiCollaboratorsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaboratorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCollaborationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCollaborationsRequest {
    fn default() -> &'a ListCollaborationsRequest {
        <ListCollaborationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollaborationsRequest {
    pub fn new() -> ListCollaborationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListCollaborationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCollaborationsRequest {
        ListCollaborationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListCollaborationsRequest| { &m.user_app_id },
                |m: &mut ListCollaborationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListCollaborationsRequest| { &m.page },
                |m: &mut ListCollaborationsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListCollaborationsRequest| { &m.per_page },
                |m: &mut ListCollaborationsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCollaborationsRequest>(
                "ListCollaborationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCollaborationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListCollaborationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCollaborationsRequest::new)
    }
}

impl ::protobuf::Clear for ListCollaborationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCollaborationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollaborationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiCollaborationsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub collaborations: ::protobuf::RepeatedField<super::resources::Collaboration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiCollaborationsResponse {
    fn default() -> &'a MultiCollaborationsResponse {
        <MultiCollaborationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollaborationsResponse {
    pub fn new() -> MultiCollaborationsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Collaboration collaborations = 2;


    pub fn get_collaborations(&self) -> &[super::resources::Collaboration] {
        &self.collaborations
    }
    pub fn clear_collaborations(&mut self) {
        self.collaborations.clear();
    }

    // Param is passed by value, moved
    pub fn set_collaborations(&mut self, v: ::protobuf::RepeatedField<super::resources::Collaboration>) {
        self.collaborations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collaborations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collaboration> {
        &mut self.collaborations
    }

    // Take field
    pub fn take_collaborations(&mut self) -> ::protobuf::RepeatedField<super::resources::Collaboration> {
        ::std::mem::replace(&mut self.collaborations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiCollaborationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collaborations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collaborations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collaborations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collaborations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiCollaborationsResponse {
        MultiCollaborationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiCollaborationsResponse| { &m.status },
                |m: &mut MultiCollaborationsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collaboration>>(
                "collaborations",
                |m: &MultiCollaborationsResponse| { &m.collaborations },
                |m: &mut MultiCollaborationsResponse| { &mut m.collaborations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiCollaborationsResponse>(
                "MultiCollaborationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiCollaborationsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiCollaborationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiCollaborationsResponse::new)
    }
}

impl ::protobuf::Clear for MultiCollaborationsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.collaborations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiCollaborationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollaborationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStatusCodeRequest {
    // message fields
    pub status_code_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStatusCodeRequest {
    fn default() -> &'a GetStatusCodeRequest {
        <GetStatusCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusCodeRequest {
    pub fn new() -> GetStatusCodeRequest {
        ::std::default::Default::default()
    }

    // string status_code_id = 1;


    pub fn get_status_code_id(&self) -> &str {
        &self.status_code_id
    }
    pub fn clear_status_code_id(&mut self) {
        self.status_code_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_code_id(&mut self, v: ::std::string::String) {
        self.status_code_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_code_id(&mut self) -> &mut ::std::string::String {
        &mut self.status_code_id
    }

    // Take field
    pub fn take_status_code_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_code_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetStatusCodeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_code_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status_code_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status_code_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status_code_id.is_empty() {
            os.write_string(1, &self.status_code_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStatusCodeRequest {
        GetStatusCodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_code_id",
                |m: &GetStatusCodeRequest| { &m.status_code_id },
                |m: &mut GetStatusCodeRequest| { &mut m.status_code_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStatusCodeRequest>(
                "GetStatusCodeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStatusCodeRequest {
        static instance: ::protobuf::rt::LazyV2<GetStatusCodeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStatusCodeRequest::new)
    }
}

impl ::protobuf::Clear for GetStatusCodeRequest {
    fn clear(&mut self) {
        self.status_code_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStatusCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusCodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListStatusCodesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListStatusCodesRequest {
    fn default() -> &'a ListStatusCodesRequest {
        <ListStatusCodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListStatusCodesRequest {
    pub fn new() -> ListStatusCodesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListStatusCodesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListStatusCodesRequest {
        ListStatusCodesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListStatusCodesRequest>(
                "ListStatusCodesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListStatusCodesRequest {
        static instance: ::protobuf::rt::LazyV2<ListStatusCodesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListStatusCodesRequest::new)
    }
}

impl ::protobuf::Clear for ListStatusCodesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListStatusCodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatusCodesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleStatusCodeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleStatusCodeResponse {
    fn default() -> &'a SingleStatusCodeResponse {
        <SingleStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleStatusCodeResponse {
    pub fn new() -> SingleStatusCodeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }
}

impl ::protobuf::Message for SingleStatusCodeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleStatusCodeResponse {
        SingleStatusCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleStatusCodeResponse| { &m.status },
                |m: &mut SingleStatusCodeResponse| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleStatusCodeResponse>(
                "SingleStatusCodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleStatusCodeResponse {
        static instance: ::protobuf::rt::LazyV2<SingleStatusCodeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleStatusCodeResponse::new)
    }
}

impl ::protobuf::Clear for SingleStatusCodeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleStatusCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiStatusCodeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub statuses: ::protobuf::RepeatedField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiStatusCodeResponse {
    fn default() -> &'a MultiStatusCodeResponse {
        <MultiStatusCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatusCodeResponse {
    pub fn new() -> MultiStatusCodeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.status.Status statuses = 2;


    pub fn get_statuses(&self) -> &[super::status::Status] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<super::status::Status>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<super::status::Status> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<super::status::Status> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiStatusCodeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.statuses {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiStatusCodeResponse {
        MultiStatusCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiStatusCodeResponse| { &m.status },
                |m: &mut MultiStatusCodeResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "statuses",
                |m: &MultiStatusCodeResponse| { &m.statuses },
                |m: &mut MultiStatusCodeResponse| { &mut m.statuses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiStatusCodeResponse>(
                "MultiStatusCodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiStatusCodeResponse {
        static instance: ::protobuf::rt::LazyV2<MultiStatusCodeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiStatusCodeResponse::new)
    }
}

impl ::protobuf::Clear for MultiStatusCodeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.statuses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiStatusCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatusCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConceptRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConceptRequest {
    fn default() -> &'a GetConceptRequest {
        <GetConceptRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptRequest {
    pub fn new() -> GetConceptRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetConceptRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConceptRequest {
        GetConceptRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetConceptRequest| { &m.user_app_id },
                |m: &mut GetConceptRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &GetConceptRequest| { &m.concept_id },
                |m: &mut GetConceptRequest| { &mut m.concept_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConceptRequest>(
                "GetConceptRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConceptRequest {
        static instance: ::protobuf::rt::LazyV2<GetConceptRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConceptRequest::new)
    }
}

impl ::protobuf::Clear for GetConceptRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConceptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListConceptsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListConceptsRequest {
    fn default() -> &'a ListConceptsRequest {
        <ListConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptsRequest {
    pub fn new() -> ListConceptsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListConceptsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListConceptsRequest {
        ListConceptsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListConceptsRequest| { &m.user_app_id },
                |m: &mut ListConceptsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListConceptsRequest| { &m.page },
                |m: &mut ListConceptsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListConceptsRequest| { &m.per_page },
                |m: &mut ListConceptsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListConceptsRequest>(
                "ListConceptsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListConceptsRequest {
        static instance: ::protobuf::rt::LazyV2<ListConceptsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListConceptsRequest::new)
    }
}

impl ::protobuf::Clear for ListConceptsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_query: ::protobuf::SingularPtrField<super::resources::ConceptQuery>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptsSearchesRequest {
    fn default() -> &'a PostConceptsSearchesRequest {
        <PostConceptsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsSearchesRequest {
    pub fn new() -> PostConceptsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.ConceptQuery concept_query = 2;


    pub fn get_concept_query(&self) -> &super::resources::ConceptQuery {
        self.concept_query.as_ref().unwrap_or_else(|| <super::resources::ConceptQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_concept_query(&mut self) {
        self.concept_query.clear();
    }

    pub fn has_concept_query(&self) -> bool {
        self.concept_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept_query(&mut self, v: super::resources::ConceptQuery) {
        self.concept_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_query(&mut self) -> &mut super::resources::ConceptQuery {
        if self.concept_query.is_none() {
            self.concept_query.set_default();
        }
        self.concept_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept_query(&mut self) -> super::resources::ConceptQuery {
        self.concept_query.take().unwrap_or_else(|| super::resources::ConceptQuery::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostConceptsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.concept_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.concept_query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptsSearchesRequest {
        PostConceptsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptsSearchesRequest| { &m.user_app_id },
                |m: &mut PostConceptsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptQuery>>(
                "concept_query",
                |m: &PostConceptsSearchesRequest| { &m.concept_query },
                |m: &mut PostConceptsSearchesRequest| { &mut m.concept_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostConceptsSearchesRequest| { &m.pagination },
                |m: &mut PostConceptsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptsSearchesRequest>(
                "PostConceptsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_query.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concepts: ::protobuf::RepeatedField<super::resources::Concept>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptsRequest {
    fn default() -> &'a PostConceptsRequest {
        <PostConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptsRequest {
    pub fn new() -> PostConceptsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Concept concepts = 2;


    pub fn get_concepts(&self) -> &[super::resources::Concept] {
        &self.concepts
    }
    pub fn clear_concepts(&mut self) {
        self.concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concepts(&mut self, v: ::protobuf::RepeatedField<super::resources::Concept>) {
        self.concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concepts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Concept> {
        &mut self.concepts
    }

    // Take field
    pub fn take_concepts(&mut self) -> ::protobuf::RepeatedField<super::resources::Concept> {
        ::std::mem::replace(&mut self.concepts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostConceptsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concepts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concepts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptsRequest {
        PostConceptsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptsRequest| { &m.user_app_id },
                |m: &mut PostConceptsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Concept>>(
                "concepts",
                |m: &PostConceptsRequest| { &m.concepts },
                |m: &mut PostConceptsRequest| { &mut m.concepts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptsRequest>(
                "PostConceptsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptsRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptsRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchConceptsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concepts: ::protobuf::RepeatedField<super::resources::Concept>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchConceptsRequest {
    fn default() -> &'a PatchConceptsRequest {
        <PatchConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptsRequest {
    pub fn new() -> PatchConceptsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Concept concepts = 2;


    pub fn get_concepts(&self) -> &[super::resources::Concept] {
        &self.concepts
    }
    pub fn clear_concepts(&mut self) {
        self.concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concepts(&mut self, v: ::protobuf::RepeatedField<super::resources::Concept>) {
        self.concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concepts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Concept> {
        &mut self.concepts
    }

    // Take field
    pub fn take_concepts(&mut self) -> ::protobuf::RepeatedField<super::resources::Concept> {
        ::std::mem::replace(&mut self.concepts, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchConceptsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concepts)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concepts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchConceptsRequest {
        PatchConceptsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchConceptsRequest| { &m.user_app_id },
                |m: &mut PatchConceptsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Concept>>(
                "concepts",
                |m: &PatchConceptsRequest| { &m.concepts },
                |m: &mut PatchConceptsRequest| { &mut m.concepts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchConceptsRequest| { &m.action },
                |m: &mut PatchConceptsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchConceptsRequest>(
                "PatchConceptsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchConceptsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchConceptsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchConceptsRequest::new)
    }
}

impl ::protobuf::Clear for PatchConceptsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concepts.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConceptCountsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConceptCountsRequest {
    fn default() -> &'a GetConceptCountsRequest {
        <GetConceptCountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptCountsRequest {
    pub fn new() -> GetConceptCountsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for GetConceptCountsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConceptCountsRequest {
        GetConceptCountsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetConceptCountsRequest| { &m.user_app_id },
                |m: &mut GetConceptCountsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &GetConceptCountsRequest| { &m.page },
                |m: &mut GetConceptCountsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &GetConceptCountsRequest| { &m.per_page },
                |m: &mut GetConceptCountsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConceptCountsRequest>(
                "GetConceptCountsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConceptCountsRequest {
        static instance: ::protobuf::rt::LazyV2<GetConceptCountsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConceptCountsRequest::new)
    }
}

impl ::protobuf::Clear for GetConceptCountsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConceptCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptCountsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleConceptResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept: ::protobuf::SingularPtrField<super::resources::Concept>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleConceptResponse {
    fn default() -> &'a SingleConceptResponse {
        <SingleConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptResponse {
    pub fn new() -> SingleConceptResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Concept concept = 2;


    pub fn get_concept(&self) -> &super::resources::Concept {
        self.concept.as_ref().unwrap_or_else(|| <super::resources::Concept as ::protobuf::Message>::default_instance())
    }
    pub fn clear_concept(&mut self) {
        self.concept.clear();
    }

    pub fn has_concept(&self) -> bool {
        self.concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept(&mut self, v: super::resources::Concept) {
        self.concept = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept(&mut self) -> &mut super::resources::Concept {
        if self.concept.is_none() {
            self.concept.set_default();
        }
        self.concept.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept(&mut self) -> super::resources::Concept {
        self.concept.take().unwrap_or_else(|| super::resources::Concept::new())
    }
}

impl ::protobuf::Message for SingleConceptResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.concept.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleConceptResponse {
        SingleConceptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleConceptResponse| { &m.status },
                |m: &mut SingleConceptResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Concept>>(
                "concept",
                |m: &SingleConceptResponse| { &m.concept },
                |m: &mut SingleConceptResponse| { &mut m.concept },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleConceptResponse>(
                "SingleConceptResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleConceptResponse {
        static instance: ::protobuf::rt::LazyV2<SingleConceptResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleConceptResponse::new)
    }
}

impl ::protobuf::Clear for SingleConceptResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concepts: ::protobuf::RepeatedField<super::resources::Concept>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptResponse {
    fn default() -> &'a MultiConceptResponse {
        <MultiConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptResponse {
    pub fn new() -> MultiConceptResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Concept concepts = 2;


    pub fn get_concepts(&self) -> &[super::resources::Concept] {
        &self.concepts
    }
    pub fn clear_concepts(&mut self) {
        self.concepts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concepts(&mut self, v: ::protobuf::RepeatedField<super::resources::Concept>) {
        self.concepts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concepts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Concept> {
        &mut self.concepts
    }

    // Take field
    pub fn take_concepts(&mut self) -> ::protobuf::RepeatedField<super::resources::Concept> {
        ::std::mem::replace(&mut self.concepts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concepts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concepts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptResponse {
        MultiConceptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptResponse| { &m.status },
                |m: &mut MultiConceptResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Concept>>(
                "concepts",
                |m: &MultiConceptResponse| { &m.concepts },
                |m: &mut MultiConceptResponse| { &mut m.concepts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptResponse>(
                "MultiConceptResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concepts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptCountResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept_counts: ::protobuf::RepeatedField<super::resources::ConceptCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptCountResponse {
    fn default() -> &'a MultiConceptCountResponse {
        <MultiConceptCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptCountResponse {
    pub fn new() -> MultiConceptCountResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ConceptCount concept_counts = 2;


    pub fn get_concept_counts(&self) -> &[super::resources::ConceptCount] {
        &self.concept_counts
    }
    pub fn clear_concept_counts(&mut self) {
        self.concept_counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_counts(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptCount>) {
        self.concept_counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_counts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptCount> {
        &mut self.concept_counts
    }

    // Take field
    pub fn take_concept_counts(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptCount> {
        ::std::mem::replace(&mut self.concept_counts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptCountResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_counts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_counts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptCountResponse {
        MultiConceptCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptCountResponse| { &m.status },
                |m: &mut MultiConceptCountResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptCount>>(
                "concept_counts",
                |m: &MultiConceptCountResponse| { &m.concept_counts },
                |m: &mut MultiConceptCountResponse| { &mut m.concept_counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptCountResponse>(
                "MultiConceptCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptCountResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptCountResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptCountResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept_counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListConceptRelationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub predicate: ::std::string::String,
    pub knowledge_graph_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListConceptRelationsRequest {
    fn default() -> &'a ListConceptRelationsRequest {
        <ListConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptRelationsRequest {
    pub fn new() -> ListConceptRelationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // string predicate = 3;


    pub fn get_predicate(&self) -> &str {
        &self.predicate
    }
    pub fn clear_predicate(&mut self) {
        self.predicate.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicate(&mut self, v: ::std::string::String) {
        self.predicate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predicate(&mut self) -> &mut ::std::string::String {
        &mut self.predicate
    }

    // Take field
    pub fn take_predicate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.predicate, ::std::string::String::new())
    }

    // string knowledge_graph_id = 4;


    pub fn get_knowledge_graph_id(&self) -> &str {
        &self.knowledge_graph_id
    }
    pub fn clear_knowledge_graph_id(&mut self) {
        self.knowledge_graph_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_knowledge_graph_id(&mut self, v: ::std::string::String) {
        self.knowledge_graph_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_knowledge_graph_id(&mut self) -> &mut ::std::string::String {
        &mut self.knowledge_graph_id
    }

    // Take field
    pub fn take_knowledge_graph_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.knowledge_graph_id, ::std::string::String::new())
    }

    // uint32 page = 5;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 6;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListConceptRelationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.predicate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.knowledge_graph_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.predicate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.predicate);
        }
        if !self.knowledge_graph_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.knowledge_graph_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(5, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(6, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.predicate.is_empty() {
            os.write_string(3, &self.predicate)?;
        }
        if !self.knowledge_graph_id.is_empty() {
            os.write_string(4, &self.knowledge_graph_id)?;
        }
        if self.page != 0 {
            os.write_uint32(5, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(6, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListConceptRelationsRequest {
        ListConceptRelationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListConceptRelationsRequest| { &m.user_app_id },
                |m: &mut ListConceptRelationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &ListConceptRelationsRequest| { &m.concept_id },
                |m: &mut ListConceptRelationsRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "predicate",
                |m: &ListConceptRelationsRequest| { &m.predicate },
                |m: &mut ListConceptRelationsRequest| { &mut m.predicate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "knowledge_graph_id",
                |m: &ListConceptRelationsRequest| { &m.knowledge_graph_id },
                |m: &mut ListConceptRelationsRequest| { &mut m.knowledge_graph_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListConceptRelationsRequest| { &m.page },
                |m: &mut ListConceptRelationsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListConceptRelationsRequest| { &m.per_page },
                |m: &mut ListConceptRelationsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListConceptRelationsRequest>(
                "ListConceptRelationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListConceptRelationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListConceptRelationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListConceptRelationsRequest::new)
    }
}

impl ::protobuf::Clear for ListConceptRelationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.predicate.clear();
        self.knowledge_graph_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptRelationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptRelationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub concept_relations: ::protobuf::RepeatedField<super::resources::ConceptRelation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptRelationsRequest {
    fn default() -> &'a PostConceptRelationsRequest {
        <PostConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptRelationsRequest {
    pub fn new() -> PostConceptRelationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ConceptRelation concept_relations = 3;


    pub fn get_concept_relations(&self) -> &[super::resources::ConceptRelation] {
        &self.concept_relations
    }
    pub fn clear_concept_relations(&mut self) {
        self.concept_relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_relations(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptRelation>) {
        self.concept_relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_relations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptRelation> {
        &mut self.concept_relations
    }

    // Take field
    pub fn take_concept_relations(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptRelation> {
        ::std::mem::replace(&mut self.concept_relations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostConceptRelationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_relations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_relations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_relations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptRelationsRequest {
        PostConceptRelationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptRelationsRequest| { &m.user_app_id },
                |m: &mut PostConceptRelationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &PostConceptRelationsRequest| { &m.concept_id },
                |m: &mut PostConceptRelationsRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptRelation>>(
                "concept_relations",
                |m: &PostConceptRelationsRequest| { &m.concept_relations },
                |m: &mut PostConceptRelationsRequest| { &mut m.concept_relations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptRelationsRequest>(
                "PostConceptRelationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptRelationsRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptRelationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptRelationsRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptRelationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_relations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptRelationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteConceptRelationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteConceptRelationsRequest {
    fn default() -> &'a DeleteConceptRelationsRequest {
        <DeleteConceptRelationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteConceptRelationsRequest {
    pub fn new() -> DeleteConceptRelationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // repeated string ids = 3;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteConceptRelationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteConceptRelationsRequest {
        DeleteConceptRelationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteConceptRelationsRequest| { &m.user_app_id },
                |m: &mut DeleteConceptRelationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &DeleteConceptRelationsRequest| { &m.concept_id },
                |m: &mut DeleteConceptRelationsRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteConceptRelationsRequest| { &m.ids },
                |m: &mut DeleteConceptRelationsRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteConceptRelationsRequest>(
                "DeleteConceptRelationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteConceptRelationsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteConceptRelationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteConceptRelationsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteConceptRelationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteConceptRelationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteConceptRelationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListKnowledgeGraphsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListKnowledgeGraphsRequest {
    fn default() -> &'a ListKnowledgeGraphsRequest {
        <ListKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKnowledgeGraphsRequest {
    pub fn new() -> ListKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for ListKnowledgeGraphsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListKnowledgeGraphsRequest {
        ListKnowledgeGraphsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListKnowledgeGraphsRequest| { &m.user_app_id },
                |m: &mut ListKnowledgeGraphsRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListKnowledgeGraphsRequest>(
                "ListKnowledgeGraphsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListKnowledgeGraphsRequest {
        static instance: ::protobuf::rt::LazyV2<ListKnowledgeGraphsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListKnowledgeGraphsRequest::new)
    }
}

impl ::protobuf::Clear for ListKnowledgeGraphsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKnowledgeGraphsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostKnowledgeGraphsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub knowledge_graphs: ::protobuf::RepeatedField<super::resources::KnowledgeGraph>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostKnowledgeGraphsRequest {
    fn default() -> &'a PostKnowledgeGraphsRequest {
        <PostKnowledgeGraphsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKnowledgeGraphsRequest {
    pub fn new() -> PostKnowledgeGraphsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.KnowledgeGraph knowledge_graphs = 2;


    pub fn get_knowledge_graphs(&self) -> &[super::resources::KnowledgeGraph] {
        &self.knowledge_graphs
    }
    pub fn clear_knowledge_graphs(&mut self) {
        self.knowledge_graphs.clear();
    }

    // Param is passed by value, moved
    pub fn set_knowledge_graphs(&mut self, v: ::protobuf::RepeatedField<super::resources::KnowledgeGraph>) {
        self.knowledge_graphs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_knowledge_graphs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::KnowledgeGraph> {
        &mut self.knowledge_graphs
    }

    // Take field
    pub fn take_knowledge_graphs(&mut self) -> ::protobuf::RepeatedField<super::resources::KnowledgeGraph> {
        ::std::mem::replace(&mut self.knowledge_graphs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostKnowledgeGraphsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.knowledge_graphs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.knowledge_graphs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.knowledge_graphs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostKnowledgeGraphsRequest {
        PostKnowledgeGraphsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostKnowledgeGraphsRequest| { &m.user_app_id },
                |m: &mut PostKnowledgeGraphsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::KnowledgeGraph>>(
                "knowledge_graphs",
                |m: &PostKnowledgeGraphsRequest| { &m.knowledge_graphs },
                |m: &mut PostKnowledgeGraphsRequest| { &mut m.knowledge_graphs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostKnowledgeGraphsRequest>(
                "PostKnowledgeGraphsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostKnowledgeGraphsRequest {
        static instance: ::protobuf::rt::LazyV2<PostKnowledgeGraphsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostKnowledgeGraphsRequest::new)
    }
}

impl ::protobuf::Clear for PostKnowledgeGraphsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.knowledge_graphs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostKnowledgeGraphsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKnowledgeGraphsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptMappingJobsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_mapping_jobs: ::protobuf::RepeatedField<super::resources::ConceptMappingJob>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptMappingJobsRequest {
    fn default() -> &'a PostConceptMappingJobsRequest {
        <PostConceptMappingJobsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptMappingJobsRequest {
    pub fn new() -> PostConceptMappingJobsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.ConceptMappingJob concept_mapping_jobs = 2;


    pub fn get_concept_mapping_jobs(&self) -> &[super::resources::ConceptMappingJob] {
        &self.concept_mapping_jobs
    }
    pub fn clear_concept_mapping_jobs(&mut self) {
        self.concept_mapping_jobs.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_mapping_jobs(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptMappingJob>) {
        self.concept_mapping_jobs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_mapping_jobs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptMappingJob> {
        &mut self.concept_mapping_jobs
    }

    // Take field
    pub fn take_concept_mapping_jobs(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptMappingJob> {
        ::std::mem::replace(&mut self.concept_mapping_jobs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostConceptMappingJobsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_mapping_jobs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_mapping_jobs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_mapping_jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_mapping_jobs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptMappingJobsRequest {
        PostConceptMappingJobsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptMappingJobsRequest| { &m.user_app_id },
                |m: &mut PostConceptMappingJobsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptMappingJob>>(
                "concept_mapping_jobs",
                |m: &PostConceptMappingJobsRequest| { &m.concept_mapping_jobs },
                |m: &mut PostConceptMappingJobsRequest| { &mut m.concept_mapping_jobs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptMappingJobsRequest>(
                "PostConceptMappingJobsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptMappingJobsRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptMappingJobsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptMappingJobsRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptMappingJobsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_mapping_jobs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptMappingJobsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptMappingJobsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptRelationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept_relations: ::protobuf::RepeatedField<super::resources::ConceptRelation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptRelationResponse {
    fn default() -> &'a MultiConceptRelationResponse {
        <MultiConceptRelationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptRelationResponse {
    pub fn new() -> MultiConceptRelationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ConceptRelation concept_relations = 2;


    pub fn get_concept_relations(&self) -> &[super::resources::ConceptRelation] {
        &self.concept_relations
    }
    pub fn clear_concept_relations(&mut self) {
        self.concept_relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_relations(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptRelation>) {
        self.concept_relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_relations(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptRelation> {
        &mut self.concept_relations
    }

    // Take field
    pub fn take_concept_relations(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptRelation> {
        ::std::mem::replace(&mut self.concept_relations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptRelationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_relations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_relations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_relations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptRelationResponse {
        MultiConceptRelationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptRelationResponse| { &m.status },
                |m: &mut MultiConceptRelationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptRelation>>(
                "concept_relations",
                |m: &MultiConceptRelationResponse| { &m.concept_relations },
                |m: &mut MultiConceptRelationResponse| { &mut m.concept_relations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptRelationResponse>(
                "MultiConceptRelationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptRelationResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptRelationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptRelationResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptRelationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept_relations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptRelationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptRelationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiKnowledgeGraphResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub knowledge_graphs: ::protobuf::RepeatedField<super::resources::KnowledgeGraph>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiKnowledgeGraphResponse {
    fn default() -> &'a MultiKnowledgeGraphResponse {
        <MultiKnowledgeGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKnowledgeGraphResponse {
    pub fn new() -> MultiKnowledgeGraphResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.KnowledgeGraph knowledge_graphs = 2;


    pub fn get_knowledge_graphs(&self) -> &[super::resources::KnowledgeGraph] {
        &self.knowledge_graphs
    }
    pub fn clear_knowledge_graphs(&mut self) {
        self.knowledge_graphs.clear();
    }

    // Param is passed by value, moved
    pub fn set_knowledge_graphs(&mut self, v: ::protobuf::RepeatedField<super::resources::KnowledgeGraph>) {
        self.knowledge_graphs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_knowledge_graphs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::KnowledgeGraph> {
        &mut self.knowledge_graphs
    }

    // Take field
    pub fn take_knowledge_graphs(&mut self) -> ::protobuf::RepeatedField<super::resources::KnowledgeGraph> {
        ::std::mem::replace(&mut self.knowledge_graphs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiKnowledgeGraphResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.knowledge_graphs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.knowledge_graphs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.knowledge_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.knowledge_graphs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiKnowledgeGraphResponse {
        MultiKnowledgeGraphResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiKnowledgeGraphResponse| { &m.status },
                |m: &mut MultiKnowledgeGraphResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::KnowledgeGraph>>(
                "knowledge_graphs",
                |m: &MultiKnowledgeGraphResponse| { &m.knowledge_graphs },
                |m: &mut MultiKnowledgeGraphResponse| { &mut m.knowledge_graphs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiKnowledgeGraphResponse>(
                "MultiKnowledgeGraphResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiKnowledgeGraphResponse {
        static instance: ::protobuf::rt::LazyV2<MultiKnowledgeGraphResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiKnowledgeGraphResponse::new)
    }
}

impl ::protobuf::Clear for MultiKnowledgeGraphResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.knowledge_graphs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiKnowledgeGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKnowledgeGraphResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptMappingJobResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptMappingJobResponse {
    fn default() -> &'a MultiConceptMappingJobResponse {
        <MultiConceptMappingJobResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptMappingJobResponse {
    pub fn new() -> MultiConceptMappingJobResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptMappingJobResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptMappingJobResponse {
        MultiConceptMappingJobResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptMappingJobResponse| { &m.status },
                |m: &mut MultiConceptMappingJobResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &MultiConceptMappingJobResponse| { &m.ids },
                |m: &mut MultiConceptMappingJobResponse| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptMappingJobResponse>(
                "MultiConceptMappingJobResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptMappingJobResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptMappingJobResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptMappingJobResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptMappingJobResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptMappingJobResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptMappingJobResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConceptLanguageRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub language: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConceptLanguageRequest {
    fn default() -> &'a GetConceptLanguageRequest {
        <GetConceptLanguageRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConceptLanguageRequest {
    pub fn new() -> GetConceptLanguageRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // string language = 3;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetConceptLanguageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(3, &self.language)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConceptLanguageRequest {
        GetConceptLanguageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetConceptLanguageRequest| { &m.user_app_id },
                |m: &mut GetConceptLanguageRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &GetConceptLanguageRequest| { &m.concept_id },
                |m: &mut GetConceptLanguageRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &GetConceptLanguageRequest| { &m.language },
                |m: &mut GetConceptLanguageRequest| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConceptLanguageRequest>(
                "GetConceptLanguageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConceptLanguageRequest {
        static instance: ::protobuf::rt::LazyV2<GetConceptLanguageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConceptLanguageRequest::new)
    }
}

impl ::protobuf::Clear for GetConceptLanguageRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConceptLanguageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConceptLanguageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListConceptLanguagesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListConceptLanguagesRequest {
    fn default() -> &'a ListConceptLanguagesRequest {
        <ListConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListConceptLanguagesRequest {
    pub fn new() -> ListConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // uint32 page = 3;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 4;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListConceptLanguagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListConceptLanguagesRequest {
        ListConceptLanguagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListConceptLanguagesRequest| { &m.user_app_id },
                |m: &mut ListConceptLanguagesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &ListConceptLanguagesRequest| { &m.concept_id },
                |m: &mut ListConceptLanguagesRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListConceptLanguagesRequest| { &m.page },
                |m: &mut ListConceptLanguagesRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListConceptLanguagesRequest| { &m.per_page },
                |m: &mut ListConceptLanguagesRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListConceptLanguagesRequest>(
                "ListConceptLanguagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListConceptLanguagesRequest {
        static instance: ::protobuf::rt::LazyV2<ListConceptLanguagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListConceptLanguagesRequest::new)
    }
}

impl ::protobuf::Clear for ListConceptLanguagesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListConceptLanguagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchConceptLanguagesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub concept_languages: ::protobuf::RepeatedField<super::resources::ConceptLanguage>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchConceptLanguagesRequest {
    fn default() -> &'a PatchConceptLanguagesRequest {
        <PatchConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchConceptLanguagesRequest {
    pub fn new() -> PatchConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ConceptLanguage concept_languages = 3;


    pub fn get_concept_languages(&self) -> &[super::resources::ConceptLanguage] {
        &self.concept_languages
    }
    pub fn clear_concept_languages(&mut self) {
        self.concept_languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_languages(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptLanguage>) {
        self.concept_languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_languages(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        &mut self.concept_languages
    }

    // Take field
    pub fn take_concept_languages(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        ::std::mem::replace(&mut self.concept_languages, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchConceptLanguagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_languages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_languages)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchConceptLanguagesRequest {
        PatchConceptLanguagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchConceptLanguagesRequest| { &m.user_app_id },
                |m: &mut PatchConceptLanguagesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &PatchConceptLanguagesRequest| { &m.concept_id },
                |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptLanguage>>(
                "concept_languages",
                |m: &PatchConceptLanguagesRequest| { &m.concept_languages },
                |m: &mut PatchConceptLanguagesRequest| { &mut m.concept_languages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchConceptLanguagesRequest| { &m.action },
                |m: &mut PatchConceptLanguagesRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchConceptLanguagesRequest>(
                "PatchConceptLanguagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchConceptLanguagesRequest {
        static instance: ::protobuf::rt::LazyV2<PatchConceptLanguagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchConceptLanguagesRequest::new)
    }
}

impl ::protobuf::Clear for PatchConceptLanguagesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchConceptLanguagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostConceptLanguagesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub concept_id: ::std::string::String,
    pub concept_languages: ::protobuf::RepeatedField<super::resources::ConceptLanguage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostConceptLanguagesRequest {
    fn default() -> &'a PostConceptLanguagesRequest {
        <PostConceptLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostConceptLanguagesRequest {
    pub fn new() -> PostConceptLanguagesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string concept_id = 2;


    pub fn get_concept_id(&self) -> &str {
        &self.concept_id
    }
    pub fn clear_concept_id(&mut self) {
        self.concept_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_id(&mut self, v: ::std::string::String) {
        self.concept_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_id(&mut self) -> &mut ::std::string::String {
        &mut self.concept_id
    }

    // Take field
    pub fn take_concept_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.concept_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ConceptLanguage concept_languages = 3;


    pub fn get_concept_languages(&self) -> &[super::resources::ConceptLanguage] {
        &self.concept_languages
    }
    pub fn clear_concept_languages(&mut self) {
        self.concept_languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_languages(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptLanguage>) {
        self.concept_languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_languages(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        &mut self.concept_languages
    }

    // Take field
    pub fn take_concept_languages(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        ::std::mem::replace(&mut self.concept_languages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostConceptLanguagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_languages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.concept_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_languages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.concept_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.concept_id);
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.concept_id.is_empty() {
            os.write_string(2, &self.concept_id)?;
        }
        for v in &self.concept_languages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostConceptLanguagesRequest {
        PostConceptLanguagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostConceptLanguagesRequest| { &m.user_app_id },
                |m: &mut PostConceptLanguagesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_id",
                |m: &PostConceptLanguagesRequest| { &m.concept_id },
                |m: &mut PostConceptLanguagesRequest| { &mut m.concept_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptLanguage>>(
                "concept_languages",
                |m: &PostConceptLanguagesRequest| { &m.concept_languages },
                |m: &mut PostConceptLanguagesRequest| { &mut m.concept_languages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostConceptLanguagesRequest>(
                "PostConceptLanguagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostConceptLanguagesRequest {
        static instance: ::protobuf::rt::LazyV2<PostConceptLanguagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostConceptLanguagesRequest::new)
    }
}

impl ::protobuf::Clear for PostConceptLanguagesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.concept_id.clear();
        self.concept_languages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostConceptLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostConceptLanguagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleConceptLanguageResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept_language: ::protobuf::SingularPtrField<super::resources::ConceptLanguage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleConceptLanguageResponse {
    fn default() -> &'a SingleConceptLanguageResponse {
        <SingleConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleConceptLanguageResponse {
    pub fn new() -> SingleConceptLanguageResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.ConceptLanguage concept_language = 2;


    pub fn get_concept_language(&self) -> &super::resources::ConceptLanguage {
        self.concept_language.as_ref().unwrap_or_else(|| <super::resources::ConceptLanguage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_concept_language(&mut self) {
        self.concept_language.clear();
    }

    pub fn has_concept_language(&self) -> bool {
        self.concept_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept_language(&mut self, v: super::resources::ConceptLanguage) {
        self.concept_language = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_concept_language(&mut self) -> &mut super::resources::ConceptLanguage {
        if self.concept_language.is_none() {
            self.concept_language.set_default();
        }
        self.concept_language.as_mut().unwrap()
    }

    // Take field
    pub fn take_concept_language(&mut self) -> super::resources::ConceptLanguage {
        self.concept_language.take().unwrap_or_else(|| super::resources::ConceptLanguage::new())
    }
}

impl ::protobuf::Message for SingleConceptLanguageResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_language {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.concept_language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.concept_language.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.concept_language.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleConceptLanguageResponse {
        SingleConceptLanguageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleConceptLanguageResponse| { &m.status },
                |m: &mut SingleConceptLanguageResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptLanguage>>(
                "concept_language",
                |m: &SingleConceptLanguageResponse| { &m.concept_language },
                |m: &mut SingleConceptLanguageResponse| { &mut m.concept_language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleConceptLanguageResponse>(
                "SingleConceptLanguageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleConceptLanguageResponse {
        static instance: ::protobuf::rt::LazyV2<SingleConceptLanguageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleConceptLanguageResponse::new)
    }
}

impl ::protobuf::Clear for SingleConceptLanguageResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept_language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleConceptLanguageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiConceptLanguageResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub concept_languages: ::protobuf::RepeatedField<super::resources::ConceptLanguage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiConceptLanguageResponse {
    fn default() -> &'a MultiConceptLanguageResponse {
        <MultiConceptLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiConceptLanguageResponse {
    pub fn new() -> MultiConceptLanguageResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ConceptLanguage concept_languages = 2;


    pub fn get_concept_languages(&self) -> &[super::resources::ConceptLanguage] {
        &self.concept_languages
    }
    pub fn clear_concept_languages(&mut self) {
        self.concept_languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_languages(&mut self, v: ::protobuf::RepeatedField<super::resources::ConceptLanguage>) {
        self.concept_languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_languages(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        &mut self.concept_languages
    }

    // Take field
    pub fn take_concept_languages(&mut self) -> ::protobuf::RepeatedField<super::resources::ConceptLanguage> {
        ::std::mem::replace(&mut self.concept_languages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiConceptLanguageResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept_languages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.concept_languages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.concept_languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.concept_languages {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiConceptLanguageResponse {
        MultiConceptLanguageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiConceptLanguageResponse| { &m.status },
                |m: &mut MultiConceptLanguageResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConceptLanguage>>(
                "concept_languages",
                |m: &MultiConceptLanguageResponse| { &m.concept_languages },
                |m: &mut MultiConceptLanguageResponse| { &mut m.concept_languages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiConceptLanguageResponse>(
                "MultiConceptLanguageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiConceptLanguageResponse {
        static instance: ::protobuf::rt::LazyV2<MultiConceptLanguageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiConceptLanguageResponse::new)
    }
}

impl ::protobuf::Clear for MultiConceptLanguageResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.concept_languages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiConceptLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiConceptLanguageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInputRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub input_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInputRequest {
    fn default() -> &'a GetInputRequest {
        <GetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputRequest {
    pub fn new() -> GetInputRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string input_id = 2;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetInputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInputRequest {
        GetInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetInputRequest| { &m.user_app_id },
                |m: &mut GetInputRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &GetInputRequest| { &m.input_id },
                |m: &mut GetInputRequest| { &mut m.input_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInputRequest>(
                "GetInputRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInputRequest {
        static instance: ::protobuf::rt::LazyV2<GetInputRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInputRequest::new)
    }
}

impl ::protobuf::Clear for GetInputRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInputSamplesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub task_id: ::std::string::String,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInputSamplesRequest {
    fn default() -> &'a GetInputSamplesRequest {
        <GetInputSamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputSamplesRequest {
    pub fn new() -> GetInputSamplesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string task_id = 2;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    // repeated string user_ids = 3;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetInputSamplesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInputSamplesRequest {
        GetInputSamplesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetInputSamplesRequest| { &m.user_app_id },
                |m: &mut GetInputSamplesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &GetInputSamplesRequest| { &m.task_id },
                |m: &mut GetInputSamplesRequest| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &GetInputSamplesRequest| { &m.user_ids },
                |m: &mut GetInputSamplesRequest| { &mut m.user_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInputSamplesRequest>(
                "GetInputSamplesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInputSamplesRequest {
        static instance: ::protobuf::rt::LazyV2<GetInputSamplesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInputSamplesRequest::new)
    }
}

impl ::protobuf::Clear for GetInputSamplesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInputSamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputSamplesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInputsRequest {
    fn default() -> &'a ListInputsRequest {
        <ListInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInputsRequest {
    pub fn new() -> ListInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // .clarifai.api.status.Status status = 5;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string ids = 4;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInputsRequest {
        ListInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListInputsRequest| { &m.user_app_id },
                |m: &mut ListInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListInputsRequest| { &m.page },
                |m: &mut ListInputsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListInputsRequest| { &m.per_page },
                |m: &mut ListInputsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &ListInputsRequest| { &m.status },
                |m: &mut ListInputsRequest| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &ListInputsRequest| { &m.ids },
                |m: &mut ListInputsRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListInputsRequest>(
                "ListInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListInputsRequest {
        static instance: ::protobuf::rt::LazyV2<ListInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListInputsRequest::new)
    }
}

impl ::protobuf::Clear for ListInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.status.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub per_page: u32,
    pub last_id: ::std::string::String,
    pub descending: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamInputsRequest {
    fn default() -> &'a StreamInputsRequest {
        <StreamInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamInputsRequest {
    pub fn new() -> StreamInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 per_page = 2;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // string last_id = 3;


    pub fn get_last_id(&self) -> &str {
        &self.last_id
    }
    pub fn clear_last_id(&mut self) {
        self.last_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_id(&mut self, v: ::std::string::String) {
        self.last_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_id(&mut self) -> &mut ::std::string::String {
        &mut self.last_id
    }

    // Take field
    pub fn take_last_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_id, ::std::string::String::new())
    }

    // bool descending = 4;


    pub fn get_descending(&self) -> bool {
        self.descending
    }
    pub fn clear_descending(&mut self) {
        self.descending = false;
    }

    // Param is passed by value, moved
    pub fn set_descending(&mut self, v: bool) {
        self.descending = v;
    }
}

impl ::protobuf::Message for StreamInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.last_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.descending = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.last_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.last_id);
        }
        if self.descending != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.per_page != 0 {
            os.write_uint32(2, self.per_page)?;
        }
        if !self.last_id.is_empty() {
            os.write_string(3, &self.last_id)?;
        }
        if self.descending != false {
            os.write_bool(4, self.descending)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamInputsRequest {
        StreamInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &StreamInputsRequest| { &m.user_app_id },
                |m: &mut StreamInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &StreamInputsRequest| { &m.per_page },
                |m: &mut StreamInputsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_id",
                |m: &StreamInputsRequest| { &m.last_id },
                |m: &mut StreamInputsRequest| { &mut m.last_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "descending",
                |m: &StreamInputsRequest| { &m.descending },
                |m: &mut StreamInputsRequest| { &mut m.descending },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamInputsRequest>(
                "StreamInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamInputsRequest {
        static instance: ::protobuf::rt::LazyV2<StreamInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamInputsRequest::new)
    }
}

impl ::protobuf::Clear for StreamInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.per_page = 0;
        self.last_id.clear();
        self.descending = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostInputsRequest {
    fn default() -> &'a PostInputsRequest {
        <PostInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsRequest {
    pub fn new() -> PostInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Input inputs = 2;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.inputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostInputsRequest {
        PostInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostInputsRequest| { &m.user_app_id },
                |m: &mut PostInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &PostInputsRequest| { &m.inputs },
                |m: &mut PostInputsRequest| { &mut m.inputs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostInputsRequest>(
                "PostInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostInputsRequest {
        static instance: ::protobuf::rt::LazyV2<PostInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostInputsRequest::new)
    }
}

impl ::protobuf::Clear for PostInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchInputsRequest {
    fn default() -> &'a PatchInputsRequest {
        <PatchInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsRequest {
    pub fn new() -> PatchInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Input inputs = 2;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.inputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchInputsRequest {
        PatchInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchInputsRequest| { &m.user_app_id },
                |m: &mut PatchInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &PatchInputsRequest| { &m.inputs },
                |m: &mut PatchInputsRequest| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchInputsRequest| { &m.action },
                |m: &mut PatchInputsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchInputsRequest>(
                "PatchInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchInputsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchInputsRequest::new)
    }
}

impl ::protobuf::Clear for PatchInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.inputs.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteInputRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub input_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteInputRequest {
    fn default() -> &'a DeleteInputRequest {
        <DeleteInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputRequest {
    pub fn new() -> DeleteInputRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string input_id = 2;


    pub fn get_input_id(&self) -> &str {
        &self.input_id
    }
    pub fn clear_input_id(&mut self) {
        self.input_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_id(&mut self, v: ::std::string::String) {
        self.input_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_id(&mut self) -> &mut ::std::string::String {
        &mut self.input_id
    }

    // Take field
    pub fn take_input_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.input_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteInputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.input_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.input_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.input_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.input_id.is_empty() {
            os.write_string(2, &self.input_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteInputRequest {
        DeleteInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteInputRequest| { &m.user_app_id },
                |m: &mut DeleteInputRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_id",
                |m: &DeleteInputRequest| { &m.input_id },
                |m: &mut DeleteInputRequest| { &mut m.input_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteInputRequest>(
                "DeleteInputRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteInputRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteInputRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteInputRequest::new)
    }
}

impl ::protobuf::Clear for DeleteInputRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.input_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteInputsRequest {
    fn default() -> &'a DeleteInputsRequest {
        <DeleteInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInputsRequest {
    pub fn new() -> DeleteInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteInputsRequest {
        DeleteInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteInputsRequest| { &m.user_app_id },
                |m: &mut DeleteInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteInputsRequest| { &m.ids },
                |m: &mut DeleteInputsRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteInputsRequest>(
                "DeleteInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteInputsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteInputsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleInputResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub input: ::protobuf::SingularPtrField<super::resources::Input>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleInputResponse {
    fn default() -> &'a SingleInputResponse {
        <SingleInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputResponse {
    pub fn new() -> SingleInputResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Input input = 2;


    pub fn get_input(&self) -> &super::resources::Input {
        self.input.as_ref().unwrap_or_else(|| <super::resources::Input as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: super::resources::Input) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut super::resources::Input {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> super::resources::Input {
        self.input.take().unwrap_or_else(|| super::resources::Input::new())
    }
}

impl ::protobuf::Message for SingleInputResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleInputResponse {
        SingleInputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleInputResponse| { &m.status },
                |m: &mut SingleInputResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "input",
                |m: &SingleInputResponse| { &m.input },
                |m: &mut SingleInputResponse| { &mut m.input },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleInputResponse>(
                "SingleInputResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleInputResponse {
        static instance: ::protobuf::rt::LazyV2<SingleInputResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleInputResponse::new)
    }
}

impl ::protobuf::Clear for SingleInputResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.input.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiInputResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiInputResponse {
    fn default() -> &'a MultiInputResponse {
        <MultiInputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputResponse {
    pub fn new() -> MultiInputResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Input inputs = 2;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiInputResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.inputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiInputResponse {
        MultiInputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiInputResponse| { &m.status },
                |m: &mut MultiInputResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &MultiInputResponse| { &m.inputs },
                |m: &mut MultiInputResponse| { &mut m.inputs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiInputResponse>(
                "MultiInputResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiInputResponse {
        static instance: ::protobuf::rt::LazyV2<MultiInputResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiInputResponse::new)
    }
}

impl ::protobuf::Clear for MultiInputResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.inputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiInputAnnotationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub hits: ::protobuf::RepeatedField<super::resources::Hit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiInputAnnotationResponse {
    fn default() -> &'a MultiInputAnnotationResponse {
        <MultiInputAnnotationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiInputAnnotationResponse {
    pub fn new() -> MultiInputAnnotationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Hit hits = 3;


    pub fn get_hits(&self) -> &[super::resources::Hit] {
        &self.hits
    }
    pub fn clear_hits(&mut self) {
        self.hits.clear();
    }

    // Param is passed by value, moved
    pub fn set_hits(&mut self, v: ::protobuf::RepeatedField<super::resources::Hit>) {
        self.hits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hits(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Hit> {
        &mut self.hits
    }

    // Take field
    pub fn take_hits(&mut self) -> ::protobuf::RepeatedField<super::resources::Hit> {
        ::std::mem::replace(&mut self.hits, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiInputAnnotationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.hits {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiInputAnnotationResponse {
        MultiInputAnnotationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiInputAnnotationResponse| { &m.status },
                |m: &mut MultiInputAnnotationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Hit>>(
                "hits",
                |m: &MultiInputAnnotationResponse| { &m.hits },
                |m: &mut MultiInputAnnotationResponse| { &mut m.hits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiInputAnnotationResponse>(
                "MultiInputAnnotationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiInputAnnotationResponse {
        static instance: ::protobuf::rt::LazyV2<MultiInputAnnotationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiInputAnnotationResponse::new)
    }
}

impl ::protobuf::Clear for MultiInputAnnotationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.hits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiInputAnnotationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiInputAnnotationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleInputCountResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub counts: ::protobuf::SingularPtrField<super::resources::InputCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleInputCountResponse {
    fn default() -> &'a SingleInputCountResponse {
        <SingleInputCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleInputCountResponse {
    pub fn new() -> SingleInputCountResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.InputCount counts = 2;


    pub fn get_counts(&self) -> &super::resources::InputCount {
        self.counts.as_ref().unwrap_or_else(|| <super::resources::InputCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_counts(&mut self) {
        self.counts.clear();
    }

    pub fn has_counts(&self) -> bool {
        self.counts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counts(&mut self, v: super::resources::InputCount) {
        self.counts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counts(&mut self) -> &mut super::resources::InputCount {
        if self.counts.is_none() {
            self.counts.set_default();
        }
        self.counts.as_mut().unwrap()
    }

    // Take field
    pub fn take_counts(&mut self) -> super::resources::InputCount {
        self.counts.take().unwrap_or_else(|| super::resources::InputCount::new())
    }
}

impl ::protobuf::Message for SingleInputCountResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.counts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.counts.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleInputCountResponse {
        SingleInputCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleInputCountResponse| { &m.status },
                |m: &mut SingleInputCountResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::InputCount>>(
                "counts",
                |m: &SingleInputCountResponse| { &m.counts },
                |m: &mut SingleInputCountResponse| { &mut m.counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleInputCountResponse>(
                "SingleInputCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleInputCountResponse {
        static instance: ::protobuf::rt::LazyV2<SingleInputCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleInputCountResponse::new)
    }
}

impl ::protobuf::Clear for SingleInputCountResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleInputCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleInputCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInputCountRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInputCountRequest {
    fn default() -> &'a GetInputCountRequest {
        <GetInputCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInputCountRequest {
    pub fn new() -> GetInputCountRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for GetInputCountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInputCountRequest {
        GetInputCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetInputCountRequest| { &m.user_app_id },
                |m: &mut GetInputCountRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInputCountRequest>(
                "GetInputCountRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInputCountRequest {
        static instance: ::protobuf::rt::LazyV2<GetInputCountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInputCountRequest::new)
    }
}

impl ::protobuf::Clear for GetInputCountRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInputCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInputCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelOutputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub model: ::protobuf::SingularPtrField<super::resources::Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelOutputsRequest {
    fn default() -> &'a PostModelOutputsRequest {
        <PostModelOutputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelOutputsRequest {
    pub fn new() -> PostModelOutputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.Input inputs = 4;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Model model = 5;


    pub fn get_model(&self) -> &super::resources::Model {
        self.model.as_ref().unwrap_or_else(|| <super::resources::Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: super::resources::Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut super::resources::Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> super::resources::Model {
        self.model.take().unwrap_or_else(|| super::resources::Model::new())
    }
}

impl ::protobuf::Message for PostModelOutputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        for v in &self.inputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelOutputsRequest {
        PostModelOutputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelOutputsRequest| { &m.user_app_id },
                |m: &mut PostModelOutputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PostModelOutputsRequest| { &m.model_id },
                |m: &mut PostModelOutputsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &PostModelOutputsRequest| { &m.version_id },
                |m: &mut PostModelOutputsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &PostModelOutputsRequest| { &m.inputs },
                |m: &mut PostModelOutputsRequest| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "model",
                |m: &PostModelOutputsRequest| { &m.model },
                |m: &mut PostModelOutputsRequest| { &mut m.model },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelOutputsRequest>(
                "PostModelOutputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelOutputsRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelOutputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelOutputsRequest::new)
    }
}

impl ::protobuf::Clear for PostModelOutputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.model.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelOutputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelOutputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelInputsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelInputsRequest {
    fn default() -> &'a ListModelInputsRequest {
        <ListModelInputsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelInputsRequest {
    pub fn new() -> ListModelInputsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // uint32 page = 4;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 5;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListModelInputsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(5, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelInputsRequest {
        ListModelInputsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelInputsRequest| { &m.user_app_id },
                |m: &mut ListModelInputsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &ListModelInputsRequest| { &m.model_id },
                |m: &mut ListModelInputsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &ListModelInputsRequest| { &m.version_id },
                |m: &mut ListModelInputsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelInputsRequest| { &m.page },
                |m: &mut ListModelInputsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelInputsRequest| { &m.per_page },
                |m: &mut ListModelInputsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelInputsRequest>(
                "ListModelInputsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelInputsRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelInputsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelInputsRequest::new)
    }
}

impl ::protobuf::Clear for ListModelInputsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelInputsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelInputsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetKeyRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub key_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetKeyRequest {
    fn default() -> &'a GetKeyRequest {
        <GetKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetKeyRequest {
    pub fn new() -> GetKeyRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string key_id = 2;


    pub fn get_key_id(&self) -> &str {
        &self.key_id
    }
    pub fn clear_key_id(&mut self) {
        self.key_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_id(&mut self, v: ::std::string::String) {
        self.key_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_id(&mut self) -> &mut ::std::string::String {
        &mut self.key_id
    }

    // Take field
    pub fn take_key_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetKeyRequest {
        GetKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetKeyRequest| { &m.user_app_id },
                |m: &mut GetKeyRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_id",
                |m: &GetKeyRequest| { &m.key_id },
                |m: &mut GetKeyRequest| { &mut m.key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetKeyRequest>(
                "GetKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetKeyRequest {
        static instance: ::protobuf::rt::LazyV2<GetKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetKeyRequest::new)
    }
}

impl ::protobuf::Clear for GetKeyRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListKeysRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListKeysRequest {
    fn default() -> &'a ListKeysRequest {
        <ListKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysRequest {
    pub fn new() -> ListKeysRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListKeysRequest {
        ListKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListKeysRequest| { &m.user_app_id },
                |m: &mut ListKeysRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListKeysRequest| { &m.page },
                |m: &mut ListKeysRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListKeysRequest| { &m.per_page },
                |m: &mut ListKeysRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListKeysRequest>(
                "ListKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListKeysRequest {
        static instance: ::protobuf::rt::LazyV2<ListKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListKeysRequest::new)
    }
}

impl ::protobuf::Clear for ListKeysRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAppKeysRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAppKeysRequest {
    fn default() -> &'a ListAppKeysRequest {
        <ListAppKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppKeysRequest {
    pub fn new() -> ListAppKeysRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListAppKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAppKeysRequest {
        ListAppKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAppKeysRequest| { &m.user_app_id },
                |m: &mut ListAppKeysRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListAppKeysRequest| { &m.page },
                |m: &mut ListAppKeysRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListAppKeysRequest| { &m.per_page },
                |m: &mut ListAppKeysRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAppKeysRequest>(
                "ListAppKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAppKeysRequest {
        static instance: ::protobuf::rt::LazyV2<ListAppKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAppKeysRequest::new)
    }
}

impl ::protobuf::Clear for ListAppKeysRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAppKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostKeysRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub keys: ::protobuf::RepeatedField<super::resources::Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostKeysRequest {
    fn default() -> &'a PostKeysRequest {
        <PostKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostKeysRequest {
    pub fn new() -> PostKeysRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Key keys = 2;


    pub fn get_keys(&self) -> &[super::resources::Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<super::resources::Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<super::resources::Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostKeysRequest {
        PostKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostKeysRequest| { &m.user_app_id },
                |m: &mut PostKeysRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Key>>(
                "keys",
                |m: &PostKeysRequest| { &m.keys },
                |m: &mut PostKeysRequest| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostKeysRequest>(
                "PostKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostKeysRequest {
        static instance: ::protobuf::rt::LazyV2<PostKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostKeysRequest::new)
    }
}

impl ::protobuf::Clear for PostKeysRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteKeyRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub key_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteKeyRequest {
    fn default() -> &'a DeleteKeyRequest {
        <DeleteKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteKeyRequest {
    pub fn new() -> DeleteKeyRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string key_id = 2;


    pub fn get_key_id(&self) -> &str {
        &self.key_id
    }
    pub fn clear_key_id(&mut self) {
        self.key_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_id(&mut self, v: ::std::string::String) {
        self.key_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_id(&mut self) -> &mut ::std::string::String {
        &mut self.key_id
    }

    // Take field
    pub fn take_key_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteKeyRequest {
        DeleteKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteKeyRequest| { &m.user_app_id },
                |m: &mut DeleteKeyRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_id",
                |m: &DeleteKeyRequest| { &m.key_id },
                |m: &mut DeleteKeyRequest| { &mut m.key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteKeyRequest>(
                "DeleteKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteKeyRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteKeyRequest::new)
    }
}

impl ::protobuf::Clear for DeleteKeyRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchKeysRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub keys: ::protobuf::RepeatedField<super::resources::Key>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchKeysRequest {
    fn default() -> &'a PatchKeysRequest {
        <PatchKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchKeysRequest {
    pub fn new() -> PatchKeysRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Key keys = 2;


    pub fn get_keys(&self) -> &[super::resources::Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<super::resources::Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<super::resources::Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchKeysRequest {
        PatchKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchKeysRequest| { &m.user_app_id },
                |m: &mut PatchKeysRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Key>>(
                "keys",
                |m: &PatchKeysRequest| { &m.keys },
                |m: &mut PatchKeysRequest| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchKeysRequest| { &m.action },
                |m: &mut PatchKeysRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchKeysRequest>(
                "PatchKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchKeysRequest {
        static instance: ::protobuf::rt::LazyV2<PatchKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchKeysRequest::new)
    }
}

impl ::protobuf::Clear for PatchKeysRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.keys.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleKeyResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub key: ::protobuf::SingularPtrField<super::resources::Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleKeyResponse {
    fn default() -> &'a SingleKeyResponse {
        <SingleKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleKeyResponse {
    pub fn new() -> SingleKeyResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Key key = 2;


    pub fn get_key(&self) -> &super::resources::Key {
        self.key.as_ref().unwrap_or_else(|| <super::resources::Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: super::resources::Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut super::resources::Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> super::resources::Key {
        self.key.take().unwrap_or_else(|| super::resources::Key::new())
    }
}

impl ::protobuf::Message for SingleKeyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleKeyResponse {
        SingleKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleKeyResponse| { &m.status },
                |m: &mut SingleKeyResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Key>>(
                "key",
                |m: &SingleKeyResponse| { &m.key },
                |m: &mut SingleKeyResponse| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleKeyResponse>(
                "SingleKeyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleKeyResponse {
        static instance: ::protobuf::rt::LazyV2<SingleKeyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleKeyResponse::new)
    }
}

impl ::protobuf::Clear for SingleKeyResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiKeyResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub keys: ::protobuf::RepeatedField<super::resources::Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiKeyResponse {
    fn default() -> &'a MultiKeyResponse {
        <MultiKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiKeyResponse {
    pub fn new() -> MultiKeyResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Key keys = 2;


    pub fn get_keys(&self) -> &[super::resources::Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<super::resources::Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<super::resources::Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiKeyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiKeyResponse {
        MultiKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiKeyResponse| { &m.status },
                |m: &mut MultiKeyResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Key>>(
                "keys",
                |m: &MultiKeyResponse| { &m.keys },
                |m: &mut MultiKeyResponse| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiKeyResponse>(
                "MultiKeyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiKeyResponse {
        static instance: ::protobuf::rt::LazyV2<MultiKeyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiKeyResponse::new)
    }
}

impl ::protobuf::Clear for MultiKeyResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub language: ::std::string::String,
    pub trained_before: bool,
    pub additional_fields: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelRequest {
    fn default() -> &'a GetModelRequest {
        <GetModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelRequest {
    pub fn new() -> GetModelRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // string language = 4;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }

    // bool trained_before = 5;


    pub fn get_trained_before(&self) -> bool {
        self.trained_before
    }
    pub fn clear_trained_before(&mut self) {
        self.trained_before = false;
    }

    // Param is passed by value, moved
    pub fn set_trained_before(&mut self, v: bool) {
        self.trained_before = v;
    }

    // repeated string additional_fields = 19;


    pub fn get_additional_fields(&self) -> &[::std::string::String] {
        &self.additional_fields
    }
    pub fn clear_additional_fields(&mut self) {
        self.additional_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.additional_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.additional_fields
    }

    // Take field
    pub fn take_additional_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.additional_fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetModelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trained_before = tmp;
                },
                19 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.additional_fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language);
        }
        if self.trained_before != false {
            my_size += 2;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if !self.language.is_empty() {
            os.write_string(4, &self.language)?;
        }
        if self.trained_before != false {
            os.write_bool(5, self.trained_before)?;
        }
        for v in &self.additional_fields {
            os.write_string(19, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelRequest {
        GetModelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelRequest| { &m.user_app_id },
                |m: &mut GetModelRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &GetModelRequest| { &m.model_id },
                |m: &mut GetModelRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &GetModelRequest| { &m.version_id },
                |m: &mut GetModelRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &GetModelRequest| { &m.language },
                |m: &mut GetModelRequest| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trained_before",
                |m: &GetModelRequest| { &m.trained_before },
                |m: &mut GetModelRequest| { &mut m.trained_before },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "additional_fields",
                |m: &GetModelRequest| { &m.additional_fields },
                |m: &mut GetModelRequest| { &mut m.additional_fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelRequest>(
                "GetModelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelRequest::new)
    }
}

impl ::protobuf::Clear for GetModelRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.language.clear();
        self.trained_before = false;
        self.additional_fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    pub sort_ascending: bool,
    pub query: ::std::string::String,
    pub name: ::std::string::String,
    pub model_type_id: ::std::string::String,
    pub trained_only: bool,
    pub input_fields: ::protobuf::RepeatedField<::std::string::String>,
    pub output_fields: ::protobuf::RepeatedField<::std::string::String>,
    pub license: ::std::string::String,
    pub featured_only: bool,
    pub starred_only: bool,
    pub toolkits: ::protobuf::RepeatedField<::std::string::String>,
    pub use_cases: ::protobuf::RepeatedField<::std::string::String>,
    pub languages: ::protobuf::RepeatedField<::std::string::String>,
    pub additional_fields: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub sort_by: ::std::option::Option<ListModelsRequest_oneof_sort_by>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelsRequest {
    fn default() -> &'a ListModelsRequest {
        <ListModelsRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ListModelsRequest_oneof_sort_by {
    sort_by_name(bool),
    sort_by_num_inputs(bool),
    sort_by_modified_at(bool),
}

impl ListModelsRequest {
    pub fn new() -> ListModelsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // bool sort_ascending = 10;


    pub fn get_sort_ascending(&self) -> bool {
        self.sort_ascending
    }
    pub fn clear_sort_ascending(&mut self) {
        self.sort_ascending = false;
    }

    // Param is passed by value, moved
    pub fn set_sort_ascending(&mut self, v: bool) {
        self.sort_ascending = v;
    }

    // bool sort_by_name = 11;


    pub fn get_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_name(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sort_by_name(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_name(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_name(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_name(v))
    }

    // bool sort_by_num_inputs = 12;


    pub fn get_sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_num_inputs(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sort_by_num_inputs(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_num_inputs(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_num_inputs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_num_inputs(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_num_inputs(v))
    }

    // bool sort_by_modified_at = 13;


    pub fn get_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_modified_at(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_modified_at(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_modified_at(v))
    }

    // string query = 14;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string model_type_id = 6;


    pub fn get_model_type_id(&self) -> &str {
        &self.model_type_id
    }
    pub fn clear_model_type_id(&mut self) {
        self.model_type_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_type_id(&mut self, v: ::std::string::String) {
        self.model_type_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_type_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_type_id
    }

    // Take field
    pub fn take_model_type_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_type_id, ::std::string::String::new())
    }

    // bool trained_only = 7;


    pub fn get_trained_only(&self) -> bool {
        self.trained_only
    }
    pub fn clear_trained_only(&mut self) {
        self.trained_only = false;
    }

    // Param is passed by value, moved
    pub fn set_trained_only(&mut self, v: bool) {
        self.trained_only = v;
    }

    // repeated string input_fields = 8;


    pub fn get_input_fields(&self) -> &[::std::string::String] {
        &self.input_fields
    }
    pub fn clear_input_fields(&mut self) {
        self.input_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input_fields
    }

    // Take field
    pub fn take_input_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input_fields, ::protobuf::RepeatedField::new())
    }

    // repeated string output_fields = 9;


    pub fn get_output_fields(&self) -> &[::std::string::String] {
        &self.output_fields
    }
    pub fn clear_output_fields(&mut self) {
        self.output_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.output_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.output_fields
    }

    // Take field
    pub fn take_output_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.output_fields, ::protobuf::RepeatedField::new())
    }

    // string license = 15;


    pub fn get_license(&self) -> &str {
        &self.license
    }
    pub fn clear_license(&mut self) {
        self.license.clear();
    }

    // Param is passed by value, moved
    pub fn set_license(&mut self, v: ::std::string::String) {
        self.license = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license(&mut self) -> &mut ::std::string::String {
        &mut self.license
    }

    // Take field
    pub fn take_license(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.license, ::std::string::String::new())
    }

    // bool featured_only = 16;


    pub fn get_featured_only(&self) -> bool {
        self.featured_only
    }
    pub fn clear_featured_only(&mut self) {
        self.featured_only = false;
    }

    // Param is passed by value, moved
    pub fn set_featured_only(&mut self, v: bool) {
        self.featured_only = v;
    }

    // bool starred_only = 20;


    pub fn get_starred_only(&self) -> bool {
        self.starred_only
    }
    pub fn clear_starred_only(&mut self) {
        self.starred_only = false;
    }

    // Param is passed by value, moved
    pub fn set_starred_only(&mut self, v: bool) {
        self.starred_only = v;
    }

    // repeated string toolkits = 17;


    pub fn get_toolkits(&self) -> &[::std::string::String] {
        &self.toolkits
    }
    pub fn clear_toolkits(&mut self) {
        self.toolkits.clear();
    }

    // Param is passed by value, moved
    pub fn set_toolkits(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.toolkits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_toolkits(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.toolkits
    }

    // Take field
    pub fn take_toolkits(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.toolkits, ::protobuf::RepeatedField::new())
    }

    // repeated string use_cases = 18;


    pub fn get_use_cases(&self) -> &[::std::string::String] {
        &self.use_cases
    }
    pub fn clear_use_cases(&mut self) {
        self.use_cases.clear();
    }

    // Param is passed by value, moved
    pub fn set_use_cases(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.use_cases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_use_cases(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.use_cases
    }

    // Take field
    pub fn take_use_cases(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.use_cases, ::protobuf::RepeatedField::new())
    }

    // repeated string languages = 21;


    pub fn get_languages(&self) -> &[::std::string::String] {
        &self.languages
    }
    pub fn clear_languages(&mut self) {
        self.languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_languages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_languages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.languages
    }

    // Take field
    pub fn take_languages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.languages, ::protobuf::RepeatedField::new())
    }

    // repeated string additional_fields = 19;


    pub fn get_additional_fields(&self) -> &[::std::string::String] {
        &self.additional_fields
    }
    pub fn clear_additional_fields(&mut self) {
        self.additional_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.additional_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.additional_fields
    }

    // Take field
    pub fn take_additional_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.additional_fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListModelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sort_ascending = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sort_by = ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_name(is.read_bool()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sort_by = ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_num_inputs(is.read_bool()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sort_by = ::std::option::Option::Some(ListModelsRequest_oneof_sort_by::sort_by_modified_at(is.read_bool()?));
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_type_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trained_only = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input_fields)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.output_fields)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.license)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.featured_only = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.starred_only = tmp;
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.toolkits)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.use_cases)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.languages)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.additional_fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sort_ascending != false {
            my_size += 2;
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.query);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model_type_id);
        }
        if self.trained_only != false {
            my_size += 2;
        }
        for value in &self.input_fields {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.output_fields {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.license);
        }
        if self.featured_only != false {
            my_size += 3;
        }
        if self.starred_only != false {
            my_size += 3;
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.use_cases {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &ListModelsRequest_oneof_sort_by::sort_by_name(v) => {
                    my_size += 2;
                },
                &ListModelsRequest_oneof_sort_by::sort_by_num_inputs(v) => {
                    my_size += 2;
                },
                &ListModelsRequest_oneof_sort_by::sort_by_modified_at(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(10, self.sort_ascending)?;
        }
        if !self.query.is_empty() {
            os.write_string(14, &self.query)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(6, &self.model_type_id)?;
        }
        if self.trained_only != false {
            os.write_bool(7, self.trained_only)?;
        }
        for v in &self.input_fields {
            os.write_string(8, &v)?;
        };
        for v in &self.output_fields {
            os.write_string(9, &v)?;
        };
        if !self.license.is_empty() {
            os.write_string(15, &self.license)?;
        }
        if self.featured_only != false {
            os.write_bool(16, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(20, self.starred_only)?;
        }
        for v in &self.toolkits {
            os.write_string(17, &v)?;
        };
        for v in &self.use_cases {
            os.write_string(18, &v)?;
        };
        for v in &self.languages {
            os.write_string(21, &v)?;
        };
        for v in &self.additional_fields {
            os.write_string(19, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &ListModelsRequest_oneof_sort_by::sort_by_name(v) => {
                    os.write_bool(11, v)?;
                },
                &ListModelsRequest_oneof_sort_by::sort_by_num_inputs(v) => {
                    os.write_bool(12, v)?;
                },
                &ListModelsRequest_oneof_sort_by::sort_by_modified_at(v) => {
                    os.write_bool(13, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelsRequest {
        ListModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelsRequest| { &m.user_app_id },
                |m: &mut ListModelsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelsRequest| { &m.page },
                |m: &mut ListModelsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelsRequest| { &m.per_page },
                |m: &mut ListModelsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sort_ascending",
                |m: &ListModelsRequest| { &m.sort_ascending },
                |m: &mut ListModelsRequest| { &mut m.sort_ascending },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sort_by_name",
                ListModelsRequest::has_sort_by_name,
                ListModelsRequest::get_sort_by_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sort_by_num_inputs",
                ListModelsRequest::has_sort_by_num_inputs,
                ListModelsRequest::get_sort_by_num_inputs,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sort_by_modified_at",
                ListModelsRequest::has_sort_by_modified_at,
                ListModelsRequest::get_sort_by_modified_at,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &ListModelsRequest| { &m.query },
                |m: &mut ListModelsRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListModelsRequest| { &m.name },
                |m: &mut ListModelsRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_type_id",
                |m: &ListModelsRequest| { &m.model_type_id },
                |m: &mut ListModelsRequest| { &mut m.model_type_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trained_only",
                |m: &ListModelsRequest| { &m.trained_only },
                |m: &mut ListModelsRequest| { &mut m.trained_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input_fields",
                |m: &ListModelsRequest| { &m.input_fields },
                |m: &mut ListModelsRequest| { &mut m.input_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output_fields",
                |m: &ListModelsRequest| { &m.output_fields },
                |m: &mut ListModelsRequest| { &mut m.output_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "license",
                |m: &ListModelsRequest| { &m.license },
                |m: &mut ListModelsRequest| { &mut m.license },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "featured_only",
                |m: &ListModelsRequest| { &m.featured_only },
                |m: &mut ListModelsRequest| { &mut m.featured_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "starred_only",
                |m: &ListModelsRequest| { &m.starred_only },
                |m: &mut ListModelsRequest| { &mut m.starred_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "toolkits",
                |m: &ListModelsRequest| { &m.toolkits },
                |m: &mut ListModelsRequest| { &mut m.toolkits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "use_cases",
                |m: &ListModelsRequest| { &m.use_cases },
                |m: &mut ListModelsRequest| { &mut m.use_cases },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "languages",
                |m: &ListModelsRequest| { &m.languages },
                |m: &mut ListModelsRequest| { &mut m.languages },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "additional_fields",
                |m: &ListModelsRequest| { &m.additional_fields },
                |m: &mut ListModelsRequest| { &mut m.additional_fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelsRequest>(
                "ListModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelsRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelsRequest::new)
    }
}

impl ::protobuf::Clear for ListModelsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.query.clear();
        self.name.clear();
        self.model_type_id.clear();
        self.trained_only = false;
        self.input_fields.clear();
        self.output_fields.clear();
        self.license.clear();
        self.featured_only = false;
        self.starred_only = false;
        self.toolkits.clear();
        self.use_cases.clear();
        self.languages.clear();
        self.additional_fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchModelToolkitsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub toolkits: ::protobuf::RepeatedField<::std::string::String>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchModelToolkitsRequest {
    fn default() -> &'a PatchModelToolkitsRequest {
        <PatchModelToolkitsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelToolkitsRequest {
    pub fn new() -> PatchModelToolkitsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated string toolkits = 3;


    pub fn get_toolkits(&self) -> &[::std::string::String] {
        &self.toolkits
    }
    pub fn clear_toolkits(&mut self) {
        self.toolkits.clear();
    }

    // Param is passed by value, moved
    pub fn set_toolkits(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.toolkits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_toolkits(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.toolkits
    }

    // Take field
    pub fn take_toolkits(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.toolkits, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchModelToolkitsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.toolkits)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.toolkits {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchModelToolkitsRequest {
        PatchModelToolkitsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchModelToolkitsRequest| { &m.user_app_id },
                |m: &mut PatchModelToolkitsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PatchModelToolkitsRequest| { &m.model_id },
                |m: &mut PatchModelToolkitsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "toolkits",
                |m: &PatchModelToolkitsRequest| { &m.toolkits },
                |m: &mut PatchModelToolkitsRequest| { &mut m.toolkits },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchModelToolkitsRequest| { &m.action },
                |m: &mut PatchModelToolkitsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchModelToolkitsRequest>(
                "PatchModelToolkitsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchModelToolkitsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchModelToolkitsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchModelToolkitsRequest::new)
    }
}

impl ::protobuf::Clear for PatchModelToolkitsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.toolkits.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchModelToolkitsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelToolkitsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchModelUseCasesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub usecases: ::protobuf::RepeatedField<::std::string::String>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchModelUseCasesRequest {
    fn default() -> &'a PatchModelUseCasesRequest {
        <PatchModelUseCasesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelUseCasesRequest {
    pub fn new() -> PatchModelUseCasesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated string usecases = 3;


    pub fn get_usecases(&self) -> &[::std::string::String] {
        &self.usecases
    }
    pub fn clear_usecases(&mut self) {
        self.usecases.clear();
    }

    // Param is passed by value, moved
    pub fn set_usecases(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.usecases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_usecases(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.usecases
    }

    // Take field
    pub fn take_usecases(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.usecases, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchModelUseCasesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.usecases)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.usecases {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.usecases {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchModelUseCasesRequest {
        PatchModelUseCasesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchModelUseCasesRequest| { &m.user_app_id },
                |m: &mut PatchModelUseCasesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PatchModelUseCasesRequest| { &m.model_id },
                |m: &mut PatchModelUseCasesRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "usecases",
                |m: &PatchModelUseCasesRequest| { &m.usecases },
                |m: &mut PatchModelUseCasesRequest| { &mut m.usecases },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchModelUseCasesRequest| { &m.action },
                |m: &mut PatchModelUseCasesRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchModelUseCasesRequest>(
                "PatchModelUseCasesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchModelUseCasesRequest {
        static instance: ::protobuf::rt::LazyV2<PatchModelUseCasesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchModelUseCasesRequest::new)
    }
}

impl ::protobuf::Clear for PatchModelUseCasesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.usecases.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchModelUseCasesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelUseCasesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchModelLanguagesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub languages: ::protobuf::RepeatedField<::std::string::String>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchModelLanguagesRequest {
    fn default() -> &'a PatchModelLanguagesRequest {
        <PatchModelLanguagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelLanguagesRequest {
    pub fn new() -> PatchModelLanguagesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated string languages = 3;


    pub fn get_languages(&self) -> &[::std::string::String] {
        &self.languages
    }
    pub fn clear_languages(&mut self) {
        self.languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_languages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_languages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.languages
    }

    // Take field
    pub fn take_languages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.languages, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchModelLanguagesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.languages)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.languages {
            os.write_string(3, &v)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchModelLanguagesRequest {
        PatchModelLanguagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchModelLanguagesRequest| { &m.user_app_id },
                |m: &mut PatchModelLanguagesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PatchModelLanguagesRequest| { &m.model_id },
                |m: &mut PatchModelLanguagesRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "languages",
                |m: &PatchModelLanguagesRequest| { &m.languages },
                |m: &mut PatchModelLanguagesRequest| { &mut m.languages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchModelLanguagesRequest| { &m.action },
                |m: &mut PatchModelLanguagesRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchModelLanguagesRequest>(
                "PatchModelLanguagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchModelLanguagesRequest {
        static instance: ::protobuf::rt::LazyV2<PatchModelLanguagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchModelLanguagesRequest::new)
    }
}

impl ::protobuf::Clear for PatchModelLanguagesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.languages.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchModelLanguagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelLanguagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelToolkitResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub toolkits: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelToolkitResponse {
    fn default() -> &'a MultiModelToolkitResponse {
        <MultiModelToolkitResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelToolkitResponse {
    pub fn new() -> MultiModelToolkitResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string toolkits = 2;


    pub fn get_toolkits(&self) -> &[::std::string::String] {
        &self.toolkits
    }
    pub fn clear_toolkits(&mut self) {
        self.toolkits.clear();
    }

    // Param is passed by value, moved
    pub fn set_toolkits(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.toolkits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_toolkits(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.toolkits
    }

    // Take field
    pub fn take_toolkits(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.toolkits, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelToolkitResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.toolkits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.toolkits {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.toolkits {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelToolkitResponse {
        MultiModelToolkitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelToolkitResponse| { &m.status },
                |m: &mut MultiModelToolkitResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "toolkits",
                |m: &MultiModelToolkitResponse| { &m.toolkits },
                |m: &mut MultiModelToolkitResponse| { &mut m.toolkits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelToolkitResponse>(
                "MultiModelToolkitResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelToolkitResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelToolkitResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelToolkitResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelToolkitResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.toolkits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelToolkitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelToolkitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelUseCaseResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub usecases: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelUseCaseResponse {
    fn default() -> &'a MultiModelUseCaseResponse {
        <MultiModelUseCaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelUseCaseResponse {
    pub fn new() -> MultiModelUseCaseResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string usecases = 2;


    pub fn get_usecases(&self) -> &[::std::string::String] {
        &self.usecases
    }
    pub fn clear_usecases(&mut self) {
        self.usecases.clear();
    }

    // Param is passed by value, moved
    pub fn set_usecases(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.usecases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_usecases(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.usecases
    }

    // Take field
    pub fn take_usecases(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.usecases, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelUseCaseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.usecases)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.usecases {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.usecases {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelUseCaseResponse {
        MultiModelUseCaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelUseCaseResponse| { &m.status },
                |m: &mut MultiModelUseCaseResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "usecases",
                |m: &MultiModelUseCaseResponse| { &m.usecases },
                |m: &mut MultiModelUseCaseResponse| { &mut m.usecases },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelUseCaseResponse>(
                "MultiModelUseCaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelUseCaseResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelUseCaseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelUseCaseResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelUseCaseResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.usecases.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelUseCaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelUseCaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelLanguageResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub languages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelLanguageResponse {
    fn default() -> &'a MultiModelLanguageResponse {
        <MultiModelLanguageResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelLanguageResponse {
    pub fn new() -> MultiModelLanguageResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string languages = 2;


    pub fn get_languages(&self) -> &[::std::string::String] {
        &self.languages
    }
    pub fn clear_languages(&mut self) {
        self.languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_languages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_languages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.languages
    }

    // Take field
    pub fn take_languages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.languages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelLanguageResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.languages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.languages {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelLanguageResponse {
        MultiModelLanguageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelLanguageResponse| { &m.status },
                |m: &mut MultiModelLanguageResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "languages",
                |m: &MultiModelLanguageResponse| { &m.languages },
                |m: &mut MultiModelLanguageResponse| { &mut m.languages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelLanguageResponse>(
                "MultiModelLanguageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelLanguageResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelLanguageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelLanguageResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelLanguageResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.languages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelLanguageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelLanguageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model: ::protobuf::SingularPtrField<super::resources::Model>,
    pub models: ::protobuf::RepeatedField<super::resources::Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelsRequest {
    fn default() -> &'a PostModelsRequest {
        <PostModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsRequest {
    pub fn new() -> PostModelsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.Model model = 2;


    pub fn get_model(&self) -> &super::resources::Model {
        self.model.as_ref().unwrap_or_else(|| <super::resources::Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: super::resources::Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut super::resources::Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> super::resources::Model {
        self.model.take().unwrap_or_else(|| super::resources::Model::new())
    }

    // repeated .clarifai.api.Model models = 3;


    pub fn get_models(&self) -> &[super::resources::Model] {
        &self.models
    }
    pub fn clear_models(&mut self) {
        self.models.clear();
    }

    // Param is passed by value, moved
    pub fn set_models(&mut self, v: ::protobuf::RepeatedField<super::resources::Model>) {
        self.models = v;
    }

    // Mutable pointer to the field.
    pub fn mut_models(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Model> {
        &mut self.models
    }

    // Take field
    pub fn take_models(&mut self) -> ::protobuf::RepeatedField<super::resources::Model> {
        ::std::mem::replace(&mut self.models, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostModelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.models)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.models {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelsRequest {
        PostModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelsRequest| { &m.user_app_id },
                |m: &mut PostModelsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "model",
                |m: &PostModelsRequest| { &m.model },
                |m: &mut PostModelsRequest| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "models",
                |m: &PostModelsRequest| { &m.models },
                |m: &mut PostModelsRequest| { &mut m.models },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelsRequest>(
                "PostModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelsRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelsRequest::new)
    }
}

impl ::protobuf::Clear for PostModelsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model.clear();
        self.models.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchModelsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub models: ::protobuf::RepeatedField<super::resources::Model>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchModelsRequest {
    fn default() -> &'a PatchModelsRequest {
        <PatchModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelsRequest {
    pub fn new() -> PatchModelsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Model models = 2;


    pub fn get_models(&self) -> &[super::resources::Model] {
        &self.models
    }
    pub fn clear_models(&mut self) {
        self.models.clear();
    }

    // Param is passed by value, moved
    pub fn set_models(&mut self, v: ::protobuf::RepeatedField<super::resources::Model>) {
        self.models = v;
    }

    // Mutable pointer to the field.
    pub fn mut_models(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Model> {
        &mut self.models
    }

    // Take field
    pub fn take_models(&mut self) -> ::protobuf::RepeatedField<super::resources::Model> {
        ::std::mem::replace(&mut self.models, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchModelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.models)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.models {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchModelsRequest {
        PatchModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchModelsRequest| { &m.user_app_id },
                |m: &mut PatchModelsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "models",
                |m: &PatchModelsRequest| { &m.models },
                |m: &mut PatchModelsRequest| { &mut m.models },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchModelsRequest| { &m.action },
                |m: &mut PatchModelsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchModelsRequest>(
                "PatchModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchModelsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchModelsRequest::new)
    }
}

impl ::protobuf::Clear for PatchModelsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.models.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdUpdateSource {
    // message fields
    pub id: ::std::string::String,
    pub new_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdUpdateSource {
    fn default() -> &'a IdUpdateSource {
        <IdUpdateSource as ::protobuf::Message>::default_instance()
    }
}

impl IdUpdateSource {
    pub fn new() -> IdUpdateSource {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string new_id = 2;


    pub fn get_new_id(&self) -> &str {
        &self.new_id
    }
    pub fn clear_new_id(&mut self) {
        self.new_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_id(&mut self, v: ::std::string::String) {
        self.new_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_id(&mut self) -> &mut ::std::string::String {
        &mut self.new_id
    }

    // Take field
    pub fn take_new_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.new_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IdUpdateSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.new_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.new_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.new_id.is_empty() {
            os.write_string(2, &self.new_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdUpdateSource {
        IdUpdateSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &IdUpdateSource| { &m.id },
                |m: &mut IdUpdateSource| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "new_id",
                |m: &IdUpdateSource| { &m.new_id },
                |m: &mut IdUpdateSource| { &mut m.new_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdUpdateSource>(
                "IdUpdateSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IdUpdateSource {
        static instance: ::protobuf::rt::LazyV2<IdUpdateSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IdUpdateSource::new)
    }
}

impl ::protobuf::Clear for IdUpdateSource {
    fn clear(&mut self) {
        self.id.clear();
        self.new_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdUpdateSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdUpdateSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchModelIdsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<IdUpdateSource>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchModelIdsRequest {
    fn default() -> &'a PatchModelIdsRequest {
        <PatchModelIdsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelIdsRequest {
    pub fn new() -> PatchModelIdsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.IdUpdateSource ids = 3;


    pub fn get_ids(&self) -> &[IdUpdateSource] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<IdUpdateSource>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<IdUpdateSource> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<IdUpdateSource> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchModelIdsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchModelIdsRequest {
        PatchModelIdsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchModelIdsRequest| { &m.user_app_id },
                |m: &mut PatchModelIdsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdUpdateSource>>(
                "ids",
                |m: &PatchModelIdsRequest| { &m.ids },
                |m: &mut PatchModelIdsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchModelIdsRequest| { &m.action },
                |m: &mut PatchModelIdsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchModelIdsRequest>(
                "PatchModelIdsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchModelIdsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchModelIdsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchModelIdsRequest::new)
    }
}

impl ::protobuf::Clear for PatchModelIdsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchModelIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelIdsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteModelRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteModelRequest {
    fn default() -> &'a DeleteModelRequest {
        <DeleteModelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelRequest {
    pub fn new() -> DeleteModelRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteModelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteModelRequest {
        DeleteModelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteModelRequest| { &m.user_app_id },
                |m: &mut DeleteModelRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &DeleteModelRequest| { &m.model_id },
                |m: &mut DeleteModelRequest| { &mut m.model_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteModelRequest>(
                "DeleteModelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteModelRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteModelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteModelRequest::new)
    }
}

impl ::protobuf::Clear for DeleteModelRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteModelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteModelsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub delete_all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteModelsRequest {
    fn default() -> &'a DeleteModelsRequest {
        <DeleteModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelsRequest {
    pub fn new() -> DeleteModelsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // bool delete_all = 3;


    pub fn get_delete_all(&self) -> bool {
        self.delete_all
    }
    pub fn clear_delete_all(&mut self) {
        self.delete_all = false;
    }

    // Param is passed by value, moved
    pub fn set_delete_all(&mut self, v: bool) {
        self.delete_all = v;
    }
}

impl ::protobuf::Message for DeleteModelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete_all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteModelsRequest {
        DeleteModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteModelsRequest| { &m.user_app_id },
                |m: &mut DeleteModelsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteModelsRequest| { &m.ids },
                |m: &mut DeleteModelsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "delete_all",
                |m: &DeleteModelsRequest| { &m.delete_all },
                |m: &mut DeleteModelsRequest| { &mut m.delete_all },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteModelsRequest>(
                "DeleteModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteModelsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteModelsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteModelsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_query: ::protobuf::SingularPtrField<super::resources::ModelQuery>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelsSearchesRequest {
    fn default() -> &'a PostModelsSearchesRequest {
        <PostModelsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelsSearchesRequest {
    pub fn new() -> PostModelsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.ModelQuery model_query = 2;


    pub fn get_model_query(&self) -> &super::resources::ModelQuery {
        self.model_query.as_ref().unwrap_or_else(|| <super::resources::ModelQuery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_query(&mut self) {
        self.model_query.clear();
    }

    pub fn has_model_query(&self) -> bool {
        self.model_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_query(&mut self, v: super::resources::ModelQuery) {
        self.model_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_query(&mut self) -> &mut super::resources::ModelQuery {
        if self.model_query.is_none() {
            self.model_query.set_default();
        }
        self.model_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_query(&mut self) -> super::resources::ModelQuery {
        self.model_query.take().unwrap_or_else(|| super::resources::ModelQuery::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostModelsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model_query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelsSearchesRequest {
        PostModelsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelsSearchesRequest| { &m.user_app_id },
                |m: &mut PostModelsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelQuery>>(
                "model_query",
                |m: &PostModelsSearchesRequest| { &m.model_query },
                |m: &mut PostModelsSearchesRequest| { &mut m.model_query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostModelsSearchesRequest| { &m.pagination },
                |m: &mut PostModelsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelsSearchesRequest>(
                "PostModelsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostModelsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_query.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleModelResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model: ::protobuf::SingularPtrField<super::resources::Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleModelResponse {
    fn default() -> &'a SingleModelResponse {
        <SingleModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelResponse {
    pub fn new() -> SingleModelResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Model model = 2;


    pub fn get_model(&self) -> &super::resources::Model {
        self.model.as_ref().unwrap_or_else(|| <super::resources::Model as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: super::resources::Model) {
        self.model = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut super::resources::Model {
        if self.model.is_none() {
            self.model.set_default();
        }
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> super::resources::Model {
        self.model.take().unwrap_or_else(|| super::resources::Model::new())
    }
}

impl ::protobuf::Message for SingleModelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleModelResponse {
        SingleModelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleModelResponse| { &m.status },
                |m: &mut SingleModelResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "model",
                |m: &SingleModelResponse| { &m.model },
                |m: &mut SingleModelResponse| { &mut m.model },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleModelResponse>(
                "SingleModelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleModelResponse {
        static instance: ::protobuf::rt::LazyV2<SingleModelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleModelResponse::new)
    }
}

impl ::protobuf::Clear for SingleModelResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub models: ::protobuf::RepeatedField<super::resources::Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelResponse {
    fn default() -> &'a MultiModelResponse {
        <MultiModelResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelResponse {
    pub fn new() -> MultiModelResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Model models = 2;


    pub fn get_models(&self) -> &[super::resources::Model] {
        &self.models
    }
    pub fn clear_models(&mut self) {
        self.models.clear();
    }

    // Param is passed by value, moved
    pub fn set_models(&mut self, v: ::protobuf::RepeatedField<super::resources::Model>) {
        self.models = v;
    }

    // Mutable pointer to the field.
    pub fn mut_models(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Model> {
        &mut self.models
    }

    // Take field
    pub fn take_models(&mut self) -> ::protobuf::RepeatedField<super::resources::Model> {
        ::std::mem::replace(&mut self.models, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.models)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.models {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelResponse {
        MultiModelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelResponse| { &m.status },
                |m: &mut MultiModelResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Model>>(
                "models",
                |m: &MultiModelResponse| { &m.models },
                |m: &mut MultiModelResponse| { &mut m.models },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelResponse>(
                "MultiModelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.models.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchModelVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub model_versions: ::protobuf::RepeatedField<super::resources::ModelVersion>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchModelVersionsRequest {
    fn default() -> &'a PatchModelVersionsRequest {
        <PatchModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchModelVersionsRequest {
    pub fn new() -> PatchModelVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ModelVersion model_versions = 3;


    pub fn get_model_versions(&self) -> &[super::resources::ModelVersion] {
        &self.model_versions
    }
    pub fn clear_model_versions(&mut self) {
        self.model_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_versions(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelVersion>) {
        self.model_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_versions(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelVersion> {
        &mut self.model_versions
    }

    // Take field
    pub fn take_model_versions(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelVersion> {
        ::std::mem::replace(&mut self.model_versions, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchModelVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_versions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchModelVersionsRequest {
        PatchModelVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchModelVersionsRequest| { &m.user_app_id },
                |m: &mut PatchModelVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PatchModelVersionsRequest| { &m.model_id },
                |m: &mut PatchModelVersionsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersion>>(
                "model_versions",
                |m: &PatchModelVersionsRequest| { &m.model_versions },
                |m: &mut PatchModelVersionsRequest| { &mut m.model_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchModelVersionsRequest| { &m.action },
                |m: &mut PatchModelVersionsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchModelVersionsRequest>(
                "PatchModelVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchModelVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchModelVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchModelVersionsRequest::new)
    }
}

impl ::protobuf::Clear for PatchModelVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchModelVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelVersionRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelVersionRequest {
    fn default() -> &'a GetModelVersionRequest {
        <GetModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionRequest {
    pub fn new() -> GetModelVersionRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetModelVersionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelVersionRequest {
        GetModelVersionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelVersionRequest| { &m.user_app_id },
                |m: &mut GetModelVersionRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &GetModelVersionRequest| { &m.model_id },
                |m: &mut GetModelVersionRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &GetModelVersionRequest| { &m.version_id },
                |m: &mut GetModelVersionRequest| { &mut m.version_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelVersionRequest>(
                "GetModelVersionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelVersionRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelVersionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelVersionRequest::new)
    }
}

impl ::protobuf::Clear for GetModelVersionRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    pub concept_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelVersionsRequest {
    fn default() -> &'a ListModelVersionsRequest {
        <ListModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionsRequest {
    pub fn new() -> ListModelVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // uint32 page = 3;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 4;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // repeated string concept_ids = 5;


    pub fn get_concept_ids(&self) -> &[::std::string::String] {
        &self.concept_ids
    }
    pub fn clear_concept_ids(&mut self) {
        self.concept_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_concept_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.concept_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_concept_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.concept_ids
    }

    // Take field
    pub fn take_concept_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.concept_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListModelVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.concept_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.concept_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        for v in &self.concept_ids {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelVersionsRequest {
        ListModelVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelVersionsRequest| { &m.user_app_id },
                |m: &mut ListModelVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &ListModelVersionsRequest| { &m.model_id },
                |m: &mut ListModelVersionsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelVersionsRequest| { &m.page },
                |m: &mut ListModelVersionsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelVersionsRequest| { &m.per_page },
                |m: &mut ListModelVersionsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "concept_ids",
                |m: &ListModelVersionsRequest| { &m.concept_ids },
                |m: &mut ListModelVersionsRequest| { &mut m.concept_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelVersionsRequest>(
                "ListModelVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelVersionsRequest::new)
    }
}

impl ::protobuf::Clear for ListModelVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.concept_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteModelVersionRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteModelVersionRequest {
    fn default() -> &'a DeleteModelVersionRequest {
        <DeleteModelVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModelVersionRequest {
    pub fn new() -> DeleteModelVersionRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 3;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 4;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteModelVersionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(3, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(4, &self.version_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteModelVersionRequest {
        DeleteModelVersionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteModelVersionRequest| { &m.user_app_id },
                |m: &mut DeleteModelVersionRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &DeleteModelVersionRequest| { &m.model_id },
                |m: &mut DeleteModelVersionRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &DeleteModelVersionRequest| { &m.version_id },
                |m: &mut DeleteModelVersionRequest| { &mut m.version_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteModelVersionRequest>(
                "DeleteModelVersionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteModelVersionRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteModelVersionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteModelVersionRequest::new)
    }
}

impl ::protobuf::Clear for DeleteModelVersionRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteModelVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModelVersionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleModelVersionResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_version: ::protobuf::SingularPtrField<super::resources::ModelVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionResponse {
    fn default() -> &'a SingleModelVersionResponse {
        <SingleModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionResponse {
    pub fn new() -> SingleModelVersionResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.ModelVersion model_version = 2;


    pub fn get_model_version(&self) -> &super::resources::ModelVersion {
        self.model_version.as_ref().unwrap_or_else(|| <super::resources::ModelVersion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_version(&mut self) {
        self.model_version.clear();
    }

    pub fn has_model_version(&self) -> bool {
        self.model_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_version(&mut self, v: super::resources::ModelVersion) {
        self.model_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version(&mut self) -> &mut super::resources::ModelVersion {
        if self.model_version.is_none() {
            self.model_version.set_default();
        }
        self.model_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_version(&mut self) -> super::resources::ModelVersion {
        self.model_version.take().unwrap_or_else(|| super::resources::ModelVersion::new())
    }
}

impl ::protobuf::Message for SingleModelVersionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model_version.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleModelVersionResponse {
        SingleModelVersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleModelVersionResponse| { &m.status },
                |m: &mut SingleModelVersionResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersion>>(
                "model_version",
                |m: &SingleModelVersionResponse| { &m.model_version },
                |m: &mut SingleModelVersionResponse| { &mut m.model_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleModelVersionResponse>(
                "SingleModelVersionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleModelVersionResponse {
        static instance: ::protobuf::rt::LazyV2<SingleModelVersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleModelVersionResponse::new)
    }
}

impl ::protobuf::Clear for SingleModelVersionResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelVersionResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_versions: ::protobuf::RepeatedField<super::resources::ModelVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionResponse {
    fn default() -> &'a MultiModelVersionResponse {
        <MultiModelVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionResponse {
    pub fn new() -> MultiModelVersionResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ModelVersion model_versions = 2;


    pub fn get_model_versions(&self) -> &[super::resources::ModelVersion] {
        &self.model_versions
    }
    pub fn clear_model_versions(&mut self) {
        self.model_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_versions(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelVersion>) {
        self.model_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_versions(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelVersion> {
        &mut self.model_versions
    }

    // Take field
    pub fn take_model_versions(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelVersion> {
        ::std::mem::replace(&mut self.model_versions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelVersionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_versions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.model_versions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelVersionResponse {
        MultiModelVersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelVersionResponse| { &m.status },
                |m: &mut MultiModelVersionResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersion>>(
                "model_versions",
                |m: &MultiModelVersionResponse| { &m.model_versions },
                |m: &mut MultiModelVersionResponse| { &mut m.model_versions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelVersionResponse>(
                "MultiModelVersionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelVersionResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelVersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelVersionResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelVersionResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_versions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub model_versions: ::protobuf::RepeatedField<super::resources::ModelVersion>,
    pub search: ::protobuf::SingularPtrField<super::resources::Search>,
    pub train_search: ::protobuf::SingularPtrField<super::resources::Search>,
    pub test_search: ::protobuf::SingularPtrField<super::resources::Search>,
    pub evaluate_after_training: bool,
    pub description: ::std::string::String,
    pub dataset_version: ::protobuf::SingularPtrField<super::resources::DatasetVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsRequest {
    fn default() -> &'a PostModelVersionsRequest {
        <PostModelVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsRequest {
    pub fn new() -> PostModelVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ModelVersion model_versions = 3;


    pub fn get_model_versions(&self) -> &[super::resources::ModelVersion] {
        &self.model_versions
    }
    pub fn clear_model_versions(&mut self) {
        self.model_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_versions(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelVersion>) {
        self.model_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_versions(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelVersion> {
        &mut self.model_versions
    }

    // Take field
    pub fn take_model_versions(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelVersion> {
        ::std::mem::replace(&mut self.model_versions, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Search search = 4;


    pub fn get_search(&self) -> &super::resources::Search {
        self.search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_search(&mut self) {
        self.search.clear();
    }

    pub fn has_search(&self) -> bool {
        self.search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: super::resources::Search) {
        self.search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search(&mut self) -> &mut super::resources::Search {
        if self.search.is_none() {
            self.search.set_default();
        }
        self.search.as_mut().unwrap()
    }

    // Take field
    pub fn take_search(&mut self) -> super::resources::Search {
        self.search.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // .clarifai.api.Search train_search = 5;


    pub fn get_train_search(&self) -> &super::resources::Search {
        self.train_search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_train_search(&mut self) {
        self.train_search.clear();
    }

    pub fn has_train_search(&self) -> bool {
        self.train_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train_search(&mut self, v: super::resources::Search) {
        self.train_search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_train_search(&mut self) -> &mut super::resources::Search {
        if self.train_search.is_none() {
            self.train_search.set_default();
        }
        self.train_search.as_mut().unwrap()
    }

    // Take field
    pub fn take_train_search(&mut self) -> super::resources::Search {
        self.train_search.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // .clarifai.api.Search test_search = 6;


    pub fn get_test_search(&self) -> &super::resources::Search {
        self.test_search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_test_search(&mut self) {
        self.test_search.clear();
    }

    pub fn has_test_search(&self) -> bool {
        self.test_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_search(&mut self, v: super::resources::Search) {
        self.test_search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_test_search(&mut self) -> &mut super::resources::Search {
        if self.test_search.is_none() {
            self.test_search.set_default();
        }
        self.test_search.as_mut().unwrap()
    }

    // Take field
    pub fn take_test_search(&mut self) -> super::resources::Search {
        self.test_search.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // bool evaluate_after_training = 7;


    pub fn get_evaluate_after_training(&self) -> bool {
        self.evaluate_after_training
    }
    pub fn clear_evaluate_after_training(&mut self) {
        self.evaluate_after_training = false;
    }

    // Param is passed by value, moved
    pub fn set_evaluate_after_training(&mut self, v: bool) {
        self.evaluate_after_training = v;
    }

    // string description = 8;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .clarifai.api.DatasetVersion dataset_version = 9;


    pub fn get_dataset_version(&self) -> &super::resources::DatasetVersion {
        self.dataset_version.as_ref().unwrap_or_else(|| <super::resources::DatasetVersion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dataset_version(&mut self) {
        self.dataset_version.clear();
    }

    pub fn has_dataset_version(&self) -> bool {
        self.dataset_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataset_version(&mut self, v: super::resources::DatasetVersion) {
        self.dataset_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset_version(&mut self) -> &mut super::resources::DatasetVersion {
        if self.dataset_version.is_none() {
            self.dataset_version.set_default();
        }
        self.dataset_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataset_version(&mut self) -> super::resources::DatasetVersion {
        self.dataset_version.take().unwrap_or_else(|| super::resources::DatasetVersion::new())
    }
}

impl ::protobuf::Message for PostModelVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.train_search {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.test_search {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dataset_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_versions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.train_search)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.test_search)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.evaluate_after_training = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataset_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.model_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.train_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.test_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.evaluate_after_training != false {
            my_size += 2;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.description);
        }
        if let Some(ref v) = self.dataset_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.model_versions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.search.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.train_search.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.test_search.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.evaluate_after_training != false {
            os.write_bool(7, self.evaluate_after_training)?;
        }
        if !self.description.is_empty() {
            os.write_string(8, &self.description)?;
        }
        if let Some(ref v) = self.dataset_version.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelVersionsRequest {
        PostModelVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelVersionsRequest| { &m.user_app_id },
                |m: &mut PostModelVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PostModelVersionsRequest| { &m.model_id },
                |m: &mut PostModelVersionsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersion>>(
                "model_versions",
                |m: &PostModelVersionsRequest| { &m.model_versions },
                |m: &mut PostModelVersionsRequest| { &mut m.model_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "search",
                |m: &PostModelVersionsRequest| { &m.search },
                |m: &mut PostModelVersionsRequest| { &mut m.search },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "train_search",
                |m: &PostModelVersionsRequest| { &m.train_search },
                |m: &mut PostModelVersionsRequest| { &mut m.train_search },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "test_search",
                |m: &PostModelVersionsRequest| { &m.test_search },
                |m: &mut PostModelVersionsRequest| { &mut m.test_search },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "evaluate_after_training",
                |m: &PostModelVersionsRequest| { &m.evaluate_after_training },
                |m: &mut PostModelVersionsRequest| { &mut m.evaluate_after_training },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &PostModelVersionsRequest| { &m.description },
                |m: &mut PostModelVersionsRequest| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::DatasetVersion>>(
                "dataset_version",
                |m: &PostModelVersionsRequest| { &m.dataset_version },
                |m: &mut PostModelVersionsRequest| { &mut m.dataset_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelVersionsRequest>(
                "PostModelVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelVersionsRequest::new)
    }
}

impl ::protobuf::Clear for PostModelVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_versions.clear();
        self.search.clear();
        self.train_search.clear();
        self.test_search.clear();
        self.evaluate_after_training = false;
        self.description.clear();
        self.dataset_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelVersionPublishRequest {
    // message fields
    pub version_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelVersionPublishRequest {
    fn default() -> &'a ModelVersionPublishRequest {
        <ModelVersionPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionPublishRequest {
    pub fn new() -> ModelVersionPublishRequest {
        ::std::default::Default::default()
    }

    // string version_id = 1;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModelVersionPublishRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelVersionPublishRequest {
        ModelVersionPublishRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &ModelVersionPublishRequest| { &m.version_id },
                |m: &mut ModelVersionPublishRequest| { &mut m.version_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelVersionPublishRequest>(
                "ModelVersionPublishRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelVersionPublishRequest {
        static instance: ::protobuf::rt::LazyV2<ModelVersionPublishRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelVersionPublishRequest::new)
    }
}

impl ::protobuf::Clear for ModelVersionPublishRequest {
    fn clear(&mut self) {
        self.version_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelVersionPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionPublishRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelVersionsPublishRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub publications: ::protobuf::RepeatedField<ModelVersionPublishRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsPublishRequest {
    fn default() -> &'a PostModelVersionsPublishRequest {
        <PostModelVersionsPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsPublishRequest {
    pub fn new() -> PostModelVersionsPublishRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ModelVersionPublishRequest publications = 3;


    pub fn get_publications(&self) -> &[ModelVersionPublishRequest] {
        &self.publications
    }
    pub fn clear_publications(&mut self) {
        self.publications.clear();
    }

    // Param is passed by value, moved
    pub fn set_publications(&mut self, v: ::protobuf::RepeatedField<ModelVersionPublishRequest>) {
        self.publications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publications(&mut self) -> &mut ::protobuf::RepeatedField<ModelVersionPublishRequest> {
        &mut self.publications
    }

    // Take field
    pub fn take_publications(&mut self) -> ::protobuf::RepeatedField<ModelVersionPublishRequest> {
        ::std::mem::replace(&mut self.publications, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostModelVersionsPublishRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.publications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.publications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.publications {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelVersionsPublishRequest {
        PostModelVersionsPublishRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelVersionsPublishRequest| { &m.user_app_id },
                |m: &mut PostModelVersionsPublishRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PostModelVersionsPublishRequest| { &m.model_id },
                |m: &mut PostModelVersionsPublishRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelVersionPublishRequest>>(
                "publications",
                |m: &PostModelVersionsPublishRequest| { &m.publications },
                |m: &mut PostModelVersionsPublishRequest| { &mut m.publications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelVersionsPublishRequest>(
                "PostModelVersionsPublishRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelVersionsPublishRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelVersionsPublishRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelVersionsPublishRequest::new)
    }
}

impl ::protobuf::Clear for PostModelVersionsPublishRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.publications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelVersionsPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsPublishRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelVersionUnpublishRequest {
    // message fields
    pub version_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelVersionUnpublishRequest {
    fn default() -> &'a ModelVersionUnpublishRequest {
        <ModelVersionUnpublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModelVersionUnpublishRequest {
    pub fn new() -> ModelVersionUnpublishRequest {
        ::std::default::Default::default()
    }

    // string version_id = 1;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModelVersionUnpublishRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version_id.is_empty() {
            os.write_string(1, &self.version_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelVersionUnpublishRequest {
        ModelVersionUnpublishRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &ModelVersionUnpublishRequest| { &m.version_id },
                |m: &mut ModelVersionUnpublishRequest| { &mut m.version_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelVersionUnpublishRequest>(
                "ModelVersionUnpublishRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelVersionUnpublishRequest {
        static instance: ::protobuf::rt::LazyV2<ModelVersionUnpublishRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelVersionUnpublishRequest::new)
    }
}

impl ::protobuf::Clear for ModelVersionUnpublishRequest {
    fn clear(&mut self) {
        self.version_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelVersionUnpublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelVersionUnpublishRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelVersionsUnPublishRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub publications: ::protobuf::RepeatedField<ModelVersionUnpublishRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelVersionsUnPublishRequest {
    fn default() -> &'a PostModelVersionsUnPublishRequest {
        <PostModelVersionsUnPublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionsUnPublishRequest {
    pub fn new() -> PostModelVersionsUnPublishRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.ModelVersionUnpublishRequest publications = 3;


    pub fn get_publications(&self) -> &[ModelVersionUnpublishRequest] {
        &self.publications
    }
    pub fn clear_publications(&mut self) {
        self.publications.clear();
    }

    // Param is passed by value, moved
    pub fn set_publications(&mut self, v: ::protobuf::RepeatedField<ModelVersionUnpublishRequest>) {
        self.publications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publications(&mut self) -> &mut ::protobuf::RepeatedField<ModelVersionUnpublishRequest> {
        &mut self.publications
    }

    // Take field
    pub fn take_publications(&mut self) -> ::protobuf::RepeatedField<ModelVersionUnpublishRequest> {
        ::std::mem::replace(&mut self.publications, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostModelVersionsUnPublishRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.publications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.publications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        for value in &self.publications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        for v in &self.publications {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelVersionsUnPublishRequest {
        PostModelVersionsUnPublishRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelVersionsUnPublishRequest| { &m.user_app_id },
                |m: &mut PostModelVersionsUnPublishRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PostModelVersionsUnPublishRequest| { &m.model_id },
                |m: &mut PostModelVersionsUnPublishRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelVersionUnpublishRequest>>(
                "publications",
                |m: &PostModelVersionsUnPublishRequest| { &m.publications },
                |m: &mut PostModelVersionsUnPublishRequest| { &mut m.publications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelVersionsUnPublishRequest>(
                "PostModelVersionsUnPublishRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelVersionsUnPublishRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelVersionsUnPublishRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelVersionsUnPublishRequest::new)
    }
}

impl ::protobuf::Clear for PostModelVersionsUnPublishRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.publications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelVersionsUnPublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionsUnPublishRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostModelVersionMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub max_examples: u32,
    pub test_search: ::protobuf::SingularPtrField<super::resources::Search>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostModelVersionMetricsRequest {
    fn default() -> &'a PostModelVersionMetricsRequest {
        <PostModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostModelVersionMetricsRequest {
    pub fn new() -> PostModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // uint32 max_examples = 4;


    pub fn get_max_examples(&self) -> u32 {
        self.max_examples
    }
    pub fn clear_max_examples(&mut self) {
        self.max_examples = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_examples(&mut self, v: u32) {
        self.max_examples = v;
    }

    // .clarifai.api.Search test_search = 5;


    pub fn get_test_search(&self) -> &super::resources::Search {
        self.test_search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_test_search(&mut self) {
        self.test_search.clear();
    }

    pub fn has_test_search(&self) -> bool {
        self.test_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_search(&mut self, v: super::resources::Search) {
        self.test_search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_test_search(&mut self) -> &mut super::resources::Search {
        if self.test_search.is_none() {
            self.test_search.set_default();
        }
        self.test_search.as_mut().unwrap()
    }

    // Take field
    pub fn take_test_search(&mut self) -> super::resources::Search {
        self.test_search.take().unwrap_or_else(|| super::resources::Search::new())
    }
}

impl ::protobuf::Message for PostModelVersionMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.test_search {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_examples = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.test_search)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if self.max_examples != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_examples, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.test_search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if self.max_examples != 0 {
            os.write_uint32(4, self.max_examples)?;
        }
        if let Some(ref v) = self.test_search.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostModelVersionMetricsRequest {
        PostModelVersionMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostModelVersionMetricsRequest| { &m.user_app_id },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &PostModelVersionMetricsRequest| { &m.model_id },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &PostModelVersionMetricsRequest| { &m.version_id },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_examples",
                |m: &PostModelVersionMetricsRequest| { &m.max_examples },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.max_examples },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "test_search",
                |m: &PostModelVersionMetricsRequest| { &m.test_search },
                |m: &mut PostModelVersionMetricsRequest| { &mut m.test_search },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostModelVersionMetricsRequest>(
                "PostModelVersionMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostModelVersionMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<PostModelVersionMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostModelVersionMetricsRequest::new)
    }
}

impl ::protobuf::Clear for PostModelVersionMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.max_examples = 0;
        self.test_search.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostModelVersionMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelVersionMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub fields: ::protobuf::SingularPtrField<super::resources::FieldsValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelVersionMetricsRequest {
    fn default() -> &'a GetModelVersionMetricsRequest {
        <GetModelVersionMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionMetricsRequest {
    pub fn new() -> GetModelVersionMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string version_id = 3;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // .clarifai.api.FieldsValue fields = 4;


    pub fn get_fields(&self) -> &super::resources::FieldsValue {
        self.fields.as_ref().unwrap_or_else(|| <super::resources::FieldsValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    pub fn has_fields(&self) -> bool {
        self.fields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: super::resources::FieldsValue) {
        self.fields = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fields(&mut self) -> &mut super::resources::FieldsValue {
        if self.fields.is_none() {
            self.fields.set_default();
        }
        self.fields.as_mut().unwrap()
    }

    // Take field
    pub fn take_fields(&mut self) -> super::resources::FieldsValue {
        self.fields.take().unwrap_or_else(|| super::resources::FieldsValue::new())
    }
}

impl ::protobuf::Message for GetModelVersionMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.version_id);
        }
        if let Some(ref v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(3, &self.version_id)?;
        }
        if let Some(ref v) = self.fields.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelVersionMetricsRequest {
        GetModelVersionMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelVersionMetricsRequest| { &m.user_app_id },
                |m: &mut GetModelVersionMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &GetModelVersionMetricsRequest| { &m.model_id },
                |m: &mut GetModelVersionMetricsRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &GetModelVersionMetricsRequest| { &m.version_id },
                |m: &mut GetModelVersionMetricsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::FieldsValue>>(
                "fields",
                |m: &GetModelVersionMetricsRequest| { &m.fields },
                |m: &mut GetModelVersionMetricsRequest| { &mut m.fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelVersionMetricsRequest>(
                "GetModelVersionMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelVersionMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelVersionMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelVersionMetricsRequest::new)
    }
}

impl ::protobuf::Clear for GetModelVersionMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.version_id.clear();
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelVersionMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelTypeRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_type_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelTypeRequest {
    fn default() -> &'a GetModelTypeRequest {
        <GetModelTypeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelTypeRequest {
    pub fn new() -> GetModelTypeRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_type_id = 2;


    pub fn get_model_type_id(&self) -> &str {
        &self.model_type_id
    }
    pub fn clear_model_type_id(&mut self) {
        self.model_type_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_type_id(&mut self, v: ::std::string::String) {
        self.model_type_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_type_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_type_id
    }

    // Take field
    pub fn take_model_type_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_type_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetModelTypeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_type_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_type_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_type_id.is_empty() {
            os.write_string(2, &self.model_type_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelTypeRequest {
        GetModelTypeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelTypeRequest| { &m.user_app_id },
                |m: &mut GetModelTypeRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_type_id",
                |m: &GetModelTypeRequest| { &m.model_type_id },
                |m: &mut GetModelTypeRequest| { &mut m.model_type_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelTypeRequest>(
                "GetModelTypeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelTypeRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelTypeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelTypeRequest::new)
    }
}

impl ::protobuf::Clear for GetModelTypeRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_type_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelTypeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelTypeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelTypesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelTypesRequest {
    fn default() -> &'a ListModelTypesRequest {
        <ListModelTypesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelTypesRequest {
    pub fn new() -> ListModelTypesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListModelTypesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelTypesRequest {
        ListModelTypesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelTypesRequest| { &m.user_app_id },
                |m: &mut ListModelTypesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelTypesRequest| { &m.page },
                |m: &mut ListModelTypesRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelTypesRequest| { &m.per_page },
                |m: &mut ListModelTypesRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelTypesRequest>(
                "ListModelTypesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelTypesRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelTypesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelTypesRequest::new)
    }
}

impl ::protobuf::Clear for ListModelTypesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelTypesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelTypesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOpenSourceLicensesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOpenSourceLicensesRequest {
    fn default() -> &'a ListOpenSourceLicensesRequest {
        <ListOpenSourceLicensesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenSourceLicensesRequest {
    pub fn new() -> ListOpenSourceLicensesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListOpenSourceLicensesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOpenSourceLicensesRequest {
        ListOpenSourceLicensesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOpenSourceLicensesRequest>(
                "ListOpenSourceLicensesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOpenSourceLicensesRequest {
        static instance: ::protobuf::rt::LazyV2<ListOpenSourceLicensesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOpenSourceLicensesRequest::new)
    }
}

impl ::protobuf::Clear for ListOpenSourceLicensesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOpenSourceLicensesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenSourceLicensesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOpenSourceLicensesResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub licenses: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOpenSourceLicensesResponse {
    fn default() -> &'a ListOpenSourceLicensesResponse {
        <ListOpenSourceLicensesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenSourceLicensesResponse {
    pub fn new() -> ListOpenSourceLicensesResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string licenses = 2;


    pub fn get_licenses(&self) -> &[::std::string::String] {
        &self.licenses
    }
    pub fn clear_licenses(&mut self) {
        self.licenses.clear();
    }

    // Param is passed by value, moved
    pub fn set_licenses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.licenses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_licenses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.licenses
    }

    // Take field
    pub fn take_licenses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.licenses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListOpenSourceLicensesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.licenses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.licenses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.licenses {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOpenSourceLicensesResponse {
        ListOpenSourceLicensesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &ListOpenSourceLicensesResponse| { &m.status },
                |m: &mut ListOpenSourceLicensesResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "licenses",
                |m: &ListOpenSourceLicensesResponse| { &m.licenses },
                |m: &mut ListOpenSourceLicensesResponse| { &mut m.licenses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOpenSourceLicensesResponse>(
                "ListOpenSourceLicensesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOpenSourceLicensesResponse {
        static instance: ::protobuf::rt::LazyV2<ListOpenSourceLicensesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOpenSourceLicensesResponse::new)
    }
}

impl ::protobuf::Clear for ListOpenSourceLicensesResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.licenses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOpenSourceLicensesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenSourceLicensesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleModelTypeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_type: ::protobuf::SingularPtrField<super::resources::ModelType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleModelTypeResponse {
    fn default() -> &'a SingleModelTypeResponse {
        <SingleModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelTypeResponse {
    pub fn new() -> SingleModelTypeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.ModelType model_type = 2;


    pub fn get_model_type(&self) -> &super::resources::ModelType {
        self.model_type.as_ref().unwrap_or_else(|| <super::resources::ModelType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_type(&mut self) {
        self.model_type.clear();
    }

    pub fn has_model_type(&self) -> bool {
        self.model_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_type(&mut self, v: super::resources::ModelType) {
        self.model_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_type(&mut self) -> &mut super::resources::ModelType {
        if self.model_type.is_none() {
            self.model_type.set_default();
        }
        self.model_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_type(&mut self) -> super::resources::ModelType {
        self.model_type.take().unwrap_or_else(|| super::resources::ModelType::new())
    }
}

impl ::protobuf::Message for SingleModelTypeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleModelTypeResponse {
        SingleModelTypeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleModelTypeResponse| { &m.status },
                |m: &mut SingleModelTypeResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelType>>(
                "model_type",
                |m: &SingleModelTypeResponse| { &m.model_type },
                |m: &mut SingleModelTypeResponse| { &mut m.model_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleModelTypeResponse>(
                "SingleModelTypeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleModelTypeResponse {
        static instance: ::protobuf::rt::LazyV2<SingleModelTypeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleModelTypeResponse::new)
    }
}

impl ::protobuf::Clear for SingleModelTypeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelTypeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelTypeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_types: ::protobuf::RepeatedField<super::resources::ModelType>,
    pub model_importers: ::protobuf::SingularPtrField<super::resources::ModelTypeField>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelTypeResponse {
    fn default() -> &'a MultiModelTypeResponse {
        <MultiModelTypeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelTypeResponse {
    pub fn new() -> MultiModelTypeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ModelType model_types = 2;


    pub fn get_model_types(&self) -> &[super::resources::ModelType] {
        &self.model_types
    }
    pub fn clear_model_types(&mut self) {
        self.model_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_types(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelType>) {
        self.model_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_types(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelType> {
        &mut self.model_types
    }

    // Take field
    pub fn take_model_types(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelType> {
        ::std::mem::replace(&mut self.model_types, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.ModelTypeField model_importers = 3;


    pub fn get_model_importers(&self) -> &super::resources::ModelTypeField {
        self.model_importers.as_ref().unwrap_or_else(|| <super::resources::ModelTypeField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_importers(&mut self) {
        self.model_importers.clear();
    }

    pub fn has_model_importers(&self) -> bool {
        self.model_importers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_importers(&mut self, v: super::resources::ModelTypeField) {
        self.model_importers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_importers(&mut self) -> &mut super::resources::ModelTypeField {
        if self.model_importers.is_none() {
            self.model_importers.set_default();
        }
        self.model_importers.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_importers(&mut self) -> super::resources::ModelTypeField {
        self.model_importers.take().unwrap_or_else(|| super::resources::ModelTypeField::new())
    }
}

impl ::protobuf::Message for MultiModelTypeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_types {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_importers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_types)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_importers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.model_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.model_importers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.model_types {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.model_importers.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelTypeResponse {
        MultiModelTypeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelTypeResponse| { &m.status },
                |m: &mut MultiModelTypeResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelType>>(
                "model_types",
                |m: &MultiModelTypeResponse| { &m.model_types },
                |m: &mut MultiModelTypeResponse| { &mut m.model_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelTypeField>>(
                "model_importers",
                |m: &MultiModelTypeResponse| { &m.model_importers },
                |m: &mut MultiModelTypeResponse| { &mut m.model_importers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelTypeResponse>(
                "MultiModelTypeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelTypeResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelTypeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelTypeResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelTypeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_types.clear();
        self.model_importers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelTypeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelTypeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetModelVersionInputExampleRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub model_version_id: ::std::string::String,
    pub example_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetModelVersionInputExampleRequest {
    fn default() -> &'a GetModelVersionInputExampleRequest {
        <GetModelVersionInputExampleRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetModelVersionInputExampleRequest {
    pub fn new() -> GetModelVersionInputExampleRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string model_version_id = 3;


    pub fn get_model_version_id(&self) -> &str {
        &self.model_version_id
    }
    pub fn clear_model_version_id(&mut self) {
        self.model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_id(&mut self, v: ::std::string::String) {
        self.model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_version_id
    }

    // Take field
    pub fn take_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_version_id, ::std::string::String::new())
    }

    // string example_id = 4;


    pub fn get_example_id(&self) -> &str {
        &self.example_id
    }
    pub fn clear_example_id(&mut self) {
        self.example_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_example_id(&mut self, v: ::std::string::String) {
        self.example_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_example_id(&mut self) -> &mut ::std::string::String {
        &mut self.example_id
    }

    // Take field
    pub fn take_example_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.example_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetModelVersionInputExampleRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.example_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if !self.example_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.example_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if !self.example_id.is_empty() {
            os.write_string(4, &self.example_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetModelVersionInputExampleRequest {
        GetModelVersionInputExampleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetModelVersionInputExampleRequest| { &m.user_app_id },
                |m: &mut GetModelVersionInputExampleRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &GetModelVersionInputExampleRequest| { &m.model_id },
                |m: &mut GetModelVersionInputExampleRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_id",
                |m: &GetModelVersionInputExampleRequest| { &m.model_version_id },
                |m: &mut GetModelVersionInputExampleRequest| { &mut m.model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "example_id",
                |m: &GetModelVersionInputExampleRequest| { &m.example_id },
                |m: &mut GetModelVersionInputExampleRequest| { &mut m.example_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetModelVersionInputExampleRequest>(
                "GetModelVersionInputExampleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetModelVersionInputExampleRequest {
        static instance: ::protobuf::rt::LazyV2<GetModelVersionInputExampleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetModelVersionInputExampleRequest::new)
    }
}

impl ::protobuf::Clear for GetModelVersionInputExampleRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.example_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetModelVersionInputExampleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetModelVersionInputExampleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelVersionInputExamplesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub model_version_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelVersionInputExamplesRequest {
    fn default() -> &'a ListModelVersionInputExamplesRequest {
        <ListModelVersionInputExamplesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelVersionInputExamplesRequest {
    pub fn new() -> ListModelVersionInputExamplesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string model_version_id = 3;


    pub fn get_model_version_id(&self) -> &str {
        &self.model_version_id
    }
    pub fn clear_model_version_id(&mut self) {
        self.model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_id(&mut self, v: ::std::string::String) {
        self.model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_version_id
    }

    // Take field
    pub fn take_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_version_id, ::std::string::String::new())
    }

    // uint32 page = 4;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 5;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListModelVersionInputExamplesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_version_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(5, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        if self.page != 0 {
            os.write_uint32(4, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(5, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelVersionInputExamplesRequest {
        ListModelVersionInputExamplesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelVersionInputExamplesRequest| { &m.user_app_id },
                |m: &mut ListModelVersionInputExamplesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &ListModelVersionInputExamplesRequest| { &m.model_id },
                |m: &mut ListModelVersionInputExamplesRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_id",
                |m: &ListModelVersionInputExamplesRequest| { &m.model_version_id },
                |m: &mut ListModelVersionInputExamplesRequest| { &mut m.model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelVersionInputExamplesRequest| { &m.page },
                |m: &mut ListModelVersionInputExamplesRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelVersionInputExamplesRequest| { &m.per_page },
                |m: &mut ListModelVersionInputExamplesRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelVersionInputExamplesRequest>(
                "ListModelVersionInputExamplesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelVersionInputExamplesRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelVersionInputExamplesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelVersionInputExamplesRequest::new)
    }
}

impl ::protobuf::Clear for ListModelVersionInputExamplesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.model_version_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelVersionInputExamplesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelVersionInputExamplesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleModelVersionInputExampleResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_version_input_example: ::protobuf::SingularPtrField<super::resources::ModelVersionInputExample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleModelVersionInputExampleResponse {
    fn default() -> &'a SingleModelVersionInputExampleResponse {
        <SingleModelVersionInputExampleResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleModelVersionInputExampleResponse {
    pub fn new() -> SingleModelVersionInputExampleResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.ModelVersionInputExample model_version_input_example = 2;


    pub fn get_model_version_input_example(&self) -> &super::resources::ModelVersionInputExample {
        self.model_version_input_example.as_ref().unwrap_or_else(|| <super::resources::ModelVersionInputExample as ::protobuf::Message>::default_instance())
    }
    pub fn clear_model_version_input_example(&mut self) {
        self.model_version_input_example.clear();
    }

    pub fn has_model_version_input_example(&self) -> bool {
        self.model_version_input_example.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_version_input_example(&mut self, v: super::resources::ModelVersionInputExample) {
        self.model_version_input_example = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version_input_example(&mut self) -> &mut super::resources::ModelVersionInputExample {
        if self.model_version_input_example.is_none() {
            self.model_version_input_example.set_default();
        }
        self.model_version_input_example.as_mut().unwrap()
    }

    // Take field
    pub fn take_model_version_input_example(&mut self) -> super::resources::ModelVersionInputExample {
        self.model_version_input_example.take().unwrap_or_else(|| super::resources::ModelVersionInputExample::new())
    }
}

impl ::protobuf::Message for SingleModelVersionInputExampleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_version_input_example {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.model_version_input_example)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.model_version_input_example.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.model_version_input_example.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleModelVersionInputExampleResponse {
        SingleModelVersionInputExampleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleModelVersionInputExampleResponse| { &m.status },
                |m: &mut SingleModelVersionInputExampleResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersionInputExample>>(
                "model_version_input_example",
                |m: &SingleModelVersionInputExampleResponse| { &m.model_version_input_example },
                |m: &mut SingleModelVersionInputExampleResponse| { &mut m.model_version_input_example },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleModelVersionInputExampleResponse>(
                "SingleModelVersionInputExampleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleModelVersionInputExampleResponse {
        static instance: ::protobuf::rt::LazyV2<SingleModelVersionInputExampleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleModelVersionInputExampleResponse::new)
    }
}

impl ::protobuf::Clear for SingleModelVersionInputExampleResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_version_input_example.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleModelVersionInputExampleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleModelVersionInputExampleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelVersionInputExampleResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_version_input_examples: ::protobuf::RepeatedField<super::resources::ModelVersionInputExample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelVersionInputExampleResponse {
    fn default() -> &'a MultiModelVersionInputExampleResponse {
        <MultiModelVersionInputExampleResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelVersionInputExampleResponse {
    pub fn new() -> MultiModelVersionInputExampleResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ModelVersionInputExample model_version_input_examples = 2;


    pub fn get_model_version_input_examples(&self) -> &[super::resources::ModelVersionInputExample] {
        &self.model_version_input_examples
    }
    pub fn clear_model_version_input_examples(&mut self) {
        self.model_version_input_examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_input_examples(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelVersionInputExample>) {
        self.model_version_input_examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_version_input_examples(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelVersionInputExample> {
        &mut self.model_version_input_examples
    }

    // Take field
    pub fn take_model_version_input_examples(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelVersionInputExample> {
        ::std::mem::replace(&mut self.model_version_input_examples, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelVersionInputExampleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_version_input_examples {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_version_input_examples)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.model_version_input_examples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.model_version_input_examples {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelVersionInputExampleResponse {
        MultiModelVersionInputExampleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelVersionInputExampleResponse| { &m.status },
                |m: &mut MultiModelVersionInputExampleResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelVersionInputExample>>(
                "model_version_input_examples",
                |m: &MultiModelVersionInputExampleResponse| { &m.model_version_input_examples },
                |m: &mut MultiModelVersionInputExampleResponse| { &mut m.model_version_input_examples },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelVersionInputExampleResponse>(
                "MultiModelVersionInputExampleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelVersionInputExampleResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelVersionInputExampleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelVersionInputExampleResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelVersionInputExampleResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_version_input_examples.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelVersionInputExampleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelVersionInputExampleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelReferencesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub model_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelReferencesRequest {
    fn default() -> &'a ListModelReferencesRequest {
        <ListModelReferencesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelReferencesRequest {
    pub fn new() -> ListModelReferencesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string model_id = 2;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // uint32 page = 3;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 4;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListModelReferencesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.model_id.is_empty() {
            os.write_string(2, &self.model_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelReferencesRequest {
        ListModelReferencesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListModelReferencesRequest| { &m.user_app_id },
                |m: &mut ListModelReferencesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &ListModelReferencesRequest| { &m.model_id },
                |m: &mut ListModelReferencesRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListModelReferencesRequest| { &m.page },
                |m: &mut ListModelReferencesRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListModelReferencesRequest| { &m.per_page },
                |m: &mut ListModelReferencesRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelReferencesRequest>(
                "ListModelReferencesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelReferencesRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelReferencesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelReferencesRequest::new)
    }
}

impl ::protobuf::Clear for ListModelReferencesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.model_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelReferencesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelReferencesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiModelReferenceResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub model_references: ::protobuf::RepeatedField<super::resources::ModelReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiModelReferenceResponse {
    fn default() -> &'a MultiModelReferenceResponse {
        <MultiModelReferenceResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiModelReferenceResponse {
    pub fn new() -> MultiModelReferenceResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ModelReference model_references = 2;


    pub fn get_model_references(&self) -> &[super::resources::ModelReference] {
        &self.model_references
    }
    pub fn clear_model_references(&mut self) {
        self.model_references.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_references(&mut self, v: ::protobuf::RepeatedField<super::resources::ModelReference>) {
        self.model_references = v;
    }

    // Mutable pointer to the field.
    pub fn mut_model_references(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ModelReference> {
        &mut self.model_references
    }

    // Take field
    pub fn take_model_references(&mut self) -> ::protobuf::RepeatedField<super::resources::ModelReference> {
        ::std::mem::replace(&mut self.model_references, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiModelReferenceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.model_references {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.model_references)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.model_references {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.model_references {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiModelReferenceResponse {
        MultiModelReferenceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiModelReferenceResponse| { &m.status },
                |m: &mut MultiModelReferenceResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ModelReference>>(
                "model_references",
                |m: &MultiModelReferenceResponse| { &m.model_references },
                |m: &mut MultiModelReferenceResponse| { &mut m.model_references },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiModelReferenceResponse>(
                "MultiModelReferenceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiModelReferenceResponse {
        static instance: ::protobuf::rt::LazyV2<MultiModelReferenceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiModelReferenceResponse::new)
    }
}

impl ::protobuf::Clear for MultiModelReferenceResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.model_references.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiModelReferenceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiModelReferenceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiOutputResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub outputs: ::protobuf::RepeatedField<super::resources::Output>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiOutputResponse {
    fn default() -> &'a MultiOutputResponse {
        <MultiOutputResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiOutputResponse {
    pub fn new() -> MultiOutputResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Output outputs = 2;


    pub fn get_outputs(&self) -> &[super::resources::Output] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Output>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Output> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Output> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiOutputResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.outputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiOutputResponse {
        MultiOutputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiOutputResponse| { &m.status },
                |m: &mut MultiOutputResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Output>>(
                "outputs",
                |m: &MultiOutputResponse| { &m.outputs },
                |m: &mut MultiOutputResponse| { &mut m.outputs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiOutputResponse>(
                "MultiOutputResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiOutputResponse {
        static instance: ::protobuf::rt::LazyV2<MultiOutputResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiOutputResponse::new)
    }
}

impl ::protobuf::Clear for MultiOutputResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.outputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiOutputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListScopesRequest {
    // message fields
    pub key_type: ::std::string::String,
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListScopesRequest {
    fn default() -> &'a ListScopesRequest {
        <ListScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListScopesRequest {
    pub fn new() -> ListScopesRequest {
        ::std::default::Default::default()
    }

    // string key_type = 1;


    pub fn get_key_type(&self) -> &str {
        &self.key_type
    }
    pub fn clear_key_type(&mut self) {
        self.key_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: ::std::string::String) {
        self.key_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_type(&mut self) -> &mut ::std::string::String {
        &mut self.key_type
    }

    // Take field
    pub fn take_key_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_type, ::std::string::String::new())
    }

    // .clarifai.api.UserAppIDSet user_app_id = 2;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for ListScopesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key_type);
        }
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key_type.is_empty() {
            os.write_string(1, &self.key_type)?;
        }
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListScopesRequest {
        ListScopesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_type",
                |m: &ListScopesRequest| { &m.key_type },
                |m: &mut ListScopesRequest| { &mut m.key_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListScopesRequest| { &m.user_app_id },
                |m: &mut ListScopesRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListScopesRequest>(
                "ListScopesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListScopesRequest {
        static instance: ::protobuf::rt::LazyV2<ListScopesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListScopesRequest::new)
    }
}

impl ::protobuf::Clear for ListScopesRequest {
    fn clear(&mut self) {
        self.key_type.clear();
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListScopesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MyScopesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyScopesRequest {
    fn default() -> &'a MyScopesRequest {
        <MyScopesRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRequest {
    pub fn new() -> MyScopesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for MyScopesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyScopesRequest {
        MyScopesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &MyScopesRequest| { &m.user_app_id },
                |m: &mut MyScopesRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MyScopesRequest>(
                "MyScopesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MyScopesRequest {
        static instance: ::protobuf::rt::LazyV2<MyScopesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MyScopesRequest::new)
    }
}

impl ::protobuf::Clear for MyScopesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyScopesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MyScopesUserRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyScopesUserRequest {
    fn default() -> &'a MyScopesUserRequest {
        <MyScopesUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesUserRequest {
    pub fn new() -> MyScopesUserRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for MyScopesUserRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyScopesUserRequest {
        MyScopesUserRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &MyScopesUserRequest| { &m.user_app_id },
                |m: &mut MyScopesUserRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MyScopesUserRequest>(
                "MyScopesUserRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MyScopesUserRequest {
        static instance: ::protobuf::rt::LazyV2<MyScopesUserRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MyScopesUserRequest::new)
    }
}

impl ::protobuf::Clear for MyScopesUserRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyScopesUserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesUserRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MyScopesRootRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyScopesRootRequest {
    fn default() -> &'a MyScopesRootRequest {
        <MyScopesRootRequest as ::protobuf::Message>::default_instance()
    }
}

impl MyScopesRootRequest {
    pub fn new() -> MyScopesRootRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MyScopesRootRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyScopesRootRequest {
        MyScopesRootRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MyScopesRootRequest>(
                "MyScopesRootRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MyScopesRootRequest {
        static instance: ::protobuf::rt::LazyV2<MyScopesRootRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MyScopesRootRequest::new)
    }
}

impl ::protobuf::Clear for MyScopesRootRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyScopesRootRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyScopesRootRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiScopeDepsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub scope_deps: ::protobuf::RepeatedField<super::resources::ScopeDeps>,
    pub endpoint_deps: ::protobuf::RepeatedField<super::resources::EndpointDeps>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiScopeDepsResponse {
    fn default() -> &'a MultiScopeDepsResponse {
        <MultiScopeDepsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeDepsResponse {
    pub fn new() -> MultiScopeDepsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.ScopeDeps scope_deps = 2;


    pub fn get_scope_deps(&self) -> &[super::resources::ScopeDeps] {
        &self.scope_deps
    }
    pub fn clear_scope_deps(&mut self) {
        self.scope_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope_deps(&mut self, v: ::protobuf::RepeatedField<super::resources::ScopeDeps>) {
        self.scope_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scope_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ScopeDeps> {
        &mut self.scope_deps
    }

    // Take field
    pub fn take_scope_deps(&mut self) -> ::protobuf::RepeatedField<super::resources::ScopeDeps> {
        ::std::mem::replace(&mut self.scope_deps, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.EndpointDeps endpoint_deps = 3;


    pub fn get_endpoint_deps(&self) -> &[super::resources::EndpointDeps] {
        &self.endpoint_deps
    }
    pub fn clear_endpoint_deps(&mut self) {
        self.endpoint_deps.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint_deps(&mut self, v: ::protobuf::RepeatedField<super::resources::EndpointDeps>) {
        self.endpoint_deps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoint_deps(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::EndpointDeps> {
        &mut self.endpoint_deps
    }

    // Take field
    pub fn take_endpoint_deps(&mut self) -> ::protobuf::RepeatedField<super::resources::EndpointDeps> {
        ::std::mem::replace(&mut self.endpoint_deps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiScopeDepsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scope_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.endpoint_deps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scope_deps)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.endpoint_deps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.scope_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.endpoint_deps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.scope_deps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.endpoint_deps {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiScopeDepsResponse {
        MultiScopeDepsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiScopeDepsResponse| { &m.status },
                |m: &mut MultiScopeDepsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ScopeDeps>>(
                "scope_deps",
                |m: &MultiScopeDepsResponse| { &m.scope_deps },
                |m: &mut MultiScopeDepsResponse| { &mut m.scope_deps },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::EndpointDeps>>(
                "endpoint_deps",
                |m: &MultiScopeDepsResponse| { &m.endpoint_deps },
                |m: &mut MultiScopeDepsResponse| { &mut m.endpoint_deps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiScopeDepsResponse>(
                "MultiScopeDepsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiScopeDepsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiScopeDepsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiScopeDepsResponse::new)
    }
}

impl ::protobuf::Clear for MultiScopeDepsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.scope_deps.clear();
        self.endpoint_deps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiScopeDepsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeDepsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiScopeResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub app: ::protobuf::SingularPtrField<super::resources::App>,
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiScopeResponse {
    fn default() -> &'a MultiScopeResponse {
        <MultiScopeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeResponse {
    pub fn new() -> MultiScopeResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string scopes = 2;


    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.App app = 3;


    pub fn get_app(&self) -> &super::resources::App {
        self.app.as_ref().unwrap_or_else(|| <super::resources::App as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: super::resources::App) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut super::resources::App {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> super::resources::App {
        self.app.take().unwrap_or_else(|| super::resources::App::new())
    }

    // repeated string endpoints = 4;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiScopeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiScopeResponse {
        MultiScopeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiScopeResponse| { &m.status },
                |m: &mut MultiScopeResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &MultiScopeResponse| { &m.scopes },
                |m: &mut MultiScopeResponse| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::App>>(
                "app",
                |m: &MultiScopeResponse| { &m.app },
                |m: &mut MultiScopeResponse| { &mut m.app },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &MultiScopeResponse| { &m.endpoints },
                |m: &mut MultiScopeResponse| { &mut m.endpoints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiScopeResponse>(
                "MultiScopeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiScopeResponse {
        static instance: ::protobuf::rt::LazyV2<MultiScopeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiScopeResponse::new)
    }
}

impl ::protobuf::Clear for MultiScopeResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.app.clear();
        self.endpoints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiScopeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiScopeUserResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiScopeUserResponse {
    fn default() -> &'a MultiScopeUserResponse {
        <MultiScopeUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeUserResponse {
    pub fn new() -> MultiScopeUserResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string scopes = 2;


    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    // repeated string endpoints = 4;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiScopeUserResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiScopeUserResponse {
        MultiScopeUserResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiScopeUserResponse| { &m.status },
                |m: &mut MultiScopeUserResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &MultiScopeUserResponse| { &m.scopes },
                |m: &mut MultiScopeUserResponse| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &MultiScopeUserResponse| { &m.endpoints },
                |m: &mut MultiScopeUserResponse| { &mut m.endpoints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiScopeUserResponse>(
                "MultiScopeUserResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiScopeUserResponse {
        static instance: ::protobuf::rt::LazyV2<MultiScopeUserResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiScopeUserResponse::new)
    }
}

impl ::protobuf::Clear for MultiScopeUserResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiScopeUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeUserResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiScopeRootResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub endpoints: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiScopeRootResponse {
    fn default() -> &'a MultiScopeRootResponse {
        <MultiScopeRootResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiScopeRootResponse {
    pub fn new() -> MultiScopeRootResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated string scopes = 2;


    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    // repeated string endpoints = 4;


    pub fn get_endpoints(&self) -> &[::std::string::String] {
        &self.endpoints
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.endpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_endpoints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.endpoints
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.endpoints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiScopeRootResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.endpoints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.endpoints {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        for v in &self.endpoints {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiScopeRootResponse {
        MultiScopeRootResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiScopeRootResponse| { &m.status },
                |m: &mut MultiScopeRootResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &MultiScopeRootResponse| { &m.scopes },
                |m: &mut MultiScopeRootResponse| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &MultiScopeRootResponse| { &m.endpoints },
                |m: &mut MultiScopeRootResponse| { &mut m.endpoints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiScopeRootResponse>(
                "MultiScopeRootResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiScopeRootResponse {
        static instance: ::protobuf::rt::LazyV2<MultiScopeRootResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiScopeRootResponse::new)
    }
}

impl ::protobuf::Clear for MultiScopeRootResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.scopes.clear();
        self.endpoints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiScopeRootResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiScopeRootResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSearchRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSearchRequest {
    fn default() -> &'a GetSearchRequest {
        <GetSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSearchRequest {
    pub fn new() -> GetSearchRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSearchRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSearchRequest {
        GetSearchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetSearchRequest| { &m.user_app_id },
                |m: &mut GetSearchRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetSearchRequest| { &m.id },
                |m: &mut GetSearchRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSearchRequest>(
                "GetSearchRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSearchRequest {
        static instance: ::protobuf::rt::LazyV2<GetSearchRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSearchRequest::new)
    }
}

impl ::protobuf::Clear for GetSearchRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSearchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSearchesRequest {
    fn default() -> &'a ListSearchesRequest {
        <ListSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSearchesRequest {
    pub fn new() -> ListSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSearchesRequest {
        ListSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListSearchesRequest| { &m.user_app_id },
                |m: &mut ListSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListSearchesRequest| { &m.page },
                |m: &mut ListSearchesRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListSearchesRequest| { &m.per_page },
                |m: &mut ListSearchesRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSearchesRequest>(
                "ListSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<ListSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListSearchesRequest::new)
    }
}

impl ::protobuf::Clear for ListSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub query: ::protobuf::SingularPtrField<super::resources::Query>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostSearchesRequest {
    fn default() -> &'a PostSearchesRequest {
        <PostSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesRequest {
    pub fn new() -> PostSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.Query query = 2;


    pub fn get_query(&self) -> &super::resources::Query {
        self.query.as_ref().unwrap_or_else(|| <super::resources::Query as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: super::resources::Query) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut super::resources::Query {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> super::resources::Query {
        self.query.take().unwrap_or_else(|| super::resources::Query::new())
    }

    // repeated .clarifai.api.Search searches = 3;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Pagination pagination = 4;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostSearchesRequest {
        PostSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostSearchesRequest| { &m.user_app_id },
                |m: &mut PostSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Query>>(
                "query",
                |m: &PostSearchesRequest| { &m.query },
                |m: &mut PostSearchesRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PostSearchesRequest| { &m.searches },
                |m: &mut PostSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostSearchesRequest| { &m.pagination },
                |m: &mut PostSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostSearchesRequest>(
                "PostSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.query.clear();
        self.searches.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchInputsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchInputsSearchesRequest {
    fn default() -> &'a PatchInputsSearchesRequest {
        <PatchInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchInputsSearchesRequest {
    pub fn new() -> PatchInputsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Search searches = 2;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchInputsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchInputsSearchesRequest {
        PatchInputsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchInputsSearchesRequest| { &m.user_app_id },
                |m: &mut PatchInputsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PatchInputsSearchesRequest| { &m.searches },
                |m: &mut PatchInputsSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchInputsSearchesRequest| { &m.action },
                |m: &mut PatchInputsSearchesRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchInputsSearchesRequest>(
                "PatchInputsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchInputsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PatchInputsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchInputsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PatchInputsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchInputsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchAnnotationsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchAnnotationsSearchesRequest {
    fn default() -> &'a PatchAnnotationsSearchesRequest {
        <PatchAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchAnnotationsSearchesRequest {
    pub fn new() -> PatchAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Search searches = 2;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchAnnotationsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchAnnotationsSearchesRequest {
        PatchAnnotationsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchAnnotationsSearchesRequest| { &m.user_app_id },
                |m: &mut PatchAnnotationsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PatchAnnotationsSearchesRequest| { &m.searches },
                |m: &mut PatchAnnotationsSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchAnnotationsSearchesRequest| { &m.action },
                |m: &mut PatchAnnotationsSearchesRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchAnnotationsSearchesRequest>(
                "PatchAnnotationsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchAnnotationsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PatchAnnotationsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchAnnotationsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PatchAnnotationsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchAnnotationsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchSearchesRequest {
    fn default() -> &'a PatchSearchesRequest {
        <PatchSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchSearchesRequest {
    pub fn new() -> PatchSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Search searches = 2;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchSearchesRequest {
        PatchSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchSearchesRequest| { &m.user_app_id },
                |m: &mut PatchSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PatchSearchesRequest| { &m.searches },
                |m: &mut PatchSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchSearchesRequest| { &m.action },
                |m: &mut PatchSearchesRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchSearchesRequest>(
                "PatchSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PatchSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PatchSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostSearchesByIDRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostSearchesByIDRequest {
    fn default() -> &'a PostSearchesByIDRequest {
        <PostSearchesByIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostSearchesByIDRequest {
    pub fn new() -> PostSearchesByIDRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostSearchesByIDRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostSearchesByIDRequest {
        PostSearchesByIDRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostSearchesByIDRequest| { &m.user_app_id },
                |m: &mut PostSearchesByIDRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PostSearchesByIDRequest| { &m.id },
                |m: &mut PostSearchesByIDRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostSearchesByIDRequest| { &m.pagination },
                |m: &mut PostSearchesByIDRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostSearchesByIDRequest>(
                "PostSearchesByIDRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostSearchesByIDRequest {
        static instance: ::protobuf::rt::LazyV2<PostSearchesByIDRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostSearchesByIDRequest::new)
    }
}

impl ::protobuf::Clear for PostSearchesByIDRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostSearchesByIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostSearchesByIDRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSearchRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSearchRequest {
    fn default() -> &'a DeleteSearchRequest {
        <DeleteSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSearchRequest {
    pub fn new() -> DeleteSearchRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSearchRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSearchRequest {
        DeleteSearchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteSearchRequest| { &m.user_app_id },
                |m: &mut DeleteSearchRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &DeleteSearchRequest| { &m.id },
                |m: &mut DeleteSearchRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSearchRequest>(
                "DeleteSearchRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSearchRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteSearchRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSearchRequest::new)
    }
}

impl ::protobuf::Clear for DeleteSearchRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSearchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAnnotationsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAnnotationsSearchesRequest {
    fn default() -> &'a PostAnnotationsSearchesRequest {
        <PostAnnotationsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationsSearchesRequest {
    pub fn new() -> PostAnnotationsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Search searches = 2;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostAnnotationsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAnnotationsSearchesRequest {
        PostAnnotationsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAnnotationsSearchesRequest| { &m.user_app_id },
                |m: &mut PostAnnotationsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PostAnnotationsSearchesRequest| { &m.searches },
                |m: &mut PostAnnotationsSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostAnnotationsSearchesRequest| { &m.pagination },
                |m: &mut PostAnnotationsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAnnotationsSearchesRequest>(
                "PostAnnotationsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAnnotationsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostAnnotationsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAnnotationsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostAnnotationsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAnnotationsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAnnotationSearchMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAnnotationSearchMetricsRequest {
    fn default() -> &'a DeleteAnnotationSearchMetricsRequest {
        <DeleteAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAnnotationSearchMetricsRequest {
    pub fn new() -> DeleteAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteAnnotationSearchMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAnnotationSearchMetricsRequest {
        DeleteAnnotationSearchMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteAnnotationSearchMetricsRequest| { &m.user_app_id },
                |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &DeleteAnnotationSearchMetricsRequest| { &m.id },
                |m: &mut DeleteAnnotationSearchMetricsRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteAnnotationSearchMetricsRequest>(
                "DeleteAnnotationSearchMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteAnnotationSearchMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteAnnotationSearchMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteAnnotationSearchMetricsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteAnnotationSearchMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAnnotationSearchMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostInputsSearchesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    pub pagination: ::protobuf::SingularPtrField<Pagination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostInputsSearchesRequest {
    fn default() -> &'a PostInputsSearchesRequest {
        <PostInputsSearchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostInputsSearchesRequest {
    pub fn new() -> PostInputsSearchesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Search searches = 2;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Pagination pagination = 3;


    pub fn get_pagination(&self) -> &Pagination {
        self.pagination.as_ref().unwrap_or_else(|| <Pagination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pagination(&mut self) {
        self.pagination.clear();
    }

    pub fn has_pagination(&self) -> bool {
        self.pagination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination(&mut self, v: Pagination) {
        self.pagination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pagination(&mut self) -> &mut Pagination {
        if self.pagination.is_none() {
            self.pagination.set_default();
        }
        self.pagination.as_mut().unwrap()
    }

    // Take field
    pub fn take_pagination(&mut self) -> Pagination {
        self.pagination.take().unwrap_or_else(|| Pagination::new())
    }
}

impl ::protobuf::Message for PostInputsSearchesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pagination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pagination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.pagination.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostInputsSearchesRequest {
        PostInputsSearchesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostInputsSearchesRequest| { &m.user_app_id },
                |m: &mut PostInputsSearchesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &PostInputsSearchesRequest| { &m.searches },
                |m: &mut PostInputsSearchesRequest| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pagination>>(
                "pagination",
                |m: &PostInputsSearchesRequest| { &m.pagination },
                |m: &mut PostInputsSearchesRequest| { &mut m.pagination },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostInputsSearchesRequest>(
                "PostInputsSearchesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostInputsSearchesRequest {
        static instance: ::protobuf::rt::LazyV2<PostInputsSearchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostInputsSearchesRequest::new)
    }
}

impl ::protobuf::Clear for PostInputsSearchesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.searches.clear();
        self.pagination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostInputsSearchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostInputsSearchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleSearchResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub search: ::protobuf::SingularPtrField<super::resources::Search>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleSearchResponse {
    fn default() -> &'a SingleSearchResponse {
        <SingleSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleSearchResponse {
    pub fn new() -> SingleSearchResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Search search = 5;


    pub fn get_search(&self) -> &super::resources::Search {
        self.search.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_search(&mut self) {
        self.search.clear();
    }

    pub fn has_search(&self) -> bool {
        self.search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: super::resources::Search) {
        self.search = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search(&mut self) -> &mut super::resources::Search {
        if self.search.is_none() {
            self.search.set_default();
        }
        self.search.as_mut().unwrap()
    }

    // Take field
    pub fn take_search(&mut self) -> super::resources::Search {
        self.search.take().unwrap_or_else(|| super::resources::Search::new())
    }
}

impl ::protobuf::Message for SingleSearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.search.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleSearchResponse {
        SingleSearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleSearchResponse| { &m.status },
                |m: &mut SingleSearchResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "search",
                |m: &SingleSearchResponse| { &m.search },
                |m: &mut SingleSearchResponse| { &mut m.search },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleSearchResponse>(
                "SingleSearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleSearchResponse {
        static instance: ::protobuf::rt::LazyV2<SingleSearchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleSearchResponse::new)
    }
}

impl ::protobuf::Clear for SingleSearchResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.search.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleSearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiSearchResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub id: ::std::string::String,
    pub hits: ::protobuf::RepeatedField<super::resources::Hit>,
    pub query: ::protobuf::SingularPtrField<super::resources::Query>,
    pub searches: ::protobuf::RepeatedField<super::resources::Search>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiSearchResponse {
    fn default() -> &'a MultiSearchResponse {
        <MultiSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiSearchResponse {
    pub fn new() -> MultiSearchResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated .clarifai.api.Hit hits = 3;


    pub fn get_hits(&self) -> &[super::resources::Hit] {
        &self.hits
    }
    pub fn clear_hits(&mut self) {
        self.hits.clear();
    }

    // Param is passed by value, moved
    pub fn set_hits(&mut self, v: ::protobuf::RepeatedField<super::resources::Hit>) {
        self.hits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hits(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Hit> {
        &mut self.hits
    }

    // Take field
    pub fn take_hits(&mut self) -> ::protobuf::RepeatedField<super::resources::Hit> {
        ::std::mem::replace(&mut self.hits, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.Query query = 4;


    pub fn get_query(&self) -> &super::resources::Query {
        self.query.as_ref().unwrap_or_else(|| <super::resources::Query as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: super::resources::Query) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut super::resources::Query {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> super::resources::Query {
        self.query.take().unwrap_or_else(|| super::resources::Query::new())
    }

    // repeated .clarifai.api.Search searches = 5;


    pub fn get_searches(&self) -> &[super::resources::Search] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<super::resources::Search>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Search> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<super::resources::Search> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiSearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hits)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.searches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.hits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.searches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.hits {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.searches {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiSearchResponse {
        MultiSearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiSearchResponse| { &m.status },
                |m: &mut MultiSearchResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &MultiSearchResponse| { &m.id },
                |m: &mut MultiSearchResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Hit>>(
                "hits",
                |m: &MultiSearchResponse| { &m.hits },
                |m: &mut MultiSearchResponse| { &mut m.hits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Query>>(
                "query",
                |m: &MultiSearchResponse| { &m.query },
                |m: &mut MultiSearchResponse| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "searches",
                |m: &MultiSearchResponse| { &m.searches },
                |m: &mut MultiSearchResponse| { &mut m.searches },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiSearchResponse>(
                "MultiSearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiSearchResponse {
        static instance: ::protobuf::rt::LazyV2<MultiSearchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiSearchResponse::new)
    }
}

impl ::protobuf::Clear for MultiSearchResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.id.clear();
        self.hits.clear();
        self.query.clear();
        self.searches.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiSearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAnnotationSearchMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    pub ground_truth: ::protobuf::SingularPtrField<super::resources::Search>,
    pub search_to_eval: ::protobuf::SingularPtrField<super::resources::Search>,
    pub data: ::protobuf::SingularPtrField<super::resources::Data>,
    pub evaluation_type: super::resources::EvaluationType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAnnotationSearchMetricsRequest {
    fn default() -> &'a PostAnnotationSearchMetricsRequest {
        <PostAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAnnotationSearchMetricsRequest {
    pub fn new() -> PostAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .clarifai.api.Search ground_truth = 3;


    pub fn get_ground_truth(&self) -> &super::resources::Search {
        self.ground_truth.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ground_truth(&mut self) {
        self.ground_truth.clear();
    }

    pub fn has_ground_truth(&self) -> bool {
        self.ground_truth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ground_truth(&mut self, v: super::resources::Search) {
        self.ground_truth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ground_truth(&mut self) -> &mut super::resources::Search {
        if self.ground_truth.is_none() {
            self.ground_truth.set_default();
        }
        self.ground_truth.as_mut().unwrap()
    }

    // Take field
    pub fn take_ground_truth(&mut self) -> super::resources::Search {
        self.ground_truth.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // .clarifai.api.Search search_to_eval = 4;


    pub fn get_search_to_eval(&self) -> &super::resources::Search {
        self.search_to_eval.as_ref().unwrap_or_else(|| <super::resources::Search as ::protobuf::Message>::default_instance())
    }
    pub fn clear_search_to_eval(&mut self) {
        self.search_to_eval.clear();
    }

    pub fn has_search_to_eval(&self) -> bool {
        self.search_to_eval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_to_eval(&mut self, v: super::resources::Search) {
        self.search_to_eval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_to_eval(&mut self) -> &mut super::resources::Search {
        if self.search_to_eval.is_none() {
            self.search_to_eval.set_default();
        }
        self.search_to_eval.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_to_eval(&mut self) -> super::resources::Search {
        self.search_to_eval.take().unwrap_or_else(|| super::resources::Search::new())
    }

    // .clarifai.api.Data data = 5;


    pub fn get_data(&self) -> &super::resources::Data {
        self.data.as_ref().unwrap_or_else(|| <super::resources::Data as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::resources::Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::resources::Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::resources::Data {
        self.data.take().unwrap_or_else(|| super::resources::Data::new())
    }

    // .clarifai.api.EvaluationType evaluation_type = 6;


    pub fn get_evaluation_type(&self) -> super::resources::EvaluationType {
        self.evaluation_type
    }
    pub fn clear_evaluation_type(&mut self) {
        self.evaluation_type = super::resources::EvaluationType::Classification;
    }

    // Param is passed by value, moved
    pub fn set_evaluation_type(&mut self, v: super::resources::EvaluationType) {
        self.evaluation_type = v;
    }
}

impl ::protobuf::Message for PostAnnotationSearchMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ground_truth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search_to_eval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ground_truth)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search_to_eval)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.evaluation_type, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if let Some(ref v) = self.ground_truth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.search_to_eval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.evaluation_type != super::resources::EvaluationType::Classification {
            my_size += ::protobuf::rt::enum_size(6, self.evaluation_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if let Some(ref v) = self.ground_truth.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.search_to_eval.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.evaluation_type != super::resources::EvaluationType::Classification {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.evaluation_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAnnotationSearchMetricsRequest {
        PostAnnotationSearchMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAnnotationSearchMetricsRequest| { &m.user_app_id },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &PostAnnotationSearchMetricsRequest| { &m.id },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "ground_truth",
                |m: &PostAnnotationSearchMetricsRequest| { &m.ground_truth },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.ground_truth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Search>>(
                "search_to_eval",
                |m: &PostAnnotationSearchMetricsRequest| { &m.search_to_eval },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.search_to_eval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Data>>(
                "data",
                |m: &PostAnnotationSearchMetricsRequest| { &m.data },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::resources::EvaluationType>>(
                "evaluation_type",
                |m: &PostAnnotationSearchMetricsRequest| { &m.evaluation_type },
                |m: &mut PostAnnotationSearchMetricsRequest| { &mut m.evaluation_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAnnotationSearchMetricsRequest>(
                "PostAnnotationSearchMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAnnotationSearchMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<PostAnnotationSearchMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAnnotationSearchMetricsRequest::new)
    }
}

impl ::protobuf::Clear for PostAnnotationSearchMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.ground_truth.clear();
        self.search_to_eval.clear();
        self.data.clear();
        self.evaluation_type = super::resources::EvaluationType::Classification;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAnnotationSearchMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAnnotationSearchMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAnnotationSearchMetricsRequest {
    fn default() -> &'a GetAnnotationSearchMetricsRequest {
        <GetAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAnnotationSearchMetricsRequest {
    pub fn new() -> GetAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAnnotationSearchMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAnnotationSearchMetricsRequest {
        GetAnnotationSearchMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetAnnotationSearchMetricsRequest| { &m.user_app_id },
                |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetAnnotationSearchMetricsRequest| { &m.id },
                |m: &mut GetAnnotationSearchMetricsRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAnnotationSearchMetricsRequest>(
                "GetAnnotationSearchMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAnnotationSearchMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<GetAnnotationSearchMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAnnotationSearchMetricsRequest::new)
    }
}

impl ::protobuf::Clear for GetAnnotationSearchMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAnnotationSearchMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAnnotationSearchMetricsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAnnotationSearchMetricsRequest {
    fn default() -> &'a ListAnnotationSearchMetricsRequest {
        <ListAnnotationSearchMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAnnotationSearchMetricsRequest {
    pub fn new() -> ListAnnotationSearchMetricsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }
}

impl ::protobuf::Message for ListAnnotationSearchMetricsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAnnotationSearchMetricsRequest {
        ListAnnotationSearchMetricsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAnnotationSearchMetricsRequest| { &m.user_app_id },
                |m: &mut ListAnnotationSearchMetricsRequest| { &mut m.user_app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAnnotationSearchMetricsRequest>(
                "ListAnnotationSearchMetricsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAnnotationSearchMetricsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAnnotationSearchMetricsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAnnotationSearchMetricsRequest::new)
    }
}

impl ::protobuf::Clear for ListAnnotationSearchMetricsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAnnotationSearchMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAnnotationSearchMetricsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiAnnotationSearchMetricsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub annotation_search_metrics: ::protobuf::RepeatedField<super::resources::AnnotationSearchMetrics>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiAnnotationSearchMetricsResponse {
    fn default() -> &'a MultiAnnotationSearchMetricsResponse {
        <MultiAnnotationSearchMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAnnotationSearchMetricsResponse {
    pub fn new() -> MultiAnnotationSearchMetricsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.AnnotationSearchMetrics annotation_search_metrics = 2;


    pub fn get_annotation_search_metrics(&self) -> &[super::resources::AnnotationSearchMetrics] {
        &self.annotation_search_metrics
    }
    pub fn clear_annotation_search_metrics(&mut self) {
        self.annotation_search_metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotation_search_metrics(&mut self, v: ::protobuf::RepeatedField<super::resources::AnnotationSearchMetrics>) {
        self.annotation_search_metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotation_search_metrics(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::AnnotationSearchMetrics> {
        &mut self.annotation_search_metrics
    }

    // Take field
    pub fn take_annotation_search_metrics(&mut self) -> ::protobuf::RepeatedField<super::resources::AnnotationSearchMetrics> {
        ::std::mem::replace(&mut self.annotation_search_metrics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiAnnotationSearchMetricsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotation_search_metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.annotation_search_metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.annotation_search_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.annotation_search_metrics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiAnnotationSearchMetricsResponse {
        MultiAnnotationSearchMetricsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiAnnotationSearchMetricsResponse| { &m.status },
                |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AnnotationSearchMetrics>>(
                "annotation_search_metrics",
                |m: &MultiAnnotationSearchMetricsResponse| { &m.annotation_search_metrics },
                |m: &mut MultiAnnotationSearchMetricsResponse| { &mut m.annotation_search_metrics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiAnnotationSearchMetricsResponse>(
                "MultiAnnotationSearchMetricsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiAnnotationSearchMetricsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiAnnotationSearchMetricsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiAnnotationSearchMetricsResponse::new)
    }
}

impl ::protobuf::Clear for MultiAnnotationSearchMetricsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.annotation_search_metrics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiAnnotationSearchMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAnnotationSearchMetricsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostValidatePasswordRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub password: ::protobuf::SingularPtrField<super::resources::Password>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostValidatePasswordRequest {
    fn default() -> &'a PostValidatePasswordRequest {
        <PostValidatePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostValidatePasswordRequest {
    pub fn new() -> PostValidatePasswordRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // .clarifai.api.Password password = 2;


    pub fn get_password(&self) -> &super::resources::Password {
        self.password.as_ref().unwrap_or_else(|| <super::resources::Password as ::protobuf::Message>::default_instance())
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: super::resources::Password) {
        self.password = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut super::resources::Password {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> super::resources::Password {
        self.password.take().unwrap_or_else(|| super::resources::Password::new())
    }
}

impl ::protobuf::Message for PostValidatePasswordRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.password {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.password.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostValidatePasswordRequest {
        PostValidatePasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostValidatePasswordRequest| { &m.user_app_id },
                |m: &mut PostValidatePasswordRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Password>>(
                "password",
                |m: &PostValidatePasswordRequest| { &m.password },
                |m: &mut PostValidatePasswordRequest| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostValidatePasswordRequest>(
                "PostValidatePasswordRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostValidatePasswordRequest {
        static instance: ::protobuf::rt::LazyV2<PostValidatePasswordRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostValidatePasswordRequest::new)
    }
}

impl ::protobuf::Clear for PostValidatePasswordRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostValidatePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostValidatePasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SinglePasswordValidationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub password_violations: ::protobuf::SingularPtrField<super::resources::PasswordViolations>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SinglePasswordValidationResponse {
    fn default() -> &'a SinglePasswordValidationResponse {
        <SinglePasswordValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SinglePasswordValidationResponse {
    pub fn new() -> SinglePasswordValidationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.PasswordViolations password_violations = 2;


    pub fn get_password_violations(&self) -> &super::resources::PasswordViolations {
        self.password_violations.as_ref().unwrap_or_else(|| <super::resources::PasswordViolations as ::protobuf::Message>::default_instance())
    }
    pub fn clear_password_violations(&mut self) {
        self.password_violations.clear();
    }

    pub fn has_password_violations(&self) -> bool {
        self.password_violations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_violations(&mut self, v: super::resources::PasswordViolations) {
        self.password_violations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password_violations(&mut self) -> &mut super::resources::PasswordViolations {
        if self.password_violations.is_none() {
            self.password_violations.set_default();
        }
        self.password_violations.as_mut().unwrap()
    }

    // Take field
    pub fn take_password_violations(&mut self) -> super::resources::PasswordViolations {
        self.password_violations.take().unwrap_or_else(|| super::resources::PasswordViolations::new())
    }
}

impl ::protobuf::Message for SinglePasswordValidationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.password_violations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.password_violations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.password_violations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.password_violations.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SinglePasswordValidationResponse {
        SinglePasswordValidationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SinglePasswordValidationResponse| { &m.status },
                |m: &mut SinglePasswordValidationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::PasswordViolations>>(
                "password_violations",
                |m: &SinglePasswordValidationResponse| { &m.password_violations },
                |m: &mut SinglePasswordValidationResponse| { &mut m.password_violations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SinglePasswordValidationResponse>(
                "SinglePasswordValidationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SinglePasswordValidationResponse {
        static instance: ::protobuf::rt::LazyV2<SinglePasswordValidationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SinglePasswordValidationResponse::new)
    }
}

impl ::protobuf::Clear for SinglePasswordValidationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.password_violations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SinglePasswordValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinglePasswordValidationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetWorkflowRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub favor_clarifai_workflows: bool,
    pub additional_fields: ::protobuf::RepeatedField<::std::string::String>,
    pub exclude_clarifai_workflows: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWorkflowRequest {
    fn default() -> &'a GetWorkflowRequest {
        <GetWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowRequest {
    pub fn new() -> GetWorkflowRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // bool favor_clarifai_workflows = 3;


    pub fn get_favor_clarifai_workflows(&self) -> bool {
        self.favor_clarifai_workflows
    }
    pub fn clear_favor_clarifai_workflows(&mut self) {
        self.favor_clarifai_workflows = false;
    }

    // Param is passed by value, moved
    pub fn set_favor_clarifai_workflows(&mut self, v: bool) {
        self.favor_clarifai_workflows = v;
    }

    // repeated string additional_fields = 4;


    pub fn get_additional_fields(&self) -> &[::std::string::String] {
        &self.additional_fields
    }
    pub fn clear_additional_fields(&mut self) {
        self.additional_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.additional_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.additional_fields
    }

    // Take field
    pub fn take_additional_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.additional_fields, ::protobuf::RepeatedField::new())
    }

    // bool exclude_clarifai_workflows = 5;


    pub fn get_exclude_clarifai_workflows(&self) -> bool {
        self.exclude_clarifai_workflows
    }
    pub fn clear_exclude_clarifai_workflows(&mut self) {
        self.exclude_clarifai_workflows = false;
    }

    // Param is passed by value, moved
    pub fn set_exclude_clarifai_workflows(&mut self, v: bool) {
        self.exclude_clarifai_workflows = v;
    }
}

impl ::protobuf::Message for GetWorkflowRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.favor_clarifai_workflows = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.additional_fields)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exclude_clarifai_workflows = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.favor_clarifai_workflows != false {
            my_size += 2;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.exclude_clarifai_workflows != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(3, self.favor_clarifai_workflows)?;
        }
        for v in &self.additional_fields {
            os.write_string(4, &v)?;
        };
        if self.exclude_clarifai_workflows != false {
            os.write_bool(5, self.exclude_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWorkflowRequest {
        GetWorkflowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetWorkflowRequest| { &m.user_app_id },
                |m: &mut GetWorkflowRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &GetWorkflowRequest| { &m.workflow_id },
                |m: &mut GetWorkflowRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "favor_clarifai_workflows",
                |m: &GetWorkflowRequest| { &m.favor_clarifai_workflows },
                |m: &mut GetWorkflowRequest| { &mut m.favor_clarifai_workflows },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "additional_fields",
                |m: &GetWorkflowRequest| { &m.additional_fields },
                |m: &mut GetWorkflowRequest| { &mut m.additional_fields },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "exclude_clarifai_workflows",
                |m: &GetWorkflowRequest| { &m.exclude_clarifai_workflows },
                |m: &mut GetWorkflowRequest| { &mut m.exclude_clarifai_workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetWorkflowRequest>(
                "GetWorkflowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetWorkflowRequest {
        static instance: ::protobuf::rt::LazyV2<GetWorkflowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWorkflowRequest::new)
    }
}

impl ::protobuf::Clear for GetWorkflowRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.favor_clarifai_workflows = false;
        self.additional_fields.clear();
        self.exclude_clarifai_workflows = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListWorkflowsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    pub sort_ascending: bool,
    pub query: ::std::string::String,
    pub id: ::std::string::String,
    pub featured_only: bool,
    pub starred_only: bool,
    pub additional_fields: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub sort_by: ::std::option::Option<ListWorkflowsRequest_oneof_sort_by>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListWorkflowsRequest {
    fn default() -> &'a ListWorkflowsRequest {
        <ListWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ListWorkflowsRequest_oneof_sort_by {
    sort_by_id(bool),
    sort_by_modified_at(bool),
}

impl ListWorkflowsRequest {
    pub fn new() -> ListWorkflowsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // bool sort_ascending = 5;


    pub fn get_sort_ascending(&self) -> bool {
        self.sort_ascending
    }
    pub fn clear_sort_ascending(&mut self) {
        self.sort_ascending = false;
    }

    // Param is passed by value, moved
    pub fn set_sort_ascending(&mut self, v: bool) {
        self.sort_ascending = v;
    }

    // bool sort_by_id = 6;


    pub fn get_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListWorkflowsRequest_oneof_sort_by::sort_by_id(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sort_by_id(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_id(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListWorkflowsRequest_oneof_sort_by::sort_by_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_id(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(ListWorkflowsRequest_oneof_sort_by::sort_by_id(v))
    }

    // bool sort_by_modified_at = 7;


    pub fn get_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListWorkflowsRequest_oneof_sort_by::sort_by_modified_at(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sort_by_modified_at(&mut self) {
        self.sort_by = ::std::option::Option::None;
    }

    pub fn has_sort_by_modified_at(&self) -> bool {
        match self.sort_by {
            ::std::option::Option::Some(ListWorkflowsRequest_oneof_sort_by::sort_by_modified_at(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sort_by_modified_at(&mut self, v: bool) {
        self.sort_by = ::std::option::Option::Some(ListWorkflowsRequest_oneof_sort_by::sort_by_modified_at(v))
    }

    // string query = 8;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // string id = 4;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bool featured_only = 9;


    pub fn get_featured_only(&self) -> bool {
        self.featured_only
    }
    pub fn clear_featured_only(&mut self) {
        self.featured_only = false;
    }

    // Param is passed by value, moved
    pub fn set_featured_only(&mut self, v: bool) {
        self.featured_only = v;
    }

    // bool starred_only = 11;


    pub fn get_starred_only(&self) -> bool {
        self.starred_only
    }
    pub fn clear_starred_only(&mut self) {
        self.starred_only = false;
    }

    // Param is passed by value, moved
    pub fn set_starred_only(&mut self, v: bool) {
        self.starred_only = v;
    }

    // repeated string additional_fields = 10;


    pub fn get_additional_fields(&self) -> &[::std::string::String] {
        &self.additional_fields
    }
    pub fn clear_additional_fields(&mut self) {
        self.additional_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.additional_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.additional_fields
    }

    // Take field
    pub fn take_additional_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.additional_fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListWorkflowsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sort_ascending = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sort_by = ::std::option::Option::Some(ListWorkflowsRequest_oneof_sort_by::sort_by_id(is.read_bool()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sort_by = ::std::option::Option::Some(ListWorkflowsRequest_oneof_sort_by::sort_by_modified_at(is.read_bool()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.featured_only = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.starred_only = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.additional_fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sort_ascending != false {
            my_size += 2;
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.query);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.id);
        }
        if self.featured_only != false {
            my_size += 2;
        }
        if self.starred_only != false {
            my_size += 2;
        }
        for value in &self.additional_fields {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &ListWorkflowsRequest_oneof_sort_by::sort_by_id(v) => {
                    my_size += 2;
                },
                &ListWorkflowsRequest_oneof_sort_by::sort_by_modified_at(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        if self.sort_ascending != false {
            os.write_bool(5, self.sort_ascending)?;
        }
        if !self.query.is_empty() {
            os.write_string(8, &self.query)?;
        }
        if !self.id.is_empty() {
            os.write_string(4, &self.id)?;
        }
        if self.featured_only != false {
            os.write_bool(9, self.featured_only)?;
        }
        if self.starred_only != false {
            os.write_bool(11, self.starred_only)?;
        }
        for v in &self.additional_fields {
            os.write_string(10, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.sort_by {
            match v {
                &ListWorkflowsRequest_oneof_sort_by::sort_by_id(v) => {
                    os.write_bool(6, v)?;
                },
                &ListWorkflowsRequest_oneof_sort_by::sort_by_modified_at(v) => {
                    os.write_bool(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListWorkflowsRequest {
        ListWorkflowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListWorkflowsRequest| { &m.user_app_id },
                |m: &mut ListWorkflowsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListWorkflowsRequest| { &m.page },
                |m: &mut ListWorkflowsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListWorkflowsRequest| { &m.per_page },
                |m: &mut ListWorkflowsRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sort_ascending",
                |m: &ListWorkflowsRequest| { &m.sort_ascending },
                |m: &mut ListWorkflowsRequest| { &mut m.sort_ascending },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sort_by_id",
                ListWorkflowsRequest::has_sort_by_id,
                ListWorkflowsRequest::get_sort_by_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sort_by_modified_at",
                ListWorkflowsRequest::has_sort_by_modified_at,
                ListWorkflowsRequest::get_sort_by_modified_at,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &ListWorkflowsRequest| { &m.query },
                |m: &mut ListWorkflowsRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ListWorkflowsRequest| { &m.id },
                |m: &mut ListWorkflowsRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "featured_only",
                |m: &ListWorkflowsRequest| { &m.featured_only },
                |m: &mut ListWorkflowsRequest| { &mut m.featured_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "starred_only",
                |m: &ListWorkflowsRequest| { &m.starred_only },
                |m: &mut ListWorkflowsRequest| { &mut m.starred_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "additional_fields",
                |m: &ListWorkflowsRequest| { &m.additional_fields },
                |m: &mut ListWorkflowsRequest| { &mut m.additional_fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListWorkflowsRequest>(
                "ListWorkflowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListWorkflowsRequest {
        static instance: ::protobuf::rt::LazyV2<ListWorkflowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListWorkflowsRequest::new)
    }
}

impl ::protobuf::Clear for ListWorkflowsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.sort_ascending = false;
        self.sort_by = ::std::option::Option::None;
        self.sort_by = ::std::option::Option::None;
        self.query.clear();
        self.id.clear();
        self.featured_only = false;
        self.starred_only = false;
        self.additional_fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflows: ::protobuf::RepeatedField<super::resources::Workflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowsRequest {
    fn default() -> &'a PostWorkflowsRequest {
        <PostWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowsRequest {
    pub fn new() -> PostWorkflowsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Workflow workflows = 2;


    pub fn get_workflows(&self) -> &[super::resources::Workflow] {
        &self.workflows
    }
    pub fn clear_workflows(&mut self) {
        self.workflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflows(&mut self, v: ::protobuf::RepeatedField<super::resources::Workflow>) {
        self.workflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflows(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Workflow> {
        &mut self.workflows
    }

    // Take field
    pub fn take_workflows(&mut self) -> ::protobuf::RepeatedField<super::resources::Workflow> {
        ::std::mem::replace(&mut self.workflows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostWorkflowsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workflows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.workflows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowsRequest {
        PostWorkflowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostWorkflowsRequest| { &m.user_app_id },
                |m: &mut PostWorkflowsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflows",
                |m: &PostWorkflowsRequest| { &m.workflows },
                |m: &mut PostWorkflowsRequest| { &mut m.workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowsRequest>(
                "PostWorkflowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowsRequest {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowsRequest::new)
    }
}

impl ::protobuf::Clear for PostWorkflowsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchWorkflowsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflows: ::protobuf::RepeatedField<super::resources::Workflow>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowsRequest {
    fn default() -> &'a PatchWorkflowsRequest {
        <PatchWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowsRequest {
    pub fn new() -> PatchWorkflowsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Workflow workflows = 2;


    pub fn get_workflows(&self) -> &[super::resources::Workflow] {
        &self.workflows
    }
    pub fn clear_workflows(&mut self) {
        self.workflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflows(&mut self, v: ::protobuf::RepeatedField<super::resources::Workflow>) {
        self.workflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflows(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Workflow> {
        &mut self.workflows
    }

    // Take field
    pub fn take_workflows(&mut self) -> ::protobuf::RepeatedField<super::resources::Workflow> {
        ::std::mem::replace(&mut self.workflows, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchWorkflowsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workflows)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.workflows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchWorkflowsRequest {
        PatchWorkflowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchWorkflowsRequest| { &m.user_app_id },
                |m: &mut PatchWorkflowsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflows",
                |m: &PatchWorkflowsRequest| { &m.workflows },
                |m: &mut PatchWorkflowsRequest| { &mut m.workflows },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchWorkflowsRequest| { &m.action },
                |m: &mut PatchWorkflowsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchWorkflowsRequest>(
                "PatchWorkflowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchWorkflowsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchWorkflowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchWorkflowsRequest::new)
    }
}

impl ::protobuf::Clear for PatchWorkflowsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflows.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWorkflowRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowRequest {
    fn default() -> &'a DeleteWorkflowRequest {
        <DeleteWorkflowRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowRequest {
    pub fn new() -> DeleteWorkflowRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteWorkflowRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWorkflowRequest {
        DeleteWorkflowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteWorkflowRequest| { &m.user_app_id },
                |m: &mut DeleteWorkflowRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &DeleteWorkflowRequest| { &m.workflow_id },
                |m: &mut DeleteWorkflowRequest| { &mut m.workflow_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteWorkflowRequest>(
                "DeleteWorkflowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteWorkflowRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteWorkflowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteWorkflowRequest::new)
    }
}

impl ::protobuf::Clear for DeleteWorkflowRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWorkflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWorkflowsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub delete_all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowsRequest {
    fn default() -> &'a DeleteWorkflowsRequest {
        <DeleteWorkflowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowsRequest {
    pub fn new() -> DeleteWorkflowsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // bool delete_all = 3;


    pub fn get_delete_all(&self) -> bool {
        self.delete_all
    }
    pub fn clear_delete_all(&mut self) {
        self.delete_all = false;
    }

    // Param is passed by value, moved
    pub fn set_delete_all(&mut self, v: bool) {
        self.delete_all = v;
    }
}

impl ::protobuf::Message for DeleteWorkflowsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete_all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWorkflowsRequest {
        DeleteWorkflowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteWorkflowsRequest| { &m.user_app_id },
                |m: &mut DeleteWorkflowsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteWorkflowsRequest| { &m.ids },
                |m: &mut DeleteWorkflowsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "delete_all",
                |m: &DeleteWorkflowsRequest| { &m.delete_all },
                |m: &mut DeleteWorkflowsRequest| { &mut m.delete_all },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteWorkflowsRequest>(
                "DeleteWorkflowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteWorkflowsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteWorkflowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteWorkflowsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteWorkflowsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWorkflowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleWorkflowResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub workflow: ::protobuf::SingularPtrField<super::resources::Workflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowResponse {
    fn default() -> &'a SingleWorkflowResponse {
        <SingleWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowResponse {
    pub fn new() -> SingleWorkflowResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Workflow workflow = 2;


    pub fn get_workflow(&self) -> &super::resources::Workflow {
        self.workflow.as_ref().unwrap_or_else(|| <super::resources::Workflow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_workflow(&mut self) {
        self.workflow.clear();
    }

    pub fn has_workflow(&self) -> bool {
        self.workflow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workflow(&mut self, v: super::resources::Workflow) {
        self.workflow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow(&mut self) -> &mut super::resources::Workflow {
        if self.workflow.is_none() {
            self.workflow.set_default();
        }
        self.workflow.as_mut().unwrap()
    }

    // Take field
    pub fn take_workflow(&mut self) -> super::resources::Workflow {
        self.workflow.take().unwrap_or_else(|| super::resources::Workflow::new())
    }
}

impl ::protobuf::Message for SingleWorkflowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workflow)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.workflow.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleWorkflowResponse {
        SingleWorkflowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleWorkflowResponse| { &m.status },
                |m: &mut SingleWorkflowResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflow",
                |m: &SingleWorkflowResponse| { &m.workflow },
                |m: &mut SingleWorkflowResponse| { &mut m.workflow },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleWorkflowResponse>(
                "SingleWorkflowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleWorkflowResponse {
        static instance: ::protobuf::rt::LazyV2<SingleWorkflowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleWorkflowResponse::new)
    }
}

impl ::protobuf::Clear for SingleWorkflowResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiWorkflowResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub workflows: ::protobuf::RepeatedField<super::resources::Workflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowResponse {
    fn default() -> &'a MultiWorkflowResponse {
        <MultiWorkflowResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowResponse {
    pub fn new() -> MultiWorkflowResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Workflow workflows = 2;


    pub fn get_workflows(&self) -> &[super::resources::Workflow] {
        &self.workflows
    }
    pub fn clear_workflows(&mut self) {
        self.workflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflows(&mut self, v: ::protobuf::RepeatedField<super::resources::Workflow>) {
        self.workflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflows(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Workflow> {
        &mut self.workflows
    }

    // Take field
    pub fn take_workflows(&mut self) -> ::protobuf::RepeatedField<super::resources::Workflow> {
        ::std::mem::replace(&mut self.workflows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiWorkflowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workflows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.workflows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiWorkflowResponse {
        MultiWorkflowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiWorkflowResponse| { &m.status },
                |m: &mut MultiWorkflowResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflows",
                |m: &MultiWorkflowResponse| { &m.workflows },
                |m: &mut MultiWorkflowResponse| { &mut m.workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiWorkflowResponse>(
                "MultiWorkflowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiWorkflowResponse {
        static instance: ::protobuf::rt::LazyV2<MultiWorkflowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiWorkflowResponse::new)
    }
}

impl ::protobuf::Clear for MultiWorkflowResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.workflows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiWorkflowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowResultsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub output_config: ::protobuf::SingularPtrField<super::resources::OutputConfig>,
    pub favor_clarifai_workflows: bool,
    pub workflow_state: ::protobuf::SingularPtrField<super::resources::WorkflowState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsRequest {
    fn default() -> &'a PostWorkflowResultsRequest {
        <PostWorkflowResultsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsRequest {
    pub fn new() -> PostWorkflowResultsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // string version_id = 7;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.Input inputs = 3;


    pub fn get_inputs(&self) -> &[super::resources::Input] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.OutputConfig output_config = 4;


    pub fn get_output_config(&self) -> &super::resources::OutputConfig {
        self.output_config.as_ref().unwrap_or_else(|| <super::resources::OutputConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_config(&mut self) {
        self.output_config.clear();
    }

    pub fn has_output_config(&self) -> bool {
        self.output_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_config(&mut self, v: super::resources::OutputConfig) {
        self.output_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_config(&mut self) -> &mut super::resources::OutputConfig {
        if self.output_config.is_none() {
            self.output_config.set_default();
        }
        self.output_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_config(&mut self) -> super::resources::OutputConfig {
        self.output_config.take().unwrap_or_else(|| super::resources::OutputConfig::new())
    }

    // bool favor_clarifai_workflows = 5;


    pub fn get_favor_clarifai_workflows(&self) -> bool {
        self.favor_clarifai_workflows
    }
    pub fn clear_favor_clarifai_workflows(&mut self) {
        self.favor_clarifai_workflows = false;
    }

    // Param is passed by value, moved
    pub fn set_favor_clarifai_workflows(&mut self, v: bool) {
        self.favor_clarifai_workflows = v;
    }

    // .clarifai.api.WorkflowState workflow_state = 6;


    pub fn get_workflow_state(&self) -> &super::resources::WorkflowState {
        self.workflow_state.as_ref().unwrap_or_else(|| <super::resources::WorkflowState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_workflow_state(&mut self) {
        self.workflow_state.clear();
    }

    pub fn has_workflow_state(&self) -> bool {
        self.workflow_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workflow_state(&mut self, v: super::resources::WorkflowState) {
        self.workflow_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_state(&mut self) -> &mut super::resources::WorkflowState {
        if self.workflow_state.is_none() {
            self.workflow_state.set_default();
        }
        self.workflow_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_workflow_state(&mut self) -> super::resources::WorkflowState {
        self.workflow_state.take().unwrap_or_else(|| super::resources::WorkflowState::new())
    }
}

impl ::protobuf::Message for PostWorkflowResultsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_config)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.favor_clarifai_workflows = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workflow_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version_id);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.output_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.favor_clarifai_workflows != false {
            my_size += 2;
        }
        if let Some(ref v) = self.workflow_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(7, &self.version_id)?;
        }
        for v in &self.inputs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.output_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.favor_clarifai_workflows != false {
            os.write_bool(5, self.favor_clarifai_workflows)?;
        }
        if let Some(ref v) = self.workflow_state.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowResultsRequest {
        PostWorkflowResultsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostWorkflowResultsRequest| { &m.user_app_id },
                |m: &mut PostWorkflowResultsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &PostWorkflowResultsRequest| { &m.workflow_id },
                |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &PostWorkflowResultsRequest| { &m.version_id },
                |m: &mut PostWorkflowResultsRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "inputs",
                |m: &PostWorkflowResultsRequest| { &m.inputs },
                |m: &mut PostWorkflowResultsRequest| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::OutputConfig>>(
                "output_config",
                |m: &PostWorkflowResultsRequest| { &m.output_config },
                |m: &mut PostWorkflowResultsRequest| { &mut m.output_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "favor_clarifai_workflows",
                |m: &PostWorkflowResultsRequest| { &m.favor_clarifai_workflows },
                |m: &mut PostWorkflowResultsRequest| { &mut m.favor_clarifai_workflows },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowState>>(
                "workflow_state",
                |m: &PostWorkflowResultsRequest| { &m.workflow_state },
                |m: &mut PostWorkflowResultsRequest| { &mut m.workflow_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowResultsRequest>(
                "PostWorkflowResultsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowResultsRequest {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowResultsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowResultsRequest::new)
    }
}

impl ::protobuf::Clear for PostWorkflowResultsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.version_id.clear();
        self.inputs.clear();
        self.output_config.clear();
        self.favor_clarifai_workflows = false;
        self.workflow_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowResultsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowResultsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub workflow: ::protobuf::SingularPtrField<super::resources::Workflow>,
    pub results: ::protobuf::RepeatedField<super::resources::WorkflowResult>,
    pub workflow_state: ::protobuf::SingularPtrField<super::resources::WorkflowState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsResponse {
    fn default() -> &'a PostWorkflowResultsResponse {
        <PostWorkflowResultsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsResponse {
    pub fn new() -> PostWorkflowResultsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Workflow workflow = 2;


    pub fn get_workflow(&self) -> &super::resources::Workflow {
        self.workflow.as_ref().unwrap_or_else(|| <super::resources::Workflow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_workflow(&mut self) {
        self.workflow.clear();
    }

    pub fn has_workflow(&self) -> bool {
        self.workflow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workflow(&mut self, v: super::resources::Workflow) {
        self.workflow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow(&mut self) -> &mut super::resources::Workflow {
        if self.workflow.is_none() {
            self.workflow.set_default();
        }
        self.workflow.as_mut().unwrap()
    }

    // Take field
    pub fn take_workflow(&mut self) -> super::resources::Workflow {
        self.workflow.take().unwrap_or_else(|| super::resources::Workflow::new())
    }

    // repeated .clarifai.api.WorkflowResult results = 3;


    pub fn get_results(&self) -> &[super::resources::WorkflowResult] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<super::resources::WorkflowResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::WorkflowResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<super::resources::WorkflowResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    // .clarifai.api.WorkflowState workflow_state = 4;


    pub fn get_workflow_state(&self) -> &super::resources::WorkflowState {
        self.workflow_state.as_ref().unwrap_or_else(|| <super::resources::WorkflowState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_workflow_state(&mut self) {
        self.workflow_state.clear();
    }

    pub fn has_workflow_state(&self) -> bool {
        self.workflow_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workflow_state(&mut self, v: super::resources::WorkflowState) {
        self.workflow_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_state(&mut self) -> &mut super::resources::WorkflowState {
        if self.workflow_state.is_none() {
            self.workflow_state.set_default();
        }
        self.workflow_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_workflow_state(&mut self) -> super::resources::WorkflowState {
        self.workflow_state.take().unwrap_or_else(|| super::resources::WorkflowState::new())
    }
}

impl ::protobuf::Message for PostWorkflowResultsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workflow)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workflow_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.workflow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.workflow_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.workflow.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.results {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.workflow_state.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowResultsResponse {
        PostWorkflowResultsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &PostWorkflowResultsResponse| { &m.status },
                |m: &mut PostWorkflowResultsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Workflow>>(
                "workflow",
                |m: &PostWorkflowResultsResponse| { &m.workflow },
                |m: &mut PostWorkflowResultsResponse| { &mut m.workflow },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowResult>>(
                "results",
                |m: &PostWorkflowResultsResponse| { &m.results },
                |m: &mut PostWorkflowResultsResponse| { &mut m.results },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowState>>(
                "workflow_state",
                |m: &PostWorkflowResultsResponse| { &m.workflow_state },
                |m: &mut PostWorkflowResultsResponse| { &mut m.workflow_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowResultsResponse>(
                "PostWorkflowResultsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowResultsResponse {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowResultsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowResultsResponse::new)
    }
}

impl ::protobuf::Clear for PostWorkflowResultsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.workflow.clear();
        self.results.clear();
        self.workflow_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowResultsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowResultsSimilarityRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub version_id: ::std::string::String,
    pub model_version_id: ::std::string::String,
    pub probe_inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub pool_inputs: ::protobuf::RepeatedField<super::resources::Input>,
    pub favor_clarifai_workflows: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityRequest {
    fn default() -> &'a PostWorkflowResultsSimilarityRequest {
        <PostWorkflowResultsSimilarityRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityRequest {
    pub fn new() -> PostWorkflowResultsSimilarityRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // string version_id = 7;


    pub fn get_version_id(&self) -> &str {
        &self.version_id
    }
    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: ::std::string::String) {
        self.version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.version_id
    }

    // Take field
    pub fn take_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_id, ::std::string::String::new())
    }

    // string model_version_id = 3;


    pub fn get_model_version_id(&self) -> &str {
        &self.model_version_id
    }
    pub fn clear_model_version_id(&mut self) {
        self.model_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_version_id(&mut self, v: ::std::string::String) {
        self.model_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_version_id
    }

    // Take field
    pub fn take_model_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_version_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.Input probe_inputs = 4;


    pub fn get_probe_inputs(&self) -> &[super::resources::Input] {
        &self.probe_inputs
    }
    pub fn clear_probe_inputs(&mut self) {
        self.probe_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_probe_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.probe_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_probe_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.probe_inputs
    }

    // Take field
    pub fn take_probe_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.probe_inputs, ::protobuf::RepeatedField::new())
    }

    // repeated .clarifai.api.Input pool_inputs = 5;


    pub fn get_pool_inputs(&self) -> &[super::resources::Input] {
        &self.pool_inputs
    }
    pub fn clear_pool_inputs(&mut self) {
        self.pool_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pool_inputs(&mut self, v: ::protobuf::RepeatedField<super::resources::Input>) {
        self.pool_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pool_inputs(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Input> {
        &mut self.pool_inputs
    }

    // Take field
    pub fn take_pool_inputs(&mut self) -> ::protobuf::RepeatedField<super::resources::Input> {
        ::std::mem::replace(&mut self.pool_inputs, ::protobuf::RepeatedField::new())
    }

    // bool favor_clarifai_workflows = 6;


    pub fn get_favor_clarifai_workflows(&self) -> bool {
        self.favor_clarifai_workflows
    }
    pub fn clear_favor_clarifai_workflows(&mut self) {
        self.favor_clarifai_workflows = false;
    }

    // Param is passed by value, moved
    pub fn set_favor_clarifai_workflows(&mut self, v: bool) {
        self.favor_clarifai_workflows = v;
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.probe_inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pool_inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.probe_inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pool_inputs)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.favor_clarifai_workflows = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.version_id);
        }
        if !self.model_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model_version_id);
        }
        for value in &self.probe_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pool_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.favor_clarifai_workflows != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.version_id.is_empty() {
            os.write_string(7, &self.version_id)?;
        }
        if !self.model_version_id.is_empty() {
            os.write_string(3, &self.model_version_id)?;
        }
        for v in &self.probe_inputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pool_inputs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.favor_clarifai_workflows != false {
            os.write_bool(6, self.favor_clarifai_workflows)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowResultsSimilarityRequest {
        PostWorkflowResultsSimilarityRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.user_app_id },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.workflow_id },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_id",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.version_id },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_version_id",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.model_version_id },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.model_version_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "probe_inputs",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.probe_inputs },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.probe_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Input>>(
                "pool_inputs",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.pool_inputs },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.pool_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "favor_clarifai_workflows",
                |m: &PostWorkflowResultsSimilarityRequest| { &m.favor_clarifai_workflows },
                |m: &mut PostWorkflowResultsSimilarityRequest| { &mut m.favor_clarifai_workflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowResultsSimilarityRequest>(
                "PostWorkflowResultsSimilarityRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityRequest {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowResultsSimilarityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowResultsSimilarityRequest::new)
    }
}

impl ::protobuf::Clear for PostWorkflowResultsSimilarityRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.version_id.clear();
        self.model_version_id.clear();
        self.probe_inputs.clear();
        self.pool_inputs.clear();
        self.favor_clarifai_workflows = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowResultsSimilarityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostWorkflowResultsSimilarityResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub results: ::protobuf::RepeatedField<super::resources::WorkflowResultsSimilarity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostWorkflowResultsSimilarityResponse {
    fn default() -> &'a PostWorkflowResultsSimilarityResponse {
        <PostWorkflowResultsSimilarityResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostWorkflowResultsSimilarityResponse {
    pub fn new() -> PostWorkflowResultsSimilarityResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.WorkflowResultsSimilarity results = 2;


    pub fn get_results(&self) -> &[super::resources::WorkflowResultsSimilarity] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<super::resources::WorkflowResultsSimilarity>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::WorkflowResultsSimilarity> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<super::resources::WorkflowResultsSimilarity> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostWorkflowResultsSimilarityResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostWorkflowResultsSimilarityResponse {
        PostWorkflowResultsSimilarityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &PostWorkflowResultsSimilarityResponse| { &m.status },
                |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowResultsSimilarity>>(
                "results",
                |m: &PostWorkflowResultsSimilarityResponse| { &m.results },
                |m: &mut PostWorkflowResultsSimilarityResponse| { &mut m.results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostWorkflowResultsSimilarityResponse>(
                "PostWorkflowResultsSimilarityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostWorkflowResultsSimilarityResponse {
        static instance: ::protobuf::rt::LazyV2<PostWorkflowResultsSimilarityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostWorkflowResultsSimilarityResponse::new)
    }
}

impl ::protobuf::Clear for PostWorkflowResultsSimilarityResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostWorkflowResultsSimilarityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostWorkflowResultsSimilarityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListWorkflowVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListWorkflowVersionsRequest {
    fn default() -> &'a ListWorkflowVersionsRequest {
        <ListWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWorkflowVersionsRequest {
    pub fn new() -> ListWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // uint32 page = 3;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 4;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListWorkflowVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListWorkflowVersionsRequest {
        ListWorkflowVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListWorkflowVersionsRequest| { &m.user_app_id },
                |m: &mut ListWorkflowVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &ListWorkflowVersionsRequest| { &m.workflow_id },
                |m: &mut ListWorkflowVersionsRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListWorkflowVersionsRequest| { &m.page },
                |m: &mut ListWorkflowVersionsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListWorkflowVersionsRequest| { &m.per_page },
                |m: &mut ListWorkflowVersionsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListWorkflowVersionsRequest>(
                "ListWorkflowVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListWorkflowVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<ListWorkflowVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListWorkflowVersionsRequest::new)
    }
}

impl ::protobuf::Clear for ListWorkflowVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWorkflowVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetWorkflowVersionRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub workflow_version_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWorkflowVersionRequest {
    fn default() -> &'a GetWorkflowVersionRequest {
        <GetWorkflowVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWorkflowVersionRequest {
    pub fn new() -> GetWorkflowVersionRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // string workflow_version_id = 3;


    pub fn get_workflow_version_id(&self) -> &str {
        &self.workflow_version_id
    }
    pub fn clear_workflow_version_id(&mut self) {
        self.workflow_version_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_version_id(&mut self, v: ::std::string::String) {
        self.workflow_version_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_version_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_version_id
    }

    // Take field
    pub fn take_workflow_version_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_version_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetWorkflowVersionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_version_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        if !self.workflow_version_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.workflow_version_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        if !self.workflow_version_id.is_empty() {
            os.write_string(3, &self.workflow_version_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWorkflowVersionRequest {
        GetWorkflowVersionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetWorkflowVersionRequest| { &m.user_app_id },
                |m: &mut GetWorkflowVersionRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &GetWorkflowVersionRequest| { &m.workflow_id },
                |m: &mut GetWorkflowVersionRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_version_id",
                |m: &GetWorkflowVersionRequest| { &m.workflow_version_id },
                |m: &mut GetWorkflowVersionRequest| { &mut m.workflow_version_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetWorkflowVersionRequest>(
                "GetWorkflowVersionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetWorkflowVersionRequest {
        static instance: ::protobuf::rt::LazyV2<GetWorkflowVersionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWorkflowVersionRequest::new)
    }
}

impl ::protobuf::Clear for GetWorkflowVersionRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_version_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetWorkflowVersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWorkflowVersionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWorkflowVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub workflow_version_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWorkflowVersionsRequest {
    fn default() -> &'a DeleteWorkflowVersionsRequest {
        <DeleteWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkflowVersionsRequest {
    pub fn new() -> DeleteWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // repeated string workflow_version_ids = 3;


    pub fn get_workflow_version_ids(&self) -> &[::std::string::String] {
        &self.workflow_version_ids
    }
    pub fn clear_workflow_version_ids(&mut self) {
        self.workflow_version_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_version_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.workflow_version_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflow_version_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.workflow_version_ids
    }

    // Take field
    pub fn take_workflow_version_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.workflow_version_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteWorkflowVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.workflow_version_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.workflow_version_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.workflow_version_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWorkflowVersionsRequest {
        DeleteWorkflowVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteWorkflowVersionsRequest| { &m.user_app_id },
                |m: &mut DeleteWorkflowVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &DeleteWorkflowVersionsRequest| { &m.workflow_id },
                |m: &mut DeleteWorkflowVersionsRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_version_ids",
                |m: &DeleteWorkflowVersionsRequest| { &m.workflow_version_ids },
                |m: &mut DeleteWorkflowVersionsRequest| { &mut m.workflow_version_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteWorkflowVersionsRequest>(
                "DeleteWorkflowVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteWorkflowVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteWorkflowVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteWorkflowVersionsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteWorkflowVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_version_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkflowVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchWorkflowVersionsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub workflow_id: ::std::string::String,
    pub workflow_versions: ::protobuf::RepeatedField<super::resources::WorkflowVersion>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchWorkflowVersionsRequest {
    fn default() -> &'a PatchWorkflowVersionsRequest {
        <PatchWorkflowVersionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchWorkflowVersionsRequest {
    pub fn new() -> PatchWorkflowVersionsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string workflow_id = 2;


    pub fn get_workflow_id(&self) -> &str {
        &self.workflow_id
    }
    pub fn clear_workflow_id(&mut self) {
        self.workflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_id(&mut self, v: ::std::string::String) {
        self.workflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.workflow_id
    }

    // Take field
    pub fn take_workflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workflow_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.WorkflowVersion workflow_versions = 3;


    pub fn get_workflow_versions(&self) -> &[super::resources::WorkflowVersion] {
        &self.workflow_versions
    }
    pub fn clear_workflow_versions(&mut self) {
        self.workflow_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_versions(&mut self, v: ::protobuf::RepeatedField<super::resources::WorkflowVersion>) {
        self.workflow_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflow_versions(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::WorkflowVersion> {
        &mut self.workflow_versions
    }

    // Take field
    pub fn take_workflow_versions(&mut self) -> ::protobuf::RepeatedField<super::resources::WorkflowVersion> {
        ::std::mem::replace(&mut self.workflow_versions, ::protobuf::RepeatedField::new())
    }

    // string action = 4;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchWorkflowVersionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workflow_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workflow_versions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.workflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.workflow_id);
        }
        for value in &self.workflow_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.workflow_id.is_empty() {
            os.write_string(2, &self.workflow_id)?;
        }
        for v in &self.workflow_versions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(4, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchWorkflowVersionsRequest {
        PatchWorkflowVersionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchWorkflowVersionsRequest| { &m.user_app_id },
                |m: &mut PatchWorkflowVersionsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workflow_id",
                |m: &PatchWorkflowVersionsRequest| { &m.workflow_id },
                |m: &mut PatchWorkflowVersionsRequest| { &mut m.workflow_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowVersion>>(
                "workflow_versions",
                |m: &PatchWorkflowVersionsRequest| { &m.workflow_versions },
                |m: &mut PatchWorkflowVersionsRequest| { &mut m.workflow_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchWorkflowVersionsRequest| { &m.action },
                |m: &mut PatchWorkflowVersionsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchWorkflowVersionsRequest>(
                "PatchWorkflowVersionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchWorkflowVersionsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchWorkflowVersionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchWorkflowVersionsRequest::new)
    }
}

impl ::protobuf::Clear for PatchWorkflowVersionsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.workflow_id.clear();
        self.workflow_versions.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchWorkflowVersionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchWorkflowVersionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiWorkflowVersionResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub workflow_versions: ::protobuf::RepeatedField<super::resources::WorkflowVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiWorkflowVersionResponse {
    fn default() -> &'a MultiWorkflowVersionResponse {
        <MultiWorkflowVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiWorkflowVersionResponse {
    pub fn new() -> MultiWorkflowVersionResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.WorkflowVersion workflow_versions = 2;


    pub fn get_workflow_versions(&self) -> &[super::resources::WorkflowVersion] {
        &self.workflow_versions
    }
    pub fn clear_workflow_versions(&mut self) {
        self.workflow_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_workflow_versions(&mut self, v: ::protobuf::RepeatedField<super::resources::WorkflowVersion>) {
        self.workflow_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workflow_versions(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::WorkflowVersion> {
        &mut self.workflow_versions
    }

    // Take field
    pub fn take_workflow_versions(&mut self) -> ::protobuf::RepeatedField<super::resources::WorkflowVersion> {
        ::std::mem::replace(&mut self.workflow_versions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiWorkflowVersionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workflow_versions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.workflow_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.workflow_versions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiWorkflowVersionResponse {
        MultiWorkflowVersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiWorkflowVersionResponse| { &m.status },
                |m: &mut MultiWorkflowVersionResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowVersion>>(
                "workflow_versions",
                |m: &MultiWorkflowVersionResponse| { &m.workflow_versions },
                |m: &mut MultiWorkflowVersionResponse| { &mut m.workflow_versions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiWorkflowVersionResponse>(
                "MultiWorkflowVersionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiWorkflowVersionResponse {
        static instance: ::protobuf::rt::LazyV2<MultiWorkflowVersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiWorkflowVersionResponse::new)
    }
}

impl ::protobuf::Clear for MultiWorkflowVersionResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.workflow_versions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiWorkflowVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiWorkflowVersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleWorkflowVersionResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub workflow_version: ::protobuf::SingularPtrField<super::resources::WorkflowVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleWorkflowVersionResponse {
    fn default() -> &'a SingleWorkflowVersionResponse {
        <SingleWorkflowVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleWorkflowVersionResponse {
    pub fn new() -> SingleWorkflowVersionResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.WorkflowVersion workflow_version = 2;


    pub fn get_workflow_version(&self) -> &super::resources::WorkflowVersion {
        self.workflow_version.as_ref().unwrap_or_else(|| <super::resources::WorkflowVersion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_workflow_version(&mut self) {
        self.workflow_version.clear();
    }

    pub fn has_workflow_version(&self) -> bool {
        self.workflow_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workflow_version(&mut self, v: super::resources::WorkflowVersion) {
        self.workflow_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workflow_version(&mut self) -> &mut super::resources::WorkflowVersion {
        if self.workflow_version.is_none() {
            self.workflow_version.set_default();
        }
        self.workflow_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_workflow_version(&mut self) -> super::resources::WorkflowVersion {
        self.workflow_version.take().unwrap_or_else(|| super::resources::WorkflowVersion::new())
    }
}

impl ::protobuf::Message for SingleWorkflowVersionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workflow_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workflow_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.workflow_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.workflow_version.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleWorkflowVersionResponse {
        SingleWorkflowVersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleWorkflowVersionResponse| { &m.status },
                |m: &mut SingleWorkflowVersionResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::WorkflowVersion>>(
                "workflow_version",
                |m: &SingleWorkflowVersionResponse| { &m.workflow_version },
                |m: &mut SingleWorkflowVersionResponse| { &mut m.workflow_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleWorkflowVersionResponse>(
                "SingleWorkflowVersionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleWorkflowVersionResponse {
        static instance: ::protobuf::rt::LazyV2<SingleWorkflowVersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleWorkflowVersionResponse::new)
    }
}

impl ::protobuf::Clear for SingleWorkflowVersionResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.workflow_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleWorkflowVersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkflowVersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostAppDuplicationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub app_duplications: ::protobuf::RepeatedField<super::resources::AppDuplication>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostAppDuplicationsRequest {
    fn default() -> &'a PostAppDuplicationsRequest {
        <PostAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostAppDuplicationsRequest {
    pub fn new() -> PostAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.AppDuplication app_duplications = 2;


    pub fn get_app_duplications(&self) -> &[super::resources::AppDuplication] {
        &self.app_duplications
    }
    pub fn clear_app_duplications(&mut self) {
        self.app_duplications.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_duplications(&mut self, v: ::protobuf::RepeatedField<super::resources::AppDuplication>) {
        self.app_duplications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_duplications(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::AppDuplication> {
        &mut self.app_duplications
    }

    // Take field
    pub fn take_app_duplications(&mut self) -> ::protobuf::RepeatedField<super::resources::AppDuplication> {
        ::std::mem::replace(&mut self.app_duplications, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostAppDuplicationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_duplications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_duplications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.app_duplications {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostAppDuplicationsRequest {
        PostAppDuplicationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostAppDuplicationsRequest| { &m.user_app_id },
                |m: &mut PostAppDuplicationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AppDuplication>>(
                "app_duplications",
                |m: &PostAppDuplicationsRequest| { &m.app_duplications },
                |m: &mut PostAppDuplicationsRequest| { &mut m.app_duplications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostAppDuplicationsRequest>(
                "PostAppDuplicationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostAppDuplicationsRequest {
        static instance: ::protobuf::rt::LazyV2<PostAppDuplicationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostAppDuplicationsRequest::new)
    }
}

impl ::protobuf::Clear for PostAppDuplicationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostAppDuplicationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAppDuplicationRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub app_duplication_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAppDuplicationRequest {
    fn default() -> &'a GetAppDuplicationRequest {
        <GetAppDuplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAppDuplicationRequest {
    pub fn new() -> GetAppDuplicationRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string app_duplication_id = 2;


    pub fn get_app_duplication_id(&self) -> &str {
        &self.app_duplication_id
    }
    pub fn clear_app_duplication_id(&mut self) {
        self.app_duplication_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_duplication_id(&mut self, v: ::std::string::String) {
        self.app_duplication_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_duplication_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_duplication_id
    }

    // Take field
    pub fn take_app_duplication_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_duplication_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAppDuplicationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_duplication_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_duplication_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_duplication_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_duplication_id.is_empty() {
            os.write_string(2, &self.app_duplication_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAppDuplicationRequest {
        GetAppDuplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetAppDuplicationRequest| { &m.user_app_id },
                |m: &mut GetAppDuplicationRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_duplication_id",
                |m: &GetAppDuplicationRequest| { &m.app_duplication_id },
                |m: &mut GetAppDuplicationRequest| { &mut m.app_duplication_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAppDuplicationRequest>(
                "GetAppDuplicationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAppDuplicationRequest {
        static instance: ::protobuf::rt::LazyV2<GetAppDuplicationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAppDuplicationRequest::new)
    }
}

impl ::protobuf::Clear for GetAppDuplicationRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.app_duplication_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAppDuplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAppDuplicationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAppDuplicationsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAppDuplicationsRequest {
    fn default() -> &'a ListAppDuplicationsRequest {
        <ListAppDuplicationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAppDuplicationsRequest {
    pub fn new() -> ListAppDuplicationsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListAppDuplicationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAppDuplicationsRequest {
        ListAppDuplicationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListAppDuplicationsRequest| { &m.user_app_id },
                |m: &mut ListAppDuplicationsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListAppDuplicationsRequest| { &m.page },
                |m: &mut ListAppDuplicationsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListAppDuplicationsRequest| { &m.per_page },
                |m: &mut ListAppDuplicationsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListAppDuplicationsRequest>(
                "ListAppDuplicationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListAppDuplicationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAppDuplicationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAppDuplicationsRequest::new)
    }
}

impl ::protobuf::Clear for ListAppDuplicationsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAppDuplicationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAppDuplicationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiAppDuplicationsResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub app_duplications: ::protobuf::RepeatedField<super::resources::AppDuplication>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiAppDuplicationsResponse {
    fn default() -> &'a MultiAppDuplicationsResponse {
        <MultiAppDuplicationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiAppDuplicationsResponse {
    pub fn new() -> MultiAppDuplicationsResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.AppDuplication app_duplications = 2;


    pub fn get_app_duplications(&self) -> &[super::resources::AppDuplication] {
        &self.app_duplications
    }
    pub fn clear_app_duplications(&mut self) {
        self.app_duplications.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_duplications(&mut self, v: ::protobuf::RepeatedField<super::resources::AppDuplication>) {
        self.app_duplications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_duplications(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::AppDuplication> {
        &mut self.app_duplications
    }

    // Take field
    pub fn take_app_duplications(&mut self) -> ::protobuf::RepeatedField<super::resources::AppDuplication> {
        ::std::mem::replace(&mut self.app_duplications, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiAppDuplicationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_duplications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_duplications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.app_duplications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.app_duplications {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiAppDuplicationsResponse {
        MultiAppDuplicationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiAppDuplicationsResponse| { &m.status },
                |m: &mut MultiAppDuplicationsResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AppDuplication>>(
                "app_duplications",
                |m: &MultiAppDuplicationsResponse| { &m.app_duplications },
                |m: &mut MultiAppDuplicationsResponse| { &mut m.app_duplications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiAppDuplicationsResponse>(
                "MultiAppDuplicationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiAppDuplicationsResponse {
        static instance: ::protobuf::rt::LazyV2<MultiAppDuplicationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiAppDuplicationsResponse::new)
    }
}

impl ::protobuf::Clear for MultiAppDuplicationsResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.app_duplications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiAppDuplicationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAppDuplicationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleAppDuplicationResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub app_duplication: ::protobuf::SingularPtrField<super::resources::AppDuplication>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleAppDuplicationResponse {
    fn default() -> &'a SingleAppDuplicationResponse {
        <SingleAppDuplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleAppDuplicationResponse {
    pub fn new() -> SingleAppDuplicationResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.AppDuplication app_duplication = 2;


    pub fn get_app_duplication(&self) -> &super::resources::AppDuplication {
        self.app_duplication.as_ref().unwrap_or_else(|| <super::resources::AppDuplication as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app_duplication(&mut self) {
        self.app_duplication.clear();
    }

    pub fn has_app_duplication(&self) -> bool {
        self.app_duplication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_duplication(&mut self, v: super::resources::AppDuplication) {
        self.app_duplication = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_duplication(&mut self) -> &mut super::resources::AppDuplication {
        if self.app_duplication.is_none() {
            self.app_duplication.set_default();
        }
        self.app_duplication.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_duplication(&mut self) -> super::resources::AppDuplication {
        self.app_duplication.take().unwrap_or_else(|| super::resources::AppDuplication::new())
    }
}

impl ::protobuf::Message for SingleAppDuplicationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.app_duplication {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app_duplication)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.app_duplication.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.app_duplication.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleAppDuplicationResponse {
        SingleAppDuplicationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleAppDuplicationResponse| { &m.status },
                |m: &mut SingleAppDuplicationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::AppDuplication>>(
                "app_duplication",
                |m: &SingleAppDuplicationResponse| { &m.app_duplication },
                |m: &mut SingleAppDuplicationResponse| { &mut m.app_duplication },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleAppDuplicationResponse>(
                "SingleAppDuplicationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleAppDuplicationResponse {
        static instance: ::protobuf::rt::LazyV2<SingleAppDuplicationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleAppDuplicationResponse::new)
    }
}

impl ::protobuf::Clear for SingleAppDuplicationResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.app_duplication.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleAppDuplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleAppDuplicationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostTasksRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub tasks: ::protobuf::RepeatedField<super::resources::Task>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostTasksRequest {
    fn default() -> &'a PostTasksRequest {
        <PostTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTasksRequest {
    pub fn new() -> PostTasksRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Task tasks = 2;


    pub fn get_tasks(&self) -> &[super::resources::Task] {
        &self.tasks
    }
    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<super::resources::Task>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Task> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<super::resources::Task> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostTasksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tasks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tasks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostTasksRequest {
        PostTasksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostTasksRequest| { &m.user_app_id },
                |m: &mut PostTasksRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Task>>(
                "tasks",
                |m: &PostTasksRequest| { &m.tasks },
                |m: &mut PostTasksRequest| { &mut m.tasks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostTasksRequest>(
                "PostTasksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostTasksRequest {
        static instance: ::protobuf::rt::LazyV2<PostTasksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostTasksRequest::new)
    }
}

impl ::protobuf::Clear for PostTasksRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTasksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTaskRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub task_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTaskRequest {
    fn default() -> &'a GetTaskRequest {
        <GetTaskRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskRequest {
    pub fn new() -> GetTaskRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string task_id = 2;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTaskRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTaskRequest {
        GetTaskRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetTaskRequest| { &m.user_app_id },
                |m: &mut GetTaskRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &GetTaskRequest| { &m.task_id },
                |m: &mut GetTaskRequest| { &mut m.task_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTaskRequest>(
                "GetTaskRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTaskRequest {
        static instance: ::protobuf::rt::LazyV2<GetTaskRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTaskRequest::new)
    }
}

impl ::protobuf::Clear for GetTaskRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTaskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTasksRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    pub worker_user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub review_user_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub including_label_order_tasks: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTasksRequest {
    fn default() -> &'a ListTasksRequest {
        <ListTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTasksRequest {
    pub fn new() -> ListTasksRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }

    // repeated string worker_user_ids = 4;


    pub fn get_worker_user_ids(&self) -> &[::std::string::String] {
        &self.worker_user_ids
    }
    pub fn clear_worker_user_ids(&mut self) {
        self.worker_user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.worker_user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_worker_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.worker_user_ids
    }

    // Take field
    pub fn take_worker_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.worker_user_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string review_user_ids = 5;


    pub fn get_review_user_ids(&self) -> &[::std::string::String] {
        &self.review_user_ids
    }
    pub fn clear_review_user_ids(&mut self) {
        self.review_user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_review_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.review_user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_review_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.review_user_ids
    }

    // Take field
    pub fn take_review_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.review_user_ids, ::protobuf::RepeatedField::new())
    }

    // bool including_label_order_tasks = 6;


    pub fn get_including_label_order_tasks(&self) -> bool {
        self.including_label_order_tasks
    }
    pub fn clear_including_label_order_tasks(&mut self) {
        self.including_label_order_tasks = false;
    }

    // Param is passed by value, moved
    pub fn set_including_label_order_tasks(&mut self, v: bool) {
        self.including_label_order_tasks = v;
    }
}

impl ::protobuf::Message for ListTasksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.worker_user_ids)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.review_user_ids)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.including_label_order_tasks = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.worker_user_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.review_user_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.including_label_order_tasks != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        for v in &self.worker_user_ids {
            os.write_string(4, &v)?;
        };
        for v in &self.review_user_ids {
            os.write_string(5, &v)?;
        };
        if self.including_label_order_tasks != false {
            os.write_bool(6, self.including_label_order_tasks)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTasksRequest {
        ListTasksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListTasksRequest| { &m.user_app_id },
                |m: &mut ListTasksRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListTasksRequest| { &m.page },
                |m: &mut ListTasksRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListTasksRequest| { &m.per_page },
                |m: &mut ListTasksRequest| { &mut m.per_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "worker_user_ids",
                |m: &ListTasksRequest| { &m.worker_user_ids },
                |m: &mut ListTasksRequest| { &mut m.worker_user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "review_user_ids",
                |m: &ListTasksRequest| { &m.review_user_ids },
                |m: &mut ListTasksRequest| { &mut m.review_user_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "including_label_order_tasks",
                |m: &ListTasksRequest| { &m.including_label_order_tasks },
                |m: &mut ListTasksRequest| { &mut m.including_label_order_tasks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTasksRequest>(
                "ListTasksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTasksRequest {
        static instance: ::protobuf::rt::LazyV2<ListTasksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTasksRequest::new)
    }
}

impl ::protobuf::Clear for ListTasksRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.worker_user_ids.clear();
        self.review_user_ids.clear();
        self.including_label_order_tasks = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTasksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchTasksRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub tasks: ::protobuf::RepeatedField<super::resources::Task>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchTasksRequest {
    fn default() -> &'a PatchTasksRequest {
        <PatchTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchTasksRequest {
    pub fn new() -> PatchTasksRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Task tasks = 2;


    pub fn get_tasks(&self) -> &[super::resources::Task] {
        &self.tasks
    }
    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<super::resources::Task>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Task> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<super::resources::Task> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchTasksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tasks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tasks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchTasksRequest {
        PatchTasksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchTasksRequest| { &m.user_app_id },
                |m: &mut PatchTasksRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Task>>(
                "tasks",
                |m: &PatchTasksRequest| { &m.tasks },
                |m: &mut PatchTasksRequest| { &mut m.tasks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchTasksRequest| { &m.action },
                |m: &mut PatchTasksRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchTasksRequest>(
                "PatchTasksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchTasksRequest {
        static instance: ::protobuf::rt::LazyV2<PatchTasksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchTasksRequest::new)
    }
}

impl ::protobuf::Clear for PatchTasksRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.tasks.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchTasksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTasksRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTasksRequest {
    fn default() -> &'a DeleteTasksRequest {
        <DeleteTasksRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTasksRequest {
    pub fn new() -> DeleteTasksRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteTasksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTasksRequest {
        DeleteTasksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteTasksRequest| { &m.user_app_id },
                |m: &mut DeleteTasksRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteTasksRequest| { &m.ids },
                |m: &mut DeleteTasksRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteTasksRequest>(
                "DeleteTasksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteTasksRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteTasksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteTasksRequest::new)
    }
}

impl ::protobuf::Clear for DeleteTasksRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTasksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTasksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiTaskResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub tasks: ::protobuf::RepeatedField<super::resources::Task>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiTaskResponse {
    fn default() -> &'a MultiTaskResponse {
        <MultiTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTaskResponse {
    pub fn new() -> MultiTaskResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Task tasks = 2;


    pub fn get_tasks(&self) -> &[super::resources::Task] {
        &self.tasks
    }
    pub fn clear_tasks(&mut self) {
        self.tasks.clear();
    }

    // Param is passed by value, moved
    pub fn set_tasks(&mut self, v: ::protobuf::RepeatedField<super::resources::Task>) {
        self.tasks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tasks(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Task> {
        &mut self.tasks
    }

    // Take field
    pub fn take_tasks(&mut self) -> ::protobuf::RepeatedField<super::resources::Task> {
        ::std::mem::replace(&mut self.tasks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiTaskResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tasks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tasks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tasks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tasks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiTaskResponse {
        MultiTaskResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiTaskResponse| { &m.status },
                |m: &mut MultiTaskResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Task>>(
                "tasks",
                |m: &MultiTaskResponse| { &m.tasks },
                |m: &mut MultiTaskResponse| { &mut m.tasks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiTaskResponse>(
                "MultiTaskResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiTaskResponse {
        static instance: ::protobuf::rt::LazyV2<MultiTaskResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiTaskResponse::new)
    }
}

impl ::protobuf::Clear for MultiTaskResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.tasks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTaskResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleTaskResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub task: ::protobuf::SingularPtrField<super::resources::Task>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleTaskResponse {
    fn default() -> &'a SingleTaskResponse {
        <SingleTaskResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskResponse {
    pub fn new() -> SingleTaskResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Task task = 2;


    pub fn get_task(&self) -> &super::resources::Task {
        self.task.as_ref().unwrap_or_else(|| <super::resources::Task as ::protobuf::Message>::default_instance())
    }
    pub fn clear_task(&mut self) {
        self.task.clear();
    }

    pub fn has_task(&self) -> bool {
        self.task.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task(&mut self, v: super::resources::Task) {
        self.task = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task(&mut self) -> &mut super::resources::Task {
        if self.task.is_none() {
            self.task.set_default();
        }
        self.task.as_mut().unwrap()
    }

    // Take field
    pub fn take_task(&mut self) -> super::resources::Task {
        self.task.take().unwrap_or_else(|| super::resources::Task::new())
    }
}

impl ::protobuf::Message for SingleTaskResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.task {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.task.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.task.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleTaskResponse {
        SingleTaskResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleTaskResponse| { &m.status },
                |m: &mut SingleTaskResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Task>>(
                "task",
                |m: &SingleTaskResponse| { &m.task },
                |m: &mut SingleTaskResponse| { &mut m.task },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleTaskResponse>(
                "SingleTaskResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleTaskResponse {
        static instance: ::protobuf::rt::LazyV2<SingleTaskResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleTaskResponse::new)
    }
}

impl ::protobuf::Clear for SingleTaskResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.task.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleTaskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTaskCountRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub task_id: ::std::string::String,
    pub user_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTaskCountRequest {
    fn default() -> &'a GetTaskCountRequest {
        <GetTaskCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTaskCountRequest {
    pub fn new() -> GetTaskCountRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string task_id = 2;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    // repeated string user_ids = 3;


    pub fn get_user_ids(&self) -> &[::std::string::String] {
        &self.user_ids
    }
    pub fn clear_user_ids(&mut self) {
        self.user_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.user_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.user_ids
    }

    // Take field
    pub fn take_user_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.user_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetTaskCountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.user_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        for value in &self.user_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        for v in &self.user_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTaskCountRequest {
        GetTaskCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetTaskCountRequest| { &m.user_app_id },
                |m: &mut GetTaskCountRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &GetTaskCountRequest| { &m.task_id },
                |m: &mut GetTaskCountRequest| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_ids",
                |m: &GetTaskCountRequest| { &m.user_ids },
                |m: &mut GetTaskCountRequest| { &mut m.user_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTaskCountRequest>(
                "GetTaskCountRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTaskCountRequest {
        static instance: ::protobuf::rt::LazyV2<GetTaskCountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTaskCountRequest::new)
    }
}

impl ::protobuf::Clear for GetTaskCountRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.task_id.clear();
        self.user_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTaskCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTaskCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleTaskCountResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub app_id: ::std::string::String,
    pub task_id: ::std::string::String,
    pub counts: ::protobuf::RepeatedField<super::resources::TaskStatusCountPerUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleTaskCountResponse {
    fn default() -> &'a SingleTaskCountResponse {
        <SingleTaskCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleTaskCountResponse {
    pub fn new() -> SingleTaskCountResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // string app_id = 2;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string task_id = 3;


    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    // repeated .clarifai.api.TaskStatusCountPerUser counts = 4;


    pub fn get_counts(&self) -> &[super::resources::TaskStatusCountPerUser] {
        &self.counts
    }
    pub fn clear_counts(&mut self) {
        self.counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_counts(&mut self, v: ::protobuf::RepeatedField<super::resources::TaskStatusCountPerUser>) {
        self.counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::TaskStatusCountPerUser> {
        &mut self.counts
    }

    // Take field
    pub fn take_counts(&mut self) -> ::protobuf::RepeatedField<super::resources::TaskStatusCountPerUser> {
        ::std::mem::replace(&mut self.counts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SingleTaskCountResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.counts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.app_id);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.task_id);
        }
        for value in &self.counts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(2, &self.app_id)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(3, &self.task_id)?;
        }
        for v in &self.counts {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleTaskCountResponse {
        SingleTaskCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleTaskCountResponse| { &m.status },
                |m: &mut SingleTaskCountResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "app_id",
                |m: &SingleTaskCountResponse| { &m.app_id },
                |m: &mut SingleTaskCountResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_id",
                |m: &SingleTaskCountResponse| { &m.task_id },
                |m: &mut SingleTaskCountResponse| { &mut m.task_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::TaskStatusCountPerUser>>(
                "counts",
                |m: &SingleTaskCountResponse| { &m.counts },
                |m: &mut SingleTaskCountResponse| { &mut m.counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleTaskCountResponse>(
                "SingleTaskCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleTaskCountResponse {
        static instance: ::protobuf::rt::LazyV2<SingleTaskCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleTaskCountResponse::new)
    }
}

impl ::protobuf::Clear for SingleTaskCountResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.app_id.clear();
        self.task_id.clear();
        self.counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleTaskCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleTaskCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostLabelOrdersRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub label_orders: ::protobuf::RepeatedField<super::resources::LabelOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostLabelOrdersRequest {
    fn default() -> &'a PostLabelOrdersRequest {
        <PostLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostLabelOrdersRequest {
    pub fn new() -> PostLabelOrdersRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.LabelOrder label_orders = 2;


    pub fn get_label_orders(&self) -> &[super::resources::LabelOrder] {
        &self.label_orders
    }
    pub fn clear_label_orders(&mut self) {
        self.label_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_orders(&mut self, v: ::protobuf::RepeatedField<super::resources::LabelOrder>) {
        self.label_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::LabelOrder> {
        &mut self.label_orders
    }

    // Take field
    pub fn take_label_orders(&mut self) -> ::protobuf::RepeatedField<super::resources::LabelOrder> {
        ::std::mem::replace(&mut self.label_orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostLabelOrdersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.label_orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostLabelOrdersRequest {
        PostLabelOrdersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostLabelOrdersRequest| { &m.user_app_id },
                |m: &mut PostLabelOrdersRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::LabelOrder>>(
                "label_orders",
                |m: &PostLabelOrdersRequest| { &m.label_orders },
                |m: &mut PostLabelOrdersRequest| { &mut m.label_orders },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostLabelOrdersRequest>(
                "PostLabelOrdersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostLabelOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<PostLabelOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostLabelOrdersRequest::new)
    }
}

impl ::protobuf::Clear for PostLabelOrdersRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostLabelOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLabelOrderRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub label_order_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLabelOrderRequest {
    fn default() -> &'a GetLabelOrderRequest {
        <GetLabelOrderRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLabelOrderRequest {
    pub fn new() -> GetLabelOrderRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string label_order_id = 2;


    pub fn get_label_order_id(&self) -> &str {
        &self.label_order_id
    }
    pub fn clear_label_order_id(&mut self) {
        self.label_order_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_order_id(&mut self, v: ::std::string::String) {
        self.label_order_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label_order_id(&mut self) -> &mut ::std::string::String {
        &mut self.label_order_id
    }

    // Take field
    pub fn take_label_order_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label_order_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetLabelOrderRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label_order_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.label_order_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label_order_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.label_order_id.is_empty() {
            os.write_string(2, &self.label_order_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLabelOrderRequest {
        GetLabelOrderRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetLabelOrderRequest| { &m.user_app_id },
                |m: &mut GetLabelOrderRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label_order_id",
                |m: &GetLabelOrderRequest| { &m.label_order_id },
                |m: &mut GetLabelOrderRequest| { &mut m.label_order_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLabelOrderRequest>(
                "GetLabelOrderRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLabelOrderRequest {
        static instance: ::protobuf::rt::LazyV2<GetLabelOrderRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLabelOrderRequest::new)
    }
}

impl ::protobuf::Clear for GetLabelOrderRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_order_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLabelOrderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLabelOrderRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListLabelOrdersRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListLabelOrdersRequest {
    fn default() -> &'a ListLabelOrdersRequest {
        <ListLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListLabelOrdersRequest {
    pub fn new() -> ListLabelOrdersRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListLabelOrdersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListLabelOrdersRequest {
        ListLabelOrdersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListLabelOrdersRequest| { &m.user_app_id },
                |m: &mut ListLabelOrdersRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListLabelOrdersRequest| { &m.page },
                |m: &mut ListLabelOrdersRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListLabelOrdersRequest| { &m.per_page },
                |m: &mut ListLabelOrdersRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListLabelOrdersRequest>(
                "ListLabelOrdersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListLabelOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<ListLabelOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListLabelOrdersRequest::new)
    }
}

impl ::protobuf::Clear for ListLabelOrdersRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLabelOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchLabelOrdersRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub label_orders: ::protobuf::RepeatedField<super::resources::LabelOrder>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchLabelOrdersRequest {
    fn default() -> &'a PatchLabelOrdersRequest {
        <PatchLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchLabelOrdersRequest {
    pub fn new() -> PatchLabelOrdersRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.LabelOrder label_orders = 2;


    pub fn get_label_orders(&self) -> &[super::resources::LabelOrder] {
        &self.label_orders
    }
    pub fn clear_label_orders(&mut self) {
        self.label_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_orders(&mut self, v: ::protobuf::RepeatedField<super::resources::LabelOrder>) {
        self.label_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::LabelOrder> {
        &mut self.label_orders
    }

    // Take field
    pub fn take_label_orders(&mut self) -> ::protobuf::RepeatedField<super::resources::LabelOrder> {
        ::std::mem::replace(&mut self.label_orders, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchLabelOrdersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_orders)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.label_orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchLabelOrdersRequest {
        PatchLabelOrdersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchLabelOrdersRequest| { &m.user_app_id },
                |m: &mut PatchLabelOrdersRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::LabelOrder>>(
                "label_orders",
                |m: &PatchLabelOrdersRequest| { &m.label_orders },
                |m: &mut PatchLabelOrdersRequest| { &mut m.label_orders },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchLabelOrdersRequest| { &m.action },
                |m: &mut PatchLabelOrdersRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchLabelOrdersRequest>(
                "PatchLabelOrdersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchLabelOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<PatchLabelOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchLabelOrdersRequest::new)
    }
}

impl ::protobuf::Clear for PatchLabelOrdersRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.label_orders.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchLabelOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteLabelOrdersRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteLabelOrdersRequest {
    fn default() -> &'a DeleteLabelOrdersRequest {
        <DeleteLabelOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteLabelOrdersRequest {
    pub fn new() -> DeleteLabelOrdersRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteLabelOrdersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteLabelOrdersRequest {
        DeleteLabelOrdersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteLabelOrdersRequest| { &m.user_app_id },
                |m: &mut DeleteLabelOrdersRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteLabelOrdersRequest| { &m.ids },
                |m: &mut DeleteLabelOrdersRequest| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteLabelOrdersRequest>(
                "DeleteLabelOrdersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteLabelOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteLabelOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteLabelOrdersRequest::new)
    }
}

impl ::protobuf::Clear for DeleteLabelOrdersRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteLabelOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteLabelOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiLabelOrderResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub label_orders: ::protobuf::RepeatedField<super::resources::LabelOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiLabelOrderResponse {
    fn default() -> &'a MultiLabelOrderResponse {
        <MultiLabelOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiLabelOrderResponse {
    pub fn new() -> MultiLabelOrderResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.LabelOrder label_orders = 2;


    pub fn get_label_orders(&self) -> &[super::resources::LabelOrder] {
        &self.label_orders
    }
    pub fn clear_label_orders(&mut self) {
        self.label_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_orders(&mut self, v: ::protobuf::RepeatedField<super::resources::LabelOrder>) {
        self.label_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::LabelOrder> {
        &mut self.label_orders
    }

    // Take field
    pub fn take_label_orders(&mut self) -> ::protobuf::RepeatedField<super::resources::LabelOrder> {
        ::std::mem::replace(&mut self.label_orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiLabelOrderResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.label_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.label_orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiLabelOrderResponse {
        MultiLabelOrderResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiLabelOrderResponse| { &m.status },
                |m: &mut MultiLabelOrderResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::LabelOrder>>(
                "label_orders",
                |m: &MultiLabelOrderResponse| { &m.label_orders },
                |m: &mut MultiLabelOrderResponse| { &mut m.label_orders },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiLabelOrderResponse>(
                "MultiLabelOrderResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiLabelOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MultiLabelOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiLabelOrderResponse::new)
    }
}

impl ::protobuf::Clear for MultiLabelOrderResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.label_orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiLabelOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiLabelOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleLabelOrderResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub label_order: ::protobuf::SingularPtrField<super::resources::LabelOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleLabelOrderResponse {
    fn default() -> &'a SingleLabelOrderResponse {
        <SingleLabelOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleLabelOrderResponse {
    pub fn new() -> SingleLabelOrderResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.LabelOrder label_order = 2;


    pub fn get_label_order(&self) -> &super::resources::LabelOrder {
        self.label_order.as_ref().unwrap_or_else(|| <super::resources::LabelOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_label_order(&mut self) {
        self.label_order.clear();
    }

    pub fn has_label_order(&self) -> bool {
        self.label_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label_order(&mut self, v: super::resources::LabelOrder) {
        self.label_order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label_order(&mut self) -> &mut super::resources::LabelOrder {
        if self.label_order.is_none() {
            self.label_order.set_default();
        }
        self.label_order.as_mut().unwrap()
    }

    // Take field
    pub fn take_label_order(&mut self) -> super::resources::LabelOrder {
        self.label_order.take().unwrap_or_else(|| super::resources::LabelOrder::new())
    }
}

impl ::protobuf::Message for SingleLabelOrderResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.label_order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.label_order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.label_order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleLabelOrderResponse {
        SingleLabelOrderResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleLabelOrderResponse| { &m.status },
                |m: &mut SingleLabelOrderResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::LabelOrder>>(
                "label_order",
                |m: &SingleLabelOrderResponse| { &m.label_order },
                |m: &mut SingleLabelOrderResponse| { &mut m.label_order },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleLabelOrderResponse>(
                "SingleLabelOrderResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleLabelOrderResponse {
        static instance: ::protobuf::rt::LazyV2<SingleLabelOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleLabelOrderResponse::new)
    }
}

impl ::protobuf::Clear for SingleLabelOrderResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.label_order.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleLabelOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleLabelOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostCollectorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collectors: ::protobuf::RepeatedField<super::resources::Collector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostCollectorsRequest {
    fn default() -> &'a PostCollectorsRequest {
        <PostCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostCollectorsRequest {
    pub fn new() -> PostCollectorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Collector collectors = 2;


    pub fn get_collectors(&self) -> &[super::resources::Collector] {
        &self.collectors
    }
    pub fn clear_collectors(&mut self) {
        self.collectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_collectors(&mut self, v: ::protobuf::RepeatedField<super::resources::Collector>) {
        self.collectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collectors(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collector> {
        &mut self.collectors
    }

    // Take field
    pub fn take_collectors(&mut self) -> ::protobuf::RepeatedField<super::resources::Collector> {
        ::std::mem::replace(&mut self.collectors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostCollectorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collectors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collectors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collectors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostCollectorsRequest {
        PostCollectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostCollectorsRequest| { &m.user_app_id },
                |m: &mut PostCollectorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collector>>(
                "collectors",
                |m: &PostCollectorsRequest| { &m.collectors },
                |m: &mut PostCollectorsRequest| { &mut m.collectors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostCollectorsRequest>(
                "PostCollectorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostCollectorsRequest {
        static instance: ::protobuf::rt::LazyV2<PostCollectorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostCollectorsRequest::new)
    }
}

impl ::protobuf::Clear for PostCollectorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCollectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchCollectorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collectors: ::protobuf::RepeatedField<super::resources::Collector>,
    pub action: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchCollectorsRequest {
    fn default() -> &'a PatchCollectorsRequest {
        <PatchCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchCollectorsRequest {
    pub fn new() -> PatchCollectorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.Collector collectors = 2;


    pub fn get_collectors(&self) -> &[super::resources::Collector] {
        &self.collectors
    }
    pub fn clear_collectors(&mut self) {
        self.collectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_collectors(&mut self, v: ::protobuf::RepeatedField<super::resources::Collector>) {
        self.collectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collectors(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collector> {
        &mut self.collectors
    }

    // Take field
    pub fn take_collectors(&mut self) -> ::protobuf::RepeatedField<super::resources::Collector> {
        ::std::mem::replace(&mut self.collectors, ::protobuf::RepeatedField::new())
    }

    // string action = 3;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchCollectorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collectors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collectors)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collectors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.action.is_empty() {
            os.write_string(3, &self.action)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchCollectorsRequest {
        PatchCollectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PatchCollectorsRequest| { &m.user_app_id },
                |m: &mut PatchCollectorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collector>>(
                "collectors",
                |m: &PatchCollectorsRequest| { &m.collectors },
                |m: &mut PatchCollectorsRequest| { &mut m.collectors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &PatchCollectorsRequest| { &m.action },
                |m: &mut PatchCollectorsRequest| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchCollectorsRequest>(
                "PatchCollectorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchCollectorsRequest {
        static instance: ::protobuf::rt::LazyV2<PatchCollectorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchCollectorsRequest::new)
    }
}

impl ::protobuf::Clear for PatchCollectorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collectors.clear();
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchCollectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteCollectorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    pub delete_all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteCollectorsRequest {
    fn default() -> &'a DeleteCollectorsRequest {
        <DeleteCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollectorsRequest {
    pub fn new() -> DeleteCollectorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated string ids = 2;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // bool delete_all = 3;


    pub fn get_delete_all(&self) -> bool {
        self.delete_all
    }
    pub fn clear_delete_all(&mut self) {
        self.delete_all = false;
    }

    // Param is passed by value, moved
    pub fn set_delete_all(&mut self, v: bool) {
        self.delete_all = v;
    }
}

impl ::protobuf::Message for DeleteCollectorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete_all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.delete_all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_string(2, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(3, self.delete_all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteCollectorsRequest {
        DeleteCollectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &DeleteCollectorsRequest| { &m.user_app_id },
                |m: &mut DeleteCollectorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ids",
                |m: &DeleteCollectorsRequest| { &m.ids },
                |m: &mut DeleteCollectorsRequest| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "delete_all",
                |m: &DeleteCollectorsRequest| { &m.delete_all },
                |m: &mut DeleteCollectorsRequest| { &mut m.delete_all },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteCollectorsRequest>(
                "DeleteCollectorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteCollectorsRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteCollectorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteCollectorsRequest::new)
    }
}

impl ::protobuf::Clear for DeleteCollectorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.ids.clear();
        self.delete_all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCollectorRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub collector_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCollectorRequest {
    fn default() -> &'a GetCollectorRequest {
        <GetCollectorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCollectorRequest {
    pub fn new() -> GetCollectorRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string collector_id = 2;


    pub fn get_collector_id(&self) -> &str {
        &self.collector_id
    }
    pub fn clear_collector_id(&mut self) {
        self.collector_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_collector_id(&mut self, v: ::std::string::String) {
        self.collector_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collector_id(&mut self) -> &mut ::std::string::String {
        &mut self.collector_id
    }

    // Take field
    pub fn take_collector_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collector_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetCollectorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collector_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.collector_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collector_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.collector_id.is_empty() {
            os.write_string(2, &self.collector_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCollectorRequest {
        GetCollectorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &GetCollectorRequest| { &m.user_app_id },
                |m: &mut GetCollectorRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "collector_id",
                |m: &GetCollectorRequest| { &m.collector_id },
                |m: &mut GetCollectorRequest| { &mut m.collector_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCollectorRequest>(
                "GetCollectorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCollectorRequest {
        static instance: ::protobuf::rt::LazyV2<GetCollectorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCollectorRequest::new)
    }
}

impl ::protobuf::Clear for GetCollectorRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.collector_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCollectorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCollectorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCollectorsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCollectorsRequest {
    fn default() -> &'a ListCollectorsRequest {
        <ListCollectorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListCollectorsRequest {
    pub fn new() -> ListCollectorsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 3;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListCollectorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(3, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCollectorsRequest {
        ListCollectorsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListCollectorsRequest| { &m.user_app_id },
                |m: &mut ListCollectorsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListCollectorsRequest| { &m.page },
                |m: &mut ListCollectorsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListCollectorsRequest| { &m.per_page },
                |m: &mut ListCollectorsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCollectorsRequest>(
                "ListCollectorsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCollectorsRequest {
        static instance: ::protobuf::rt::LazyV2<ListCollectorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCollectorsRequest::new)
    }
}

impl ::protobuf::Clear for ListCollectorsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCollectorsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollectorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiCollectorResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub collectors: ::protobuf::RepeatedField<super::resources::Collector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiCollectorResponse {
    fn default() -> &'a MultiCollectorResponse {
        <MultiCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiCollectorResponse {
    pub fn new() -> MultiCollectorResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.Collector collectors = 2;


    pub fn get_collectors(&self) -> &[super::resources::Collector] {
        &self.collectors
    }
    pub fn clear_collectors(&mut self) {
        self.collectors.clear();
    }

    // Param is passed by value, moved
    pub fn set_collectors(&mut self, v: ::protobuf::RepeatedField<super::resources::Collector>) {
        self.collectors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collectors(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Collector> {
        &mut self.collectors
    }

    // Take field
    pub fn take_collectors(&mut self) -> ::protobuf::RepeatedField<super::resources::Collector> {
        ::std::mem::replace(&mut self.collectors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiCollectorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collectors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collectors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.collectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.collectors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiCollectorResponse {
        MultiCollectorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiCollectorResponse| { &m.status },
                |m: &mut MultiCollectorResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collector>>(
                "collectors",
                |m: &MultiCollectorResponse| { &m.collectors },
                |m: &mut MultiCollectorResponse| { &mut m.collectors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiCollectorResponse>(
                "MultiCollectorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiCollectorResponse {
        static instance: ::protobuf::rt::LazyV2<MultiCollectorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiCollectorResponse::new)
    }
}

impl ::protobuf::Clear for MultiCollectorResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.collectors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiCollectorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleCollectorResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub collector: ::protobuf::SingularPtrField<super::resources::Collector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleCollectorResponse {
    fn default() -> &'a SingleCollectorResponse {
        <SingleCollectorResponse as ::protobuf::Message>::default_instance()
    }
}

impl SingleCollectorResponse {
    pub fn new() -> SingleCollectorResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // .clarifai.api.Collector collector = 2;


    pub fn get_collector(&self) -> &super::resources::Collector {
        self.collector.as_ref().unwrap_or_else(|| <super::resources::Collector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_collector(&mut self) {
        self.collector.clear();
    }

    pub fn has_collector(&self) -> bool {
        self.collector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collector(&mut self, v: super::resources::Collector) {
        self.collector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collector(&mut self) -> &mut super::resources::Collector {
        if self.collector.is_none() {
            self.collector.set_default();
        }
        self.collector.as_mut().unwrap()
    }

    // Take field
    pub fn take_collector(&mut self) -> super::resources::Collector {
        self.collector.take().unwrap_or_else(|| super::resources::Collector::new())
    }
}

impl ::protobuf::Message for SingleCollectorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.collector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.collector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.collector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.collector.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleCollectorResponse {
        SingleCollectorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &SingleCollectorResponse| { &m.status },
                |m: &mut SingleCollectorResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Collector>>(
                "collector",
                |m: &SingleCollectorResponse| { &m.collector },
                |m: &mut SingleCollectorResponse| { &mut m.collector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleCollectorResponse>(
                "SingleCollectorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleCollectorResponse {
        static instance: ::protobuf::rt::LazyV2<SingleCollectorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleCollectorResponse::new)
    }
}

impl ::protobuf::Clear for SingleCollectorResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.collector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleCollectorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleCollectorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostStatValuesRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub stat_values: ::protobuf::RepeatedField<super::resources::StatValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostStatValuesRequest {
    fn default() -> &'a PostStatValuesRequest {
        <PostStatValuesRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesRequest {
    pub fn new() -> PostStatValuesRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.StatValue stat_values = 2;


    pub fn get_stat_values(&self) -> &[super::resources::StatValue] {
        &self.stat_values
    }
    pub fn clear_stat_values(&mut self) {
        self.stat_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_values(&mut self, v: ::protobuf::RepeatedField<super::resources::StatValue>) {
        self.stat_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_values(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::StatValue> {
        &mut self.stat_values
    }

    // Take field
    pub fn take_stat_values(&mut self) -> ::protobuf::RepeatedField<super::resources::StatValue> {
        ::std::mem::replace(&mut self.stat_values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostStatValuesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stat_values {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostStatValuesRequest {
        PostStatValuesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostStatValuesRequest| { &m.user_app_id },
                |m: &mut PostStatValuesRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::StatValue>>(
                "stat_values",
                |m: &PostStatValuesRequest| { &m.stat_values },
                |m: &mut PostStatValuesRequest| { &mut m.stat_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostStatValuesRequest>(
                "PostStatValuesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostStatValuesRequest {
        static instance: ::protobuf::rt::LazyV2<PostStatValuesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostStatValuesRequest::new)
    }
}

impl ::protobuf::Clear for PostStatValuesRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostStatValuesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiStatValueResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub stat_values: ::protobuf::RepeatedField<super::resources::StatValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiStatValueResponse {
    fn default() -> &'a MultiStatValueResponse {
        <MultiStatValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueResponse {
    pub fn new() -> MultiStatValueResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.StatValue stat_values = 2;


    pub fn get_stat_values(&self) -> &[super::resources::StatValue] {
        &self.stat_values
    }
    pub fn clear_stat_values(&mut self) {
        self.stat_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_values(&mut self, v: ::protobuf::RepeatedField<super::resources::StatValue>) {
        self.stat_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_values(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::StatValue> {
        &mut self.stat_values
    }

    // Take field
    pub fn take_stat_values(&mut self) -> ::protobuf::RepeatedField<super::resources::StatValue> {
        ::std::mem::replace(&mut self.stat_values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiStatValueResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stat_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stat_values {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiStatValueResponse {
        MultiStatValueResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiStatValueResponse| { &m.status },
                |m: &mut MultiStatValueResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::StatValue>>(
                "stat_values",
                |m: &MultiStatValueResponse| { &m.stat_values },
                |m: &mut MultiStatValueResponse| { &mut m.stat_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiStatValueResponse>(
                "MultiStatValueResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiStatValueResponse {
        static instance: ::protobuf::rt::LazyV2<MultiStatValueResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiStatValueResponse::new)
    }
}

impl ::protobuf::Clear for MultiStatValueResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.stat_values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiStatValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostStatValuesAggregateRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub stat_value_aggregate_queries: ::protobuf::RepeatedField<super::resources::StatValueAggregateQuery>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostStatValuesAggregateRequest {
    fn default() -> &'a PostStatValuesAggregateRequest {
        <PostStatValuesAggregateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostStatValuesAggregateRequest {
    pub fn new() -> PostStatValuesAggregateRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // repeated .clarifai.api.StatValueAggregateQuery stat_value_aggregate_queries = 2;


    pub fn get_stat_value_aggregate_queries(&self) -> &[super::resources::StatValueAggregateQuery] {
        &self.stat_value_aggregate_queries
    }
    pub fn clear_stat_value_aggregate_queries(&mut self) {
        self.stat_value_aggregate_queries.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_value_aggregate_queries(&mut self, v: ::protobuf::RepeatedField<super::resources::StatValueAggregateQuery>) {
        self.stat_value_aggregate_queries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_value_aggregate_queries(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::StatValueAggregateQuery> {
        &mut self.stat_value_aggregate_queries
    }

    // Take field
    pub fn take_stat_value_aggregate_queries(&mut self) -> ::protobuf::RepeatedField<super::resources::StatValueAggregateQuery> {
        ::std::mem::replace(&mut self.stat_value_aggregate_queries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PostStatValuesAggregateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_value_aggregate_queries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_value_aggregate_queries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stat_value_aggregate_queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stat_value_aggregate_queries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostStatValuesAggregateRequest {
        PostStatValuesAggregateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostStatValuesAggregateRequest| { &m.user_app_id },
                |m: &mut PostStatValuesAggregateRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::StatValueAggregateQuery>>(
                "stat_value_aggregate_queries",
                |m: &PostStatValuesAggregateRequest| { &m.stat_value_aggregate_queries },
                |m: &mut PostStatValuesAggregateRequest| { &mut m.stat_value_aggregate_queries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostStatValuesAggregateRequest>(
                "PostStatValuesAggregateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostStatValuesAggregateRequest {
        static instance: ::protobuf::rt::LazyV2<PostStatValuesAggregateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostStatValuesAggregateRequest::new)
    }
}

impl ::protobuf::Clear for PostStatValuesAggregateRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.stat_value_aggregate_queries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostStatValuesAggregateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostStatValuesAggregateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiStatValueAggregateResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub stat_value_aggregate_results: ::protobuf::RepeatedField<super::resources::StatValueAggregateResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiStatValueAggregateResponse {
    fn default() -> &'a MultiStatValueAggregateResponse {
        <MultiStatValueAggregateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiStatValueAggregateResponse {
    pub fn new() -> MultiStatValueAggregateResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.StatValueAggregateResult stat_value_aggregate_results = 2;


    pub fn get_stat_value_aggregate_results(&self) -> &[super::resources::StatValueAggregateResult] {
        &self.stat_value_aggregate_results
    }
    pub fn clear_stat_value_aggregate_results(&mut self) {
        self.stat_value_aggregate_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_value_aggregate_results(&mut self, v: ::protobuf::RepeatedField<super::resources::StatValueAggregateResult>) {
        self.stat_value_aggregate_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_value_aggregate_results(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::StatValueAggregateResult> {
        &mut self.stat_value_aggregate_results
    }

    // Take field
    pub fn take_stat_value_aggregate_results(&mut self) -> ::protobuf::RepeatedField<super::resources::StatValueAggregateResult> {
        ::std::mem::replace(&mut self.stat_value_aggregate_results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiStatValueAggregateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat_value_aggregate_results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_value_aggregate_results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.stat_value_aggregate_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.stat_value_aggregate_results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiStatValueAggregateResponse {
        MultiStatValueAggregateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiStatValueAggregateResponse| { &m.status },
                |m: &mut MultiStatValueAggregateResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::StatValueAggregateResult>>(
                "stat_value_aggregate_results",
                |m: &MultiStatValueAggregateResponse| { &m.stat_value_aggregate_results },
                |m: &mut MultiStatValueAggregateResponse| { &mut m.stat_value_aggregate_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiStatValueAggregateResponse>(
                "MultiStatValueAggregateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiStatValueAggregateResponse {
        static instance: ::protobuf::rt::LazyV2<MultiStatValueAggregateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiStatValueAggregateResponse::new)
    }
}

impl ::protobuf::Clear for MultiStatValueAggregateResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.stat_value_aggregate_results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiStatValueAggregateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiStatValueAggregateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostTrendingMetricsViewRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub view_type: ::std::string::String,
    pub object_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PostTrendingMetricsViewRequest {
    fn default() -> &'a PostTrendingMetricsViewRequest {
        <PostTrendingMetricsViewRequest as ::protobuf::Message>::default_instance()
    }
}

impl PostTrendingMetricsViewRequest {
    pub fn new() -> PostTrendingMetricsViewRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string view_type = 2;


    pub fn get_view_type(&self) -> &str {
        &self.view_type
    }
    pub fn clear_view_type(&mut self) {
        self.view_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_view_type(&mut self, v: ::std::string::String) {
        self.view_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_type(&mut self) -> &mut ::std::string::String {
        &mut self.view_type
    }

    // Take field
    pub fn take_view_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.view_type, ::std::string::String::new())
    }

    // string object_id = 3;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PostTrendingMetricsViewRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.view_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.view_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.view_type);
        }
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.view_type.is_empty() {
            os.write_string(2, &self.view_type)?;
        }
        if !self.object_id.is_empty() {
            os.write_string(3, &self.object_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostTrendingMetricsViewRequest {
        PostTrendingMetricsViewRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &PostTrendingMetricsViewRequest| { &m.user_app_id },
                |m: &mut PostTrendingMetricsViewRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "view_type",
                |m: &PostTrendingMetricsViewRequest| { &m.view_type },
                |m: &mut PostTrendingMetricsViewRequest| { &mut m.view_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &PostTrendingMetricsViewRequest| { &m.object_id },
                |m: &mut PostTrendingMetricsViewRequest| { &mut m.object_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PostTrendingMetricsViewRequest>(
                "PostTrendingMetricsViewRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PostTrendingMetricsViewRequest {
        static instance: ::protobuf::rt::LazyV2<PostTrendingMetricsViewRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PostTrendingMetricsViewRequest::new)
    }
}

impl ::protobuf::Clear for PostTrendingMetricsViewRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.view_type.clear();
        self.object_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostTrendingMetricsViewRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostTrendingMetricsViewRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTrendingMetricsViewsRequest {
    // message fields
    pub user_app_id: ::protobuf::SingularPtrField<super::resources::UserAppIDSet>,
    pub view_type: ::std::string::String,
    pub page: u32,
    pub per_page: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTrendingMetricsViewsRequest {
    fn default() -> &'a ListTrendingMetricsViewsRequest {
        <ListTrendingMetricsViewsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTrendingMetricsViewsRequest {
    pub fn new() -> ListTrendingMetricsViewsRequest {
        ::std::default::Default::default()
    }

    // .clarifai.api.UserAppIDSet user_app_id = 1;


    pub fn get_user_app_id(&self) -> &super::resources::UserAppIDSet {
        self.user_app_id.as_ref().unwrap_or_else(|| <super::resources::UserAppIDSet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user_app_id(&mut self) {
        self.user_app_id.clear();
    }

    pub fn has_user_app_id(&self) -> bool {
        self.user_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_id(&mut self, v: super::resources::UserAppIDSet) {
        self.user_app_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_app_id(&mut self) -> &mut super::resources::UserAppIDSet {
        if self.user_app_id.is_none() {
            self.user_app_id.set_default();
        }
        self.user_app_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_app_id(&mut self) -> super::resources::UserAppIDSet {
        self.user_app_id.take().unwrap_or_else(|| super::resources::UserAppIDSet::new())
    }

    // string view_type = 2;


    pub fn get_view_type(&self) -> &str {
        &self.view_type
    }
    pub fn clear_view_type(&mut self) {
        self.view_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_view_type(&mut self, v: ::std::string::String) {
        self.view_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_type(&mut self) -> &mut ::std::string::String {
        &mut self.view_type
    }

    // Take field
    pub fn take_view_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.view_type, ::std::string::String::new())
    }

    // uint32 page = 3;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 per_page = 4;


    pub fn get_per_page(&self) -> u32 {
        self.per_page
    }
    pub fn clear_per_page(&mut self) {
        self.per_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_per_page(&mut self, v: u32) {
        self.per_page = v;
    }
}

impl ::protobuf::Message for ListTrendingMetricsViewsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.user_app_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.view_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.per_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_app_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.view_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.view_type);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.per_page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.per_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_app_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.view_type.is_empty() {
            os.write_string(2, &self.view_type)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.per_page != 0 {
            os.write_uint32(4, self.per_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTrendingMetricsViewsRequest {
        ListTrendingMetricsViewsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::UserAppIDSet>>(
                "user_app_id",
                |m: &ListTrendingMetricsViewsRequest| { &m.user_app_id },
                |m: &mut ListTrendingMetricsViewsRequest| { &mut m.user_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "view_type",
                |m: &ListTrendingMetricsViewsRequest| { &m.view_type },
                |m: &mut ListTrendingMetricsViewsRequest| { &mut m.view_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &ListTrendingMetricsViewsRequest| { &m.page },
                |m: &mut ListTrendingMetricsViewsRequest| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "per_page",
                |m: &ListTrendingMetricsViewsRequest| { &m.per_page },
                |m: &mut ListTrendingMetricsViewsRequest| { &mut m.per_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTrendingMetricsViewsRequest>(
                "ListTrendingMetricsViewsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTrendingMetricsViewsRequest {
        static instance: ::protobuf::rt::LazyV2<ListTrendingMetricsViewsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTrendingMetricsViewsRequest::new)
    }
}

impl ::protobuf::Clear for ListTrendingMetricsViewsRequest {
    fn clear(&mut self) {
        self.user_app_id.clear();
        self.view_type.clear();
        self.page = 0;
        self.per_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTrendingMetricsViewsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTrendingMetricsViewsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiTrendingMetricsViewResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub metrics: ::protobuf::RepeatedField<super::resources::TrendingMetric>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiTrendingMetricsViewResponse {
    fn default() -> &'a MultiTrendingMetricsViewResponse {
        <MultiTrendingMetricsViewResponse as ::protobuf::Message>::default_instance()
    }
}

impl MultiTrendingMetricsViewResponse {
    pub fn new() -> MultiTrendingMetricsViewResponse {
        ::std::default::Default::default()
    }

    // .clarifai.api.status.Status status = 1;


    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| <super::status::Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    // repeated .clarifai.api.TrendingMetric metrics = 2;


    pub fn get_metrics(&self) -> &[super::resources::TrendingMetric] {
        &self.metrics
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: ::protobuf::RepeatedField<super::resources::TrendingMetric>) {
        self.metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::TrendingMetric> {
        &mut self.metrics
    }

    // Take field
    pub fn take_metrics(&mut self) -> ::protobuf::RepeatedField<super::resources::TrendingMetric> {
        ::std::mem::replace(&mut self.metrics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiTrendingMetricsViewResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metrics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiTrendingMetricsViewResponse {
        MultiTrendingMetricsViewResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                "status",
                |m: &MultiTrendingMetricsViewResponse| { &m.status },
                |m: &mut MultiTrendingMetricsViewResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::TrendingMetric>>(
                "metrics",
                |m: &MultiTrendingMetricsViewResponse| { &m.metrics },
                |m: &mut MultiTrendingMetricsViewResponse| { &mut m.metrics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MultiTrendingMetricsViewResponse>(
                "MultiTrendingMetricsViewResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MultiTrendingMetricsViewResponse {
        static instance: ::protobuf::rt::LazyV2<MultiTrendingMetricsViewResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MultiTrendingMetricsViewResponse::new)
    }
}

impl ::protobuf::Clear for MultiTrendingMetricsViewResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.metrics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiTrendingMetricsViewResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiTrendingMetricsViewResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrganizationInvitationStatus {
    NOT_SET = 0,
    PENDING = 1,
    ACCEPTED = 2,
    CANCELLED = 3,
    DECLINED = 4,
    EXPIRED = 5,
}

impl ::protobuf::ProtobufEnum for OrganizationInvitationStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrganizationInvitationStatus> {
        match value {
            0 => ::std::option::Option::Some(OrganizationInvitationStatus::NOT_SET),
            1 => ::std::option::Option::Some(OrganizationInvitationStatus::PENDING),
            2 => ::std::option::Option::Some(OrganizationInvitationStatus::ACCEPTED),
            3 => ::std::option::Option::Some(OrganizationInvitationStatus::CANCELLED),
            4 => ::std::option::Option::Some(OrganizationInvitationStatus::DECLINED),
            5 => ::std::option::Option::Some(OrganizationInvitationStatus::EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrganizationInvitationStatus] = &[
            OrganizationInvitationStatus::NOT_SET,
            OrganizationInvitationStatus::PENDING,
            OrganizationInvitationStatus::ACCEPTED,
            OrganizationInvitationStatus::CANCELLED,
            OrganizationInvitationStatus::DECLINED,
            OrganizationInvitationStatus::EXPIRED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OrganizationInvitationStatus>("OrganizationInvitationStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OrganizationInvitationStatus {
}

impl ::std::default::Default for OrganizationInvitationStatus {
    fn default() -> Self {
        OrganizationInvitationStatus::NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for OrganizationInvitationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20proto/clarifai/api/service.proto\x12\x0cclarifai.api\x1a\"proto/cl\
    arifai/api/resources.proto\x1a&proto/clarifai/api/status/status.proto\
    \x1a)proto/clarifai/api/utils/extensions.proto\x1a%proto/clarifai/auth/s\
    cope/scope.proto\x1a(proto/clarifai/auth/util/extension.proto\x1a+proto/\
    clarifai/api/status/status_code.proto\x1a\x1cgoogle/api/annotations.prot\
    o\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/protobuf/struct.pr\
    oto\x1a\x1fgoogle/protobuf/timestamp.proto\";\n\nPagination\x12\x12\n\
    \x04page\x18\x01\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x02\x20\
    \x01(\rR\x07perPage\"\x92\x01\n\x14GetAnnotationRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12#\n\rannotation_id\x18\x02\x20\x01(\tR\x0cannotationId\x12\x19\n\x08\
    input_id\x18\x03\x20\x01(\tR\x07inputId\"\xb3\x03\n\x16ListAnnotationsRe\
    quest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserA\
    ppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\x1b\
    \n\tinput_ids\x18\x03\x20\x03(\tR\x08inputIds\x12\x19\n\x08user_ids\x18\
    \t\x20\x03(\tR\x07userIds\x12*\n\x11model_version_ids\x18\n\x20\x03(\tR\
    \x0fmodelVersionIds\x127\n\x08statuses\x18\x05\x20\x03(\x0b2\x1b.clarifa\
    i.api.status.StatusR\x08statuses\x120\n\x14list_all_annotations\x18\x06\
    \x20\x01(\x08R\x12listAllAnnotations\x12.\n\x13return_model_output\x18\
    \x0c\x20\x01(\x08R\x11returnModelOutput\x12\x12\n\x04page\x18\x07\x20\
    \x01(\rR\x04page\x12\x19\n\x08per_page\x18\x08\x20\x01(\rR\x07perPage\
    \x12\x17\n\x07task_id\x18\x0b\x20\x01(\tR\x06taskIdJ\x04\x08\x04\x10\x05\
    \"\x90\x01\n\x16PostAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotatio\
    ns\x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\"\
    \xa9\x01\n\x17PatchAnnotationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12:\n\x0bannotatio\
    ns\x18\x02\x20\x03(\x0b2\x18.clarifai.api.AnnotationR\x0bannotations\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\xe9\x01\n\x1dPatchAnnot\
    ationsStatusRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12@\n\x0bstatus_code\x18\x02\x20\x01(\
    \x0e2\x1f.clarifai.api.status.StatusCodeR\nstatusCode\x12\x19\n\x08user_\
    ids\x18\x03\x20\x03(\tR\x07userIds\x12\x17\n\x07task_id\x18\x04\x20\x01(\
    \tR\x06taskId\x12\x16\n\x06action\x18\x05\x20\x01(\tR\x06action\"\x95\
    \x01\n\x1ePatchAnnotationsStatusResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x19\n\x08user_i\
    ds\x18\x02\x20\x03(\tR\x07userIds\x12#\n\rupdated_count\x18\x03\x20\x01(\
    \rR\x0cupdatedCount\"\x95\x01\n\x17DeleteAnnotationRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\x12#\n\rannotation\
    _id\x18\x03\x20\x01(\tR\x0cannotationId\"\x85\x01\n\x18DeleteAnnotations\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\x12\
    \x1b\n\tinput_ids\x18\x03\x20\x03(\tR\x08inputIds\"\x89\x01\n\x18SingleA\
    nnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x128\n\nannotation\x18\x02\x20\x01(\x0b2\x18.\
    clarifai.api.AnnotationR\nannotation\"\x90\x01\n\x17MultiAnnotationRespo\
    nse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Statu\
    sR\x06status\x12@\n\x0bannotations\x18\x02\x20\x03(\x0b2\x18.clarifai.ap\
    i.AnnotationR\x0bannotationsB\x04\x80\xb5\x18\x01\"x\n\rGetAppRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12+\n\x11additional_fields\x18\x02\x20\x03(\tR\x10additi\
    onalFields\"\xa6\x03\n\x0fListAppsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04pa\
    ge\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\
    \x07perPage\x12%\n\x0esort_ascending\x18\x05\x20\x01(\x08R\rsortAscendin\
    g\x12\"\n\x0csort_by_name\x18\x06\x20\x01(\x08H\0R\nsortByName\x12/\n\
    \x13sort_by_modified_at\x18\x07\x20\x01(\x08H\0R\x10sortByModifiedAt\x12\
    \x14\n\x05query\x18\x08\x20\x01(\tR\x05query\x12\x16\n\x04name\x18\x04\
    \x20\x01(\tR\x04nameB\x02\x18\x01\x12#\n\rfeatured_only\x18\t\x20\x01(\
    \x08R\x0cfeaturedOnly\x12!\n\x0cstarred_only\x18\x0b\x20\x01(\x08R\x0bst\
    arredOnly\x12+\n\x11additional_fields\x18\n\x20\x03(\tR\x10additionalFie\
    ldsB\t\n\x07sort_by\"t\n\x0fPostAppsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04a\
    pps\x18\x02\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\"N\n\x10DeleteAp\
    pRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\"\xeb\x01\n\x10PatchAppsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    %\n\x04apps\x18\x02\x20\x03(\x0b2\x11.clarifai.api.AppR\x04apps\x12\x16\
    \n\x06action\x18\x03\x20\x01(\tR\x06action\x12B\n\x0fmetadata_action\x18\
    \x04\x20\x01(\x0b2\x19.clarifai.api.PatchActionR\x0emetadataAction\x12\
    \x18\n\x07reindex\x18\x05\x20\x01(\x08R\x07reindex\"\xc4\x01\n\x17PostAp\
    psSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarif\
    ai.api.UserAppIDSetR\tuserAppId\x123\n\tapp_query\x18\x02\x20\x01(\x0b2\
    \x16.clarifai.api.AppQueryR\x08appQuery\x128\n\npagination\x18\x03\x20\
    \x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"m\n\x11SingleAppRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12#\n\x03app\x18\x02\x20\x01(\x0b2\x11.clarifai.api.AppR\
    \x03app\"t\n\x10MultiAppResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\
    \x1b.clarifai.api.status.StatusR\x06status\x12+\n\x04apps\x18\x02\x20\
    \x03(\x0b2\x11.clarifai.api.AppR\x04appsB\x04\x80\xb5\x18\x01\"\x8c\x01\
    \n\x18ListCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x124\n\x16list_all_colla\
    borators\x18\x02\x20\x01(\x08R\x14listAllCollaborators\"\x98\x01\n\x18Po\
    stCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.c\
    larifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollaborators\x18\x02\x20\
    \x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborators\"\xb1\x01\n\x19\
    PatchCollaboratorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12@\n\rcollaborators\x18\x02\
    \x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborators\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"\xa4\x01\n\x1aDeleteCollaborat\
    orsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12)\n\x10collaborator_ids\x18\x02\x20\x03(\tR\
    \x0fcollaboratorIds\x12\x1f\n\x0buser_emails\x18\x03\x20\x03(\tR\nuserEm\
    ails\"\x99\x01\n\x1aMultiCollaboratorsResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12F\n\rcollabo\
    rators\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.CollaboratorR\rcollaborato\
    rsB\x04\x80\xb5\x18\x01\"\x86\x01\n\x19ListCollaborationsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_p\
    age\x18\x03\x20\x01(\rR\x07perPage\"\x9d\x01\n\x1bMultiCollaborationsRes\
    ponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Sta\
    tusR\x06status\x12I\n\x0ecollaborations\x18\x02\x20\x03(\x0b2\x1b.clarif\
    ai.api.CollaborationR\x0ecollaborationsB\x04\x80\xb5\x18\x01\"<\n\x14Get\
    StatusCodeRequest\x12$\n\x0estatus_code_id\x18\x01\x20\x01(\tR\x0cstatus\
    CodeId\"\x18\n\x16ListStatusCodesRequest\"O\n\x18SingleStatusCodeRespons\
    e\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\"\x87\x01\n\x17MultiStatusCodeResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\n\x08s\
    tatuses\x18\x02\x20\x03(\x0b2\x1b.clarifai.api.status.StatusR\x08statuse\
    s\"n\n\x11GetConceptRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\
    \x20\x01(\tR\tconceptId\"\x80\x01\n\x13ListConceptsRequest\x12:\n\x0buse\
    r_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x03\x20\x01(\rR\x07perPage\"\xd4\x01\n\x1bPostConceptsSearchesRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12?\n\rconcept_query\x18\x02\x20\x01(\x0b2\x1a.clarifai.\
    api.ConceptQueryR\x0cconceptQuery\x128\n\npagination\x18\x03\x20\x01(\
    \x0b2\x18.clarifai.api.PaginationR\npagination\"\x84\x01\n\x13PostConcep\
    tsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x121\n\x08concepts\x18\x02\x20\x03(\x0b2\x15.cla\
    rifai.api.ConceptR\x08concepts\"\x9d\x01\n\x14PatchConceptsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x121\n\x08concepts\x18\x02\x20\x03(\x0b2\x15.clarifai.api.Conc\
    eptR\x08concepts\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x84\
    \x01\n\x17GetConceptCountsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\"}\n\x15SingleConceptResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12/\n\x07concept\x18\
    \x02\x20\x01(\x0b2\x15.clarifai.api.ConceptR\x07concept\"\x84\x01\n\x14M\
    ultiConceptResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x127\n\x08concepts\x18\x02\x20\x03(\x0b2\
    \x15.clarifai.api.ConceptR\x08conceptsB\x04\x80\xb5\x18\x01\"\x99\x01\n\
    \x19MultiConceptCountResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b\
    .clarifai.api.status.StatusR\x06status\x12G\n\x0econcept_counts\x18\x02\
    \x20\x03(\x0b2\x1a.clarifai.api.ConceptCountR\rconceptCountsB\x04\x80\
    \xb5\x18\x01\"\xf3\x01\n\x1bListConceptRelationsRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x1c\n\tpredica\
    te\x18\x03\x20\x01(\tR\tpredicate\x12,\n\x12knowledge_graph_id\x18\x04\
    \x20\x01(\tR\x10knowledgeGraphId\x12\x12\n\x04page\x18\x05\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x06\x20\x01(\rR\x07perPage\"\xc4\x01\
    \n\x1bPostConceptRelationsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\
    \x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_relations\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.ConceptRelationR\x10conceptRelations\"\x8c\
    \x01\n\x1dDeleteConceptRelationsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconc\
    ept_id\x18\x02\x20\x01(\tR\tconceptId\x12\x10\n\x03ids\x18\x03\x20\x03(\
    \tR\x03ids\"X\n\x1aListKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\xa1\x01\n\
    \x1aPostKnowledgeGraphsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12G\n\x10knowledge_grap\
    hs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fknowledgeGr\
    aphs\"\xae\x01\n\x1dPostConceptMappingJobsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12Q\n\
    \x14concept_mapping_jobs\x18\x02\x20\x03(\x0b2\x1f.clarifai.api.ConceptM\
    appingJobR\x12conceptMappingJobs\"\xa5\x01\n\x1cMultiConceptRelationResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x12P\n\x11concept_relations\x18\x02\x20\x03(\x0b2\x1d.clar\
    ifai.api.ConceptRelationR\x10conceptRelationsB\x04\x80\xb5\x18\x01\"\xa1\
    \x01\n\x1bMultiKnowledgeGraphResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12M\n\x10knowledge_grap\
    hs\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.KnowledgeGraphR\x0fknowledgeGr\
    aphsB\x04\x80\xb5\x18\x01\"g\n\x1eMultiConceptMappingJobResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"\x92\x01\n\x19GetConcept\
    LanguageRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\
    \tconceptId\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\x08language\"\xa7\
    \x01\n\x1bListConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_\
    id\x18\x02\x20\x01(\tR\tconceptId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\x07perPage\"\xdd\x01\
    \n\x1cPatchConceptLanguagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01\
    (\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\
    \x18\x02\x20\x01(\tR\tconceptId\x12J\n\x11concept_languages\x18\x03\x20\
    \x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguages\x12\x16\
    \n\x06action\x18\x04\x20\x01(\tR\x06action\"\xc4\x01\n\x1bPostConceptLan\
    guagesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x1d\n\nconcept_id\x18\x02\x20\x01(\tR\tc\
    onceptId\x12J\n\x11concept_languages\x18\x03\x20\x03(\x0b2\x1d.clarifai.\
    api.ConceptLanguageR\x10conceptLanguages\"\x9e\x01\n\x1dSingleConceptLan\
    guageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.st\
    atus.StatusR\x06status\x12H\n\x10concept_language\x18\x02\x20\x01(\x0b2\
    \x1d.clarifai.api.ConceptLanguageR\x0fconceptLanguage\"\xa5\x01\n\x1cMul\
    tiConceptLanguageResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.cla\
    rifai.api.status.StatusR\x06status\x12P\n\x11concept_languages\x18\x02\
    \x20\x03(\x0b2\x1d.clarifai.api.ConceptLanguageR\x10conceptLanguagesB\
    \x04\x80\xb5\x18\x01\"h\n\x0fGetInputRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\
    \x08input_id\x18\x02\x20\x01(\tR\x07inputId\"\x88\x01\n\x16GetInputSampl\
    esRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06task\
    Id\x12\x19\n\x08user_ids\x18\x03\x20\x03(\tR\x07userIds\"\xc5\x01\n\x11L\
    istInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04\
    page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x123\n\x06stat\
    us\x18\x05\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\
    \x10\n\x03ids\x18\x04\x20\x03(\tR\x03ids\"\xa5\x01\n\x13StreamInputsRequ\
    est\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserApp\
    IDSetR\tuserAppId\x12\x19\n\x08per_page\x18\x02\x20\x01(\rR\x07perPage\
    \x12\x17\n\x07last_id\x18\x03\x20\x01(\tR\x06lastId\x12\x1e\n\ndescendin\
    g\x18\x04\x20\x01(\x08R\ndescending\"|\n\x11PostInputsRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12+\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\x06in\
    puts\"\x95\x01\n\x12PatchInputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\x06inputs\
    \x18\x02\x20\x03(\x0b2\x13.clarifai.api.InputR\x06inputs\x12\x16\n\x06ac\
    tion\x18\x03\x20\x01(\tR\x06action\"k\n\x12DeleteInputRequest\x12:\n\x0b\
    user_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAp\
    pId\x12\x19\n\x08input_id\x18\x02\x20\x01(\tR\x07inputId\"i\n\x13DeleteI\
    nputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03idsJ\
    \x04\x08\x03\x10\x04\"u\n\x13SingleInputResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12)\n\x05i\
    nput\x18\x02\x20\x01(\x0b2\x13.clarifai.api.InputR\x05input\"|\n\x12Mult\
    iInputResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.s\
    tatus.StatusR\x06status\x121\n\x06inputs\x18\x02\x20\x03(\x0b2\x13.clari\
    fai.api.InputR\x06inputsB\x04\x80\xb5\x18\x01\"\x80\x01\n\x1cMultiInputA\
    nnotationResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.ap\
    i.status.StatusR\x06status\x12+\n\x04hits\x18\x03\x20\x03(\x0b2\x11.clar\
    ifai.api.HitR\x04hitsB\x04\x80\xb5\x18\x01\"\x81\x01\n\x18SingleInputCou\
    ntResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.statu\
    s.StatusR\x06status\x120\n\x06counts\x18\x02\x20\x01(\x0b2\x18.clarifai.\
    api.InputCountR\x06counts\"R\n\x14GetInputCountRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\
    \xe7\x01\n\x17PostModelOutputsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_\
    id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\
    \tR\tversionId\x12+\n\x06inputs\x18\x04\x20\x03(\x0b2\x13.clarifai.api.I\
    nputR\x06inputs\x12)\n\x05model\x18\x05\x20\x01(\x0b2\x13.clarifai.api.M\
    odelR\x05model\"\xbd\x01\n\x16ListModelInputsRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\
    \x18\x03\x20\x01(\tR\tversionId\x12\x12\n\x04page\x18\x04\x20\x01(\rR\
    \x04page\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPage\"b\n\rGetK\
    eyRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x15\n\x06key_id\x18\x02\x20\x01(\tR\x05keyId\
    \"|\n\x0fListKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01\
    (\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\x7f\
    \n\x12ListAppKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a\
    .clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01\
    (\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"t\n\
    \x0fPostKeysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12%\n\x04keys\x18\x02\x20\x03(\x0b2\
    \x11.clarifai.api.KeyR\x04keys\"e\n\x10DeleteKeyRequest\x12:\n\x0buser_a\
    pp_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x15\n\x06key_id\x18\x02\x20\x01(\tR\x05keyId\"\x8d\x01\n\x10PatchKe\
    ysRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12%\n\x04keys\x18\x02\x20\x03(\x0b2\x11.clarifa\
    i.api.KeyR\x04keys\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"m\
    \n\x11SingleKeyResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clari\
    fai.api.status.StatusR\x06status\x12#\n\x03key\x18\x02\x20\x01(\x0b2\x11\
    .clarifai.api.KeyR\x03key\"t\n\x10MultiKeyResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12+\n\x04k\
    eys\x18\x02\x20\x03(\x0b2\x11.clarifai.api.KeyR\x04keysB\x04\x80\xb5\x18\
    \x01\"\xf7\x01\n\x0fGetModelRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_\
    id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\
    \tR\tversionId\x12\x1a\n\x08language\x18\x04\x20\x01(\tR\x08language\x12\
    %\n\x0etrained_before\x18\x05\x20\x01(\x08R\rtrainedBefore\x12+\n\x11add\
    itional_fields\x18\x13\x20\x03(\tR\x10additionalFields\"\xdd\x05\n\x11Li\
    stModelsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04p\
    age\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\x12%\n\x0esort_\
    ascending\x18\n\x20\x01(\x08R\rsortAscending\x12\"\n\x0csort_by_name\x18\
    \x0b\x20\x01(\x08H\0R\nsortByName\x12-\n\x12sort_by_num_inputs\x18\x0c\
    \x20\x01(\x08H\0R\x0fsortByNumInputs\x12/\n\x13sort_by_modified_at\x18\r\
    \x20\x01(\x08H\0R\x10sortByModifiedAt\x12\x14\n\x05query\x18\x0e\x20\x01\
    (\tR\x05query\x12\x16\n\x04name\x18\x05\x20\x01(\tR\x04nameB\x02\x18\x01\
    \x12\"\n\rmodel_type_id\x18\x06\x20\x01(\tR\x0bmodelTypeId\x12!\n\x0ctra\
    ined_only\x18\x07\x20\x01(\x08R\x0btrainedOnly\x12!\n\x0cinput_fields\
    \x18\x08\x20\x03(\tR\x0binputFields\x12#\n\routput_fields\x18\t\x20\x03(\
    \tR\x0coutputFields\x12\x18\n\x07license\x18\x0f\x20\x01(\tR\x07license\
    \x12#\n\rfeatured_only\x18\x10\x20\x01(\x08R\x0cfeaturedOnly\x12!\n\x0cs\
    tarred_only\x18\x14\x20\x01(\x08R\x0bstarredOnly\x12\x1a\n\x08toolkits\
    \x18\x11\x20\x03(\tR\x08toolkits\x12\x1b\n\tuse_cases\x18\x12\x20\x03(\t\
    R\x08useCases\x12\x1c\n\tlanguages\x18\x15\x20\x03(\tR\tlanguages\x12+\n\
    \x11additional_fields\x18\x13\x20\x03(\tR\x10additionalFieldsB\t\n\x07so\
    rt_byJ\x04\x08\x04\x10\x05\"\xa6\x01\n\x19PatchModelToolkitsRequest\x12:\
    \n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\t\
    userAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1a\n\
    \x08toolkits\x18\x03\x20\x03(\tR\x08toolkits\x12\x16\n\x06action\x18\x04\
    \x20\x01(\tR\x06action\"\xa6\x01\n\x19PatchModelUseCasesRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1a\n\
    \x08usecases\x18\x03\x20\x03(\tR\x08usecases\x12\x16\n\x06action\x18\x04\
    \x20\x01(\tR\x06action\"\xa9\x01\n\x1aPatchModelLanguagesRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1c\n\t\
    languages\x18\x03\x20\x03(\tR\tlanguages\x12\x16\n\x06action\x18\x04\x20\
    \x01(\tR\x06action\"l\n\x19MultiModelToolkitResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1a\
    \n\x08toolkits\x18\x02\x20\x03(\tR\x08toolkits\"l\n\x19MultiModelUseCase\
    Response\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.\
    StatusR\x06status\x12\x1a\n\x08usecases\x18\x02\x20\x03(\tR\x08usecases\
    \"o\n\x1aMultiModelLanguageResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x1c\n\tlanguages\x18\
    \x02\x20\x03(\tR\tlanguages\"\xab\x01\n\x11PostModelsRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12-\n\x05model\x18\x02\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05mode\
    lB\x02\x18\x01\x12+\n\x06models\x18\x03\x20\x03(\x0b2\x13.clarifai.api.M\
    odelR\x06models\"\x95\x01\n\x12PatchModelsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12+\n\
    \x06models\x18\x02\x20\x03(\x0b2\x13.clarifai.api.ModelR\x06models\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"7\n\x0eIdUpdateSource\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x15\n\x06new_id\x18\x02\
    \x20\x01(\tR\x05newId\"\x9a\x01\n\x14PatchModelIdsRequest\x12:\n\x0buser\
    _app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12.\n\x03ids\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.IdUpdateSourceR\
    \x03ids\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06action\"k\n\x12Delete\
    ModelRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07\
    modelId\"\x82\x01\n\x13DeleteModelsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03id\
    s\x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\
    \tdeleteAll\"\xcc\x01\n\x19PostModelsSearchesRequest\x12:\n\x0buser_app_\
    id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x129\
    \n\x0bmodel_query\x18\x02\x20\x01(\x0b2\x18.clarifai.api.ModelQueryR\nmo\
    delQuery\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.Pagin\
    ationR\npagination\"u\n\x13SingleModelResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12)\n\x05model\
    \x18\x02\x20\x01(\x0b2\x13.clarifai.api.ModelR\x05model\"|\n\x12MultiMod\
    elResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.statu\
    s.StatusR\x06status\x121\n\x06models\x18\x02\x20\x03(\x0b2\x13.clarifai.\
    api.ModelR\x06modelsB\x04\x80\xb5\x18\x01\"\xcd\x01\n\x19PatchModelVersi\
    onsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07mo\
    delId\x12A\n\x0emodel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.Mo\
    delVersionR\rmodelVersions\x12\x16\n\x06action\x18\x04\x20\x01(\tR\x06ac\
    tion\"\x8e\x01\n\x16GetModelVersionRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08mo\
    del_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\
    \x01(\tR\tversionId\"\xc1\x01\n\x18ListModelVersionsRequest\x12:\n\x0bus\
    er_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppI\
    d\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x12\n\x04page\
    \x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\x01(\rR\
    \x07perPage\x12\x1f\n\x0bconcept_ids\x18\x05\x20\x03(\tR\nconceptIds\"\
    \x91\x01\n\x19DeleteModelVersionRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08mo\
    del_id\x18\x03\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x04\x20\
    \x01(\tR\tversionId\"\x92\x01\n\x1aSingleModelVersionResponse\x123\n\x06\
    status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12?\n\rmodel_version\x18\x02\x20\x01(\x0b2\x1a.clarifai.api.ModelVersi\
    onR\x0cmodelVersion\"\x99\x01\n\x19MultiModelVersionResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12G\n\x0emodel_versions\x18\x02\x20\x03(\x0b2\x1a.clarifai.api.ModelVe\
    rsionR\rmodelVersionsB\x04\x80\xb5\x18\x01\"\xf7\x03\n\x18PostModelVersi\
    onsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.\
    UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07mo\
    delId\x12A\n\x0emodel_versions\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.Mo\
    delVersionR\rmodelVersions\x120\n\x06search\x18\x04\x20\x01(\x0b2\x14.cl\
    arifai.api.SearchR\x06searchB\x02\x18\x01\x127\n\x0ctrain_search\x18\x05\
    \x20\x01(\x0b2\x14.clarifai.api.SearchR\x0btrainSearch\x125\n\x0btest_se\
    arch\x18\x06\x20\x01(\x0b2\x14.clarifai.api.SearchR\ntestSearch\x126\n\
    \x17evaluate_after_training\x18\x07\x20\x01(\x08R\x15evaluateAfterTraini\
    ng\x12\x20\n\x0bdescription\x18\x08\x20\x01(\tR\x0bdescription\x12E\n\
    \x0fdataset_version\x18\t\x20\x01(\x0b2\x1c.clarifai.api.DatasetVersionR\
    \x0edatasetVersion\";\n\x1aModelVersionPublishRequest\x12\x1d\n\nversion\
    _id\x18\x01\x20\x01(\tR\tversionId\"\xc6\x01\n\x1fPostModelVersionsPubli\
    shRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.U\
    serAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07mod\
    elId\x12L\n\x0cpublications\x18\x03\x20\x03(\x0b2(.clarifai.api.ModelVer\
    sionPublishRequestR\x0cpublications\"=\n\x1cModelVersionUnpublishRequest\
    \x12\x1d\n\nversion_id\x18\x01\x20\x01(\tR\tversionId\"\xca\x01\n!PostMo\
    delVersionsUnPublishRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\x18\x02\
    \x20\x01(\tR\x07modelId\x12N\n\x0cpublications\x18\x03\x20\x03(\x0b2*.cl\
    arifai.api.ModelVersionUnpublishRequestR\x0cpublications\"\xf0\x01\n\x1e\
    PostModelVersionMetricsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\
    \x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\x18\x03\x20\x01(\t\
    R\tversionId\x12!\n\x0cmax_examples\x18\x04\x20\x01(\rR\x0bmaxExamples\
    \x125\n\x0btest_search\x18\x05\x20\x01(\x0b2\x14.clarifai.api.SearchR\nt\
    estSearch\"\xc8\x01\n\x1dGetModelVersionMetricsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x1d\n\nversion_id\
    \x18\x03\x20\x01(\tR\tversionId\x121\n\x06fields\x18\x04\x20\x01(\x0b2\
    \x19.clarifai.api.FieldsValueR\x06fields\"u\n\x13GetModelTypeRequest\x12\
    :\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\
    \tuserAppId\x12\"\n\rmodel_type_id\x18\x02\x20\x01(\tR\x0bmodelTypeId\"\
    \x82\x01\n\x15ListModelTypesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\
    \x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\
    \x07perPage\"\x1f\n\x1dListOpenSourceLicensesRequest\"q\n\x1eListOpenSou\
    rceLicensesResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.\
    api.status.StatusR\x06status\x12\x1a\n\x08licenses\x18\x02\x20\x03(\tR\
    \x08licenses\"\x8c\x01\n\x17SingleModelTypeResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12<\n\nmod\
    el_type\x18\x02\x20\x01(\x0b2\x17.clarifai.api.ModelTypeR\tmodelTypeB\
    \x04\x80\xb5\x18\x01\"\xd4\x01\n\x16MultiModelTypeResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12>\
    \n\x0bmodel_types\x18\x02\x20\x03(\x0b2\x17.clarifai.api.ModelTypeR\nmod\
    elTypesB\x04\x80\xb5\x18\x01\x12E\n\x0fmodel_importers\x18\x03\x20\x01(\
    \x0b2\x1c.clarifai.api.ModelTypeFieldR\x0emodelImporters\"\xc4\x01\n\"Ge\
    tModelVersionInputExampleRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x19\n\x08model_id\
    \x18\x02\x20\x01(\tR\x07modelId\x12(\n\x10model_version_id\x18\x03\x20\
    \x01(\tR\x0emodelVersionId\x12\x1d\n\nexample_id\x18\x04\x20\x01(\tR\tex\
    ampleId\"\xd6\x01\n$ListModelVersionInputExamplesRequest\x12:\n\x0buser_\
    app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12(\n\x10model_ve\
    rsion_id\x18\x03\x20\x01(\tR\x0emodelVersionId\x12\x12\n\x04page\x18\x04\
    \x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x05\x20\x01(\rR\x07perPag\
    e\"\xc4\x01\n&SingleModelVersionInputExampleResponse\x123\n\x06status\
    \x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12e\n\
    \x1bmodel_version_input_example\x18\x02\x20\x01(\x0b2&.clarifai.api.Mode\
    lVersionInputExampleR\x18modelVersionInputExample\"\xc5\x01\n%MultiModel\
    VersionInputExampleResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.c\
    larifai.api.status.StatusR\x06status\x12g\n\x1cmodel_version_input_examp\
    les\x18\x02\x20\x03(\x0b2&.clarifai.api.ModelVersionInputExampleR\x19mod\
    elVersionInputExamples\"\xa2\x01\n\x1aListModelReferencesRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x19\n\x08model_id\x18\x02\x20\x01(\tR\x07modelId\x12\x12\n\
    \x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x04\x20\
    \x01(\rR\x07perPage\"\x9b\x01\n\x1bMultiModelReferenceResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12G\n\x10model_references\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.Mod\
    elReferenceR\x0fmodelReferences\"\x80\x01\n\x13MultiOutputResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x124\n\x07outputs\x18\x02\x20\x03(\x0b2\x14.clarifai.api.OutputR\
    \x07outputsB\x04\x80\xb5\x18\x01\"j\n\x11ListScopesRequest\x12\x19\n\x08\
    key_type\x18\x01\x20\x01(\tR\x07keyType\x12:\n\x0buser_app_id\x18\x02\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"M\n\x0fMyScope\
    sRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Us\
    erAppIDSetR\tuserAppId\"Q\n\x13MyScopesUserRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\"\x15\n\
    \x13MyScopesRootRequest\"\xc6\x01\n\x16MultiScopeDepsResponse\x123\n\x06\
    status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x126\n\nscope_deps\x18\x02\x20\x03(\x0b2\x17.clarifai.api.ScopeDepsR\ts\
    copeDeps\x12?\n\rendpoint_deps\x18\x03\x20\x03(\x0b2\x1a.clarifai.api.En\
    dpointDepsR\x0cendpointDeps\"\xa4\x01\n\x12MultiScopeResponse\x123\n\x06\
    status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12\x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12#\n\x03app\x18\x03\
    \x20\x01(\x0b2\x11.clarifai.api.AppR\x03app\x12\x1c\n\tendpoints\x18\x04\
    \x20\x03(\tR\tendpoints\"\x83\x01\n\x16MultiScopeUserResponse\x123\n\x06\
    status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x12\x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12\x1c\n\tendpoints\
    \x18\x04\x20\x03(\tR\tendpoints\"\x83\x01\n\x16MultiScopeRootResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12\x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12\x1c\n\t\
    endpoints\x18\x04\x20\x03(\tR\tendpoints\"^\n\x10GetSearchRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\x80\x01\n\x13ListSea\
    rchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.ap\
    i.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\
    \x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07perPage\"\xec\x01\n\x13Pos\
    tSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12-\n\x05query\x18\x02\x20\x01(\x0b2\x13\
    .clarifai.api.QueryR\x05queryB\x02\x18\x01\x120\n\x08searches\x18\x03\
    \x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x128\n\npagination\
    \x18\x04\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"\xa2\
    \x01\n\x1aPatchInputsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\n\x08searches\
    \x18\x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"\xa7\x01\n\x1fPatchAnnotations\
    SearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai\
    .api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\
    \x14.clarifai.api.SearchR\x08searches\x12\x16\n\x06action\x18\x03\x20\
    \x01(\tR\x06action\"\x9c\x01\n\x14PatchSearchesRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    0\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08search\
    es\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x9f\x01\n\x17Post\
    SearchesByIDRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clar\
    ifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\
    \x02id\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.clarifai.api.Paginat\
    ionR\npagination\"a\n\x13DeleteSearchRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x0e\n\
    \x02id\x18\x02\x20\x01(\tR\x02id\"\xc8\x01\n\x1ePostAnnotationsSearchesR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x120\n\x08searches\x18\x02\x20\x03(\x0b2\x14.clarif\
    ai.api.SearchR\x08searches\x128\n\npagination\x18\x03\x20\x01(\x0b2\x18.\
    clarifai.api.PaginationR\npagination\"r\n$DeleteAnnotationSearchMetricsR\
    equest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.User\
    AppIDSetR\tuserAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\xc3\x01\
    \n\x19PostInputsSearchesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x120\n\x08searches\x18\
    \x02\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08searches\x128\n\npaginati\
    on\x18\x03\x20\x01(\x0b2\x18.clarifai.api.PaginationR\npagination\"y\n\
    \x14SingleSearchResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clar\
    ifai.api.status.StatusR\x06status\x12,\n\x06search\x18\x05\x20\x01(\x0b2\
    \x14.clarifai.api.SearchR\x06search\"\xe4\x01\n\x13MultiSearchResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12+\n\x04hits\x18\
    \x03\x20\x03(\x0b2\x11.clarifai.api.HitR\x04hitsB\x04\x80\xb5\x18\x01\
    \x12)\n\x05query\x18\x04\x20\x01(\x0b2\x13.clarifai.api.QueryR\x05query\
    \x120\n\x08searches\x18\x05\x20\x03(\x0b2\x14.clarifai.api.SearchR\x08se\
    arches\"\xd4\x02\n\"PostAnnotationSearchMetricsRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x127\n\x0cground_truth\x18\x03\
    \x20\x01(\x0b2\x14.clarifai.api.SearchR\x0bgroundTruth\x12:\n\x0esearch_\
    to_eval\x18\x04\x20\x01(\x0b2\x14.clarifai.api.SearchR\x0csearchToEval\
    \x12&\n\x04data\x18\x05\x20\x01(\x0b2\x12.clarifai.api.DataR\x04data\x12\
    E\n\x0fevaluation_type\x18\x06\x20\x01(\x0e2\x1c.clarifai.api.Evaluation\
    TypeR\x0eevaluationType\"o\n!GetAnnotationSearchMetricsRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"`\n\"ListAnnotationSe\
    archMetricsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clari\
    fai.api.UserAppIDSetR\tuserAppId\"\xbe\x01\n$MultiAnnotationSearchMetric\
    sResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status\
    .StatusR\x06status\x12a\n\x19annotation_search_metrics\x18\x02\x20\x03(\
    \x0b2%.clarifai.api.AnnotationSearchMetricsR\x17annotationSearchMetrics\
    \"\x8d\x01\n\x1bPostValidatePasswordRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x122\n\x08p\
    assword\x18\x02\x20\x01(\x0b2\x16.clarifai.api.PasswordR\x08password\"\
    \xaa\x01\n\x20SinglePasswordValidationResponse\x123\n\x06status\x18\x01\
    \x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12Q\n\x13passw\
    ord_violations\x18\x02\x20\x01(\x0b2\x20.clarifai.api.PasswordViolations\
    R\x12passwordViolations\"\x96\x02\n\x12GetWorkflowRequest\x12:\n\x0buser\
    _app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\
    \x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x128\n\x18favo\
    r_clarifai_workflows\x18\x03\x20\x01(\x08R\x16favorClarifaiWorkflows\x12\
    +\n\x11additional_fields\x18\x04\x20\x03(\tR\x10additionalFields\x12<\n\
    \x1aexclude_clarifai_workflows\x18\x05\x20\x01(\x08R\x18excludeClarifaiW\
    orkflows\"\xa3\x03\n\x14ListWorkflowsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\x12%\n\x0esort_ascending\x18\x05\x20\x01(\x08R\rsort\
    Ascending\x12\x1e\n\nsort_by_id\x18\x06\x20\x01(\x08H\0R\x08sortById\x12\
    /\n\x13sort_by_modified_at\x18\x07\x20\x01(\x08H\0R\x10sortByModifiedAt\
    \x12\x14\n\x05query\x18\x08\x20\x01(\tR\x05query\x12\x12\n\x02id\x18\x04\
    \x20\x01(\tR\x02idB\x02\x18\x01\x12#\n\rfeatured_only\x18\t\x20\x01(\x08\
    R\x0cfeaturedOnly\x12!\n\x0cstarred_only\x18\x0b\x20\x01(\x08R\x0bstarre\
    dOnly\x12+\n\x11additional_fields\x18\n\x20\x03(\tR\x10additionalFieldsB\
    \t\n\x07sort_by\"\x88\x01\n\x14PostWorkflowsRequest\x12:\n\x0buser_app_i\
    d\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x124\n\
    \tworkflows\x18\x02\x20\x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflows\
    \"\xa1\x01\n\x15PatchWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x124\n\tworkflows\
    \x18\x02\x20\x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflows\x12\x16\n\
    \x06action\x18\x03\x20\x01(\tR\x06action\"t\n\x15DeleteWorkflowRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\
    \"\x85\x01\n\x16DeleteWorkflowsRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\
    \x18\x02\x20\x03(\tR\x03ids\x12\x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\
    \tdeleteAll\"\x81\x01\n\x16SingleWorkflowResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x122\n\x08w\
    orkflow\x18\x02\x20\x01(\x0b2\x16.clarifai.api.WorkflowR\x08workflow\"\
    \x88\x01\n\x15MultiWorkflowResponse\x123\n\x06status\x18\x01\x20\x01(\
    \x0b2\x1b.clarifai.api.status.StatusR\x06status\x12:\n\tworkflows\x18\
    \x02\x20\x03(\x0b2\x16.clarifai.api.WorkflowR\tworkflowsB\x04\x80\xb5\
    \x18\x01\"\x84\x03\n\x1aPostWorkflowResultsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\
    \n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x12\x1d\n\nversion_id\
    \x18\x07\x20\x01(\tR\tversionId\x12+\n\x06inputs\x18\x03\x20\x03(\x0b2\
    \x13.clarifai.api.InputR\x06inputs\x12?\n\routput_config\x18\x04\x20\x01\
    (\x0b2\x1a.clarifai.api.OutputConfigR\x0coutputConfig\x128\n\x18favor_cl\
    arifai_workflows\x18\x05\x20\x01(\x08R\x16favorClarifaiWorkflows\x12B\n\
    \x0eworkflow_state\x18\x06\x20\x01(\x0b2\x1b.clarifai.api.WorkflowStateR\
    \rworkflowState\"\x82\x02\n\x1bPostWorkflowResultsResponse\x123\n\x06sta\
    tus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x122\
    \n\x08workflow\x18\x02\x20\x01(\x0b2\x16.clarifai.api.WorkflowR\x08workf\
    low\x126\n\x07results\x18\x03\x20\x03(\x0b2\x1c.clarifai.api.WorkflowRes\
    ultR\x07results\x12B\n\x0eworkflow_state\x18\x04\x20\x01(\x0b2\x1b.clari\
    fai.api.WorkflowStateR\rworkflowState\"\xf4\x02\n$PostWorkflowResultsSim\
    ilarityRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.\
    api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\t\
    R\nworkflowId\x12\x1d\n\nversion_id\x18\x07\x20\x01(\tR\tversionId\x12(\
    \n\x10model_version_id\x18\x03\x20\x01(\tR\x0emodelVersionId\x126\n\x0cp\
    robe_inputs\x18\x04\x20\x03(\x0b2\x13.clarifai.api.InputR\x0bprobeInputs\
    \x124\n\x0bpool_inputs\x18\x05\x20\x03(\x0b2\x13.clarifai.api.InputR\npo\
    olInputs\x128\n\x18favor_clarifai_workflows\x18\x06\x20\x01(\x08R\x16fav\
    orClarifaiWorkflows\"\x9f\x01\n%PostWorkflowResultsSimilarityResponse\
    \x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\
    \x06status\x12A\n\x07results\x18\x02\x20\x03(\x0b2'.clarifai.api.Workflo\
    wResultsSimilarityR\x07results\"\xa9\x01\n\x1bListWorkflowVersionsReques\
    t\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppID\
    SetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\
    \x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\
    \x04\x20\x01(\rR\x07perPage\"\xa8\x01\n\x19GetWorkflowVersionRequest\x12\
    :\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\
    \tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x12\
    .\n\x13workflow_version_id\x18\x03\x20\x01(\tR\x11workflowVersionId\"\
    \xae\x01\n\x1dDeleteWorkflowVersionsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\
    \x0bworkflow_id\x18\x02\x20\x01(\tR\nworkflowId\x120\n\x14workflow_versi\
    on_ids\x18\x03\x20\x03(\tR\x12workflowVersionIds\"\xdf\x01\n\x1cPatchWor\
    kflowVersionsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.cla\
    rifai.api.UserAppIDSetR\tuserAppId\x12\x1f\n\x0bworkflow_id\x18\x02\x20\
    \x01(\tR\nworkflowId\x12J\n\x11workflow_versions\x18\x03\x20\x03(\x0b2\
    \x1d.clarifai.api.WorkflowVersionR\x10workflowVersions\x12\x16\n\x06acti\
    on\x18\x04\x20\x01(\tR\x06action\"\xa5\x01\n\x1cMultiWorkflowVersionResp\
    onse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Stat\
    usR\x06status\x12P\n\x11workflow_versions\x18\x02\x20\x03(\x0b2\x1d.clar\
    ifai.api.WorkflowVersionR\x10workflowVersionsB\x04\x80\xb5\x18\x01\"\x9e\
    \x01\n\x1dSingleWorkflowVersionResponse\x123\n\x06status\x18\x01\x20\x01\
    (\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12H\n\x10workflow_vers\
    ion\x18\x02\x20\x01(\x0b2\x1d.clarifai.api.WorkflowVersionR\x0fworkflowV\
    ersion\"\xa1\x01\n\x1aPostAppDuplicationsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12G\n\
    \x10app_duplications\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.AppDuplicati\
    onR\x0fappDuplications\"\x84\x01\n\x18GetAppDuplicationRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12,\n\x12app_duplication_id\x18\x02\x20\x01(\tR\x10appDuplicati\
    onId\"\x87\x01\n\x1aListAppDuplicationsRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\
    \x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\"\x9c\x01\n\x1cMultiAppDuplicationsResponse\x123\n\
    \x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06stat\
    us\x12G\n\x10app_duplications\x18\x02\x20\x03(\x0b2\x1c.clarifai.api.App\
    DuplicationR\x0fappDuplications\"\x9a\x01\n\x1cSingleAppDuplicationRespo\
    nse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.Statu\
    sR\x06status\x12E\n\x0fapp_duplication\x18\x02\x20\x01(\x0b2\x1c.clarifa\
    i.api.AppDuplicationR\x0eappDuplication\"x\n\x10PostTasksRequest\x12:\n\
    \x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tus\
    erAppId\x12(\n\x05tasks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\x05\
    tasks\"e\n\x0eGetTaskRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_id\x18\x02\
    \x20\x01(\tR\x06taskId\"\x8c\x02\n\x10ListTasksRequest\x12:\n\x0buser_ap\
    p_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\
    \x20\x01(\rR\x07perPage\x12&\n\x0fworker_user_ids\x18\x04\x20\x03(\tR\rw\
    orkerUserIds\x12&\n\x0freview_user_ids\x18\x05\x20\x03(\tR\rreviewUserId\
    s\x12=\n\x1bincluding_label_order_tasks\x18\x06\x20\x01(\x08R\x18includi\
    ngLabelOrderTasks\"\x91\x01\n\x11PatchTasksRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12(\n\
    \x05tasks\x18\x02\x20\x03(\x0b2\x12.clarifai.api.TaskR\x05tasks\x12\x16\
    \n\x06action\x18\x03\x20\x01(\tR\x06action\"b\n\x12DeleteTasksRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\"x\n\x11Multi\
    TaskResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12.\n\x05tasks\x18\x02\x20\x03(\x0b2\x12.clarifai\
    .api.TaskR\x05tasksB\x04\x80\xb5\x18\x01\"q\n\x12SingleTaskResponse\x123\
    \n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06st\
    atus\x12&\n\x04task\x18\x02\x20\x01(\x0b2\x12.clarifai.api.TaskR\x04task\
    \"\x85\x01\n\x13GetTaskCountRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x17\n\x07task_i\
    d\x18\x02\x20\x01(\tR\x06taskId\x12\x19\n\x08user_ids\x18\x03\x20\x03(\t\
    R\x07userIds\"\xbc\x01\n\x17SingleTaskCountResponse\x123\n\x06status\x18\
    \x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12\x15\n\
    \x06app_id\x18\x02\x20\x01(\tR\x05appId\x12\x17\n\x07task_id\x18\x03\x20\
    \x01(\tR\x06taskId\x12<\n\x06counts\x18\x04\x20\x03(\x0b2$.clarifai.api.\
    TaskStatusCountPerUserR\x06counts\"\x91\x01\n\x16PostLabelOrdersRequest\
    \x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDS\
    etR\tuserAppId\x12;\n\x0clabel_orders\x18\x02\x20\x03(\x0b2\x18.clarifai\
    .api.LabelOrderR\x0blabelOrders\"x\n\x14GetLabelOrderRequest\x12:\n\x0bu\
    ser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserApp\
    Id\x12$\n\x0elabel_order_id\x18\x02\x20\x01(\tR\x0clabelOrderId\"\x83\
    \x01\n\x16ListLabelOrdersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\
    \x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\n\x04page\x18\
    \x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\x01(\rR\x07pe\
    rPage\"\xaa\x01\n\x17PatchLabelOrdersRequest\x12:\n\x0buser_app_id\x18\
    \x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12;\n\x0cl\
    abel_orders\x18\x02\x20\x03(\x0b2\x18.clarifai.api.LabelOrderR\x0blabelO\
    rders\x12\x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"h\n\x18DeleteLa\
    belOrdersRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifa\
    i.api.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03i\
    ds\"\x91\x01\n\x17MultiLabelOrderResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x12A\n\x0clabel_ord\
    ers\x18\x02\x20\x03(\x0b2\x18.clarifai.api.LabelOrderR\x0blabelOrdersB\
    \x04\x80\xb5\x18\x01\"\x8a\x01\n\x18SingleLabelOrderResponse\x123\n\x06s\
    tatus\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\
    \x129\n\x0blabel_order\x18\x02\x20\x01(\x0b2\x18.clarifai.api.LabelOrder\
    R\nlabelOrder\"\x8c\x01\n\x15PostCollectorsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x127\n\
    \ncollectors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollecto\
    rs\"\xa5\x01\n\x16PatchCollectorsRequest\x12:\n\x0buser_app_id\x18\x01\
    \x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x127\n\ncollect\
    ors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollectors\x12\
    \x16\n\x06action\x18\x03\x20\x01(\tR\x06action\"\x86\x01\n\x17DeleteColl\
    ectorsRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.a\
    pi.UserAppIDSetR\tuserAppId\x12\x10\n\x03ids\x18\x02\x20\x03(\tR\x03ids\
    \x12\x1d\n\ndelete_all\x18\x03\x20\x01(\x08R\tdeleteAll\"t\n\x13GetColle\
    ctorRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api\
    .UserAppIDSetR\tuserAppId\x12!\n\x0ccollector_id\x18\x02\x20\x01(\tR\x0b\
    collectorId\"\x82\x01\n\x15ListCollectorsRequest\x12:\n\x0buser_app_id\
    \x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\x12\
    \n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x19\n\x08per_page\x18\x03\x20\
    \x01(\rR\x07perPage\"\x86\x01\n\x16MultiCollectorResponse\x123\n\x06stat\
    us\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x127\
    \n\ncollectors\x18\x02\x20\x03(\x0b2\x17.clarifai.api.CollectorR\ncollec\
    tors\"\x85\x01\n\x17SingleCollectorResponse\x123\n\x06status\x18\x01\x20\
    \x01(\x0b2\x1b.clarifai.api.status.StatusR\x06status\x125\n\tcollector\
    \x18\x02\x20\x01(\x0b2\x17.clarifai.api.CollectorR\tcollector\"\x8d\x01\
    \n\x15PostStatValuesRequest\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\
    \x1a.clarifai.api.UserAppIDSetR\tuserAppId\x128\n\x0bstat_values\x18\x02\
    \x20\x03(\x0b2\x17.clarifai.api.StatValueR\nstatValues\"\x8d\x01\n\x16Mu\
    ltiStatValueResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai\
    .api.status.StatusR\x06status\x12>\n\x0bstat_values\x18\x02\x20\x03(\x0b\
    2\x17.clarifai.api.StatValueR\nstatValuesB\x04\x80\xb5\x18\x01\"\xc4\x01\
    \n\x1ePostStatValuesAggregateRequest\x12:\n\x0buser_app_id\x18\x01\x20\
    \x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12f\n\x1cstat_valu\
    e_aggregate_queries\x18\x02\x20\x03(\x0b2%.clarifai.api.StatValueAggrega\
    teQueryR\x19statValueAggregateQueries\"\xbf\x01\n\x1fMultiStatValueAggre\
    gateResponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.sta\
    tus.StatusR\x06status\x12g\n\x1cstat_value_aggregate_results\x18\x02\x20\
    \x03(\x0b2&.clarifai.api.StatValueAggregateResultR\x19statValueAggregate\
    Results\"\x96\x01\n\x1ePostTrendingMetricsViewRequest\x12:\n\x0buser_app\
    _id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.UserAppIDSetR\tuserAppId\x12\
    \x1b\n\tview_type\x18\x02\x20\x01(\tR\x08viewType\x12\x1b\n\tobject_id\
    \x18\x03\x20\x01(\tR\x08objectId\"\xa9\x01\n\x1fListTrendingMetricsViews\
    Request\x12:\n\x0buser_app_id\x18\x01\x20\x01(\x0b2\x1a.clarifai.api.Use\
    rAppIDSetR\tuserAppId\x12\x1b\n\tview_type\x18\x02\x20\x01(\tR\x08viewTy\
    pe\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\x19\n\x08per_page\
    \x18\x04\x20\x01(\rR\x07perPage\"\x8f\x01\n\x20MultiTrendingMetricsViewR\
    esponse\x123\n\x06status\x18\x01\x20\x01(\x0b2\x1b.clarifai.api.status.S\
    tatusR\x06status\x126\n\x07metrics\x18\x02\x20\x03(\x0b2\x1c.clarifai.ap\
    i.TrendingMetricR\x07metrics*p\n\x1cOrganizationInvitationStatus\x12\x0b\
    \n\x07NOT_SET\x10\0\x12\x0b\n\x07PENDING\x10\x01\x12\x0c\n\x08ACCEPTED\
    \x10\x02\x12\r\n\tCANCELLED\x10\x03\x12\x0c\n\x08DECLINED\x10\x04\x12\
    \x0b\n\x07EXPIRED\x10\x052\xf7\xf2\x01\n\x02V2\x12\xaa\x02\n\x14ListConc\
    eptRelations\x12).clarifai.api.ListConceptRelationsRequest\x1a*.clarifai\
    .api.MultiConceptRelationResponse\"\xba\x01\x98\x9c'\x05\x90\x9c'\x0b\
    \x82\xd3\xe4\x93\x02\xab\x01\x12Y/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/concepts/{concept_id}/relationsZN\x12L/v2/users/{user\
    _app_id.user_id}/apps/{user_app_id.app_id}/concepts/relations\x12\xdf\
    \x01\n\x14PostConceptRelations\x12).clarifai.api.PostConceptRelationsReq\
    uest\x1a*.clarifai.api.MultiConceptRelationResponse\"p\x82\xd3\xe4\x93\
    \x02^\"Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concep\
    ts/{concept_id}/relations:\x01*\x98\x9c'\x05\x90\x9c'\n\x90\x9c'\x0b\x12\
    \xde\x01\n\x16DeleteConceptRelations\x12+.clarifai.api.DeleteConceptRela\
    tionsRequest\x1a!.clarifai.api.status.BaseResponse\"t\x90\x9c'\r\x90\x9c\
    '\n\x90\x9c'\x0b\x98\x9c'\x05\x82\xd3\xe4\x93\x02^*Y/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations:\
    \x01*\x12\xdc\x01\n\x10GetConceptCounts\x12%.clarifai.api.GetConceptCoun\
    tsRequest\x1a'.clarifai.api.MultiConceptCountResponse\"x\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/concepts/statusZ\x15\x12\x13/v2/concep\
    ts/status\x98\x9c'\x02\x12\xd0\x01\n\nGetConcept\x12\x1f.clarifai.api.Ge\
    tConceptRequest\x1a#.clarifai.api.SingleConceptResponse\"|\x98\x9c'\x02\
    \x82\xd3\xe4\x93\x02n\x12O/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/concepts/{concept_id}Z\x1b\x12\x19/v2/concepts/{concept_id}\
    \x90\x9c'\x0b\x12\xb9\x01\n\x0cListConcepts\x12!.clarifai.api.ListConcep\
    tsRequest\x1a\".clarifai.api.MultiConceptResponse\"b\x90\x9c'\x0b\x82\
    \xd3\xe4\x93\x02T\x12B/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/conceptsZ\x0e\x12\x0c/v2/concepts\x98\x9c'\x02\x12\xea\x01\n\x14\
    PostConceptsSearches\x12).clarifai.api.PostConceptsSearchesRequest\x1a\"\
    .clarifai.api.MultiConceptResponse\"\x82\x01\x98\x9c'\x02\x82\xd3\xe4\
    \x93\x02l\"K/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/co\
    ncepts/searches:\x01*Z\x1a\"\x15/v2/concepts/searches:\x01*\x90\x9c'\x0b\
    \x90\x9c'\x0f\x90\x9c'\x13\x12\xc3\x01\n\x0cPostConcepts\x12!.clarifai.a\
    pi.PostConceptsRequest\x1a\".clarifai.api.MultiConceptResponse\"l\x82\
    \xd3\xe4\x93\x02Z\"B/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/concepts:\x01*Z\x11\"\x0c/v2/concepts:\x01*\x98\x9c'\x02\x90\x9c'\
    \n\x90\x9c'\x0b\x12\xc5\x01\n\rPatchConcepts\x12\".clarifai.api.PatchCon\
    ceptsRequest\x1a\".clarifai.api.MultiConceptResponse\"l\x98\x9c'\x02\x82\
    \xd3\xe4\x93\x02Z2B/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/concepts:\x01*Z\x112\x0c/v2/concepts:\x01*\x90\x9c'\n\x90\x9c'\x0b\
    \x12\x94\x02\n\x12GetConceptLanguage\x12'.clarifai.api.GetConceptLanguag\
    eRequest\x1a+.clarifai.api.SingleConceptLanguageResponse\"\xa7\x01\x82\
    \xd3\xe4\x93\x02\x98\x01\x12d/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/concepts/{concept_id}/languages/{language}Z0\x12./v2/conc\
    epts/{concept_id}/languages/{language}\x98\x9c'\x02\x90\x9c'\x0b\x12\x81\
    \x02\n\x14ListConceptLanguages\x12).clarifai.api.ListConceptLanguagesReq\
    uest\x1a*.clarifai.api.MultiConceptLanguageResponse\"\x91\x01\x82\xd3\
    \xe4\x93\x02\x82\x01\x12Y/v2/users/{user_app_id.user_id}/apps/{user_app_\
    id.app_id}/concepts/{concept_id}/languagesZ%\x12#/v2/concepts/{concept_i\
    d}/languages\x98\x9c'\x02\x90\x9c'\x0b\x12\x8b\x02\n\x14PostConceptLangu\
    ages\x12).clarifai.api.PostConceptLanguagesRequest\x1a*.clarifai.api.Mul\
    tiConceptLanguageResponse\"\x9b\x01\x82\xd3\xe4\x93\x02\x88\x01\"Y/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id\
    }/languages:\x01*Z(\"#/v2/concepts/{concept_id}/languages:\x01*\x90\x9c'\
    \n\x90\x9c'\x0b\x98\x9c'\x02\x12\x8d\x02\n\x15PatchConceptLanguages\x12*\
    .clarifai.api.PatchConceptLanguagesRequest\x1a*.clarifai.api.MultiConcep\
    tLanguageResponse\"\x9b\x01\x98\x9c'\x02\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\
    \xe4\x93\x02\x88\x012Y/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/concepts/{concept_id}/languages:\x01*Z(2#/v2/concepts/{concept_i\
    d}/languages:\x01*\x12\xf1\x01\n\x13ListKnowledgeGraphs\x12(.clarifai.ap\
    i.ListKnowledgeGraphsRequest\x1a).clarifai.api.MultiKnowledgeGraphRespon\
    se\"\x84\x01\x82\xd3\xe4\x93\x02v\x12S/v2/users/{user_app_id.user_id}/ap\
    ps/{user_app_id.app_id}/concepts/knowledge_graphsZ\x1f\x12\x1d/v2/concep\
    ts/knowledge_graphs\x98\x9c'\x02\x90\x9c'\x0b\x12\xfb\x01\n\x13PostKnowl\
    edgeGraphs\x12(.clarifai.api.PostKnowledgeGraphsRequest\x1a).clarifai.ap\
    i.MultiKnowledgeGraphResponse\"\x8e\x01\x82\xd3\xe4\x93\x02|\"S/v2/users\
    /{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_grap\
    hs:\x01*Z\"\"\x1d/v2/concepts/knowledge_graphs:\x01*\x98\x9c'\x02\x90\
    \x9c'\n\x90\x9c'\x0b\x12\xfe\x01\n\x16PostConceptMappingJobs\x12+.clarif\
    ai.api.PostConceptMappingJobsRequest\x1a,.clarifai.api.MultiConceptMappi\
    ngJobResponse\"\x88\x01\x90\x9c'\n\x90\x9c'\x0b\x82\xd3\xe4\x93\x02v\"P/\
    v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappin\
    gs/jobs:\x01*Z\x1f\"\x1a/v2/concepts/mappings/jobs:\x01*\x98\x9c'\x02\
    \x12\x93\x02\n\rGetAnnotation\x12\".clarifai.api.GetAnnotationRequest\
    \x1a&.clarifai.api.SingleAnnotationResponse\"\xb5\x01\x98\x9c'\x02\x90\
    \x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02\x9e\x01\x12g/v2/use\
    rs/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/ann\
    otations/{annotation_id}Z3\x121/v2/inputs/{input_id}/annotations/{annota\
    tion_id}\x12\xd0\x01\n\x0fListAnnotations\x12$.clarifai.api.ListAnnotati\
    onsRequest\x1a%.clarifai.api.MultiAnnotationResponse\"p\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x0f\x82\xd3\xe4\x93\x02Z\x12E/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/annotationsZ\x11\x12\x0f/v2/annotation\
    s\x98\x9c'\x02\x12\xe3\x01\n\x0fPostAnnotations\x12$.clarifai.api.PostAn\
    notationsRequest\x1a%.clarifai.api.MultiAnnotationResponse\"\x82\x01\x82\
    \xd3\xe4\x93\x02`\"E/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/annotations:\x01*Z\x14\"\x0f/v2/annotations:\x01*\x90\x9c'\x05\x90\
    \x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x13\x98\x9c'\x02\x12\
    \xe5\x01\n\x10PatchAnnotations\x12%.clarifai.api.PatchAnnotationsRequest\
    \x1a%.clarifai.api.MultiAnnotationResponse\"\x82\x01\x98\x9c'\x02\x82\
    \xd3\xe4\x93\x02`2E/v2/users/{user_app_id.user_id}/apps/{user_app_id.app\
    _id}/annotations:\x01*Z\x142\x0f/v2/annotations:\x01*\x90\x9c'\x05\x90\
    \x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x12\xf3\x01\n\
    \x16PatchAnnotationsStatus\x12+.clarifai.api.PatchAnnotationsStatusReque\
    st\x1a,.clarifai.api.PatchAnnotationsStatusResponse\"~\x82\xd3\xe4\x93\
    \x02`2[/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/task/{t\
    ask_id}/annotations/status:\x01*\x98\x9c'\x02\x90\x9c'%\x90\x9c'&\x90\
    \x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x12\x9c\x02\n\x10DeleteAnnotation\
    \x12%.clarifai.api.DeleteAnnotationRequest\x1a!.clarifai.api.status.Base\
    Response\"\xbd\x01\x82\xd3\xe4\x93\x02\x9e\x01*g/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotat\
    ion_id}Z3*1/v2/inputs/{input_id}/annotations/{annotation_id}\x98\x9c'\
    \x02\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\x13\x90\x9c'\x0f\x12\xd0\x02\
    \n\x11DeleteAnnotations\x12&.clarifai.api.DeleteAnnotationsRequest\x1a!.\
    clarifai.api.status.BaseResponse\"\xef\x01\x98\x9c'\x02\x82\xd3\xe4\x93\
    \x02\xd0\x01*L/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    inputs/annotations:\x01*Z\x1b*\x16/v2/inputs/annotations:\x01*ZJ*E/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations:\x01*Z\
    \x14*\x0f/v2/annotations:\x01*\x90\x9c'%\x90\x9c'(\x90\x9c'&\x90\x9c'\
    \x13\x90\x9c'\x0f\x12\xf3\x01\n\x18PatchAnnotationsSearches\x12-.clarifa\
    i.api.PatchAnnotationsSearchesRequest\x1a!.clarifai.api.MultiSearchRespo\
    nse\"\x84\x01\x98\x9c'\x02\x90\x9c's\x90\x9c'r\x82\xd3\xe4\x93\x02r2N/v2\
    /users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searc\
    hes:\x01*Z\x1d2\x18/v2/annotations/searches:\x01*\x12\x81\x02\n\x17PostA\
    nnotationsSearches\x12,.clarifai.api.PostAnnotationsSearchesRequest\x1a!\
    .clarifai.api.MultiSearchResponse\"\x94\x01\x90\x9c'&\x90\x9c'\x0b\x90\
    \x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02r\"N/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/annotations/searches:\x01*Z\x1d\"\x18/v2/annotations/searches:\x01*\
    \x12\xd1\x01\n\rGetInputCount\x12\".clarifai.api.GetInputCountRequest\
    \x1a&.clarifai.api.SingleInputCountResponse\"t\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x05\x98\x9c'\x02\x82\xd3\xe4\x93\x02^\x12G/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/inputs/statusZ\x13\x12\x11/v2/inpu\
    ts/status\x12\xc9\x01\n\x0cStreamInputs\x12!.clarifai.api.StreamInputsRe\
    quest\x1a\x20.clarifai.api.MultiInputResponse\"t\x82\xd3\xe4\x93\x02^\
    \x12G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/st\
    reamZ\x13\x12\x11/v2/inputs/stream\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x05\x12\xfd\x01\n\x0fGetInputSamples\x12$.clarifai.api.GetInpu\
    tSamplesRequest\x1a*.clarifai.api.MultiInputAnnotationResponse\"\x97\x01\
    \x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x82\xd3\xe4\x93\x02\
    \x80\x01\x12X/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/t\
    asks/{task_id}/inputs/samplesZ$\x12\"/v2/tasks/{task_id}/inputs/samples\
    \x12\xca\x01\n\x08GetInput\x12\x1d.clarifai.api.GetInputRequest\x1a!.cla\
    rifai.api.SingleInputResponse\"|\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\
    \x9c'\x05\x82\xd3\xe4\x93\x02f\x12K/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/inputs/{input_id}Z\x17\x12\x15/v2/inputs/{input_id}\
    \x12\xb7\x01\n\nListInputs\x12\x1f.clarifai.api.ListInputsRequest\x1a\
    \x20.clarifai.api.MultiInputResponse\"f\x82\xd3\xe4\x93\x02P\x12@/v2/use\
    rs/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputsZ\x0c\x12\n/v2/\
    inputs\x98\x9c'\x02\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x12\xd2\x01\n\nP\
    ostInputs\x12\x1f.clarifai.api.PostInputsRequest\x1a\x20.clarifai.api.Mu\
    ltiInputResponse\"\x80\x01\x98\x9c'\x02\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\
    \x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x02\x90\x9c'\x13\x82\
    \xd3\xe4\x93\x02V\"@/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/inputs:\x01*Z\x0f\"\n/v2/inputs:\x01*\x12\xcb\x01\n\x0bPatchInputs\
    \x12\x20.clarifai.api.PatchInputsRequest\x1a\x20.clarifai.api.MultiInput\
    Response\"x\x90\x9c'%\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\
    \x90\x9c'\x0f\x82\xd3\xe4\x93\x02V2@/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/inputs:\x01*Z\x0f2\n/v2/inputs:\x01*\x98\x9c'\x02\
    \x12\xe5\x01\n\x0bDeleteInput\x12\x20.clarifai.api.DeleteInputRequest\
    \x1a!.clarifai.api.status.BaseResponse\"\x90\x01\x98\x9c'\x02\x90\x9c'%\
    \x90\x9c'(\x90\x9c'&\x90\x9c'\x04\x90\x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02f*K/v2/users/{user_app_id.user_id}/apps\
    /{user_app_id.app_id}/inputs/{input_id}Z\x17*\x15/v2/inputs/{input_id}\
    \x12\xd7\x01\n\x0cDeleteInputs\x12!.clarifai.api.DeleteInputsRequest\x1a\
    !.clarifai.api.status.BaseResponse\"\x80\x01\x98\x9c'\x02\x90\x9c'%\x90\
    \x9c'(\x90\x9c'&\x90\x9c'\x04\x90\x9c'\x08\x90\x9c'\x05\x90\x9c'\x0f\x90\
    \x9c'\x13\x82\xd3\xe4\x93\x02V*@/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/inputs:\x01*Z\x0f*\n/v2/inputs:\x01*\x12\xde\x01\n\x13\
    PatchInputsSearches\x12(.clarifai.api.PatchInputsSearchesRequest\x1a!.cl\
    arifai.api.MultiSearchResponse\"z\x90\x9c's\x90\x9c'r\x82\xd3\xe4\x93\
    \x02h2I/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/\
    searches:\x01*Z\x182\x13/v2/inputs/searches:\x01*\x98\x9c'\x02\x12\xed\
    \x01\n\x12PostInputsSearches\x12'.clarifai.api.PostInputsSearchesRequest\
    \x1a!.clarifai.api.MultiSearchResponse\"\x8a\x01\x98\x9c'\x02\x90\x9c'&\
    \x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\x9c'\x03\x90\x9c'\x13\x82\
    \xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/inputs/searches:\x01*Z\x18\"\x13/v2/inputs/searches:\x01*\x12\x9c\
    \x03\n\x10PostModelOutputs\x12%.clarifai.api.PostModelOutputsRequest\x1a\
    !.clarifai.api.MultiOutputResponse\"\xbd\x02\x82\xd3\xe4\x93\x02\xa6\x02\
    \"i/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{mod\
    el_id}/versions/{version_id}/outputs:\x01*Z8\"3/v2/models/{model_id}/ver\
    sions/{version_id}/outputs:\x01*ZX\"S/v2/users/{user_app_id.user_id}/app\
    s/{user_app_id.app_id}/models/{model_id}/outputs:\x01*Z\"\"\x1d/v2/model\
    s/{model_id}/outputs:\x01*\x98\x9c'\x02\x90\x9c'\x0b\x90\x9c'\x0f\x90\
    \x9c'\x02\x12\xe5\x01\n\x0cGetModelType\x12!.clarifai.api.GetModelTypeRe\
    quest\x1a%.clarifai.api.SingleModelTypeResponse\"\x8a\x01\x98\x9c'\x02\
    \x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/models/types/{model_type_id}Z\"\x12\x20/v2/models/types/{mod\
    el_type_id}\x90\x9c'\x0f\x12\x99\x01\n\x16ListOpenSourceLicenses\x12+.cl\
    arifai.api.ListOpenSourceLicensesRequest\x1a,.clarifai.api.ListOpenSourc\
    eLicensesResponse\"$\x82\xd3\xe4\x93\x02\x1a\x12\x18/v2/open_source_lice\
    nses\x98\x9c'\x01\x12\xc7\x01\n\x0eListModelTypes\x12#.clarifai.api.List\
    ModelTypesRequest\x1a$.clarifai.api.MultiModelTypeResponse\"j\x90\x9c'\
    \x0f\x82\xd3\xe4\x93\x02\\\x12F/v2/users/{user_app_id.user_id}/apps/{use\
    r_app_id.app_id}/models/typesZ\x12\x12\x10/v2/models/types\x98\x9c'\x02\
    \x12\xc6\x01\n\x08GetModel\x12\x1d.clarifai.api.GetModelRequest\x1a!.cla\
    rifai.api.SingleModelResponse\"x\x82\xd3\xe4\x93\x02f\x12K/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}Z\x17\x12\
    \x15/v2/models/{model_id}\x98\x9c'\x02\x90\x9c'\x0b\x90\x9c'\x0f\x12\x96\
    \x03\n\x12GetModelOutputInfo\x12\x1d.clarifai.api.GetModelRequest\x1a!.c\
    larifai.api.SingleModelResponse\"\xbd\x02\x82\xd3\xe4\x93\x02\xaa\x02\
    \x12W/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{m\
    odel_id}/output_infoZ#\x12!/v2/models/{model_id}/output_infoZo\x12m/v2/u\
    sers/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/v\
    ersions/{version_id}/output_infoZ9\x127/v2/models/{model_id}/versions/{v\
    ersion_id}/output_info\x98\x9c'\x02\x90\x9c'\x0b\x90\x9c'\x0f\x12\xde\
    \x01\n\nListModels\x12\x1f.clarifai.api.ListModelsRequest\x1a\x20.clarif\
    ai.api.MultiModelResponse\"\x8c\x01\x82\xd3\xe4\x93\x02z\x12@/v2/users/{\
    user_app_id.user_id}/apps/{user_app_id.app_id}/modelsZ(\x12&/v2/users/{u\
    ser_app_id.user_id}/modelsZ\x0c\x12\n/v2/models\x90\x9c'\x0b\x90\x9c'\
    \x0f\x98\x9c'\x02\x12\xdb\x01\n\x12PostModelsSearches\x12'.clarifai.api.\
    PostModelsSearchesRequest\x1a\x20.clarifai.api.MultiModelResponse\"z\x82\
    \xd3\xe4\x93\x02h\"I/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/models/searches:\x01*Z\x18\"\x13/v2/models/searches:\x01*\x98\x9c'\
    \x02\x90\x9c'\x0b\x90\x9c'\x0f\x12\xc6\x01\n\nPostModels\x12\x1f.clarifa\
    i.api.PostModelsRequest\x1a!.clarifai.api.SingleModelResponse\"t\x90\x9c\
    '\x0b\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c'\x13\x82\xd3\xe4\
    \x93\x02V\"@/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/mo\
    dels:\x01*Z\x0f\"\n/v2/models:\x01*\x98\x9c'\x02\x12\xc3\x01\n\x0bPatchM\
    odels\x12\x20.clarifai.api.PatchModelsRequest\x1a\x20.clarifai.api.Multi\
    ModelResponse\"p\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x98\
    \x9c'\x02\x82\xd3\xe4\x93\x02V2@/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/models:\x01*Z\x0f2\n/v2/models:\x01*\x12\xb2\x01\n\rPa\
    tchModelIds\x12\".clarifai.api.PatchModelIdsRequest\x1a\x20.clarifai.api\
    .MultiModelResponse\"[\x82\xd3\xe4\x93\x02I2D/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/models/ids:\x01*\x98\x9c'\x02\x90\x9c'\
    \x0e\x90\x9c'\x0f\x12\xd9\x01\n\x0bDeleteModel\x12\x20.clarifai.api.Dele\
    teModelRequest\x1a!.clarifai.api.status.BaseResponse\"\x84\x01\x98\x9c'\
    \x02\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\x9c'\x13\
    \x82\xd3\xe4\x93\x02f*K/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/models/{model_id}Z\x17*\x15/v2/models/{model_id}\x12\xca\x01\n\
    \x0cDeleteModels\x12!.clarifai.api.DeleteModelsRequest\x1a!.clarifai.api\
    .status.BaseResponse\"t\x98\x9c'\x02\x82\xd3\xe4\x93\x02V*@/v2/users/{us\
    er_app_id.user_id}/apps/{user_app_id.app_id}/models:\x01*Z\x0f*\n/v2/mod\
    els:\x01*\x90\x9c'\x0b\x90\x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\x9c'\
    \x13\x12\xf5\x01\n\x12PatchModelToolkits\x12'.clarifai.api.PatchModelToo\
    lkitsRequest\x1a'.clarifai.api.MultiModelToolkitResponse\"\x8c\x01\x90\
    \x9c'\x0f\x98\x9c'\x02\x82\xd3\xe4\x93\x02~2T/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/models/{model_id}/toolkits:\x01*Z#2\x1e/v\
    2/models/{model_id}/toolkits:\x01*\x12\xf5\x01\n\x12PatchModelUseCases\
    \x12'.clarifai.api.PatchModelUseCasesRequest\x1a'.clarifai.api.MultiMode\
    lUseCaseResponse\"\x8c\x01\x90\x9c'\x0f\x98\x9c'\x02\x82\xd3\xe4\x93\x02\
    ~2T/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{mod\
    el_id}/usecases:\x01*Z#2\x1e/v2/models/{model_id}/usecases:\x01*\x12\xfb\
    \x01\n\x13PatchModelLanguages\x12(.clarifai.api.PatchModelLanguagesReque\
    st\x1a(.clarifai.api.MultiModelLanguageResponse\"\x8f\x01\x82\xd3\xe4\
    \x93\x02\x80\x012U/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/models/{model_id}/languages:\x01*Z$2\x1f/v2/models/{model_id}/langua\
    ges:\x01*\x98\x9c'\x02\x90\x9c'\x0f\x12\x8d\x03\n\x0fListModelInputs\x12\
    $.clarifai.api.ListModelInputsRequest\x1a\x20.clarifai.api.MultiInputRes\
    ponse\"\xb1\x02\x82\xd3\xe4\x93\x02\x96\x02\x12R/v2/users/{user_app_id.u\
    ser_id}/apps/{user_app_id.app_id}/models/{model_id}/inputsZ\x1e\x12\x1c/\
    v2/models/{model_id}/inputsZj\x12h/v2/users/{user_app_id.user_id}/apps/{\
    user_app_id.app_id}/models/{model_id}/versions/{version_id}/inputsZ4\x12\
    2/v2/models/{model_id}/versions/{version_id}/inputs\x90\x9c'&\x90\x9c'\
    \x0b\x90\x9c'\x05\x90\x9c'\x0f\x98\x9c'\x02\x12\x89\x02\n\x0fGetModelVer\
    sion\x12$.clarifai.api.GetModelVersionRequest\x1a(.clarifai.api.SingleMo\
    delVersionResponse\"\xa5\x01\x98\x9c'\x02\x90\x9c'\x0b\x90\x9c'\x0f\x82\
    \xd3\xe4\x93\x02\x92\x01\x12a/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/models/{model_id}/versions/{version_id}Z-\x12+/v2/models/\
    {model_id}/versions/{version_id}\x12\xf1\x01\n\x11ListModelVersions\x12&\
    .clarifai.api.ListModelVersionsRequest\x1a'.clarifai.api.MultiModelVersi\
    onResponse\"\x8a\x01\x82\xd3\xe4\x93\x02x\x12T/v2/users/{user_app_id.use\
    r_id}/apps/{user_app_id.app_id}/models/{model_id}/versionsZ\x20\x12\x1e/\
    v2/models/{model_id}/versions\x90\x9c'\x0b\x90\x9c'\x0f\x98\x9c'\x02\x12\
    \x99\x02\n\x18PostModelVersionsPublish\x12-.clarifai.api.PostModelVersio\
    nsPublishRequest\x1a!.clarifai.api.status.BaseResponse\"\xaa\x01\x90\x9c\
    '&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\
    \x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02|\"S/v2/users/{user_app\
    _id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/publish:\x01*Z\
    \"\"\x1d/v2/models/{model_id}/publish:\x01*\x98\x9c'\x02\x12\xa2\x02\n\
    \x1aPostModelVersionsUnPublish\x12/.clarifai.api.PostModelVersionsUnPubl\
    ishRequest\x1a!.clarifai.api.status.BaseResponse\"\xaf\x01\x98\x9c'\x02\
    \x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\
    \x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x82\xd3\xe4\x93\x02\x80\x01\"U/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/\
    unpublish:\x01*Z$\"\x1f/v2/models/{model_id}/unpublish:\x01*\x12\x8d\x02\
    \n\x11PostModelVersions\x12&.clarifai.api.PostModelVersionsRequest\x1a!.\
    clarifai.api.SingleModelResponse\"\xac\x01\x82\xd3\xe4\x93\x02~\"T/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/ve\
    rsions:\x01*Z#\"\x1e/v2/models/{model_id}/versions:\x01*\x98\x9c'\x02\
    \x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\
    \x1a\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x12\xdb\x01\n\x12PatchModelVersion\
    s\x12'.clarifai.api.PatchModelVersionsRequest\x1a'.clarifai.api.MultiMod\
    elVersionResponse\"s\x98\x9c'\x02\x82\xd3\xe4\x93\x02Y2T/v2/users/{user_\
    app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions:\
    \x01*\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x0e\x90\x9c'\x1a\x12\x94\x02\n\
    \x12DeleteModelVersion\x12'.clarifai.api.DeleteModelVersionRequest\x1a!.\
    clarifai.api.status.BaseResponse\"\xb1\x01\x98\x9c'\x02\x90\x9c'\x0b\x90\
    \x9c'\x0e\x90\x9c'\x11\x90\x9c'\x0f\x90\x9c'\x13\x82\xd3\xe4\x93\x02\x92\
    \x01*a/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{\
    model_id}/versions/{version_id}Z-*+/v2/models/{model_id}/versions/{versi\
    on_id}\x12\xb3\x02\n\x16GetModelVersionMetrics\x12+.clarifai.api.GetMode\
    lVersionMetricsRequest\x1a(.clarifai.api.SingleModelVersionResponse\"\
    \xc1\x01\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x0f\x90\x9c'\x05\x90\x9c'5\x82\
    \xd3\xe4\x93\x02\xa2\x01\x12i/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/models/{model_id}/versions/{version_id}/metricsZ5\x123/v2\
    /models/{model_id}/versions/{version_id}/metrics\x98\x9c'\x02\x12\xcf\
    \x02\n\x17PostModelVersionMetrics\x12,.clarifai.api.PostModelVersionMetr\
    icsRequest\x1a(.clarifai.api.SingleModelVersionResponse\"\xdb\x01\x82\
    \xd3\xe4\x93\x02\xa8\x01\"i/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/models/{model_id}/versions/{version_id}/metrics:\x01*Z8\"3/\
    v2/models/{model_id}/versions/{version_id}/metrics:\x01*\x98\x9c'\x02\
    \x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\
    \x1a\x90\x9c'\x02\x90\x9c'\x13\x90\x9c'5\x90\x9c'6\x12\xf7\x01\n\x13List\
    ModelReferences\x12(.clarifai.api.ListModelReferencesRequest\x1a).clarif\
    ai.api.MultiModelReferenceResponse\"\x8a\x01\x82\xd3\xe4\x93\x02|\x12V/v\
    2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id\
    }/referencesZ\"\x12\x20/v2/models/{model_id}/references\x90\x9c'\x0f\x98\
    \x9c'\x02\x12\xee\x02\n\x1bGetModelVersionInputExample\x120.clarifai.api\
    .GetModelVersionInputExampleRequest\x1a4.clarifai.api.SingleModelVersion\
    InputExampleResponse\"\xe6\x01\x90\x9c'\x0f\x98\x9c'\x02\x82\xd3\xe4\x93\
    \x02\xd7\x01\x12\x83\x01/v2/users/{user_app_id.user_id}/apps/{user_app_i\
    d.app_id}/models/{model_id}/versions/{model_version_id}/input_examples/{\
    example_id}ZO\x12M/v2/models/{model_id}/versions/{model_version_id}/inpu\
    t_examples/{example_id}\x12\xd6\x02\n\x1dListModelVersionInputExamples\
    \x122.clarifai.api.ListModelVersionInputExamplesRequest\x1a3.clarifai.ap\
    i.MultiModelVersionInputExampleResponse\"\xcb\x01\x82\xd3\xe4\x93\x02\
    \xbc\x01\x12v/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/m\
    odels/{model_id}/versions/{model_version_id}/input_examplesZB\x12@/v2/mo\
    dels/{model_id}/versions/{model_version_id}/input_examples\x98\x9c'\x02\
    \x90\x9c'\x0f\x12\xdc\x01\n\x0bGetWorkflow\x12\x20.clarifai.api.GetWorkf\
    lowRequest\x1a$.clarifai.api.SingleWorkflowResponse\"\x84\x01\x82\xd3\
    \xe4\x93\x02r\x12Q/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_\
    id}/workflows/{workflow_id}Z\x1d\x12\x1b/v2/workflows/{workflow_id}\x90\
    \x9c'\x0f\x90\x9c'\x13\x98\x9c'\x02\x12\xf1\x01\n\rListWorkflows\x12\".c\
    larifai.api.ListWorkflowsRequest\x1a#.clarifai.api.MultiWorkflowResponse\
    \"\x96\x01\x82\xd3\xe4\x93\x02\x83\x01\x12C/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/workflowsZ+\x12)/v2/users/{user_app_id.user\
    _id}/workflowsZ\x0f\x12\r/v2/workflows\x98\x9c'\x02\x90\x9c'\x0f\x90\x9c\
    '\x13\x12\xcc\x01\n\rPostWorkflows\x12\".clarifai.api.PostWorkflowsReque\
    st\x1a#.clarifai.api.MultiWorkflowResponse\"r\x90\x9c'\x0f\x90\x9c'\x12\
    \x90\x9c'\x13\x82\xd3\xe4\x93\x02\\\"C/v2/users/{user_app_id.user_id}/ap\
    ps/{user_app_id.app_id}/workflows:\x01*Z\x12\"\r/v2/workflows:\x01*\x98\
    \x9c'\x02\x12\xce\x01\n\x0ePatchWorkflows\x12#.clarifai.api.PatchWorkflo\
    wsRequest\x1a#.clarifai.api.MultiWorkflowResponse\"r\x82\xd3\xe4\x93\x02\
    \\2C/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows:\
    \x01*Z\x122\r/v2/workflows:\x01*\x98\x9c'\x02\x90\x9c'\x0f\x90\x9c'\x12\
    \x90\x9c'\x13\x12\xe3\x01\n\x0eDeleteWorkflow\x12#.clarifai.api.DeleteWo\
    rkflowRequest\x1a!.clarifai.api.status.BaseResponse\"\x88\x01\x82\xd3\
    \xe4\x93\x02r*Q/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}\
    /workflows/{workflow_id}Z\x1d*\x1b/v2/workflows/{workflow_id}\x90\x9c'\
    \x12\x90\x9c'\x15\x90\x9c'\x13\x98\x9c'\x02\x12\xce\x01\n\x0fDeleteWorkf\
    lows\x12$.clarifai.api.DeleteWorkflowsRequest\x1a!.clarifai.api.status.B\
    aseResponse\"r\x98\x9c'\x02\x90\x9c'\x12\x90\x9c'\x15\x90\x9c'\x13\x82\
    \xd3\xe4\x93\x02\\*C/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/workflows:\x01*Z\x12*\r/v2/workflows:\x01*\x12\x86\x03\n\x13PostWo\
    rkflowResults\x12(.clarifai.api.PostWorkflowResultsRequest\x1a).clarifai\
    .api.PostWorkflowResultsResponse\"\x99\x02\x82\xd3\xe4\x93\x02\xfe\x01\"\
    o/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{wo\
    rkflow_id}/versions/{version_id}/results:\x01*Z^\"Y/v2/users/{user_app_i\
    d.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results:\
    \x01*Z(\"#/v2/workflows/{workflow_id}/results:\x01*\x98\x9c'\x02\x90\x9c\
    '\x0f\x90\x9c'\x0b\x90\x9c'\x02\x90\x9c'\x13\x12\xc5\x03\n\x1dPostWorkfl\
    owResultsSimilarity\x122.clarifai.api.PostWorkflowResultsSimilarityReque\
    st\x1a3.clarifai.api.PostWorkflowResultsSimilarityResponse\"\xba\x02\x90\
    \x9c'\x0f\x90\x9c'\x0b\x90\x9c'\x02\x90\x9c'\x13\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02\x9f\x02\"z/v2/users/{user_app_id.user_id}/apps/{user_app_id\
    .app_id}/workflows/{workflow_id}/versions/{version_id}/results/similarit\
    y:\x01*Zi\"d/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/wo\
    rkflows/{workflow_id}/results/similarity:\x01*Z3\"./v2/workflows/{workfl\
    ow_id}/results/similarity:\x01*\x12\x87\x02\n\x14ListWorkflowVersions\
    \x12).clarifai.api.ListWorkflowVersionsRequest\x1a*.clarifai.api.MultiWo\
    rkflowVersionResponse\"\x97\x01\x98\x9c'\x02\x82\xd3\xe4\x93\x02\x84\x01\
    \x12Z/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows\
    /{workflow_id}/versionsZ&\x12$/v2/workflows/{workflow_id}/versions\x90\
    \x9c'\x0f\x90\x9c'\x13\x12\xb0\x02\n\x12GetWorkflowVersion\x12'.clarifai\
    .api.GetWorkflowVersionRequest\x1a+.clarifai.api.SingleWorkflowVersionRe\
    sponse\"\xc3\x01\x82\xd3\xe4\x93\x02\xb0\x01\x12p/v2/users/{user_app_id.\
    user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/versions/{wor\
    kflow_version_id}Z<\x12:/v2/workflows/{workflow_id}/versions/{workflow_v\
    ersion_id}\x98\x9c'\x02\x90\x9c'\x0f\x90\x9c'\x13\x12\x8c\x02\n\x16Delet\
    eWorkflowVersions\x12+.clarifai.api.DeleteWorkflowVersionsRequest\x1a!.c\
    larifai.api.status.BaseResponse\"\xa1\x01\x90\x9c'\x13\x90\x9c'\x12\x90\
    \x9c'\x15\x82\xd3\xe4\x93\x02\x8a\x01*Z/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/workflows/{workflow_id}/versions:\x01*Z)*$/v2/w\
    orkflows/{workflow_id}/versions:\x01*\x98\x9c'\x02\x12\x93\x02\n\x15Patc\
    hWorkflowVersions\x12*.clarifai.api.PatchWorkflowVersionsRequest\x1a*.cl\
    arifai.api.MultiWorkflowVersionResponse\"\xa1\x01\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02\x8a\x012Z/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/workflows/{workflow_id}/versions:\x01*Z)2$/v2/workflows/{workflo\
    w_id}/versions:\x01*\x90\x9c'\x0f\x90\x9c'\x13\x90\x9c'\x12\x12\x85\x01\
    \n\x06GetKey\x12\x1b.clarifai.api.GetKeyRequest\x1a\x1f.clarifai.api.Sin\
    gleKeyResponse\"=\x82\xd3\xe4\x93\x02/\x12-/v2/users/{user_app_id.user_i\
    d}/keys/{key_id}\x98\x9c'\x05\x90\x9c'0\x12\x7f\n\x08ListKeys\x12\x1d.cl\
    arifai.api.ListKeysRequest\x1a\x1e.clarifai.api.MultiKeyResponse\"4\x98\
    \x9c'\x05\x82\xd3\xe4\x93\x02&\x12$/v2/users/{user_app_id.user_id}/keys\
    \x90\x9c'0\x12\x9f\x01\n\x0bListAppKeys\x12\x20.clarifai.api.ListAppKeys\
    Request\x1a\x1e.clarifai.api.MultiKeyResponse\"N\x98\x9c'\x05\x90\x9c'0\
    \x82\xd3\xe4\x93\x02@\x12>/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/keys\x12\x95\x01\n\tDeleteKey\x12\x1e.clarifai.api.DeleteKey\
    Request\x1a!.clarifai.api.status.BaseResponse\"E\x82\xd3\xe4\x93\x02/*-/\
    v2/users/{user_app_id.user_id}/keys/{key_id}\x98\x9c'\x05\x90\x9c'/\x90\
    \x9c'1\x90\x9c'0\x12\x8a\x01\n\x08PostKeys\x12\x1d.clarifai.api.PostKeys\
    Request\x1a\x1e.clarifai.api.MultiKeyResponse\"?\x90\x9c'-\x90\x9c'/\x90\
    \x9c'0\x98\x9c'\x05\x82\xd3\xe4\x93\x02)\"$/v2/users/{user_app_id.user_i\
    d}/keys:\x01*\x12\x88\x01\n\tPatchKeys\x12\x1e.clarifai.api.PatchKeysReq\
    uest\x1a\x1e.clarifai.api.MultiKeyResponse\";\x90\x9c'/\x90\x9c'0\x82\
    \xd3\xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/keys:\x01*\x98\x9c'\
    \x05\x12\xbc\x01\n\x08MyScopes\x12\x1d.clarifai.api.MyScopesRequest\x1a\
    \x20.clarifai.api.MultiScopeResponse\"o\x82\xd3\xe4\x93\x02e\x12B/v2/use\
    rs/{user_app_id.user_id}/apps/{user_app_id.app_id}/myscopesZ\x0e\x12\x0c\
    /v2/myscopesZ\x0f\x12\r/v2/my_scopes\x98\x9c'\x02\x12\x8d\x01\n\x0cMySco\
    pesUser\x12!.clarifai.api.MyScopesUserRequest\x1a$.clarifai.api.MultiSco\
    peUserResponse\"4\x82\xd3\xe4\x93\x02*\x12(/v2/users/{user_app_id.user_i\
    d}/myscopes\x98\x9c'\x05\x12u\n\x0cMyScopesRoot\x12!.clarifai.api.MyScop\
    esRootRequest\x1a$.clarifai.api.MultiScopeRootResponse\"\x1c\x98\x9c'\
    \x05\x82\xd3\xe4\x93\x02\x12\x12\x10/v2/myscopesroot\x12\x87\x01\n\nList\
    Scopes\x12\x1f.clarifai.api.ListScopesRequest\x1a$.clarifai.api.MultiSco\
    peDepsResponse\"2\x82\xd3\xe4\x93\x02(\x12&/v2/users/{user_app_id.user_i\
    d}/scopes\x98\x9c'\x03\x12\x95\x01\n\x06GetApp\x12\x1b.clarifai.api.GetA\
    ppRequest\x1a\x1f.clarifai.api.SingleAppResponse\"M\x98\x9c'\x05\x90\x9c\
    '-\x90\x9c'\x13\x82\xd3\xe4\x93\x02;\x129/v2/users/{user_app_id.user_id}\
    /apps/{user_app_id.app_id}\x12\x8f\x01\n\x08ListApps\x12\x1d.clarifai.ap\
    i.ListAppsRequest\x1a\x1e.clarifai.api.MultiAppResponse\"D\x82\xd3\xe4\
    \x93\x022\x12$/v2/users/{user_app_id.user_id}/appsZ\n\x12\x08/v2/apps\
    \x98\x9c'\x05\x90\x9c'-\x90\x9c'\x13\x12\xa5\x01\n\tDeleteApp\x12\x1e.cl\
    arifai.api.DeleteAppRequest\x1a!.clarifai.api.status.BaseResponse\"U\x90\
    \x9c',\x90\x9c'.\x90\x9c'-\x90\x9c'\x13\x82\xd3\xe4\x93\x02;*9/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}\x98\x9c'\x05\x12\x92\x01\
    \n\x08PostApps\x12\x1d.clarifai.api.PostAppsRequest\x1a\x1e.clarifai.api\
    .MultiAppResponse\"G\x98\x9c'\x05\x90\x9c',\x90\x9c'-\x90\x9c'\x0f\x90\
    \x9c'\x13\x90\x9c'\x12\x82\xd3\xe4\x93\x02)\"$/v2/users/{user_app_id.use\
    r_id}/apps:\x01*\x12\x88\x01\n\tPatchApps\x12\x1e.clarifai.api.PatchApps\
    Request\x1a\x1e.clarifai.api.MultiAppResponse\";\x98\x9c'\x05\x82\xd3\
    \xe4\x93\x02)2$/v2/users/{user_app_id.user_id}/apps:\x01*\x90\x9c',\x90\
    \x9c'-\x12\x9f\x01\n\x10PostAppsSearches\x12%.clarifai.api.PostAppsSearc\
    hesRequest\x1a\x1e.clarifai.api.MultiAppResponse\"D\x98\x9c'\x05\x90\x9c\
    '-\x90\x9c'\x13\x82\xd3\xe4\x93\x022\"-/v2/users/{user_app_id.user_id}/a\
    pps/searches:\x01*\x12\xcf\x01\n\x14PostValidatePassword\x12).clarifai.a\
    pi.PostValidatePasswordRequest\x1a..clarifai.api.SinglePasswordValidatio\
    nResponse\"\\\x98\x9c'\x03\x82\xd3\xe4\x93\x02R\"1/v2/users/{user_app_id\
    .user_id}/validate_password:\x01*Z\x1a\"\x15/v2/validate_password:\x01*\
    \x12\xbd\x01\n\tGetSearch\x12\x1e.clarifai.api.GetSearchRequest\x1a\".cl\
    arifai.api.SingleSearchResponse\"l\x98\x9c'\x02\x82\xd3\xe4\x93\x02^\x12\
    G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}\
    Z\x13\x12\x11/v2/searches/{id}\x90\x9c'r\x12\xb8\x01\n\x0cListSearches\
    \x12!.clarifai.api.ListSearchesRequest\x1a!.clarifai.api.MultiSearchResp\
    onse\"b\x82\xd3\xe4\x93\x02T\x12B/v2/users/{user_app_id.user_id}/apps/{u\
    ser_app_id.app_id}/searchesZ\x0e\x12\x0c/v2/searches\x90\x9c'r\x98\x9c'\
    \x02\x12\xc4\x01\n\rPatchSearches\x12\".clarifai.api.PatchSearchesReques\
    t\x1a!.clarifai.api.MultiSearchResponse\"l\x98\x9c'\x02\x90\x9c's\x90\
    \x9c'r\x82\xd3\xe4\x93\x02Z2B/v2/users/{user_app_id.user_id}/apps/{user_\
    app_id.app_id}/searches:\x01*Z\x112\x0c/v2/searches:\x01*\x12\xd2\x01\n\
    \x0cPostSearches\x12!.clarifai.api.PostSearchesRequest\x1a!.clarifai.api\
    .MultiSearchResponse\"|\x98\x9c'\x02\x82\xd3\xe4\x93\x02Z\"B/v2/users/{u\
    ser_app_id.user_id}/apps/{user_app_id.app_id}/searches:\x01*Z\x11\"\x0c/\
    v2/searches:\x01*\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'\x0f\x90\
    \x9c'\x03\x90\x9c'\x13\x12\xd4\x01\n\x10PostSearchesByID\x12%.clarifai.a\
    pi.PostSearchesByIDRequest\x1a!.clarifai.api.MultiSearchResponse\"v\x82\
    \xd3\xe4\x93\x02d\"G/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/searches/{id}:\x01*Z\x16\"\x11/v2/searches/{id}:\x01*\x90\x9c'r\
    \x90\x9c'\x03\x98\x9c'\x02\x12\xaf\x02\n\x1bPostAnnotationSearchMetrics\
    \x120.clarifai.api.PostAnnotationSearchMetricsRequest\x1a2.clarifai.api.\
    MultiAnnotationSearchMetricsResponse\"\xa9\x01\x82\xd3\xe4\x93\x02\x82\
    \x01\"V/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotat\
    ions/searches/metrics:\x01*Z%\"\x20/v2/annotations/searches/metrics:\x01\
    *\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x90\x9c'6\x90\x9c'\x0f\
    \x90\x9c'\x13\x98\x9c'\x02\x12\xa5\x02\n\x1aGetAnnotationSearchMetrics\
    \x12/.clarifai.api.GetAnnotationSearchMetricsRequest\x1a2.clarifai.api.M\
    ultiAnnotationSearchMetricsResponse\"\xa1\x01\x90\x9c'&\x90\x9c'\x0b\x90\
    \x9c'\x05\x90\x9c'5\x82\xd3\xe4\x93\x02\x86\x01\x12[/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}Z\
    '\x12%/v2/annotations/searches/metrics/{id}\x98\x9c'\x02\x12\x9c\x02\n\
    \x1bListAnnotationSearchMetrics\x120.clarifai.api.ListAnnotationSearchMe\
    tricsRequest\x1a2.clarifai.api.MultiAnnotationSearchMetricsResponse\"\
    \x96\x01\x90\x9c'&\x90\x9c'\x0b\x90\x9c'\x05\x90\x9c'5\x98\x9c'\x02\x82\
    \xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/apps/{user_app_id.\
    app_id}/annotations/searches/metricsZ\"\x12\x20/v2/annotations/searches/\
    metrics\x12\x96\x02\n\x1dDeleteAnnotationSearchMetrics\x122.clarifai.api\
    .DeleteAnnotationSearchMetricsRequest\x1a!.clarifai.api.status.BaseRespo\
    nse\"\x9d\x01\x98\x9c'\x02\x90\x9c'5\x90\x9c'6\x90\x9c'?\x82\xd3\xe4\x93\
    \x02\x86\x01*[/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/\
    annotations/searches/metrics/{id}Z'*%/v2/annotations/searches/metrics/{i\
    d}\x12\xca\x01\n\x0cDeleteSearch\x12!.clarifai.api.DeleteSearchRequest\
    \x1a!.clarifai.api.status.BaseResponse\"t\x82\xd3\xe4\x93\x02^*G/v2/user\
    s/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}Z\x13*\
    \x11/v2/searches/{id}\x98\x9c'\x02\x90\x9c'r\x90\x9c's\x90\x9c't\x12|\n\
    \x0fListStatusCodes\x12$.clarifai.api.ListStatusCodesRequest\x1a%.clarif\
    ai.api.MultiStatusCodeResponse\"\x1c\x82\xd3\xe4\x93\x02\x12\x12\x10/v2/\
    status_codes\x98\x9c'\x01\x12\x8a\x01\n\rGetStatusCode\x12\".clarifai.ap\
    i.GetStatusCodeRequest\x1a&.clarifai.api.SingleStatusCodeResponse\"-\x98\
    \x9c'\x01\x82\xd3\xe4\x93\x02#\x12!/v2/status_codes/{status_code_id}\x12\
    \xbe\x01\n\x11ListCollaborators\x12&.clarifai.api.ListCollaboratorsReque\
    st\x1a(.clarifai.api.MultiCollaboratorsResponse\"W\x82\xd3\xe4\x93\x02I\
    \x12G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collabora\
    tors\x98\x9c'\x02\x90\x9c'2\x12\xc5\x01\n\x11PostCollaborators\x12&.clar\
    ifai.api.PostCollaboratorsRequest\x1a(.clarifai.api.MultiCollaboratorsRe\
    sponse\"^\x98\x9c'\x02\x90\x9c'3\x90\x9c'2\x82\xd3\xe4\x93\x02L\"G/v2/us\
    ers/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators:\x01*\
    \x12\xcb\x01\n\x12PatchCollaborators\x12'.clarifai.api.PatchCollaborator\
    sRequest\x1a(.clarifai.api.MultiCollaboratorsResponse\"b\x82\xd3\xe4\x93\
    \x02L2G/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collabo\
    rators:\x01*\x98\x9c'\x02\x90\x9c'3\x90\x9c'2\x90\x9c'4\x12\xce\x01\n\
    \x13DeleteCollaborators\x12(.clarifai.api.DeleteCollaboratorsRequest\x1a\
    !.clarifai.api.status.BaseResponse\"j\x90\x9c'3\x90\x9c'2\x90\x9c'4\x90\
    \x9c'7\x90\x9c'8\x82\xd3\xe4\x93\x02L*G/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/collaborators:\x01*\x98\x9c'\x02\x12\xa4\x01\n\
    \x12ListCollaborations\x12'.clarifai.api.ListCollaborationsRequest\x1a).\
    clarifai.api.MultiCollaborationsResponse\":\x82\xd3\xe4\x93\x020\x12./v2\
    /users/{user_app_id.user_id}/collaborations\x98\x9c'\x03\x12\xef\x01\n\
    \x13PostAppDuplications\x12(.clarifai.api.PostAppDuplicationsRequest\x1a\
    *.clarifai.api.MultiAppDuplicationsResponse\"\x81\x01\x82\xd3\xe4\x93\
    \x02K\"F/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/duplic\
    ations:\x01*\x98\x9c'\x02\x90\x9c'\x0e\x90\x9c'\x0f\x90\x9c'\x1a\x90\x9c\
    '\n\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'%\x90\x9c'&\x90\x9c'\
    \x12\x90\x9c'\x13\x12\xa5\x01\n\x13ListAppDuplications\x12(.clarifai.api\
    .ListAppDuplicationsRequest\x1a*.clarifai.api.MultiAppDuplicationsRespon\
    se\"8\x98\x9c'\x03\x82\xd3\xe4\x93\x02.\x12,/v2/users/{user_app_id.user_\
    id}/duplications\x12\xb6\x01\n\x11GetAppDuplication\x12&.clarifai.api.Ge\
    tAppDuplicationRequest\x1a*.clarifai.api.SingleAppDuplicationResponse\"M\
    \x98\x9c'\x03\x82\xd3\xe4\x93\x02C\x12A/v2/users/{user_app_id.user_id}/d\
    uplications/{app_duplication_id}\x12\xd5\x01\n\tPostTasks\x12\x1e.clarif\
    ai.api.PostTasksRequest\x1a\x1f.clarifai.api.MultiTaskResponse\"\x86\x01\
    \x82\xd3\xe4\x93\x02T\"?/v2/users/{user_app_id.user_id}/apps/{user_app_i\
    d.app_id}/tasks:\x01*Z\x0e\"\t/v2/tasks:\x01*\x90\x9c'7\x90\x9c'8\x90\
    \x9c'\x05\x90\x9c'\x03\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\
    \x90\x9c'%\x90\x9c'&\x98\x9c'\x02\x12\xfa\x01\n\x16GetTaskAnnotationCoun\
    t\x12!.clarifai.api.GetTaskCountRequest\x1a%.clarifai.api.SingleTaskCoun\
    tResponse\"\x95\x01\x90\x9c'8\x82\xd3\xe4\x93\x02\x86\x01\x12[/v2/users/\
    {user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/annotati\
    ons/countZ'\x12%/v2/tasks/{task_id}/annotations/count\x98\x9c'\x02\x12\
    \xea\x01\n\x11GetTaskInputCount\x12!.clarifai.api.GetTaskCountRequest\
    \x1a%.clarifai.api.SingleTaskCountResponse\"\x8a\x01\x98\x9c'\x02\x90\
    \x9c'8\x82\xd3\xe4\x93\x02|\x12V/v2/users/{user_app_id.user_id}/apps/{us\
    er_app_id.app_id}/tasks/{task_id}/inputs/countZ\"\x12\x20/v2/tasks/{task\
    _id}/inputs/count\x12\xcc\x01\n\x07GetTask\x12\x1c.clarifai.api.GetTaskR\
    equest\x1a\x20.clarifai.api.SingleTaskResponse\"\x80\x01\x98\x9c'\x02\
    \x82\xd3\xe4\x93\x02b\x12I/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/tasks/{task_id}Z\x15\x12\x13/v2/tasks/{task_id}\x90\x9c'8\
    \x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x12\xba\x01\n\tListTas\
    ks\x12\x1e.clarifai.api.ListTasksRequest\x1a\x1f.clarifai.api.MultiTaskR\
    esponse\"l\x90\x9c'8\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\
    \x82\xd3\xe4\x93\x02N\x12?/v2/users/{user_app_id.user_id}/apps/{user_app\
    _id.app_id}/tasksZ\x0b\x12\t/v2/tasks\x98\x9c'\x02\x12\xd3\x01\n\nPatchT\
    asks\x12\x1f.clarifai.api.PatchTasksRequest\x1a\x1f.clarifai.api.MultiTa\
    skResponse\"\x82\x01\x82\xd3\xe4\x93\x02T2?/v2/users/{user_app_id.user_i\
    d}/apps/{user_app_id.app_id}/tasks:\x01*Z\x0e2\t/v2/tasks:\x01*\x90\x9c'\
    7\x90\x9c'8\x90\x9c'\x05\x90\x9c'r\x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\
    \x0f\x90\x9c'%\x90\x9c'&\x98\x9c'\x02\x12\xbe\x01\n\x0bDeleteTasks\x12\
    \x20.clarifai.api.DeleteTasksRequest\x1a!.clarifai.api.status.BaseRespon\
    se\"j\x90\x9c'7\x90\x9c'8\x90\x9c'F\x82\xd3\xe4\x93\x02T*?/v2/users/{use\
    r_app_id.user_id}/apps/{user_app_id.app_id}/tasks:\x01*Z\x0e*\t/v2/tasks\
    :\x01*\x98\x9c'\x02\x12\xf5\x01\n\x0fPostLabelOrders\x12$.clarifai.api.P\
    ostLabelOrdersRequest\x1a%.clarifai.api.MultiLabelOrderResponse\"\x94\
    \x01\x98\x9c'\x02\x82\xd3\xe4\x93\x02b\"F/v2/users/{user_app_id.user_id}\
    /apps/{user_app_id.app_id}/label_orders:\x01*Z\x15\"\x10/v2/label_orders\
    :\x01*\x90\x9c'C\x90\x9c'D\x90\x9c'7\x90\x9c'8\x90\x9c'\x05\x90\x9c'r\
    \x90\x9c'\x0b\x90\x9c'\x13\x90\x9c'\x0f\x88\x9c'\0\x12\xf6\x01\n\rGetLab\
    elOrder\x12\".clarifai.api.GetLabelOrderRequest\x1a&.clarifai.api.Single\
    LabelOrderResponse\"\x98\x01\x98\x9c'\x02\x90\x9c'C\x90\x9c'\x0b\x90\x9c\
    '8\x82\xd3\xe4\x93\x02~\x12W/v2/users/{user_app_id.user_id}/apps/{user_a\
    pp_id.app_id}/label_orders/{label_order_id}Z#\x12!/v2/label_orders/{labe\
    l_order_id}\x88\x9c'\0\x12\xd6\x01\n\x0fListLabelOrders\x12$.clarifai.ap\
    i.ListLabelOrdersRequest\x1a%.clarifai.api.MultiLabelOrderResponse\"v\
    \x82\xd3\xe4\x93\x02\\\x12F/v2/users/{user_app_id.user_id}/apps/{user_ap\
    p_id.app_id}/label_ordersZ\x12\x12\x10/v2/label_orders\x98\x9c'\x02\x90\
    \x9c'C\x90\x9c'\x0b\x90\x9c'8\x88\x9c'\0\x12\xeb\x01\n\x10PatchLabelOrde\
    rs\x12%.clarifai.api.PatchLabelOrdersRequest\x1a%.clarifai.api.MultiLabe\
    lOrderResponse\"\x88\x01\x90\x9c'C\x90\x9c'D\x90\x9c'\x0b\x90\x9c'7\x90\
    \x9c'8\x90\x9c'F\x98\x9c'\x02\x82\xd3\xe4\x93\x02b2F/v2/users/{user_app_\
    id.user_id}/apps/{user_app_id.app_id}/label_orders:\x01*Z\x152\x10/v2/la\
    bel_orders:\x01*\x88\x9c'\0\x12\xe5\x01\n\x11DeleteLabelOrders\x12&.clar\
    ifai.api.DeleteLabelOrdersRequest\x1a!.clarifai.api.status.BaseResponse\
    \"\x84\x01\x88\x9c'\0\x98\x9c'\x02\x90\x9c'E\x90\x9c'C\x90\x9c'D\x90\x9c\
    '7\x90\x9c'8\x82\xd3\xe4\x93\x02b*F/v2/users/{user_app_id.user_id}/apps/\
    {user_app_id.app_id}/label_orders:\x01*Z\x15*\x10/v2/label_orders:\x01*\
    \x12\xee\x01\n\x0ePostCollectors\x12#.clarifai.api.PostCollectorsRequest\
    \x1a$.clarifai.api.MultiCollectorResponse\"\x90\x01\x98\x9c'\x02\x82\xd3\
    \xe4\x93\x02^\"D/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/collectors:\x01*Z\x13\"\x0e/v2/collectors:\x01*\x90\x9c'\x04\x90\x9c'%\
    \x90\x9c'&\x90\x9c')\x90\x9c'\x0b\x90\x9c'\x04\x90\x9c'\x05\x90\x9c'\x0f\
    \x90\x9c'\x02\x90\x9c'\x13\x12\xdf\x01\n\x0cGetCollector\x12!.clarifai.a\
    pi.GetCollectorRequest\x1a%.clarifai.api.SingleCollectorResponse\"\x84\
    \x01\x82\xd3\xe4\x93\x02v\x12S/v2/users/{user_app_id.user_id}/apps/{user\
    _app_id.app_id}/collectors/{collector_id}Z\x1f\x12\x1d/v2/collectors/{co\
    llector_id}\x98\x9c'\x02\x90\x9c'*\x12\xc3\x01\n\x0eListCollectors\x12#.\
    clarifai.api.ListCollectorsRequest\x1a$.clarifai.api.MultiCollectorRespo\
    nse\"f\x98\x9c'\x02\x82\xd3\xe4\x93\x02X\x12D/v2/users/{user_app_id.user\
    _id}/apps/{user_app_id.app_id}/collectorsZ\x10\x12\x0e/v2/collectors\x90\
    \x9c'*\x12\xcf\x01\n\x0fPatchCollectors\x12$.clarifai.api.PatchCollector\
    sRequest\x1a$.clarifai.api.MultiCollectorResponse\"p\x98\x9c'\x02\x90\
    \x9c')\x90\x9c'*\x82\xd3\xe4\x93\x02^2D/v2/users/{user_app_id.user_id}/a\
    pps/{user_app_id.app_id}/collectors:\x01*Z\x132\x0e/v2/collectors:\x01*\
    \x12\xd2\x01\n\x10DeleteCollectors\x12%.clarifai.api.DeleteCollectorsReq\
    uest\x1a!.clarifai.api.status.BaseResponse\"t\x82\xd3\xe4\x93\x02^*D/v2/\
    users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors:\x01*Z\
    \x13*\x0e/v2/collectors:\x01*\x98\x9c'\x02\x90\x9c')\x90\x9c'+\x90\x9c'*\
    \x12\xc9\x01\n\x0ePostStatValues\x12#.clarifai.api.PostStatValuesRequest\
    \x1a$.clarifai.api.MultiStatValueResponse\"l\x98\x9c'\x02\x82\xd3\xe4\
    \x93\x02b\"F/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/st\
    ats/values:\x01*Z\x15\"\x10/v2/stats/values:\x01*\x12\xf9\x01\n\x17PostS\
    tatValuesAggregate\x12,.clarifai.api.PostStatValuesAggregateRequest\x1a-\
    .clarifai.api.MultiStatValueAggregateResponse\"\x80\x01\x98\x9c'\x02\x82\
    \xd3\xe4\x93\x02v\"P/v2/users/{user_app_id.user_id}/apps/{user_app_id.ap\
    p_id}/stats/values/aggregate:\x01*Z\x1f\"\x1a/v2/stats/values/aggregate:\
    \x01*\x12\xe3\x01\n\x17PostTrendingMetricsView\x12,.clarifai.api.PostTre\
    ndingMetricsViewRequest\x1a!.clarifai.api.status.BaseResponse\"w\x82\xd3\
    \xe4\x93\x02m\"h/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id\
    }/trending_metrics/views/{view_type}/{object_id}:\x01*\x98\x9c'\x02\x12\
    \x8f\x02\n\x18ListTrendingMetricsViews\x12-.clarifai.api.ListTrendingMet\
    ricsViewsRequest\x1a..clarifai.api.MultiTrendingMetricsViewResponse\"\
    \x93\x01\x82\xd3\xe4\x93\x02\x88\x01\x12\\/v2/users/{user_app_id.user_id\
    }/apps/{user_app_id.app_id}/trending_metrics/views/{view_type}Z(\x12&/v2\
    /trending_metrics/views/{view_type}\x98\x9c'\x02B]\n\x15com.clarifai.grp\
    c.apiP\x01Z;github.com/Clarifai/clarifai-go-grpc/proto/clarifai/api/api\
    \xa2\x02\x04CAIPJ\x8f\x9a\x07\n\x07\x12\x05\x02\0\xf6\"\x01\n\x08\n\x01\
    \x0c\x12\x03\x02\0\x12\n\t\n\x02\x03\0\x12\x03\x04\0,\n\t\n\x02\x03\x01\
    \x12\x03\x05\00\n\t\n\x02\x03\x02\x12\x03\x06\03\n\t\n\x02\x03\x03\x12\
    \x03\x07\0/\n\t\n\x02\x03\x04\x12\x03\x08\02\n\t\n\x02\x03\x05\x12\x03\t\
    \05\n\t\n\x02\x03\x06\x12\x03\x0c\0&\n\t\n\x02\x03\x07\x12\x03\r\0(\n\t\
    \n\x02\x03\x08\x12\x03\x0e\0&\n\t\n\x02\x03\t\x12\x03\x0f\0)\n\x08\n\x01\
    \x02\x12\x03\x12\0\x15\n\x08\n\x01\x08\x12\x03\x14\0R\n\t\n\x02\x08\x0b\
    \x12\x03\x14\0R\n\x08\n\x01\x08\x12\x03\x15\0\"\n\t\n\x02\x08\n\x12\x03\
    \x15\0\"\n\x08\n\x01\x08\x12\x03\x16\0.\n\t\n\x02\x08\x01\x12\x03\x16\0.\
    \n\x08\n\x01\x08\x12\x03\x17\0\"\n\t\n\x02\x08$\x12\x03\x17\0\"\n\xfa\
    \x01\n\x02\x06\0\x12\x05!\0\xca\x11\x012\xec\x01\nNote:\x20this\x20is\
    \x20based\x20on\x20the\x20google\x20api\x20format\x20defined\x20here.\
    \x20Please\nread\x20this\x20before\x20contributing\x20to\x20this\x20file\
    \x20and\x20other\x20*.proto\x20files\nfor\x20the\x20API.\nhttps://cloud.\
    google.com/service-management/reference/rpc/google.api#google.api.HttpRu\
    le\n\n\n\n\x03\x06\0\x01\x12\x03!\x08\n\n\xdd\x01\n\x04\x06\0\x02\0\x12\
    \x04(\x021\x03\x1a\xce\x01\x20List\x20concept\x20relations\x20between\
    \x20concepts\x20in\x20the\x20platform.\n\x20MUST\x20be\x20above\x20ListC\
    oncepts\x20so\x20that\x20if\x20concept_id\x20is\x20empty\x20this\x20will\
    \x20still\x20match\n\x20/concepts/relations\x20to\x20list\x20all\x20the\
    \x20concept\x20relations\x20in\x20the\x20app.\n\n\x0c\n\x05\x06\0\x02\0\
    \x01\x12\x03(\x06\x1a\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03(\x1c7\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x03(B^\n\r\n\x05\x06\0\x02\0\x04\x12\x04)\x04.\
    \x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04)\x04.\x06\n\x0c\n\
    \x05\x06\0\x02\0\x04\x12\x03/\x047\n\x0f\n\x08\x06\0\x02\0\x04\xc3\xf3\
    \x04\x12\x03/\x047\n\x0c\n\x05\x06\0\x02\0\x04\x12\x030\x04C\n\x10\n\t\
    \x06\0\x02\0\x04\xc2\xf3\x04\0\x12\x030\x04C\n\\\n\x04\x06\0\x02\x01\x12\
    \x046\x02>\x03\x1aN\x20Post\x20concept\x20relations\x20to\x20create\x20r\
    elations\x20between\x20concepts\x20in\x20the\x20platform.\n\n\x0c\n\x05\
    \x06\0\x02\x01\x01\x12\x036\x06\x1a\n\x0c\n\x05\x06\0\x02\x01\x02\x12\
    \x036\x1c7\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x036B^\n\r\n\x05\x06\0\x02\
    \x01\x04\x12\x047\x04:\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\
    \x047\x04:\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03;\x047\n\x0f\n\x08\
    \x06\0\x02\x01\x04\xc3\xf3\x04\x12\x03;\x047\n\x0c\n\x05\x06\0\x02\x01\
    \x04\x12\x03<\x04C\n\x10\n\t\x06\0\x02\x01\x04\xc2\xf3\x04\0\x12\x03<\
    \x04C\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03=\x04C\n\x10\n\t\x06\0\x02\
    \x01\x04\xc2\xf3\x04\x01\x12\x03=\x04C\n\\\n\x04\x06\0\x02\x02\x12\x04A\
    \x02J\x03\x1aN\x20Post\x20concept\x20relations\x20to\x20create\x20relati\
    ons\x20between\x20concepts\x20in\x20the\x20platform.\n\n\x0c\n\x05\x06\0\
    \x02\x02\x01\x12\x03A\x06\x1c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03A\x1e\
    ;\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03AFf\n\r\n\x05\x06\0\x02\x02\x04\
    \x12\x04B\x04E\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04B\
    \x04E\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03F\x047\n\x0f\n\x08\x06\0\
    \x02\x02\x04\xc3\xf3\x04\x12\x03F\x047\n\x0c\n\x05\x06\0\x02\x02\x04\x12\
    \x03G\x04F\n\x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\0\x12\x03G\x04F\n\x0c\
    \n\x05\x06\0\x02\x02\x04\x12\x03H\x04C\n\x10\n\t\x06\0\x02\x02\x04\xc2\
    \xf3\x04\x01\x12\x03H\x04C\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03I\x04C\n\
    \x10\n\t\x06\0\x02\x02\x04\xc2\xf3\x04\x02\x12\x03I\x04C\nM\n\x04\x06\0\
    \x02\x03\x12\x04M\x02X\x03\x1a?\x20List\x20all\x20the\x20concepts\x20wit\
    h\x20their\x20positive\x20and\x20negative\x20counts\n\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x03M\x06\x16\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03M\x18\
    /\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03M:S\n\r\n\x05\x06\0\x02\x03\x04\
    \x12\x04N\x04S\x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04N\
    \x04S\x06\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03T\x047\n\x0f\n\x08\x06\0\
    \x02\x03\x04\xc3\xf3\x04\x12\x03T\x047\n\x0c\n\x05\x06\0\x02\x03\x04\x12\
    \x03U\x04F\n\x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\0\x12\x03U\x04F\n\x0c\
    \n\x05\x06\0\x02\x03\x04\x12\x03V\x04C\n\x10\n\t\x06\0\x02\x03\x04\xc2\
    \xf3\x04\x01\x12\x03V\x04C\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03W\x04A\n\
    \x10\n\t\x06\0\x02\x03\x04\xc2\xf3\x04\x02\x12\x03W\x04A\n3\n\x04\x06\0\
    \x02\x04\x12\x04[\x02d\x03\x1a%\x20Get\x20a\x20specific\x20concept\x20fr\
    om\x20an\x20app.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03[\x06\x10\n\x0c\
    \n\x05\x06\0\x02\x04\x02\x12\x03[\x12#\n\x0c\n\x05\x06\0\x02\x04\x03\x12\
    \x03[.C\n\r\n\x05\x06\0\x02\x04\x04\x12\x04\\\x04a\x06\n\x11\n\t\x06\0\
    \x02\x04\x04\xb0\xca\xbc\"\x12\x04\\\x04a\x06\n\x0c\n\x05\x06\0\x02\x04\
    \x04\x12\x03b\x047\n\x0f\n\x08\x06\0\x02\x04\x04\xc3\xf3\x04\x12\x03b\
    \x047\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03c\x04C\n\x10\n\t\x06\0\x02\
    \x04\x04\xc2\xf3\x04\0\x12\x03c\x04C\n&\n\x04\x06\0\x02\x05\x12\x04g\x02\
    p\x03\x1a\x18\x20List\x20all\x20the\x20concepts.\n\n\x0c\n\x05\x06\0\x02\
    \x05\x01\x12\x03g\x06\x12\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03g\x14'\n\
    \x0c\n\x05\x06\0\x02\x05\x03\x12\x03g2F\n\r\n\x05\x06\0\x02\x05\x04\x12\
    \x04h\x04m\x06\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x04h\x04m\
    \x06\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03n\x047\n\x0f\n\x08\x06\0\x02\
    \x05\x04\xc3\xf3\x04\x12\x03n\x047\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03\
    o\x04C\n\x10\n\t\x06\0\x02\x05\x04\xc2\xf3\x04\0\x12\x03o\x04C\n\xcc\x01\
    \n\x04\x06\0\x02\x06\x12\x05u\x02\x82\x01\x03\x1a\xbc\x01\x20Search\x20o\
    ver\x20the\x20concepts\x20to\x20find\x20one\x20or\x20more\x20you're\x20l\
    ooking\x20for.\n\x20This\x20leverage\x20the\x20\"body\"\x20parameter\x20\
    because\x20we\x20also\x20have\x20page\x20and\n\x20per_page\x20as\x20url\
    \x20query\x20param\x20variables\x20in\x20this\x20request.\n\n\x0c\n\x05\
    \x06\0\x02\x06\x01\x12\x03u\x06\x1a\n\x0c\n\x05\x06\0\x02\x06\x02\x12\
    \x03u\x1c7\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03uBV\n\r\n\x05\x06\0\x02\
    \x06\x04\x12\x04v\x04}\x06\n\x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\
    \x04v\x04}\x06\n\x0c\n\x05\x06\0\x02\x06\x04\x12\x03~\x047\n\x0f\n\x08\
    \x06\0\x02\x06\x04\xc3\xf3\x04\x12\x03~\x047\n\x0c\n\x05\x06\0\x02\x06\
    \x04\x12\x03\x7f\x04C\n\x10\n\t\x06\0\x02\x06\x04\xc2\xf3\x04\0\x12\x03\
    \x7f\x04C\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x80\x01\x04A\n\x11\n\t\x06\
    \0\x02\x06\x04\xc2\xf3\x04\x01\x12\x04\x80\x01\x04A\n\r\n\x05\x06\0\x02\
    \x06\x04\x12\x04\x81\x01\x04D\nP\n\t\x06\0\x02\x06\x04\xc2\xf3\x04\x02\
    \x12\x04\x81\x01\x04D\"=\x20as\x20it\x20needs\x20to\x20know\x20the\x20co\
    ncepts\x20in\x20your\x20workflow's\x20models.\n\n*\n\x04\x06\0\x02\x07\
    \x12\x06\x85\x01\x02\x91\x01\x03\x1a\x1a\x20Add\x20a\x20concept\x20to\
    \x20an\x20app.\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\x85\x01\x06\x12\n\r\
    \n\x05\x06\0\x02\x07\x02\x12\x04\x85\x01\x14'\n\r\n\x05\x06\0\x02\x07\
    \x03\x12\x04\x85\x012F\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x86\x01\x04\
    \x8d\x01\x06\n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\x86\x01\
    \x04\x8d\x01\x06\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\x8e\x01\x047\n\x10\
    \n\x08\x06\0\x02\x07\x04\xc3\xf3\x04\x12\x04\x8e\x01\x047\n\r\n\x05\x06\
    \0\x02\x07\x04\x12\x04\x8f\x01\x04C\n\x11\n\t\x06\0\x02\x07\x04\xc2\xf3\
    \x04\0\x12\x04\x8f\x01\x04C\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\x90\x01\
    \x04C\n\x11\n\t\x06\0\x02\x07\x04\xc2\xf3\x04\x01\x12\x04\x90\x01\x04C\n\
    -\n\x04\x06\0\x02\x08\x12\x06\x94\x01\x02\xa0\x01\x03\x1a\x1d\x20Patch\
    \x20one\x20or\x20more\x20concepts.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\
    \x94\x01\x06\x13\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\x94\x01\x15)\n\r\n\
    \x05\x06\0\x02\x08\x03\x12\x04\x94\x014H\n\x0f\n\x05\x06\0\x02\x08\x04\
    \x12\x06\x95\x01\x04\x9c\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\
    \"\x12\x06\x95\x01\x04\x9c\x01\x06\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\
    \x9d\x01\x047\n\x10\n\x08\x06\0\x02\x08\x04\xc3\xf3\x04\x12\x04\x9d\x01\
    \x047\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\x9e\x01\x04C\n\x11\n\t\x06\0\
    \x02\x08\x04\xc2\xf3\x04\0\x12\x04\x9e\x01\x04C\n\r\n\x05\x06\0\x02\x08\
    \x04\x12\x04\x9f\x01\x04C\n\x11\n\t\x06\0\x02\x08\x04\xc2\xf3\x04\x01\
    \x12\x04\x9f\x01\x04C\n5\n\x04\x06\0\x02\t\x12\x06\xad\x01\x02\xb6\x01\
    \x03\x1a%\x20Get\x20a\x20specific\x20concept\x20from\x20an\x20app.\n\n\r\
    \n\x05\x06\0\x02\t\x01\x12\x04\xad\x01\x06\x18\n\r\n\x05\x06\0\x02\t\x02\
    \x12\x04\xad\x01\x1a3\n\r\n\x05\x06\0\x02\t\x03\x12\x04\xad\x01>[\n\x0f\
    \n\x05\x06\0\x02\t\x04\x12\x06\xae\x01\x04\xb3\x01\x06\n\x13\n\t\x06\0\
    \x02\t\x04\xb0\xca\xbc\"\x12\x06\xae\x01\x04\xb3\x01\x06\n\r\n\x05\x06\0\
    \x02\t\x04\x12\x04\xb4\x01\x047\n\x10\n\x08\x06\0\x02\t\x04\xc3\xf3\x04\
    \x12\x04\xb4\x01\x047\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xb5\x01\x04C\n\
    \x11\n\t\x06\0\x02\t\x04\xc2\xf3\x04\0\x12\x04\xb5\x01\x04C\nC\n\x04\x06\
    \0\x02\n\x12\x06\xb9\x01\x02\xc2\x01\x03\x1a3\x20List\x20the\x20concept\
    \x20in\x20all\x20the\x20translated\x20languages.\n\n\r\n\x05\x06\0\x02\n\
    \x01\x12\x04\xb9\x01\x06\x1a\n\r\n\x05\x06\0\x02\n\x02\x12\x04\xb9\x01\
    \x1c7\n\r\n\x05\x06\0\x02\n\x03\x12\x04\xb9\x01B^\n\x0f\n\x05\x06\0\x02\
    \n\x04\x12\x06\xba\x01\x04\xbf\x01\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\
    \xbc\"\x12\x06\xba\x01\x04\xbf\x01\x06\n\r\n\x05\x06\0\x02\n\x04\x12\x04\
    \xc0\x01\x047\n\x10\n\x08\x06\0\x02\n\x04\xc3\xf3\x04\x12\x04\xc0\x01\
    \x047\n\r\n\x05\x06\0\x02\n\x04\x12\x04\xc1\x01\x04C\n\x11\n\t\x06\0\x02\
    \n\x04\xc2\xf3\x04\0\x12\x04\xc1\x01\x04C\n9\n\x04\x06\0\x02\x0b\x12\x06\
    \xc5\x01\x02\xd1\x01\x03\x1a)\x20Add\x20a\x20new\x20translation\x20for\
    \x20this\x20concept.\n\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\xc5\x01\x06\
    \x1a\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\xc5\x01\x1c7\n\r\n\x05\x06\0\
    \x02\x0b\x03\x12\x04\xc5\x01B^\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xc6\
    \x01\x04\xcd\x01\x06\n\x13\n\t\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\
    \xc6\x01\x04\xcd\x01\x06\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xce\x01\x04\
    7\n\x10\n\x08\x06\0\x02\x0b\x04\xc3\xf3\x04\x12\x04\xce\x01\x047\n\r\n\
    \x05\x06\0\x02\x0b\x04\x12\x04\xcf\x01\x04C\n\x11\n\t\x06\0\x02\x0b\x04\
    \xc2\xf3\x04\0\x12\x04\xcf\x01\x04C\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\
    \xd0\x01\x04C\n\x11\n\t\x06\0\x02\x0b\x04\xc2\xf3\x04\x01\x12\x04\xd0\
    \x01\x04C\n\x83\x01\n\x04\x06\0\x02\x0c\x12\x06\xd5\x01\x02\xe1\x01\x03\
    \x1as\x20Patch\x20the\x20name\x20for\x20a\x20given\x20language\x20names\
    \x20by\x20passing\x20in\x20a\x20list\x20of\x20concepts\x20with\x20the\
    \x20new\x20names\n\x20for\x20the\x20languages.\n\n\r\n\x05\x06\0\x02\x0c\
    \x01\x12\x04\xd5\x01\x06\x1b\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xd5\x01\
    \x1d9\n\r\n\x05\x06\0\x02\x0c\x03\x12\x04\xd5\x01D`\n\x0f\n\x05\x06\0\
    \x02\x0c\x04\x12\x06\xd6\x01\x04\xdd\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\
    \xb0\xca\xbc\"\x12\x06\xd6\x01\x04\xdd\x01\x06\n\r\n\x05\x06\0\x02\x0c\
    \x04\x12\x04\xde\x01\x047\n\x10\n\x08\x06\0\x02\x0c\x04\xc3\xf3\x04\x12\
    \x04\xde\x01\x047\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xdf\x01\x04C\n\x11\
    \n\t\x06\0\x02\x0c\x04\xc2\xf3\x04\0\x12\x04\xdf\x01\x04C\n\r\n\x05\x06\
    \0\x02\x0c\x04\x12\x04\xe0\x01\x04C\n\x11\n\t\x06\0\x02\x0c\x04\xc2\xf3\
    \x04\x01\x12\x04\xe0\x01\x04C\n)\n\x04\x06\0\x02\r\x12\x06\xe7\x01\x02\
    \xf0\x01\x03\x1a\x19\x20List\x20all\x20domain\x20graphs.\n\n\r\n\x05\x06\
    \0\x02\r\x01\x12\x04\xe7\x01\x06\x19\n\r\n\x05\x06\0\x02\r\x02\x12\x04\
    \xe7\x01\x1b5\n\r\n\x05\x06\0\x02\r\x03\x12\x04\xe7\x01@[\n\x0f\n\x05\
    \x06\0\x02\r\x04\x12\x06\xe8\x01\x04\xed\x01\x06\n\x13\n\t\x06\0\x02\r\
    \x04\xb0\xca\xbc\"\x12\x06\xe8\x01\x04\xed\x01\x06\n\r\n\x05\x06\0\x02\r\
    \x04\x12\x04\xee\x01\x047\n\x10\n\x08\x06\0\x02\r\x04\xc3\xf3\x04\x12\
    \x04\xee\x01\x047\n\r\n\x05\x06\0\x02\r\x04\x12\x04\xef\x01\x04C\n\x11\n\
    \t\x06\0\x02\r\x04\xc2\xf3\x04\0\x12\x04\xef\x01\x04C\n%\n\x04\x06\0\x02\
    \x0e\x12\x06\xf3\x01\x02\xff\x01\x03\x1a\x15\x20Post\x20domain\x20graphs\
    .\n\n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\xf3\x01\x06\x19\n\r\n\x05\x06\0\
    \x02\x0e\x02\x12\x04\xf3\x01\x1b5\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\
    \xf3\x01@[\n\x0f\n\x05\x06\0\x02\x0e\x04\x12\x06\xf4\x01\x04\xfb\x01\x06\
    \n\x13\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\x06\xf4\x01\x04\xfb\x01\
    \x06\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\xfc\x01\x047\n\x10\n\x08\x06\0\
    \x02\x0e\x04\xc3\xf3\x04\x12\x04\xfc\x01\x047\n\r\n\x05\x06\0\x02\x0e\
    \x04\x12\x04\xfd\x01\x04C\n\x11\n\t\x06\0\x02\x0e\x04\xc2\xf3\x04\0\x12\
    \x04\xfd\x01\x04C\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\xfe\x01\x04C\n\x11\
    \n\t\x06\0\x02\x0e\x04\xc2\xf3\x04\x01\x12\x04\xfe\x01\x04C\n-\n\x04\x06\
    \0\x02\x0f\x12\x06\x82\x02\x02\x8e\x02\x03\x1a\x1d\x20Start\x20concept\
    \x20mapping\x20jobs.\n\n\r\n\x05\x06\0\x02\x0f\x01\x12\x04\x82\x02\x06\
    \x1c\n\r\n\x05\x06\0\x02\x0f\x02\x12\x04\x82\x02\x1e;\n\r\n\x05\x06\0\
    \x02\x0f\x03\x12\x04\x82\x02Fd\n\x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\x83\
    \x02\x04\x8a\x02\x06\n\x13\n\t\x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\
    \x83\x02\x04\x8a\x02\x06\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\x8b\x02\x04\
    7\n\x10\n\x08\x06\0\x02\x0f\x04\xc3\xf3\x04\x12\x04\x8b\x02\x047\n\r\n\
    \x05\x06\0\x02\x0f\x04\x12\x04\x8c\x02\x04C\n\x11\n\t\x06\0\x02\x0f\x04\
    \xc2\xf3\x04\0\x12\x04\x8c\x02\x04C\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\
    \x8d\x02\x04C\n\x11\n\t\x06\0\x02\x0f\x04\xc2\xf3\x04\x01\x12\x04\x8d\
    \x02\x04C\n8\n\x04\x06\0\x02\x10\x12\x06\x93\x02\x02\x9e\x02\x03\x1a(\
    \x20Get\x20a\x20specific\x20annotation\x20from\x20an\x20app.\n\n\r\n\x05\
    \x06\0\x02\x10\x01\x12\x04\x93\x02\x06\x13\n\r\n\x05\x06\0\x02\x10\x02\
    \x12\x04\x93\x02\x15)\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\x93\x024L\n\
    \x0f\n\x05\x06\0\x02\x10\x04\x12\x06\x94\x02\x04\x99\x02\x06\n\x13\n\t\
    \x06\0\x02\x10\x04\xb0\xca\xbc\"\x12\x06\x94\x02\x04\x99\x02\x06\n\r\n\
    \x05\x06\0\x02\x10\x04\x12\x04\x9a\x02\x047\n\x10\n\x08\x06\0\x02\x10\
    \x04\xc3\xf3\x04\x12\x04\x9a\x02\x047\n\r\n\x05\x06\0\x02\x10\x04\x12\
    \x04\x9b\x02\x04F\n\x11\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\0\x12\x04\x9b\
    \x02\x04F\n\r\n\x05\x06\0\x02\x10\x04\x12\x04\x9c\x02\x04C\n\x11\n\t\x06\
    \0\x02\x10\x04\xc2\xf3\x04\x01\x12\x04\x9c\x02\x04C\n\r\n\x05\x06\0\x02\
    \x10\x04\x12\x04\x9d\x02\x04A\n5\n\t\x06\0\x02\x10\x04\xc2\xf3\x04\x02\
    \x12\x04\x9d\x02\x04A\"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20\
    worker.\n\n*\n\x04\x06\0\x02\x11\x12\x06\xa1\x02\x02\xac\x02\x03\x1a\x1a\
    \x20List\x20all\x20the\x20annotation.\n\n\r\n\x05\x06\0\x02\x11\x01\x12\
    \x04\xa1\x02\x06\x15\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\xa1\x02\x17-\n\
    \r\n\x05\x06\0\x02\x11\x03\x12\x04\xa1\x028O\n\x0f\n\x05\x06\0\x02\x11\
    \x04\x12\x06\xa2\x02\x04\xa7\x02\x06\n\x13\n\t\x06\0\x02\x11\x04\xb0\xca\
    \xbc\"\x12\x06\xa2\x02\x04\xa7\x02\x06\n\r\n\x05\x06\0\x02\x11\x04\x12\
    \x04\xa8\x02\x047\n\x10\n\x08\x06\0\x02\x11\x04\xc3\xf3\x04\x12\x04\xa8\
    \x02\x047\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xa9\x02\x04F\n\x11\n\t\x06\
    \0\x02\x11\x04\xc2\xf3\x04\0\x12\x04\xa9\x02\x04F\n\r\n\x05\x06\0\x02\
    \x11\x04\x12\x04\xaa\x02\x04C\n\x11\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\
    \x01\x12\x04\xaa\x02\x04C\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\xab\x02\
    \x04A\n5\n\t\x06\0\x02\x11\x04\xc2\xf3\x04\x02\x12\x04\xab\x02\x04A\"\"\
    \x20to\x20get\x20the\x20model\x20for\x20the\x20worker.\n\n#\n\x04\x06\0\
    \x02\x12\x12\x06\xaf\x02\x02\xbf\x02\x03\x1a\x13\x20Post\x20annotations.\
    \n\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\xaf\x02\x06\x15\n\r\n\x05\x06\0\
    \x02\x12\x02\x12\x04\xaf\x02\x17-\n\r\n\x05\x06\0\x02\x12\x03\x12\x04\
    \xaf\x028O\n\x0f\n\x05\x06\0\x02\x12\x04\x12\x06\xb0\x02\x04\xb7\x02\x06\
    \n\x13\n\t\x06\0\x02\x12\x04\xb0\xca\xbc\"\x12\x06\xb0\x02\x04\xb7\x02\
    \x06\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xb8\x02\x047\n\x10\n\x08\x06\0\
    \x02\x12\x04\xc3\xf3\x04\x12\x04\xb8\x02\x047\n\r\n\x05\x06\0\x02\x12\
    \x04\x12\x04\xb9\x02\x04A\n\x11\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\0\x12\
    \x04\xb9\x02\x04A\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xba\x02\x04F\n\x11\
    \n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x01\x12\x04\xba\x02\x04F\n\r\n\x05\
    \x06\0\x02\x12\x04\x12\x04\xbb\x02\x04F\n\x11\n\t\x06\0\x02\x12\x04\xc2\
    \xf3\x04\x02\x12\x04\xbb\x02\x04F\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\
    \xbc\x02\x04C\n\x11\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x03\x12\x04\xbc\
    \x02\x04C\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\xbd\x02\x04A\n\x11\n\t\x06\
    \0\x02\x12\x04\xc2\xf3\x04\x04\x12\x04\xbd\x02\x04A\n\r\n\x05\x06\0\x02\
    \x12\x04\x12\x04\xbe\x02\x04D\nA\n\t\x06\0\x02\x12\x04\xc2\xf3\x04\x05\
    \x12\x04\xbe\x02\x04D\".\x20to\x20know\x20the\x20models\x20in\x20your\
    \x20default\x20workflow.\n\n0\n\x04\x06\0\x02\x13\x12\x06\xc2\x02\x02\
    \xd2\x02\x03\x1a\x20\x20Patch\x20one\x20or\x20more\x20annotations.\n\n\r\
    \n\x05\x06\0\x02\x13\x01\x12\x04\xc2\x02\x06\x16\n\r\n\x05\x06\0\x02\x13\
    \x02\x12\x04\xc2\x02\x18/\n\r\n\x05\x06\0\x02\x13\x03\x12\x04\xc2\x02:Q\
    \n\x0f\n\x05\x06\0\x02\x13\x04\x12\x06\xc3\x02\x04\xca\x02\x06\n\x13\n\t\
    \x06\0\x02\x13\x04\xb0\xca\xbc\"\x12\x06\xc3\x02\x04\xca\x02\x06\n\r\n\
    \x05\x06\0\x02\x13\x04\x12\x04\xcb\x02\x047\n\x10\n\x08\x06\0\x02\x13\
    \x04\xc3\xf3\x04\x12\x04\xcb\x02\x047\n\r\n\x05\x06\0\x02\x13\x04\x12\
    \x04\xcc\x02\x04A\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\0\x12\x04\xcc\
    \x02\x04A\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xcd\x02\x04F\n\x11\n\t\x06\
    \0\x02\x13\x04\xc2\xf3\x04\x01\x12\x04\xcd\x02\x04F\n\r\n\x05\x06\0\x02\
    \x13\x04\x12\x04\xce\x02\x04F\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\
    \x02\x12\x04\xce\x02\x04F\n\r\n\x05\x06\0\x02\x13\x04\x12\x04\xcf\x02\
    \x04C\n\x11\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x03\x12\x04\xcf\x02\x04C\n\
    \r\n\x05\x06\0\x02\x13\x04\x12\x04\xd0\x02\x04D\nA\n\t\x06\0\x02\x13\x04\
    \xc2\xf3\x04\x04\x12\x04\xd0\x02\x04D\".\x20to\x20know\x20the\x20models\
    \x20in\x20your\x20default\x20workflow.\n\n\r\n\x05\x06\0\x02\x13\x04\x12\
    \x04\xd1\x02\x04A\n5\n\t\x06\0\x02\x13\x04\xc2\xf3\x04\x05\x12\x04\xd1\
    \x02\x04A\"\"\x20to\x20get\x20the\x20model\x20for\x20the\x20worker.\n\nD\
    \n\x04\x06\0\x02\x14\x12\x06\xd5\x02\x02\xe0\x02\x03\x1a4\x20Patch\x20an\
    notations\x20status\x20by\x20worker\x20id\x20and\x20task\x20id.\n\n\r\n\
    \x05\x06\0\x02\x14\x01\x12\x04\xd5\x02\x06\x1c\n\r\n\x05\x06\0\x02\x14\
    \x02\x12\x04\xd5\x02\x1e;\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\xd5\x02Fd\
    \n\x0f\n\x05\x06\0\x02\x14\x04\x12\x06\xd6\x02\x04\xd9\x02\x06\n\x13\n\t\
    \x06\0\x02\x14\x04\xb0\xca\xbc\"\x12\x06\xd6\x02\x04\xd9\x02\x06\n\r\n\
    \x05\x06\0\x02\x14\x04\x12\x04\xda\x02\x047\n\x10\n\x08\x06\0\x02\x14\
    \x04\xc3\xf3\x04\x12\x04\xda\x02\x047\n\r\n\x05\x06\0\x02\x14\x04\x12\
    \x04\xdb\x02\x04F\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\0\x12\x04\xdb\
    \x02\x04F\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xdc\x02\x04F\n\x11\n\t\x06\
    \0\x02\x14\x04\xc2\xf3\x04\x01\x12\x04\xdc\x02\x04F\n\r\n\x05\x06\0\x02\
    \x14\x04\x12\x04\xdd\x02\x04C\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\
    \x02\x12\x04\xdd\x02\x04C\n\r\n\x05\x06\0\x02\x14\x04\x12\x04\xde\x02\
    \x04D\n\x11\n\t\x06\0\x02\x14\x04\xc2\xf3\x04\x03\x12\x04\xde\x02\x04D\n\
    \r\n\x05\x06\0\x02\x14\x04\x12\x04\xdf\x02\x04A\n\x11\n\t\x06\0\x02\x14\
    \x04\xc2\xf3\x04\x04\x12\x04\xdf\x02\x04A\n-\n\x04\x06\0\x02\x15\x12\x06\
    \xe3\x02\x02\xf0\x02\x03\x1a\x1d\x20Delete\x20a\x20single\x20annotation.\
    \n\n\r\n\x05\x06\0\x02\x15\x01\x12\x04\xe3\x02\x06\x16\n\r\n\x05\x06\0\
    \x02\x15\x02\x12\x04\xe3\x02\x18/\n\r\n\x05\x06\0\x02\x15\x03\x12\x04\
    \xe3\x02:Z\n\x0f\n\x05\x06\0\x02\x15\x04\x12\x06\xe4\x02\x04\xe9\x02\x06\
    \n\x13\n\t\x06\0\x02\x15\x04\xb0\xca\xbc\"\x12\x06\xe4\x02\x04\xe9\x02\
    \x06\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\xea\x02\x047\n\x10\n\x08\x06\0\
    \x02\x15\x04\xc3\xf3\x04\x12\x04\xea\x02\x047\n\r\n\x05\x06\0\x02\x15\
    \x04\x12\x04\xeb\x02\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\0\x12\
    \x04\xeb\x02\x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\xec\x02\x04I\n\x11\
    \n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x01\x12\x04\xec\x02\x04I\n\r\n\x05\
    \x06\0\x02\x15\x04\x12\x04\xed\x02\x04F\n\x11\n\t\x06\0\x02\x15\x04\xc2\
    \xf3\x04\x02\x12\x04\xed\x02\x04F\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\
    \xee\x02\x04D\n\\\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x03\x12\x04\xee\x02\
    \x04D\"I\x20for\x20cleaning\x20up\x20some\x20optimizations\x20we\x20have\
    \x20in\x20DB\x20layer\x20for\x20annotations.\n\n\r\n\x05\x06\0\x02\x15\
    \x04\x12\x04\xef\x02\x04A\n\x11\n\t\x06\0\x02\x15\x04\xc2\xf3\x04\x04\
    \x12\x04\xef\x02\x04A\n=\n\x04\x06\0\x02\x16\x12\x06\xf3\x02\x02\x8a\x03\
    \x03\x1a-\x20Delete\x20multiple\x20annotations\x20in\x20one\x20request.\
    \n\n\r\n\x05\x06\0\x02\x16\x01\x12\x04\xf3\x02\x06\x17\n\r\n\x05\x06\0\
    \x02\x16\x02\x12\x04\xf3\x02\x191\n\r\n\x05\x06\0\x02\x16\x03\x12\x04\
    \xf3\x02<\\\n\x0f\n\x05\x06\0\x02\x16\x04\x12\x06\xf4\x02\x04\x83\x03\
    \x06\n\x13\n\t\x06\0\x02\x16\x04\xb0\xca\xbc\"\x12\x06\xf4\x02\x04\x83\
    \x03\x06\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x84\x03\x047\n\x10\n\x08\
    \x06\0\x02\x16\x04\xc3\xf3\x04\x12\x04\x84\x03\x047\n\r\n\x05\x06\0\x02\
    \x16\x04\x12\x04\x85\x03\x04F\n\x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\0\
    \x12\x04\x85\x03\x04F\n\r\n\x05\x06\0\x02\x16\x04\x12\x04\x86\x03\x04I\n\
    \x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x01\x12\x04\x86\x03\x04I\n\r\n\
    \x05\x06\0\x02\x16\x04\x12\x04\x87\x03\x04F\n\x11\n\t\x06\0\x02\x16\x04\
    \xc2\xf3\x04\x02\x12\x04\x87\x03\x04F\n\r\n\x05\x06\0\x02\x16\x04\x12\
    \x04\x88\x03\x04D\n\\\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\x03\x12\x04\x88\
    \x03\x04D\"I\x20for\x20cleaning\x20up\x20some\x20optimizations\x20we\x20\
    have\x20in\x20DB\x20layer\x20for\x20annotations.\n\n\r\n\x05\x06\0\x02\
    \x16\x04\x12\x04\x89\x03\x04A\n\x11\n\t\x06\0\x02\x16\x04\xc2\xf3\x04\
    \x04\x12\x04\x89\x03\x04A\n:\n\x04\x06\0\x02\x17\x12\x06\x8d\x03\x02\x99\
    \x03\x03\x1a*\x20Patch\x20saved\x20annotations\x20searches\x20by\x20ids.\
    \n\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\x8d\x03\x06\x1e\n\r\n\x05\x06\0\
    \x02\x17\x02\x12\x04\x8d\x03\x20?\n\r\n\x05\x06\0\x02\x17\x03\x12\x04\
    \x8d\x03J]\n\x0f\n\x05\x06\0\x02\x17\x04\x12\x06\x8e\x03\x04\x95\x03\x06\
    \n\x13\n\t\x06\0\x02\x17\x04\xb0\xca\xbc\"\x12\x06\x8e\x03\x04\x95\x03\
    \x06\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\x96\x03\x047\n\x10\n\x08\x06\0\
    \x02\x17\x04\xc3\xf3\x04\x12\x04\x96\x03\x047\n\r\n\x05\x06\0\x02\x17\
    \x04\x12\x04\x97\x03\x04F\n\x11\n\t\x06\0\x02\x17\x04\xc2\xf3\x04\0\x12\
    \x04\x97\x03\x04F\n\r\n\x05\x06\0\x02\x17\x04\x12\x04\x98\x03\x04F\n\x11\
    \n\t\x06\0\x02\x17\x04\xc2\xf3\x04\x01\x12\x04\x98\x03\x04F\n3\n\x04\x06\
    \0\x02\x18\x12\x06\x9c\x03\x02\xac\x03\x03\x1a#\x20Execute\x20a\x20searc\
    h\x20over\x20annotations\n\n\r\n\x05\x06\0\x02\x18\x01\x12\x04\x9c\x03\
    \x06\x1d\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\x9c\x03\x1e<\n\r\n\x05\x06\
    \0\x02\x18\x03\x12\x04\x9c\x03GZ\n\x0f\n\x05\x06\0\x02\x18\x04\x12\x06\
    \x9d\x03\x04\xa4\x03\x06\n\x13\n\t\x06\0\x02\x18\x04\xb0\xca\xbc\"\x12\
    \x06\x9d\x03\x04\xa4\x03\x06\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xa5\x03\
    \x047\n\x10\n\x08\x06\0\x02\x18\x04\xc3\xf3\x04\x12\x04\xa5\x03\x047\n\r\
    \n\x05\x06\0\x02\x18\x04\x12\x04\xa6\x03\x04F\n\x11\n\t\x06\0\x02\x18\
    \x04\xc2\xf3\x04\0\x12\x04\xa6\x03\x04F\n\r\n\x05\x06\0\x02\x18\x04\x12\
    \x04\xa7\x03\x04C\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\x04\x01\x12\x04\
    \xa7\x03\x04C\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xa8\x03\x04A\n\x11\n\t\
    \x06\0\x02\x18\x04\xc2\xf3\x04\x02\x12\x04\xa8\x03\x04A\n\r\n\x05\x06\0\
    \x02\x18\x04\x12\x04\xa9\x03\x04A\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\
    \x04\x03\x12\x04\xa9\x03\x04A\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xaa\
    \x03\x04=\n\x11\n\t\x06\0\x02\x18\x04\xc2\xf3\x04\x04\x12\x04\xaa\x03\
    \x04=\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xab\x03\x04D\nN\n\t\x06\0\x02\
    \x18\x04\xc2\xf3\x04\x05\x12\x04\xab\x03\x04D\";\x20to\x20know\x20the\
    \x20concepts\x20and\x20models\x20in\x20your\x20default\x20workflow.\n\n-\
    \n\x04\x06\0\x02\x19\x12\x06\xaf\x03\x02\xba\x03\x03\x1a\x1d\x20Get\x20i\
    nput\x20count\x20per\x20status.\n\n\r\n\x05\x06\0\x02\x19\x01\x12\x04\
    \xaf\x03\x06\x13\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xaf\x03\x15)\n\r\n\
    \x05\x06\0\x02\x19\x03\x12\x04\xaf\x034L\n\x0f\n\x05\x06\0\x02\x19\x04\
    \x12\x06\xb0\x03\x04\xb5\x03\x06\n\x13\n\t\x06\0\x02\x19\x04\xb0\xca\xbc\
    \"\x12\x06\xb0\x03\x04\xb5\x03\x06\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\
    \xb6\x03\x047\n\x10\n\x08\x06\0\x02\x19\x04\xc3\xf3\x04\x12\x04\xb6\x03\
    \x047\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xb7\x03\x04F\n\x11\n\t\x06\0\
    \x02\x19\x04\xc2\xf3\x04\0\x12\x04\xb7\x03\x04F\n\r\n\x05\x06\0\x02\x19\
    \x04\x12\x04\xb8\x03\x04C\n\x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x01\
    \x12\x04\xb8\x03\x04C\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xb9\x03\x04A\n\
    \x11\n\t\x06\0\x02\x19\x04\xc2\xf3\x04\x02\x12\x04\xb9\x03\x04A\nE\n\x04\
    \x06\0\x02\x1a\x12\x06\xbd\x03\x02\xc8\x03\x03\x1a5\x20Streams\x20all\
    \x20the\x20inputs\x20starting\x20from\x20oldest\x20assets.\n\n\r\n\x05\
    \x06\0\x02\x1a\x01\x12\x04\xbd\x03\x06\x12\n\r\n\x05\x06\0\x02\x1a\x02\
    \x12\x04\xbd\x03\x14'\n\r\n\x05\x06\0\x02\x1a\x03\x12\x04\xbd\x032D\n\
    \x0f\n\x05\x06\0\x02\x1a\x04\x12\x06\xbe\x03\x04\xc3\x03\x06\n\x13\n\t\
    \x06\0\x02\x1a\x04\xb0\xca\xbc\"\x12\x06\xbe\x03\x04\xc3\x03\x06\n\r\n\
    \x05\x06\0\x02\x1a\x04\x12\x04\xc4\x03\x047\n\x10\n\x08\x06\0\x02\x1a\
    \x04\xc3\xf3\x04\x12\x04\xc4\x03\x047\n\r\n\x05\x06\0\x02\x1a\x04\x12\
    \x04\xc5\x03\x04F\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\0\x12\x04\xc5\
    \x03\x04F\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\xc6\x03\x04C\n\x11\n\t\x06\
    \0\x02\x1a\x04\xc2\xf3\x04\x01\x12\x04\xc6\x03\x04C\n\r\n\x05\x06\0\x02\
    \x1a\x04\x12\x04\xc7\x03\x04A\n\x11\n\t\x06\0\x02\x1a\x04\xc2\xf3\x04\
    \x02\x12\x04\xc7\x03\x04A\n3\n\x04\x06\0\x02\x1b\x12\x06\xcb\x03\x02\xd6\
    \x03\x03\x1a#\x20Get\x20a\x20specific\x20input\x20from\x20an\x20app.\n\n\
    \r\n\x05\x06\0\x02\x1b\x01\x12\x04\xcb\x03\x06\x15\n\r\n\x05\x06\0\x02\
    \x1b\x02\x12\x04\xcb\x03\x17-\n\r\n\x05\x06\0\x02\x1b\x03\x12\x04\xcb\
    \x038T\n\x0f\n\x05\x06\0\x02\x1b\x04\x12\x06\xcc\x03\x04\xd1\x03\x06\n\
    \x13\n\t\x06\0\x02\x1b\x04\xb0\xca\xbc\"\x12\x06\xcc\x03\x04\xd1\x03\x06\
    \n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xd2\x03\x047\n\x10\n\x08\x06\0\x02\
    \x1b\x04\xc3\xf3\x04\x12\x04\xd2\x03\x047\n\r\n\x05\x06\0\x02\x1b\x04\
    \x12\x04\xd3\x03\x04F\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\x04\0\x12\x04\
    \xd3\x03\x04F\n\r\n\x05\x06\0\x02\x1b\x04\x12\x04\xd4\x03\x04C\n\x11\n\t\
    \x06\0\x02\x1b\x04\xc2\xf3\x04\x01\x12\x04\xd4\x03\x04C\n\r\n\x05\x06\0\
    \x02\x1b\x04\x12\x04\xd5\x03\x04A\n\x11\n\t\x06\0\x02\x1b\x04\xc2\xf3\
    \x04\x02\x12\x04\xd5\x03\x04A\n3\n\x04\x06\0\x02\x1c\x12\x06\xd9\x03\x02\
    \xe4\x03\x03\x1a#\x20Get\x20a\x20specific\x20input\x20from\x20an\x20app.\
    \n\n\r\n\x05\x06\0\x02\x1c\x01\x12\x04\xd9\x03\x06\x0e\n\r\n\x05\x06\0\
    \x02\x1c\x02\x12\x04\xd9\x03\x10\x1f\n\r\n\x05\x06\0\x02\x1c\x03\x12\x04\
    \xd9\x03*=\n\x0f\n\x05\x06\0\x02\x1c\x04\x12\x06\xda\x03\x04\xdf\x03\x06\
    \n\x13\n\t\x06\0\x02\x1c\x04\xb0\xca\xbc\"\x12\x06\xda\x03\x04\xdf\x03\
    \x06\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\xe0\x03\x047\n\x10\n\x08\x06\0\
    \x02\x1c\x04\xc3\xf3\x04\x12\x04\xe0\x03\x047\n\r\n\x05\x06\0\x02\x1c\
    \x04\x12\x04\xe1\x03\x04F\n\x11\n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\0\x12\
    \x04\xe1\x03\x04F\n\r\n\x05\x06\0\x02\x1c\x04\x12\x04\xe2\x03\x04C\n\x11\
    \n\t\x06\0\x02\x1c\x04\xc2\xf3\x04\x01\x12\x04\xe2\x03\x04C\n\r\n\x05\
    \x06\0\x02\x1c\x04\x12\x04\xe3\x03\x04A\n\x11\n\t\x06\0\x02\x1c\x04\xc2\
    \xf3\x04\x02\x12\x04\xe3\x03\x04A\n&\n\x04\x06\0\x02\x1d\x12\x06\xe7\x03\
    \x02\xf2\x03\x03\x1a\x16\x20List\x20all\x20the\x20inputs.\n\n\r\n\x05\
    \x06\0\x02\x1d\x01\x12\x04\xe7\x03\x06\x10\n\r\n\x05\x06\0\x02\x1d\x02\
    \x12\x04\xe7\x03\x12#\n\r\n\x05\x06\0\x02\x1d\x03\x12\x04\xe7\x03.@\n\
    \x0f\n\x05\x06\0\x02\x1d\x04\x12\x06\xe8\x03\x04\xed\x03\x06\n\x13\n\t\
    \x06\0\x02\x1d\x04\xb0\xca\xbc\"\x12\x06\xe8\x03\x04\xed\x03\x06\n\r\n\
    \x05\x06\0\x02\x1d\x04\x12\x04\xee\x03\x047\n\x10\n\x08\x06\0\x02\x1d\
    \x04\xc3\xf3\x04\x12\x04\xee\x03\x047\n\r\n\x05\x06\0\x02\x1d\x04\x12\
    \x04\xef\x03\x04F\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\0\x12\x04\xef\
    \x03\x04F\n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\xf0\x03\x04C\n\x11\n\t\x06\
    \0\x02\x1d\x04\xc2\xf3\x04\x01\x12\x04\xf0\x03\x04C\n\r\n\x05\x06\0\x02\
    \x1d\x04\x12\x04\xf1\x03\x04A\n\x11\n\t\x06\0\x02\x1d\x04\xc2\xf3\x04\
    \x02\x12\x04\xf1\x03\x04A\n\xb2\x01\n\x04\x06\0\x02\x1e\x12\x06\xf7\x03\
    \x02\x89\x04\x03\x1a\xa1\x01\x20Add\x20an\x20input\x20(or\x20set\x20of\
    \x20inputs)\x20to\x20an\x20app.\n\x20This\x20call\x20is\x20synchronous\
    \x20if\x20the\x20PostInputsRequest\x20contains\x20exactly\x20one\x20imag\
    e\x20input.\x20Otherwise,\n\x20it\x20is\x20asynchronous.\n\n\r\n\x05\x06\
    \0\x02\x1e\x01\x12\x04\xf7\x03\x06\x10\n\r\n\x05\x06\0\x02\x1e\x02\x12\
    \x04\xf7\x03\x12#\n\r\n\x05\x06\0\x02\x1e\x03\x12\x04\xf7\x03.@\n\x0f\n\
    \x05\x06\0\x02\x1e\x04\x12\x06\xf8\x03\x04\xff\x03\x06\n\x13\n\t\x06\0\
    \x02\x1e\x04\xb0\xca\xbc\"\x12\x06\xf8\x03\x04\xff\x03\x06\n\r\n\x05\x06\
    \0\x02\x1e\x04\x12\x04\x80\x04\x047\n\x10\n\x08\x06\0\x02\x1e\x04\xc3\
    \xf3\x04\x12\x04\x80\x04\x047\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\x81\
    \x04\x04F\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\0\x12\x04\x81\x04\x04F\
    \n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\x82\x04\x04F\n\x11\n\t\x06\0\x02\
    \x1e\x04\xc2\xf3\x04\x01\x12\x04\x82\x04\x04F\n\r\n\x05\x06\0\x02\x1e\
    \x04\x12\x04\x83\x04\x04C\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x02\
    \x12\x04\x83\x04\x04C\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\x84\x04\x04A\n\
    \x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x03\x12\x04\x84\x04\x04A\n\r\n\
    \x05\x06\0\x02\x1e\x04\x12\x04\x85\x04\x04A\n\x11\n\t\x06\0\x02\x1e\x04\
    \xc2\xf3\x04\x04\x12\x04\x85\x04\x04A\n\r\n\x05\x06\0\x02\x1e\x04\x12\
    \x04\x86\x04\x04A\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\x04\x05\x12\x04\
    \x86\x04\x04A\n\r\n\x05\x06\0\x02\x1e\x04\x12\x04\x87\x04\x04>\n\x11\n\t\
    \x06\0\x02\x1e\x04\xc2\xf3\x04\x06\x12\x04\x87\x04\x04>\n\r\n\x05\x06\0\
    \x02\x1e\x04\x12\x04\x88\x04\x04D\n\x11\n\t\x06\0\x02\x1e\x04\xc2\xf3\
    \x04\x07\x12\x04\x88\x04\x04D\n+\n\x04\x06\0\x02\x1f\x12\x06\x8f\x04\x02\
    \x9f\x04\x03\x1a\x1b\x20Patch\x20one\x20or\x20more\x20inputs.\n\n\r\n\
    \x05\x06\0\x02\x1f\x01\x12\x04\x8f\x04\x06\x11\n\r\n\x05\x06\0\x02\x1f\
    \x02\x12\x04\x8f\x04\x13%\n\r\n\x05\x06\0\x02\x1f\x03\x12\x04\x8f\x040B\
    \n\x0f\n\x05\x06\0\x02\x1f\x04\x12\x06\x90\x04\x04\x97\x04\x06\n\x13\n\t\
    \x06\0\x02\x1f\x04\xb0\xca\xbc\"\x12\x06\x90\x04\x04\x97\x04\x06\n\r\n\
    \x05\x06\0\x02\x1f\x04\x12\x04\x98\x04\x047\n\x10\n\x08\x06\0\x02\x1f\
    \x04\xc3\xf3\x04\x12\x04\x98\x04\x047\n\r\n\x05\x06\0\x02\x1f\x04\x12\
    \x04\x99\x04\x04F\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\0\x12\x04\x99\
    \x04\x04F\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\x9a\x04\x04F\n\x11\n\t\x06\
    \0\x02\x1f\x04\xc2\xf3\x04\x01\x12\x04\x9a\x04\x04F\n\r\n\x05\x06\0\x02\
    \x1f\x04\x12\x04\x9b\x04\x04C\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\
    \x02\x12\x04\x9b\x04\x04C\n\r\n\x05\x06\0\x02\x1f\x04\x12\x04\x9c\x04\
    \x04A\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\x03\x12\x04\x9c\x04\x04A\n\
    \r\n\x05\x06\0\x02\x1f\x04\x12\x04\x9d\x04\x04A\n\x11\n\t\x06\0\x02\x1f\
    \x04\xc2\xf3\x04\x04\x12\x04\x9d\x04\x04A\n\r\n\x05\x06\0\x02\x1f\x04\
    \x12\x04\x9e\x04\x04A\n\x11\n\t\x06\0\x02\x1f\x04\xc2\xf3\x04\x05\x12\
    \x04\x9e\x04\x04A\n7\n\x04\x06\0\x02\x20\x12\x06\xa2\x04\x02\xb2\x04\x03\
    \x1a'\x20Delete\x20a\x20single\x20input\x20asynchronously.\n\n\r\n\x05\
    \x06\0\x02\x20\x01\x12\x04\xa2\x04\x06\x11\n\r\n\x05\x06\0\x02\x20\x02\
    \x12\x04\xa2\x04\x13%\n\r\n\x05\x06\0\x02\x20\x03\x12\x04\xa2\x040P\n\
    \x0f\n\x05\x06\0\x02\x20\x04\x12\x06\xa3\x04\x04\xa8\x04\x06\n\x13\n\t\
    \x06\0\x02\x20\x04\xb0\xca\xbc\"\x12\x06\xa3\x04\x04\xa8\x04\x06\n\r\n\
    \x05\x06\0\x02\x20\x04\x12\x04\xa9\x04\x047\n\x10\n\x08\x06\0\x02\x20\
    \x04\xc3\xf3\x04\x12\x04\xa9\x04\x047\n\r\n\x05\x06\0\x02\x20\x04\x12\
    \x04\xaa\x04\x04F\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\0\x12\x04\xaa\
    \x04\x04F\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xab\x04\x04I\n\x11\n\t\x06\
    \0\x02\x20\x04\xc2\xf3\x04\x01\x12\x04\xab\x04\x04I\n\r\n\x05\x06\0\x02\
    \x20\x04\x12\x04\xac\x04\x04F\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\
    \x02\x12\x04\xac\x04\x04F\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xad\x04\
    \x04A\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x03\x12\x04\xad\x04\x04A\n\
    \r\n\x05\x06\0\x02\x20\x04\x12\x04\xae\x04\x04D\n\x11\n\t\x06\0\x02\x20\
    \x04\xc2\xf3\x04\x04\x12\x04\xae\x04\x04D\n\r\n\x05\x06\0\x02\x20\x04\
    \x12\x04\xaf\x04\x04A\n\x11\n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x05\x12\
    \x04\xaf\x04\x04A\n\r\n\x05\x06\0\x02\x20\x04\x12\x04\xb0\x04\x04A\n\x11\
    \n\t\x06\0\x02\x20\x04\xc2\xf3\x04\x06\x12\x04\xb0\x04\x04A\n\r\n\x05\
    \x06\0\x02\x20\x04\x12\x04\xb1\x04\x04D\n\x11\n\t\x06\0\x02\x20\x04\xc2\
    \xf3\x04\x07\x12\x04\xb1\x04\x04D\nT\n\x04\x06\0\x02!\x12\x06\xb6\x04\
    \x02\xc8\x04\x03\x1aD\x20Delete\x20multiple\x20inputs\x20in\x20one\x20re\
    quest.\n\x20This\x20call\x20is\x20asynchronous.\n\n\r\n\x05\x06\0\x02!\
    \x01\x12\x04\xb6\x04\x06\x12\n\r\n\x05\x06\0\x02!\x02\x12\x04\xb6\x04\
    \x14'\n\r\n\x05\x06\0\x02!\x03\x12\x04\xb6\x042R\n\x0f\n\x05\x06\0\x02!\
    \x04\x12\x06\xb7\x04\x04\xbe\x04\x06\n\x13\n\t\x06\0\x02!\x04\xb0\xca\
    \xbc\"\x12\x06\xb7\x04\x04\xbe\x04\x06\n\r\n\x05\x06\0\x02!\x04\x12\x04\
    \xbf\x04\x047\n\x10\n\x08\x06\0\x02!\x04\xc3\xf3\x04\x12\x04\xbf\x04\x04\
    7\n\r\n\x05\x06\0\x02!\x04\x12\x04\xc0\x04\x04F\n\x11\n\t\x06\0\x02!\x04\
    \xc2\xf3\x04\0\x12\x04\xc0\x04\x04F\n\r\n\x05\x06\0\x02!\x04\x12\x04\xc1\
    \x04\x04I\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x01\x12\x04\xc1\x04\x04I\
    \n\r\n\x05\x06\0\x02!\x04\x12\x04\xc2\x04\x04F\n\x11\n\t\x06\0\x02!\x04\
    \xc2\xf3\x04\x02\x12\x04\xc2\x04\x04F\n\r\n\x05\x06\0\x02!\x04\x12\x04\
    \xc3\x04\x04A\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x03\x12\x04\xc3\x04\
    \x04A\n\r\n\x05\x06\0\x02!\x04\x12\x04\xc4\x04\x04D\n\x11\n\t\x06\0\x02!\
    \x04\xc2\xf3\x04\x04\x12\x04\xc4\x04\x04D\n\r\n\x05\x06\0\x02!\x04\x12\
    \x04\xc5\x04\x04A\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x05\x12\x04\xc5\
    \x04\x04A\n\r\n\x05\x06\0\x02!\x04\x12\x04\xc6\x04\x04A\n\x11\n\t\x06\0\
    \x02!\x04\xc2\xf3\x04\x06\x12\x04\xc6\x04\x04A\n\r\n\x05\x06\0\x02!\x04\
    \x12\x04\xc7\x04\x04D\n\x11\n\t\x06\0\x02!\x04\xc2\xf3\x04\x07\x12\x04\
    \xc7\x04\x04D\n5\n\x04\x06\0\x02\"\x12\x06\xcb\x04\x02\xd7\x04\x03\x1a%\
    \x20Patch\x20saved\x20inputs\x20searches\x20by\x20ids.\n\n\r\n\x05\x06\0\
    \x02\"\x01\x12\x04\xcb\x04\x06\x19\n\r\n\x05\x06\0\x02\"\x02\x12\x04\xcb\
    \x04\x1b5\n\r\n\x05\x06\0\x02\"\x03\x12\x04\xcb\x04@S\n\x0f\n\x05\x06\0\
    \x02\"\x04\x12\x06\xcc\x04\x04\xd3\x04\x06\n\x13\n\t\x06\0\x02\"\x04\xb0\
    \xca\xbc\"\x12\x06\xcc\x04\x04\xd3\x04\x06\n\r\n\x05\x06\0\x02\"\x04\x12\
    \x04\xd4\x04\x047\n\x10\n\x08\x06\0\x02\"\x04\xc3\xf3\x04\x12\x04\xd4\
    \x04\x047\n\r\n\x05\x06\0\x02\"\x04\x12\x04\xd5\x04\x04F\n\x11\n\t\x06\0\
    \x02\"\x04\xc2\xf3\x04\0\x12\x04\xd5\x04\x04F\n\r\n\x05\x06\0\x02\"\x04\
    \x12\x04\xd6\x04\x04F\n\x11\n\t\x06\0\x02\"\x04\xc2\xf3\x04\x01\x12\x04\
    \xd6\x04\x04F\n.\n\x04\x06\0\x02#\x12\x06\xda\x04\x02\xea\x04\x03\x1a\
    \x1e\x20Execute\x20a\x20search\x20over\x20inputs\n\n\r\n\x05\x06\0\x02#\
    \x01\x12\x04\xda\x04\x06\x18\n\r\n\x05\x06\0\x02#\x02\x12\x04\xda\x04\
    \x192\n\r\n\x05\x06\0\x02#\x03\x12\x04\xda\x04=P\n\x0f\n\x05\x06\0\x02#\
    \x04\x12\x06\xdb\x04\x04\xe2\x04\x06\n\x13\n\t\x06\0\x02#\x04\xb0\xca\
    \xbc\"\x12\x06\xdb\x04\x04\xe2\x04\x06\n\r\n\x05\x06\0\x02#\x04\x12\x04\
    \xe3\x04\x047\n\x10\n\x08\x06\0\x02#\x04\xc3\xf3\x04\x12\x04\xe3\x04\x04\
    7\n\r\n\x05\x06\0\x02#\x04\x12\x04\xe4\x04\x04F\n\x11\n\t\x06\0\x02#\x04\
    \xc2\xf3\x04\0\x12\x04\xe4\x04\x04F\n\r\n\x05\x06\0\x02#\x04\x12\x04\xe5\
    \x04\x04C\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x01\x12\x04\xe5\x04\x04C\
    \n\r\n\x05\x06\0\x02#\x04\x12\x04\xe6\x04\x04A\n\x11\n\t\x06\0\x02#\x04\
    \xc2\xf3\x04\x02\x12\x04\xe6\x04\x04A\n\r\n\x05\x06\0\x02#\x04\x12\x04\
    \xe7\x04\x04A\n\x11\n\t\x06\0\x02#\x04\xc2\xf3\x04\x03\x12\x04\xe7\x04\
    \x04A\n\r\n\x05\x06\0\x02#\x04\x12\x04\xe8\x04\x04=\n\x11\n\t\x06\0\x02#\
    \x04\xc2\xf3\x04\x04\x12\x04\xe8\x04\x04=\n\r\n\x05\x06\0\x02#\x04\x12\
    \x04\xe9\x04\x04D\nN\n\t\x06\0\x02#\x04\xc2\xf3\x04\x05\x12\x04\xe9\x04\
    \x04D\";\x20to\x20know\x20the\x20concepts\x20and\x20models\x20in\x20your\
    \x20default\x20workflow.\n\n7\n\x04\x06\0\x02$\x12\x06\xed\x04\x02\x82\
    \x05\x03\x1a'\x20Get\x20predicted\x20outputs\x20from\x20the\x20model.\n\
    \n\r\n\x05\x06\0\x02$\x01\x12\x04\xed\x04\x06\x16\n\r\n\x05\x06\0\x02$\
    \x02\x12\x04\xed\x04\x18/\n\r\n\x05\x06\0\x02$\x03\x12\x04\xed\x04:M\n\
    \x0f\n\x05\x06\0\x02$\x04\x12\x06\xee\x04\x04\xfd\x04\x06\n\x13\n\t\x06\
    \0\x02$\x04\xb0\xca\xbc\"\x12\x06\xee\x04\x04\xfd\x04\x06\n\r\n\x05\x06\
    \0\x02$\x04\x12\x04\xfe\x04\x047\n\x10\n\x08\x06\0\x02$\x04\xc3\xf3\x04\
    \x12\x04\xfe\x04\x047\n\r\n\x05\x06\0\x02$\x04\x12\x04\xff\x04\x04C\n\
    \x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\0\x12\x04\xff\x04\x04C\n\r\n\x05\x06\
    \0\x02$\x04\x12\x04\x80\x05\x04A\n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\
    \x01\x12\x04\x80\x05\x04A\n\r\n\x05\x06\0\x02$\x04\x12\x04\x81\x05\x04>\
    \n\x11\n\t\x06\0\x02$\x04\xc2\xf3\x04\x02\x12\x04\x81\x05\x04>\n\x84\x01\
    \n\x04\x06\0\x02%\x12\x06\x99\x05\x02\xa2\x05\x03\x1a\x1c\x20Get\x20a\
    \x20specific\x20model\x20type.\n2V//////////////////////////////////////\
    \n\x20Models\n//////////////////////////////////////\n\n\r\n\x05\x06\0\
    \x02%\x01\x12\x04\x99\x05\x06\x12\n\r\n\x05\x06\0\x02%\x02\x12\x04\x99\
    \x05\x14'\n\r\n\x05\x06\0\x02%\x03\x12\x04\x99\x052I\n\x0f\n\x05\x06\0\
    \x02%\x04\x12\x06\x9a\x05\x04\x9f\x05\x06\n\x13\n\t\x06\0\x02%\x04\xb0\
    \xca\xbc\"\x12\x06\x9a\x05\x04\x9f\x05\x06\n\r\n\x05\x06\0\x02%\x04\x12\
    \x04\xa0\x05\x047\n\x10\n\x08\x06\0\x02%\x04\xc3\xf3\x04\x12\x04\xa0\x05\
    \x047\n\r\n\x05\x06\0\x02%\x04\x12\x04\xa1\x05\x04A\n\x11\n\t\x06\0\x02%\
    \x04\xc2\xf3\x04\0\x12\x04\xa1\x05\x04A\nN\n\x04\x06\0\x02&\x12\x06\xa5\
    \x05\x02\xaa\x05\x03\x1a>\x20List\x20all\x20the\x20supported\x20open\x20\
    source\x20licenses\x20in\x20the\x20platform.\n\n\r\n\x05\x06\0\x02&\x01\
    \x12\x04\xa5\x05\x06\x1c\n\r\n\x05\x06\0\x02&\x02\x12\x04\xa5\x05\x1e;\n\
    \r\n\x05\x06\0\x02&\x03\x12\x04\xa5\x05Fd\n\x0f\n\x05\x06\0\x02&\x04\x12\
    \x06\xa6\x05\x04\xa8\x05\x06\n\x13\n\t\x06\0\x02&\x04\xb0\xca\xbc\"\x12\
    \x06\xa6\x05\x04\xa8\x05\x06\n\r\n\x05\x06\0\x02&\x04\x12\x04\xa9\x05\
    \x046\n\x10\n\x08\x06\0\x02&\x04\xc3\xf3\x04\x12\x04\xa9\x05\x046\n\x9a\
    \x01\n\x04\x06\0\x02'\x12\x06\xae\x05\x02\xb7\x05\x03\x1a\x89\x01\x20Lis\
    t\x20all\x20the\x20model\x20types\x20available\x20in\x20the\x20platform.\
    \n\x20This\x20MUST\x20be\x20above\x20ListModels\x20so\x20that\x20the\x20\
    /models/types\x20endpoint\x20takes\x20precedence.\n\n\r\n\x05\x06\0\x02'\
    \x01\x12\x04\xae\x05\x06\x14\n\r\n\x05\x06\0\x02'\x02\x12\x04\xae\x05\
    \x16+\n\r\n\x05\x06\0\x02'\x03\x12\x04\xae\x056L\n\x0f\n\x05\x06\0\x02'\
    \x04\x12\x06\xaf\x05\x04\xb4\x05\x06\n\x13\n\t\x06\0\x02'\x04\xb0\xca\
    \xbc\"\x12\x06\xaf\x05\x04\xb4\x05\x06\n\r\n\x05\x06\0\x02'\x04\x12\x04\
    \xb5\x05\x047\n\x10\n\x08\x06\0\x02'\x04\xc3\xf3\x04\x12\x04\xb5\x05\x04\
    7\n\r\n\x05\x06\0\x02'\x04\x12\x04\xb6\x05\x04A\n\x11\n\t\x06\0\x02'\x04\
    \xc2\xf3\x04\0\x12\x04\xb6\x05\x04A\n3\n\x04\x06\0\x02(\x12\x06\xba\x05\
    \x02\xc4\x05\x03\x1a#\x20Get\x20a\x20specific\x20model\x20from\x20an\x20\
    app.\n\n\r\n\x05\x06\0\x02(\x01\x12\x04\xba\x05\x06\x0e\n\r\n\x05\x06\0\
    \x02(\x02\x12\x04\xba\x05\x10\x1f\n\r\n\x05\x06\0\x02(\x03\x12\x04\xba\
    \x05*=\n\x0f\n\x05\x06\0\x02(\x04\x12\x06\xbb\x05\x04\xc0\x05\x06\n\x13\
    \n\t\x06\0\x02(\x04\xb0\xca\xbc\"\x12\x06\xbb\x05\x04\xc0\x05\x06\n\r\n\
    \x05\x06\0\x02(\x04\x12\x04\xc1\x05\x047\n\x10\n\x08\x06\0\x02(\x04\xc3\
    \xf3\x04\x12\x04\xc1\x05\x047\n\r\n\x05\x06\0\x02(\x04\x12\x04\xc2\x05\
    \x04C\n\x11\n\t\x06\0\x02(\x04\xc2\xf3\x04\0\x12\x04\xc2\x05\x04C\n\r\n\
    \x05\x06\0\x02(\x04\x12\x04\xc3\x05\x04A\n\x11\n\t\x06\0\x02(\x04\xc2\
    \xf3\x04\x01\x12\x04\xc3\x05\x04A\n[\n\x04\x06\0\x02)\x12\x06\xc8\x05\
    \x02\xd8\x05\x03\x1aK\x20Get\x20a\x20the\x20output\x20info\x20for\x20a\
    \x20given\x20model_id\x20or\x20model_id/version_id\n\x20combo.\n\n\r\n\
    \x05\x06\0\x02)\x01\x12\x04\xc8\x05\x06\x18\n\r\n\x05\x06\0\x02)\x02\x12\
    \x04\xc8\x05\x1a)\n\r\n\x05\x06\0\x02)\x03\x12\x04\xc8\x054G\n\x0f\n\x05\
    \x06\0\x02)\x04\x12\x06\xc9\x05\x04\xd4\x05\x06\n\x13\n\t\x06\0\x02)\x04\
    \xb0\xca\xbc\"\x12\x06\xc9\x05\x04\xd4\x05\x06\n\r\n\x05\x06\0\x02)\x04\
    \x12\x04\xd5\x05\x047\n\x10\n\x08\x06\0\x02)\x04\xc3\xf3\x04\x12\x04\xd5\
    \x05\x047\n\r\n\x05\x06\0\x02)\x04\x12\x04\xd6\x05\x04C\n\x11\n\t\x06\0\
    \x02)\x04\xc2\xf3\x04\0\x12\x04\xd6\x05\x04C\n\r\n\x05\x06\0\x02)\x04\
    \x12\x04\xd7\x05\x04A\n\x11\n\t\x06\0\x02)\x04\xc2\xf3\x04\x01\x12\x04\
    \xd7\x05\x04A\n&\n\x04\x06\0\x02*\x12\x06\xdb\x05\x02\xe8\x05\x03\x1a\
    \x16\x20List\x20all\x20the\x20models.\n\n\r\n\x05\x06\0\x02*\x01\x12\x04\
    \xdb\x05\x06\x10\n\r\n\x05\x06\0\x02*\x02\x12\x04\xdb\x05\x12#\n\r\n\x05\
    \x06\0\x02*\x03\x12\x04\xdb\x05.@\n\x0f\n\x05\x06\0\x02*\x04\x12\x06\xdc\
    \x05\x04\xe4\x05\x06\n\x13\n\t\x06\0\x02*\x04\xb0\xca\xbc\"\x12\x06\xdc\
    \x05\x04\xe4\x05\x06\n\r\n\x05\x06\0\x02*\x04\x12\x04\xe5\x05\x047\n\x10\
    \n\x08\x06\0\x02*\x04\xc3\xf3\x04\x12\x04\xe5\x05\x047\n\r\n\x05\x06\0\
    \x02*\x04\x12\x04\xe6\x05\x04C\n\x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\0\
    \x12\x04\xe6\x05\x04C\n\r\n\x05\x06\0\x02*\x04\x12\x04\xe7\x05\x04A\n\
    \x11\n\t\x06\0\x02*\x04\xc2\xf3\x04\x01\x12\x04\xe7\x05\x04A\n\xcb\x01\n\
    \x04\x06\0\x02+\x12\x06\xef\x05\x02\xfb\x05\x03\x1a\xba\x01\x20Search\
    \x20over\x20the\x20models\x20to\x20find\x20one\x20or\x20more\x20you're\
    \x20looking\x20for.\n\x20This\x20leverage\x20the\x20\"body\"\x20paramete\
    r\x20because\x20we\x20also\x20have\x20page\x20and\n\x20per_page\x20as\
    \x20url\x20query\x20param\x20variables\x20in\x20this\x20request.\n\n\r\n\
    \x05\x06\0\x02+\x01\x12\x04\xef\x05\x06\x18\n\r\n\x05\x06\0\x02+\x02\x12\
    \x04\xef\x05\x1a3\n\r\n\x05\x06\0\x02+\x03\x12\x04\xef\x05>P\n\x0f\n\x05\
    \x06\0\x02+\x04\x12\x06\xf0\x05\x04\xf7\x05\x06\n\x13\n\t\x06\0\x02+\x04\
    \xb0\xca\xbc\"\x12\x06\xf0\x05\x04\xf7\x05\x06\n\r\n\x05\x06\0\x02+\x04\
    \x12\x04\xf8\x05\x047\n\x10\n\x08\x06\0\x02+\x04\xc3\xf3\x04\x12\x04\xf8\
    \x05\x047\n\r\n\x05\x06\0\x02+\x04\x12\x04\xf9\x05\x04C\n\x11\n\t\x06\0\
    \x02+\x04\xc2\xf3\x04\0\x12\x04\xf9\x05\x04C\n\r\n\x05\x06\0\x02+\x04\
    \x12\x04\xfa\x05\x04A\n\x11\n\t\x06\0\x02+\x04\xc2\xf3\x04\x01\x12\x04\
    \xfa\x05\x04A\n)\n\x04\x06\0\x02,\x12\x06\xfe\x05\x02\x8d\x06\x03\x1a\
    \x19\x20Add\x20a\x20models\x20to\x20an\x20app.\n\n\r\n\x05\x06\0\x02,\
    \x01\x12\x04\xfe\x05\x06\x10\n\r\n\x05\x06\0\x02,\x02\x12\x04\xfe\x05\
    \x12#\n\r\n\x05\x06\0\x02,\x03\x12\x04\xfe\x05.A\n\x0f\n\x05\x06\0\x02,\
    \x04\x12\x06\xff\x05\x04\x86\x06\x06\n\x13\n\t\x06\0\x02,\x04\xb0\xca\
    \xbc\"\x12\x06\xff\x05\x04\x86\x06\x06\n\r\n\x05\x06\0\x02,\x04\x12\x04\
    \x87\x06\x047\n\x10\n\x08\x06\0\x02,\x04\xc3\xf3\x04\x12\x04\x87\x06\x04\
    7\n\r\n\x05\x06\0\x02,\x04\x12\x04\x88\x06\x04C\n\x11\n\t\x06\0\x02,\x04\
    \xc2\xf3\x04\0\x12\x04\x88\x06\x04C\n\r\n\x05\x06\0\x02,\x04\x12\x04\x89\
    \x06\x04A\n\x11\n\t\x06\0\x02,\x04\xc2\xf3\x04\x01\x12\x04\x89\x06\x04A\
    \n\r\n\x05\x06\0\x02,\x04\x12\x04\x8a\x06\x04A\n\x11\n\t\x06\0\x02,\x04\
    \xc2\xf3\x04\x02\x12\x04\x8a\x06\x04A\n\r\n\x05\x06\0\x02,\x04\x12\x04\
    \x8b\x06\x04C\nF\n\t\x06\0\x02,\x04\xc2\xf3\x04\x03\x12\x04\x8b\x06\x04C\
    \"3\x20Train\x20is\x20needed\x20because\x20it\x20creates\x20a\x20new\x20\
    version.\n\n\r\n\x05\x06\0\x02,\x04\x12\x04\x8c\x06\x04D\nF\n\t\x06\0\
    \x02,\x04\xc2\xf3\x04\x04\x12\x04\x8c\x06\x04D\"3\x20Needs\x20to\x20chec\
    k\x20the\x20base\x20workflow\x20to\x20build\x20off\x20of.\n\n+\n\x04\x06\
    \0\x02-\x12\x06\x90\x06\x02\x9e\x06\x03\x1a\x1b\x20Patch\x20one\x20or\
    \x20more\x20models.\n\n\r\n\x05\x06\0\x02-\x01\x12\x04\x90\x06\x06\x11\n\
    \r\n\x05\x06\0\x02-\x02\x12\x04\x90\x06\x13%\n\r\n\x05\x06\0\x02-\x03\
    \x12\x04\x90\x060B\n\x0f\n\x05\x06\0\x02-\x04\x12\x06\x91\x06\x04\x98\
    \x06\x06\n\x13\n\t\x06\0\x02-\x04\xb0\xca\xbc\"\x12\x06\x91\x06\x04\x98\
    \x06\x06\n\r\n\x05\x06\0\x02-\x04\x12\x04\x99\x06\x047\n\x10\n\x08\x06\0\
    \x02-\x04\xc3\xf3\x04\x12\x04\x99\x06\x047\n\r\n\x05\x06\0\x02-\x04\x12\
    \x04\x9a\x06\x04C\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\0\x12\x04\x9a\x06\
    \x04C\n\r\n\x05\x06\0\x02-\x04\x12\x04\x9b\x06\x04A\n\x11\n\t\x06\0\x02-\
    \x04\xc2\xf3\x04\x01\x12\x04\x9b\x06\x04A\n\r\n\x05\x06\0\x02-\x04\x12\
    \x04\x9c\x06\x04A\n\x11\n\t\x06\0\x02-\x04\xc2\xf3\x04\x02\x12\x04\x9c\
    \x06\x04A\n\r\n\x05\x06\0\x02-\x04\x12\x04\x9d\x06\x04C\n\x11\n\t\x06\0\
    \x02-\x04\xc2\xf3\x04\x03\x12\x04\x9d\x06\x04C\n+\n\x04\x06\0\x02.\x12\
    \x06\xa1\x06\x02\xa9\x06\x03\x1a\x1b\x20Patch\x20one\x20or\x20more\x20mo\
    dels.\n\n\r\n\x05\x06\0\x02.\x01\x12\x04\xa1\x06\x06\x13\n\r\n\x05\x06\0\
    \x02.\x02\x12\x04\xa1\x06\x15)\n\r\n\x05\x06\0\x02.\x03\x12\x04\xa1\x064\
    F\n\x0f\n\x05\x06\0\x02.\x04\x12\x06\xa2\x06\x04\xa5\x06\x06\n\x13\n\t\
    \x06\0\x02.\x04\xb0\xca\xbc\"\x12\x06\xa2\x06\x04\xa5\x06\x06\n\r\n\x05\
    \x06\0\x02.\x04\x12\x04\xa6\x06\x047\n\x10\n\x08\x06\0\x02.\x04\xc3\xf3\
    \x04\x12\x04\xa6\x06\x047\n\r\n\x05\x06\0\x02.\x04\x12\x04\xa7\x06\x04A\
    \n\x11\n\t\x06\0\x02.\x04\xc2\xf3\x04\0\x12\x04\xa7\x06\x04A\n\r\n\x05\
    \x06\0\x02.\x04\x12\x04\xa8\x06\x04A\n\x11\n\t\x06\0\x02.\x04\xc2\xf3\
    \x04\x01\x12\x04\xa8\x06\x04A\n(\n\x04\x06\0\x02/\x12\x06\xac\x06\x02\
    \xb9\x06\x03\x1a\x18\x20Delete\x20a\x20single\x20model.\n\n\r\n\x05\x06\
    \0\x02/\x01\x12\x04\xac\x06\x06\x11\n\r\n\x05\x06\0\x02/\x02\x12\x04\xac\
    \x06\x13%\n\r\n\x05\x06\0\x02/\x03\x12\x04\xac\x060P\n\x0f\n\x05\x06\0\
    \x02/\x04\x12\x06\xad\x06\x04\xb2\x06\x06\n\x13\n\t\x06\0\x02/\x04\xb0\
    \xca\xbc\"\x12\x06\xad\x06\x04\xb2\x06\x06\n\r\n\x05\x06\0\x02/\x04\x12\
    \x04\xb3\x06\x047\n\x10\n\x08\x06\0\x02/\x04\xc3\xf3\x04\x12\x04\xb3\x06\
    \x047\n\r\n\x05\x06\0\x02/\x04\x12\x04\xb4\x06\x04C\n\x11\n\t\x06\0\x02/\
    \x04\xc2\xf3\x04\0\x12\x04\xb4\x06\x04C\n\r\n\x05\x06\0\x02/\x04\x12\x04\
    \xb5\x06\x04A\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x01\x12\x04\xb5\x06\
    \x04A\n\r\n\x05\x06\0\x02/\x04\x12\x04\xb6\x06\x04D\n\x11\n\t\x06\0\x02/\
    \x04\xc2\xf3\x04\x02\x12\x04\xb6\x06\x04D\n\r\n\x05\x06\0\x02/\x04\x12\
    \x04\xb7\x06\x04A\n\x11\n\t\x06\0\x02/\x04\xc2\xf3\x04\x03\x12\x04\xb7\
    \x06\x04A\n\r\n\x05\x06\0\x02/\x04\x12\x04\xb8\x06\x04D\n\x11\n\t\x06\0\
    \x02/\x04\xc2\xf3\x04\x04\x12\x04\xb8\x06\x04D\n8\n\x04\x06\0\x020\x12\
    \x06\xbc\x06\x02\xcb\x06\x03\x1a(\x20Delete\x20multiple\x20models\x20in\
    \x20one\x20request.\n\n\r\n\x05\x06\0\x020\x01\x12\x04\xbc\x06\x06\x12\n\
    \r\n\x05\x06\0\x020\x02\x12\x04\xbc\x06\x14'\n\r\n\x05\x06\0\x020\x03\
    \x12\x04\xbc\x062R\n\x0f\n\x05\x06\0\x020\x04\x12\x06\xbd\x06\x04\xc4\
    \x06\x06\n\x13\n\t\x06\0\x020\x04\xb0\xca\xbc\"\x12\x06\xbd\x06\x04\xc4\
    \x06\x06\n\r\n\x05\x06\0\x020\x04\x12\x04\xc5\x06\x047\n\x10\n\x08\x06\0\
    \x020\x04\xc3\xf3\x04\x12\x04\xc5\x06\x047\n\r\n\x05\x06\0\x020\x04\x12\
    \x04\xc6\x06\x04C\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\0\x12\x04\xc6\x06\
    \x04C\n\r\n\x05\x06\0\x020\x04\x12\x04\xc7\x06\x04A\n\x11\n\t\x06\0\x020\
    \x04\xc2\xf3\x04\x01\x12\x04\xc7\x06\x04A\n\r\n\x05\x06\0\x020\x04\x12\
    \x04\xc8\x06\x04D\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x02\x12\x04\xc8\
    \x06\x04D\n\r\n\x05\x06\0\x020\x04\x12\x04\xc9\x06\x04A\n\x11\n\t\x06\0\
    \x020\x04\xc2\xf3\x04\x03\x12\x04\xc9\x06\x04A\n\r\n\x05\x06\0\x020\x04\
    \x12\x04\xca\x06\x04D\n\x11\n\t\x06\0\x020\x04\xc2\xf3\x04\x04\x12\x04\
    \xca\x06\x04D\n,\n\x04\x06\0\x021\x12\x06\xd0\x06\x02\xdb\x06\x03\x1a\
    \x1c\x20Update\x20model\x20toolkits\x20tags\n\n\r\n\x05\x06\0\x021\x01\
    \x12\x04\xd0\x06\x06\x18\n\r\n\x05\x06\0\x021\x02\x12\x04\xd0\x06\x1a3\n\
    \r\n\x05\x06\0\x021\x03\x12\x04\xd0\x06>W\n\x0f\n\x05\x06\0\x021\x04\x12\
    \x06\xd1\x06\x04\xd8\x06\x06\n\x13\n\t\x06\0\x021\x04\xb0\xca\xbc\"\x12\
    \x06\xd1\x06\x04\xd8\x06\x06\n\r\n\x05\x06\0\x021\x04\x12\x04\xd9\x06\
    \x047\n\x10\n\x08\x06\0\x021\x04\xc3\xf3\x04\x12\x04\xd9\x06\x047\n\r\n\
    \x05\x06\0\x021\x04\x12\x04\xda\x06\x04A\n\x11\n\t\x06\0\x021\x04\xc2\
    \xf3\x04\0\x12\x04\xda\x06\x04A\n-\n\x04\x06\0\x022\x12\x06\xde\x06\x02\
    \xe9\x06\x03\x1a\x1d\x20Update\x20model\x20use_cases\x20tags\n\n\r\n\x05\
    \x06\0\x022\x01\x12\x04\xde\x06\x06\x18\n\r\n\x05\x06\0\x022\x02\x12\x04\
    \xde\x06\x1a3\n\r\n\x05\x06\0\x022\x03\x12\x04\xde\x06>W\n\x0f\n\x05\x06\
    \0\x022\x04\x12\x06\xdf\x06\x04\xe6\x06\x06\n\x13\n\t\x06\0\x022\x04\xb0\
    \xca\xbc\"\x12\x06\xdf\x06\x04\xe6\x06\x06\n\r\n\x05\x06\0\x022\x04\x12\
    \x04\xe7\x06\x047\n\x10\n\x08\x06\0\x022\x04\xc3\xf3\x04\x12\x04\xe7\x06\
    \x047\n\r\n\x05\x06\0\x022\x04\x12\x04\xe8\x06\x04A\n\x11\n\t\x06\0\x022\
    \x04\xc2\xf3\x04\0\x12\x04\xe8\x06\x04A\n-\n\x04\x06\0\x023\x12\x06\xec\
    \x06\x02\xf7\x06\x03\x1a\x1d\x20Update\x20model\x20languages\x20tags\n\n\
    \r\n\x05\x06\0\x023\x01\x12\x04\xec\x06\x06\x19\n\r\n\x05\x06\0\x023\x02\
    \x12\x04\xec\x06\x1b5\n\r\n\x05\x06\0\x023\x03\x12\x04\xec\x06@Z\n\x0f\n\
    \x05\x06\0\x023\x04\x12\x06\xed\x06\x04\xf4\x06\x06\n\x13\n\t\x06\0\x023\
    \x04\xb0\xca\xbc\"\x12\x06\xed\x06\x04\xf4\x06\x06\n\r\n\x05\x06\0\x023\
    \x04\x12\x04\xf5\x06\x047\n\x10\n\x08\x06\0\x023\x04\xc3\xf3\x04\x12\x04\
    \xf5\x06\x047\n\r\n\x05\x06\0\x023\x04\x12\x04\xf6\x06\x04A\n\x11\n\t\
    \x06\0\x023\x04\xc2\xf3\x04\0\x12\x04\xf6\x06\x04A\n&\n\x04\x06\0\x024\
    \x12\x06\xfa\x06\x02\x8c\x07\x03\x1a\x16\x20List\x20all\x20the\x20inputs\
    .\n\n\r\n\x05\x06\0\x024\x01\x12\x04\xfa\x06\x06\x15\n\r\n\x05\x06\0\x02\
    4\x02\x12\x04\xfa\x06\x17-\n\r\n\x05\x06\0\x024\x03\x12\x04\xfa\x068J\n\
    \x0f\n\x05\x06\0\x024\x04\x12\x06\xfb\x06\x04\x86\x07\x06\n\x13\n\t\x06\
    \0\x024\x04\xb0\xca\xbc\"\x12\x06\xfb\x06\x04\x86\x07\x06\n\r\n\x05\x06\
    \0\x024\x04\x12\x04\x87\x07\x047\n\x10\n\x08\x06\0\x024\x04\xc3\xf3\x04\
    \x12\x04\x87\x07\x047\n\r\n\x05\x06\0\x024\x04\x12\x04\x88\x07\x04F\n\
    \x11\n\t\x06\0\x024\x04\xc2\xf3\x04\0\x12\x04\x88\x07\x04F\n\r\n\x05\x06\
    \0\x024\x04\x12\x04\x89\x07\x04C\n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\
    \x01\x12\x04\x89\x07\x04C\n\r\n\x05\x06\0\x024\x04\x12\x04\x8a\x07\x04A\
    \n\x11\n\t\x06\0\x024\x04\xc2\xf3\x04\x02\x12\x04\x8a\x07\x04A\n\r\n\x05\
    \x06\0\x024\x04\x12\x04\x8b\x07\x04A\n\x11\n\t\x06\0\x024\x04\xc2\xf3\
    \x04\x03\x12\x04\x8b\x07\x04A\n3\n\x04\x06\0\x025\x12\x06\x8f\x07\x02\
    \x99\x07\x03\x1a#\x20Get\x20a\x20specific\x20model\x20from\x20an\x20app.\
    \n\n\r\n\x05\x06\0\x025\x01\x12\x04\x8f\x07\x06\x15\n\r\n\x05\x06\0\x025\
    \x02\x12\x04\x8f\x07\x17-\n\r\n\x05\x06\0\x025\x03\x12\x04\x8f\x078R\n\
    \x0f\n\x05\x06\0\x025\x04\x12\x06\x90\x07\x04\x95\x07\x06\n\x13\n\t\x06\
    \0\x025\x04\xb0\xca\xbc\"\x12\x06\x90\x07\x04\x95\x07\x06\n\r\n\x05\x06\
    \0\x025\x04\x12\x04\x96\x07\x047\n\x10\n\x08\x06\0\x025\x04\xc3\xf3\x04\
    \x12\x04\x96\x07\x047\n\r\n\x05\x06\0\x025\x04\x12\x04\x97\x07\x04C\n\
    \x11\n\t\x06\0\x025\x04\xc2\xf3\x04\0\x12\x04\x97\x07\x04C\n\r\n\x05\x06\
    \0\x025\x04\x12\x04\x98\x07\x04A\n\x11\n\t\x06\0\x025\x04\xc2\xf3\x04\
    \x01\x12\x04\x98\x07\x04A\n&\n\x04\x06\0\x026\x12\x06\x9c\x07\x02\xa6\
    \x07\x03\x1a\x16\x20List\x20all\x20the\x20models.\n\n\r\n\x05\x06\0\x026\
    \x01\x12\x04\x9c\x07\x06\x17\n\r\n\x05\x06\0\x026\x02\x12\x04\x9c\x07\
    \x191\n\r\n\x05\x06\0\x026\x03\x12\x04\x9c\x07<U\n\x0f\n\x05\x06\0\x026\
    \x04\x12\x06\x9d\x07\x04\xa2\x07\x06\n\x13\n\t\x06\0\x026\x04\xb0\xca\
    \xbc\"\x12\x06\x9d\x07\x04\xa2\x07\x06\n\r\n\x05\x06\0\x026\x04\x12\x04\
    \xa3\x07\x047\n\x10\n\x08\x06\0\x026\x04\xc3\xf3\x04\x12\x04\xa3\x07\x04\
    7\n\r\n\x05\x06\0\x026\x04\x12\x04\xa4\x07\x04C\n\x11\n\t\x06\0\x026\x04\
    \xc2\xf3\x04\0\x12\x04\xa4\x07\x04C\n\r\n\x05\x06\0\x026\x04\x12\x04\xa5\
    \x07\x04A\n\x11\n\t\x06\0\x026\x04\xc2\xf3\x04\x01\x12\x04\xa5\x07\x04A\
    \n*\n\x04\x06\0\x027\x12\x06\xa9\x07\x02\xbc\x07\x03\x1a\x1a\x20PostMode\
    lVersionsPublish\n\n\r\n\x05\x06\0\x027\x01\x12\x04\xa9\x07\x06\x1e\n\r\
    \n\x05\x06\0\x027\x02\x12\x04\xa9\x07\x20?\n\r\n\x05\x06\0\x027\x03\x12\
    \x04\xa9\x07Jj\n\x0f\n\x05\x06\0\x027\x04\x12\x06\xaa\x07\x04\xb1\x07\
    \x06\n\x13\n\t\x06\0\x027\x04\xb0\xca\xbc\"\x12\x06\xaa\x07\x04\xb1\x07\
    \x06\n\r\n\x05\x06\0\x027\x04\x12\x04\xb2\x07\x047\n\x10\n\x08\x06\0\x02\
    7\x04\xc3\xf3\x04\x12\x04\xb2\x07\x047\n\r\n\x05\x06\0\x027\x04\x12\x04\
    \xb3\x07\x04F\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\0\x12\x04\xb3\x07\x04\
    F\n\r\n\x05\x06\0\x027\x04\x12\x04\xb4\x07\x04C\n\x11\n\t\x06\0\x027\x04\
    \xc2\xf3\x04\x01\x12\x04\xb4\x07\x04C\n\r\n\x05\x06\0\x027\x04\x12\x04\
    \xb5\x07\x04A\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\x02\x12\x04\xb5\x07\
    \x04A\n\r\n\x05\x06\0\x027\x04\x12\x04\xb6\x07\x04A\n\x11\n\t\x06\0\x027\
    \x04\xc2\xf3\x04\x03\x12\x04\xb6\x07\x04A\n\r\n\x05\x06\0\x027\x04\x12\
    \x04\xb7\x07\x04A\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\x04\x12\x04\xb7\
    \x07\x04A\n\r\n\x05\x06\0\x027\x04\x12\x04\xb8\x07\x04C\n\x11\n\t\x06\0\
    \x027\x04\xc2\xf3\x04\x05\x12\x04\xb8\x07\x04C\n\r\n\x05\x06\0\x027\x04\
    \x12\x04\xb9\x07\x04D\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\x06\x12\x04\
    \xb9\x07\x04D\n\r\n\x05\x06\0\x027\x04\x12\x04\xba\x07\x04B\n\x11\n\t\
    \x06\0\x027\x04\xc2\xf3\x04\x07\x12\x04\xba\x07\x04B\n\r\n\x05\x06\0\x02\
    7\x04\x12\x04\xbb\x07\x04B\n\x11\n\t\x06\0\x027\x04\xc2\xf3\x04\x08\x12\
    \x04\xbb\x07\x04B\n,\n\x04\x06\0\x028\x12\x06\xbf\x07\x02\xd2\x07\x03\
    \x1a\x1c\x20PostModelVersionsUnPublish\n\n\r\n\x05\x06\0\x028\x01\x12\
    \x04\xbf\x07\x06\x20\n\r\n\x05\x06\0\x028\x02\x12\x04\xbf\x07\"C\n\r\n\
    \x05\x06\0\x028\x03\x12\x04\xbf\x07Nn\n\x0f\n\x05\x06\0\x028\x04\x12\x06\
    \xc0\x07\x04\xc7\x07\x06\n\x13\n\t\x06\0\x028\x04\xb0\xca\xbc\"\x12\x06\
    \xc0\x07\x04\xc7\x07\x06\n\r\n\x05\x06\0\x028\x04\x12\x04\xc8\x07\x047\n\
    \x10\n\x08\x06\0\x028\x04\xc3\xf3\x04\x12\x04\xc8\x07\x047\n\r\n\x05\x06\
    \0\x028\x04\x12\x04\xc9\x07\x04F\n\x11\n\t\x06\0\x028\x04\xc2\xf3\x04\0\
    \x12\x04\xc9\x07\x04F\n\r\n\x05\x06\0\x028\x04\x12\x04\xca\x07\x04C\n\
    \x11\n\t\x06\0\x028\x04\xc2\xf3\x04\x01\x12\x04\xca\x07\x04C\n\r\n\x05\
    \x06\0\x028\x04\x12\x04\xcb\x07\x04A\n\x11\n\t\x06\0\x028\x04\xc2\xf3\
    \x04\x02\x12\x04\xcb\x07\x04A\n\r\n\x05\x06\0\x028\x04\x12\x04\xcc\x07\
    \x04A\n\x11\n\t\x06\0\x028\x04\xc2\xf3\x04\x03\x12\x04\xcc\x07\x04A\n\r\
    \n\x05\x06\0\x028\x04\x12\x04\xcd\x07\x04A\n\x11\n\t\x06\0\x028\x04\xc2\
    \xf3\x04\x04\x12\x04\xcd\x07\x04A\n\r\n\x05\x06\0\x028\x04\x12\x04\xce\
    \x07\x04C\n\x11\n\t\x06\0\x028\x04\xc2\xf3\x04\x05\x12\x04\xce\x07\x04C\
    \n\r\n\x05\x06\0\x028\x04\x12\x04\xcf\x07\x04D\n\x11\n\t\x06\0\x028\x04\
    \xc2\xf3\x04\x06\x12\x04\xcf\x07\x04D\n\r\n\x05\x06\0\x028\x04\x12\x04\
    \xd0\x07\x04B\n\x11\n\t\x06\0\x028\x04\xc2\xf3\x04\x07\x12\x04\xd0\x07\
    \x04B\n\r\n\x05\x06\0\x028\x04\x12\x04\xd1\x07\x04B\n\x11\n\t\x06\0\x028\
    \x04\xc2\xf3\x04\x08\x12\x04\xd1\x07\x04B\n\x97\x01\n\x04\x06\0\x029\x12\
    \x06\xd8\x07\x02\xeb\x07\x03\x1a>\x20Create\x20a\x20new\x20model\x20vers\
    ion\x20to\x20trigger\x20training\x20of\x20the\x20model.\n2G\x20NOTE:\x20\
    inconsistency:\x20do\x20we\x20want\x20this\x20to\x20return\x20a\x20Singl\
    eModelResponse?\n\n\r\n\x05\x06\0\x029\x01\x12\x04\xd8\x07\x06\x17\n\r\n\
    \x05\x06\0\x029\x02\x12\x04\xd8\x07\x191\n\r\n\x05\x06\0\x029\x03\x12\
    \x04\xd8\x07<O\n\x0f\n\x05\x06\0\x029\x04\x12\x06\xd9\x07\x04\xe0\x07\
    \x06\n\x13\n\t\x06\0\x029\x04\xb0\xca\xbc\"\x12\x06\xd9\x07\x04\xe0\x07\
    \x06\n\r\n\x05\x06\0\x029\x04\x12\x04\xe1\x07\x047\n\x10\n\x08\x06\0\x02\
    9\x04\xc3\xf3\x04\x12\x04\xe1\x07\x047\n\r\n\x05\x06\0\x029\x04\x12\x04\
    \xe2\x07\x04F\n\x11\n\t\x06\0\x029\x04\xc2\xf3\x04\0\x12\x04\xe2\x07\x04\
    F\n\r\n\x05\x06\0\x029\x04\x12\x04\xe3\x07\x04C\n\x11\n\t\x06\0\x029\x04\
    \xc2\xf3\x04\x01\x12\x04\xe3\x07\x04C\n\r\n\x05\x06\0\x029\x04\x12\x04\
    \xe4\x07\x04A\n\x11\n\t\x06\0\x029\x04\xc2\xf3\x04\x02\x12\x04\xe4\x07\
    \x04A\n\r\n\x05\x06\0\x029\x04\x12\x04\xe5\x07\x04A\n\x11\n\t\x06\0\x029\
    \x04\xc2\xf3\x04\x03\x12\x04\xe5\x07\x04A\n\r\n\x05\x06\0\x029\x04\x12\
    \x04\xe6\x07\x04A\n\x11\n\t\x06\0\x029\x04\xc2\xf3\x04\x04\x12\x04\xe6\
    \x07\x04A\n\r\n\x05\x06\0\x029\x04\x12\x04\xe7\x07\x04C\n\x11\n\t\x06\0\
    \x029\x04\xc2\xf3\x04\x05\x12\x04\xe7\x07\x04C\n\r\n\x05\x06\0\x029\x04\
    \x12\x04\xe8\x07\x04D\nF\n\t\x06\0\x029\x04\xc2\xf3\x04\x06\x12\x04\xe8\
    \x07\x04D\"3\x20Needs\x20to\x20check\x20the\x20base\x20workflow\x20to\
    \x20build\x20off\x20of.\n\n\r\n\x05\x06\0\x029\x04\x12\x04\xe9\x07\x04B\
    \n\x11\n\t\x06\0\x029\x04\xc2\xf3\x04\x07\x12\x04\xe9\x07\x04B\n\r\n\x05\
    \x06\0\x029\x04\x12\x04\xea\x07\x04B\n\x11\n\t\x06\0\x029\x04\xc2\xf3\
    \x04\x08\x12\x04\xea\x07\x04B\n$\n\x04\x06\0\x02:\x12\x06\xee\x07\x02\
    \xf8\x07\x03\x1a\x14\x20PatchModelVersions\n\n\r\n\x05\x06\0\x02:\x01\
    \x12\x04\xee\x07\x06\x18\n\r\n\x05\x06\0\x02:\x02\x12\x04\xee\x07\x1a3\n\
    \r\n\x05\x06\0\x02:\x03\x12\x04\xee\x07>W\n\x0f\n\x05\x06\0\x02:\x04\x12\
    \x06\xef\x07\x04\xf2\x07\x06\n\x13\n\t\x06\0\x02:\x04\xb0\xca\xbc\"\x12\
    \x06\xef\x07\x04\xf2\x07\x06\n\r\n\x05\x06\0\x02:\x04\x12\x04\xf3\x07\
    \x047\n\x10\n\x08\x06\0\x02:\x04\xc3\xf3\x04\x12\x04\xf3\x07\x047\n\r\n\
    \x05\x06\0\x02:\x04\x12\x04\xf4\x07\x04C\n\x11\n\t\x06\0\x02:\x04\xc2\
    \xf3\x04\0\x12\x04\xf4\x07\x04C\n\r\n\x05\x06\0\x02:\x04\x12\x04\xf5\x07\
    \x04A\n\x11\n\t\x06\0\x02:\x04\xc2\xf3\x04\x01\x12\x04\xf5\x07\x04A\n\r\
    \n\x05\x06\0\x02:\x04\x12\x04\xf6\x07\x04A\n\x11\n\t\x06\0\x02:\x04\xc2\
    \xf3\x04\x02\x12\x04\xf6\x07\x04A\n\r\n\x05\x06\0\x02:\x04\x12\x04\xf7\
    \x07\x04C\n\x11\n\t\x06\0\x02:\x04\xc2\xf3\x04\x03\x12\x04\xf7\x07\x04C\
    \n(\n\x04\x06\0\x02;\x12\x06\xfb\x07\x02\x88\x08\x03\x1a\x18\x20Delete\
    \x20a\x20single\x20model.\n\n\r\n\x05\x06\0\x02;\x01\x12\x04\xfb\x07\x06\
    \x18\n\r\n\x05\x06\0\x02;\x02\x12\x04\xfb\x07\x1a3\n\r\n\x05\x06\0\x02;\
    \x03\x12\x04\xfb\x07>^\n\x0f\n\x05\x06\0\x02;\x04\x12\x06\xfc\x07\x04\
    \x81\x08\x06\n\x13\n\t\x06\0\x02;\x04\xb0\xca\xbc\"\x12\x06\xfc\x07\x04\
    \x81\x08\x06\n\r\n\x05\x06\0\x02;\x04\x12\x04\x82\x08\x047\n\x10\n\x08\
    \x06\0\x02;\x04\xc3\xf3\x04\x12\x04\x82\x08\x047\n\r\n\x05\x06\0\x02;\
    \x04\x12\x04\x83\x08\x04C\n\x11\n\t\x06\0\x02;\x04\xc2\xf3\x04\0\x12\x04\
    \x83\x08\x04C\n\r\n\x05\x06\0\x02;\x04\x12\x04\x84\x08\x04A\n\x11\n\t\
    \x06\0\x02;\x04\xc2\xf3\x04\x01\x12\x04\x84\x08\x04A\n\r\n\x05\x06\0\x02\
    ;\x04\x12\x04\x85\x08\x04D\n\x11\n\t\x06\0\x02;\x04\xc2\xf3\x04\x02\x12\
    \x04\x85\x08\x04D\n\r\n\x05\x06\0\x02;\x04\x12\x04\x86\x08\x04A\n\x11\n\
    \t\x06\0\x02;\x04\xc2\xf3\x04\x03\x12\x04\x86\x08\x04A\n\r\n\x05\x06\0\
    \x02;\x04\x12\x04\x87\x08\x04D\n\x11\n\t\x06\0\x02;\x04\xc2\xf3\x04\x04\
    \x12\x04\x87\x08\x04D\nA\n\x04\x06\0\x02<\x12\x06\x8b\x08\x02\x98\x08\
    \x03\x1a1\x20Get\x20the\x20evaluation\x20metrics\x20for\x20a\x20model\
    \x20version.\n\n\r\n\x05\x06\0\x02<\x01\x12\x04\x8b\x08\x06\x1c\n\r\n\
    \x05\x06\0\x02<\x02\x12\x04\x8b\x08\x1e;\n\r\n\x05\x06\0\x02<\x03\x12\
    \x04\x8b\x08F`\n\x0f\n\x05\x06\0\x02<\x04\x12\x06\x8c\x08\x04\x91\x08\
    \x06\n\x13\n\t\x06\0\x02<\x04\xb0\xca\xbc\"\x12\x06\x8c\x08\x04\x91\x08\
    \x06\n\r\n\x05\x06\0\x02<\x04\x12\x04\x92\x08\x047\n\x10\n\x08\x06\0\x02\
    <\x04\xc3\xf3\x04\x12\x04\x92\x08\x047\n\r\n\x05\x06\0\x02<\x04\x12\x04\
    \x93\x08\x04F\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\0\x12\x04\x93\x08\x04\
    F\n\r\n\x05\x06\0\x02<\x04\x12\x04\x94\x08\x04C\n\x11\n\t\x06\0\x02<\x04\
    \xc2\xf3\x04\x01\x12\x04\x94\x08\x04C\n\r\n\x05\x06\0\x02<\x04\x12\x04\
    \x95\x08\x04A\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\x02\x12\x04\x95\x08\
    \x04A\n\r\n\x05\x06\0\x02<\x04\x12\x04\x96\x08\x04A\n\x11\n\t\x06\0\x02<\
    \x04\xc2\xf3\x04\x03\x12\x04\x96\x08\x04A\n\r\n\x05\x06\0\x02<\x04\x12\
    \x04\x97\x08\x04B\n\x11\n\t\x06\0\x02<\x04\xc2\xf3\x04\x04\x12\x04\x97\
    \x08\x04B\nA\n\x04\x06\0\x02=\x12\x06\x9b\x08\x02\xaf\x08\x03\x1a1\x20Ru\
    n\x20the\x20evaluation\x20metrics\x20for\x20a\x20model\x20version.\n\n\r\
    \n\x05\x06\0\x02=\x01\x12\x04\x9b\x08\x06\x1d\n\r\n\x05\x06\0\x02=\x02\
    \x12\x04\x9b\x08\x1f=\n\r\n\x05\x06\0\x02=\x03\x12\x04\x9b\x08Hb\n\x0f\n\
    \x05\x06\0\x02=\x04\x12\x06\x9c\x08\x04\xa3\x08\x06\n\x13\n\t\x06\0\x02=\
    \x04\xb0\xca\xbc\"\x12\x06\x9c\x08\x04\xa3\x08\x06\n\r\n\x05\x06\0\x02=\
    \x04\x12\x04\xa4\x08\x047\n\x10\n\x08\x06\0\x02=\x04\xc3\xf3\x04\x12\x04\
    \xa4\x08\x047\n\r\n\x05\x06\0\x02=\x04\x12\x04\xa5\x08\x04F\n\x11\n\t\
    \x06\0\x02=\x04\xc2\xf3\x04\0\x12\x04\xa5\x08\x04F\n\r\n\x05\x06\0\x02=\
    \x04\x12\x04\xa6\x08\x04C\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x01\x12\
    \x04\xa6\x08\x04C\n\r\n\x05\x06\0\x02=\x04\x12\x04\xa7\x08\x04A\n\x11\n\
    \t\x06\0\x02=\x04\xc2\xf3\x04\x02\x12\x04\xa7\x08\x04A\n\r\n\x05\x06\0\
    \x02=\x04\x12\x04\xa8\x08\x04A\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x03\
    \x12\x04\xa8\x08\x04A\n\r\n\x05\x06\0\x02=\x04\x12\x04\xa9\x08\x04A\n\
    \x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x04\x12\x04\xa9\x08\x04A\n\r\n\x05\
    \x06\0\x02=\x04\x12\x04\xaa\x08\x04C\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\
    \x04\x05\x12\x04\xaa\x08\x04C\n\r\n\x05\x06\0\x02=\x04\x12\x04\xab\x08\
    \x04>\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x06\x12\x04\xab\x08\x04>\n\r\
    \n\x05\x06\0\x02=\x04\x12\x04\xac\x08\x04D\nF\n\t\x06\0\x02=\x04\xc2\xf3\
    \x04\x07\x12\x04\xac\x08\x04D\"3\x20Needs\x20to\x20check\x20the\x20base\
    \x20workflow\x20to\x20build\x20off\x20of.\n\n\r\n\x05\x06\0\x02=\x04\x12\
    \x04\xad\x08\x04B\n\x11\n\t\x06\0\x02=\x04\xc2\xf3\x04\x08\x12\x04\xad\
    \x08\x04B\n\r\n\x05\x06\0\x02=\x04\x12\x04\xae\x08\x04B\n\x11\n\t\x06\0\
    \x02=\x04\xc2\xf3\x04\t\x12\x04\xae\x08\x04B\nG\n\x04\x06\0\x02>\x12\x06\
    \xb2\x08\x02\xbb\x08\x03\x1a7\x20Lists\x20model\x20references\x20tied\
    \x20to\x20a\x20particular\x20model\x20id.\n\n\r\n\x05\x06\0\x02>\x01\x12\
    \x04\xb2\x08\x06\x19\n\r\n\x05\x06\0\x02>\x02\x12\x04\xb2\x08\x1b5\n\r\n\
    \x05\x06\0\x02>\x03\x12\x04\xb2\x08@[\n\x0f\n\x05\x06\0\x02>\x04\x12\x06\
    \xb3\x08\x04\xb8\x08\x06\n\x13\n\t\x06\0\x02>\x04\xb0\xca\xbc\"\x12\x06\
    \xb3\x08\x04\xb8\x08\x06\n\r\n\x05\x06\0\x02>\x04\x12\x04\xb9\x08\x047\n\
    \x10\n\x08\x06\0\x02>\x04\xc3\xf3\x04\x12\x04\xb9\x08\x047\n\r\n\x05\x06\
    \0\x02>\x04\x12\x04\xba\x08\x04A\n\x11\n\t\x06\0\x02>\x04\xc2\xf3\x04\0\
    \x12\x04\xba\x08\x04A\n-\n\x04\x06\0\x02?\x12\x06\xc0\x08\x02\xc9\x08\
    \x03\x1a\x1d\x20GetModelVersionInputExample\n\n\r\n\x05\x06\0\x02?\x01\
    \x12\x04\xc0\x08\x06!\n\r\n\x05\x06\0\x02?\x02\x12\x04\xc0\x08#E\n\r\n\
    \x05\x06\0\x02?\x03\x12\x04\xc0\x08Pv\n\x0f\n\x05\x06\0\x02?\x04\x12\x06\
    \xc1\x08\x04\xc6\x08\x06\n\x13\n\t\x06\0\x02?\x04\xb0\xca\xbc\"\x12\x06\
    \xc1\x08\x04\xc6\x08\x06\n\r\n\x05\x06\0\x02?\x04\x12\x04\xc7\x08\x047\n\
    \x10\n\x08\x06\0\x02?\x04\xc3\xf3\x04\x12\x04\xc7\x08\x047\n\r\n\x05\x06\
    \0\x02?\x04\x12\x04\xc8\x08\x04A\n\x11\n\t\x06\0\x02?\x04\xc2\xf3\x04\0\
    \x12\x04\xc8\x08\x04A\n/\n\x04\x06\0\x02@\x12\x06\xcc\x08\x02\xd5\x08\
    \x03\x1a\x1f\x20ListModelVersionInputExamples\n\n\r\n\x05\x06\0\x02@\x01\
    \x12\x04\xcc\x08\x06#\n\r\n\x05\x06\0\x02@\x02\x12\x04\xcc\x08%I\n\r\n\
    \x05\x06\0\x02@\x03\x12\x04\xcc\x08Ty\n\x0f\n\x05\x06\0\x02@\x04\x12\x06\
    \xcd\x08\x04\xd2\x08\x06\n\x13\n\t\x06\0\x02@\x04\xb0\xca\xbc\"\x12\x06\
    \xcd\x08\x04\xd2\x08\x06\n\r\n\x05\x06\0\x02@\x04\x12\x04\xd3\x08\x047\n\
    \x10\n\x08\x06\0\x02@\x04\xc3\xf3\x04\x12\x04\xd3\x08\x047\n\r\n\x05\x06\
    \0\x02@\x04\x12\x04\xd4\x08\x04A\n\x11\n\t\x06\0\x02@\x04\xc2\xf3\x04\0\
    \x12\x04\xd4\x08\x04A\n\xba\x01\n\x04\x06\0\x02A\x12\x06\xe8\x08\x02\xf2\
    \x08\x03\x1a&\x20Get\x20a\x20specific\x20workflow\x20from\x20an\x20app.\
    \n2'//////////////////////////////////////\n2Y//////////////////////////\
    ////////////\n\x20Workflows\n//////////////////////////////////////\n\n\
    \r\n\x05\x06\0\x02A\x01\x12\x04\xe8\x08\x06\x11\n\r\n\x05\x06\0\x02A\x02\
    \x12\x04\xe8\x08\x13%\n\r\n\x05\x06\0\x02A\x03\x12\x04\xe8\x080F\n\x0f\n\
    \x05\x06\0\x02A\x04\x12\x06\xe9\x08\x04\xee\x08\x06\n\x13\n\t\x06\0\x02A\
    \x04\xb0\xca\xbc\"\x12\x06\xe9\x08\x04\xee\x08\x06\n\r\n\x05\x06\0\x02A\
    \x04\x12\x04\xef\x08\x047\n\x10\n\x08\x06\0\x02A\x04\xc3\xf3\x04\x12\x04\
    \xef\x08\x047\n\r\n\x05\x06\0\x02A\x04\x12\x04\xf0\x08\x04A\n\x11\n\t\
    \x06\0\x02A\x04\xc2\xf3\x04\0\x12\x04\xf0\x08\x04A\n\r\n\x05\x06\0\x02A\
    \x04\x12\x04\xf1\x08\x04D\n\x11\n\t\x06\0\x02A\x04\xc2\xf3\x04\x01\x12\
    \x04\xf1\x08\x04D\n)\n\x04\x06\0\x02B\x12\x06\xf5\x08\x02\x82\t\x03\x1a\
    \x19\x20List\x20all\x20the\x20workflows.\n\n\r\n\x05\x06\0\x02B\x01\x12\
    \x04\xf5\x08\x06\x13\n\r\n\x05\x06\0\x02B\x02\x12\x04\xf5\x08\x15)\n\r\n\
    \x05\x06\0\x02B\x03\x12\x04\xf5\x084I\n\x0f\n\x05\x06\0\x02B\x04\x12\x06\
    \xf6\x08\x04\xfe\x08\x06\n\x13\n\t\x06\0\x02B\x04\xb0\xca\xbc\"\x12\x06\
    \xf6\x08\x04\xfe\x08\x06\n\r\n\x05\x06\0\x02B\x04\x12\x04\xff\x08\x047\n\
    \x10\n\x08\x06\0\x02B\x04\xc3\xf3\x04\x12\x04\xff\x08\x047\n\r\n\x05\x06\
    \0\x02B\x04\x12\x04\x80\t\x04A\n\x11\n\t\x06\0\x02B\x04\xc2\xf3\x04\0\
    \x12\x04\x80\t\x04A\n\r\n\x05\x06\0\x02B\x04\x12\x04\x81\t\x04D\n\x11\n\
    \t\x06\0\x02B\x04\xc2\xf3\x04\x01\x12\x04\x81\t\x04D\n+\n\x04\x06\0\x02C\
    \x12\x06\x86\t\x02\x93\t\x03\x1a\x1b\x20Add\x20a\x20workflow\x20to\x20an\
    \x20app.\n\n\r\n\x05\x06\0\x02C\x01\x12\x04\x86\t\x06\x13\n\r\n\x05\x06\
    \0\x02C\x02\x12\x04\x86\t\x15)\n\r\n\x05\x06\0\x02C\x03\x12\x04\x86\t4I\
    \n\x0f\n\x05\x06\0\x02C\x04\x12\x06\x87\t\x04\x8e\t\x06\n\x13\n\t\x06\0\
    \x02C\x04\xb0\xca\xbc\"\x12\x06\x87\t\x04\x8e\t\x06\n\r\n\x05\x06\0\x02C\
    \x04\x12\x04\x8f\t\x047\n\x10\n\x08\x06\0\x02C\x04\xc3\xf3\x04\x12\x04\
    \x8f\t\x047\n\r\n\x05\x06\0\x02C\x04\x12\x04\x90\t\x04A\n\x11\n\t\x06\0\
    \x02C\x04\xc2\xf3\x04\0\x12\x04\x90\t\x04A\n\r\n\x05\x06\0\x02C\x04\x12\
    \x04\x91\t\x04D\n\x11\n\t\x06\0\x02C\x04\xc2\xf3\x04\x01\x12\x04\x91\t\
    \x04D\n\r\n\x05\x06\0\x02C\x04\x12\x04\x92\t\x04D\n\x11\n\t\x06\0\x02C\
    \x04\xc2\xf3\x04\x02\x12\x04\x92\t\x04D\n.\n\x04\x06\0\x02D\x12\x06\x96\
    \t\x02\xa3\t\x03\x1a\x1e\x20Patch\x20one\x20or\x20more\x20workflows.\n\n\
    \r\n\x05\x06\0\x02D\x01\x12\x04\x96\t\x06\x14\n\r\n\x05\x06\0\x02D\x02\
    \x12\x04\x96\t\x16+\n\r\n\x05\x06\0\x02D\x03\x12\x04\x96\t6K\n\x0f\n\x05\
    \x06\0\x02D\x04\x12\x06\x97\t\x04\x9e\t\x06\n\x13\n\t\x06\0\x02D\x04\xb0\
    \xca\xbc\"\x12\x06\x97\t\x04\x9e\t\x06\n\r\n\x05\x06\0\x02D\x04\x12\x04\
    \x9f\t\x047\n\x10\n\x08\x06\0\x02D\x04\xc3\xf3\x04\x12\x04\x9f\t\x047\n\
    \r\n\x05\x06\0\x02D\x04\x12\x04\xa0\t\x04A\n\x11\n\t\x06\0\x02D\x04\xc2\
    \xf3\x04\0\x12\x04\xa0\t\x04A\n\r\n\x05\x06\0\x02D\x04\x12\x04\xa1\t\x04\
    D\n\x11\n\t\x06\0\x02D\x04\xc2\xf3\x04\x01\x12\x04\xa1\t\x04D\n\r\n\x05\
    \x06\0\x02D\x04\x12\x04\xa2\t\x04D\n\x11\n\t\x06\0\x02D\x04\xc2\xf3\x04\
    \x02\x12\x04\xa2\t\x04D\n+\n\x04\x06\0\x02E\x12\x06\xa6\t\x02\xb1\t\x03\
    \x1a\x1b\x20Delete\x20a\x20single\x20workflow.\n\n\r\n\x05\x06\0\x02E\
    \x01\x12\x04\xa6\t\x06\x14\n\r\n\x05\x06\0\x02E\x02\x12\x04\xa6\t\x16+\n\
    \r\n\x05\x06\0\x02E\x03\x12\x04\xa6\t6V\n\x0f\n\x05\x06\0\x02E\x04\x12\
    \x06\xa7\t\x04\xac\t\x06\n\x13\n\t\x06\0\x02E\x04\xb0\xca\xbc\"\x12\x06\
    \xa7\t\x04\xac\t\x06\n\r\n\x05\x06\0\x02E\x04\x12\x04\xad\t\x047\n\x10\n\
    \x08\x06\0\x02E\x04\xc3\xf3\x04\x12\x04\xad\t\x047\n\r\n\x05\x06\0\x02E\
    \x04\x12\x04\xae\t\x04D\n\x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\0\x12\x04\
    \xae\t\x04D\n\r\n\x05\x06\0\x02E\x04\x12\x04\xaf\t\x04G\n\x11\n\t\x06\0\
    \x02E\x04\xc2\xf3\x04\x01\x12\x04\xaf\t\x04G\n\r\n\x05\x06\0\x02E\x04\
    \x12\x04\xb0\t\x04D\n\x11\n\t\x06\0\x02E\x04\xc2\xf3\x04\x02\x12\x04\xb0\
    \t\x04D\n;\n\x04\x06\0\x02F\x12\x06\xb4\t\x02\xc1\t\x03\x1a+\x20Delete\
    \x20multiple\x20workflows\x20in\x20one\x20request.\n\n\r\n\x05\x06\0\x02\
    F\x01\x12\x04\xb4\t\x06\x15\n\r\n\x05\x06\0\x02F\x02\x12\x04\xb4\t\x17-\
    \n\r\n\x05\x06\0\x02F\x03\x12\x04\xb4\t8X\n\x0f\n\x05\x06\0\x02F\x04\x12\
    \x06\xb5\t\x04\xbc\t\x06\n\x13\n\t\x06\0\x02F\x04\xb0\xca\xbc\"\x12\x06\
    \xb5\t\x04\xbc\t\x06\n\r\n\x05\x06\0\x02F\x04\x12\x04\xbd\t\x047\n\x10\n\
    \x08\x06\0\x02F\x04\xc3\xf3\x04\x12\x04\xbd\t\x047\n\r\n\x05\x06\0\x02F\
    \x04\x12\x04\xbe\t\x04D\n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\0\x12\x04\
    \xbe\t\x04D\n\r\n\x05\x06\0\x02F\x04\x12\x04\xbf\t\x04G\n\x11\n\t\x06\0\
    \x02F\x04\xc2\xf3\x04\x01\x12\x04\xbf\t\x04G\n\r\n\x05\x06\0\x02F\x04\
    \x12\x04\xc0\t\x04D\n\x11\n\t\x06\0\x02F\x04\xc2\xf3\x04\x02\x12\x04\xc0\
    \t\x04D\n+\n\x04\x06\0\x02G\x12\x06\xc4\t\x02\xd6\t\x03\x1a\x1b\x20Predi\
    ct\x20using\x20a\x20workflow.\n\n\r\n\x05\x06\0\x02G\x01\x12\x04\xc4\t\
    \x06\x19\n\r\n\x05\x06\0\x02G\x02\x12\x04\xc4\t\x1b5\n\r\n\x05\x06\0\x02\
    G\x03\x12\x04\xc4\t@[\n\x0f\n\x05\x06\0\x02G\x04\x12\x06\xc5\t\x04\xd0\t\
    \x06\n\x13\n\t\x06\0\x02G\x04\xb0\xca\xbc\"\x12\x06\xc5\t\x04\xd0\t\x06\
    \n\r\n\x05\x06\0\x02G\x04\x12\x04\xd1\t\x047\n\x10\n\x08\x06\0\x02G\x04\
    \xc3\xf3\x04\x12\x04\xd1\t\x047\n\r\n\x05\x06\0\x02G\x04\x12\x04\xd2\t\
    \x04A\n\x11\n\t\x06\0\x02G\x04\xc2\xf3\x04\0\x12\x04\xd2\t\x04A\n\r\n\
    \x05\x06\0\x02G\x04\x12\x04\xd3\t\x04C\n\x11\n\t\x06\0\x02G\x04\xc2\xf3\
    \x04\x01\x12\x04\xd3\t\x04C\n\r\n\x05\x06\0\x02G\x04\x12\x04\xd4\t\x04>\
    \n\x11\n\t\x06\0\x02G\x04\xc2\xf3\x04\x02\x12\x04\xd4\t\x04>\n\r\n\x05\
    \x06\0\x02G\x04\x12\x04\xd5\t\x04D\n\x11\n\t\x06\0\x02G\x04\xc2\xf3\x04\
    \x03\x12\x04\xd5\t\x04D\n?\n\x04\x06\0\x02H\x12\x06\xd9\t\x02\xeb\t\x03\
    \x1a/\x20Compare\x20embeddings\x20distances\x20using\x20a\x20workflow\n\
    \n\r\n\x05\x06\0\x02H\x01\x12\x04\xd9\t\x06#\n\r\n\x05\x06\0\x02H\x02\
    \x12\x04\xd9\t$H\n\r\n\x05\x06\0\x02H\x03\x12\x04\xd9\tSx\n\x0f\n\x05\
    \x06\0\x02H\x04\x12\x06\xda\t\x04\xe5\t\x06\n\x13\n\t\x06\0\x02H\x04\xb0\
    \xca\xbc\"\x12\x06\xda\t\x04\xe5\t\x06\n\r\n\x05\x06\0\x02H\x04\x12\x04\
    \xe6\t\x047\n\x10\n\x08\x06\0\x02H\x04\xc3\xf3\x04\x12\x04\xe6\t\x047\n\
    \r\n\x05\x06\0\x02H\x04\x12\x04\xe7\t\x04A\n\x11\n\t\x06\0\x02H\x04\xc2\
    \xf3\x04\0\x12\x04\xe7\t\x04A\n\r\n\x05\x06\0\x02H\x04\x12\x04\xe8\t\x04\
    C\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\x01\x12\x04\xe8\t\x04C\n\r\n\x05\
    \x06\0\x02H\x04\x12\x04\xe9\t\x04>\n\x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\
    \x02\x12\x04\xe9\t\x04>\n\r\n\x05\x06\0\x02H\x04\x12\x04\xea\t\x04D\n\
    \x11\n\t\x06\0\x02H\x04\xc2\xf3\x04\x03\x12\x04\xea\t\x04D\n)\n\x04\x06\
    \0\x02I\x12\x06\xee\t\x02\xf8\t\x03\x1a\x19\x20List\x20workflow\x20versi\
    ons.\n\n\r\n\x05\x06\0\x02I\x01\x12\x04\xee\t\x06\x1a\n\r\n\x05\x06\0\
    \x02I\x02\x12\x04\xee\t\x1c7\n\r\n\x05\x06\0\x02I\x03\x12\x04\xee\tB^\n\
    \x0f\n\x05\x06\0\x02I\x04\x12\x06\xef\t\x04\xf4\t\x06\n\x13\n\t\x06\0\
    \x02I\x04\xb0\xca\xbc\"\x12\x06\xef\t\x04\xf4\t\x06\n\r\n\x05\x06\0\x02I\
    \x04\x12\x04\xf5\t\x047\n\x10\n\x08\x06\0\x02I\x04\xc3\xf3\x04\x12\x04\
    \xf5\t\x047\n\r\n\x05\x06\0\x02I\x04\x12\x04\xf6\t\x04A\n\x11\n\t\x06\0\
    \x02I\x04\xc2\xf3\x04\0\x12\x04\xf6\t\x04A\n\r\n\x05\x06\0\x02I\x04\x12\
    \x04\xf7\t\x04D\n\x11\n\t\x06\0\x02I\x04\xc2\xf3\x04\x01\x12\x04\xf7\t\
    \x04D\n.\n\x04\x06\0\x02J\x12\x06\xfb\t\x02\x85\n\x03\x1a\x1e\x20Get\x20\
    single\x20workflow\x20version.\n\n\r\n\x05\x06\0\x02J\x01\x12\x04\xfb\t\
    \x06\x18\n\r\n\x05\x06\0\x02J\x02\x12\x04\xfb\t\x1a3\n\r\n\x05\x06\0\x02\
    J\x03\x12\x04\xfb\t>[\n\x0f\n\x05\x06\0\x02J\x04\x12\x06\xfc\t\x06\x81\n\
    \x08\n\x13\n\t\x06\0\x02J\x04\xb0\xca\xbc\"\x12\x06\xfc\t\x06\x81\n\x08\
    \n\r\n\x05\x06\0\x02J\x04\x12\x04\x82\n\x069\n\x10\n\x08\x06\0\x02J\x04\
    \xc3\xf3\x04\x12\x04\x82\n\x069\n\r\n\x05\x06\0\x02J\x04\x12\x04\x83\n\
    \x06C\n\x11\n\t\x06\0\x02J\x04\xc2\xf3\x04\0\x12\x04\x83\n\x06C\n\r\n\
    \x05\x06\0\x02J\x04\x12\x04\x84\n\x06F\n\x11\n\t\x06\0\x02J\x04\xc2\xf3\
    \x04\x01\x12\x04\x84\n\x06F\n+\n\x04\x06\0\x02K\x12\x06\x88\n\x02\x95\n\
    \x03\x1a\x1b\x20Delete\x20workflow\x20versions.\n\n\r\n\x05\x06\0\x02K\
    \x01\x12\x04\x88\n\x06\x1c\n\r\n\x05\x06\0\x02K\x02\x12\x04\x88\n\x1e;\n\
    \r\n\x05\x06\0\x02K\x03\x12\x04\x88\nFf\n\x0f\n\x05\x06\0\x02K\x04\x12\
    \x06\x89\n\x06\x90\n\x08\n\x13\n\t\x06\0\x02K\x04\xb0\xca\xbc\"\x12\x06\
    \x89\n\x06\x90\n\x08\n\r\n\x05\x06\0\x02K\x04\x12\x04\x91\n\x069\n\x10\n\
    \x08\x06\0\x02K\x04\xc3\xf3\x04\x12\x04\x91\n\x069\n\r\n\x05\x06\0\x02K\
    \x04\x12\x04\x92\n\x06F\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\0\x12\x04\
    \x92\n\x06F\n\r\n\x05\x06\0\x02K\x04\x12\x04\x93\n\x06F\n\x11\n\t\x06\0\
    \x02K\x04\xc2\xf3\x04\x01\x12\x04\x93\n\x06F\n\r\n\x05\x06\0\x02K\x04\
    \x12\x04\x94\n\x06I\n\x11\n\t\x06\0\x02K\x04\xc2\xf3\x04\x02\x12\x04\x94\
    \n\x06I\n*\n\x04\x06\0\x02L\x12\x06\x98\n\x02\xa5\n\x03\x1a\x1a\x20Patch\
    \x20workflow\x20versions.\n\n\r\n\x05\x06\0\x02L\x01\x12\x04\x98\n\x06\
    \x1b\n\r\n\x05\x06\0\x02L\x02\x12\x04\x98\n\x1d9\n\r\n\x05\x06\0\x02L\
    \x03\x12\x04\x98\nD`\n\x0f\n\x05\x06\0\x02L\x04\x12\x06\x99\n\x06\xa0\n\
    \x08\n\x13\n\t\x06\0\x02L\x04\xb0\xca\xbc\"\x12\x06\x99\n\x06\xa0\n\x08\
    \n\r\n\x05\x06\0\x02L\x04\x12\x04\xa1\n\x069\n\x10\n\x08\x06\0\x02L\x04\
    \xc3\xf3\x04\x12\x04\xa1\n\x069\n\r\n\x05\x06\0\x02L\x04\x12\x04\xa2\n\
    \x06C\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\0\x12\x04\xa2\n\x06C\n\r\n\
    \x05\x06\0\x02L\x04\x12\x04\xa3\n\x06F\n\x11\n\t\x06\0\x02L\x04\xc2\xf3\
    \x04\x01\x12\x04\xa3\n\x06F\n\r\n\x05\x06\0\x02L\x04\x12\x04\xa4\n\x06F\
    \n\x11\n\t\x06\0\x02L\x04\xc2\xf3\x04\x02\x12\x04\xa4\n\x06F\n1\n\x04\
    \x06\0\x02M\x12\x06\xad\n\x02\xb3\n\x03\x1a!\x20Get\x20a\x20specific\x20\
    key\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02M\x01\x12\x04\xad\n\x06\
    \x0c\n\r\n\x05\x06\0\x02M\x02\x12\x04\xad\n\x0e\x1b\n\r\n\x05\x06\0\x02M\
    \x03\x12\x04\xad\n&7\n\x0f\n\x05\x06\0\x02M\x04\x12\x06\xae\n\x04\xb0\n\
    \x06\n\x13\n\t\x06\0\x02M\x04\xb0\xca\xbc\"\x12\x06\xae\n\x04\xb0\n\x06\
    \n\r\n\x05\x06\0\x02M\x04\x12\x04\xb1\n\x047\n\x10\n\x08\x06\0\x02M\x04\
    \xc3\xf3\x04\x12\x04\xb1\n\x047\n\r\n\x05\x06\0\x02M\x04\x12\x04\xb2\n\
    \x04?\n\x11\n\t\x06\0\x02M\x04\xc2\xf3\x04\0\x12\x04\xb2\n\x04?\n$\n\x04\
    \x06\0\x02N\x12\x06\xb6\n\x02\xbc\n\x03\x1a\x14\x20List\x20all\x20the\
    \x20keys.\n\n\r\n\x05\x06\0\x02N\x01\x12\x04\xb6\n\x06\x0e\n\r\n\x05\x06\
    \0\x02N\x02\x12\x04\xb6\n\x10\x1f\n\r\n\x05\x06\0\x02N\x03\x12\x04\xb6\n\
    *:\n\x0f\n\x05\x06\0\x02N\x04\x12\x06\xb7\n\x04\xb9\n\x06\n\x13\n\t\x06\
    \0\x02N\x04\xb0\xca\xbc\"\x12\x06\xb7\n\x04\xb9\n\x06\n\r\n\x05\x06\0\
    \x02N\x04\x12\x04\xba\n\x047\n\x10\n\x08\x06\0\x02N\x04\xc3\xf3\x04\x12\
    \x04\xba\n\x047\n\r\n\x05\x06\0\x02N\x04\x12\x04\xbb\n\x04?\n\x11\n\t\
    \x06\0\x02N\x04\xc2\xf3\x04\0\x12\x04\xbb\n\x04?\n%\n\x04\x06\0\x02O\x12\
    \x06\xbf\n\x02\xc5\n\x03\x1a\x15\x20List\x20keys\x20by\x20app_id\n\n\r\n\
    \x05\x06\0\x02O\x01\x12\x04\xbf\n\x06\x11\n\r\n\x05\x06\0\x02O\x02\x12\
    \x04\xbf\n\x13%\n\r\n\x05\x06\0\x02O\x03\x12\x04\xbf\n0@\n\x0f\n\x05\x06\
    \0\x02O\x04\x12\x06\xc0\n\x04\xc2\n\x06\n\x13\n\t\x06\0\x02O\x04\xb0\xca\
    \xbc\"\x12\x06\xc0\n\x04\xc2\n\x06\n\r\n\x05\x06\0\x02O\x04\x12\x04\xc3\
    \n\x047\n\x10\n\x08\x06\0\x02O\x04\xc3\xf3\x04\x12\x04\xc3\n\x047\n\r\n\
    \x05\x06\0\x02O\x04\x12\x04\xc4\n\x04?\n\x11\n\t\x06\0\x02O\x04\xc2\xf3\
    \x04\0\x12\x04\xc4\n\x04?\n\xc9\x01\n\x04\x06\0\x02P\x12\x06\xca\n\x02\
    \xd2\n\x03\x1a\xb8\x01\x20Search\x20over\x20the\x20keys\x20to\x20find\
    \x20one\x20or\x20more\x20you're\x20looking\x20for.\n\x20This\x20leverage\
    \x20the\x20\"body\"\x20parameter\x20because\x20we\x20also\x20have\x20pag\
    e\x20and\n\x20per_page\x20as\x20url\x20query\x20param\x20variables\x20in\
    \x20this\x20request.\n\n\r\n\x05\x06\0\x02P\x01\x12\x04\xca\n\x06\x0f\n\
    \r\n\x05\x06\0\x02P\x02\x12\x04\xca\n\x11!\n\r\n\x05\x06\0\x02P\x03\x12\
    \x04\xca\n,L\n\x0f\n\x05\x06\0\x02P\x04\x12\x06\xcb\n\x04\xcd\n\x06\n\
    \x13\n\t\x06\0\x02P\x04\xb0\xca\xbc\"\x12\x06\xcb\n\x04\xcd\n\x06\n\r\n\
    \x05\x06\0\x02P\x04\x12\x04\xce\n\x047\n\x10\n\x08\x06\0\x02P\x04\xc3\
    \xf3\x04\x12\x04\xce\n\x047\n\r\n\x05\x06\0\x02P\x04\x12\x04\xcf\n\x04?\
    \n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\0\x12\x04\xcf\n\x04?\n\r\n\x05\x06\
    \0\x02P\x04\x12\x04\xd0\n\x04B\n\x11\n\t\x06\0\x02P\x04\xc2\xf3\x04\x01\
    \x12\x04\xd0\n\x04B\n\r\n\x05\x06\0\x02P\x04\x12\x04\xd1\n\x04?\n\x11\n\
    \t\x06\0\x02P\x04\xc2\xf3\x04\x02\x12\x04\xd1\n\x04?\n&\n\x04\x06\0\x02Q\
    \x12\x06\xd5\n\x02\xde\n\x03\x1a\x16\x20Add\x20a\x20key\x20to\x20an\x20a\
    pp.\n\n\r\n\x05\x06\0\x02Q\x01\x12\x04\xd5\n\x06\x0e\n\r\n\x05\x06\0\x02\
    Q\x02\x12\x04\xd5\n\x10\x1f\n\r\n\x05\x06\0\x02Q\x03\x12\x04\xd5\n*:\n\
    \x0f\n\x05\x06\0\x02Q\x04\x12\x06\xd6\n\x04\xd9\n\x06\n\x13\n\t\x06\0\
    \x02Q\x04\xb0\xca\xbc\"\x12\x06\xd6\n\x04\xd9\n\x06\n\r\n\x05\x06\0\x02Q\
    \x04\x12\x04\xda\n\x047\n\x10\n\x08\x06\0\x02Q\x04\xc3\xf3\x04\x12\x04\
    \xda\n\x047\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xdb\n\x04?\n\x11\n\t\x06\0\
    \x02Q\x04\xc2\xf3\x04\0\x12\x04\xdb\n\x04?\n\r\n\x05\x06\0\x02Q\x04\x12\
    \x04\xdc\n\x04?\n\x11\n\t\x06\0\x02Q\x04\xc2\xf3\x04\x01\x12\x04\xdc\n\
    \x04?\n\r\n\x05\x06\0\x02Q\x04\x12\x04\xdd\n\x04?\n\x11\n\t\x06\0\x02Q\
    \x04\xc2\xf3\x04\x02\x12\x04\xdd\n\x04?\n)\n\x04\x06\0\x02R\x12\x06\xe1\
    \n\x02\xe9\n\x03\x1a\x19\x20Patch\x20one\x20or\x20more\x20keys.\n\n\r\n\
    \x05\x06\0\x02R\x01\x12\x04\xe1\n\x06\x0f\n\r\n\x05\x06\0\x02R\x02\x12\
    \x04\xe1\n\x11!\n\r\n\x05\x06\0\x02R\x03\x12\x04\xe1\n,<\n\x0f\n\x05\x06\
    \0\x02R\x04\x12\x06\xe2\n\x04\xe5\n\x06\n\x13\n\t\x06\0\x02R\x04\xb0\xca\
    \xbc\"\x12\x06\xe2\n\x04\xe5\n\x06\n\r\n\x05\x06\0\x02R\x04\x12\x04\xe6\
    \n\x047\n\x10\n\x08\x06\0\x02R\x04\xc3\xf3\x04\x12\x04\xe6\n\x047\n\r\n\
    \x05\x06\0\x02R\x04\x12\x04\xe7\n\x04?\n\x11\n\t\x06\0\x02R\x04\xc2\xf3\
    \x04\0\x12\x04\xe7\n\x04?\n\r\n\x05\x06\0\x02R\x04\x12\x04\xe8\n\x04?\n\
    \x11\n\t\x06\0\x02R\x04\xc2\xf3\x04\x01\x12\x04\xe8\n\x04?\n\xc5\x01\n\
    \x04\x06\0\x02S\x12\x06\xee\n\x02\xf9\n\x03\x1a\xb4\x01\x20API\x20Keys\
    \x20in\x20the\x20public\x20API\x20--\x20request\x20is\x20itself\x20Key\
    \x20authorized,\x20and\x20will\x20tell\n\x20the\x20user\x20the\x20scopes\
    /access\x20of\x20the\x20key/credential\x20they're\x20providing,\x20as\
    \x20computed\x20by\n\x20our\x20authorizer:\n\n\r\n\x05\x06\0\x02S\x01\
    \x12\x04\xee\n\x06\x0e\n\r\n\x05\x06\0\x02S\x02\x12\x04\xee\n\x10\x1f\n\
    \r\n\x05\x06\0\x02S\x03\x12\x04\xee\n*<\n\x0f\n\x05\x06\0\x02S\x04\x12\
    \x06\xef\n\x04\xf7\n\x06\n\x13\n\t\x06\0\x02S\x04\xb0\xca\xbc\"\x12\x06\
    \xef\n\x04\xf7\n\x06\n\r\n\x05\x06\0\x02S\x04\x12\x04\xf8\n\x047\n\x10\n\
    \x08\x06\0\x02S\x04\xc3\xf3\x04\x12\x04\xf8\n\x047\n\x0e\n\x04\x06\0\x02\
    T\x12\x06\xfb\n\x02\x80\x0b\x03\n\r\n\x05\x06\0\x02T\x01\x12\x04\xfb\n\
    \x06\x12\n\r\n\x05\x06\0\x02T\x02\x12\x04\xfb\n\x14'\n\r\n\x05\x06\0\x02\
    T\x03\x12\x04\xfb\n2H\n\x0f\n\x05\x06\0\x02T\x04\x12\x06\xfc\n\x04\xfe\n\
    \x06\n\x13\n\t\x06\0\x02T\x04\xb0\xca\xbc\"\x12\x06\xfc\n\x04\xfe\n\x06\
    \n\r\n\x05\x06\0\x02T\x04\x12\x04\xff\n\x047\n\x10\n\x08\x06\0\x02T\x04\
    \xc3\xf3\x04\x12\x04\xff\n\x047\n\x0e\n\x04\x06\0\x02U\x12\x06\x82\x0b\
    \x02\x87\x0b\x03\n\r\n\x05\x06\0\x02U\x01\x12\x04\x82\x0b\x06\x12\n\r\n\
    \x05\x06\0\x02U\x02\x12\x04\x82\x0b\x14'\n\r\n\x05\x06\0\x02U\x03\x12\
    \x04\x82\x0b2H\n\x0f\n\x05\x06\0\x02U\x04\x12\x06\x83\x0b\x04\x85\x0b\
    \x06\n\x13\n\t\x06\0\x02U\x04\xb0\xca\xbc\"\x12\x06\x83\x0b\x04\x85\x0b\
    \x06\n\r\n\x05\x06\0\x02U\x04\x12\x04\x86\x0b\x047\n\x10\n\x08\x06\0\x02\
    U\x04\xc3\xf3\x04\x12\x04\x86\x0b\x047\nA\n\x04\x06\0\x02V\x12\x06\x8a\
    \x0b\x02\x8f\x0b\x03\x1a1\x20List\x20all\x20auth\x20scopes\x20available\
    \x20to\x20me\x20as\x20a\x20user.\n\n\r\n\x05\x06\0\x02V\x01\x12\x04\x8a\
    \x0b\x06\x10\n\r\n\x05\x06\0\x02V\x02\x12\x04\x8a\x0b\x12#\n\r\n\x05\x06\
    \0\x02V\x03\x12\x04\x8a\x0b.D\n\x0f\n\x05\x06\0\x02V\x04\x12\x06\x8b\x0b\
    \x04\x8d\x0b\x06\n\x13\n\t\x06\0\x02V\x04\xb0\xca\xbc\"\x12\x06\x8b\x0b\
    \x04\x8d\x0b\x06\n\r\n\x05\x06\0\x02V\x04\x12\x04\x8e\x0b\x04@\n\x10\n\
    \x08\x06\0\x02V\x04\xc3\xf3\x04\x12\x04\x8e\x0b\x04@\n1\n\x04\x06\0\x02W\
    \x12\x06\x92\x0b\x02\x99\x0b\x03\x1a!\x20Get\x20a\x20specific\x20app\x20\
    from\x20an\x20app.\n\n\r\n\x05\x06\0\x02W\x01\x12\x04\x92\x0b\x06\x0c\n\
    \r\n\x05\x06\0\x02W\x02\x12\x04\x92\x0b\x0e\x1b\n\r\n\x05\x06\0\x02W\x03\
    \x12\x04\x92\x0b&7\n\x0f\n\x05\x06\0\x02W\x04\x12\x06\x93\x0b\x04\x95\
    \x0b\x06\n\x13\n\t\x06\0\x02W\x04\xb0\xca\xbc\"\x12\x06\x93\x0b\x04\x95\
    \x0b\x06\n\r\n\x05\x06\0\x02W\x04\x12\x04\x96\x0b\x047\n\x10\n\x08\x06\0\
    \x02W\x04\xc3\xf3\x04\x12\x04\x96\x0b\x047\n\r\n\x05\x06\0\x02W\x04\x12\
    \x04\x97\x0b\x04?\n\x11\n\t\x06\0\x02W\x04\xc2\xf3\x04\0\x12\x04\x97\x0b\
    \x04?\n\r\n\x05\x06\0\x02W\x04\x12\x04\x98\x0b\x04D\n\x11\n\t\x06\0\x02W\
    \x04\xc2\xf3\x04\x01\x12\x04\x98\x0b\x04D\n$\n\x04\x06\0\x02X\x12\x06\
    \x9c\x0b\x02\xa6\x0b\x03\x1a\x14\x20List\x20all\x20the\x20apps.\n\n\r\n\
    \x05\x06\0\x02X\x01\x12\x04\x9c\x0b\x06\x0e\n\r\n\x05\x06\0\x02X\x02\x12\
    \x04\x9c\x0b\x10\x1f\n\r\n\x05\x06\0\x02X\x03\x12\x04\x9c\x0b*:\n\x0f\n\
    \x05\x06\0\x02X\x04\x12\x06\x9d\x0b\x04\xa2\x0b\x06\n\x13\n\t\x06\0\x02X\
    \x04\xb0\xca\xbc\"\x12\x06\x9d\x0b\x04\xa2\x0b\x06\n\r\n\x05\x06\0\x02X\
    \x04\x12\x04\xa3\x0b\x047\n\x10\n\x08\x06\0\x02X\x04\xc3\xf3\x04\x12\x04\
    \xa3\x0b\x047\n\r\n\x05\x06\0\x02X\x04\x12\x04\xa4\x0b\x04?\n\x11\n\t\
    \x06\0\x02X\x04\xc2\xf3\x04\0\x12\x04\xa4\x0b\x04?\n\r\n\x05\x06\0\x02X\
    \x04\x12\x04\xa5\x0b\x04D\n\x11\n\t\x06\0\x02X\x04\xc2\xf3\x04\x01\x12\
    \x04\xa5\x0b\x04D\n\xc9\x01\n\x04\x06\0\x02Y\x12\x06\xab\x0b\x02\xb4\x0b\
    \x03\x1a\xb8\x01\x20Search\x20over\x20the\x20apps\x20to\x20find\x20one\
    \x20or\x20more\x20you're\x20looking\x20for.\n\x20This\x20leverage\x20the\
    \x20\"body\"\x20parameter\x20because\x20we\x20also\x20have\x20page\x20an\
    d\n\x20per_page\x20as\x20url\x20query\x20param\x20variables\x20in\x20thi\
    s\x20request.\n\n\r\n\x05\x06\0\x02Y\x01\x12\x04\xab\x0b\x06\x0f\n\r\n\
    \x05\x06\0\x02Y\x02\x12\x04\xab\x0b\x11!\n\r\n\x05\x06\0\x02Y\x03\x12\
    \x04\xab\x0b,L\n\x0f\n\x05\x06\0\x02Y\x04\x12\x06\xac\x0b\x04\xae\x0b\
    \x06\n\x13\n\t\x06\0\x02Y\x04\xb0\xca\xbc\"\x12\x06\xac\x0b\x04\xae\x0b\
    \x06\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xaf\x0b\x047\n\x10\n\x08\x06\0\x02\
    Y\x04\xc3\xf3\x04\x12\x04\xaf\x0b\x047\n\r\n\x05\x06\0\x02Y\x04\x12\x04\
    \xb0\x0b\x04?\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\0\x12\x04\xb0\x0b\x04\
    ?\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xb1\x0b\x04B\n\x11\n\t\x06\0\x02Y\x04\
    \xc2\xf3\x04\x01\x12\x04\xb1\x0b\x04B\n\r\n\x05\x06\0\x02Y\x04\x12\x04\
    \xb2\x0b\x04?\n\x11\n\t\x06\0\x02Y\x04\xc2\xf3\x04\x02\x12\x04\xb2\x0b\
    \x04?\n\r\n\x05\x06\0\x02Y\x04\x12\x04\xb3\x0b\x04D\n\x11\n\t\x06\0\x02Y\
    \x04\xc2\xf3\x04\x03\x12\x04\xb3\x0b\x04D\n\xba\x01\n\x04\x06\0\x02Z\x12\
    \x06\xb9\x0b\x02\xc4\x0b\x03\x1a\xa9\x01\x20Add\x20a\x20app\x20to\x20an\
    \x20app.\n\x20This\x20needs\x20to\x20load\x20the\x20default\x20workflow\
    \x20to\x20make\x20a\x20copy,\x20validating\x20all\x20the\x20models\x20in\
    \x20it,\x20and\n\x20then\x20writing\x20the\x20new\x20workflow\x20back\
    \x20to\x20this\x20new\x20app.\n\n\r\n\x05\x06\0\x02Z\x01\x12\x04\xb9\x0b\
    \x06\x0e\n\r\n\x05\x06\0\x02Z\x02\x12\x04\xb9\x0b\x10\x1f\n\r\n\x05\x06\
    \0\x02Z\x03\x12\x04\xb9\x0b*:\n\x0f\n\x05\x06\0\x02Z\x04\x12\x06\xba\x0b\
    \x04\xbd\x0b\x06\n\x13\n\t\x06\0\x02Z\x04\xb0\xca\xbc\"\x12\x06\xba\x0b\
    \x04\xbd\x0b\x06\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xbe\x0b\x047\n\x10\n\
    \x08\x06\0\x02Z\x04\xc3\xf3\x04\x12\x04\xbe\x0b\x047\n\r\n\x05\x06\0\x02\
    Z\x04\x12\x04\xbf\x0b\x04?\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\0\x12\
    \x04\xbf\x0b\x04?\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xc0\x0b\x04?\n\x11\n\
    \t\x06\0\x02Z\x04\xc2\xf3\x04\x01\x12\x04\xc0\x0b\x04?\n\r\n\x05\x06\0\
    \x02Z\x04\x12\x04\xc1\x0b\x04A\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x02\
    \x12\x04\xc1\x0b\x04A\n\r\n\x05\x06\0\x02Z\x04\x12\x04\xc2\x0b\x04D\n\
    \x11\n\t\x06\0\x02Z\x04\xc2\xf3\x04\x03\x12\x04\xc2\x0b\x04D\n\r\n\x05\
    \x06\0\x02Z\x04\x12\x04\xc3\x0b\x04D\n\x11\n\t\x06\0\x02Z\x04\xc2\xf3\
    \x04\x04\x12\x04\xc3\x0b\x04D\n)\n\x04\x06\0\x02[\x12\x06\xc7\x0b\x02\
    \xcf\x0b\x03\x1a\x19\x20Patch\x20one\x20or\x20more\x20apps.\n\n\r\n\x05\
    \x06\0\x02[\x01\x12\x04\xc7\x0b\x06\x0f\n\r\n\x05\x06\0\x02[\x02\x12\x04\
    \xc7\x0b\x11!\n\r\n\x05\x06\0\x02[\x03\x12\x04\xc7\x0b,<\n\x0f\n\x05\x06\
    \0\x02[\x04\x12\x06\xc8\x0b\x04\xcb\x0b\x06\n\x13\n\t\x06\0\x02[\x04\xb0\
    \xca\xbc\"\x12\x06\xc8\x0b\x04\xcb\x0b\x06\n\r\n\x05\x06\0\x02[\x04\x12\
    \x04\xcc\x0b\x047\n\x10\n\x08\x06\0\x02[\x04\xc3\xf3\x04\x12\x04\xcc\x0b\
    \x047\n\r\n\x05\x06\0\x02[\x04\x12\x04\xcd\x0b\x04?\n\x11\n\t\x06\0\x02[\
    \x04\xc2\xf3\x04\0\x12\x04\xcd\x0b\x04?\n\r\n\x05\x06\0\x02[\x04\x12\x04\
    \xce\x0b\x04?\n\x11\n\t\x06\0\x02[\x04\xc2\xf3\x04\x01\x12\x04\xce\x0b\
    \x04?\nV\n\x04\x06\0\x02\\\x12\x06\xd2\x0b\x02\xda\x0b\x03\x1aF\x20Searc\
    h\x20over\x20the\x20applications\x20to\x20find\x20one\x20or\x20more\x20y\
    ou're\x20looking\x20for.\n\n\r\n\x05\x06\0\x02\\\x01\x12\x04\xd2\x0b\x06\
    \x16\n\r\n\x05\x06\0\x02\\\x02\x12\x04\xd2\x0b\x18/\n\r\n\x05\x06\0\x02\
    \\\x03\x12\x04\xd2\x0b:J\n\x0f\n\x05\x06\0\x02\\\x04\x12\x06\xd3\x0b\x04\
    \xd6\x0b\x06\n\x13\n\t\x06\0\x02\\\x04\xb0\xca\xbc\"\x12\x06\xd3\x0b\x04\
    \xd6\x0b\x06\n\r\n\x05\x06\0\x02\\\x04\x12\x04\xd7\x0b\x047\n\x10\n\x08\
    \x06\0\x02\\\x04\xc3\xf3\x04\x12\x04\xd7\x0b\x047\n\r\n\x05\x06\0\x02\\\
    \x04\x12\x04\xd8\x0b\x04?\n\x11\n\t\x06\0\x02\\\x04\xc2\xf3\x04\0\x12\
    \x04\xd8\x0b\x04?\n\r\n\x05\x06\0\x02\\\x04\x12\x04\xd9\x0b\x04D\n\x11\n\
    \t\x06\0\x02\\\x04\xc2\xf3\x04\x01\x12\x04\xd9\x0b\x04D\n?\n\x04\x06\0\
    \x02]\x12\x06\xe9\x0b\x02\xf3\x0b\x03\x1a/\x20Validate\x20new\x20passwor\
    d\x20in\x20real-time\x20for\x20a\x20user\n\n\r\n\x05\x06\0\x02]\x01\x12\
    \x04\xe9\x0b\x06\x1a\n\r\n\x05\x06\0\x02]\x02\x12\x04\xe9\x0b\x1c7\n\r\n\
    \x05\x06\0\x02]\x03\x12\x04\xe9\x0bBb\n\x0f\n\x05\x06\0\x02]\x04\x12\x06\
    \xea\x0b\x04\xf1\x0b\x06\n\x13\n\t\x06\0\x02]\x04\xb0\xca\xbc\"\x12\x06\
    \xea\x0b\x04\xf1\x0b\x06\n\r\n\x05\x06\0\x02]\x04\x12\x04\xf2\x0b\x04@\n\
    \x10\n\x08\x06\0\x02]\x04\xc3\xf3\x04\x12\x04\xf2\x0b\x04@\n,\n\x04\x06\
    \0\x02^\x12\x06\xa1\x0c\x02\xaa\x0c\x03\x1a\x1c\x20Get\x20a\x20saved\x20\
    legacy\x20search.\n\n\r\n\x05\x06\0\x02^\x01\x12\x04\xa1\x0c\x06\x0f\n\r\
    \n\x05\x06\0\x02^\x02\x12\x04\xa1\x0c\x11!\n\r\n\x05\x06\0\x02^\x03\x12\
    \x04\xa1\x0c,@\n\x0f\n\x05\x06\0\x02^\x04\x12\x06\xa2\x0c\x04\xa7\x0c\
    \x06\n\x13\n\t\x06\0\x02^\x04\xb0\xca\xbc\"\x12\x06\xa2\x0c\x04\xa7\x0c\
    \x06\n\r\n\x05\x06\0\x02^\x04\x12\x04\xa8\x0c\x047\n\x10\n\x08\x06\0\x02\
    ^\x04\xc3\xf3\x04\x12\x04\xa8\x0c\x047\n\r\n\x05\x06\0\x02^\x04\x12\x04\
    \xa9\x0c\x04F\n\x11\n\t\x06\0\x02^\x04\xc2\xf3\x04\0\x12\x04\xa9\x0c\x04\
    F\n1\n\x04\x06\0\x02_\x12\x06\xad\x0c\x02\xb6\x0c\x03\x1a!\x20List\x20al\
    l\x20saved\x20legacy\x20searches.\n\n\r\n\x05\x06\0\x02_\x01\x12\x04\xad\
    \x0c\x06\x12\n\r\n\x05\x06\0\x02_\x02\x12\x04\xad\x0c\x14'\n\r\n\x05\x06\
    \0\x02_\x03\x12\x04\xad\x0c2E\n\x0f\n\x05\x06\0\x02_\x04\x12\x06\xae\x0c\
    \x04\xb3\x0c\x06\n\x13\n\t\x06\0\x02_\x04\xb0\xca\xbc\"\x12\x06\xae\x0c\
    \x04\xb3\x0c\x06\n\r\n\x05\x06\0\x02_\x04\x12\x04\xb4\x0c\x047\n\x10\n\
    \x08\x06\0\x02_\x04\xc3\xf3\x04\x12\x04\xb4\x0c\x047\n\r\n\x05\x06\0\x02\
    _\x04\x12\x04\xb5\x0c\x04F\n\x11\n\t\x06\0\x02_\x04\xc2\xf3\x04\0\x12\
    \x04\xb5\x0c\x04F\n5\n\x04\x06\0\x02`\x12\x06\xb9\x0c\x02\xc5\x0c\x03\
    \x1a%\x20Patch\x20saved\x20legacy\x20searches\x20by\x20ids.\n\n\r\n\x05\
    \x06\0\x02`\x01\x12\x04\xb9\x0c\x06\x13\n\r\n\x05\x06\0\x02`\x02\x12\x04\
    \xb9\x0c\x15)\n\r\n\x05\x06\0\x02`\x03\x12\x04\xb9\x0c4G\n\x0f\n\x05\x06\
    \0\x02`\x04\x12\x06\xba\x0c\x04\xc1\x0c\x06\n\x13\n\t\x06\0\x02`\x04\xb0\
    \xca\xbc\"\x12\x06\xba\x0c\x04\xc1\x0c\x06\n\r\n\x05\x06\0\x02`\x04\x12\
    \x04\xc2\x0c\x047\n\x10\n\x08\x06\0\x02`\x04\xc3\xf3\x04\x12\x04\xc2\x0c\
    \x047\n\r\n\x05\x06\0\x02`\x04\x12\x04\xc3\x0c\x04F\n\x11\n\t\x06\0\x02`\
    \x04\xc2\xf3\x04\0\x12\x04\xc3\x0c\x04F\n\r\n\x05\x06\0\x02`\x04\x12\x04\
    \xc4\x0c\x04F\n\x11\n\t\x06\0\x02`\x04\xc2\xf3\x04\x01\x12\x04\xc4\x0c\
    \x04F\n>\n\x04\x06\0\x02a\x12\x06\xc8\x0c\x02\xd9\x0c\x03\x1a.\x20Execut\
    e\x20a\x20new\x20search\x20and\x20optionally\x20save\x20it.\n\n\r\n\x05\
    \x06\0\x02a\x01\x12\x04\xc8\x0c\x06\x12\n\r\n\x05\x06\0\x02a\x02\x12\x04\
    \xc8\x0c\x14'\n\r\n\x05\x06\0\x02a\x03\x12\x04\xc8\x0c2E\n\x0f\n\x05\x06\
    \0\x02a\x04\x12\x06\xc9\x0c\x04\xd0\x0c\x06\n\x13\n\t\x06\0\x02a\x04\xb0\
    \xca\xbc\"\x12\x06\xc9\x0c\x04\xd0\x0c\x06\n\r\n\x05\x06\0\x02a\x04\x12\
    \x04\xd1\x0c\x047\n\x10\n\x08\x06\0\x02a\x04\xc3\xf3\x04\x12\x04\xd1\x0c\
    \x047\n\r\n\x05\x06\0\x02a\x04\x12\x04\xd2\x0c\x04F\n\x11\n\t\x06\0\x02a\
    \x04\xc2\xf3\x04\0\x12\x04\xd2\x0c\x04F\n\r\n\x05\x06\0\x02a\x04\x12\x04\
    \xd3\x0c\x04C\n\x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\x01\x12\x04\xd3\x0c\
    \x04C\n\r\n\x05\x06\0\x02a\x04\x12\x04\xd4\x0c\x04A\n\x11\n\t\x06\0\x02a\
    \x04\xc2\xf3\x04\x02\x12\x04\xd4\x0c\x04A\n\r\n\x05\x06\0\x02a\x04\x12\
    \x04\xd5\x0c\x04A\n\x11\n\t\x06\0\x02a\x04\xc2\xf3\x04\x03\x12\x04\xd5\
    \x0c\x04A\n\r\n\x05\x06\0\x02a\x04\x12\x04\xd7\x0c\x04=\n[\n\t\x06\0\x02\
    a\x04\xc2\xf3\x04\x04\x12\x04\xd7\x0c\x04=\x1aH\x20option\x20(clarifai.a\
    uth.util.cl_depending_scopes)\x20=\x20Predict;\x20//\x20optional\n\n\r\n\
    \x05\x06\0\x02a\x04\x12\x04\xd8\x0c\x04D\nN\n\t\x06\0\x02a\x04\xc2\xf3\
    \x04\x05\x12\x04\xd8\x0c\x04D\";\x20to\x20know\x20the\x20concepts\x20and\
    \x20models\x20in\x20your\x20default\x20workflow.\n\n;\n\x04\x06\0\x02b\
    \x12\x06\xdc\x0c\x02\xe8\x0c\x03\x1a+\x20Execute\x20a\x20previously\x20s\
    aved\x20legacy\x20search.\n\n\r\n\x05\x06\0\x02b\x01\x12\x04\xdc\x0c\x06\
    \x16\n\r\n\x05\x06\0\x02b\x02\x12\x04\xdc\x0c\x18/\n\r\n\x05\x06\0\x02b\
    \x03\x12\x04\xdc\x0c:M\n\x0f\n\x05\x06\0\x02b\x04\x12\x06\xdd\x0c\x04\
    \xe4\x0c\x06\n\x13\n\t\x06\0\x02b\x04\xb0\xca\xbc\"\x12\x06\xdd\x0c\x04\
    \xe4\x0c\x06\n\r\n\x05\x06\0\x02b\x04\x12\x04\xe5\x0c\x047\n\x10\n\x08\
    \x06\0\x02b\x04\xc3\xf3\x04\x12\x04\xe5\x0c\x047\n\r\n\x05\x06\0\x02b\
    \x04\x12\x04\xe6\x0c\x04F\n\x11\n\t\x06\0\x02b\x04\xc2\xf3\x04\0\x12\x04\
    \xe6\x0c\x04F\n\r\n\x05\x06\0\x02b\x04\x12\x04\xe7\x0c\x04=\n\x11\n\t\
    \x06\0\x02b\x04\xc2\xf3\x04\x01\x12\x04\xe7\x0c\x04=\n=\n\x04\x06\0\x02c\
    \x12\x06\xeb\x0c\x02\xfc\x0c\x03\x1a-\x20Evaluate\x20the\x20results\x20o\
    f\x20two\x20search\x20requests\n\n\r\n\x05\x06\0\x02c\x01\x12\x04\xeb\
    \x0c\x06!\n\r\n\x05\x06\0\x02c\x02\x12\x04\xeb\x0c\"D\n\r\n\x05\x06\0\
    \x02c\x03\x12\x04\xeb\x0cOs\n\x0f\n\x05\x06\0\x02c\x04\x12\x06\xec\x0c\
    \x04\xf3\x0c\x06\n\x13\n\t\x06\0\x02c\x04\xb0\xca\xbc\"\x12\x06\xec\x0c\
    \x04\xf3\x0c\x06\n\r\n\x05\x06\0\x02c\x04\x12\x04\xf4\x0c\x047\n\x10\n\
    \x08\x06\0\x02c\x04\xc3\xf3\x04\x12\x04\xf4\x0c\x047\n\r\n\x05\x06\0\x02\
    c\x04\x12\x04\xf5\x0c\x04F\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\0\x12\
    \x04\xf5\x0c\x04F\n\r\n\x05\x06\0\x02c\x04\x12\x04\xf6\x0c\x04C\n\x11\n\
    \t\x06\0\x02c\x04\xc2\xf3\x04\x01\x12\x04\xf6\x0c\x04C\n\r\n\x05\x06\0\
    \x02c\x04\x12\x04\xf7\x0c\x04A\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x02\
    \x12\x04\xf7\x0c\x04A\n\r\n\x05\x06\0\x02c\x04\x12\x04\xf8\x0c\x04B\n\
    \x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x03\x12\x04\xf8\x0c\x04B\n\r\n\x05\
    \x06\0\x02c\x04\x12\x04\xf9\x0c\x04B\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\
    \x04\x04\x12\x04\xf9\x0c\x04B\n\r\n\x05\x06\0\x02c\x04\x12\x04\xfa\x0c\
    \x04A\n\x11\n\t\x06\0\x02c\x04\xc2\xf3\x04\x05\x12\x04\xfa\x0c\x04A\n\r\
    \n\x05\x06\0\x02c\x04\x12\x04\xfb\x0c\x04D\nP\n\t\x06\0\x02c\x04\xc2\xf3\
    \x04\x06\x12\x04\xfb\x0c\x04D\"=\x20as\x20it\x20needs\x20to\x20know\x20t\
    he\x20concepts\x20in\x20your\x20workflow's\x20models.\n\nH\n\x04\x06\0\
    \x02d\x12\x06\xff\x0c\x02\x8b\r\x03\x1a8\x20Get\x20the\x20evaluation\x20\
    results\x20between\x20two\x20search\x20requests\n\n\r\n\x05\x06\0\x02d\
    \x01\x12\x04\xff\x0c\x06\x20\n\r\n\x05\x06\0\x02d\x02\x12\x04\xff\x0c!B\
    \n\r\n\x05\x06\0\x02d\x03\x12\x04\xff\x0cMq\n\x0f\n\x05\x06\0\x02d\x04\
    \x12\x06\x80\r\x04\x85\r\x06\n\x13\n\t\x06\0\x02d\x04\xb0\xca\xbc\"\x12\
    \x06\x80\r\x04\x85\r\x06\n\r\n\x05\x06\0\x02d\x04\x12\x04\x86\r\x047\n\
    \x10\n\x08\x06\0\x02d\x04\xc3\xf3\x04\x12\x04\x86\r\x047\n\r\n\x05\x06\0\
    \x02d\x04\x12\x04\x87\r\x04F\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\0\x12\
    \x04\x87\r\x04F\n\r\n\x05\x06\0\x02d\x04\x12\x04\x88\r\x04C\n\x11\n\t\
    \x06\0\x02d\x04\xc2\xf3\x04\x01\x12\x04\x88\r\x04C\n\r\n\x05\x06\0\x02d\
    \x04\x12\x04\x89\r\x04A\n\x11\n\t\x06\0\x02d\x04\xc2\xf3\x04\x02\x12\x04\
    \x89\r\x04A\n\r\n\x05\x06\0\x02d\x04\x12\x04\x8a\r\x04B\n\x11\n\t\x06\0\
    \x02d\x04\xc2\xf3\x04\x03\x12\x04\x8a\r\x04B\nI\n\x04\x06\0\x02e\x12\x06\
    \x90\r\x02\x9c\r\x03\x1a9\x20List\x20the\x20evaluation\x20results\x20bet\
    ween\x20two\x20search\x20requests\n\n\r\n\x05\x06\0\x02e\x01\x12\x04\x90\
    \r\x06!\n\r\n\x05\x06\0\x02e\x02\x12\x04\x90\r\"D\n\r\n\x05\x06\0\x02e\
    \x03\x12\x04\x90\rOs\n\x0f\n\x05\x06\0\x02e\x04\x12\x06\x91\r\x04\x96\r\
    \x06\n\x13\n\t\x06\0\x02e\x04\xb0\xca\xbc\"\x12\x06\x91\r\x04\x96\r\x06\
    \n\r\n\x05\x06\0\x02e\x04\x12\x04\x97\r\x047\n\x10\n\x08\x06\0\x02e\x04\
    \xc3\xf3\x04\x12\x04\x97\r\x047\n\r\n\x05\x06\0\x02e\x04\x12\x04\x98\r\
    \x04F\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\0\x12\x04\x98\r\x04F\n\r\n\
    \x05\x06\0\x02e\x04\x12\x04\x99\r\x04C\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\
    \x04\x01\x12\x04\x99\r\x04C\n\r\n\x05\x06\0\x02e\x04\x12\x04\x9a\r\x04A\
    \n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\x02\x12\x04\x9a\r\x04A\n\r\n\x05\
    \x06\0\x02e\x04\x12\x04\x9b\r\x04B\n\x11\n\t\x06\0\x02e\x04\xc2\xf3\x04\
    \x03\x12\x04\x9b\r\x04B\n/\n\x04\x06\0\x02f\x12\x06\x9f\r\x02\xaa\r\x03\
    \x1a\x1f\x20DeleteAnnotationSearchMetrics\n\n\r\n\x05\x06\0\x02f\x01\x12\
    \x04\x9f\r\x06#\n\r\n\x05\x06\0\x02f\x02\x12\x04\x9f\r%I\n\r\n\x05\x06\0\
    \x02f\x03\x12\x04\x9f\rTt\n\x0f\n\x05\x06\0\x02f\x04\x12\x06\xa0\r\x04\
    \xa5\r\x06\n\x13\n\t\x06\0\x02f\x04\xb0\xca\xbc\"\x12\x06\xa0\r\x04\xa5\
    \r\x06\n\r\n\x05\x06\0\x02f\x04\x12\x04\xa6\r\x047\n\x10\n\x08\x06\0\x02\
    f\x04\xc3\xf3\x04\x12\x04\xa6\r\x047\n\r\n\x05\x06\0\x02f\x04\x12\x04\
    \xa7\r\x04B\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\0\x12\x04\xa7\r\x04B\n\
    \r\n\x05\x06\0\x02f\x04\x12\x04\xa8\r\x04B\n\x11\n\t\x06\0\x02f\x04\xc2\
    \xf3\x04\x01\x12\x04\xa8\r\x04B\n\r\n\x05\x06\0\x02f\x04\x12\x04\xa9\r\
    \x04E\n\x11\n\t\x06\0\x02f\x04\xc2\xf3\x04\x02\x12\x04\xa9\r\x04E\n(\n\
    \x04\x06\0\x02g\x12\x06\xad\r\x02\xb8\r\x03\x1a\x18\x20Delete\x20a\x20sa\
    ved\x20search.\n\n\r\n\x05\x06\0\x02g\x01\x12\x04\xad\r\x06\x12\n\r\n\
    \x05\x06\0\x02g\x02\x12\x04\xad\r\x14'\n\r\n\x05\x06\0\x02g\x03\x12\x04\
    \xad\r2R\n\x0f\n\x05\x06\0\x02g\x04\x12\x06\xae\r\x04\xb3\r\x06\n\x13\n\
    \t\x06\0\x02g\x04\xb0\xca\xbc\"\x12\x06\xae\r\x04\xb3\r\x06\n\r\n\x05\
    \x06\0\x02g\x04\x12\x04\xb4\r\x047\n\x10\n\x08\x06\0\x02g\x04\xc3\xf3\
    \x04\x12\x04\xb4\r\x047\n\r\n\x05\x06\0\x02g\x04\x12\x04\xb5\r\x04F\n\
    \x11\n\t\x06\0\x02g\x04\xc2\xf3\x04\0\x12\x04\xb5\r\x04F\n\r\n\x05\x06\0\
    \x02g\x04\x12\x04\xb6\r\x04F\n\x11\n\t\x06\0\x02g\x04\xc2\xf3\x04\x01\
    \x12\x04\xb6\r\x04F\n\r\n\x05\x06\0\x02g\x04\x12\x04\xb7\r\x04I\n\x11\n\
    \t\x06\0\x02g\x04\xc2\xf3\x04\x02\x12\x04\xb7\r\x04I\n(\n\x04\x06\0\x02h\
    \x12\x06\xdf\r\x02\xe4\r\x03\x1a\x18\x20List\x20all\x20status\x20codes.\
    \n\n\r\n\x05\x06\0\x02h\x01\x12\x04\xdf\r\x06\x15\n\r\n\x05\x06\0\x02h\
    \x02\x12\x04\xdf\r\x17-\n\r\n\x05\x06\0\x02h\x03\x12\x04\xdf\r8O\n\x0f\n\
    \x05\x06\0\x02h\x04\x12\x06\xe0\r\x04\xe2\r\x06\n\x13\n\t\x06\0\x02h\x04\
    \xb0\xca\xbc\"\x12\x06\xe0\r\x04\xe2\r\x06\n\r\n\x05\x06\0\x02h\x04\x12\
    \x04\xe3\r\x046\n\x10\n\x08\x06\0\x02h\x04\xc3\xf3\x04\x12\x04\xe3\r\x04\
    6\n5\n\x04\x06\0\x02i\x12\x06\xe7\r\x02\xec\r\x03\x1a%\x20Get\x20more\
    \x20details\x20for\x20a\x20status\x20code.\n\n\r\n\x05\x06\0\x02i\x01\
    \x12\x04\xe7\r\x06\x13\n\r\n\x05\x06\0\x02i\x02\x12\x04\xe7\r\x15)\n\r\n\
    \x05\x06\0\x02i\x03\x12\x04\xe7\r4L\n\x0f\n\x05\x06\0\x02i\x04\x12\x06\
    \xe8\r\x04\xea\r\x06\n\x13\n\t\x06\0\x02i\x04\xb0\xca\xbc\"\x12\x06\xe8\
    \r\x04\xea\r\x06\n\r\n\x05\x06\0\x02i\x04\x12\x04\xeb\r\x046\n\x10\n\x08\
    \x06\0\x02i\x04\xc3\xf3\x04\x12\x04\xeb\r\x046\n=\n\x04\x06\0\x02j\x12\
    \x06\xf6\r\x02\xfc\r\x03\x1a-\x20owner\x20list\x20users\x20who\x20the\
    \x20app\x20is\x20shared\x20with\n\n\r\n\x05\x06\0\x02j\x01\x12\x04\xf6\r\
    \x06\x17\n\r\n\x05\x06\0\x02j\x02\x12\x04\xf6\r\x191\n\r\n\x05\x06\0\x02\
    j\x03\x12\x04\xf6\r<V\n\x0f\n\x05\x06\0\x02j\x04\x12\x06\xf7\r\x04\xf9\r\
    \x06\n\x13\n\t\x06\0\x02j\x04\xb0\xca\xbc\"\x12\x06\xf7\r\x04\xf9\r\x06\
    \n\r\n\x05\x06\0\x02j\x04\x12\x04\xfa\r\x047\n\x10\n\x08\x06\0\x02j\x04\
    \xc3\xf3\x04\x12\x04\xfa\r\x047\n\r\n\x05\x06\0\x02j\x04\x12\x04\xfb\r\
    \x04H\n\x11\n\t\x06\0\x02j\x04\xc2\xf3\x04\0\x12\x04\xfb\r\x04H\n.\n\x04\
    \x06\0\x02k\x12\x06\xff\r\x02\x87\x0e\x03\x1a\x1e\x20add\x20collaborator\
    s\x20to\x20an\x20app.\n\n\r\n\x05\x06\0\x02k\x01\x12\x04\xff\r\x06\x17\n\
    \r\n\x05\x06\0\x02k\x02\x12\x04\xff\r\x191\n\r\n\x05\x06\0\x02k\x03\x12\
    \x04\xff\r<V\n\x0f\n\x05\x06\0\x02k\x04\x12\x06\x80\x0e\x04\x83\x0e\x06\
    \n\x13\n\t\x06\0\x02k\x04\xb0\xca\xbc\"\x12\x06\x80\x0e\x04\x83\x0e\x06\
    \n\r\n\x05\x06\0\x02k\x04\x12\x04\x84\x0e\x047\n\x10\n\x08\x06\0\x02k\
    \x04\xc3\xf3\x04\x12\x04\x84\x0e\x047\n\r\n\x05\x06\0\x02k\x04\x12\x04\
    \x85\x0e\x04H\n\x11\n\t\x06\0\x02k\x04\xc2\xf3\x04\0\x12\x04\x85\x0e\x04\
    H\n\r\n\x05\x06\0\x02k\x04\x12\x04\x86\x0e\x04H\n\x11\n\t\x06\0\x02k\x04\
    \xc2\xf3\x04\x01\x12\x04\x86\x0e\x04H\n/\n\x04\x06\0\x02l\x12\x06\x8a\
    \x0e\x02\x93\x0e\x03\x1a\x1f\x20Patch\x20existing\x20collaborators.\n\n\
    \r\n\x05\x06\0\x02l\x01\x12\x04\x8a\x0e\x06\x18\n\r\n\x05\x06\0\x02l\x02\
    \x12\x04\x8a\x0e\x1a3\n\r\n\x05\x06\0\x02l\x03\x12\x04\x8a\x0e>X\n\x0f\n\
    \x05\x06\0\x02l\x04\x12\x06\x8b\x0e\x04\x8e\x0e\x06\n\x13\n\t\x06\0\x02l\
    \x04\xb0\xca\xbc\"\x12\x06\x8b\x0e\x04\x8e\x0e\x06\n\r\n\x05\x06\0\x02l\
    \x04\x12\x04\x8f\x0e\x047\n\x10\n\x08\x06\0\x02l\x04\xc3\xf3\x04\x12\x04\
    \x8f\x0e\x047\n\r\n\x05\x06\0\x02l\x04\x12\x04\x90\x0e\x04H\n\x11\n\t\
    \x06\0\x02l\x04\xc2\xf3\x04\0\x12\x04\x90\x0e\x04H\n\r\n\x05\x06\0\x02l\
    \x04\x12\x04\x91\x0e\x04H\n\x11\n\t\x06\0\x02l\x04\xc2\xf3\x04\x01\x12\
    \x04\x91\x0e\x04H\n\r\n\x05\x06\0\x02l\x04\x12\x04\x92\x0e\x04K\n\x11\n\
    \t\x06\0\x02l\x04\xc2\xf3\x04\x02\x12\x04\x92\x0e\x04K\n0\n\x04\x06\0\
    \x02m\x12\x06\x96\x0e\x02\xa1\x0e\x03\x1a\x20\x20Delete\x20existing\x20c\
    ollaborators.\n\n\r\n\x05\x06\0\x02m\x01\x12\x04\x96\x0e\x06\x19\n\r\n\
    \x05\x06\0\x02m\x02\x12\x04\x96\x0e\x1b5\n\r\n\x05\x06\0\x02m\x03\x12\
    \x04\x96\x0e@`\n\x0f\n\x05\x06\0\x02m\x04\x12\x06\x97\x0e\x04\x9a\x0e\
    \x06\n\x13\n\t\x06\0\x02m\x04\xb0\xca\xbc\"\x12\x06\x97\x0e\x04\x9a\x0e\
    \x06\n\r\n\x05\x06\0\x02m\x04\x12\x04\x9b\x0e\x047\n\x10\n\x08\x06\0\x02\
    m\x04\xc3\xf3\x04\x12\x04\x9b\x0e\x047\n\r\n\x05\x06\0\x02m\x04\x12\x04\
    \x9c\x0e\x04H\n\x11\n\t\x06\0\x02m\x04\xc2\xf3\x04\0\x12\x04\x9c\x0e\x04\
    H\n\r\n\x05\x06\0\x02m\x04\x12\x04\x9d\x0e\x04H\n\x11\n\t\x06\0\x02m\x04\
    \xc2\xf3\x04\x01\x12\x04\x9d\x0e\x04H\n\r\n\x05\x06\0\x02m\x04\x12\x04\
    \x9e\x0e\x04K\n\x11\n\t\x06\0\x02m\x04\xc2\xf3\x04\x02\x12\x04\x9e\x0e\
    \x04K\n\r\n\x05\x06\0\x02m\x04\x12\x04\x9f\x0e\x04@\nn\n\t\x06\0\x02m\
    \x04\xc2\xf3\x04\x03\x12\x04\x9f\x0e\x04@\"[\x20when\x20deleting\x20a\
    \x20collaborator,\x20we\x20also\x20delete\x20task\x20workers\x20associat\
    ed\x20to\x20this\x20collaborator\n\n\r\n\x05\x06\0\x02m\x04\x12\x04\xa0\
    \x0e\x04@\n\x11\n\t\x06\0\x02m\x04\xc2\xf3\x04\x04\x12\x04\xa0\x0e\x04@\
    \nM\n\x04\x06\0\x02n\x12\x06\xa4\x0e\x02\xa9\x0e\x03\x1a=\x20Collaborati\
    on\x20includes\x20the\x20app\x20user\x20are\x20invitied\x20to\x20work\
    \x20on\n\n\r\n\x05\x06\0\x02n\x01\x12\x04\xa4\x0e\x06\x18\n\r\n\x05\x06\
    \0\x02n\x02\x12\x04\xa4\x0e\x1a3\n\r\n\x05\x06\0\x02n\x03\x12\x04\xa4\
    \x0e>Y\n\x0f\n\x05\x06\0\x02n\x04\x12\x06\xa5\x0e\x04\xa7\x0e\x06\n\x13\
    \n\t\x06\0\x02n\x04\xb0\xca\xbc\"\x12\x06\xa5\x0e\x04\xa7\x0e\x06\n\r\n\
    \x05\x06\0\x02n\x04\x12\x04\xa8\x0e\x04@\n\x10\n\x08\x06\0\x02n\x04\xc3\
    \xf3\x04\x12\x04\xa8\x0e\x04@\n\xe2\x01\n\x04\x06\0\x02o\x12\x06\xb1\x0e\
    \x02\xc2\x0e\x03\x1a\xd1\x01\x20start\x20to\x20duplicate\x20an\x20app\
    \x20which\x20copies\x20all\x20the\x20inputs,\x20annotations,\x20models,\
    \x20concepts\x20etc.\x20to\x20a\x20new\x20app.\n\x20this\x20is\x20an\x20\
    async\x20process,\x20you\x20should\x20use\x20ListAppDuplications\x20or\
    \x20GetAppDuplication\x20to\x20check\x20the\x20status.\n\n\r\n\x05\x06\0\
    \x02o\x01\x12\x04\xb1\x0e\x06\x19\n\r\n\x05\x06\0\x02o\x02\x12\x04\xb1\
    \x0e\x1b5\n\r\n\x05\x06\0\x02o\x03\x12\x04\xb1\x0e@\\\n\x0f\n\x05\x06\0\
    \x02o\x04\x12\x06\xb2\x0e\x04\xb5\x0e\x06\n\x13\n\t\x06\0\x02o\x04\xb0\
    \xca\xbc\"\x12\x06\xb2\x0e\x04\xb5\x0e\x06\n\r\n\x05\x06\0\x02o\x04\x12\
    \x04\xb6\x0e\x047\n\x10\n\x08\x06\0\x02o\x04\xc3\xf3\x04\x12\x04\xb6\x0e\
    \x047\n\r\n\x05\x06\0\x02o\x04\x12\x04\xb7\x0e\x04A\n\x11\n\t\x06\0\x02o\
    \x04\xc2\xf3\x04\0\x12\x04\xb7\x0e\x04A\n\r\n\x05\x06\0\x02o\x04\x12\x04\
    \xb8\x0e\x04A\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\x01\x12\x04\xb8\x0e\
    \x04A\n\r\n\x05\x06\0\x02o\x04\x12\x04\xb9\x0e\x04C\n\x11\n\t\x06\0\x02o\
    \x04\xc2\xf3\x04\x02\x12\x04\xb9\x0e\x04C\n\r\n\x05\x06\0\x02o\x04\x12\
    \x04\xba\x0e\x04C\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\x03\x12\x04\xba\
    \x0e\x04C\n\r\n\x05\x06\0\x02o\x04\x12\x04\xbb\x0e\x04C\n\x11\n\t\x06\0\
    \x02o\x04\xc2\xf3\x04\x04\x12\x04\xbb\x0e\x04C\n\r\n\x05\x06\0\x02o\x04\
    \x12\x04\xbc\x0e\x04A\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\x05\x12\x04\
    \xbc\x0e\x04A\n\r\n\x05\x06\0\x02o\x04\x12\x04\xbd\x0e\x04A\n\x11\n\t\
    \x06\0\x02o\x04\xc2\xf3\x04\x06\x12\x04\xbd\x0e\x04A\n\r\n\x05\x06\0\x02\
    o\x04\x12\x04\xbe\x0e\x04F\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\x07\x12\
    \x04\xbe\x0e\x04F\n\r\n\x05\x06\0\x02o\x04\x12\x04\xbf\x0e\x04F\n\x11\n\
    \t\x06\0\x02o\x04\xc2\xf3\x04\x08\x12\x04\xbf\x0e\x04F\n\r\n\x05\x06\0\
    \x02o\x04\x12\x04\xc0\x0e\x04D\n\x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\t\
    \x12\x04\xc0\x0e\x04D\n\r\n\x05\x06\0\x02o\x04\x12\x04\xc1\x0e\x04D\n\
    \x11\n\t\x06\0\x02o\x04\xc2\xf3\x04\n\x12\x04\xc1\x0e\x04D\n=\n\x04\x06\
    \0\x02p\x12\x06\xc5\x0e\x02\xca\x0e\x03\x1a-\x20list\x20all\x20the\x20ap\
    p\x20duplications\x20user\x20triggers\n\n\r\n\x05\x06\0\x02p\x01\x12\x04\
    \xc5\x0e\x06\x19\n\r\n\x05\x06\0\x02p\x02\x12\x04\xc5\x0e\x1b5\n\r\n\x05\
    \x06\0\x02p\x03\x12\x04\xc5\x0e@\\\n\x0f\n\x05\x06\0\x02p\x04\x12\x06\
    \xc6\x0e\x04\xc8\x0e\x06\n\x13\n\t\x06\0\x02p\x04\xb0\xca\xbc\"\x12\x06\
    \xc6\x0e\x04\xc8\x0e\x06\n\r\n\x05\x06\0\x02p\x04\x12\x04\xc9\x0e\x04@\n\
    \x10\n\x08\x06\0\x02p\x04\xc3\xf3\x04\x12\x04\xc9\x0e\x04@\n0\n\x04\x06\
    \0\x02q\x12\x06\xcd\x0e\x02\xd2\x0e\x03\x1a\x20\x20get\x20the\x20app\x20\
    duplication\x20status\n\n\r\n\x05\x06\0\x02q\x01\x12\x04\xcd\x0e\x06\x17\
    \n\r\n\x05\x06\0\x02q\x02\x12\x04\xcd\x0e\x191\n\r\n\x05\x06\0\x02q\x03\
    \x12\x04\xcd\x0e<X\n\x0f\n\x05\x06\0\x02q\x04\x12\x06\xce\x0e\x04\xd0\
    \x0e\x06\n\x13\n\t\x06\0\x02q\x04\xb0\xca\xbc\"\x12\x06\xce\x0e\x04\xd0\
    \x0e\x06\n\r\n\x05\x06\0\x02q\x04\x12\x04\xd1\x0e\x04@\n\x10\n\x08\x06\0\
    \x02q\x04\xc3\xf3\x04\x12\x04\xd1\x0e\x04@\n&\n\x04\x06\0\x02r\x12\x06\
    \xd5\x0e\x02\xea\x0e\x03\x1a\x16\x20Add\x20tasks\x20to\x20an\x20app.\n\n\
    \r\n\x05\x06\0\x02r\x01\x12\x04\xd5\x0e\x06\x0f\n\r\n\x05\x06\0\x02r\x02\
    \x12\x04\xd5\x0e\x11!\n\r\n\x05\x06\0\x02r\x03\x12\x04\xd5\x0e,=\n\x0f\n\
    \x05\x06\0\x02r\x04\x12\x06\xd6\x0e\x04\xdd\x0e\x06\n\x13\n\t\x06\0\x02r\
    \x04\xb0\xca\xbc\"\x12\x06\xd6\x0e\x04\xdd\x0e\x06\n\r\n\x05\x06\0\x02r\
    \x04\x12\x04\xde\x0e\x047\n\x10\n\x08\x06\0\x02r\x04\xc3\xf3\x04\x12\x04\
    \xde\x0e\x047\n\r\n\x05\x06\0\x02r\x04\x12\x04\xdf\x0e\x04@\n\x11\n\t\
    \x06\0\x02r\x04\xc2\xf3\x04\0\x12\x04\xdf\x0e\x04@\n\r\n\x05\x06\0\x02r\
    \x04\x12\x04\xe0\x0e\x04@\n\x11\n\t\x06\0\x02r\x04\xc2\xf3\x04\x01\x12\
    \x04\xe0\x0e\x04@\n\r\n\x05\x06\0\x02r\x04\x12\x04\xe1\x0e\x04A\n\x11\n\
    \t\x06\0\x02r\x04\xc2\xf3\x04\x02\x12\x04\xe1\x0e\x04A\n\r\n\x05\x06\0\
    \x02r\x04\x12\x04\xe2\x0e\x04=\n\x11\n\t\x06\0\x02r\x04\xc2\xf3\x04\x03\
    \x12\x04\xe2\x0e\x04=\n\r\n\x05\x06\0\x02r\x04\x12\x04\xe3\x0e\x04F\n\
    \x11\n\t\x06\0\x02r\x04\xc2\xf3\x04\x04\x12\x04\xe3\x0e\x04F\n\r\n\x05\
    \x06\0\x02r\x04\x12\x04\xe4\x0e\x04C\n\x11\n\t\x06\0\x02r\x04\xc2\xf3\
    \x04\x05\x12\x04\xe4\x0e\x04C\n\r\n\x05\x06\0\x02r\x04\x12\x04\xe5\x0e\
    \x04D\n\x11\n\t\x06\0\x02r\x04\xc2\xf3\x04\x06\x12\x04\xe5\x0e\x04D\n\r\
    \n\x05\x06\0\x02r\x04\x12\x04\xe6\x0e\x04A\nO\n\t\x06\0\x02r\x04\xc2\xf3\
    \x04\x07\x12\x04\xe6\x0e\x04A\"<\x20needed\x20for\x20converting\x20worke\
    rs\x20internal\x20ids\x20to\x20external\x20ids\n\n\r\n\x05\x06\0\x02r\
    \x04\x12\x04\xe8\x0e\x04F\n\xcb\x01\n\t\x06\0\x02r\x04\xc2\xf3\x04\x08\
    \x12\x04\xe8\x0e\x04F\x1a\x91\x01\x20option\x20(clarifai.auth.util.cl_de\
    pending_scopes)\x20=\x20Predict;\x20//\x20optional,\x20needed\x20for\x20\
    add_task_annotations.go\x20when\x20saved\x20search\x20uses\x20visual\x20\
    search\n\"$\x20needed\x20for\x20add_task_annotations.go\n\n\r\n\x05\x06\
    \0\x02r\x04\x12\x04\xe9\x0e\x04F\n7\n\t\x06\0\x02r\x04\xc2\xf3\x04\t\x12\
    \x04\xe9\x0e\x04F\"$\x20needed\x20for\x20add_task_annotations.go\n\n'\n\
    \x04\x06\0\x02s\x12\x06\xed\x0e\x02\xf6\x0e\x03\x1a\x17\x20Task\x20annot\
    ation\x20count\n\n\r\n\x05\x06\0\x02s\x01\x12\x04\xed\x0e\x06\x1c\n\r\n\
    \x05\x06\0\x02s\x02\x12\x04\xed\x0e\x1e1\n\r\n\x05\x06\0\x02s\x03\x12\
    \x04\xed\x0e<S\n\x0f\n\x05\x06\0\x02s\x04\x12\x06\xee\x0e\x04\xf3\x0e\
    \x06\n\x13\n\t\x06\0\x02s\x04\xb0\xca\xbc\"\x12\x06\xee\x0e\x04\xf3\x0e\
    \x06\n\r\n\x05\x06\0\x02s\x04\x12\x04\xf4\x0e\x047\n\x10\n\x08\x06\0\x02\
    s\x04\xc3\xf3\x04\x12\x04\xf4\x0e\x047\n\r\n\x05\x06\0\x02s\x04\x12\x04\
    \xf5\x0e\x04@\n\x11\n\t\x06\0\x02s\x04\xc2\xf3\x04\0\x12\x04\xf5\x0e\x04\
    @\n\"\n\x04\x06\0\x02t\x12\x06\xf9\x0e\x02\x82\x0f\x03\x1a\x12\x20Task\
    \x20Input\x20count\n\n\r\n\x05\x06\0\x02t\x01\x12\x04\xf9\x0e\x06\x17\n\
    \r\n\x05\x06\0\x02t\x02\x12\x04\xf9\x0e\x19,\n\r\n\x05\x06\0\x02t\x03\
    \x12\x04\xf9\x0e7N\n\x0f\n\x05\x06\0\x02t\x04\x12\x06\xfa\x0e\x04\xff\
    \x0e\x06\n\x13\n\t\x06\0\x02t\x04\xb0\xca\xbc\"\x12\x06\xfa\x0e\x04\xff\
    \x0e\x06\n\r\n\x05\x06\0\x02t\x04\x12\x04\x80\x0f\x047\n\x10\n\x08\x06\0\
    \x02t\x04\xc3\xf3\x04\x12\x04\x80\x0f\x047\n\r\n\x05\x06\0\x02t\x04\x12\
    \x04\x81\x0f\x04@\n\x11\n\t\x06\0\x02t\x04\xc2\xf3\x04\0\x12\x04\x81\x0f\
    \x04@\n2\n\x04\x06\0\x02u\x12\x06\x85\x0f\x02\x92\x0f\x03\x1a\"\x20Get\
    \x20a\x20specific\x20task\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02u\
    \x01\x12\x04\x85\x0f\x06\r\n\r\n\x05\x06\0\x02u\x02\x12\x04\x85\x0f\x0f\
    \x1d\n\r\n\x05\x06\0\x02u\x03\x12\x04\x85\x0f(:\n\x0f\n\x05\x06\0\x02u\
    \x04\x12\x06\x86\x0f\x04\x8b\x0f\x06\n\x13\n\t\x06\0\x02u\x04\xb0\xca\
    \xbc\"\x12\x06\x86\x0f\x04\x8b\x0f\x06\n\r\n\x05\x06\0\x02u\x04\x12\x04\
    \x8c\x0f\x047\n\x10\n\x08\x06\0\x02u\x04\xc3\xf3\x04\x12\x04\x8c\x0f\x04\
    7\n\r\n\x05\x06\0\x02u\x04\x12\x04\x8d\x0f\x04@\n\x11\n\t\x06\0\x02u\x04\
    \xc2\xf3\x04\0\x12\x04\x8d\x0f\x04@\n\r\n\x05\x06\0\x02u\x04\x12\x04\x8e\
    \x0f\x04F\n\x11\n\t\x06\0\x02u\x04\xc2\xf3\x04\x01\x12\x04\x8e\x0f\x04F\
    \n\r\n\x05\x06\0\x02u\x04\x12\x04\x8f\x0f\x04C\n\x11\n\t\x06\0\x02u\x04\
    \xc2\xf3\x04\x02\x12\x04\x8f\x0f\x04C\n\r\n\x05\x06\0\x02u\x04\x12\x04\
    \x90\x0f\x04D\n\x11\n\t\x06\0\x02u\x04\xc2\xf3\x04\x03\x12\x04\x90\x0f\
    \x04D\n\r\n\x05\x06\0\x02u\x04\x12\x04\x91\x0f\x04A\nO\n\t\x06\0\x02u\
    \x04\xc2\xf3\x04\x04\x12\x04\x91\x0f\x04A\"<\x20needed\x20for\x20convert\
    ing\x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\n)\n\x04\
    \x06\0\x02v\x12\x06\x95\x0f\x02\xa2\x0f\x03\x1a\x19\x20List\x20tasks\x20\
    from\x20an\x20app.\n\n\r\n\x05\x06\0\x02v\x01\x12\x04\x95\x0f\x06\x0f\n\
    \r\n\x05\x06\0\x02v\x02\x12\x04\x95\x0f\x11!\n\r\n\x05\x06\0\x02v\x03\
    \x12\x04\x95\x0f,=\n\x0f\n\x05\x06\0\x02v\x04\x12\x06\x96\x0f\x04\x9b\
    \x0f\x06\n\x13\n\t\x06\0\x02v\x04\xb0\xca\xbc\"\x12\x06\x96\x0f\x04\x9b\
    \x0f\x06\n\r\n\x05\x06\0\x02v\x04\x12\x04\x9c\x0f\x047\n\x10\n\x08\x06\0\
    \x02v\x04\xc3\xf3\x04\x12\x04\x9c\x0f\x047\n\r\n\x05\x06\0\x02v\x04\x12\
    \x04\x9d\x0f\x04@\n\x11\n\t\x06\0\x02v\x04\xc2\xf3\x04\0\x12\x04\x9d\x0f\
    \x04@\n\r\n\x05\x06\0\x02v\x04\x12\x04\x9e\x0f\x04F\n\x11\n\t\x06\0\x02v\
    \x04\xc2\xf3\x04\x01\x12\x04\x9e\x0f\x04F\n\r\n\x05\x06\0\x02v\x04\x12\
    \x04\x9f\x0f\x04C\n\x11\n\t\x06\0\x02v\x04\xc2\xf3\x04\x02\x12\x04\x9f\
    \x0f\x04C\n\r\n\x05\x06\0\x02v\x04\x12\x04\xa0\x0f\x04D\n\x11\n\t\x06\0\
    \x02v\x04\xc2\xf3\x04\x03\x12\x04\xa0\x0f\x04D\n\r\n\x05\x06\0\x02v\x04\
    \x12\x04\xa1\x0f\x04A\nO\n\t\x06\0\x02v\x04\xc2\xf3\x04\x04\x12\x04\xa1\
    \x0f\x04A\"<\x20needed\x20for\x20converting\x20workers\x20internal\x20id\
    s\x20to\x20external\x20ids\n\n*\n\x04\x06\0\x02w\x12\x06\xa5\x0f\x02\xb9\
    \x0f\x03\x1a\x1a\x20Patch\x20one\x20or\x20more\x20tasks.\n\n\r\n\x05\x06\
    \0\x02w\x01\x12\x04\xa5\x0f\x06\x10\n\r\n\x05\x06\0\x02w\x02\x12\x04\xa5\
    \x0f\x12#\n\r\n\x05\x06\0\x02w\x03\x12\x04\xa5\x0f.?\n\x0f\n\x05\x06\0\
    \x02w\x04\x12\x06\xa6\x0f\x04\xad\x0f\x06\n\x13\n\t\x06\0\x02w\x04\xb0\
    \xca\xbc\"\x12\x06\xa6\x0f\x04\xad\x0f\x06\n\r\n\x05\x06\0\x02w\x04\x12\
    \x04\xae\x0f\x047\n\x10\n\x08\x06\0\x02w\x04\xc3\xf3\x04\x12\x04\xae\x0f\
    \x047\n\r\n\x05\x06\0\x02w\x04\x12\x04\xaf\x0f\x04@\n\x11\n\t\x06\0\x02w\
    \x04\xc2\xf3\x04\0\x12\x04\xaf\x0f\x04@\n\r\n\x05\x06\0\x02w\x04\x12\x04\
    \xb0\x0f\x04@\n\x11\n\t\x06\0\x02w\x04\xc2\xf3\x04\x01\x12\x04\xb0\x0f\
    \x04@\n\r\n\x05\x06\0\x02w\x04\x12\x04\xb1\x0f\x04A\n\x11\n\t\x06\0\x02w\
    \x04\xc2\xf3\x04\x02\x12\x04\xb1\x0f\x04A\n\r\n\x05\x06\0\x02w\x04\x12\
    \x04\xb2\x0f\x04F\n\x11\n\t\x06\0\x02w\x04\xc2\xf3\x04\x03\x12\x04\xb2\
    \x0f\x04F\n\r\n\x05\x06\0\x02w\x04\x12\x04\xb3\x0f\x04C\n\x11\n\t\x06\0\
    \x02w\x04\xc2\xf3\x04\x04\x12\x04\xb3\x0f\x04C\n\r\n\x05\x06\0\x02w\x04\
    \x12\x04\xb4\x0f\x04D\n\x11\n\t\x06\0\x02w\x04\xc2\xf3\x04\x05\x12\x04\
    \xb4\x0f\x04D\n\r\n\x05\x06\0\x02w\x04\x12\x04\xb5\x0f\x04A\nO\n\t\x06\0\
    \x02w\x04\xc2\xf3\x04\x06\x12\x04\xb5\x0f\x04A\"<\x20needed\x20for\x20co\
    nverting\x20workers\x20internal\x20ids\x20to\x20external\x20ids\n\n\r\n\
    \x05\x06\0\x02w\x04\x12\x04\xb7\x0f\x04F\n\xcb\x01\n\t\x06\0\x02w\x04\
    \xc2\xf3\x04\x07\x12\x04\xb7\x0f\x04F\x1a\x91\x01\x20option\x20(clarifai\
    .auth.util.cl_depending_scopes)\x20=\x20Predict;\x20//\x20optional,\x20n\
    eeded\x20for\x20add_task_annotations.go\x20when\x20saved\x20search\x20us\
    es\x20visual\x20search\n\"$\x20needed\x20for\x20add_task_annotations.go\
    \n\n\r\n\x05\x06\0\x02w\x04\x12\x04\xb8\x0f\x04F\n7\n\t\x06\0\x02w\x04\
    \xc2\xf3\x04\x08\x12\x04\xb8\x0f\x04F\"$\x20needed\x20for\x20add_task_an\
    notations.go\n\n7\n\x04\x06\0\x02x\x12\x06\xbc\x0f\x02\xc9\x0f\x03\x1a'\
    \x20Delete\x20multiple\x20tasks\x20in\x20one\x20request.\n\n\r\n\x05\x06\
    \0\x02x\x01\x12\x04\xbc\x0f\x06\x11\n\r\n\x05\x06\0\x02x\x02\x12\x04\xbc\
    \x0f\x13%\n\r\n\x05\x06\0\x02x\x03\x12\x04\xbc\x0f0P\n\x0f\n\x05\x06\0\
    \x02x\x04\x12\x06\xbd\x0f\x04\xc4\x0f\x06\n\x13\n\t\x06\0\x02x\x04\xb0\
    \xca\xbc\"\x12\x06\xbd\x0f\x04\xc4\x0f\x06\n\r\n\x05\x06\0\x02x\x04\x12\
    \x04\xc5\x0f\x047\n\x10\n\x08\x06\0\x02x\x04\xc3\xf3\x04\x12\x04\xc5\x0f\
    \x047\n\r\n\x05\x06\0\x02x\x04\x12\x04\xc6\x0f\x04@\n\x11\n\t\x06\0\x02x\
    \x04\xc2\xf3\x04\0\x12\x04\xc6\x0f\x04@\n\r\n\x05\x06\0\x02x\x04\x12\x04\
    \xc7\x0f\x04@\n\x11\n\t\x06\0\x02x\x04\xc2\xf3\x04\x01\x12\x04\xc7\x0f\
    \x04@\n\r\n\x05\x06\0\x02x\x04\x12\x04\xc8\x0f\x04C\n\x11\n\t\x06\0\x02x\
    \x04\xc2\xf3\x04\x02\x12\x04\xc8\x0f\x04C\n#\n\x04\x06\0\x02y\x12\x06\
    \xcc\x0f\x02\xe0\x0f\x03\x1a\x13\x20Add\x20Label\x20orders.\n\n\r\n\x05\
    \x06\0\x02y\x01\x12\x04\xcc\x0f\x06\x15\n\r\n\x05\x06\0\x02y\x02\x12\x04\
    \xcc\x0f\x17-\n\r\n\x05\x06\0\x02y\x03\x12\x04\xcc\x0f8O\n\x0f\n\x05\x06\
    \0\x02y\x04\x12\x06\xcd\x0f\x04\xd4\x0f\x06\n\x13\n\t\x06\0\x02y\x04\xb0\
    \xca\xbc\"\x12\x06\xcd\x0f\x04\xd4\x0f\x06\n\r\n\x05\x06\0\x02y\x04\x12\
    \x04\xd5\x0f\x047\n\x10\n\x08\x06\0\x02y\x04\xc1\xf3\x04\x12\x04\xd5\x0f\
    \x047\n\r\n\x05\x06\0\x02y\x04\x12\x04\xd6\x0f\x047\n\x10\n\x08\x06\0\
    \x02y\x04\xc3\xf3\x04\x12\x04\xd6\x0f\x047\n\r\n\x05\x06\0\x02y\x04\x12\
    \x04\xd7\x0f\x04F\n\x11\n\t\x06\0\x02y\x04\xc2\xf3\x04\0\x12\x04\xd7\x0f\
    \x04F\n\r\n\x05\x06\0\x02y\x04\x12\x04\xd8\x0f\x04F\n\x11\n\t\x06\0\x02y\
    \x04\xc2\xf3\x04\x01\x12\x04\xd8\x0f\x04F\n\r\n\x05\x06\0\x02y\x04\x12\
    \x04\xd9\x0f\x04@\n\x11\n\t\x06\0\x02y\x04\xc2\xf3\x04\x02\x12\x04\xd9\
    \x0f\x04@\n\r\n\x05\x06\0\x02y\x04\x12\x04\xda\x0f\x04@\n\x11\n\t\x06\0\
    \x02y\x04\xc2\xf3\x04\x03\x12\x04\xda\x0f\x04@\n\r\n\x05\x06\0\x02y\x04\
    \x12\x04\xdb\x0f\x04A\n\x11\n\t\x06\0\x02y\x04\xc2\xf3\x04\x04\x12\x04\
    \xdb\x0f\x04A\n\r\n\x05\x06\0\x02y\x04\x12\x04\xdc\x0f\x04F\n\x11\n\t\
    \x06\0\x02y\x04\xc2\xf3\x04\x05\x12\x04\xdc\x0f\x04F\n\r\n\x05\x06\0\x02\
    y\x04\x12\x04\xdd\x0f\x04C\n\x11\n\t\x06\0\x02y\x04\xc2\xf3\x04\x06\x12\
    \x04\xdd\x0f\x04C\n\r\n\x05\x06\0\x02y\x04\x12\x04\xde\x0f\x04D\n\x11\n\
    \t\x06\0\x02y\x04\xc2\xf3\x04\x07\x12\x04\xde\x0f\x04D\n\r\n\x05\x06\0\
    \x02y\x04\x12\x04\xdf\x0f\x04A\nO\n\t\x06\0\x02y\x04\xc2\xf3\x04\x08\x12\
    \x04\xdf\x0f\x04A\"<\x20needed\x20for\x20converting\x20workers\x20intern\
    al\x20ids\x20to\x20external\x20ids\n\n$\n\x04\x06\0\x02z\x12\x06\xe5\x0f\
    \x02\xf1\x0f\x03\x1a\x14\x20Get\x20a\x20label\x20order.\n\n\r\n\x05\x06\
    \0\x02z\x01\x12\x04\xe5\x0f\x06\x13\n\r\n\x05\x06\0\x02z\x02\x12\x04\xe5\
    \x0f\x15)\n\r\n\x05\x06\0\x02z\x03\x12\x04\xe5\x0f4L\n\x0f\n\x05\x06\0\
    \x02z\x04\x12\x06\xe6\x0f\x04\xeb\x0f\x06\n\x13\n\t\x06\0\x02z\x04\xb0\
    \xca\xbc\"\x12\x06\xe6\x0f\x04\xeb\x0f\x06\n\r\n\x05\x06\0\x02z\x04\x12\
    \x04\xec\x0f\x047\n\x10\n\x08\x06\0\x02z\x04\xc1\xf3\x04\x12\x04\xec\x0f\
    \x047\n\r\n\x05\x06\0\x02z\x04\x12\x04\xed\x0f\x047\n\x10\n\x08\x06\0\
    \x02z\x04\xc3\xf3\x04\x12\x04\xed\x0f\x047\n\r\n\x05\x06\0\x02z\x04\x12\
    \x04\xee\x0f\x04F\n\x11\n\t\x06\0\x02z\x04\xc2\xf3\x04\0\x12\x04\xee\x0f\
    \x04F\n\r\n\x05\x06\0\x02z\x04\x12\x04\xef\x0f\x04C\n\x11\n\t\x06\0\x02z\
    \x04\xc2\xf3\x04\x01\x12\x04\xef\x0f\x04C\n\r\n\x05\x06\0\x02z\x04\x12\
    \x04\xf0\x0f\x04@\n4\n\t\x06\0\x02z\x04\xc2\xf3\x04\x02\x12\x04\xf0\x0f\
    \x04@\"!\x20needed\x20because\x20task\x20is\x20embedded\n\n$\n\x04\x06\0\
    \x02{\x12\x06\xf4\x0f\x02\x80\x10\x03\x1a\x14\x20List\x20label\x20orders\
    .\n\n\r\n\x05\x06\0\x02{\x01\x12\x04\xf4\x0f\x06\x15\n\r\n\x05\x06\0\x02\
    {\x02\x12\x04\xf4\x0f\x17-\n\r\n\x05\x06\0\x02{\x03\x12\x04\xf4\x0f8O\n\
    \x0f\n\x05\x06\0\x02{\x04\x12\x06\xf5\x0f\x04\xfa\x0f\x06\n\x13\n\t\x06\
    \0\x02{\x04\xb0\xca\xbc\"\x12\x06\xf5\x0f\x04\xfa\x0f\x06\n\r\n\x05\x06\
    \0\x02{\x04\x12\x04\xfb\x0f\x047\n\x10\n\x08\x06\0\x02{\x04\xc1\xf3\x04\
    \x12\x04\xfb\x0f\x047\n\r\n\x05\x06\0\x02{\x04\x12\x04\xfc\x0f\x047\n\
    \x10\n\x08\x06\0\x02{\x04\xc3\xf3\x04\x12\x04\xfc\x0f\x047\n\r\n\x05\x06\
    \0\x02{\x04\x12\x04\xfd\x0f\x04F\n\x11\n\t\x06\0\x02{\x04\xc2\xf3\x04\0\
    \x12\x04\xfd\x0f\x04F\n\r\n\x05\x06\0\x02{\x04\x12\x04\xfe\x0f\x04C\n\
    \x11\n\t\x06\0\x02{\x04\xc2\xf3\x04\x01\x12\x04\xfe\x0f\x04C\n\r\n\x05\
    \x06\0\x02{\x04\x12\x04\xff\x0f\x04@\n4\n\t\x06\0\x02{\x04\xc2\xf3\x04\
    \x02\x12\x04\xff\x0f\x04@\"!\x20needed\x20because\x20task\x20is\x20embed\
    ded\n\n1\n\x04\x06\0\x02|\x12\x06\x83\x10\x02\x94\x10\x03\x1a!\x20Patch\
    \x20one\x20or\x20more\x20label\x20orders.\n\n\r\n\x05\x06\0\x02|\x01\x12\
    \x04\x83\x10\x06\x16\n\r\n\x05\x06\0\x02|\x02\x12\x04\x83\x10\x18/\n\r\n\
    \x05\x06\0\x02|\x03\x12\x04\x83\x10:Q\n\x0f\n\x05\x06\0\x02|\x04\x12\x06\
    \x84\x10\x04\x8b\x10\x06\n\x13\n\t\x06\0\x02|\x04\xb0\xca\xbc\"\x12\x06\
    \x84\x10\x04\x8b\x10\x06\n\r\n\x05\x06\0\x02|\x04\x12\x04\x8c\x10\x047\n\
    \x10\n\x08\x06\0\x02|\x04\xc1\xf3\x04\x12\x04\x8c\x10\x047\n\r\n\x05\x06\
    \0\x02|\x04\x12\x04\x8d\x10\x047\n\x10\n\x08\x06\0\x02|\x04\xc3\xf3\x04\
    \x12\x04\x8d\x10\x047\n\r\n\x05\x06\0\x02|\x04\x12\x04\x8e\x10\x04F\n\
    \x11\n\t\x06\0\x02|\x04\xc2\xf3\x04\0\x12\x04\x8e\x10\x04F\n\r\n\x05\x06\
    \0\x02|\x04\x12\x04\x8f\x10\x04F\n\x11\n\t\x06\0\x02|\x04\xc2\xf3\x04\
    \x01\x12\x04\x8f\x10\x04F\n\r\n\x05\x06\0\x02|\x04\x12\x04\x90\x10\x04C\
    \n\x11\n\t\x06\0\x02|\x04\xc2\xf3\x04\x02\x12\x04\x90\x10\x04C\n\r\n\x05\
    \x06\0\x02|\x04\x12\x04\x91\x10\x04@\n\x11\n\t\x06\0\x02|\x04\xc2\xf3\
    \x04\x03\x12\x04\x91\x10\x04@\n\r\n\x05\x06\0\x02|\x04\x12\x04\x92\x10\
    \x04@\n\x11\n\t\x06\0\x02|\x04\xc2\xf3\x04\x04\x12\x04\x92\x10\x04@\n\r\
    \n\x05\x06\0\x02|\x04\x12\x04\x93\x10\x04C\n\x11\n\t\x06\0\x02|\x04\xc2\
    \xf3\x04\x05\x12\x04\x93\x10\x04C\n^\n\x04\x06\0\x02}\x12\x06\x98\x10\
    \x02\xa8\x10\x03\x1aN\x20Delete\x20multiple\x20label\x20orders\x20in\x20\
    one\x20request.\n\x20this\x20do\x20not\x20change\x20task\x20status\n\n\r\
    \n\x05\x06\0\x02}\x01\x12\x04\x98\x10\x06\x17\n\r\n\x05\x06\0\x02}\x02\
    \x12\x04\x98\x10\x191\n\r\n\x05\x06\0\x02}\x03\x12\x04\x98\x10<\\\n\x0f\
    \n\x05\x06\0\x02}\x04\x12\x06\x99\x10\x04\xa0\x10\x06\n\x13\n\t\x06\0\
    \x02}\x04\xb0\xca\xbc\"\x12\x06\x99\x10\x04\xa0\x10\x06\n\r\n\x05\x06\0\
    \x02}\x04\x12\x04\xa1\x10\x047\n\x10\n\x08\x06\0\x02}\x04\xc1\xf3\x04\
    \x12\x04\xa1\x10\x047\n\r\n\x05\x06\0\x02}\x04\x12\x04\xa2\x10\x047\n\
    \x10\n\x08\x06\0\x02}\x04\xc3\xf3\x04\x12\x04\xa2\x10\x047\n\r\n\x05\x06\
    \0\x02}\x04\x12\x04\xa3\x10\x04I\n\x11\n\t\x06\0\x02}\x04\xc2\xf3\x04\0\
    \x12\x04\xa3\x10\x04I\n\r\n\x05\x06\0\x02}\x04\x12\x04\xa4\x10\x04F\n\
    \x11\n\t\x06\0\x02}\x04\xc2\xf3\x04\x01\x12\x04\xa4\x10\x04F\n\r\n\x05\
    \x06\0\x02}\x04\x12\x04\xa5\x10\x04F\n\x11\n\t\x06\0\x02}\x04\xc2\xf3\
    \x04\x02\x12\x04\xa5\x10\x04F\n\r\n\x05\x06\0\x02}\x04\x12\x04\xa6\x10\
    \x04@\n\x11\n\t\x06\0\x02}\x04\xc2\xf3\x04\x03\x12\x04\xa6\x10\x04@\n\r\
    \n\x05\x06\0\x02}\x04\x12\x04\xa7\x10\x04@\n\x11\n\t\x06\0\x02}\x04\xc2\
    \xf3\x04\x04\x12\x04\xa7\x10\x04@\n\xf2\x02\n\x04\x06\0\x02~\x12\x06\xb0\
    \x10\x02\xc4\x10\x03\x1a\xe1\x02\x20Add\x20a\x20list\x20of\x20Collectors\
    \x20to\x20an\x20app.\n\x20In\x20the\x20handler\x20of\x20this\x20endpoint\
    \x20we\x20also\x20check\x20for\x20all\x20the\x20scopes\x20of\x20the\x20\
    \x20POST\x20/inputs\n\x20endpoint.\n\x20Those\x20current\x20scopes\x20ar\
    e\x20listed\x20here\x20as\x20a\x20hard\x20requirement.\n\x20They\x20are\
    \x20needed\x20when\x20adding\x20the\x20collectors\x20just\x20so\x20we\
    \x20now\x20that\x20you\x20have\x20permission\x20with\n\x20that\x20key\
    \x20at\x20least\x20to\x20do\x20the\x20writing\x20to\x20this\x20app\x20wi\
    th\x20POST\x20/inputs.\n\n\r\n\x05\x06\0\x02~\x01\x12\x04\xb0\x10\x06\
    \x14\n\r\n\x05\x06\0\x02~\x02\x12\x04\xb0\x10\x16+\n\r\n\x05\x06\0\x02~\
    \x03\x12\x04\xb0\x106L\n\x0f\n\x05\x06\0\x02~\x04\x12\x06\xb1\x10\x04\
    \xb8\x10\x06\n\x13\n\t\x06\0\x02~\x04\xb0\xca\xbc\"\x12\x06\xb1\x10\x04\
    \xb8\x10\x06\n\r\n\x05\x06\0\x02~\x04\x12\x04\xb9\x10\x047\n\x10\n\x08\
    \x06\0\x02~\x04\xc3\xf3\x04\x12\x04\xb9\x10\x047\n\r\n\x05\x06\0\x02~\
    \x04\x12\x04\xba\x10\x04A\n\x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\0\x12\x04\
    \xba\x10\x04A\n\r\n\x05\x06\0\x02~\x04\x12\x04\xbb\x10\x04F\n\x11\n\t\
    \x06\0\x02~\x04\xc2\xf3\x04\x01\x12\x04\xbb\x10\x04F\n\r\n\x05\x06\0\x02\
    ~\x04\x12\x04\xbc\x10\x04F\n\x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\x02\x12\
    \x04\xbc\x10\x04F\n\r\n\x05\x06\0\x02~\x04\x12\x04\xbd\x10\x04E\n\x11\n\
    \t\x06\0\x02~\x04\xc2\xf3\x04\x03\x12\x04\xbd\x10\x04E\n\r\n\x05\x06\0\
    \x02~\x04\x12\x04\xbe\x10\x04C\n\x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\x04\
    \x12\x04\xbe\x10\x04C\n\r\n\x05\x06\0\x02~\x04\x12\x04\xbf\x10\x04A\n\
    \x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\x05\x12\x04\xbf\x10\x04A\n\r\n\x05\
    \x06\0\x02~\x04\x12\x04\xc0\x10\x04A\n\x11\n\t\x06\0\x02~\x04\xc2\xf3\
    \x04\x06\x12\x04\xc0\x10\x04A\n\r\n\x05\x06\0\x02~\x04\x12\x04\xc1\x10\
    \x04A\n\x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\x07\x12\x04\xc1\x10\x04A\n\r\
    \n\x05\x06\0\x02~\x04\x12\x04\xc2\x10\x04>\n\x11\n\t\x06\0\x02~\x04\xc2\
    \xf3\x04\x08\x12\x04\xc2\x10\x04>\n\r\n\x05\x06\0\x02~\x04\x12\x04\xc3\
    \x10\x04D\n\x11\n\t\x06\0\x02~\x04\xc2\xf3\x04\t\x12\x04\xc3\x10\x04D\n7\
    \n\x04\x06\0\x02\x7f\x12\x06\xc7\x10\x02\xd0\x10\x03\x1a'\x20Get\x20a\
    \x20specific\x20collector\x20from\x20an\x20app.\n\n\r\n\x05\x06\0\x02\
    \x7f\x01\x12\x04\xc7\x10\x06\x12\n\r\n\x05\x06\0\x02\x7f\x02\x12\x04\xc7\
    \x10\x14'\n\r\n\x05\x06\0\x02\x7f\x03\x12\x04\xc7\x102I\n\x0f\n\x05\x06\
    \0\x02\x7f\x04\x12\x06\xc8\x10\x04\xcd\x10\x06\n\x13\n\t\x06\0\x02\x7f\
    \x04\xb0\xca\xbc\"\x12\x06\xc8\x10\x04\xcd\x10\x06\n\r\n\x05\x06\0\x02\
    \x7f\x04\x12\x04\xce\x10\x047\n\x10\n\x08\x06\0\x02\x7f\x04\xc3\xf3\x04\
    \x12\x04\xce\x10\x047\n\r\n\x05\x06\0\x02\x7f\x04\x12\x04\xcf\x10\x04E\n\
    \x11\n\t\x06\0\x02\x7f\x04\xc2\xf3\x04\0\x12\x04\xcf\x10\x04E\n+\n\x05\
    \x06\0\x02\x80\x01\x12\x06\xd3\x10\x02\xdc\x10\x03\x1a\x1a\x20List\x20al\
    l\x20the\x20collectors.\n\n\x0e\n\x06\x06\0\x02\x80\x01\x01\x12\x04\xd3\
    \x10\x06\x14\n\x0e\n\x06\x06\0\x02\x80\x01\x02\x12\x04\xd3\x10\x16+\n\
    \x0e\n\x06\x06\0\x02\x80\x01\x03\x12\x04\xd3\x106L\n\x10\n\x06\x06\0\x02\
    \x80\x01\x04\x12\x06\xd4\x10\x04\xd9\x10\x06\n\x14\n\n\x06\0\x02\x80\x01\
    \x04\xb0\xca\xbc\"\x12\x06\xd4\x10\x04\xd9\x10\x06\n\x0e\n\x06\x06\0\x02\
    \x80\x01\x04\x12\x04\xda\x10\x047\n\x11\n\t\x06\0\x02\x80\x01\x04\xc3\
    \xf3\x04\x12\x04\xda\x10\x047\n\x0e\n\x06\x06\0\x02\x80\x01\x04\x12\x04\
    \xdb\x10\x04E\n\x12\n\n\x06\0\x02\x80\x01\x04\xc2\xf3\x04\0\x12\x04\xdb\
    \x10\x04E\n0\n\x05\x06\0\x02\x81\x01\x12\x06\xdf\x10\x02\xeb\x10\x03\x1a\
    \x1f\x20Patch\x20one\x20or\x20more\x20collectors.\n\n\x0e\n\x06\x06\0\
    \x02\x81\x01\x01\x12\x04\xdf\x10\x06\x15\n\x0e\n\x06\x06\0\x02\x81\x01\
    \x02\x12\x04\xdf\x10\x17-\n\x0e\n\x06\x06\0\x02\x81\x01\x03\x12\x04\xdf\
    \x108N\n\x10\n\x06\x06\0\x02\x81\x01\x04\x12\x06\xe0\x10\x04\xe7\x10\x06\
    \n\x14\n\n\x06\0\x02\x81\x01\x04\xb0\xca\xbc\"\x12\x06\xe0\x10\x04\xe7\
    \x10\x06\n\x0e\n\x06\x06\0\x02\x81\x01\x04\x12\x04\xe8\x10\x047\n\x11\n\
    \t\x06\0\x02\x81\x01\x04\xc3\xf3\x04\x12\x04\xe8\x10\x047\n\x0e\n\x06\
    \x06\0\x02\x81\x01\x04\x12\x04\xe9\x10\x04E\n\x12\n\n\x06\0\x02\x81\x01\
    \x04\xc2\xf3\x04\0\x12\x04\xe9\x10\x04E\n\x0e\n\x06\x06\0\x02\x81\x01\
    \x04\x12\x04\xea\x10\x04E\n\x12\n\n\x06\0\x02\x81\x01\x04\xc2\xf3\x04\
    \x01\x12\x04\xea\x10\x04E\n\x90\x01\n\x05\x06\0\x02\x82\x01\x12\x06\xf1\
    \x10\x02\xfe\x10\x03\x1a\x7f\x20Delete\x20multiple\x20collectors\x20in\
    \x20one\x20request.\n\x20This\x20call\x20is\x20asynchronous.\x20Use\x20D\
    eleteCollector\x20if\x20you\x20want\x20a\x20synchronous\x20version.\n\n\
    \x0e\n\x06\x06\0\x02\x82\x01\x01\x12\x04\xf1\x10\x06\x16\n\x0e\n\x06\x06\
    \0\x02\x82\x01\x02\x12\x04\xf1\x10\x18/\n\x0e\n\x06\x06\0\x02\x82\x01\
    \x03\x12\x04\xf1\x10:Z\n\x10\n\x06\x06\0\x02\x82\x01\x04\x12\x06\xf2\x10\
    \x04\xf9\x10\x06\n\x14\n\n\x06\0\x02\x82\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xf2\x10\x04\xf9\x10\x06\n\x0e\n\x06\x06\0\x02\x82\x01\x04\x12\x04\xfa\
    \x10\x047\n\x11\n\t\x06\0\x02\x82\x01\x04\xc3\xf3\x04\x12\x04\xfa\x10\
    \x047\n\x0e\n\x06\x06\0\x02\x82\x01\x04\x12\x04\xfb\x10\x04E\n\x12\n\n\
    \x06\0\x02\x82\x01\x04\xc2\xf3\x04\0\x12\x04\xfb\x10\x04E\n\x0e\n\x06\
    \x06\0\x02\x82\x01\x04\x12\x04\xfc\x10\x04H\n\x12\n\n\x06\0\x02\x82\x01\
    \x04\xc2\xf3\x04\x01\x12\x04\xfc\x10\x04H\n\x0e\n\x06\x06\0\x02\x82\x01\
    \x04\x12\x04\xfd\x10\x04E\n\x12\n\n\x06\0\x02\x82\x01\x04\xc2\xf3\x04\
    \x02\x12\x04\xfd\x10\x04E\n!\n\x05\x06\0\x02\x83\x01\x12\x06\x81\x11\x02\
    \x8b\x11\x03\x1a\x10\x20PostStatValues\n\n\x0e\n\x06\x06\0\x02\x83\x01\
    \x01\x12\x04\x81\x11\x06\x14\n\x0e\n\x06\x06\0\x02\x83\x01\x02\x12\x04\
    \x81\x11\x16+\n\x0e\n\x06\x06\0\x02\x83\x01\x03\x12\x04\x81\x116L\n\x10\
    \n\x06\x06\0\x02\x83\x01\x04\x12\x06\x82\x11\x04\x89\x11\x06\n\x14\n\n\
    \x06\0\x02\x83\x01\x04\xb0\xca\xbc\"\x12\x06\x82\x11\x04\x89\x11\x06\n\
    \x0e\n\x06\x06\0\x02\x83\x01\x04\x12\x04\x8a\x11\x047\n\x11\n\t\x06\0\
    \x02\x83\x01\x04\xc3\xf3\x04\x12\x04\x8a\x11\x047\n*\n\x05\x06\0\x02\x84\
    \x01\x12\x06\x8e\x11\x02\x98\x11\x03\x1a\x19\x20PostStatValuesAggregate\
    \n\n\x0e\n\x06\x06\0\x02\x84\x01\x01\x12\x04\x8e\x11\x06\x1d\n\x0e\n\x06\
    \x06\0\x02\x84\x01\x02\x12\x04\x8e\x11\x1f=\n\x0e\n\x06\x06\0\x02\x84\
    \x01\x03\x12\x04\x8e\x11Hg\n\x10\n\x06\x06\0\x02\x84\x01\x04\x12\x06\x8f\
    \x11\x04\x96\x11\x06\n\x14\n\n\x06\0\x02\x84\x01\x04\xb0\xca\xbc\"\x12\
    \x06\x8f\x11\x04\x96\x11\x06\n\x0e\n\x06\x06\0\x02\x84\x01\x04\x12\x04\
    \x97\x11\x047\n\x11\n\t\x06\0\x02\x84\x01\x04\xc3\xf3\x04\x12\x04\x97\
    \x11\x047\n=\n\x05\x06\0\x02\x85\x01\x12\x06\xa2\x11\x02\xa8\x11\x03\x1a\
    ,\x20Increase\x20the\x20view\x20metric\x20for\x20a\x20detail\x20view\n\n\
    \x0e\n\x06\x06\0\x02\x85\x01\x01\x12\x04\xa2\x11\x06\x1d\n\x0e\n\x06\x06\
    \0\x02\x85\x01\x02\x12\x04\xa2\x11\x1f=\n\x0e\n\x06\x06\0\x02\x85\x01\
    \x03\x12\x04\xa2\x11Hh\n\x10\n\x06\x06\0\x02\x85\x01\x04\x12\x06\xa3\x11\
    \x04\xa6\x11\x06\n\x14\n\n\x06\0\x02\x85\x01\x04\xb0\xca\xbc\"\x12\x06\
    \xa3\x11\x04\xa6\x11\x06\n\x0e\n\x06\x06\0\x02\x85\x01\x04\x12\x04\xa7\
    \x11\x047\n\x11\n\t\x06\0\x02\x85\x01\x04\xc3\xf3\x04\x12\x04\xa7\x11\
    \x047\n:\n\x05\x06\0\x02\x86\x01\x12\x06\xab\x11\x02\xb3\x11\x03\x1a)\
    \x20List\x20the\x20view\x20metrics\x20for\x20a\x20detail\x20view\n\n\x0e\
    \n\x06\x06\0\x02\x86\x01\x01\x12\x04\xab\x11\x06\x1e\n\x0e\n\x06\x06\0\
    \x02\x86\x01\x02\x12\x04\xab\x11\x20?\n\x0e\n\x06\x06\0\x02\x86\x01\x03\
    \x12\x04\xab\x11Jj\n\x10\n\x06\x06\0\x02\x86\x01\x04\x12\x06\xac\x11\x04\
    \xb1\x11\x06\n\x14\n\n\x06\0\x02\x86\x01\x04\xb0\xca\xbc\"\x12\x06\xac\
    \x11\x04\xb1\x11\x06\n\x0e\n\x06\x06\0\x02\x86\x01\x04\x12\x04\xb2\x11\
    \x047\n\x11\n\t\x06\0\x02\x86\x01\x04\xc3\xf3\x04\x12\x04\xb2\x11\x047\n\
    -\n\x02\x04\0\x12\x06\xce\x11\0\xd3\x11\x01\x1a\x1f\x20Split\x20the\x20r\
    esults\x20into\x20pages.\n\n\x0b\n\x03\x04\0\x01\x12\x04\xce\x11\x08\x12\
    \n}\n\x04\x04\0\x02\0\x12\x04\xd0\x11\x02\x12\x1ao\x20(optional\x20URL\
    \x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20\
    to\x20split\x20the\x20results\x20into\x20chunks.\x20Defaults\x20to\x201.\
    \n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xd0\x11\x02\x08\n\r\n\x05\x04\0\x02\
    \0\x01\x12\x04\xd0\x11\t\r\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xd0\x11\x10\
    \x11\nt\n\x04\x04\0\x02\x01\x12\x04\xd2\x11\x02\x16\x1af\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\x20to\x20128.\n\n\
    \r\n\x05\x04\0\x02\x01\x05\x12\x04\xd2\x11\x02\x08\n\r\n\x05\x04\0\x02\
    \x01\x01\x12\x04\xd2\x11\t\x11\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xd2\
    \x11\x14\x15\n$\n\x02\x04\x01\x12\x06\xd6\x11\0\xda\x11\x01\x1a\x16\x20G\
    etAnnotationRequest\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xd6\x11\x08\x1c\n\
    \x0c\n\x04\x04\x01\x02\0\x12\x04\xd7\x11\x02,\n\r\n\x05\x04\x01\x02\0\
    \x06\x12\x04\xd7\x11\x02\x1b\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xd7\x11\
    \x1c'\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xd7\x11*+\n\x0c\n\x04\x04\x01\
    \x02\x01\x12\x04\xd8\x11\x02\x1b\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\
    \xd8\x11\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xd8\x11\t\x16\n\r\
    \n\x05\x04\x01\x02\x01\x03\x12\x04\xd8\x11\x19\x1a\n\x0c\n\x04\x04\x01\
    \x02\x02\x12\x04\xd9\x11\x02\x16\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\
    \xd9\x11\x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xd9\x11\t\x11\n\r\
    \n\x05\x04\x01\x02\x02\x03\x12\x04\xd9\x11\x14\x15\n&\n\x02\x04\x02\x12\
    \x06\xdd\x11\0\x8f\x12\x01\x1a\x18\x20ListAnnotationsRequest\n\n\x0b\n\
    \x03\x04\x02\x01\x12\x04\xdd\x11\x08\x1e\n\x0b\n\x03\x04\x02\t\x12\x04\
    \xde\x11\x02\r\n\x0c\n\x04\x04\x02\t\0\x12\x04\xde\x11\x0b\x0c\n\r\n\x05\
    \x04\x02\t\0\x01\x12\x04\xde\x11\x0b\x0c\n\r\n\x05\x04\x02\t\0\x02\x12\
    \x04\xde\x11\x0b\x0c\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xe0\x11\x02,\n\r\
    \n\x05\x04\x02\x02\0\x06\x12\x04\xe0\x11\x02\x1b\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\xe0\x11\x1c'\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xe0\x11*+\
    \n.\n\x04\x04\x02\x02\x01\x12\x04\xe3\x11\x02\x1a\x1a\x20\x20List\x20ann\
    otations\x20for\x20these\x20IDs\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\
    \xe3\x11\x02\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\xe3\x11\x0b\x11\n\r\
    \n\x05\x04\x02\x02\x01\x01\x12\x04\xe3\x11\x12\x15\n\r\n\x05\x04\x02\x02\
    \x01\x03\x12\x04\xe3\x11\x18\x19\n\xd5\x02\n\x04\x04\x02\x02\x02\x12\x04\
    \xea\x11\x02\x20\x1a\xc6\x02\x20List\x20annotations\x20for\x20these\x20I\
    nput\x20IDs\n\x20Note\x20that\x20'ids'\x20are\x20optional\x20but\x20if\
    \x20the\x20are\x20provided\x20the\x20number\x20and\x20order\x20in\n\x20'\
    ids'\x20and\x20'input_ids'\x20should\x20match\n\x20If\x20you\x20do\x20no\
    t\x20specify\x20'ids'\x20all\x20the\x20annotations\x20for\x20'input_ids'\
    \x20are\x20returned\n\x20If\x20a\x20you\x20do\x20not\x20specify\x20both\
    \x20'input_ids'\x20and\x20'ids'\x20all\x20the\x20annotations\x20in\x20th\
    e\x20app\x20are\x20returned\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\xea\
    \x11\x02\n\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\xea\x11\x0b\x11\n\r\n\
    \x05\x04\x02\x02\x02\x01\x12\x04\xea\x11\x12\x1b\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\xea\x11\x1e\x1f\n\xe6\x03\n\x04\x04\x02\x02\x03\x12\x04\
    \xf2\x11\x02\x1f\x1a\xd7\x03\x20Only\x20return\x20the\x20annotations\x20\
    that\x20has\x20one\x20of\x20these\x20user\x20IDs,\x20effectively\x20oper\
    ating\x20as\x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20down\x20th\
    e\x20results.\n\x20If\x20model_version_ids\x20are\x20also\x20provided\
    \x20these\x20user_ids\x20are\x20OR'd\x20with\x20them\x20as\x20well\x20si\
    nce\n\x20annotations\x20are\x20either\x20provided\x20by\x20users\x20or\
    \x20model\x20versions\x20and\x20we\x20want\x20the\x20union\x20of\x20any\
    \n\x20provided\x20user\x20or\x20model\x20version\x20annotations\x20in\
    \x20the\x20results\x20of\x20ListAnnotations\x20request.\n\x20If\x20no\
    \x20user_ids\x20are\x20provided\x20then\x20annotations\x20from\x20all\
    \x20users\x20are\x20returned.\n\n\r\n\x05\x04\x02\x02\x03\x04\x12\x04\
    \xf2\x11\x02\n\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\xf2\x11\x0b\x11\n\r\
    \n\x05\x04\x02\x02\x03\x01\x12\x04\xf2\x11\x12\x1a\n\r\n\x05\x04\x02\x02\
    \x03\x03\x12\x04\xf2\x11\x1d\x1e\n\x82\x04\n\x04\x04\x02\x02\x04\x12\x04\
    \xfa\x11\x02)\x1a\xf3\x03\x20Only\x20return\x20the\x20annotations\x20tha\
    t\x20has\x20one\x20of\x20these\x20model\x20version\x20IDs,\x20effectivel\
    y\x20operating\x20as\x20an\n\x20OR\x20among\x20them\x20to\x20filter\x20d\
    own\x20the\x20results.\n\x20If\x20user_ids\x20are\x20also\x20provided\
    \x20these\x20model_versions_ids\x20are\x20OR'd\x20with\x20them\x20as\x20\
    well\x20since\n\x20annotations\x20are\x20either\x20provided\x20by\x20use\
    rs\x20or\x20model\x20versions\x20and\x20we\x20want\x20the\x20union\x20of\
    \x20any\n\x20provided\x20user\x20or\x20model\x20version\x20annotations\
    \x20in\x20the\x20results\x20of\x20ListAnnotations\x20request.\n\x20If\
    \x20no\x20model_version_ids\x20are\x20provided\x20then\x20annotations\
    \x20from\x20all\x20model\x20versions\x20are\x20returned.\n\n\r\n\x05\x04\
    \x02\x02\x04\x04\x12\x04\xfa\x11\x02\n\n\r\n\x05\x04\x02\x02\x04\x05\x12\
    \x04\xfa\x11\x0b\x11\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\xfa\x11\x12#\
    \n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\xfa\x11&(\n\x8b\x01\n\x04\x04\x02\
    \x02\x05\x12\x04\xfe\x11\x023\x1a}\x20Set\x20status\x20to\x20filter\x20b\
    y\x20a\x20list\x20of\x20statuses\n\x20If\x20not\x20statuses\x20are\x20pr\
    ovided\x20then\x20annotations\x20with\x20any\x20status\x20will\x20be\x20\
    returned.\n\n\r\n\x05\x04\x02\x02\x05\x04\x12\x04\xfe\x11\x02\n\n\r\n\
    \x05\x04\x02\x02\x05\x06\x12\x04\xfe\x11\x0b%\n\r\n\x05\x04\x02\x02\x05\
    \x01\x12\x04\xfe\x11&.\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\xfe\x1112\n\
    \x80\x01\n\x04\x04\x02\x02\x06\x12\x04\x82\x12\x02\x20\x1ar\x20Set\x20th\
    is\x20flag\x20to\x20list\x20both\x20trusted\x20and\x20not\x20trusted\x20\
    annotations\n\x20by\x20default\x20it's\x20listing\x20only\x20trusted\x20\
    annotations\n\n\r\n\x05\x04\x02\x02\x06\x05\x12\x04\x82\x12\x02\x06\n\r\
    \n\x05\x04\x02\x02\x06\x01\x12\x04\x82\x12\x07\x1b\n\r\n\x05\x04\x02\x02\
    \x06\x03\x12\x04\x82\x12\x1e\x1f\n_\n\x04\x04\x02\x02\x07\x12\x04\x85\
    \x12\x02\x20\x1aQ\x20Set\x20this\x20flag\x20to\x20return\x20the\x20model\
    \x20output\x20for\x20model\x20annotations\x20in\x20the\x20response.\n\n\
    \r\n\x05\x04\x02\x02\x07\x05\x12\x04\x85\x12\x02\x06\n\r\n\x05\x04\x02\
    \x02\x07\x01\x12\x04\x85\x12\x07\x1a\n\r\n\x05\x04\x02\x02\x07\x03\x12\
    \x04\x85\x12\x1d\x1f\n~\n\x04\x04\x02\x02\x08\x12\x04\x89\x12\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x02\x02\x08\x05\x12\x04\x89\
    \x12\x02\x08\n\r\n\x05\x04\x02\x02\x08\x01\x12\x04\x89\x12\t\r\n\r\n\x05\
    \x04\x02\x02\x08\x03\x12\x04\x89\x12\x10\x11\nu\n\x04\x04\x02\x02\t\x12\
    \x04\x8c\x12\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20nu\
    mber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x02\x02\t\x05\x12\
    \x04\x8c\x12\x02\x08\n\r\n\x05\x04\x02\x02\t\x01\x12\x04\x8c\x12\t\x11\n\
    \r\n\x05\x04\x02\x02\t\x03\x12\x04\x8c\x12\x14\x15\n5\n\x04\x04\x02\x02\
    \n\x12\x04\x8e\x12\x02\x16\x1a'\x20Flag\x20to\x20filter\x20annotations\
    \x20by\x20task_id\n\n\r\n\x05\x04\x02\x02\n\x05\x12\x04\x8e\x12\x02\x08\
    \n\r\n\x05\x04\x02\x02\n\x01\x12\x04\x8e\x12\t\x10\n\r\n\x05\x04\x02\x02\
    \n\x03\x12\x04\x8e\x12\x13\x15\n&\n\x02\x04\x03\x12\x06\x92\x12\0\x97\
    \x12\x01\x1a\x18\x20PostAnnotationsRequest\n\n\x0b\n\x03\x04\x03\x01\x12\
    \x04\x92\x12\x08\x1e\n\x0c\n\x04\x04\x03\x02\0\x12\x04\x94\x12\x02,\n\r\
    \n\x05\x04\x03\x02\0\x06\x12\x04\x94\x12\x02\x1b\n\r\n\x05\x04\x03\x02\0\
    \x01\x12\x04\x94\x12\x1c'\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x94\x12*+\
    \n\x0c\n\x04\x04\x03\x02\x01\x12\x04\x96\x12\x02&\n\r\n\x05\x04\x03\x02\
    \x01\x04\x12\x04\x96\x12\x02\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x96\
    \x12\x0b\x15\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x96\x12\x16!\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\x96\x12$%\n'\n\x02\x04\x04\x12\x06\x9a\
    \x12\0\xa2\x12\x01\x1a\x19\x20PatchAnnotationsRequest\n\n\x0b\n\x03\x04\
    \x04\x01\x12\x04\x9a\x12\x08\x1f\n\x0c\n\x04\x04\x04\x02\0\x12\x04\x9b\
    \x12\x02,\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\x9b\x12\x02\x1b\n\r\n\x05\
    \x04\x04\x02\0\x01\x12\x04\x9b\x12\x1c'\n\r\n\x05\x04\x04\x02\0\x03\x12\
    \x04\x9b\x12*+\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\x9d\x12\x02&\n\r\n\
    \x05\x04\x04\x02\x01\x04\x12\x04\x9d\x12\x02\n\n\r\n\x05\x04\x04\x02\x01\
    \x06\x12\x04\x9d\x12\x0b\x15\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x9d\
    \x12\x16!\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x9d\x12$%\n~\n\x04\x04\
    \x04\x02\x02\x12\x04\xa1\x12\x02\x14\x1ap\x20The\x20action\x20to\x20perf\
    orm\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\x20'me\
    rge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\r\n\x05\
    \x04\x04\x02\x02\x05\x12\x04\xa1\x12\x02\x08\n\r\n\x05\x04\x04\x02\x02\
    \x01\x12\x04\xa1\x12\t\x0f\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xa1\x12\
    \x12\x13\n-\n\x02\x04\x05\x12\x06\xa5\x12\0\xae\x12\x01\x1a\x1f\x20Patch\
    AnnotationsStatusRequest\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xa5\x12\x08%\
    \n\x0c\n\x04\x04\x05\x02\0\x12\x04\xa6\x12\x02,\n\r\n\x05\x04\x05\x02\0\
    \x06\x12\x04\xa6\x12\x02\x1b\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xa6\x12\
    \x1c'\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xa6\x12*+\n&\n\x04\x04\x05\x02\
    \x01\x12\x04\xa8\x12\x021\x1a\x18\x20Annotation\x20Status\x20code\n\n\r\
    \n\x05\x04\x05\x02\x01\x06\x12\x04\xa8\x12\x02\x20\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\xa8\x12!,\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xa8\x12\
    /0\n\x0c\n\x04\x04\x05\x02\x02\x12\x04\xa9\x12\x02\x1f\n\r\n\x05\x04\x05\
    \x02\x02\x04\x12\x04\xa9\x12\x02\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\
    \xa9\x12\x0b\x11\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xa9\x12\x12\x1a\n\
    \r\n\x05\x04\x05\x02\x02\x03\x12\x04\xa9\x12\x1d\x1e\n\x0c\n\x04\x04\x05\
    \x02\x03\x12\x04\xaa\x12\x02\x15\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\
    \xaa\x12\x02\x08\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xaa\x12\t\x10\n\r\
    \n\x05\x04\x05\x02\x03\x03\x12\x04\xaa\x12\x13\x14\n(\n\x04\x04\x05\x02\
    \x04\x12\x04\xac\x12\x02\x14\x1a\x1a\x20'overwrite'\x20is\x20supported\n\
    \n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\xac\x12\x02\x08\n\r\n\x05\x04\x05\
    \x02\x04\x01\x12\x04\xac\x12\t\x0f\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\
    \xac\x12\x12\x13\n.\n\x02\x04\x06\x12\x06\xb1\x12\0\xb5\x12\x01\x1a\x20\
    \x20PatchAnnotationsStatusResponse\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xb1\
    \x12\x08&\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xb2\x12\x02(\n\r\n\x05\x04\
    \x06\x02\0\x06\x12\x04\xb2\x12\x02\x1c\n\r\n\x05\x04\x06\x02\0\x01\x12\
    \x04\xb2\x12\x1d#\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xb2\x12&'\n\x0c\n\
    \x04\x04\x06\x02\x01\x12\x04\xb3\x12\x02\x1f\n\r\n\x05\x04\x06\x02\x01\
    \x04\x12\x04\xb3\x12\x02\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xb3\x12\
    \x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xb3\x12\x12\x1a\n\r\n\x05\
    \x04\x06\x02\x01\x03\x12\x04\xb3\x12\x1d\x1e\n\x0c\n\x04\x04\x06\x02\x02\
    \x12\x04\xb4\x12\x02\x1b\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xb4\x12\
    \x02\x08\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xb4\x12\t\x16\n\r\n\x05\
    \x04\x06\x02\x02\x03\x12\x04\xb4\x12\x19\x1a\n'\n\x02\x04\x07\x12\x06\
    \xb8\x12\0\xbe\x12\x01\x1a\x19\x20DeleteAnnotationRequest\n\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\xb8\x12\x08\x1f\n\x0c\n\x04\x04\x07\x02\0\x12\x04\
    \xb9\x12\x02,\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xb9\x12\x02\x1b\n\r\n\
    \x05\x04\x07\x02\0\x01\x12\x04\xb9\x12\x1c'\n\r\n\x05\x04\x07\x02\0\x03\
    \x12\x04\xb9\x12*+\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xbb\x12\x02\x16\n\
    \r\n\x05\x04\x07\x02\x01\x05\x12\x04\xbb\x12\x02\x08\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xbb\x12\t\x11\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\
    \xbb\x12\x14\x15\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xbd\x12\x02\x1b\n\r\
    \n\x05\x04\x07\x02\x02\x05\x12\x04\xbd\x12\x02\x08\n\r\n\x05\x04\x07\x02\
    \x02\x01\x12\x04\xbd\x12\t\x16\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xbd\
    \x12\x19\x1a\nD\n\x02\x04\x08\x12\x06\xc1\x12\0\xce\x12\x01\x1a6\x20Requ\
    est\x20to\x20delete\x20several\x20things\x20by\x20the\x20list\x20of\x20i\
    ds.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xc1\x12\x08\x20\n\x0c\n\x04\x04\
    \x08\x02\0\x12\x04\xc2\x12\x02,\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xc2\
    \x12\x02\x1b\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xc2\x12\x1c'\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xc2\x12*+\n+\n\x04\x04\x08\x02\x01\x12\x04\
    \xc5\x12\x02\x1a\x1a\x1d\x20Delete\x20annotations\x20with\x20IDs\n\n\r\n\
    \x05\x04\x08\x02\x01\x04\x12\x04\xc5\x12\x02\n\n\r\n\x05\x04\x08\x02\x01\
    \x05\x12\x04\xc5\x12\x0b\x11\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xc5\
    \x12\x12\x15\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xc5\x12\x18\x19\n\xf0\
    \x02\n\x04\x04\x08\x02\x02\x12\x04\xcd\x12\x02\x20\x1a\xe1\x02\x20Delete\
    \x20annotations\x20for\x20these\x20Input\x20IDs\n\x20Note\x20that\x20'id\
    s'\x20are\x20optional\x20but\x20if\x20the\x20are\x20provided\x20the\x20n\
    umber\x20and\x20order\x20in\n\x20'ids'\x20and\x20'input_ids'\x20should\
    \x20match\n\x20If\x20you\x20do\x20not\x20specifiy\x20'ids'\x20all\x20the\
    \x20annotations\x20for\x20'input_ids'\x20are\x20deleted\n\x20However\x20\
    you\x20need\x20to\x20specify\x20at\x20least\x20one\x20value\x20for\x20'i\
    nput_ids'\n\x20i.e.\x20this\x20API\x20does\x20not\x20support\x20deleting\
    \x20all\x20annotations\n\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xcd\x12\
    \x02\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xcd\x12\x0b\x11\n\r\n\x05\
    \x04\x08\x02\x02\x01\x12\x04\xcd\x12\x12\x1b\n\r\n\x05\x04\x08\x02\x02\
    \x03\x12\x04\xcd\x12\x1e\x1f\n(\n\x02\x04\t\x12\x06\xd1\x12\0\xd4\x12\
    \x01\x1a\x1a\x20SingleAnnotationResponse\n\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xd1\x12\x08\x20\n\x0c\n\x04\x04\t\x02\0\x12\x04\xd2\x12\x02(\n\r\n\x05\
    \x04\t\x02\0\x06\x12\x04\xd2\x12\x02\x1c\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xd2\x12\x1d#\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xd2\x12&'\n\x0c\n\
    \x04\x04\t\x02\x01\x12\x04\xd3\x12\x02\x1c\n\r\n\x05\x04\t\x02\x01\x06\
    \x12\x04\xd3\x12\x02\x0c\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xd3\x12\r\
    \x17\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xd3\x12\x1a\x1b\n'\n\x02\x04\n\
    \x12\x06\xd7\x12\0\xdb\x12\x01\x1a\x19\x20MultiAnnotationResponse\n\n\
    \x0b\n\x03\x04\n\x01\x12\x04\xd7\x12\x08\x1f\n\x0c\n\x04\x04\n\x02\0\x12\
    \x04\xd8\x12\x02(\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xd8\x12\x02\x1c\n\r\
    \n\x05\x04\n\x02\0\x01\x12\x04\xd8\x12\x1d#\n\r\n\x05\x04\n\x02\0\x03\
    \x12\x04\xd8\x12&'\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xda\x12\x02U\n\r\n\
    \x05\x04\n\x02\x01\x04\x12\x04\xda\x12\x02\n\n\r\n\x05\x04\n\x02\x01\x06\
    \x12\x04\xda\x12\x0b\x15\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xda\x12\x16\
    !\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xda\x12$%\n\r\n\x05\x04\n\x02\x01\
    \x08\x12\x04\xda\x12&T\n\x10\n\x08\x04\n\x02\x01\x08\xd0\x86\x03\x12\x04\
    \xda\x12'S\n\x1d\n\x02\x04\x0b\x12\x06\xde\x12\0\xe2\x12\x01\x1a\x0f\x20\
    GetAppRequest\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xde\x12\x08\x15\n\x0c\n\
    \x04\x04\x0b\x02\0\x12\x04\xdf\x12\x02,\n\r\n\x05\x04\x0b\x02\0\x06\x12\
    \x04\xdf\x12\x02\x1b\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xdf\x12\x1c'\n\
    \r\n\x05\x04\x0b\x02\0\x03\x12\x04\xdf\x12*+\n\x82\x01\n\x04\x04\x0b\x02\
    \x01\x12\x04\xe1\x12\x02(\x1at\x20(optional\x20URL\x20parameter)\x20List\
    \x20of\x20additional\x20fields\x20to\x20be\x20included\x20in\x20the\x20r\
    esponse.\x20Currently\x20supported:\x20all,\x20stars\n\n\r\n\x05\x04\x0b\
    \x02\x01\x04\x12\x04\xe1\x12\x02\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\
    \xe1\x12\x0b\x11\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xe1\x12\x12#\n\r\
    \n\x05\x04\x0b\x02\x01\x03\x12\x04\xe1\x12&'\n\x1f\n\x02\x04\x0c\x12\x06\
    \xe5\x12\0\x85\x13\x01\x1a\x11\x20ListAppsRequest\n\n\x0b\n\x03\x04\x0c\
    \x01\x12\x04\xe5\x12\x08\x17\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xe6\x12\
    \x02,\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\xe6\x12\x02\x1b\n\r\n\x05\x04\
    \x0c\x02\0\x01\x12\x04\xe6\x12\x1c'\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\
    \xe6\x12*+\n~\n\x04\x04\x0c\x02\x01\x12\x04\xe9\x12\x02\x12\x1ap\x20(opt\
    ional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\
    \x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaul\
    ts\x20to\x201.\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xe9\x12\x02\x08\n\
    \r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xe9\x12\t\r\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\xe9\x12\x10\x11\nu\n\x04\x04\x0c\x02\x02\x12\x04\xec\
    \x12\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xec\
    \x12\x02\x08\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xec\x12\t\x11\n\r\n\
    \x05\x04\x0c\x02\x02\x03\x12\x04\xec\x12\x14\x15\no\n\x04\x04\x0c\x02\
    \x03\x12\x04\xf0\x12\x03\x1b\x1aa\x20Sorting\x20opitons:\n\x20Whether\
    \x20to\x20sort\x20in\x20ascending\x20order.\x20If\x20false,\x20will\x20o\
    rder\x20in\x20descending\x20order.\n\n\r\n\x05\x04\x0c\x02\x03\x05\x12\
    \x04\xf0\x12\x03\x07\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xf0\x12\x08\
    \x16\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xf0\x12\x19\x1a\n\x0e\n\x04\
    \x04\x0c\x08\0\x12\x06\xf1\x12\x03\xf7\x12\x04\n\r\n\x05\x04\x0c\x08\0\
    \x01\x12\x04\xf1\x12\t\x10\n,\n\x04\x04\x0c\x02\x04\x12\x04\xf3\x12\x04\
    \x1a\x1a\x1e\x20Whether\x20to\x20order\x20by\x20the\x20name\n\n\r\n\x05\
    \x04\x0c\x02\x04\x05\x12\x04\xf3\x12\x04\x08\n\r\n\x05\x04\x0c\x02\x04\
    \x01\x12\x04\xf3\x12\t\x15\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xf3\x12\
    \x18\x19\n{\n\x04\x04\x0c\x02\x05\x12\x04\xf6\x12\x04!\x1am\x20Whether\
    \x20to\x20order\x20by\x20the\x20modified_at\x20time.\n\x20If\x20neither\
    \x20sort\x20option\x20is\x20set\x20to\x20true,\x20will\x20sort\x20by\x20\
    modified_at.\n\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\xf6\x12\x04\x08\n\r\
    \n\x05\x04\x0c\x02\x05\x01\x12\x04\xf6\x12\t\x1c\n\r\n\x05\x04\x0c\x02\
    \x05\x03\x12\x04\xf6\x12\x1f\x20\nl\n\x04\x04\x0c\x02\x06\x12\x04\xfb\
    \x12\x02\x13\x1a^\x20Filtering\x20options:\n\x20Query\x20various\x20text\
    \x20fields\x20that\x20can\x20contain\x20the\x20words\x20in\x20the\x20que\
    ry\x20string\n\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xfb\x12\x02\x08\n\r\
    \n\x05\x04\x0c\x02\x06\x01\x12\x04\xfb\x12\t\x0e\n\r\n\x05\x04\x0c\x02\
    \x06\x03\x12\x04\xfb\x12\x11\x12\n\x99\x01\n\x04\x04\x0c\x02\x07\x12\x04\
    \xfe\x12\x02&\x1a\x8a\x01\x20Filter\x20by\x20the\x20name\x20of\x20the\
    \x20app.\x20This\x20supports\x20wilcard\x20queries\x20like\x20\"gen*\"\
    \x20to\x20match\x20\"general\"\x20as\x20an\x20example.\n\x20Deprecated\
    \x20in\x20favor\x20of\x20query\n\n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\
    \xfe\x12\x02\x08\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\xfe\x12\t\r\n\r\n\
    \x05\x04\x0c\x02\x07\x03\x12\x04\xfe\x12\x10\x11\n\r\n\x05\x04\x0c\x02\
    \x07\x08\x12\x04\xfe\x12\x12%\n\x0e\n\x06\x04\x0c\x02\x07\x08\x03\x12\
    \x04\xfe\x12\x13$\nR\n\x04\x04\x0c\x02\x08\x12\x04\x80\x13\x02\x19\x1aD\
    \x20If\x20true,\x20we\x20only\x20return\x20apps\x20that\x20are\x20handpi\
    cked\x20by\x20clarifai\x20staff\n\n\r\n\x05\x04\x0c\x02\x08\x05\x12\x04\
    \x80\x13\x02\x06\n\r\n\x05\x04\x0c\x02\x08\x01\x12\x04\x80\x13\x07\x14\n\
    \r\n\x05\x04\x0c\x02\x08\x03\x12\x04\x80\x13\x17\x18\nT\n\x04\x04\x0c\
    \x02\t\x12\x04\x82\x13\x02\x19\x1aF\x20If\x20true,\x20we\x20only\x20retu\
    rn\x20apps\x20that\x20are\x20starred\x20by\x20the\x20requesting\x20user\
    \n\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\x82\x13\x02\x06\n\r\n\x05\x04\x0c\
    \x02\t\x01\x12\x04\x82\x13\x07\x13\n\r\n\x05\x04\x0c\x02\t\x03\x12\x04\
    \x82\x13\x16\x18\n\x82\x01\n\x04\x04\x0c\x02\n\x12\x04\x84\x13\x02)\x1at\
    \x20(optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\
    \x20to\x20be\x20included\x20in\x20the\x20response.\x20Currently\x20suppo\
    rted:\x20all,\x20stars\n\n\r\n\x05\x04\x0c\x02\n\x04\x12\x04\x84\x13\x02\
    \n\n\r\n\x05\x04\x0c\x02\n\x05\x12\x04\x84\x13\x0b\x11\n\r\n\x05\x04\x0c\
    \x02\n\x01\x12\x04\x84\x13\x12#\n\r\n\x05\x04\x0c\x02\n\x03\x12\x04\x84\
    \x13&(\n\x1f\n\x02\x04\r\x12\x06\x88\x13\0\x8b\x13\x01\x1a\x11\x20PostAp\
    psRequest\n\n\x0b\n\x03\x04\r\x01\x12\x04\x88\x13\x08\x17\n\x0c\n\x04\
    \x04\r\x02\0\x12\x04\x89\x13\x02,\n\r\n\x05\x04\r\x02\0\x06\x12\x04\x89\
    \x13\x02\x1b\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x89\x13\x1c'\n\r\n\x05\
    \x04\r\x02\0\x03\x12\x04\x89\x13*+\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x8a\
    \x13\x02\x18\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\x8a\x13\x02\n\n\r\n\x05\
    \x04\r\x02\x01\x06\x12\x04\x8a\x13\x0b\x0e\n\r\n\x05\x04\r\x02\x01\x01\
    \x12\x04\x8a\x13\x0f\x13\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x8a\x13\x16\
    \x17\n\x20\n\x02\x04\x0e\x12\x06\x8e\x13\0\x90\x13\x01\x1a\x12\x20Delete\
    AppRequest\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\x8e\x13\x08\x18\n\x0c\n\x04\
    \x04\x0e\x02\0\x12\x04\x8f\x13\x02,\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\
    \x8f\x13\x02\x1b\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x8f\x13\x1c'\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\x8f\x13*+\n\x20\n\x02\x04\x0f\x12\x06\x93\
    \x13\0\xa0\x13\x01\x1a\x12\x20PatchAppsRequest\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\x93\x13\x08\x18\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x94\x13\x02,\
    \n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x94\x13\x02\x1b\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\x94\x13\x1c'\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x94\
    \x13*+\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\x95\x13\x02\x18\n\r\n\x05\x04\
    \x0f\x02\x01\x04\x12\x04\x95\x13\x02\n\n\r\n\x05\x04\x0f\x02\x01\x06\x12\
    \x04\x95\x13\x0b\x0e\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x95\x13\x0f\
    \x13\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x95\x13\x16\x17\n\x82\x01\n\
    \x04\x04\x0f\x02\x02\x12\x04\x99\x13\x02\x14\x1at\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20App\x20objects\x20except\x20App.M\
    etadata\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20suppor\
    ted\n\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\x99\x13\x02\x08\n\r\n\x05\
    \x04\x0f\x02\x02\x01\x12\x04\x99\x13\t\x0f\n\r\n\x05\x04\x0f\x02\x02\x03\
    \x12\x04\x99\x13\x12\x13\nA\n\x04\x04\x0f\x02\x03\x12\x04\x9c\x13\x02/\
    \x1a3\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20App.M\
    etadata\n\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\x9c\x13\x02\x1a\n\r\n\
    \x05\x04\x0f\x02\x03\x01\x12\x04\x9c\x13\x1b*\n\r\n\x05\x04\x0f\x02\x03\
    \x03\x12\x04\x9c\x13-.\na\n\x04\x04\x0f\x02\x04\x12\x04\x9f\x13\x02\x13\
    \x1aS\x20If\x20set,\x20the\x20app\x20will\x20be\x20automatically\x20rein\
    dexed\x20upon\x20change\x20of\x20its\x20base\x20workflow.\n\n\r\n\x05\
    \x04\x0f\x02\x04\x05\x12\x04\x9f\x13\x02\x06\n\r\n\x05\x04\x0f\x02\x04\
    \x01\x12\x04\x9f\x13\x07\x0e\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\x9f\
    \x13\x11\x12\n7\n\x02\x04\x10\x12\x06\xa3\x13\0\xaa\x13\x01\x1a)\x20Sear\
    ch\x20over\x20the\x20available\x20applications.\n\n\x0b\n\x03\x04\x10\
    \x01\x12\x04\xa3\x13\x08\x1f\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xa4\x13\
    \x02,\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xa4\x13\x02\x1b\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\xa4\x13\x1c'\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \xa4\x13*+\n(\n\x04\x04\x10\x02\x01\x12\x04\xa6\x13\x02\x19\x1a\x1a\x20T\
    he\x20body\x20of\x20the\x20request.\n\n\r\n\x05\x04\x10\x02\x01\x06\x12\
    \x04\xa6\x13\x02\n\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xa6\x13\x0b\x14\
    \n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xa6\x13\x17\x18\n]\n\x04\x04\x10\
    \x02\x02\x12\x04\xa9\x13\x02\x1c\x1aO\x20Pagination\x20parameters\x20her\
    e\x20since\x20there\x20are\x20no\x20url\x20args\x20in\x20this\n\x20POST\
    \x20request.\n\n\r\n\x05\x04\x10\x02\x02\x06\x12\x04\xa9\x13\x02\x0c\n\r\
    \n\x05\x04\x10\x02\x02\x01\x12\x04\xa9\x13\r\x17\n\r\n\x05\x04\x10\x02\
    \x02\x03\x12\x04\xa9\x13\x1a\x1b\n!\n\x02\x04\x11\x12\x06\xad\x13\0\xb0\
    \x13\x01\x1a\x13\x20SingleAppResponse\n\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xad\x13\x08\x19\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xae\x13\x02(\n\r\n\
    \x05\x04\x11\x02\0\x06\x12\x04\xae\x13\x02\x1c\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xae\x13\x1d#\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xae\x13&'\
    \n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xaf\x13\x02\x0e\n\r\n\x05\x04\x11\
    \x02\x01\x06\x12\x04\xaf\x13\x02\x05\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xaf\x13\x06\t\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xaf\x13\x0c\r\n\
    \x20\n\x02\x04\x12\x12\x06\xb3\x13\0\xb6\x13\x01\x1a\x12\x20MultiAppResp\
    onse\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xb3\x13\x08\x18\n\x0c\n\x04\x04\
    \x12\x02\0\x12\x04\xb4\x13\x02(\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xb4\
    \x13\x02\x1c\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xb4\x13\x1d#\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\xb4\x13&'\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\
    \xb5\x13\x02G\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xb5\x13\x02\n\n\r\n\
    \x05\x04\x12\x02\x01\x06\x12\x04\xb5\x13\x0b\x0e\n\r\n\x05\x04\x12\x02\
    \x01\x01\x12\x04\xb5\x13\x0f\x13\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xb5\x13\x16\x17\n\r\n\x05\x04\x12\x02\x01\x08\x12\x04\xb5\x13\x18F\n\
    \x10\n\x08\x04\x12\x02\x01\x08\xd0\x86\x03\x12\x04\xb5\x13\x19E\n(\n\x02\
    \x04\x13\x12\x06\xb9\x13\0\xbe\x13\x01\x1a\x1a\x20ListCollaboratorsReque\
    st\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xb9\x13\x08\x20\n\x0c\n\x04\x04\x13\
    \x02\0\x12\x04\xba\x13\x02,\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xba\x13\
    \x02\x1b\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xba\x13\x1c'\n\r\n\x05\x04\
    \x13\x02\0\x03\x12\x04\xba\x13*+\n\x88\x01\n\x04\x04\x13\x02\x01\x12\x04\
    \xbd\x13\x02\"\x1az\x20Set\x20this\x20flag\x20to\x20list\x20both\x20dele\
    ted\x20and\x20not\x20deleted\x20collaborators\n\x20by\x20default\x20it's\
    \x20listing\x20only\x20not\x20deleted\x20collaborators\n\n\r\n\x05\x04\
    \x13\x02\x01\x05\x12\x04\xbd\x13\x02\x06\n\r\n\x05\x04\x13\x02\x01\x01\
    \x12\x04\xbd\x13\x07\x1d\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xbd\x13\
    \x20!\n(\n\x02\x04\x14\x12\x06\xc1\x13\0\xc4\x13\x01\x1a\x1a\x20PostColl\
    aboratorsRequest\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xc1\x13\x08\x20\n\x0c\
    \n\x04\x04\x14\x02\0\x12\x04\xc2\x13\x02,\n\r\n\x05\x04\x14\x02\0\x06\
    \x12\x04\xc2\x13\x02\x1b\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xc2\x13\x1c\
    '\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xc2\x13*+\n\x0c\n\x04\x04\x14\x02\
    \x01\x12\x04\xc3\x13\x02*\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xc3\x13\
    \x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xc3\x13\x0b\x17\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\xc3\x13\x18%\n\r\n\x05\x04\x14\x02\x01\x03\
    \x12\x04\xc3\x13()\n)\n\x02\x04\x15\x12\x06\xc7\x13\0\xce\x13\x01\x1a\
    \x1b\x20PatchCollaboratorsRequest\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xc7\
    \x13\x08!\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xc8\x13\x02,\n\r\n\x05\x04\
    \x15\x02\0\x06\x12\x04\xc8\x13\x02\x1b\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\xc8\x13\x1c'\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xc8\x13*+\n\x0c\n\
    \x04\x04\x15\x02\x01\x12\x04\xc9\x13\x02*\n\r\n\x05\x04\x15\x02\x01\x04\
    \x12\x04\xc9\x13\x02\n\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\xc9\x13\x0b\
    \x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xc9\x13\x18%\n\r\n\x05\x04\
    \x15\x02\x01\x03\x12\x04\xc9\x13()\nj\n\x04\x04\x15\x02\x02\x12\x04\xcd\
    \x13\x02\x14\x1a\\\x20The\x20action\x20to\x20perform\x20on\x20the\x20pat\
    ched\x20objects\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\
    \x20supported\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xcd\x13\x02\x08\n\
    \r\n\x05\x04\x15\x02\x02\x01\x12\x04\xcd\x13\t\x0f\n\r\n\x05\x04\x15\x02\
    \x02\x03\x12\x04\xcd\x13\x12\x13\n*\n\x02\x04\x16\x12\x06\xd1\x13\0\xd5\
    \x13\x01\x1a\x1c\x20DeleteCollaboratorsRequest\n\n\x0b\n\x03\x04\x16\x01\
    \x12\x04\xd1\x13\x08\"\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xd2\x13\x02,\n\
    \r\n\x05\x04\x16\x02\0\x06\x12\x04\xd2\x13\x02\x1b\n\r\n\x05\x04\x16\x02\
    \0\x01\x12\x04\xd2\x13\x1c'\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xd2\x13*\
    +\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xd3\x13\x02'\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\xd3\x13\x02\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xd3\
    \x13\x0b\x11\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xd3\x13\x12\"\n\r\n\
    \x05\x04\x16\x02\x01\x03\x12\x04\xd3\x13%&\n\x0c\n\x04\x04\x16\x02\x02\
    \x12\x04\xd4\x13\x02\"\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xd4\x13\x02\
    \n\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xd4\x13\x0b\x11\n\r\n\x05\x04\
    \x16\x02\x02\x01\x12\x04\xd4\x13\x12\x1d\n\r\n\x05\x04\x16\x02\x02\x03\
    \x12\x04\xd4\x13\x20!\n*\n\x02\x04\x17\x12\x06\xd8\x13\0\xdb\x13\x01\x1a\
    \x1c\x20MultiCollaboratorsResponse\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xd8\
    \x13\x08\"\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xd9\x13\x02(\n\r\n\x05\x04\
    \x17\x02\0\x06\x12\x04\xd9\x13\x02\x1c\n\r\n\x05\x04\x17\x02\0\x01\x12\
    \x04\xd9\x13\x1d#\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xd9\x13&'\n\x0c\n\
    \x04\x04\x17\x02\x01\x12\x04\xda\x13\x02Y\n\r\n\x05\x04\x17\x02\x01\x04\
    \x12\x04\xda\x13\x02\n\n\r\n\x05\x04\x17\x02\x01\x06\x12\x04\xda\x13\x0b\
    \x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xda\x13\x18%\n\r\n\x05\x04\
    \x17\x02\x01\x03\x12\x04\xda\x13()\n\r\n\x05\x04\x17\x02\x01\x08\x12\x04\
    \xda\x13*X\n\x10\n\x08\x04\x17\x02\x01\x08\xd0\x86\x03\x12\x04\xda\x13+W\
    \n)\n\x02\x04\x18\x12\x06\xde\x13\0\xe6\x13\x01\x1a\x1b\x20ListCollabora\
    tionsRequest\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xde\x13\x08!\n\x0c\n\x04\
    \x04\x18\x02\0\x12\x04\xdf\x13\x02,\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\
    \xdf\x13\x02\x1b\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xdf\x13\x1c'\n\r\n\
    \x05\x04\x18\x02\0\x03\x12\x04\xdf\x13*+\n~\n\x04\x04\x18\x02\x01\x12\
    \x04\xe2\x13\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20pa\
    ge\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20resul\
    ts\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x18\x02\
    \x01\x05\x12\x04\xe2\x13\x02\x08\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\
    \xe2\x13\t\r\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xe2\x13\x10\x11\nu\n\
    \x04\x04\x18\x02\x02\x12\x04\xe5\x13\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04\x18\x02\x02\x05\x12\x04\xe5\x13\x02\x08\n\r\n\x05\x04\x18\x02\
    \x02\x01\x12\x04\xe5\x13\t\x11\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xe5\
    \x13\x14\x15\n+\n\x02\x04\x19\x12\x06\xe9\x13\0\xec\x13\x01\x1a\x1d\x20M\
    ultiCollaborationsResponse\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xe9\x13\x08\
    #\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xea\x13\x02(\n\r\n\x05\x04\x19\x02\0\
    \x06\x12\x04\xea\x13\x02\x1c\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xea\x13\
    \x1d#\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xea\x13&'\n\x0c\n\x04\x04\x19\
    \x02\x01\x12\x04\xeb\x13\x02[\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xeb\
    \x13\x02\n\n\r\n\x05\x04\x19\x02\x01\x06\x12\x04\xeb\x13\x0b\x18\n\r\n\
    \x05\x04\x19\x02\x01\x01\x12\x04\xeb\x13\x19'\n\r\n\x05\x04\x19\x02\x01\
    \x03\x12\x04\xeb\x13*+\n\r\n\x05\x04\x19\x02\x01\x08\x12\x04\xeb\x13,Z\n\
    \x10\n\x08\x04\x19\x02\x01\x08\xd0\x86\x03\x12\x04\xeb\x13-Y\n$\n\x02\
    \x04\x1a\x12\x06\x90\x14\0\x92\x14\x01\x1a\x16\x20GetStatusCodeRequest\n\
    \n\x0b\n\x03\x04\x1a\x01\x12\x04\x90\x14\x08\x1c\n\x0c\n\x04\x04\x1a\x02\
    \0\x12\x04\x91\x14\x02\x1c\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\x91\x14\
    \x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x91\x14\t\x17\n\r\n\x05\x04\
    \x1a\x02\0\x03\x12\x04\x91\x14\x1a\x1b\n&\n\x02\x04\x1b\x12\x06\x95\x14\
    \0\x96\x14\x01\x1a\x18\x20ListStatusCodesRequest\n\n\x0b\n\x03\x04\x1b\
    \x01\x12\x04\x95\x14\x08\x1e\n(\n\x02\x04\x1c\x12\x06\x99\x14\0\x9c\x14\
    \x01\x1a\x1a\x20SingleStatusCodeResponse\n\n\x0b\n\x03\x04\x1c\x01\x12\
    \x04\x99\x14\x08\x20\n'\n\x04\x04\x1c\x02\0\x12\x04\x9b\x14\x02(\x1a\x19\
    \x20Status\x20of\x20this\x20request.\n\n\r\n\x05\x04\x1c\x02\0\x06\x12\
    \x04\x9b\x14\x02\x1c\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\x9b\x14\x1d#\n\
    \r\n\x05\x04\x1c\x02\0\x03\x12\x04\x9b\x14&'\n'\n\x02\x04\x1d\x12\x06\
    \x9f\x14\0\xa2\x14\x01\x1a\x19\x20MultiStatusCodeResponse\n\n\x0b\n\x03\
    \x04\x1d\x01\x12\x04\x9f\x14\x08\x1f\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\
    \xa0\x14\x02(\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xa0\x14\x02\x1c\n\r\n\
    \x05\x04\x1d\x02\0\x01\x12\x04\xa0\x14\x1d#\n\r\n\x05\x04\x1d\x02\0\x03\
    \x12\x04\xa0\x14&'\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xa1\x14\x023\n\r\
    \n\x05\x04\x1d\x02\x01\x04\x12\x04\xa1\x14\x02\n\n\r\n\x05\x04\x1d\x02\
    \x01\x06\x12\x04\xa1\x14\x0b%\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xa1\
    \x14&.\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xa1\x1412\n!\n\x02\x04\x1e\
    \x12\x06\xa5\x14\0\xa9\x14\x01\x1a\x13\x20GetConceptRequest\n\n\x0b\n\
    \x03\x04\x1e\x01\x12\x04\xa5\x14\x08\x19\n\x0c\n\x04\x04\x1e\x02\0\x12\
    \x04\xa6\x14\x02,\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xa6\x14\x02\x1b\n\
    \r\n\x05\x04\x1e\x02\0\x01\x12\x04\xa6\x14\x1c'\n\r\n\x05\x04\x1e\x02\0\
    \x03\x12\x04\xa6\x14*+\n!\n\x04\x04\x1e\x02\x01\x12\x04\xa8\x14\x02\x18\
    \x1a\x13\x20The\x20concept's\x20id.\n\n\r\n\x05\x04\x1e\x02\x01\x05\x12\
    \x04\xa8\x14\x02\x08\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xa8\x14\t\x13\
    \n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xa8\x14\x16\x17\n#\n\x02\x04\x1f\
    \x12\x06\xac\x14\0\xb4\x14\x01\x1a\x15\x20ListConceptsRequest\n\n\x0b\n\
    \x03\x04\x1f\x01\x12\x04\xac\x14\x08\x1b\n\x0c\n\x04\x04\x1f\x02\0\x12\
    \x04\xad\x14\x02,\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xad\x14\x02\x1b\n\
    \r\n\x05\x04\x1f\x02\0\x01\x12\x04\xad\x14\x1c'\n\r\n\x05\x04\x1f\x02\0\
    \x03\x12\x04\xad\x14*+\n~\n\x04\x04\x1f\x02\x01\x12\x04\xb0\x14\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xb0\
    \x14\x02\x08\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xb0\x14\t\r\n\r\n\x05\
    \x04\x1f\x02\x01\x03\x12\x04\xb0\x14\x10\x11\nu\n\x04\x04\x1f\x02\x02\
    \x12\x04\xb3\x14\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04\x1f\x02\x02\
    \x05\x12\x04\xb3\x14\x02\x08\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xb3\
    \x14\t\x11\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xb3\x14\x14\x15\n+\n\
    \x02\x04\x20\x12\x06\xb7\x14\0\xbf\x14\x01\x1a\x1d\x20PostConceptsSearch\
    esRequest\n\n\x0b\n\x03\x04\x20\x01\x12\x04\xb7\x14\x08#\n6\n\x04\x04\
    \x20\x02\0\x12\x04\xb9\x14\x02,\x1a(\x20Ids\x20present\x20in\x20the\x20u\
    rl\x20of\x20the\x20request.\n\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\xb9\
    \x14\x02\x1b\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xb9\x14\x1c'\n\r\n\x05\
    \x04\x20\x02\0\x03\x12\x04\xb9\x14*+\n(\n\x04\x04\x20\x02\x01\x12\x04\
    \xbb\x14\x02!\x1a\x1a\x20The\x20body\x20of\x20the\x20request.\n\n\r\n\
    \x05\x04\x20\x02\x01\x06\x12\x04\xbb\x14\x02\x0e\n\r\n\x05\x04\x20\x02\
    \x01\x01\x12\x04\xbb\x14\x0f\x1c\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\
    \xbb\x14\x1f\x20\n]\n\x04\x04\x20\x02\x02\x12\x04\xbe\x14\x02\x1c\x1aO\
    \x20Pagination\x20parameters\x20here\x20since\x20there\x20are\x20no\x20u\
    rl\x20args\x20in\x20this\n\x20POST\x20request.\n\n\r\n\x05\x04\x20\x02\
    \x02\x06\x12\x04\xbe\x14\x02\x0c\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\
    \xbe\x14\r\x17\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xbe\x14\x1a\x1b\n#\
    \n\x02\x04!\x12\x06\xc2\x14\0\xc6\x14\x01\x1a\x15\x20PostConceptsRequest\
    \n\n\x0b\n\x03\x04!\x01\x12\x04\xc2\x14\x08\x1b\n\x0c\n\x04\x04!\x02\0\
    \x12\x04\xc3\x14\x02,\n\r\n\x05\x04!\x02\0\x06\x12\x04\xc3\x14\x02\x1b\n\
    \r\n\x05\x04!\x02\0\x01\x12\x04\xc3\x14\x1c'\n\r\n\x05\x04!\x02\0\x03\
    \x12\x04\xc3\x14*+\n$\n\x04\x04!\x02\x01\x12\x04\xc5\x14\x02\x20\x1a\x16\
    \x20The\x20concepts\x20to\x20add.\n\n\r\n\x05\x04!\x02\x01\x04\x12\x04\
    \xc5\x14\x02\n\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xc5\x14\x0b\x12\n\r\n\
    \x05\x04!\x02\x01\x01\x12\x04\xc5\x14\x13\x1b\n\r\n\x05\x04!\x02\x01\x03\
    \x12\x04\xc5\x14\x1e\x1f\n$\n\x02\x04\"\x12\x06\xc9\x14\0\xd1\x14\x01\
    \x1a\x16\x20PatchConceptsRequest\n\n\x0b\n\x03\x04\"\x01\x12\x04\xc9\x14\
    \x08\x1c\n\x0c\n\x04\x04\"\x02\0\x12\x04\xca\x14\x02,\n\r\n\x05\x04\"\
    \x02\0\x06\x12\x04\xca\x14\x02\x1b\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xca\
    \x14\x1c'\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xca\x14*+\n&\n\x04\x04\"\x02\
    \x01\x12\x04\xcc\x14\x02\x20\x1a\x18\x20The\x20concepts\x20to\x20patch.\
    \n\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xcc\x14\x02\n\n\r\n\x05\x04\"\x02\
    \x01\x06\x12\x04\xcc\x14\x0b\x12\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xcc\
    \x14\x13\x1b\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xcc\x14\x1e\x1f\ni\n\
    \x04\x04\"\x02\x02\x12\x04\xd0\x14\x02\x14\x1a[\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20ony\
    \x20action\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04\"\x02\x02\
    \x05\x12\x04\xd0\x14\x02\x08\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xd0\x14\
    \t\x0f\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xd0\x14\x12\x13\n'\n\x02\x04#\
    \x12\x06\xd4\x14\0\xdc\x14\x01\x1a\x19\x20GetConceptCountsRequest\n\n\
    \x0b\n\x03\x04#\x01\x12\x04\xd4\x14\x08\x1f\n\x0c\n\x04\x04#\x02\0\x12\
    \x04\xd5\x14\x02,\n\r\n\x05\x04#\x02\0\x06\x12\x04\xd5\x14\x02\x1b\n\r\n\
    \x05\x04#\x02\0\x01\x12\x04\xd5\x14\x1c'\n\r\n\x05\x04#\x02\0\x03\x12\
    \x04\xd5\x14*+\n~\n\x04\x04#\x02\x01\x12\x04\xd8\x14\x02\x12\x1ap\x20(op\
    tional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20i\
    s\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defau\
    lts\x20to\x201.\n\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xd8\x14\x02\x08\n\r\
    \n\x05\x04#\x02\x01\x01\x12\x04\xd8\x14\t\r\n\r\n\x05\x04#\x02\x01\x03\
    \x12\x04\xd8\x14\x10\x11\nu\n\x04\x04#\x02\x02\x12\x04\xdb\x14\x02\x16\
    \x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20of\x20result\
    s\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\
    \n\x20to\x20128.\n\n\r\n\x05\x04#\x02\x02\x05\x12\x04\xdb\x14\x02\x08\n\
    \r\n\x05\x04#\x02\x02\x01\x12\x04\xdb\x14\t\x11\n\r\n\x05\x04#\x02\x02\
    \x03\x12\x04\xdb\x14\x14\x15\n%\n\x02\x04$\x12\x06\xdf\x14\0\xe4\x14\x01\
    \x1a\x17\x20SingleConceptResponse\n\n\x0b\n\x03\x04$\x01\x12\x04\xdf\x14\
    \x08\x1d\n$\n\x04\x04$\x02\0\x12\x04\xe1\x14\x02(\x1a\x16\x20The\x20resp\
    onse\x20status.\n\n\r\n\x05\x04$\x02\0\x06\x12\x04\xe1\x14\x02\x1c\n\r\n\
    \x05\x04$\x02\0\x01\x12\x04\xe1\x14\x1d#\n\r\n\x05\x04$\x02\0\x03\x12\
    \x04\xe1\x14&'\n%\n\x04\x04$\x02\x01\x12\x04\xe3\x14\x02\x16\x1a\x17\x20\
    The\x20returned\x20concept.\n\n\r\n\x05\x04$\x02\x01\x06\x12\x04\xe3\x14\
    \x02\t\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xe3\x14\n\x11\n\r\n\x05\x04$\
    \x02\x01\x03\x12\x04\xe3\x14\x14\x15\n$\n\x02\x04%\x12\x06\xe7\x14\0\xec\
    \x14\x01\x1a\x16\x20MultiConceptResponse\n\n\x0b\n\x03\x04%\x01\x12\x04\
    \xe7\x14\x08\x1c\n$\n\x04\x04%\x02\0\x12\x04\xe9\x14\x02(\x1a\x16\x20The\
    \x20response\x20status.\n\n\r\n\x05\x04%\x02\0\x06\x12\x04\xe9\x14\x02\
    \x1c\n\r\n\x05\x04%\x02\0\x01\x12\x04\xe9\x14\x1d#\n\r\n\x05\x04%\x02\0\
    \x03\x12\x04\xe9\x14&'\n&\n\x04\x04%\x02\x01\x12\x04\xeb\x14\x02O\x1a\
    \x18\x20The\x20returned\x20concepts.\n\n\r\n\x05\x04%\x02\x01\x04\x12\
    \x04\xeb\x14\x02\n\n\r\n\x05\x04%\x02\x01\x06\x12\x04\xeb\x14\x0b\x12\n\
    \r\n\x05\x04%\x02\x01\x01\x12\x04\xeb\x14\x13\x1b\n\r\n\x05\x04%\x02\x01\
    \x03\x12\x04\xeb\x14\x1e\x1f\n\r\n\x05\x04%\x02\x01\x08\x12\x04\xeb\x14\
    \x20N\n\x10\n\x08\x04%\x02\x01\x08\xd0\x86\x03\x12\x04\xeb\x14!M\n)\n\
    \x02\x04&\x12\x06\xef\x14\0\xf4\x14\x01\x1a\x1b\x20MultiConceptCountResp\
    onse\n\n\x0b\n\x03\x04&\x01\x12\x04\xef\x14\x08!\n$\n\x04\x04&\x02\0\x12\
    \x04\xf1\x14\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\x05\x04&\
    \x02\0\x06\x12\x04\xf1\x14\x02\x1c\n\r\n\x05\x04&\x02\0\x01\x12\x04\xf1\
    \x14\x1d#\n\r\n\x05\x04&\x02\0\x03\x12\x04\xf1\x14&'\n,\n\x04\x04&\x02\
    \x01\x12\x04\xf3\x14\x02Z\x1a\x1e\x20The\x20returned\x20concept\x20count\
    s.\n\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xf3\x14\x02\n\n\r\n\x05\x04&\x02\
    \x01\x06\x12\x04\xf3\x14\x0b\x17\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xf3\
    \x14\x18&\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xf3\x14)*\n\r\n\x05\x04&\
    \x02\x01\x08\x12\x04\xf3\x14+Y\n\x10\n\x08\x04&\x02\x01\x08\xd0\x86\x03\
    \x12\x04\xf3\x14,X\n`\n\x02\x04'\x12\x06\xf7\x14\0\x99\x15\x01\x1aR\x20G\
    ET\x20all\x20relations\x20such\x20that\x20the\x20concept_id\x20refers\
    \x20to\x20the\x20subject\x20of\x20the\x20relation\n\n\x0b\n\x03\x04'\x01\
    \x12\x04\xf7\x14\x08#\n3\n\x04\x04'\x02\0\x12\x04\xf9\x14\x02,\x1a%\x20T\
    he\x20user_id\x20and\x20app_id\x20information.\n\n\r\n\x05\x04'\x02\0\
    \x06\x12\x04\xf9\x14\x02\x1b\n\r\n\x05\x04'\x02\0\x01\x12\x04\xf9\x14\
    \x1c'\n\r\n\x05\x04'\x02\0\x03\x12\x04\xf9\x14*+\n\xb4\x07\n\x04\x04'\
    \x02\x01\x12\x04\x89\x15\x02\x18\x1a\xa5\x07\x20The\x20subject\x20concep\
    t\x20id\x20in\x20your\x20app\x20to\x20get\x20all\x20the\x20relationships\
    \x20for.\n\x20Leave\x20as\x20an\x20empty\x20string\x20(GET\x20/concepts/\
    relations)\x20to\x20list\x20ALL\x20the\x20relations\x20in\x20the\x20app.\
    \n\n\x20When\x20listing\x20all\x20the\x20relations\x20it\x20will\x20only\
    \x20return\x20one\x20direction\x20of\x20the\x20relationship\n\x20with\
    \x20the\x20predicate\x20acting\x20on\x20the\x20subject\x20and\x20not\x20\
    the\x20inverse\x20like\x20is\x20done\x20when\x20providing\x20a\n\x20conc\
    ept_id\x20so\x20that\x20we\x20can\x20return\x20a\x20reliable\x20page\x20\
    size\x20always.\n\n\x20When\x20providing\x20a\x20concept_id,\x20if\x20a\
    \x20hyponym\x20is\x20present\x20in\x20the\x20DB\x20such\x20as:\n\x20'hon\
    ey'\x20(subject),\x20'hyponym'\x20(predict\x20for\x20\"is\x20a\x20kind\
    \x20of\"),\x20'food'\x20(object)\n\x20then\x20you\x20can\x20list\x20the\
    \x20concept\x20relations\x20for\x20'honey'\x20and\x20get\x20hyponym\x20p\
    redicate\x20with\x20'food'\n\x20object.\n\x20But\x20you\x20can\x20also\
    \x20list\x20the\x20concept\x20relations\x20for\x20'food'\x20and\x20it\
    \x20will\x20return\x20the\x20same\x20hyponym\n\x20relationship\x20with\
    \x20'honey'\x20as\x20subject\x20and\x20'food'\x20as\x20predicate.\n\x20S\
    ynonyms\x20by\x20nature\x20are\x20symmetrical\x20relationships\x20so\x20\
    either\x20side\x20can\x20be\x20the\x20concept_id\x20(subject)\n\x20when\
    \x20listing\x20the\x20relations.\n\n\r\n\x05\x04'\x02\x01\x05\x12\x04\
    \x89\x15\x02\x08\n\r\n\x05\x04'\x02\x01\x01\x12\x04\x89\x15\t\x13\n\r\n\
    \x05\x04'\x02\x01\x03\x12\x04\x89\x15\x16\x17\n\x8f\x01\n\x04\x04'\x02\
    \x02\x12\x04\x8e\x15\x02\x17\x1a\x80\x01\x20This\x20is\x20part\x20of\x20\
    the\x20url\x20so\x20we\x20can\x20extend\x20to\x20multiple\x20link\x20typ\
    es\x20in\x20the\x20future.\n\x20Valid\x20predicates\x20are:\n\x20'hypern\
    yms'\n\x20'hyponyms'\n\n\r\n\x05\x04'\x02\x02\x05\x12\x04\x8e\x15\x02\
    \x08\n\r\n\x05\x04'\x02\x02\x01\x12\x04\x8e\x15\t\x12\n\r\n\x05\x04'\x02\
    \x02\x03\x12\x04\x8e\x15\x15\x16\n\x8b\x02\n\x04\x04'\x02\x03\x12\x04\
    \x92\x15\x02\x20\x1a\xfc\x01\x20If\x20knowledge_graph_id\x20is\x20provid\
    ed\x20then\x20just\x20list\x20relations\x20from\x20that\x20knowledge\x20\
    graph.\n\x20If\x20not\x20provided\x20then\x20list\x20relations\x20from\
    \x20all\x20knowledge\x20graphs\x20including\x20the\x20global\x20one\x20f\
    or\x20this\n\x20app\x20one\x20(ie.\x20knowledge_graph\x20\"\")\x20and\
    \x20any\x20specific\x20ones\x20in\x20the\x20app.\n\n\r\n\x05\x04'\x02\
    \x03\x05\x12\x04\x92\x15\x02\x08\n\r\n\x05\x04'\x02\x03\x01\x12\x04\x92\
    \x15\t\x1b\n\r\n\x05\x04'\x02\x03\x03\x12\x04\x92\x15\x1e\x1f\n~\n\x04\
    \x04'\x02\x04\x12\x04\x95\x15\x02\x12\x1ap\x20(optional\x20URL\x20parame\
    ter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20spli\
    t\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\
    \x05\x04'\x02\x04\x05\x12\x04\x95\x15\x02\x08\n\r\n\x05\x04'\x02\x04\x01\
    \x12\x04\x95\x15\t\r\n\r\n\x05\x04'\x02\x04\x03\x12\x04\x95\x15\x10\x11\
    \nu\n\x04\x04'\x02\x05\x12\x04\x98\x15\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04'\x02\x05\x05\x12\x04\x98\x15\x02\x08\n\r\n\x05\x04'\x02\x05\x01\
    \x12\x04\x98\x15\t\x11\n\r\n\x05\x04'\x02\x05\x03\x12\x04\x98\x15\x14\
    \x15\n*\n\x02\x04(\x12\x06\x9c\x15\0\xa3\x15\x01\x1a\x1c\x20POST\x20new\
    \x20concept\x20relations\n\n\x0b\n\x03\x04(\x01\x12\x04\x9c\x15\x08#\n3\
    \n\x04\x04(\x02\0\x12\x04\x9e\x15\x02,\x1a%\x20The\x20user_id\x20and\x20\
    app_id\x20information.\n\n\r\n\x05\x04(\x02\0\x06\x12\x04\x9e\x15\x02\
    \x1b\n\r\n\x05\x04(\x02\0\x01\x12\x04\x9e\x15\x1c'\n\r\n\x05\x04(\x02\0\
    \x03\x12\x04\x9e\x15*+\nI\n\x04\x04(\x02\x01\x12\x04\xa0\x15\x02\x18\x1a\
    ;\x20The\x20subject\x20concept\x20id\x20you're\x20going\x20to\x20add\x20\
    relations\x20for.\n\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xa0\x15\x02\x08\n\
    \r\n\x05\x04(\x02\x01\x01\x12\x04\xa0\x15\t\x13\n\r\n\x05\x04(\x02\x01\
    \x03\x12\x04\xa0\x15\x16\x17\n6\n\x04\x04(\x02\x02\x12\x04\xa2\x15\x021\
    \x1a(\x20The\x20relationships\x20you're\x20going\x20to\x20add.\n\n\r\n\
    \x05\x04(\x02\x02\x04\x12\x04\xa2\x15\x02\n\n\r\n\x05\x04(\x02\x02\x06\
    \x12\x04\xa2\x15\x0b\x1a\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xa2\x15\x1b,\
    \n\r\n\x05\x04(\x02\x02\x03\x12\x04\xa2\x15/0\n(\n\x02\x04)\x12\x06\xa6\
    \x15\0\xad\x15\x01\x1a\x1a\x20DELETE\x20concept\x20relations\n\n\x0b\n\
    \x03\x04)\x01\x12\x04\xa6\x15\x08%\n3\n\x04\x04)\x02\0\x12\x04\xa8\x15\
    \x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20information.\n\n\r\n\
    \x05\x04)\x02\0\x06\x12\x04\xa8\x15\x02\x1b\n\r\n\x05\x04)\x02\0\x01\x12\
    \x04\xa8\x15\x1c'\n\r\n\x05\x04)\x02\0\x03\x12\x04\xa8\x15*+\n7\n\x04\
    \x04)\x02\x01\x12\x04\xaa\x15\x02\x18\x1a)\x20The\x20concept\x20to\x20de\
    lete\x20relationship\x20for.\n\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xaa\
    \x15\x02\x08\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xaa\x15\t\x13\n\r\n\x05\
    \x04)\x02\x01\x03\x12\x04\xaa\x15\x16\x17\n7\n\x04\x04)\x02\x02\x12\x04\
    \xac\x15\x02\x1a\x1a)\x20The\x20concept\x20relationship\x20ids\x20to\x20\
    delete.\n\n\r\n\x05\x04)\x02\x02\x04\x12\x04\xac\x15\x02\n\n\r\n\x05\x04\
    )\x02\x02\x05\x12\x04\xac\x15\x0b\x11\n\r\n\x05\x04)\x02\x02\x01\x12\x04\
    \xac\x15\x12\x15\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xac\x15\x18\x19\n(\n\
    \x02\x04*\x12\x06\xb0\x15\0\xb3\x15\x01\x1a\x1a\x20GET\x20all\x20knowled\
    ge\x20graphs\n\n\x0b\n\x03\x04*\x01\x12\x04\xb0\x15\x08\"\n3\n\x04\x04*\
    \x02\0\x12\x04\xb2\x15\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20i\
    nformation.\n\n\r\n\x05\x04*\x02\0\x06\x12\x04\xb2\x15\x02\x1b\n\r\n\x05\
    \x04*\x02\0\x01\x12\x04\xb2\x15\x1c'\n\r\n\x05\x04*\x02\0\x03\x12\x04\
    \xb2\x15*+\n)\n\x02\x04+\x12\x06\xb6\x15\0\xba\x15\x01\x1a\x1b\x20POST\
    \x20new\x20knowledge\x20graphs\n\n\x0b\n\x03\x04+\x01\x12\x04\xb6\x15\
    \x08\"\n3\n\x04\x04+\x02\0\x12\x04\xb8\x15\x02,\x1a%\x20The\x20user_id\
    \x20and\x20app_id\x20information.\n\n\r\n\x05\x04+\x02\0\x06\x12\x04\xb8\
    \x15\x02\x1b\n\r\n\x05\x04+\x02\0\x01\x12\x04\xb8\x15\x1c'\n\r\n\x05\x04\
    +\x02\0\x03\x12\x04\xb8\x15*+\n\x0c\n\x04\x04+\x02\x01\x12\x04\xb9\x15\
    \x02/\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xb9\x15\x02\n\n\r\n\x05\x04+\
    \x02\x01\x06\x12\x04\xb9\x15\x0b\x19\n\r\n\x05\x04+\x02\x01\x01\x12\x04\
    \xb9\x15\x1a*\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xb9\x15-.\n*\n\x02\x04,\
    \x12\x06\xbf\x15\0\xc4\x15\x01\x1a\x1c\x20Start\x20concept\x20mapping\
    \x20jobs\n\n\x0b\n\x03\x04,\x01\x12\x04\xbf\x15\x08%\n3\n\x04\x04,\x02\0\
    \x12\x04\xc1\x15\x02,\x1a%\x20The\x20user_id\x20and\x20app_id\x20informa\
    tion.\n\n\r\n\x05\x04,\x02\0\x06\x12\x04\xc1\x15\x02\x1b\n\r\n\x05\x04,\
    \x02\0\x01\x12\x04\xc1\x15\x1c'\n\r\n\x05\x04,\x02\0\x03\x12\x04\xc1\x15\
    *+\n?\n\x04\x04,\x02\x01\x12\x04\xc3\x15\x026\x1a1\x20The\x20concept\x20\
    mapping\x20jobs\x20that\x20are\x20being\x20started\n\n\r\n\x05\x04,\x02\
    \x01\x04\x12\x04\xc3\x15\x02\n\n\r\n\x05\x04,\x02\x01\x06\x12\x04\xc3\
    \x15\x0b\x1c\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xc3\x15\x1d1\n\r\n\x05\
    \x04,\x02\x01\x03\x12\x04\xc3\x1545\n,\n\x02\x04-\x12\x06\xc8\x15\0\xcd\
    \x15\x01\x1a\x1e\x20MultiConceptRelationResponse\n\n\x0b\n\x03\x04-\x01\
    \x12\x04\xc8\x15\x08$\n$\n\x04\x04-\x02\0\x12\x04\xca\x15\x02(\x1a\x16\
    \x20The\x20response\x20status.\n\n\r\n\x05\x04-\x02\0\x06\x12\x04\xca\
    \x15\x02\x1c\n\r\n\x05\x04-\x02\0\x01\x12\x04\xca\x15\x1d#\n\r\n\x05\x04\
    -\x02\0\x03\x12\x04\xca\x15&'\n/\n\x04\x04-\x02\x01\x12\x04\xcc\x15\x02`\
    \x1a!\x20The\x20returned\x20concept\x20relations.\n\n\r\n\x05\x04-\x02\
    \x01\x04\x12\x04\xcc\x15\x02\n\n\r\n\x05\x04-\x02\x01\x06\x12\x04\xcc\
    \x15\x0b\x1a\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xcc\x15\x1b,\n\r\n\x05\
    \x04-\x02\x01\x03\x12\x04\xcc\x15/0\n\r\n\x05\x04-\x02\x01\x08\x12\x04\
    \xcc\x151_\n\x10\n\x08\x04-\x02\x01\x08\xd0\x86\x03\x12\x04\xcc\x152^\n+\
    \n\x02\x04.\x12\x06\xd1\x15\0\xd6\x15\x01\x1a\x1d\x20MultiKnowledgeGraph\
    Response\n\n\x0b\n\x03\x04.\x01\x12\x04\xd1\x15\x08#\n$\n\x04\x04.\x02\0\
    \x12\x04\xd3\x15\x02(\x1a\x16\x20The\x20response\x20status.\n\n\r\n\x05\
    \x04.\x02\0\x06\x12\x04\xd3\x15\x02\x1c\n\r\n\x05\x04.\x02\0\x01\x12\x04\
    \xd3\x15\x1d#\n\r\n\x05\x04.\x02\0\x03\x12\x04\xd3\x15&'\n.\n\x04\x04.\
    \x02\x01\x12\x04\xd5\x15\x02^\x1a\x20\x20The\x20returned\x20knowledge\
    \x20graphs.\n\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xd5\x15\x02\n\n\r\n\x05\
    \x04.\x02\x01\x06\x12\x04\xd5\x15\x0b\x19\n\r\n\x05\x04.\x02\x01\x01\x12\
    \x04\xd5\x15\x1a*\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xd5\x15-.\n\r\n\x05\
    \x04.\x02\x01\x08\x12\x04\xd5\x15/]\n\x10\n\x08\x04.\x02\x01\x08\xd0\x86\
    \x03\x12\x04\xd5\x150\\\n.\n\x02\x04/\x12\x06\xdc\x15\0\xe1\x15\x01\x1a\
    \x20\x20MultiConceptMappingJobResponse\n\n\x0b\n\x03\x04/\x01\x12\x04\
    \xdc\x15\x08&\n$\n\x04\x04/\x02\0\x12\x04\xde\x15\x02(\x1a\x16\x20The\
    \x20response\x20status.\n\n\r\n\x05\x04/\x02\0\x06\x12\x04\xde\x15\x02\
    \x1c\n\r\n\x05\x04/\x02\0\x01\x12\x04\xde\x15\x1d#\n\r\n\x05\x04/\x02\0\
    \x03\x12\x04\xde\x15&'\n=\n\x04\x04/\x02\x01\x12\x04\xe0\x15\x02\x1a\x1a\
    /\x20The\x20ids\x20of\x20the\x20concept\x20mapping\x20jobs\x20underway.\
    \n\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xe0\x15\x02\n\n\r\n\x05\x04/\x02\
    \x01\x05\x12\x04\xe0\x15\x0b\x11\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xe0\
    \x15\x12\x15\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xe0\x15\x18\x19\nB\n\x02\
    \x040\x12\x06\xe4\x15\0\xe9\x15\x01\x1a4\x20GET\x20single\x20concept\x20\
    language\x20for\x20the\x20given\x20concept.\n\n\x0b\n\x03\x040\x01\x12\
    \x04\xe4\x15\x08!\n\x0c\n\x04\x040\x02\0\x12\x04\xe5\x15\x02,\n\r\n\x05\
    \x040\x02\0\x06\x12\x04\xe5\x15\x02\x1b\n\r\n\x05\x040\x02\0\x01\x12\x04\
    \xe5\x15\x1c'\n\r\n\x05\x040\x02\0\x03\x12\x04\xe5\x15*+\n\x0c\n\x04\x04\
    0\x02\x01\x12\x04\xe6\x15\x02\x18\n\r\n\x05\x040\x02\x01\x05\x12\x04\xe6\
    \x15\x02\x08\n\r\n\x05\x040\x02\x01\x01\x12\x04\xe6\x15\t\x13\n\r\n\x05\
    \x040\x02\x01\x03\x12\x04\xe6\x15\x16\x17\n0\n\x04\x040\x02\x02\x12\x04\
    \xe8\x15\x02\x16\x1a\"\x20This\x20is\x20the\x20language\x20identifier.\n\
    \n\r\n\x05\x040\x02\x02\x05\x12\x04\xe8\x15\x02\x08\n\r\n\x05\x040\x02\
    \x02\x01\x12\x04\xe8\x15\t\x11\n\r\n\x05\x040\x02\x02\x03\x12\x04\xe8\
    \x15\x14\x15\nF\n\x02\x041\x12\x06\xec\x15\0\xf5\x15\x01\x1a8\x20List\
    \x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20concept.\
    \n\n\x0b\n\x03\x041\x01\x12\x04\xec\x15\x08#\n\x0c\n\x04\x041\x02\0\x12\
    \x04\xed\x15\x02,\n\r\n\x05\x041\x02\0\x06\x12\x04\xed\x15\x02\x1b\n\r\n\
    \x05\x041\x02\0\x01\x12\x04\xed\x15\x1c'\n\r\n\x05\x041\x02\0\x03\x12\
    \x04\xed\x15*+\n\x0c\n\x04\x041\x02\x01\x12\x04\xee\x15\x02\x18\n\r\n\
    \x05\x041\x02\x01\x05\x12\x04\xee\x15\x02\x08\n\r\n\x05\x041\x02\x01\x01\
    \x12\x04\xee\x15\t\x13\n\r\n\x05\x041\x02\x01\x03\x12\x04\xee\x15\x16\
    \x17\n~\n\x04\x041\x02\x02\x12\x04\xf1\x15\x02\x12\x1ap\x20(optional\x20\
    URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\
    \x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\
    \x201.\n\n\r\n\x05\x041\x02\x02\x05\x12\x04\xf1\x15\x02\x08\n\r\n\x05\
    \x041\x02\x02\x01\x12\x04\xf1\x15\t\r\n\r\n\x05\x041\x02\x02\x03\x12\x04\
    \xf1\x15\x10\x11\nu\n\x04\x041\x02\x03\x12\x04\xf4\x15\x02\x16\x1ag\x20(\
    optional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\
    \x20will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\
    \x20128.\n\n\r\n\x05\x041\x02\x03\x05\x12\x04\xf4\x15\x02\x08\n\r\n\x05\
    \x041\x02\x03\x01\x12\x04\xf4\x15\t\x11\n\r\n\x05\x041\x02\x03\x03\x12\
    \x04\xf4\x15\x14\x15\nG\n\x02\x042\x12\x06\xf8\x15\0\xfe\x15\x01\x1a9\
    \x20PATCH\x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20\
    concept.\n\n\x0b\n\x03\x042\x01\x12\x04\xf8\x15\x08$\n\x0c\n\x04\x042\
    \x02\0\x12\x04\xf9\x15\x02,\n\r\n\x05\x042\x02\0\x06\x12\x04\xf9\x15\x02\
    \x1b\n\r\n\x05\x042\x02\0\x01\x12\x04\xf9\x15\x1c'\n\r\n\x05\x042\x02\0\
    \x03\x12\x04\xf9\x15*+\n\x0c\n\x04\x042\x02\x01\x12\x04\xfa\x15\x02\x18\
    \n\r\n\x05\x042\x02\x01\x05\x12\x04\xfa\x15\x02\x08\n\r\n\x05\x042\x02\
    \x01\x01\x12\x04\xfa\x15\t\x13\n\r\n\x05\x042\x02\x01\x03\x12\x04\xfa\
    \x15\x16\x17\n\x0c\n\x04\x042\x02\x02\x12\x04\xfb\x15\x021\n\r\n\x05\x04\
    2\x02\x02\x04\x12\x04\xfb\x15\x02\n\n\r\n\x05\x042\x02\x02\x06\x12\x04\
    \xfb\x15\x0b\x1a\n\r\n\x05\x042\x02\x02\x01\x12\x04\xfb\x15\x1b,\n\r\n\
    \x05\x042\x02\x02\x03\x12\x04\xfb\x15/0\nD\n\x04\x042\x02\x03\x12\x04\
    \xfd\x15\x02\x14\x1a6\x20The\x20action\x20to\x20perform\x20with\x20the\
    \x20objects\x20in\x20the\x20PATCH.\n\n\r\n\x05\x042\x02\x03\x05\x12\x04\
    \xfd\x15\x02\x08\n\r\n\x05\x042\x02\x03\x01\x12\x04\xfd\x15\t\x0f\n\r\n\
    \x05\x042\x02\x03\x03\x12\x04\xfd\x15\x12\x13\n\xb9\x04\n\x02\x043\x12\
    \x06\x94\x16\0\x98\x16\x01\x1a8\x20POST\x20multiple\x20concept\x20langua\
    ges\x20for\x20the\x20given\x20concept.\n2\xeb\x01\x20//\x20DELETE\x20mul\
    tiple\x20concept\x20languages\x20for\x20the\x20given\x20concept.\n\x20me\
    ssage\x20DeleteConceptLanguageRequest\x20{\n\x20\x20\x20clarifai.api.Use\
    rAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20string\x20concept_id\
    \x20=\x202;\n\x20\x20\x20//\x20The\x20language\x20code\x20to\x20delete.\
    \n\x20\x20\x20string\x20language\x20=\x203;\n\x20}\n2\x82\x02\x20//\x20D\
    ELETE\x20multiple\x20concept\x20languages\x20for\x20the\x20given\x20conc\
    ept.\n\x20message\x20DeleteConceptLanguagesRequest\x20{\n\x20\x20\x20cla\
    rifai.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20string\x20\
    concept_id\x20=\x202;\n\x20\x20\x20//\x20The\x20language\x20code(s)\x20t\
    o\x20delete.\n\x20\x20\x20string\x20ids\x20=\x203;\n\x20\x20\x20bool\x20\
    delete_all\x20=\x204;\n\x20}\n\n\x0b\n\x03\x043\x01\x12\x04\x94\x16\x08#\
    \n\x0c\n\x04\x043\x02\0\x12\x04\x95\x16\x02,\n\r\n\x05\x043\x02\0\x06\
    \x12\x04\x95\x16\x02\x1b\n\r\n\x05\x043\x02\0\x01\x12\x04\x95\x16\x1c'\n\
    \r\n\x05\x043\x02\0\x03\x12\x04\x95\x16*+\n\x0c\n\x04\x043\x02\x01\x12\
    \x04\x96\x16\x02\x18\n\r\n\x05\x043\x02\x01\x05\x12\x04\x96\x16\x02\x08\
    \n\r\n\x05\x043\x02\x01\x01\x12\x04\x96\x16\t\x13\n\r\n\x05\x043\x02\x01\
    \x03\x12\x04\x96\x16\x16\x17\n\x0c\n\x04\x043\x02\x02\x12\x04\x97\x16\
    \x021\n\r\n\x05\x043\x02\x02\x04\x12\x04\x97\x16\x02\n\n\r\n\x05\x043\
    \x02\x02\x06\x12\x04\x97\x16\x0b\x1a\n\r\n\x05\x043\x02\x02\x01\x12\x04\
    \x97\x16\x1b,\n\r\n\x05\x043\x02\x02\x03\x12\x04\x97\x16/0\n-\n\x02\x044\
    \x12\x06\x9b\x16\0\x9e\x16\x01\x1a\x1f\x20SingleConceptLanguageResponse\
    \n\n\x0b\n\x03\x044\x01\x12\x04\x9b\x16\x08%\n\x0c\n\x04\x044\x02\0\x12\
    \x04\x9c\x16\x02(\n\r\n\x05\x044\x02\0\x06\x12\x04\x9c\x16\x02\x1c\n\r\n\
    \x05\x044\x02\0\x01\x12\x04\x9c\x16\x1d#\n\r\n\x05\x044\x02\0\x03\x12\
    \x04\x9c\x16&'\n\x0c\n\x04\x044\x02\x01\x12\x04\x9d\x16\x02'\n\r\n\x05\
    \x044\x02\x01\x06\x12\x04\x9d\x16\x02\x11\n\r\n\x05\x044\x02\x01\x01\x12\
    \x04\x9d\x16\x12\"\n\r\n\x05\x044\x02\x01\x03\x12\x04\x9d\x16%&\n,\n\x02\
    \x045\x12\x06\xa1\x16\0\xa4\x16\x01\x1a\x1e\x20MultiConceptLanguageRespo\
    nse\n\n\x0b\n\x03\x045\x01\x12\x04\xa1\x16\x08$\n\x0c\n\x04\x045\x02\0\
    \x12\x04\xa2\x16\x02(\n\r\n\x05\x045\x02\0\x06\x12\x04\xa2\x16\x02\x1c\n\
    \r\n\x05\x045\x02\0\x01\x12\x04\xa2\x16\x1d#\n\r\n\x05\x045\x02\0\x03\
    \x12\x04\xa2\x16&'\n\x0c\n\x04\x045\x02\x01\x12\x04\xa3\x16\x02`\n\r\n\
    \x05\x045\x02\x01\x04\x12\x04\xa3\x16\x02\n\n\r\n\x05\x045\x02\x01\x06\
    \x12\x04\xa3\x16\x0b\x1a\n\r\n\x05\x045\x02\x01\x01\x12\x04\xa3\x16\x1b,\
    \n\r\n\x05\x045\x02\x01\x03\x12\x04\xa3\x16/0\n\r\n\x05\x045\x02\x01\x08\
    \x12\x04\xa3\x161_\n\x10\n\x08\x045\x02\x01\x08\xd0\x86\x03\x12\x04\xa3\
    \x162^\n\x1f\n\x02\x046\x12\x06\xac\x16\0\xaf\x16\x01\x1a\x11\x20GetInpu\
    tRequest\n\n\x0b\n\x03\x046\x01\x12\x04\xac\x16\x08\x17\n\x0c\n\x04\x046\
    \x02\0\x12\x04\xad\x16\x02,\n\r\n\x05\x046\x02\0\x06\x12\x04\xad\x16\x02\
    \x1b\n\r\n\x05\x046\x02\0\x01\x12\x04\xad\x16\x1c'\n\r\n\x05\x046\x02\0\
    \x03\x12\x04\xad\x16*+\n\x0c\n\x04\x046\x02\x01\x12\x04\xae\x16\x02\x16\
    \n\r\n\x05\x046\x02\x01\x05\x12\x04\xae\x16\x02\x08\n\r\n\x05\x046\x02\
    \x01\x01\x12\x04\xae\x16\t\x11\n\r\n\x05\x046\x02\x01\x03\x12\x04\xae\
    \x16\x14\x15\n&\n\x02\x047\x12\x06\xb2\x16\0\xb7\x16\x01\x1a\x18\x20GetI\
    nputSamplesRequest\n\n\x0b\n\x03\x047\x01\x12\x04\xb2\x16\x08\x1e\n\x0c\
    \n\x04\x047\x02\0\x12\x04\xb3\x16\x02,\n\r\n\x05\x047\x02\0\x06\x12\x04\
    \xb3\x16\x02\x1b\n\r\n\x05\x047\x02\0\x01\x12\x04\xb3\x16\x1c'\n\r\n\x05\
    \x047\x02\0\x03\x12\x04\xb3\x16*+\n\x0c\n\x04\x047\x02\x01\x12\x04\xb4\
    \x16\x02\x15\n\r\n\x05\x047\x02\x01\x05\x12\x04\xb4\x16\x02\x08\n\r\n\
    \x05\x047\x02\x01\x01\x12\x04\xb4\x16\t\x10\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\xb4\x16\x13\x14\nN\n\x04\x047\x02\x02\x12\x04\xb6\x16\x02\x1f\
    \x1a@\x20URL\x20param.\x20If\x20zero\x20ids\x20provided,\x20returns\x20f\
    or\x20all\x20task\x20labelers\n\n\r\n\x05\x047\x02\x02\x04\x12\x04\xb6\
    \x16\x02\n\n\r\n\x05\x047\x02\x02\x05\x12\x04\xb6\x16\x0b\x11\n\r\n\x05\
    \x047\x02\x02\x01\x12\x04\xb6\x16\x12\x1a\n\r\n\x05\x047\x02\x02\x03\x12\
    \x04\xb6\x16\x1d\x1e\n!\n\x02\x048\x12\x06\xba\x16\0\xc7\x16\x01\x1a\x13\
    \x20ListInputsRequest\n\n\x0b\n\x03\x048\x01\x12\x04\xba\x16\x08\x19\n\
    \x0c\n\x04\x048\x02\0\x12\x04\xbb\x16\x02,\n\r\n\x05\x048\x02\0\x06\x12\
    \x04\xbb\x16\x02\x1b\n\r\n\x05\x048\x02\0\x01\x12\x04\xbb\x16\x1c'\n\r\n\
    \x05\x048\x02\0\x03\x12\x04\xbb\x16*+\n~\n\x04\x048\x02\x01\x12\x04\xbe\
    \x16\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20nu\
    mber.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20in\
    to\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x048\x02\x01\x05\x12\
    \x04\xbe\x16\x02\x08\n\r\n\x05\x048\x02\x01\x01\x12\x04\xbe\x16\t\r\n\r\
    \n\x05\x048\x02\x01\x03\x12\x04\xbe\x16\x10\x11\nu\n\x04\x048\x02\x02\
    \x12\x04\xc1\x16\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x048\x02\x02\x05\
    \x12\x04\xc1\x16\x02\x08\n\r\n\x05\x048\x02\x02\x01\x12\x04\xc1\x16\t\
    \x11\n\r\n\x05\x048\x02\x02\x03\x12\x04\xc1\x16\x14\x15\n.\n\x04\x048\
    \x02\x03\x12\x04\xc4\x16\x02(\x1a\x20\x20Set\x20status\x20to\x20filter\
    \x20by\x20status\n\n\r\n\x05\x048\x02\x03\x06\x12\x04\xc4\x16\x02\x1c\n\
    \r\n\x05\x048\x02\x03\x01\x12\x04\xc4\x16\x1d#\n\r\n\x05\x048\x02\x03\
    \x03\x12\x04\xc4\x16&'\n\x0c\n\x04\x048\x02\x04\x12\x04\xc6\x16\x02\x1a\
    \n\r\n\x05\x048\x02\x04\x04\x12\x04\xc6\x16\x02\n\n\r\n\x05\x048\x02\x04\
    \x05\x12\x04\xc6\x16\x0b\x11\n\r\n\x05\x048\x02\x04\x01\x12\x04\xc6\x16\
    \x12\x15\n\r\n\x05\x048\x02\x04\x03\x12\x04\xc6\x16\x18\x19\n#\n\x02\x04\
    9\x12\x06\xca\x16\0\xd3\x16\x01\x1a\x15\x20StreamInputsRequest\n\n\x0b\n\
    \x03\x049\x01\x12\x04\xca\x16\x08\x1b\n\x0c\n\x04\x049\x02\0\x12\x04\xcb\
    \x16\x02,\n\r\n\x05\x049\x02\0\x06\x12\x04\xcb\x16\x02\x1b\n\r\n\x05\x04\
    9\x02\0\x01\x12\x04\xcb\x16\x1c'\n\r\n\x05\x049\x02\0\x03\x12\x04\xcb\
    \x16*+\nt\n\x04\x049\x02\x01\x12\x04\xce\x16\x02\x16\x1af\x20(optional\
    \x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\
    \x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x2020.\n\
    \n\r\n\x05\x049\x02\x01\x05\x12\x04\xce\x16\x02\x08\n\r\n\x05\x049\x02\
    \x01\x01\x12\x04\xce\x16\t\x11\n\r\n\x05\x049\x02\x01\x03\x12\x04\xce\
    \x16\x14\x15\n\x0c\n\x04\x049\x02\x02\x12\x04\xcf\x16\x02\x15\n\r\n\x05\
    \x049\x02\x02\x05\x12\x04\xcf\x16\x02\x08\n\r\n\x05\x049\x02\x02\x01\x12\
    \x04\xcf\x16\t\x10\n\r\n\x05\x049\x02\x02\x03\x12\x04\xcf\x16\x13\x14\n\
    \x0c\n\x04\x049\x02\x03\x12\x04\xd2\x16\x02\x16\n\r\n\x05\x049\x02\x03\
    \x05\x12\x04\xd2\x16\x02\x06\n\r\n\x05\x049\x02\x03\x01\x12\x04\xd2\x16\
    \x07\x11\n\r\n\x05\x049\x02\x03\x03\x12\x04\xd2\x16\x14\x15\n!\n\x02\x04\
    :\x12\x06\xd6\x16\0\xdf\x16\x01\x1a\x13\x20PostInputsRequest\n\n\x0b\n\
    \x03\x04:\x01\x12\x04\xd6\x16\x08\x19\n\x0c\n\x04\x04:\x02\0\x12\x04\xd7\
    \x16\x02,\n\r\n\x05\x04:\x02\0\x06\x12\x04\xd7\x16\x02\x1b\n\r\n\x05\x04\
    :\x02\0\x01\x12\x04\xd7\x16\x1c'\n\r\n\x05\x04:\x02\0\x03\x12\x04\xd7\
    \x16*+\nt\n\x04\x04:\x02\x01\x12\x04\xde\x16\x02\x1c\x1af\x20List\x20of\
    \x20inputs\x20to\x20post.\n\x20For\x20each\x20input,\x20the\x20following\
    \x20fields\x20are\x20used:\n\x20*\x20id\n\x20*\x20data\n\x20*\x20dataset\
    _ids\n\n\r\n\x05\x04:\x02\x01\x04\x12\x04\xde\x16\x02\n\n\r\n\x05\x04:\
    \x02\x01\x06\x12\x04\xde\x16\x0b\x10\n\r\n\x05\x04:\x02\x01\x01\x12\x04\
    \xde\x16\x11\x17\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xde\x16\x1a\x1b\n\"\
    \n\x02\x04;\x12\x06\xe6\x16\0\xf2\x16\x01\x1a\x14\x20PatchInputsRequest\
    \n\n\x0b\n\x03\x04;\x01\x12\x04\xe6\x16\x08\x1a\n\x0c\n\x04\x04;\x02\0\
    \x12\x04\xe7\x16\x02,\n\r\n\x05\x04;\x02\0\x06\x12\x04\xe7\x16\x02\x1b\n\
    \r\n\x05\x04;\x02\0\x01\x12\x04\xe7\x16\x1c'\n\r\n\x05\x04;\x02\0\x03\
    \x12\x04\xe7\x16*+\n\x89\x01\n\x04\x04;\x02\x01\x12\x04\xed\x16\x02\x1c\
    \x1a{\x20List\x20of\x20inputs\x20to\x20patch.\n\x20Inputs\x20are\x20iden\
    tified\x20by\x20id\x20field.\n\x20For\x20each\x20input,\x20the\x20follow\
    ing\x20fields\x20are\x20patchable:\n\x20*\x20data\n\n\r\n\x05\x04;\x02\
    \x01\x04\x12\x04\xed\x16\x02\n\n\r\n\x05\x04;\x02\x01\x06\x12\x04\xed\
    \x16\x0b\x10\n\r\n\x05\x04;\x02\x01\x01\x12\x04\xed\x16\x11\x17\n\r\n\
    \x05\x04;\x02\x01\x03\x12\x04\xed\x16\x1a\x1b\n~\n\x04\x04;\x02\x02\x12\
    \x04\xf1\x16\x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\
    \x20patched\x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwr\
    ite',\x20and\x20'remove'\x20are\x20supported\n\n\r\n\x05\x04;\x02\x02\
    \x05\x12\x04\xf1\x16\x02\x08\n\r\n\x05\x04;\x02\x02\x01\x12\x04\xf1\x16\
    \t\x0f\n\r\n\x05\x04;\x02\x02\x03\x12\x04\xf1\x16\x12\x13\n\"\n\x02\x04<\
    \x12\x06\xf5\x16\0\xf8\x16\x01\x1a\x14\x20DeleteInputRequest\n\n\x0b\n\
    \x03\x04<\x01\x12\x04\xf5\x16\x08\x1a\n\x0c\n\x04\x04<\x02\0\x12\x04\xf6\
    \x16\x02,\n\r\n\x05\x04<\x02\0\x06\x12\x04\xf6\x16\x02\x1b\n\r\n\x05\x04\
    <\x02\0\x01\x12\x04\xf6\x16\x1c'\n\r\n\x05\x04<\x02\0\x03\x12\x04\xf6\
    \x16*+\n\x0c\n\x04\x04<\x02\x01\x12\x04\xf7\x16\x02\x16\n\r\n\x05\x04<\
    \x02\x01\x05\x12\x04\xf7\x16\x02\x08\n\r\n\x05\x04<\x02\x01\x01\x12\x04\
    \xf7\x16\t\x11\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xf7\x16\x14\x15\nD\n\
    \x02\x04=\x12\x06\xfb\x16\0\x80\x17\x01\x1a6\x20Request\x20to\x20delete\
    \x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0b\n\x03\
    \x04=\x01\x12\x04\xfb\x16\x08\x1b\n\x0b\n\x03\x04=\t\x12\x04\xfc\x16\x02\
    \r\n\x0c\n\x04\x04=\t\0\x12\x04\xfc\x16\x0b\x0c\n\r\n\x05\x04=\t\0\x01\
    \x12\x04\xfc\x16\x0b\x0c\n\r\n\x05\x04=\t\0\x02\x12\x04\xfc\x16\x0b\x0c\
    \n\x0c\n\x04\x04=\x02\0\x12\x04\xfe\x16\x02,\n\r\n\x05\x04=\x02\0\x06\
    \x12\x04\xfe\x16\x02\x1b\n\r\n\x05\x04=\x02\0\x01\x12\x04\xfe\x16\x1c'\n\
    \r\n\x05\x04=\x02\0\x03\x12\x04\xfe\x16*+\n\x0c\n\x04\x04=\x02\x01\x12\
    \x04\xff\x16\x02\x1a\n\r\n\x05\x04=\x02\x01\x04\x12\x04\xff\x16\x02\n\n\
    \r\n\x05\x04=\x02\x01\x05\x12\x04\xff\x16\x0b\x11\n\r\n\x05\x04=\x02\x01\
    \x01\x12\x04\xff\x16\x12\x15\n\r\n\x05\x04=\x02\x01\x03\x12\x04\xff\x16\
    \x18\x19\n#\n\x02\x04>\x12\x06\x83\x17\0\x86\x17\x01\x1a\x15\x20SingleIn\
    putResponse\n\n\x0b\n\x03\x04>\x01\x12\x04\x83\x17\x08\x1b\n\x0c\n\x04\
    \x04>\x02\0\x12\x04\x84\x17\x02(\n\r\n\x05\x04>\x02\0\x06\x12\x04\x84\
    \x17\x02\x1c\n\r\n\x05\x04>\x02\0\x01\x12\x04\x84\x17\x1d#\n\r\n\x05\x04\
    >\x02\0\x03\x12\x04\x84\x17&'\n\x0c\n\x04\x04>\x02\x01\x12\x04\x85\x17\
    \x02\x12\n\r\n\x05\x04>\x02\x01\x06\x12\x04\x85\x17\x02\x07\n\r\n\x05\
    \x04>\x02\x01\x01\x12\x04\x85\x17\x08\r\n\r\n\x05\x04>\x02\x01\x03\x12\
    \x04\x85\x17\x10\x11\n\"\n\x02\x04?\x12\x06\x89\x17\0\x8d\x17\x01\x1a\
    \x14\x20MultiInputResponse\n\n\x0b\n\x03\x04?\x01\x12\x04\x89\x17\x08\
    \x1a\n\x0c\n\x04\x04?\x02\0\x12\x04\x8b\x17\x02(\n\r\n\x05\x04?\x02\0\
    \x06\x12\x04\x8b\x17\x02\x1c\n\r\n\x05\x04?\x02\0\x01\x12\x04\x8b\x17\
    \x1d#\n\r\n\x05\x04?\x02\0\x03\x12\x04\x8b\x17&'\n\x0c\n\x04\x04?\x02\
    \x01\x12\x04\x8c\x17\x02K\n\r\n\x05\x04?\x02\x01\x04\x12\x04\x8c\x17\x02\
    \n\n\r\n\x05\x04?\x02\x01\x06\x12\x04\x8c\x17\x0b\x10\n\r\n\x05\x04?\x02\
    \x01\x01\x12\x04\x8c\x17\x11\x17\n\r\n\x05\x04?\x02\x01\x03\x12\x04\x8c\
    \x17\x1a\x1b\n\r\n\x05\x04?\x02\x01\x08\x12\x04\x8c\x17\x1cJ\n\x10\n\x08\
    \x04?\x02\x01\x08\xd0\x86\x03\x12\x04\x8c\x17\x1dI\n,\n\x02\x04@\x12\x06\
    \x90\x17\0\x94\x17\x01\x1a\x1e\x20MultiInputAnnotationResponse\n\n\x0b\n\
    \x03\x04@\x01\x12\x04\x90\x17\x08$\n\x0c\n\x04\x04@\x02\0\x12\x04\x92\
    \x17\x02(\n\r\n\x05\x04@\x02\0\x06\x12\x04\x92\x17\x02\x1c\n\r\n\x05\x04\
    @\x02\0\x01\x12\x04\x92\x17\x1d#\n\r\n\x05\x04@\x02\0\x03\x12\x04\x92\
    \x17&'\n\x0c\n\x04\x04@\x02\x01\x12\x04\x93\x17\x02G\n\r\n\x05\x04@\x02\
    \x01\x04\x12\x04\x93\x17\x02\n\n\r\n\x05\x04@\x02\x01\x06\x12\x04\x93\
    \x17\x0b\x0e\n\r\n\x05\x04@\x02\x01\x01\x12\x04\x93\x17\x0f\x13\n\r\n\
    \x05\x04@\x02\x01\x03\x12\x04\x93\x17\x16\x17\n\r\n\x05\x04@\x02\x01\x08\
    \x12\x04\x93\x17\x18F\n\x10\n\x08\x04@\x02\x01\x08\xd0\x86\x03\x12\x04\
    \x93\x17\x19E\n(\n\x02\x04A\x12\x06\x97\x17\0\x9b\x17\x01\x1a\x1a\x20Sin\
    gleInputCountResponse\n\n\x0b\n\x03\x04A\x01\x12\x04\x97\x17\x08\x20\n\
    \x0c\n\x04\x04A\x02\0\x12\x04\x98\x17\x02(\n\r\n\x05\x04A\x02\0\x06\x12\
    \x04\x98\x17\x02\x1c\n\r\n\x05\x04A\x02\0\x01\x12\x04\x98\x17\x1d#\n\r\n\
    \x05\x04A\x02\0\x03\x12\x04\x98\x17&'\n\x0c\n\x04\x04A\x02\x01\x12\x04\
    \x9a\x17\x02\x18\n\r\n\x05\x04A\x02\x01\x06\x12\x04\x9a\x17\x02\x0c\n\r\
    \n\x05\x04A\x02\x01\x01\x12\x04\x9a\x17\r\x13\n\r\n\x05\x04A\x02\x01\x03\
    \x12\x04\x9a\x17\x16\x17\n$\n\x02\x04B\x12\x06\x9e\x17\0\xa0\x17\x01\x1a\
    \x16\x20GetInputCountRequest\n\n\x0b\n\x03\x04B\x01\x12\x04\x9e\x17\x08\
    \x1c\n\x0c\n\x04\x04B\x02\0\x12\x04\x9f\x17\x02,\n\r\n\x05\x04B\x02\0\
    \x06\x12\x04\x9f\x17\x02\x1b\n\r\n\x05\x04B\x02\0\x01\x12\x04\x9f\x17\
    \x1c'\n\r\n\x05\x04B\x02\0\x03\x12\x04\x9f\x17*+\n\xcb\x01\n\x02\x04C\
    \x12\x06\xbc\x17\0\xc4\x17\x01\x1a\xbc\x01//////////////////////////////\
    ////////////////////\n\x20Model\x20prediction\x20related\x20stuff\x20nee\
    ds\x20inputs\x20and\x20produces\x20outputs.\n///////////////////////////\
    ///////////////////////\n\x20Model\x20prediction.\n\n\x0b\n\x03\x04C\x01\
    \x12\x04\xbc\x17\x08\x1f\n\x0c\n\x04\x04C\x02\0\x12\x04\xbd\x17\x02,\n\r\
    \n\x05\x04C\x02\0\x06\x12\x04\xbd\x17\x02\x1b\n\r\n\x05\x04C\x02\0\x01\
    \x12\x04\xbd\x17\x1c'\n\r\n\x05\x04C\x02\0\x03\x12\x04\xbd\x17*+\n\x0c\n\
    \x04\x04C\x02\x01\x12\x04\xbe\x17\x02\x16\n\r\n\x05\x04C\x02\x01\x05\x12\
    \x04\xbe\x17\x02\x08\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xbe\x17\t\x11\n\
    \r\n\x05\x04C\x02\x01\x03\x12\x04\xbe\x17\x14\x15\n\x0c\n\x04\x04C\x02\
    \x02\x12\x04\xbf\x17\x02\x18\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xbf\x17\
    \x02\x08\n\r\n\x05\x04C\x02\x02\x01\x12\x04\xbf\x17\t\x13\n\r\n\x05\x04C\
    \x02\x02\x03\x12\x04\xbf\x17\x16\x17\n\x0c\n\x04\x04C\x02\x03\x12\x04\
    \xc0\x17\x02\x1c\n\r\n\x05\x04C\x02\x03\x04\x12\x04\xc0\x17\x02\n\n\r\n\
    \x05\x04C\x02\x03\x06\x12\x04\xc0\x17\x0b\x10\n\r\n\x05\x04C\x02\x03\x01\
    \x12\x04\xc0\x17\x11\x17\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xc0\x17\x1a\
    \x1b\n\x88\x01\n\x04\x04C\x02\x04\x12\x04\xc3\x17\x02\x12\x1az\x20This\
    \x20allows\x20you\x20to\x20specify\x20config\x20options\x20for\x20the\
    \x20model\x20such\x20as\n\x20the\x20language\x20which\x20appear's\x20in\
    \x20the\x20model's\x20output_info.\n\n\r\n\x05\x04C\x02\x04\x06\x12\x04\
    \xc3\x17\x02\x07\n\r\n\x05\x04C\x02\x04\x01\x12\x04\xc3\x17\x08\r\n\r\n\
    \x05\x04C\x02\x04\x03\x12\x04\xc3\x17\x10\x11\nF\n\x02\x04D\x12\x06\xc7\
    \x17\0\xd1\x17\x01\x1a8\x20Listing\x20the\x20inputs\x20that\x20went\x20i\
    nto\x20training\x20this\x20model.\n\n\x0b\n\x03\x04D\x01\x12\x04\xc7\x17\
    \x08\x1e\n\x0c\n\x04\x04D\x02\0\x12\x04\xc8\x17\x02,\n\r\n\x05\x04D\x02\
    \0\x06\x12\x04\xc8\x17\x02\x1b\n\r\n\x05\x04D\x02\0\x01\x12\x04\xc8\x17\
    \x1c'\n\r\n\x05\x04D\x02\0\x03\x12\x04\xc8\x17*+\n\x0c\n\x04\x04D\x02\
    \x01\x12\x04\xc9\x17\x02\x16\n\r\n\x05\x04D\x02\x01\x05\x12\x04\xc9\x17\
    \x02\x08\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xc9\x17\t\x11\n\r\n\x05\x04D\
    \x02\x01\x03\x12\x04\xc9\x17\x14\x15\n\x0c\n\x04\x04D\x02\x02\x12\x04\
    \xca\x17\x02\x18\n\r\n\x05\x04D\x02\x02\x05\x12\x04\xca\x17\x02\x08\n\r\
    \n\x05\x04D\x02\x02\x01\x12\x04\xca\x17\t\x13\n\r\n\x05\x04D\x02\x02\x03\
    \x12\x04\xca\x17\x16\x17\n~\n\x04\x04D\x02\x03\x12\x04\xcd\x17\x02\x12\
    \x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pag\
    ination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks\
    .\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04D\x02\x03\x05\x12\x04\xcd\x17\
    \x02\x08\n\r\n\x05\x04D\x02\x03\x01\x12\x04\xcd\x17\t\r\n\r\n\x05\x04D\
    \x02\x03\x03\x12\x04\xcd\x17\x10\x11\nu\n\x04\x04D\x02\x04\x12\x04\xd0\
    \x17\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04D\x02\x04\x05\x12\x04\xd0\
    \x17\x02\x08\n\r\n\x05\x04D\x02\x04\x01\x12\x04\xd0\x17\t\x11\n\r\n\x05\
    \x04D\x02\x04\x03\x12\x04\xd0\x17\x14\x15\n\x1d\n\x02\x04E\x12\x06\xd4\
    \x17\0\xd7\x17\x01\x1a\x0f\x20GetKeyRequest\n\n\x0b\n\x03\x04E\x01\x12\
    \x04\xd4\x17\x08\x15\n\x0c\n\x04\x04E\x02\0\x12\x04\xd5\x17\x02,\n\r\n\
    \x05\x04E\x02\0\x06\x12\x04\xd5\x17\x02\x1b\n\r\n\x05\x04E\x02\0\x01\x12\
    \x04\xd5\x17\x1c'\n\r\n\x05\x04E\x02\0\x03\x12\x04\xd5\x17*+\n\x0c\n\x04\
    \x04E\x02\x01\x12\x04\xd6\x17\x02\x14\n\r\n\x05\x04E\x02\x01\x05\x12\x04\
    \xd6\x17\x02\x08\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xd6\x17\t\x0f\n\r\n\
    \x05\x04E\x02\x01\x03\x12\x04\xd6\x17\x12\x13\n\x1f\n\x02\x04F\x12\x06\
    \xda\x17\0\xe2\x17\x01\x1a\x11\x20ListKeysRequest\n\n\x0b\n\x03\x04F\x01\
    \x12\x04\xda\x17\x08\x17\n\x0c\n\x04\x04F\x02\0\x12\x04\xdb\x17\x02,\n\r\
    \n\x05\x04F\x02\0\x06\x12\x04\xdb\x17\x02\x1b\n\r\n\x05\x04F\x02\0\x01\
    \x12\x04\xdb\x17\x1c'\n\r\n\x05\x04F\x02\0\x03\x12\x04\xdb\x17*+\n~\n\
    \x04\x04F\x02\x01\x12\x04\xde\x17\x02\x12\x1ap\x20(optional\x20URL\x20pa\
    rameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20\
    split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\
    \r\n\x05\x04F\x02\x01\x05\x12\x04\xde\x17\x02\x08\n\r\n\x05\x04F\x02\x01\
    \x01\x12\x04\xde\x17\t\r\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xde\x17\x10\
    \x11\nu\n\x04\x04F\x02\x02\x12\x04\xe1\x17\x02\x16\x1ag\x20(optional\x20\
    URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20b\
    e\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\
    \n\x05\x04F\x02\x02\x05\x12\x04\xe1\x17\x02\x08\n\r\n\x05\x04F\x02\x02\
    \x01\x12\x04\xe1\x17\t\x11\n\r\n\x05\x04F\x02\x02\x03\x12\x04\xe1\x17\
    \x14\x15\n\"\n\x02\x04G\x12\x06\xe5\x17\0\xed\x17\x01\x1a\x14\x20ListApp\
    KeysRequest\n\n\x0b\n\x03\x04G\x01\x12\x04\xe5\x17\x08\x1a\n\x0c\n\x04\
    \x04G\x02\0\x12\x04\xe6\x17\x02,\n\r\n\x05\x04G\x02\0\x06\x12\x04\xe6\
    \x17\x02\x1b\n\r\n\x05\x04G\x02\0\x01\x12\x04\xe6\x17\x1c'\n\r\n\x05\x04\
    G\x02\0\x03\x12\x04\xe6\x17*+\n~\n\x04\x04G\x02\x01\x12\x04\xe9\x17\x02\
    \x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\x20number.\
    \x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\x20into\
    \x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04G\x02\x01\x05\x12\
    \x04\xe9\x17\x02\x08\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xe9\x17\t\r\n\r\
    \n\x05\x04G\x02\x01\x03\x12\x04\xe9\x17\x10\x11\nu\n\x04\x04G\x02\x02\
    \x12\x04\xec\x17\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04G\x02\x02\x05\
    \x12\x04\xec\x17\x02\x08\n\r\n\x05\x04G\x02\x02\x01\x12\x04\xec\x17\t\
    \x11\n\r\n\x05\x04G\x02\x02\x03\x12\x04\xec\x17\x14\x15\n\x1f\n\x02\x04H\
    \x12\x06\xf0\x17\0\xf3\x17\x01\x1a\x11\x20PostKeysRequest\n\n\x0b\n\x03\
    \x04H\x01\x12\x04\xf0\x17\x08\x17\n\x0c\n\x04\x04H\x02\0\x12\x04\xf1\x17\
    \x02,\n\r\n\x05\x04H\x02\0\x06\x12\x04\xf1\x17\x02\x1b\n\r\n\x05\x04H\
    \x02\0\x01\x12\x04\xf1\x17\x1c'\n\r\n\x05\x04H\x02\0\x03\x12\x04\xf1\x17\
    *+\n\x0c\n\x04\x04H\x02\x01\x12\x04\xf2\x17\x02\x18\n\r\n\x05\x04H\x02\
    \x01\x04\x12\x04\xf2\x17\x02\n\n\r\n\x05\x04H\x02\x01\x06\x12\x04\xf2\
    \x17\x0b\x0e\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xf2\x17\x0f\x13\n\r\n\
    \x05\x04H\x02\x01\x03\x12\x04\xf2\x17\x16\x17\n\x20\n\x02\x04I\x12\x06\
    \xf6\x17\0\xf9\x17\x01\x1a\x12\x20DeleteKeyRequest\n\n\x0b\n\x03\x04I\
    \x01\x12\x04\xf6\x17\x08\x18\n\x0c\n\x04\x04I\x02\0\x12\x04\xf7\x17\x02,\
    \n\r\n\x05\x04I\x02\0\x06\x12\x04\xf7\x17\x02\x1b\n\r\n\x05\x04I\x02\0\
    \x01\x12\x04\xf7\x17\x1c'\n\r\n\x05\x04I\x02\0\x03\x12\x04\xf7\x17*+\n\
    \x0c\n\x04\x04I\x02\x01\x12\x04\xf8\x17\x02\x14\n\r\n\x05\x04I\x02\x01\
    \x05\x12\x04\xf8\x17\x02\x08\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xf8\x17\
    \t\x0f\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xf8\x17\x12\x13\n\x20\n\x02\
    \x04J\x12\x06\xfc\x17\0\x83\x18\x01\x1a\x12\x20PatchKeysRequest\n\n\x0b\
    \n\x03\x04J\x01\x12\x04\xfc\x17\x08\x18\n\x0c\n\x04\x04J\x02\0\x12\x04\
    \xfd\x17\x02,\n\r\n\x05\x04J\x02\0\x06\x12\x04\xfd\x17\x02\x1b\n\r\n\x05\
    \x04J\x02\0\x01\x12\x04\xfd\x17\x1c'\n\r\n\x05\x04J\x02\0\x03\x12\x04\
    \xfd\x17*+\n\x0c\n\x04\x04J\x02\x01\x12\x04\xfe\x17\x02\x18\n\r\n\x05\
    \x04J\x02\x01\x04\x12\x04\xfe\x17\x02\n\n\r\n\x05\x04J\x02\x01\x06\x12\
    \x04\xfe\x17\x0b\x0e\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xfe\x17\x0f\x13\
    \n\r\n\x05\x04J\x02\x01\x03\x12\x04\xfe\x17\x16\x17\nj\n\x04\x04J\x02\
    \x02\x12\x04\x82\x18\x02\x14\x1a\\\x20The\x20action\x20to\x20perform\x20\
    on\x20the\x20patched\x20objects\n\x20For\x20now\x20only\x20action\x20'ov\
    erwrite'\x20is\x20supported\n\n\r\n\x05\x04J\x02\x02\x05\x12\x04\x82\x18\
    \x02\x08\n\r\n\x05\x04J\x02\x02\x01\x12\x04\x82\x18\t\x0f\n\r\n\x05\x04J\
    \x02\x02\x03\x12\x04\x82\x18\x12\x13\n!\n\x02\x04K\x12\x06\x86\x18\0\x89\
    \x18\x01\x1a\x13\x20SingleKeyResponse\n\n\x0b\n\x03\x04K\x01\x12\x04\x86\
    \x18\x08\x19\n\x0c\n\x04\x04K\x02\0\x12\x04\x87\x18\x02(\n\r\n\x05\x04K\
    \x02\0\x06\x12\x04\x87\x18\x02\x1c\n\r\n\x05\x04K\x02\0\x01\x12\x04\x87\
    \x18\x1d#\n\r\n\x05\x04K\x02\0\x03\x12\x04\x87\x18&'\n\x0c\n\x04\x04K\
    \x02\x01\x12\x04\x88\x18\x02\x0e\n\r\n\x05\x04K\x02\x01\x06\x12\x04\x88\
    \x18\x02\x05\n\r\n\x05\x04K\x02\x01\x01\x12\x04\x88\x18\x06\t\n\r\n\x05\
    \x04K\x02\x01\x03\x12\x04\x88\x18\x0c\r\n\x20\n\x02\x04L\x12\x06\x8c\x18\
    \0\x8f\x18\x01\x1a\x12\x20MultiKeyResponse\n\n\x0b\n\x03\x04L\x01\x12\
    \x04\x8c\x18\x08\x18\n\x0c\n\x04\x04L\x02\0\x12\x04\x8d\x18\x02(\n\r\n\
    \x05\x04L\x02\0\x06\x12\x04\x8d\x18\x02\x1c\n\r\n\x05\x04L\x02\0\x01\x12\
    \x04\x8d\x18\x1d#\n\r\n\x05\x04L\x02\0\x03\x12\x04\x8d\x18&'\n\x0c\n\x04\
    \x04L\x02\x01\x12\x04\x8e\x18\x02G\n\r\n\x05\x04L\x02\x01\x04\x12\x04\
    \x8e\x18\x02\n\n\r\n\x05\x04L\x02\x01\x06\x12\x04\x8e\x18\x0b\x0e\n\r\n\
    \x05\x04L\x02\x01\x01\x12\x04\x8e\x18\x0f\x13\n\r\n\x05\x04L\x02\x01\x03\
    \x12\x04\x8e\x18\x16\x17\n\r\n\x05\x04L\x02\x01\x08\x12\x04\x8e\x18\x18F\
    \n\x10\n\x08\x04L\x02\x01\x08\xd0\x86\x03\x12\x04\x8e\x18\x19E\n\x1f\n\
    \x02\x04M\x12\x06\x9a\x18\0\xa4\x18\x01\x1a\x11\x20GetModelRequest\n\n\
    \x0b\n\x03\x04M\x01\x12\x04\x9a\x18\x08\x17\n\x0c\n\x04\x04M\x02\0\x12\
    \x04\x9b\x18\x02,\n\r\n\x05\x04M\x02\0\x06\x12\x04\x9b\x18\x02\x1b\n\r\n\
    \x05\x04M\x02\0\x01\x12\x04\x9b\x18\x1c'\n\r\n\x05\x04M\x02\0\x03\x12\
    \x04\x9b\x18*+\n\x0c\n\x04\x04M\x02\x01\x12\x04\x9c\x18\x02\x16\n\r\n\
    \x05\x04M\x02\x01\x05\x12\x04\x9c\x18\x02\x08\n\r\n\x05\x04M\x02\x01\x01\
    \x12\x04\x9c\x18\t\x11\n\r\n\x05\x04M\x02\x01\x03\x12\x04\x9c\x18\x14\
    \x15\nw\n\x04\x04M\x02\x02\x12\x04\x9f\x18\x02\x18\x1ai\x20This\x20is\
    \x20included\x20so\x20that\x20we\x20can\x20re-use\x20this\x20request\x20\
    for\x20multiple\n\x20rpcs\x20with\x20and\x20without\x20the\x20version_id\
    .\n\n\r\n\x05\x04M\x02\x02\x05\x12\x04\x9f\x18\x02\x08\n\r\n\x05\x04M\
    \x02\x02\x01\x12\x04\x9f\x18\t\x13\n\r\n\x05\x04M\x02\x02\x03\x12\x04\
    \x9f\x18\x16\x17\n\x0c\n\x04\x04M\x02\x03\x12\x04\xa0\x18\x02\x16\n\r\n\
    \x05\x04M\x02\x03\x05\x12\x04\xa0\x18\x02\x08\n\r\n\x05\x04M\x02\x03\x01\
    \x12\x04\xa0\x18\t\x11\n\r\n\x05\x04M\x02\x03\x03\x12\x04\xa0\x18\x14\
    \x15\n\x0c\n\x04\x04M\x02\x04\x12\x04\xa1\x18\x02\x1a\n\r\n\x05\x04M\x02\
    \x04\x05\x12\x04\xa1\x18\x02\x06\n\r\n\x05\x04M\x02\x04\x01\x12\x04\xa1\
    \x18\x07\x15\n\r\n\x05\x04M\x02\x04\x03\x12\x04\xa1\x18\x18\x19\n\x8b\
    \x01\n\x04\x04M\x02\x05\x12\x04\xa3\x18\x02)\x1a}\x20(optional\x20URL\
    \x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\x20incl\
    uded\x20in\x20the\x20response.\x20Currently\x20supported:\x20all,\x20sta\
    rs,\x20outputs\n\n\r\n\x05\x04M\x02\x05\x04\x12\x04\xa3\x18\x02\n\n\r\n\
    \x05\x04M\x02\x05\x05\x12\x04\xa3\x18\x0b\x11\n\r\n\x05\x04M\x02\x05\x01\
    \x12\x04\xa3\x18\x12#\n\r\n\x05\x04M\x02\x05\x03\x12\x04\xa3\x18&(\n!\n\
    \x02\x04N\x12\x06\xa7\x18\0\xdd\x18\x01\x1a\x13\x20ListModelsRequest\n\n\
    \x0b\n\x03\x04N\x01\x12\x04\xa7\x18\x08\x19\n\x0b\n\x03\x04N\t\x12\x04\
    \xa8\x18\x02\r\n\x0c\n\x04\x04N\t\0\x12\x04\xa8\x18\x0b\x0c\n\r\n\x05\
    \x04N\t\0\x01\x12\x04\xa8\x18\x0b\x0c\n\r\n\x05\x04N\t\0\x02\x12\x04\xa8\
    \x18\x0b\x0c\n\x0c\n\x04\x04N\x02\0\x12\x04\xa9\x18\x02,\n\r\n\x05\x04N\
    \x02\0\x06\x12\x04\xa9\x18\x02\x1b\n\r\n\x05\x04N\x02\0\x01\x12\x04\xa9\
    \x18\x1c'\n\r\n\x05\x04N\x02\0\x03\x12\x04\xa9\x18*+\n~\n\x04\x04N\x02\
    \x01\x12\x04\xac\x18\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20T\
    he\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\
    \x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04\
    N\x02\x01\x05\x12\x04\xac\x18\x02\x08\n\r\n\x05\x04N\x02\x01\x01\x12\x04\
    \xac\x18\t\r\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xac\x18\x10\x11\nu\n\x04\
    \x04N\x02\x02\x12\x04\xaf\x18\x02\x16\x1ag\x20(optional\x20URL\x20parame\
    ter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20containe\
    d\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04N\
    \x02\x02\x05\x12\x04\xaf\x18\x02\x08\n\r\n\x05\x04N\x02\x02\x01\x12\x04\
    \xaf\x18\t\x11\n\r\n\x05\x04N\x02\x02\x03\x12\x04\xaf\x18\x14\x15\no\n\
    \x04\x04N\x02\x03\x12\x04\xb3\x18\x02\x1b\x1aa\x20Sorting\x20options:\n\
    \x20Whether\x20to\x20sort\x20in\x20ascending\x20order.\x20If\x20false,\
    \x20will\x20order\x20in\x20descending\x20order.\n\n\r\n\x05\x04N\x02\x03\
    \x05\x12\x04\xb3\x18\x02\x06\n\r\n\x05\x04N\x02\x03\x01\x12\x04\xb3\x18\
    \x07\x15\n\r\n\x05\x04N\x02\x03\x03\x12\x04\xb3\x18\x18\x1a\n\x0e\n\x04\
    \x04N\x08\0\x12\x06\xb4\x18\x02\xbc\x18\x03\n\r\n\x05\x04N\x08\0\x01\x12\
    \x04\xb4\x18\x08\x0f\n,\n\x04\x04N\x02\x04\x12\x04\xb6\x18\x04\x1b\x1a\
    \x1e\x20Whether\x20to\x20order\x20by\x20the\x20name\n\n\r\n\x05\x04N\x02\
    \x04\x05\x12\x04\xb6\x18\x04\x08\n\r\n\x05\x04N\x02\x04\x01\x12\x04\xb6\
    \x18\t\x15\n\r\n\x05\x04N\x02\x04\x03\x12\x04\xb6\x18\x18\x1a\nA\n\x04\
    \x04N\x02\x05\x12\x04\xb8\x18\x04!\x1a3\x20Whether\x20to\x20order\x20by\
    \x20the\x20number\x20of\x20training\x20inputs\n\n\r\n\x05\x04N\x02\x05\
    \x05\x12\x04\xb8\x18\x04\x08\n\r\n\x05\x04N\x02\x05\x01\x12\x04\xb8\x18\
    \t\x1b\n\r\n\x05\x04N\x02\x05\x03\x12\x04\xb8\x18\x1e\x20\n\x98\x01\n\
    \x04\x04N\x02\x06\x12\x04\xbb\x18\x04\"\x1a\x89\x01\x20Whether\x20to\x20\
    order\x20by\x20the\x20modified_at\x20time\x20of\x20the\x20latest\x20mode\
    l\x20version.\n\x20If\x20neither\x20sort\x20option\x20is\x20set\x20to\
    \x20true,\x20will\x20sort\x20by\x20modified_at.\n\n\r\n\x05\x04N\x02\x06\
    \x05\x12\x04\xbb\x18\x04\x08\n\r\n\x05\x04N\x02\x06\x01\x12\x04\xbb\x18\
    \t\x1c\n\r\n\x05\x04N\x02\x06\x03\x12\x04\xbb\x18\x1f!\n\xd1\x01\n\x04\
    \x04N\x02\x07\x12\x04\xc0\x18\x02\x14\x1a\xc2\x01\x20Filtering\x20option\
    s:\n\x20Query\x20name,\x20description\x20and\x20id\x20fields,\x20that\
    \x20can\x20contain\x20the\x20words\x20in\x20the\x20query\x20string.\x20D\
    oes\x20NOT\x20support\x20wildcards\x20-\x20full\x20words\x20only.\x20Sup\
    ports\x20operators\x20\"OR\"\x20and\x20\"-\"\x20as\x20NOT.\n\n\r\n\x05\
    \x04N\x02\x07\x05\x12\x04\xc0\x18\x02\x08\n\r\n\x05\x04N\x02\x07\x01\x12\
    \x04\xc0\x18\t\x0e\n\r\n\x05\x04N\x02\x07\x03\x12\x04\xc0\x18\x11\x13\n\
    \xb0\x01\n\x04\x04N\x02\x08\x12\x04\xc3\x18\x02&\x1a\xa1\x01\x20Filter\
    \x20by\x20the\x20name,\x20description\x20and\x20id\x20of\x20the\x20model\
    .\x20This\x20supports\x20wildcard\x20queries\x20like\x20\"gen*\"\x20to\
    \x20match\x20\"general\"\x20as\x20an\x20example.\n\x20Deprecated\x20in\
    \x20favor\x20of\x20query\n\n\r\n\x05\x04N\x02\x08\x05\x12\x04\xc3\x18\
    \x02\x08\n\r\n\x05\x04N\x02\x08\x01\x12\x04\xc3\x18\t\r\n\r\n\x05\x04N\
    \x02\x08\x03\x12\x04\xc3\x18\x10\x11\n\r\n\x05\x04N\x02\x08\x08\x12\x04\
    \xc3\x18\x12%\n\x0e\n\x06\x04N\x02\x08\x08\x03\x12\x04\xc3\x18\x13$\nz\n\
    \x04\x04N\x02\t\x12\x04\xc6\x18\x02\x1b\x1al\x20Filter\x20models\x20by\
    \x20the\x20specific\x20model_type_id.\x20See\x20ListModelTypes\x20for\
    \x20the\x20list\x20of\x20ModelType.Id's\n\x20supported.\n\n\r\n\x05\x04N\
    \x02\t\x05\x12\x04\xc6\x18\x02\x08\n\r\n\x05\x04N\x02\t\x01\x12\x04\xc6\
    \x18\t\x16\n\r\n\x05\x04N\x02\t\x03\x12\x04\xc6\x18\x19\x1a\n|\n\x04\x04\
    N\x02\n\x12\x04\xc8\x18\x02\x18\x1an\x20If\x20true,\x20we\x20only\x20ret\
    urn\x20models\x20that\x20have\x20the\x20status\x20MODEL_TRAINED,\x20whic\
    h\x20includes\x20non-trainable\x20model\x20types.\n\n\r\n\x05\x04N\x02\n\
    \x05\x12\x04\xc8\x18\x02\x06\n\r\n\x05\x04N\x02\n\x01\x12\x04\xc8\x18\
    \x07\x13\n\r\n\x05\x04N\x02\n\x03\x12\x04\xc8\x18\x16\x17\n\xb5\x01\n\
    \x04\x04N\x02\x0b\x12\x04\xcb\x18\x02#\x1a\xa6\x01\x20The\x20list\x20of\
    \x20input\x20fields\x20to\x20the\x20model.\n\x20For\x20example,\x20you\
    \x20can\x20specify\x20'image',\x20which\x20will\x20return\x20models\x20t\
    hat\x20make\x20inferences\x20on\x20images\x20like\x20visual-classifier\
    \x20models.\n\n\r\n\x05\x04N\x02\x0b\x04\x12\x04\xcb\x18\x02\n\n\r\n\x05\
    \x04N\x02\x0b\x05\x12\x04\xcb\x18\x0b\x11\n\r\n\x05\x04N\x02\x0b\x01\x12\
    \x04\xcb\x18\x12\x1e\n\r\n\x05\x04N\x02\x0b\x03\x12\x04\xcb\x18!\"\n\x9e\
    \x01\n\x04\x04N\x02\x0c\x12\x04\xce\x18\x02$\x1a\x8f\x01\x20The\x20list\
    \x20of\x20output\x20fields\x20to\x20the\x20model.\n\x20For\x20example,\
    \x20you\x20can\x20specify\x20'regions[...].data.concepts',\x20which\x20w\
    ill\x20return\x20visual-detector\x20models.\n\n\r\n\x05\x04N\x02\x0c\x04\
    \x12\x04\xce\x18\x02\n\n\r\n\x05\x04N\x02\x0c\x05\x12\x04\xce\x18\x0b\
    \x11\n\r\n\x05\x04N\x02\x0c\x01\x12\x04\xce\x18\x12\x1f\n\r\n\x05\x04N\
    \x02\x0c\x03\x12\x04\xce\x18\"#\n:\n\x04\x04N\x02\r\x12\x04\xd0\x18\x02\
    \x16\x1a,\x20Filter\x20by\x20the\x20license\x20of\x20the\x20model\x20ver\
    sion\n\n\r\n\x05\x04N\x02\r\x05\x12\x04\xd0\x18\x02\x08\n\r\n\x05\x04N\
    \x02\r\x01\x12\x04\xd0\x18\t\x10\n\r\n\x05\x04N\x02\r\x03\x12\x04\xd0\
    \x18\x13\x15\nT\n\x04\x04N\x02\x0e\x12\x04\xd2\x18\x02\x1a\x1aF\x20If\
    \x20true,\x20we\x20only\x20return\x20models\x20that\x20are\x20handpicked\
    \x20by\x20clarifai\x20staff\n\n\r\n\x05\x04N\x02\x0e\x05\x12\x04\xd2\x18\
    \x02\x06\n\r\n\x05\x04N\x02\x0e\x01\x12\x04\xd2\x18\x07\x14\n\r\n\x05\
    \x04N\x02\x0e\x03\x12\x04\xd2\x18\x17\x19\nV\n\x04\x04N\x02\x0f\x12\x04\
    \xd4\x18\x02\x19\x1aH\x20If\x20true,\x20we\x20only\x20return\x20models\
    \x20that\x20are\x20starred\x20by\x20the\x20requesting\x20user\n\n\r\n\
    \x05\x04N\x02\x0f\x05\x12\x04\xd4\x18\x02\x06\n\r\n\x05\x04N\x02\x0f\x01\
    \x12\x04\xd4\x18\x07\x13\n\r\n\x05\x04N\x02\x0f\x03\x12\x04\xd4\x18\x16\
    \x18\n1\n\x04\x04N\x02\x10\x12\x04\xd6\x18\x02\x20\x1a#\x20List\x20of\
    \x20toolkit\x20tags\x20to\x20filter\x20by\n\n\r\n\x05\x04N\x02\x10\x04\
    \x12\x04\xd6\x18\x02\n\n\r\n\x05\x04N\x02\x10\x05\x12\x04\xd6\x18\x0b\
    \x11\n\r\n\x05\x04N\x02\x10\x01\x12\x04\xd6\x18\x12\x1a\n\r\n\x05\x04N\
    \x02\x10\x03\x12\x04\xd6\x18\x1d\x1f\n2\n\x04\x04N\x02\x11\x12\x04\xd8\
    \x18\x02!\x1a$\x20List\x20of\x20use_case\x20tags\x20to\x20filter\x20by\n\
    \n\r\n\x05\x04N\x02\x11\x04\x12\x04\xd8\x18\x02\n\n\r\n\x05\x04N\x02\x11\
    \x05\x12\x04\xd8\x18\x0b\x11\n\r\n\x05\x04N\x02\x11\x01\x12\x04\xd8\x18\
    \x12\x1b\n\r\n\x05\x04N\x02\x11\x03\x12\x04\xd8\x18\x1e\x20\n2\n\x04\x04\
    N\x02\x12\x12\x04\xda\x18\x02!\x1a$\x20List\x20of\x20language\x20tags\
    \x20to\x20filter\x20by\n\n\r\n\x05\x04N\x02\x12\x04\x12\x04\xda\x18\x02\
    \n\n\r\n\x05\x04N\x02\x12\x05\x12\x04\xda\x18\x0b\x11\n\r\n\x05\x04N\x02\
    \x12\x01\x12\x04\xda\x18\x12\x1b\n\r\n\x05\x04N\x02\x12\x03\x12\x04\xda\
    \x18\x1e\x20\n\x8b\x01\n\x04\x04N\x02\x13\x12\x04\xdc\x18\x02)\x1a}\x20(\
    optional\x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20t\
    o\x20be\x20included\x20in\x20the\x20response.\x20Currently\x20supported:\
    \x20all,\x20stars,\x20outputs\n\n\r\n\x05\x04N\x02\x13\x04\x12\x04\xdc\
    \x18\x02\n\n\r\n\x05\x04N\x02\x13\x05\x12\x04\xdc\x18\x0b\x11\n\r\n\x05\
    \x04N\x02\x13\x01\x12\x04\xdc\x18\x12#\n\r\n\x05\x04N\x02\x13\x03\x12\
    \x04\xdc\x18&(\n\x0c\n\x02\x04O\x12\x06\xdf\x18\0\xe7\x18\x01\n\x0b\n\
    \x03\x04O\x01\x12\x04\xdf\x18\x08!\n\x0c\n\x04\x04O\x02\0\x12\x04\xe0\
    \x18\x02,\n\r\n\x05\x04O\x02\0\x06\x12\x04\xe0\x18\x02\x1b\n\r\n\x05\x04\
    O\x02\0\x01\x12\x04\xe0\x18\x1c'\n\r\n\x05\x04O\x02\0\x03\x12\x04\xe0\
    \x18*+\n\x0c\n\x04\x04O\x02\x01\x12\x04\xe2\x18\x02\x16\n\r\n\x05\x04O\
    \x02\x01\x05\x12\x04\xe2\x18\x02\x08\n\r\n\x05\x04O\x02\x01\x01\x12\x04\
    \xe2\x18\t\x11\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xe2\x18\x14\x15\n\x0c\
    \n\x04\x04O\x02\x02\x12\x04\xe4\x18\x02\x1f\n\r\n\x05\x04O\x02\x02\x04\
    \x12\x04\xe4\x18\x02\n\n\r\n\x05\x04O\x02\x02\x05\x12\x04\xe4\x18\x0b\
    \x11\n\r\n\x05\x04O\x02\x02\x01\x12\x04\xe4\x18\x12\x1a\n\r\n\x05\x04O\
    \x02\x02\x03\x12\x04\xe4\x18\x1d\x1e\n\"\n\x04\x04O\x02\x03\x12\x04\xe6\
    \x18\x02\x14\x1a\x14overwrite\x20supported\n\n\r\n\x05\x04O\x02\x03\x05\
    \x12\x04\xe6\x18\x02\x08\n\r\n\x05\x04O\x02\x03\x01\x12\x04\xe6\x18\t\
    \x0f\n\r\n\x05\x04O\x02\x03\x03\x12\x04\xe6\x18\x12\x13\n\x0c\n\x02\x04P\
    \x12\x06\xe9\x18\0\xf1\x18\x01\n\x0b\n\x03\x04P\x01\x12\x04\xe9\x18\x08!\
    \n\x0c\n\x04\x04P\x02\0\x12\x04\xea\x18\x02,\n\r\n\x05\x04P\x02\0\x06\
    \x12\x04\xea\x18\x02\x1b\n\r\n\x05\x04P\x02\0\x01\x12\x04\xea\x18\x1c'\n\
    \r\n\x05\x04P\x02\0\x03\x12\x04\xea\x18*+\n\x0c\n\x04\x04P\x02\x01\x12\
    \x04\xec\x18\x02\x16\n\r\n\x05\x04P\x02\x01\x05\x12\x04\xec\x18\x02\x08\
    \n\r\n\x05\x04P\x02\x01\x01\x12\x04\xec\x18\t\x11\n\r\n\x05\x04P\x02\x01\
    \x03\x12\x04\xec\x18\x14\x15\n\x0c\n\x04\x04P\x02\x02\x12\x04\xee\x18\
    \x02\x1f\n\r\n\x05\x04P\x02\x02\x04\x12\x04\xee\x18\x02\n\n\r\n\x05\x04P\
    \x02\x02\x05\x12\x04\xee\x18\x0b\x11\n\r\n\x05\x04P\x02\x02\x01\x12\x04\
    \xee\x18\x12\x1a\n\r\n\x05\x04P\x02\x02\x03\x12\x04\xee\x18\x1d\x1e\n\"\
    \n\x04\x04P\x02\x03\x12\x04\xf0\x18\x02\x14\x1a\x14overwrite\x20supporte\
    d\n\n\r\n\x05\x04P\x02\x03\x05\x12\x04\xf0\x18\x02\x08\n\r\n\x05\x04P\
    \x02\x03\x01\x12\x04\xf0\x18\t\x0f\n\r\n\x05\x04P\x02\x03\x03\x12\x04\
    \xf0\x18\x12\x13\n\x0c\n\x02\x04Q\x12\x06\xf3\x18\0\xfb\x18\x01\n\x0b\n\
    \x03\x04Q\x01\x12\x04\xf3\x18\x08\"\n\x0c\n\x04\x04Q\x02\0\x12\x04\xf4\
    \x18\x02,\n\r\n\x05\x04Q\x02\0\x06\x12\x04\xf4\x18\x02\x1b\n\r\n\x05\x04\
    Q\x02\0\x01\x12\x04\xf4\x18\x1c'\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xf4\
    \x18*+\n\x0c\n\x04\x04Q\x02\x01\x12\x04\xf6\x18\x02\x16\n\r\n\x05\x04Q\
    \x02\x01\x05\x12\x04\xf6\x18\x02\x08\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\
    \xf6\x18\t\x11\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xf6\x18\x14\x15\n\x0c\
    \n\x04\x04Q\x02\x02\x12\x04\xf8\x18\x02\x20\n\r\n\x05\x04Q\x02\x02\x04\
    \x12\x04\xf8\x18\x02\n\n\r\n\x05\x04Q\x02\x02\x05\x12\x04\xf8\x18\x0b\
    \x11\n\r\n\x05\x04Q\x02\x02\x01\x12\x04\xf8\x18\x12\x1b\n\r\n\x05\x04Q\
    \x02\x02\x03\x12\x04\xf8\x18\x1e\x1f\n(\n\x04\x04Q\x02\x03\x12\x04\xfa\
    \x18\x02\x14\x1a\x1a\x20Only\x20overwrite\x20supported\n\n\r\n\x05\x04Q\
    \x02\x03\x05\x12\x04\xfa\x18\x02\x08\n\r\n\x05\x04Q\x02\x03\x01\x12\x04\
    \xfa\x18\t\x0f\n\r\n\x05\x04Q\x02\x03\x03\x12\x04\xfa\x18\x12\x13\n\x0c\
    \n\x02\x04R\x12\x06\xff\x18\0\x82\x19\x01\n\x0b\n\x03\x04R\x01\x12\x04\
    \xff\x18\x08!\n\x0c\n\x04\x04R\x02\0\x12\x04\x80\x19\x02(\n\r\n\x05\x04R\
    \x02\0\x06\x12\x04\x80\x19\x02\x1c\n\r\n\x05\x04R\x02\0\x01\x12\x04\x80\
    \x19\x1d#\n\r\n\x05\x04R\x02\0\x03\x12\x04\x80\x19&'\n\x0c\n\x04\x04R\
    \x02\x01\x12\x04\x81\x19\x02\x1f\n\r\n\x05\x04R\x02\x01\x04\x12\x04\x81\
    \x19\x02\n\n\r\n\x05\x04R\x02\x01\x05\x12\x04\x81\x19\x0b\x11\n\r\n\x05\
    \x04R\x02\x01\x01\x12\x04\x81\x19\x12\x1a\n\r\n\x05\x04R\x02\x01\x03\x12\
    \x04\x81\x19\x1d\x1e\n\x0c\n\x02\x04S\x12\x06\x84\x19\0\x87\x19\x01\n\
    \x0b\n\x03\x04S\x01\x12\x04\x84\x19\x08!\n\x0c\n\x04\x04S\x02\0\x12\x04\
    \x85\x19\x02(\n\r\n\x05\x04S\x02\0\x06\x12\x04\x85\x19\x02\x1c\n\r\n\x05\
    \x04S\x02\0\x01\x12\x04\x85\x19\x1d#\n\r\n\x05\x04S\x02\0\x03\x12\x04\
    \x85\x19&'\n\x0c\n\x04\x04S\x02\x01\x12\x04\x86\x19\x02\x1f\n\r\n\x05\
    \x04S\x02\x01\x04\x12\x04\x86\x19\x02\n\n\r\n\x05\x04S\x02\x01\x05\x12\
    \x04\x86\x19\x0b\x11\n\r\n\x05\x04S\x02\x01\x01\x12\x04\x86\x19\x12\x1a\
    \n\r\n\x05\x04S\x02\x01\x03\x12\x04\x86\x19\x1d\x1e\n\x0c\n\x02\x04T\x12\
    \x06\x89\x19\0\x8c\x19\x01\n\x0b\n\x03\x04T\x01\x12\x04\x89\x19\x08\"\n\
    \x0c\n\x04\x04T\x02\0\x12\x04\x8a\x19\x02(\n\r\n\x05\x04T\x02\0\x06\x12\
    \x04\x8a\x19\x02\x1c\n\r\n\x05\x04T\x02\0\x01\x12\x04\x8a\x19\x1d#\n\r\n\
    \x05\x04T\x02\0\x03\x12\x04\x8a\x19&'\n\x0c\n\x04\x04T\x02\x01\x12\x04\
    \x8b\x19\x02\x20\n\r\n\x05\x04T\x02\x01\x04\x12\x04\x8b\x19\x02\n\n\r\n\
    \x05\x04T\x02\x01\x05\x12\x04\x8b\x19\x0b\x11\n\r\n\x05\x04T\x02\x01\x01\
    \x12\x04\x8b\x19\x12\x1b\n\r\n\x05\x04T\x02\x01\x03\x12\x04\x8b\x19\x1e\
    \x1f\n!\n\x02\x04U\x12\x06\x8f\x19\0\x99\x19\x01\x1a\x13\x20PostModelsRe\
    quest\n\n\x0b\n\x03\x04U\x01\x12\x04\x8f\x19\x08\x19\n\x0c\n\x04\x04U\
    \x02\0\x12\x04\x90\x19\x02,\n\r\n\x05\x04U\x02\0\x06\x12\x04\x90\x19\x02\
    \x1b\n\r\n\x05\x04U\x02\0\x01\x12\x04\x90\x19\x1c'\n\r\n\x05\x04U\x02\0\
    \x03\x12\x04\x90\x19*+\n\x91\x02\n\x04\x04U\x02\x01\x12\x04\x96\x19\x02&\
    \x1a\x82\x02\x20NOTE:\x20inconsistent\x20since\x20\"model\"\x20is\x20not\
    \x20plural,\x20please\x20use\x20\"models\"\x20below.\n\x20Previously\x20\
    you\x20could\x20only\x20create\x20one\x20model\x20at\x20a\x20time.\n\x20\
    We\x20still\x20support\x20this\x20but\x20you\x20should\x20pass\x20it\x20\
    as\x20models=[model]\x20so\n\x20that\x20this\x20endpoint\x20is\x20consis\
    tent\x20with\x20the\x20rest\x20of\x20our\x20API.\n\n\r\n\x05\x04U\x02\
    \x01\x06\x12\x04\x96\x19\x02\x07\n\r\n\x05\x04U\x02\x01\x01\x12\x04\x96\
    \x19\x08\r\n\r\n\x05\x04U\x02\x01\x03\x12\x04\x96\x19\x10\x11\n\r\n\x05\
    \x04U\x02\x01\x08\x12\x04\x96\x19\x12%\n\x0e\n\x06\x04U\x02\x01\x08\x03\
    \x12\x04\x96\x19\x13$\nU\n\x04\x04U\x02\x02\x12\x04\x98\x19\x02\x1c\x1aG\
    \x20This\x20allows\x20you\x20to\x20create\x20one\x20or\x20more\x20model\
    \x20by\x20posting\x20it\x20to\x20the\x20API.\n\n\r\n\x05\x04U\x02\x02\
    \x04\x12\x04\x98\x19\x02\n\n\r\n\x05\x04U\x02\x02\x06\x12\x04\x98\x19\
    \x0b\x10\n\r\n\x05\x04U\x02\x02\x01\x12\x04\x98\x19\x11\x17\n\r\n\x05\
    \x04U\x02\x02\x03\x12\x04\x98\x19\x1a\x1b\n\"\n\x02\x04V\x12\x06\x9c\x19\
    \0\xa3\x19\x01\x1a\x14\x20PatchModelsRequest\n\n\x0b\n\x03\x04V\x01\x12\
    \x04\x9c\x19\x08\x1a\n\x0c\n\x04\x04V\x02\0\x12\x04\x9d\x19\x02,\n\r\n\
    \x05\x04V\x02\0\x06\x12\x04\x9d\x19\x02\x1b\n\r\n\x05\x04V\x02\0\x01\x12\
    \x04\x9d\x19\x1c'\n\r\n\x05\x04V\x02\0\x03\x12\x04\x9d\x19*+\n\x0c\n\x04\
    \x04V\x02\x01\x12\x04\x9e\x19\x02\x1c\n\r\n\x05\x04V\x02\x01\x04\x12\x04\
    \x9e\x19\x02\n\n\r\n\x05\x04V\x02\x01\x06\x12\x04\x9e\x19\x0b\x10\n\r\n\
    \x05\x04V\x02\x01\x01\x12\x04\x9e\x19\x11\x17\n\r\n\x05\x04V\x02\x01\x03\
    \x12\x04\x9e\x19\x1a\x1b\n~\n\x04\x04V\x02\x02\x12\x04\xa2\x19\x02\x14\
    \x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objec\
    ts\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20and\x20'rem\
    ove'\x20are\x20supported\n\n\r\n\x05\x04V\x02\x02\x05\x12\x04\xa2\x19\
    \x02\x08\n\r\n\x05\x04V\x02\x02\x01\x12\x04\xa2\x19\t\x0f\n\r\n\x05\x04V\
    \x02\x02\x03\x12\x04\xa2\x19\x12\x13\n\x0c\n\x02\x04W\x12\x06\xa5\x19\0\
    \xaa\x19\x01\n\x0b\n\x03\x04W\x01\x12\x04\xa5\x19\x08\x16\n\x15\n\x04\
    \x04W\x02\0\x12\x04\xa7\x19\x02\x10\x1a\x07old\x20id\n\n\r\n\x05\x04W\
    \x02\0\x05\x12\x04\xa7\x19\x02\x08\n\r\n\x05\x04W\x02\0\x01\x12\x04\xa7\
    \x19\t\x0b\n\r\n\x05\x04W\x02\0\x03\x12\x04\xa7\x19\x0e\x0f\n\x15\n\x04\
    \x04W\x02\x01\x12\x04\xa9\x19\x02\x14\x1a\x07new\x20id\n\n\r\n\x05\x04W\
    \x02\x01\x05\x12\x04\xa9\x19\x02\x08\n\r\n\x05\x04W\x02\x01\x01\x12\x04\
    \xa9\x19\t\x0f\n\r\n\x05\x04W\x02\x01\x03\x12\x04\xa9\x19\x12\x13\n#\n\
    \x02\x04X\x12\x06\xad\x19\0\xb6\x19\x01\x1a\x15\x20PatchModelIdRequest\n\
    \n\x0b\n\x03\x04X\x01\x12\x04\xad\x19\x08\x1c\n\x0c\n\x04\x04X\x02\0\x12\
    \x04\xae\x19\x02,\n\r\n\x05\x04X\x02\0\x06\x12\x04\xae\x19\x02\x1b\n\r\n\
    \x05\x04X\x02\0\x01\x12\x04\xae\x19\x1c'\n\r\n\x05\x04X\x02\0\x03\x12\
    \x04\xae\x19*+\n(\n\x04\x04X\x02\x01\x12\x04\xb1\x19\x02\"\x1a\x1a\x20Ar\
    ray\x20containing\x201\x20entry\n\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xb1\
    \x19\x02\n\n\r\n\x05\x04X\x02\x01\x06\x12\x04\xb1\x19\x0b\x19\n\r\n\x05\
    \x04X\x02\x01\x01\x12\x04\xb1\x19\x1a\x1d\n\r\n\x05\x04X\x02\x01\x03\x12\
    \x04\xb1\x19\x20!\n[\n\x04\x04X\x02\x02\x12\x04\xb5\x19\x02\x14\x1aM\x20\
    The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20O\
    nly\x20'overwrite'\x20is\x20supported\n\n\r\n\x05\x04X\x02\x02\x05\x12\
    \x04\xb5\x19\x02\x08\n\r\n\x05\x04X\x02\x02\x01\x12\x04\xb5\x19\t\x0f\n\
    \r\n\x05\x04X\x02\x02\x03\x12\x04\xb5\x19\x12\x13\n\"\n\x02\x04Y\x12\x06\
    \xb9\x19\0\xbc\x19\x01\x1a\x14\x20DeleteModelRequest\n\n\x0b\n\x03\x04Y\
    \x01\x12\x04\xb9\x19\x08\x1a\n\x0c\n\x04\x04Y\x02\0\x12\x04\xba\x19\x02,\
    \n\r\n\x05\x04Y\x02\0\x06\x12\x04\xba\x19\x02\x1b\n\r\n\x05\x04Y\x02\0\
    \x01\x12\x04\xba\x19\x1c'\n\r\n\x05\x04Y\x02\0\x03\x12\x04\xba\x19*+\n\
    \x0c\n\x04\x04Y\x02\x01\x12\x04\xbb\x19\x02\x16\n\r\n\x05\x04Y\x02\x01\
    \x05\x12\x04\xbb\x19\x02\x08\n\r\n\x05\x04Y\x02\x01\x01\x12\x04\xbb\x19\
    \t\x11\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\xbb\x19\x14\x15\nD\n\x02\x04Z\
    \x12\x06\xbf\x19\0\xc3\x19\x01\x1a6\x20Request\x20to\x20delete\x20severa\
    l\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0b\n\x03\x04Z\x01\
    \x12\x04\xbf\x19\x08\x1b\n\x0c\n\x04\x04Z\x02\0\x12\x04\xc0\x19\x02,\n\r\
    \n\x05\x04Z\x02\0\x06\x12\x04\xc0\x19\x02\x1b\n\r\n\x05\x04Z\x02\0\x01\
    \x12\x04\xc0\x19\x1c'\n\r\n\x05\x04Z\x02\0\x03\x12\x04\xc0\x19*+\n\x0c\n\
    \x04\x04Z\x02\x01\x12\x04\xc1\x19\x02\x1a\n\r\n\x05\x04Z\x02\x01\x04\x12\
    \x04\xc1\x19\x02\n\n\r\n\x05\x04Z\x02\x01\x05\x12\x04\xc1\x19\x0b\x11\n\
    \r\n\x05\x04Z\x02\x01\x01\x12\x04\xc1\x19\x12\x15\n\r\n\x05\x04Z\x02\x01\
    \x03\x12\x04\xc1\x19\x18\x19\n\x0c\n\x04\x04Z\x02\x02\x12\x04\xc2\x19\
    \x02\x16\n\r\n\x05\x04Z\x02\x02\x05\x12\x04\xc2\x19\x02\x06\n\r\n\x05\
    \x04Z\x02\x02\x01\x12\x04\xc2\x19\x07\x11\n\r\n\x05\x04Z\x02\x02\x03\x12\
    \x04\xc2\x19\x14\x15\n1\n\x02\x04[\x12\x06\xc6\x19\0\xce\x19\x01\x1a#\
    \x20Search\x20over\x20the\x20available\x20models.\n\n\x0b\n\x03\x04[\x01\
    \x12\x04\xc6\x19\x08!\n6\n\x04\x04[\x02\0\x12\x04\xc8\x19\x02,\x1a(\x20I\
    ds\x20present\x20in\x20the\x20url\x20of\x20the\x20request.\n\n\r\n\x05\
    \x04[\x02\0\x06\x12\x04\xc8\x19\x02\x1b\n\r\n\x05\x04[\x02\0\x01\x12\x04\
    \xc8\x19\x1c'\n\r\n\x05\x04[\x02\0\x03\x12\x04\xc8\x19*+\n(\n\x04\x04[\
    \x02\x01\x12\x04\xca\x19\x02\x1d\x1a\x1a\x20The\x20body\x20of\x20the\x20\
    request.\n\n\r\n\x05\x04[\x02\x01\x06\x12\x04\xca\x19\x02\x0c\n\r\n\x05\
    \x04[\x02\x01\x01\x12\x04\xca\x19\r\x18\n\r\n\x05\x04[\x02\x01\x03\x12\
    \x04\xca\x19\x1b\x1c\n]\n\x04\x04[\x02\x02\x12\x04\xcd\x19\x02\x1c\x1aO\
    \x20Pagination\x20parameters\x20here\x20since\x20there\x20are\x20no\x20u\
    rl\x20args\x20in\x20this\n\x20POST\x20request.\n\n\r\n\x05\x04[\x02\x02\
    \x06\x12\x04\xcd\x19\x02\x0c\n\r\n\x05\x04[\x02\x02\x01\x12\x04\xcd\x19\
    \r\x17\n\r\n\x05\x04[\x02\x02\x03\x12\x04\xcd\x19\x1a\x1b\n#\n\x02\x04\\\
    \x12\x06\xd1\x19\0\xd4\x19\x01\x1a\x15\x20SingleModelResponse\n\n\x0b\n\
    \x03\x04\\\x01\x12\x04\xd1\x19\x08\x1b\n\x0c\n\x04\x04\\\x02\0\x12\x04\
    \xd2\x19\x02(\n\r\n\x05\x04\\\x02\0\x06\x12\x04\xd2\x19\x02\x1c\n\r\n\
    \x05\x04\\\x02\0\x01\x12\x04\xd2\x19\x1d#\n\r\n\x05\x04\\\x02\0\x03\x12\
    \x04\xd2\x19&'\n\x0c\n\x04\x04\\\x02\x01\x12\x04\xd3\x19\x02\x12\n\r\n\
    \x05\x04\\\x02\x01\x06\x12\x04\xd3\x19\x02\x07\n\r\n\x05\x04\\\x02\x01\
    \x01\x12\x04\xd3\x19\x08\r\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\xd3\x19\
    \x10\x11\n\"\n\x02\x04]\x12\x06\xd7\x19\0\xda\x19\x01\x1a\x14\x20MultiMo\
    delResponse\n\n\x0b\n\x03\x04]\x01\x12\x04\xd7\x19\x08\x1a\n\x0c\n\x04\
    \x04]\x02\0\x12\x04\xd8\x19\x02(\n\r\n\x05\x04]\x02\0\x06\x12\x04\xd8\
    \x19\x02\x1c\n\r\n\x05\x04]\x02\0\x01\x12\x04\xd8\x19\x1d#\n\r\n\x05\x04\
    ]\x02\0\x03\x12\x04\xd8\x19&'\n\x0c\n\x04\x04]\x02\x01\x12\x04\xd9\x19\
    \x02K\n\r\n\x05\x04]\x02\x01\x04\x12\x04\xd9\x19\x02\n\n\r\n\x05\x04]\
    \x02\x01\x06\x12\x04\xd9\x19\x0b\x10\n\r\n\x05\x04]\x02\x01\x01\x12\x04\
    \xd9\x19\x11\x17\n\r\n\x05\x04]\x02\x01\x03\x12\x04\xd9\x19\x1a\x1b\n\r\
    \n\x05\x04]\x02\x01\x08\x12\x04\xd9\x19\x1cJ\n\x10\n\x08\x04]\x02\x01\
    \x08\xd0\x86\x03\x12\x04\xd9\x19\x1dI\n)\n\x02\x04^\x12\x06\xdd\x19\0\
    \xe4\x19\x01\x1a\x1b\x20PatchModelVersionsRequest\n\n\x0b\n\x03\x04^\x01\
    \x12\x04\xdd\x19\x08!\n\x0c\n\x04\x04^\x02\0\x12\x04\xde\x19\x02,\n\r\n\
    \x05\x04^\x02\0\x06\x12\x04\xde\x19\x02\x1b\n\r\n\x05\x04^\x02\0\x01\x12\
    \x04\xde\x19\x1c'\n\r\n\x05\x04^\x02\0\x03\x12\x04\xde\x19*+\n\x0c\n\x04\
    \x04^\x02\x01\x12\x04\xdf\x19\x02\x16\n\r\n\x05\x04^\x02\x01\x05\x12\x04\
    \xdf\x19\x02\x08\n\r\n\x05\x04^\x02\x01\x01\x12\x04\xdf\x19\t\x11\n\r\n\
    \x05\x04^\x02\x01\x03\x12\x04\xdf\x19\x14\x15\n\x0c\n\x04\x04^\x02\x02\
    \x12\x04\xe0\x19\x02+\n\r\n\x05\x04^\x02\x02\x04\x12\x04\xe0\x19\x02\n\n\
    \r\n\x05\x04^\x02\x02\x06\x12\x04\xe0\x19\x0b\x17\n\r\n\x05\x04^\x02\x02\
    \x01\x12\x04\xe0\x19\x18&\n\r\n\x05\x04^\x02\x02\x03\x12\x04\xe0\x19)*\n\
    ~\n\x04\x04^\x02\x03\x12\x04\xe3\x19\x02\x14\x1ap\x20The\x20action\x20to\
    \x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20action\
    s\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\
    \r\n\x05\x04^\x02\x03\x05\x12\x04\xe3\x19\x02\x08\n\r\n\x05\x04^\x02\x03\
    \x01\x12\x04\xe3\x19\t\x0f\n\r\n\x05\x04^\x02\x03\x03\x12\x04\xe3\x19\
    \x12\x13\n:\n\x02\x04_\x12\x06\xe7\x19\0\xeb\x19\x01\x1a,\x20request\x20\
    for\x20different\x20endpoints\x20currently.\n\n\x0b\n\x03\x04_\x01\x12\
    \x04\xe7\x19\x08\x1e\n\x0c\n\x04\x04_\x02\0\x12\x04\xe8\x19\x02,\n\r\n\
    \x05\x04_\x02\0\x06\x12\x04\xe8\x19\x02\x1b\n\r\n\x05\x04_\x02\0\x01\x12\
    \x04\xe8\x19\x1c'\n\r\n\x05\x04_\x02\0\x03\x12\x04\xe8\x19*+\n\x0c\n\x04\
    \x04_\x02\x01\x12\x04\xe9\x19\x02\x16\n\r\n\x05\x04_\x02\x01\x05\x12\x04\
    \xe9\x19\x02\x08\n\r\n\x05\x04_\x02\x01\x01\x12\x04\xe9\x19\t\x11\n\r\n\
    \x05\x04_\x02\x01\x03\x12\x04\xe9\x19\x14\x15\n\x0c\n\x04\x04_\x02\x02\
    \x12\x04\xea\x19\x02\x18\n\r\n\x05\x04_\x02\x02\x05\x12\x04\xea\x19\x02\
    \x08\n\r\n\x05\x04_\x02\x02\x01\x12\x04\xea\x19\t\x13\n\r\n\x05\x04_\x02\
    \x02\x03\x12\x04\xea\x19\x16\x17\n(\n\x02\x04`\x12\x06\xee\x19\0\xf9\x19\
    \x01\x1a\x1a\x20ListModelVersionsRequest\n\n\x0b\n\x03\x04`\x01\x12\x04\
    \xee\x19\x08\x20\n\x0c\n\x04\x04`\x02\0\x12\x04\xef\x19\x02,\n\r\n\x05\
    \x04`\x02\0\x06\x12\x04\xef\x19\x02\x1b\n\r\n\x05\x04`\x02\0\x01\x12\x04\
    \xef\x19\x1c'\n\r\n\x05\x04`\x02\0\x03\x12\x04\xef\x19*+\n\x0c\n\x04\x04\
    `\x02\x01\x12\x04\xf0\x19\x02\x16\n\r\n\x05\x04`\x02\x01\x05\x12\x04\xf0\
    \x19\x02\x08\n\r\n\x05\x04`\x02\x01\x01\x12\x04\xf0\x19\t\x11\n\r\n\x05\
    \x04`\x02\x01\x03\x12\x04\xf0\x19\x14\x15\n~\n\x04\x04`\x02\x02\x12\x04\
    \xf3\x19\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20page\
    \x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20results\
    \x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\x05\x04`\x02\x02\
    \x05\x12\x04\xf3\x19\x02\x08\n\r\n\x05\x04`\x02\x02\x01\x12\x04\xf3\x19\
    \t\r\n\r\n\x05\x04`\x02\x02\x03\x12\x04\xf3\x19\x10\x11\nu\n\x04\x04`\
    \x02\x03\x12\x04\xf6\x19\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\
    \x20The\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\
    \x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\x05\x04`\x02\
    \x03\x05\x12\x04\xf6\x19\x02\x08\n\r\n\x05\x04`\x02\x03\x01\x12\x04\xf6\
    \x19\t\x11\n\r\n\x05\x04`\x02\x03\x03\x12\x04\xf6\x19\x14\x15\n\\\n\x04\
    \x04`\x02\x04\x12\x04\xf8\x19\x02\"\x1aN\x20To\x20list\x20only\x20the\
    \x20model\x20versions\x20that\x20have\x20these\x20concept\x20ids\x20pres\
    ent\x20in\x20them.\n\n\r\n\x05\x04`\x02\x04\x04\x12\x04\xf8\x19\x02\n\n\
    \r\n\x05\x04`\x02\x04\x05\x12\x04\xf8\x19\x0b\x11\n\r\n\x05\x04`\x02\x04\
    \x01\x12\x04\xf8\x19\x12\x1d\n\r\n\x05\x04`\x02\x04\x03\x12\x04\xf8\x19\
    \x20!\n)\n\x02\x04a\x12\x06\xfc\x19\0\x80\x1a\x01\x1a\x1b\x20DeleteModel\
    VersionRequest\n\n\x0b\n\x03\x04a\x01\x12\x04\xfc\x19\x08!\n\x0c\n\x04\
    \x04a\x02\0\x12\x04\xfd\x19\x02,\n\r\n\x05\x04a\x02\0\x06\x12\x04\xfd\
    \x19\x02\x1b\n\r\n\x05\x04a\x02\0\x01\x12\x04\xfd\x19\x1c'\n\r\n\x05\x04\
    a\x02\0\x03\x12\x04\xfd\x19*+\n\x0c\n\x04\x04a\x02\x01\x12\x04\xfe\x19\
    \x02\x16\n\r\n\x05\x04a\x02\x01\x05\x12\x04\xfe\x19\x02\x08\n\r\n\x05\
    \x04a\x02\x01\x01\x12\x04\xfe\x19\t\x11\n\r\n\x05\x04a\x02\x01\x03\x12\
    \x04\xfe\x19\x14\x15\n\x0c\n\x04\x04a\x02\x02\x12\x04\xff\x19\x02\x18\n\
    \r\n\x05\x04a\x02\x02\x05\x12\x04\xff\x19\x02\x08\n\r\n\x05\x04a\x02\x02\
    \x01\x12\x04\xff\x19\t\x13\n\r\n\x05\x04a\x02\x02\x03\x12\x04\xff\x19\
    \x16\x17\n*\n\x02\x04b\x12\x06\x83\x1a\0\x86\x1a\x01\x1a\x1c\x20SingleMo\
    delVersionResponse\n\n\x0b\n\x03\x04b\x01\x12\x04\x83\x1a\x08\"\n\x0c\n\
    \x04\x04b\x02\0\x12\x04\x84\x1a\x02(\n\r\n\x05\x04b\x02\0\x06\x12\x04\
    \x84\x1a\x02\x1c\n\r\n\x05\x04b\x02\0\x01\x12\x04\x84\x1a\x1d#\n\r\n\x05\
    \x04b\x02\0\x03\x12\x04\x84\x1a&'\n\x0c\n\x04\x04b\x02\x01\x12\x04\x85\
    \x1a\x02!\n\r\n\x05\x04b\x02\x01\x06\x12\x04\x85\x1a\x02\x0e\n\r\n\x05\
    \x04b\x02\x01\x01\x12\x04\x85\x1a\x0f\x1c\n\r\n\x05\x04b\x02\x01\x03\x12\
    \x04\x85\x1a\x1f\x20\n)\n\x02\x04c\x12\x06\x89\x1a\0\x8c\x1a\x01\x1a\x1b\
    \x20MultiModelVersionResponse\n\n\x0b\n\x03\x04c\x01\x12\x04\x89\x1a\x08\
    !\n\x0c\n\x04\x04c\x02\0\x12\x04\x8a\x1a\x02(\n\r\n\x05\x04c\x02\0\x06\
    \x12\x04\x8a\x1a\x02\x1c\n\r\n\x05\x04c\x02\0\x01\x12\x04\x8a\x1a\x1d#\n\
    \r\n\x05\x04c\x02\0\x03\x12\x04\x8a\x1a&'\n\x0c\n\x04\x04c\x02\x01\x12\
    \x04\x8b\x1a\x02Z\n\r\n\x05\x04c\x02\x01\x04\x12\x04\x8b\x1a\x02\n\n\r\n\
    \x05\x04c\x02\x01\x06\x12\x04\x8b\x1a\x0b\x17\n\r\n\x05\x04c\x02\x01\x01\
    \x12\x04\x8b\x1a\x18&\n\r\n\x05\x04c\x02\x01\x03\x12\x04\x8b\x1a)*\n\r\n\
    \x05\x04c\x02\x01\x08\x12\x04\x8b\x1a+Y\n\x10\n\x08\x04c\x02\x01\x08\xd0\
    \x86\x03\x12\x04\x8b\x1a,X\n3\n\x02\x04d\x12\x06\x8f\x1a\0\xae\x1a\x01\
    \x1a%\x20Create\x20(train)\x20a\x20new\x20model\x20version.\n\n\x0b\n\
    \x03\x04d\x01\x12\x04\x8f\x1a\x08\x20\n\x0c\n\x04\x04d\x02\0\x12\x04\x90\
    \x1a\x02,\n\r\n\x05\x04d\x02\0\x06\x12\x04\x90\x1a\x02\x1b\n\r\n\x05\x04\
    d\x02\0\x01\x12\x04\x90\x1a\x1c'\n\r\n\x05\x04d\x02\0\x03\x12\x04\x90\
    \x1a*+\n\x0c\n\x04\x04d\x02\x01\x12\x04\x91\x1a\x02\x16\n\r\n\x05\x04d\
    \x02\x01\x05\x12\x04\x91\x1a\x02\x08\n\r\n\x05\x04d\x02\x01\x01\x12\x04\
    \x91\x1a\t\x11\n\r\n\x05\x04d\x02\x01\x03\x12\x04\x91\x1a\x14\x15\n\x86\
    \x01\n\x04\x04d\x02\x02\x12\x04\x95\x1a\x02+\x1ax\x20This\x20lets\x20you\
    \x20post\x20an\x20existing\x20model\x20version\x20rather\x20than\x20trai\
    ning\x20a\x20new\x20one.\n\x20For\x20internal\x20Clarifai\x20use\x20only\
    \x20to\x20start.\n\n\r\n\x05\x04d\x02\x02\x04\x12\x04\x95\x1a\x02\n\n\r\
    \n\x05\x04d\x02\x02\x06\x12\x04\x95\x1a\x0b\x17\n\r\n\x05\x04d\x02\x02\
    \x01\x12\x04\x95\x1a\x18&\n\r\n\x05\x04d\x02\x02\x03\x12\x04\x95\x1a)*\n\
    \x94\x01\n\x04\x04d\x02\x03\x12\x04\x99\x1a\x025\x1a\x85\x01\x20Use\x20t\
    his\x20to\x20filter\x20inputs\x20that\x20are\x20used\x20in\x20training\n\
    \x20Alternatively,\x20use\x20train_search\x20&\x20test_search\x20fields\
    \x20OR\x20dataset_version\x20field.\n\n\r\n\x05\x04d\x02\x03\x06\x12\x04\
    \x99\x1a\x02\x15\n\r\n\x05\x04d\x02\x03\x01\x12\x04\x99\x1a\x16\x1c\n\r\
    \n\x05\x04d\x02\x03\x03\x12\x04\x99\x1a\x1f\x20\n\r\n\x05\x04d\x02\x03\
    \x08\x12\x04\x99\x1a!4\n\x0e\n\x06\x04d\x02\x03\x08\x03\x12\x04\x99\x1a\
    \"3\np\n\x04\x04d\x02\x04\x12\x04\x9c\x1a\x02'\x1abtrain_search\x20is\
    \x20used\x20to\x20specify\x20what\x20data\x20to\x20train\x20on.\n\x20Alt\
    ernatively,\x20use\x20dataset_version\x20field.\n\n\r\n\x05\x04d\x02\x04\
    \x06\x12\x04\x9c\x1a\x02\x15\n\r\n\x05\x04d\x02\x04\x01\x12\x04\x9c\x1a\
    \x16\"\n\r\n\x05\x04d\x02\x04\x03\x12\x04\x9c\x1a%&\nn\n\x04\x04d\x02\
    \x05\x12\x04\x9f\x1a\x02&\x1a`test_search\x20is\x20used\x20to\x20specify\
    \x20what\x20data\x20to\x20test\x20on.\n\x20Alternatively,\x20use\x20data\
    set_version\x20field.\n\n\r\n\x05\x04d\x02\x05\x06\x12\x04\x9f\x1a\x02\
    \x15\n\r\n\x05\x04d\x02\x05\x01\x12\x04\x9f\x1a\x16!\n\r\n\x05\x04d\x02\
    \x05\x03\x12\x04\x9f\x1a$%\nM\n\x04\x04d\x02\x06\x12\x04\xa2\x1a\x02#\
    \x1a?\x20whether\x20to\x20evaluate\x20the\x20transfer\x20trained\x20mode\
    l\x20after\x20training\n\n\r\n\x05\x04d\x02\x06\x05\x12\x04\xa2\x1a\x02\
    \x06\n\r\n\x05\x04d\x02\x06\x01\x12\x04\xa2\x1a\x07\x1e\n\r\n\x05\x04d\
    \x02\x06\x03\x12\x04\xa2\x1a!\"\n3\n\x04\x04d\x02\x07\x12\x04\xa5\x1a\
    \x02\x19\x1a%\x20Description\x20about\x20this\x20training\x20run\n\n\r\n\
    \x05\x04d\x02\x07\x05\x12\x04\xa5\x1a\x02\x08\n\r\n\x05\x04d\x02\x07\x01\
    \x12\x04\xa5\x1a\t\x14\n\r\n\x05\x04d\x02\x07\x03\x12\x04\xa5\x1a\x17\
    \x18\n\x81\x03\n\x04\x04d\x02\x08\x12\x04\xad\x1a\x02%\x1a\xf2\x02\x20Us\
    e\x20the\x20data\x20from\x20this\x20dataset\x20version\x20for\x20trainin\
    g.\n\x20Set\x20dataset_version.dataset_id\x20to\x20identify\x20the\x20da\
    taset\x20that\x20you\x20would\x20like\x20to\x20use.\n\x20When\x20dataset\
    _version.id\x20field\x20is\x20set,\n\x20the\x20system\x20will\x20reuse\
    \x20the\x20data\x20from\x20provided\x20dataset\x20version.\n\x20When\x20\
    dataset_version.id\x20is\x20not\x20set,\n\x20a\x20new\x20dataset\x20vers\
    ion\x20will\x20be\x20created\x20in\x20the\x20dataset\x20using\x20provide\
    d\x20dataset_version\x20fields.\n\n\r\n\x05\x04d\x02\x08\x06\x12\x04\xad\
    \x1a\x02\x10\n\r\n\x05\x04d\x02\x08\x01\x12\x04\xad\x1a\x11\x20\n\r\n\
    \x05\x04d\x02\x08\x03\x12\x04\xad\x1a#$\n*\n\x02\x04e\x12\x06\xb1\x1a\0\
    \xb3\x1a\x01\x1a\x1c\x20ModelVersionPublishRequest\n\n\x0b\n\x03\x04e\
    \x01\x12\x04\xb1\x1a\x08\"\n\x0c\n\x04\x04e\x02\0\x12\x04\xb2\x1a\x02\
    \x18\n\r\n\x05\x04e\x02\0\x05\x12\x04\xb2\x1a\x02\x08\n\r\n\x05\x04e\x02\
    \0\x01\x12\x04\xb2\x1a\t\x13\n\r\n\x05\x04e\x02\0\x03\x12\x04\xb2\x1a\
    \x16\x17\n/\n\x02\x04f\x12\x06\xb6\x1a\0\xba\x1a\x01\x1a!\x20PostModelVe\
    rsionsPublishRequest\n\n\x0b\n\x03\x04f\x01\x12\x04\xb6\x1a\x08'\n\x0c\n\
    \x04\x04f\x02\0\x12\x04\xb7\x1a\x02,\n\r\n\x05\x04f\x02\0\x06\x12\x04\
    \xb7\x1a\x02\x1b\n\r\n\x05\x04f\x02\0\x01\x12\x04\xb7\x1a\x1c'\n\r\n\x05\
    \x04f\x02\0\x03\x12\x04\xb7\x1a*+\n\x0c\n\x04\x04f\x02\x01\x12\x04\xb8\
    \x1a\x02\x16\n\r\n\x05\x04f\x02\x01\x05\x12\x04\xb8\x1a\x02\x08\n\r\n\
    \x05\x04f\x02\x01\x01\x12\x04\xb8\x1a\t\x11\n\r\n\x05\x04f\x02\x01\x03\
    \x12\x04\xb8\x1a\x14\x15\n\x0c\n\x04\x04f\x02\x02\x12\x04\xb9\x1a\x027\n\
    \r\n\x05\x04f\x02\x02\x04\x12\x04\xb9\x1a\x02\n\n\r\n\x05\x04f\x02\x02\
    \x06\x12\x04\xb9\x1a\x0b%\n\r\n\x05\x04f\x02\x02\x01\x12\x04\xb9\x1a&2\n\
    \r\n\x05\x04f\x02\x02\x03\x12\x04\xb9\x1a56\n,\n\x02\x04g\x12\x06\xbd\
    \x1a\0\xbf\x1a\x01\x1a\x1e\x20ModelVersionUnpublishRequest\n\n\x0b\n\x03\
    \x04g\x01\x12\x04\xbd\x1a\x08$\n\x0c\n\x04\x04g\x02\0\x12\x04\xbe\x1a\
    \x02\x18\n\r\n\x05\x04g\x02\0\x05\x12\x04\xbe\x1a\x02\x08\n\r\n\x05\x04g\
    \x02\0\x01\x12\x04\xbe\x1a\t\x13\n\r\n\x05\x04g\x02\0\x03\x12\x04\xbe\
    \x1a\x16\x17\n1\n\x02\x04h\x12\x06\xc2\x1a\0\xc6\x1a\x01\x1a#\x20PostMod\
    elVersionsUnPublishRequest\n\n\x0b\n\x03\x04h\x01\x12\x04\xc2\x1a\x08)\n\
    \x0c\n\x04\x04h\x02\0\x12\x04\xc3\x1a\x02,\n\r\n\x05\x04h\x02\0\x06\x12\
    \x04\xc3\x1a\x02\x1b\n\r\n\x05\x04h\x02\0\x01\x12\x04\xc3\x1a\x1c'\n\r\n\
    \x05\x04h\x02\0\x03\x12\x04\xc3\x1a*+\n\x0c\n\x04\x04h\x02\x01\x12\x04\
    \xc4\x1a\x02\x16\n\r\n\x05\x04h\x02\x01\x05\x12\x04\xc4\x1a\x02\x08\n\r\
    \n\x05\x04h\x02\x01\x01\x12\x04\xc4\x1a\t\x11\n\r\n\x05\x04h\x02\x01\x03\
    \x12\x04\xc4\x1a\x14\x15\n\x0c\n\x04\x04h\x02\x02\x12\x04\xc5\x1a\x029\n\
    \r\n\x05\x04h\x02\x02\x04\x12\x04\xc5\x1a\x02\n\n\r\n\x05\x04h\x02\x02\
    \x06\x12\x04\xc5\x1a\x0b'\n\r\n\x05\x04h\x02\x02\x01\x12\x04\xc5\x1a(4\n\
    \r\n\x05\x04h\x02\x02\x03\x12\x04\xc5\x1a78\n,\n\x02\x04i\x12\x06\xcb\
    \x1a\0\xd3\x1a\x01\x1a\x1e\x20Evaluate\x20this\x20model\x20version.\n\n\
    \x0b\n\x03\x04i\x01\x12\x04\xcb\x1a\x08&\n\x0c\n\x04\x04i\x02\0\x12\x04\
    \xcc\x1a\x02,\n\r\n\x05\x04i\x02\0\x06\x12\x04\xcc\x1a\x02\x1b\n\r\n\x05\
    \x04i\x02\0\x01\x12\x04\xcc\x1a\x1c'\n\r\n\x05\x04i\x02\0\x03\x12\x04\
    \xcc\x1a*+\n\x0c\n\x04\x04i\x02\x01\x12\x04\xcd\x1a\x02\x16\n\r\n\x05\
    \x04i\x02\x01\x05\x12\x04\xcd\x1a\x02\x08\n\r\n\x05\x04i\x02\x01\x01\x12\
    \x04\xcd\x1a\t\x11\n\r\n\x05\x04i\x02\x01\x03\x12\x04\xcd\x1a\x14\x15\n\
    \x0c\n\x04\x04i\x02\x02\x12\x04\xce\x1a\x02\x18\n\r\n\x05\x04i\x02\x02\
    \x05\x12\x04\xce\x1a\x02\x08\n\r\n\x05\x04i\x02\x02\x01\x12\x04\xce\x1a\
    \t\x13\n\r\n\x05\x04i\x02\x02\x03\x12\x04\xce\x1a\x16\x17\n\x0c\n\x04\
    \x04i\x02\x03\x12\x04\xcf\x1a\x02\x1a\n\r\n\x05\x04i\x02\x03\x05\x12\x04\
    \xcf\x1a\x02\x08\n\r\n\x05\x04i\x02\x03\x01\x12\x04\xcf\x1a\t\x15\n\r\n\
    \x05\x04i\x02\x03\x03\x12\x04\xcf\x1a\x18\x19\nE\n\x04\x04i\x02\x04\x12\
    \x04\xd2\x1a\x02&\x1a7\x20Use\x20this\x20to\x20filter\x20inputs\x20that\
    \x20are\x20used\x20in\x20evaluation\n\n\r\n\x05\x04i\x02\x04\x06\x12\x04\
    \xd2\x1a\x02\x15\n\r\n\x05\x04i\x02\x04\x01\x12\x04\xd2\x1a\x16!\n\r\n\
    \x05\x04i\x02\x04\x03\x12\x04\xd2\x1a$%\nT\n\x02\x04j\x12\x06\xd7\x1a\0\
    \xde\x1a\x01\x1aF\x20Get\x20the\x20already\x20computed\x20evaluation\x20\
    metrics\x20for\x20this\x20model\n\x20version.\n\n\x0b\n\x03\x04j\x01\x12\
    \x04\xd7\x1a\x08%\n\x0c\n\x04\x04j\x02\0\x12\x04\xd8\x1a\x02,\n\r\n\x05\
    \x04j\x02\0\x06\x12\x04\xd8\x1a\x02\x1b\n\r\n\x05\x04j\x02\0\x01\x12\x04\
    \xd8\x1a\x1c'\n\r\n\x05\x04j\x02\0\x03\x12\x04\xd8\x1a*+\n\x0c\n\x04\x04\
    j\x02\x01\x12\x04\xd9\x1a\x02\x16\n\r\n\x05\x04j\x02\x01\x05\x12\x04\xd9\
    \x1a\x02\x08\n\r\n\x05\x04j\x02\x01\x01\x12\x04\xd9\x1a\t\x11\n\r\n\x05\
    \x04j\x02\x01\x03\x12\x04\xd9\x1a\x14\x15\n\x0c\n\x04\x04j\x02\x02\x12\
    \x04\xda\x1a\x02\x18\n\r\n\x05\x04j\x02\x02\x05\x12\x04\xda\x1a\x02\x08\
    \n\r\n\x05\x04j\x02\x02\x01\x12\x04\xda\x1a\t\x13\n\r\n\x05\x04j\x02\x02\
    \x03\x12\x04\xda\x1a\x16\x17\nL\n\x04\x04j\x02\x03\x12\x04\xdd\x1a\x02\
    \x19\x1a>\x20Any\x20of\x20the\x20fields\x20you\x20wish\x20to\x20return\
    \x20from\x20multiclass_metrics\n\n\r\n\x05\x04j\x02\x03\x06\x12\x04\xdd\
    \x1a\x02\r\n\r\n\x05\x04j\x02\x03\x01\x12\x04\xdd\x1a\x0e\x14\n\r\n\x05\
    \x04j\x02\x03\x03\x12\x04\xdd\x1a\x17\x18\n\xea\x01\n\x02\x04k\x12\x06\
    \xeb\x1a\0\xf0\x1a\x01\x1a\x15\x20GetModelTypeRequest\n2\xc4\x01\x20//\
    \x20Request\x20to\x20delete\x20several\x20things\x20by\x20the\x20list\
    \x20of\x20ids.\n\x20message\x20DeleteModelVersionsRequest\x20{\n\x20\x20\
    \x20clarifai.api.UserAppIDSet\x20user_app_id\x20=\x201;\n\x20\x20\x20rep\
    eated\x20string\x20ids\x20=\x202;\n\x20\x20\x20bool\x20delete_all\x20=\
    \x203;\n\x20}\n\n\x0b\n\x03\x04k\x01\x12\x04\xeb\x1a\x08\x1b\nk\n\x04\
    \x04k\x02\0\x12\x04\xed\x1a\x02,\x1a]\x20use\x20and\x20app\x20combo.\x20\
    Not\x20really\x20used\x20for\x20this\x20endpoint\x20at\x20this\x20time\
    \x20so\x20may\x20go\x20away\x20in\x20future.\n\n\r\n\x05\x04k\x02\0\x06\
    \x12\x04\xed\x1a\x02\x1b\n\r\n\x05\x04k\x02\0\x01\x12\x04\xed\x1a\x1c'\n\
    \r\n\x05\x04k\x02\0\x03\x12\x04\xed\x1a*+\n?\n\x04\x04k\x02\x01\x12\x04\
    \xef\x1a\x02\x1b\x1a1\x20The\x20specific\x20ModelType.Id\x20you\x20want\
    \x20to\x20retrieve.\n\n\r\n\x05\x04k\x02\x01\x05\x12\x04\xef\x1a\x02\x08\
    \n\r\n\x05\x04k\x02\x01\x01\x12\x04\xef\x1a\t\x16\n\r\n\x05\x04k\x02\x01\
    \x03\x12\x04\xef\x1a\x19\x1a\n%\n\x02\x04l\x12\x06\xf3\x1a\0\xfc\x1a\x01\
    \x1a\x17\x20ListModelTypesRequest\n\n\x0b\n\x03\x04l\x01\x12\x04\xf3\x1a\
    \x08\x1d\nk\n\x04\x04l\x02\0\x12\x04\xf5\x1a\x02,\x1a]\x20use\x20and\x20\
    app\x20combo.\x20Not\x20really\x20used\x20for\x20this\x20endpoint\x20at\
    \x20this\x20time\x20so\x20may\x20go\x20away\x20in\x20future.\n\n\r\n\x05\
    \x04l\x02\0\x06\x12\x04\xf5\x1a\x02\x1b\n\r\n\x05\x04l\x02\0\x01\x12\x04\
    \xf5\x1a\x1c'\n\r\n\x05\x04l\x02\0\x03\x12\x04\xf5\x1a*+\n~\n\x04\x04l\
    \x02\x01\x12\x04\xf8\x1a\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\
    \x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\r\n\
    \x05\x04l\x02\x01\x05\x12\x04\xf8\x1a\x02\x08\n\r\n\x05\x04l\x02\x01\x01\
    \x12\x04\xf8\x1a\t\r\n\r\n\x05\x04l\x02\x01\x03\x12\x04\xf8\x1a\x10\x11\
    \nu\n\x04\x04l\x02\x02\x12\x04\xfb\x1a\x02\x16\x1ag\x20(optional\x20URL\
    \x20parameter)\x20The\x20number\x20of\x20results\x20that\x20will\x20be\
    \x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\r\n\
    \x05\x04l\x02\x02\x05\x12\x04\xfb\x1a\x02\x08\n\r\n\x05\x04l\x02\x02\x01\
    \x12\x04\xfb\x1a\t\x11\n\r\n\x05\x04l\x02\x02\x03\x12\x04\xfb\x1a\x14\
    \x15\n+\n\x02\x04m\x12\x04\xff\x1a\0(\x1a\x1f\x20ListOpenSourceLicensesR\
    equest\n\n\x0b\n\x03\x04m\x01\x12\x04\xff\x1a\x08%\n.\n\x02\x04n\x12\x06\
    \x82\x1b\0\x85\x1b\x01\x1a\x20\x20ListOpenSourceLicensesResponse\n\n\x0b\
    \n\x03\x04n\x01\x12\x04\x82\x1b\x08&\n\x0c\n\x04\x04n\x02\0\x12\x04\x83\
    \x1b\x02(\n\r\n\x05\x04n\x02\0\x06\x12\x04\x83\x1b\x02\x1c\n\r\n\x05\x04\
    n\x02\0\x01\x12\x04\x83\x1b\x1d#\n\r\n\x05\x04n\x02\0\x03\x12\x04\x83\
    \x1b&'\n\x0c\n\x04\x04n\x02\x01\x12\x04\x84\x1b\x02\x1f\n\r\n\x05\x04n\
    \x02\x01\x04\x12\x04\x84\x1b\x02\n\n\r\n\x05\x04n\x02\x01\x05\x12\x04\
    \x84\x1b\x0b\x11\n\r\n\x05\x04n\x02\x01\x01\x12\x04\x84\x1b\x12\x1a\n\r\
    \n\x05\x04n\x02\x01\x03\x12\x04\x84\x1b\x1d\x1e\n'\n\x02\x04o\x12\x06\
    \x88\x1b\0\x8d\x1b\x01\x1a\x19\x20SingleModelTypeResponse\n\n\x0b\n\x03\
    \x04o\x01\x12\x04\x88\x1b\x08\x1f\n'\n\x04\x04o\x02\0\x12\x04\x8a\x1b\
    \x02(\x1a\x19\x20Status\x20of\x20the\x20response.\n\n\r\n\x05\x04o\x02\0\
    \x06\x12\x04\x8a\x1b\x02\x1c\n\r\n\x05\x04o\x02\0\x01\x12\x04\x8a\x1b\
    \x1d#\n\r\n\x05\x04o\x02\0\x03\x12\x04\x8a\x1b&'\n1\n\x04\x04o\x02\x01\
    \x12\x04\x8c\x1b\x02J\x1a#\x20The\x20retrieved\x20ModelType\x20object.\
    \x20.\n\n\r\n\x05\x04o\x02\x01\x06\x12\x04\x8c\x1b\x02\x0b\n\r\n\x05\x04\
    o\x02\x01\x01\x12\x04\x8c\x1b\x0c\x16\n\r\n\x05\x04o\x02\x01\x03\x12\x04\
    \x8c\x1b\x19\x1a\n\r\n\x05\x04o\x02\x01\x08\x12\x04\x8c\x1b\x1bI\n\x10\n\
    \x08\x04o\x02\x01\x08\xd0\x86\x03\x12\x04\x8c\x1b\x1cH\n&\n\x02\x04p\x12\
    \x06\x90\x1b\0\x97\x1b\x01\x1a\x18\x20MultiModelTypeResponse\n\n\x0b\n\
    \x03\x04p\x01\x12\x04\x90\x1b\x08\x1e\n'\n\x04\x04p\x02\0\x12\x04\x92\
    \x1b\x02(\x1a\x19\x20Status\x20of\x20the\x20response.\n\n\r\n\x05\x04p\
    \x02\0\x06\x12\x04\x92\x1b\x02\x1c\n\r\n\x05\x04p\x02\0\x01\x12\x04\x92\
    \x1b\x1d#\n\r\n\x05\x04p\x02\0\x03\x12\x04\x92\x1b&'\n*\n\x04\x04p\x02\
    \x01\x12\x04\x94\x1b\x02T\x1a\x1c\x20List\x20of\x20ModelType\x20objects.\
    \n\n\r\n\x05\x04p\x02\x01\x04\x12\x04\x94\x1b\x02\n\n\r\n\x05\x04p\x02\
    \x01\x06\x12\x04\x94\x1b\x0b\x14\n\r\n\x05\x04p\x02\x01\x01\x12\x04\x94\
    \x1b\x15\x20\n\r\n\x05\x04p\x02\x01\x03\x12\x04\x94\x1b#$\n\r\n\x05\x04p\
    \x02\x01\x08\x12\x04\x94\x1b%S\n\x10\n\x08\x04p\x02\x01\x08\xd0\x86\x03\
    \x12\x04\x94\x1b&R\n'\n\x04\x04p\x02\x02\x12\x04\x96\x1b\x02%\x1a\x19\
    \x20List\x20of\x20model\x20importers\n\n\r\n\x05\x04p\x02\x02\x06\x12\
    \x04\x96\x1b\x02\x10\n\r\n\x05\x04p\x02\x02\x01\x12\x04\x96\x1b\x11\x20\
    \n\r\n\x05\x04p\x02\x02\x03\x12\x04\x96\x1b#$\n2\n\x02\x04q\x12\x06\x9a\
    \x1b\0\xa3\x1b\x01\x1a$\x20GetModelVersionInputExampleRequest\n\n\x0b\n\
    \x03\x04q\x01\x12\x04\x9a\x1b\x08*\n@\n\x04\x04q\x02\0\x12\x04\x9c\x1b\
    \x02,\x1a2\x20authorization\x20field\x20\x20(contains\x20app/user\x20id\
    \x20info)\n\n\r\n\x05\x04q\x02\0\x06\x12\x04\x9c\x1b\x02\x1b\n\r\n\x05\
    \x04q\x02\0\x01\x12\x04\x9c\x1b\x1c'\n\r\n\x05\x04q\x02\0\x03\x12\x04\
    \x9c\x1b*+\n2\n\x04\x04q\x02\x01\x12\x04\x9e\x1b\x02\x16\x1a$\x20id\x20o\
    f\x20model\x20the\x20example\x20belongs\x20to\n\n\r\n\x05\x04q\x02\x01\
    \x05\x12\x04\x9e\x1b\x02\x08\n\r\n\x05\x04q\x02\x01\x01\x12\x04\x9e\x1b\
    \t\x11\n\r\n\x05\x04q\x02\x01\x03\x12\x04\x9e\x1b\x14\x15\n7\n\x04\x04q\
    \x02\x02\x12\x04\xa0\x1b\x02\x1e\x1a)\x20specific\x20version\x20the\x20e\
    xample\x20belongs\x20to\n\n\r\n\x05\x04q\x02\x02\x05\x12\x04\xa0\x1b\x02\
    \x08\n\r\n\x05\x04q\x02\x02\x01\x12\x04\xa0\x1b\t\x19\n\r\n\x05\x04q\x02\
    \x02\x03\x12\x04\xa0\x1b\x1c\x1d\n&\n\x04\x04q\x02\x03\x12\x04\xa2\x1b\
    \x02\x18\x1a\x18\x20Id\x20of\x20example\x20to\x20fetch\n\n\r\n\x05\x04q\
    \x02\x03\x05\x12\x04\xa2\x1b\x02\x08\n\r\n\x05\x04q\x02\x03\x01\x12\x04\
    \xa2\x1b\t\x13\n\r\n\x05\x04q\x02\x03\x03\x12\x04\xa2\x1b\x16\x17\n4\n\
    \x02\x04r\x12\x06\xa6\x1b\0\xb1\x1b\x01\x1a&\x20ListModelVersionInputExa\
    mplesRequest\n\n\x0b\n\x03\x04r\x01\x12\x04\xa6\x1b\x08,\n@\n\x04\x04r\
    \x02\0\x12\x04\xa8\x1b\x02,\x1a2\x20authorization\x20field\x20\x20(conta\
    ins\x20app/user\x20id\x20info)\n\n\r\n\x05\x04r\x02\0\x06\x12\x04\xa8\
    \x1b\x02\x1b\n\r\n\x05\x04r\x02\0\x01\x12\x04\xa8\x1b\x1c'\n\r\n\x05\x04\
    r\x02\0\x03\x12\x04\xa8\x1b*+\n2\n\x04\x04r\x02\x01\x12\x04\xaa\x1b\x02\
    \x16\x1a$\x20id\x20of\x20model\x20the\x20example\x20belongs\x20to\n\n\r\
    \n\x05\x04r\x02\x01\x05\x12\x04\xaa\x1b\x02\x08\n\r\n\x05\x04r\x02\x01\
    \x01\x12\x04\xaa\x1b\t\x11\n\r\n\x05\x04r\x02\x01\x03\x12\x04\xaa\x1b\
    \x14\x15\n7\n\x04\x04r\x02\x02\x12\x04\xac\x1b\x02\x1e\x1a)\x20specific\
    \x20version\x20the\x20example\x20belongs\x20to\n\n\r\n\x05\x04r\x02\x02\
    \x05\x12\x04\xac\x1b\x02\x08\n\r\n\x05\x04r\x02\x02\x01\x12\x04\xac\x1b\
    \t\x19\n\r\n\x05\x04r\x02\x02\x03\x12\x04\xac\x1b\x1c\x1d\n(\n\x04\x04r\
    \x02\x03\x12\x04\xae\x1b\x02\x12\x1a\x1a\x20Optional,\x20defaults\x20to\
    \x201.\n\n\r\n\x05\x04r\x02\x03\x05\x12\x04\xae\x1b\x02\x08\n\r\n\x05\
    \x04r\x02\x03\x01\x12\x04\xae\x1b\t\r\n\r\n\x05\x04r\x02\x03\x03\x12\x04\
    \xae\x1b\x10\x11\n>\n\x04\x04r\x02\x04\x12\x04\xb0\x1b\x02\x16\x1a0\x20O\
    ptional,\x20defaults\x20to\x20128\x20references\x20per\x20page.\n\n\r\n\
    \x05\x04r\x02\x04\x05\x12\x04\xb0\x1b\x02\x08\n\r\n\x05\x04r\x02\x04\x01\
    \x12\x04\xb0\x1b\t\x11\n\r\n\x05\x04r\x02\x04\x03\x12\x04\xb0\x1b\x14\
    \x15\n6\n\x02\x04s\x12\x06\xb6\x1b\0\xbb\x1b\x01\x1a(\x20SingleModelVers\
    ionInputExampleResponse\n\n\x0b\n\x03\x04s\x01\x12\x04\xb6\x1b\x08.\n\"\
    \n\x04\x04s\x02\0\x12\x04\xb8\x1b\x02(\x1a\x14\x20status\x20of\x20respon\
    se\n\n\r\n\x05\x04s\x02\0\x06\x12\x04\xb8\x1b\x02\x1c\n\r\n\x05\x04s\x02\
    \0\x01\x12\x04\xb8\x1b\x1d#\n\r\n\x05\x04s\x02\0\x03\x12\x04\xb8\x1b&'\n\
    +\n\x04\x04s\x02\x01\x12\x04\xba\x1b\x02;\x1a\x1d\x20model\x20input\x20e\
    xample\x20message\n\n\r\n\x05\x04s\x02\x01\x06\x12\x04\xba\x1b\x02\x1a\n\
    \r\n\x05\x04s\x02\x01\x01\x12\x04\xba\x1b\x1b6\n\r\n\x05\x04s\x02\x01\
    \x03\x12\x04\xba\x1b9:\n5\n\x02\x04t\x12\x06\xbe\x1b\0\xc3\x1b\x01\x1a'\
    \x20MultiModelVersionInputExampleResponse\n\n\x0b\n\x03\x04t\x01\x12\x04\
    \xbe\x1b\x08-\n\"\n\x04\x04t\x02\0\x12\x04\xc0\x1b\x02(\x1a\x14\x20statu\
    s\x20of\x20response\n\n\r\n\x05\x04t\x02\0\x06\x12\x04\xc0\x1b\x02\x1c\n\
    \r\n\x05\x04t\x02\0\x01\x12\x04\xc0\x1b\x1d#\n\r\n\x05\x04t\x02\0\x03\
    \x12\x04\xc0\x1b&'\n,\n\x04\x04t\x02\x01\x12\x04\xc2\x1b\x02E\x1a\x1e\
    \x20model\x20input\x20example\x20messages\n\n\r\n\x05\x04t\x02\x01\x04\
    \x12\x04\xc2\x1b\x02\n\n\r\n\x05\x04t\x02\x01\x06\x12\x04\xc2\x1b\x0b#\n\
    \r\n\x05\x04t\x02\x01\x01\x12\x04\xc2\x1b$@\n\r\n\x05\x04t\x02\x01\x03\
    \x12\x04\xc2\x1bCD\n*\n\x02\x04u\x12\x06\xc6\x1b\0\xce\x1b\x01\x1a\x1c\
    \x20ListModelReferencesRequest\n\n\x0b\n\x03\x04u\x01\x12\x04\xc6\x1b\
    \x08\"\n\x0c\n\x04\x04u\x02\0\x12\x04\xc7\x1b\x02,\n\r\n\x05\x04u\x02\0\
    \x06\x12\x04\xc7\x1b\x02\x1b\n\r\n\x05\x04u\x02\0\x01\x12\x04\xc7\x1b\
    \x1c'\n\r\n\x05\x04u\x02\0\x03\x12\x04\xc7\x1b*+\n\x0c\n\x04\x04u\x02\
    \x01\x12\x04\xc9\x1b\x02\x16\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xc9\x1b\
    \x02\x08\n\r\n\x05\x04u\x02\x01\x01\x12\x04\xc9\x1b\t\x11\n\r\n\x05\x04u\
    \x02\x01\x03\x12\x04\xc9\x1b\x14\x15\n(\n\x04\x04u\x02\x02\x12\x04\xcb\
    \x1b\x02\x12\x1a\x1a\x20Optional,\x20defaults\x20to\x201.\n\n\r\n\x05\
    \x04u\x02\x02\x05\x12\x04\xcb\x1b\x02\x08\n\r\n\x05\x04u\x02\x02\x01\x12\
    \x04\xcb\x1b\t\r\n\r\n\x05\x04u\x02\x02\x03\x12\x04\xcb\x1b\x10\x11\n>\n\
    \x04\x04u\x02\x03\x12\x04\xcd\x1b\x02\x16\x1a0\x20Optional,\x20defaults\
    \x20to\x20128\x20references\x20per\x20page.\n\n\r\n\x05\x04u\x02\x03\x05\
    \x12\x04\xcd\x1b\x02\x08\n\r\n\x05\x04u\x02\x03\x01\x12\x04\xcd\x1b\t\
    \x11\n\r\n\x05\x04u\x02\x03\x03\x12\x04\xcd\x1b\x14\x15\n+\n\x02\x04v\
    \x12\x06\xd3\x1b\0\xd6\x1b\x01\x1a\x1d\x20MultiModelReferenceResponse\n\
    \n\x0b\n\x03\x04v\x01\x12\x04\xd3\x1b\x08#\n\x0c\n\x04\x04v\x02\0\x12\
    \x04\xd4\x1b\x02(\n\r\n\x05\x04v\x02\0\x06\x12\x04\xd4\x1b\x02\x1c\n\r\n\
    \x05\x04v\x02\0\x01\x12\x04\xd4\x1b\x1d#\n\r\n\x05\x04v\x02\0\x03\x12\
    \x04\xd4\x1b&'\n\x0c\n\x04\x04v\x02\x01\x12\x04\xd5\x1b\x02/\n\r\n\x05\
    \x04v\x02\x01\x04\x12\x04\xd5\x1b\x02\n\n\r\n\x05\x04v\x02\x01\x06\x12\
    \x04\xd5\x1b\x0b\x19\n\r\n\x05\x04v\x02\x01\x01\x12\x04\xd5\x1b\x1a*\n\r\
    \n\x05\x04v\x02\x01\x03\x12\x04\xd5\x1b-.\n#\n\x02\x04w\x12\x06\xd9\x1b\
    \0\xdc\x1b\x01\x1a\x15\x20MultiOutputResponse\n\n\x0b\n\x03\x04w\x01\x12\
    \x04\xd9\x1b\x08\x1b\n\x0c\n\x04\x04w\x02\0\x12\x04\xda\x1b\x02(\n\r\n\
    \x05\x04w\x02\0\x06\x12\x04\xda\x1b\x02\x1c\n\r\n\x05\x04w\x02\0\x01\x12\
    \x04\xda\x1b\x1d#\n\r\n\x05\x04w\x02\0\x03\x12\x04\xda\x1b&'\n\x0c\n\x04\
    \x04w\x02\x01\x12\x04\xdb\x1b\x02M\n\r\n\x05\x04w\x02\x01\x04\x12\x04\
    \xdb\x1b\x02\n\n\r\n\x05\x04w\x02\x01\x06\x12\x04\xdb\x1b\x0b\x11\n\r\n\
    \x05\x04w\x02\x01\x01\x12\x04\xdb\x1b\x12\x19\n\r\n\x05\x04w\x02\x01\x03\
    \x12\x04\xdb\x1b\x1c\x1d\n\r\n\x05\x04w\x02\x01\x08\x12\x04\xdb\x1b\x1eL\
    \n\x10\n\x08\x04w\x02\x01\x08\xd0\x86\x03\x12\x04\xdb\x1b\x1fK\n!\n\x02\
    \x04x\x12\x06\xdf\x1b\0\xe6\x1b\x01\x1a\x13\x20ListScopesRequest\n\n\x0b\
    \n\x03\x04x\x01\x12\x04\xdf\x1b\x08\x19\n\xc2\x01\n\x04\x04x\x02\0\x12\
    \x04\xe2\x1b\x02\x16\x1a\xb3\x01\x20If\x20\"personal_access_token\"\x20i\
    nclude\x20scopes\x20and\x20endpoints\x20available\x20to\x20personal\x20a\
    ccess\x20tokens.\n\x20If\x20\"api_key\"\x20include\x20scopes\x20and\x20e\
    ndpoints\x20available\x20to\x20app-specific\x20keys.\x20(default)\n\n\r\
    \n\x05\x04x\x02\0\x05\x12\x04\xe2\x1b\x02\x08\n\r\n\x05\x04x\x02\0\x01\
    \x12\x04\xe2\x1b\t\x11\n\r\n\x05\x04x\x02\0\x03\x12\x04\xe2\x1b\x14\x15\
    \no\n\x04\x04x\x02\x01\x12\x04\xe5\x1b\x02,\x1aa\x20For\x20all\x20user\
    \x20specific\x20information\x20we\x20include\x20user_app_id\x20to\x20get\
    \x20the\x20user_id\x20in\x20a\x20consistent\x20way\n\n\r\n\x05\x04x\x02\
    \x01\x06\x12\x04\xe5\x1b\x02\x1b\n\r\n\x05\x04x\x02\x01\x01\x12\x04\xe5\
    \x1b\x1c'\n\r\n\x05\x04x\x02\x01\x03\x12\x04\xe5\x1b*+\n\x1f\n\x02\x04y\
    \x12\x06\xe9\x1b\0\xeb\x1b\x01\x1a\x11\x20MyScopesRequest\n\n\x0b\n\x03\
    \x04y\x01\x12\x04\xe9\x1b\x08\x17\n\x0c\n\x04\x04y\x02\0\x12\x04\xea\x1b\
    \x02,\n\r\n\x05\x04y\x02\0\x06\x12\x04\xea\x1b\x02\x1b\n\r\n\x05\x04y\
    \x02\0\x01\x12\x04\xea\x1b\x1c'\n\r\n\x05\x04y\x02\0\x03\x12\x04\xea\x1b\
    *+\n#\n\x02\x04z\x12\x06\xee\x1b\0\xf0\x1b\x01\x1a\x15\x20MyScopesUserRe\
    quest\n\n\x0b\n\x03\x04z\x01\x12\x04\xee\x1b\x08\x1b\n\x0c\n\x04\x04z\
    \x02\0\x12\x04\xef\x1b\x02,\n\r\n\x05\x04z\x02\0\x06\x12\x04\xef\x1b\x02\
    \x1b\n\r\n\x05\x04z\x02\0\x01\x12\x04\xef\x1b\x1c'\n\r\n\x05\x04z\x02\0\
    \x03\x12\x04\xef\x1b*+\n#\n\x02\x04{\x12\x06\xf3\x1b\0\xf4\x1b\x01\x1a\
    \x15\x20MyScopesRootRequest\n\n\x0b\n\x03\x04{\x01\x12\x04\xf3\x1b\x08\
    \x1b\n&\n\x02\x04|\x12\x06\xf7\x1b\0\x80\x1c\x01\x1a\x18\x20MultiScopeDe\
    psResponse\n\n\x0b\n\x03\x04|\x01\x12\x04\xf7\x1b\x08\x1e\n*\n\x04\x04|\
    \x02\0\x12\x04\xf9\x1b\x02(\x1a\x1c\x20The\x20status\x20of\x20the\x20req\
    uest.\n\n\r\n\x05\x04|\x02\0\x06\x12\x04\xf9\x1b\x02\x1c\n\r\n\x05\x04|\
    \x02\0\x01\x12\x04\xf9\x1b\x1d#\n\r\n\x05\x04|\x02\0\x03\x12\x04\xf9\x1b\
    &'\nL\n\x04\x04|\x02\x01\x12\x04\xfb\x1b\x02$\x1a>\x20scopes\x20is\x20a\
    \x20list\x20of\x20low-level\x20scopes\x20and\x20their\x20dependencies.\n\
    \n\r\n\x05\x04|\x02\x01\x04\x12\x04\xfb\x1b\x02\n\n\r\n\x05\x04|\x02\x01\
    \x06\x12\x04\xfb\x1b\x0b\x14\n\r\n\x05\x04|\x02\x01\x01\x12\x04\xfb\x1b\
    \x15\x1f\n\r\n\x05\x04|\x02\x01\x03\x12\x04\xfb\x1b\"#\n\xc2\x01\n\x04\
    \x04|\x02\x02\x12\x04\xff\x1b\x02*\x1a\xb3\x01\x20endpoint_scopes\x20is\
    \x20a\x20listof\x20all\x20the\x20publicly\x20available\x20endponts\x20wh\
    ich\x20can\x20be\n\x20used\x20as\x20scopes\x20as\x20well.\x20A\x20call\
    \x20to\x20each\x20of\x20those\x20endpoint\x20depends\x20on\x20a\x20subse\
    t\n\x20of\x20the\x20above\x20\"scopes\"\n\n\r\n\x05\x04|\x02\x02\x04\x12\
    \x04\xff\x1b\x02\n\n\r\n\x05\x04|\x02\x02\x06\x12\x04\xff\x1b\x0b\x17\n\
    \r\n\x05\x04|\x02\x02\x01\x12\x04\xff\x1b\x18%\n\r\n\x05\x04|\x02\x02\
    \x03\x12\x04\xff\x1b()\n\"\n\x02\x04}\x12\x06\x83\x1c\0\x8c\x1c\x01\x1a\
    \x14\x20MultiScopeResponse\n\n\x0b\n\x03\x04}\x01\x12\x04\x83\x1c\x08\
    \x1a\n*\n\x04\x04}\x02\0\x12\x04\x85\x1c\x02(\x1a\x1c\x20The\x20status\
    \x20of\x20the\x20request.\n\n\r\n\x05\x04}\x02\0\x06\x12\x04\x85\x1c\x02\
    \x1c\n\r\n\x05\x04}\x02\0\x01\x12\x04\x85\x1c\x1d#\n\r\n\x05\x04}\x02\0\
    \x03\x12\x04\x85\x1c&'\n?\n\x04\x04}\x02\x01\x12\x04\x87\x1c\x02\x1d\x1a\
    1\x20This\x20is\x20a\x20list\x20of\x20the\x20scopes\x20that\x20your\x20k\
    ey\x20has.\n\n\r\n\x05\x04}\x02\x01\x04\x12\x04\x87\x1c\x02\n\n\r\n\x05\
    \x04}\x02\x01\x05\x12\x04\x87\x1c\x0b\x11\n\r\n\x05\x04}\x02\x01\x01\x12\
    \x04\x87\x1c\x12\x18\n\r\n\x05\x04}\x02\x01\x03\x12\x04\x87\x1c\x1b\x1c\
    \n3\n\x04\x04}\x02\x02\x12\x04\x89\x1c\x02\x0e\x1a%\x20The\x20app\x20tha\
    t\x20the\x20key\x20has\x20access\x20to.\n\n\r\n\x05\x04}\x02\x02\x06\x12\
    \x04\x89\x1c\x02\x05\n\r\n\x05\x04}\x02\x02\x01\x12\x04\x89\x1c\x06\t\n\
    \r\n\x05\x04}\x02\x02\x03\x12\x04\x89\x1c\x0c\r\nI\n\x04\x04}\x02\x03\
    \x12\x04\x8b\x1c\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20endpoi\
    nt\x20permissions\x20that\x20your\x20key\x20has.\n\n\r\n\x05\x04}\x02\
    \x03\x04\x12\x04\x8b\x1c\x02\n\n\r\n\x05\x04}\x02\x03\x05\x12\x04\x8b\
    \x1c\x0b\x11\n\r\n\x05\x04}\x02\x03\x01\x12\x04\x8b\x1c\x12\x1b\n\r\n\
    \x05\x04}\x02\x03\x03\x12\x04\x8b\x1c\x1e\x1f\n&\n\x02\x04~\x12\x06\x8f\
    \x1c\0\x96\x1c\x01\x1a\x18\x20MultiScopeUserResponse\n\n\x0b\n\x03\x04~\
    \x01\x12\x04\x8f\x1c\x08\x1e\n*\n\x04\x04~\x02\0\x12\x04\x91\x1c\x02(\
    \x1a\x1c\x20The\x20status\x20of\x20the\x20request.\n\n\r\n\x05\x04~\x02\
    \0\x06\x12\x04\x91\x1c\x02\x1c\n\r\n\x05\x04~\x02\0\x01\x12\x04\x91\x1c\
    \x1d#\n\r\n\x05\x04~\x02\0\x03\x12\x04\x91\x1c&'\n?\n\x04\x04~\x02\x01\
    \x12\x04\x93\x1c\x02\x1d\x1a1\x20This\x20is\x20a\x20list\x20of\x20the\
    \x20scopes\x20that\x20your\x20key\x20has.\n\n\r\n\x05\x04~\x02\x01\x04\
    \x12\x04\x93\x1c\x02\n\n\r\n\x05\x04~\x02\x01\x05\x12\x04\x93\x1c\x0b\
    \x11\n\r\n\x05\x04~\x02\x01\x01\x12\x04\x93\x1c\x12\x18\n\r\n\x05\x04~\
    \x02\x01\x03\x12\x04\x93\x1c\x1b\x1c\nI\n\x04\x04~\x02\x02\x12\x04\x95\
    \x1c\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20endpoint\x20permis\
    sions\x20that\x20your\x20key\x20has.\n\n\r\n\x05\x04~\x02\x02\x04\x12\
    \x04\x95\x1c\x02\n\n\r\n\x05\x04~\x02\x02\x05\x12\x04\x95\x1c\x0b\x11\n\
    \r\n\x05\x04~\x02\x02\x01\x12\x04\x95\x1c\x12\x1b\n\r\n\x05\x04~\x02\x02\
    \x03\x12\x04\x95\x1c\x1e\x1f\n&\n\x02\x04\x7f\x12\x06\x99\x1c\0\xa0\x1c\
    \x01\x1a\x18\x20MultiScopeRootResponse\n\n\x0b\n\x03\x04\x7f\x01\x12\x04\
    \x99\x1c\x08\x1e\n*\n\x04\x04\x7f\x02\0\x12\x04\x9b\x1c\x02(\x1a\x1c\x20\
    The\x20status\x20of\x20the\x20request.\n\n\r\n\x05\x04\x7f\x02\0\x06\x12\
    \x04\x9b\x1c\x02\x1c\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\x9b\x1c\x1d#\n\
    \r\n\x05\x04\x7f\x02\0\x03\x12\x04\x9b\x1c&'\n?\n\x04\x04\x7f\x02\x01\
    \x12\x04\x9d\x1c\x02\x1d\x1a1\x20This\x20is\x20a\x20list\x20of\x20the\
    \x20scopes\x20that\x20your\x20key\x20has.\n\n\r\n\x05\x04\x7f\x02\x01\
    \x04\x12\x04\x9d\x1c\x02\n\n\r\n\x05\x04\x7f\x02\x01\x05\x12\x04\x9d\x1c\
    \x0b\x11\n\r\n\x05\x04\x7f\x02\x01\x01\x12\x04\x9d\x1c\x12\x18\n\r\n\x05\
    \x04\x7f\x02\x01\x03\x12\x04\x9d\x1c\x1b\x1c\nI\n\x04\x04\x7f\x02\x02\
    \x12\x04\x9f\x1c\x02\x20\x1a;\x20This\x20is\x20a\x20list\x20of\x20endpoi\
    nt\x20permissions\x20that\x20your\x20key\x20has.\n\n\r\n\x05\x04\x7f\x02\
    \x02\x04\x12\x04\x9f\x1c\x02\n\n\r\n\x05\x04\x7f\x02\x02\x05\x12\x04\x9f\
    \x1c\x0b\x11\n\r\n\x05\x04\x7f\x02\x02\x01\x12\x04\x9f\x1c\x12\x1b\n\r\n\
    \x05\x04\x7f\x02\x02\x03\x12\x04\x9f\x1c\x1e\x1f\n!\n\x03\x04\x80\x01\
    \x12\x06\xa3\x1c\0\xa6\x1c\x01\x1a\x12\x20GetSearchRequest\n\n\x0c\n\x04\
    \x04\x80\x01\x01\x12\x04\xa3\x1c\x08\x18\n\r\n\x05\x04\x80\x01\x02\0\x12\
    \x04\xa4\x1c\x02,\n\x0e\n\x06\x04\x80\x01\x02\0\x06\x12\x04\xa4\x1c\x02\
    \x1b\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\xa4\x1c\x1c'\n\x0e\n\x06\
    \x04\x80\x01\x02\0\x03\x12\x04\xa4\x1c*+\n\r\n\x05\x04\x80\x01\x02\x01\
    \x12\x04\xa5\x1c\x02\x10\n\x0e\n\x06\x04\x80\x01\x02\x01\x05\x12\x04\xa5\
    \x1c\x02\x08\n\x0e\n\x06\x04\x80\x01\x02\x01\x01\x12\x04\xa5\x1c\t\x0b\n\
    \x0e\n\x06\x04\x80\x01\x02\x01\x03\x12\x04\xa5\x1c\x0e\x0f\n$\n\x03\x04\
    \x81\x01\x12\x06\xa9\x1c\0\xb1\x1c\x01\x1a\x15\x20ListSearchesRequest\n\
    \n\x0c\n\x04\x04\x81\x01\x01\x12\x04\xa9\x1c\x08\x1b\n\r\n\x05\x04\x81\
    \x01\x02\0\x12\x04\xaa\x1c\x02,\n\x0e\n\x06\x04\x81\x01\x02\0\x06\x12\
    \x04\xaa\x1c\x02\x1b\n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\x04\xaa\x1c\
    \x1c'\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xaa\x1c*+\n\x7f\n\x05\
    \x04\x81\x01\x02\x01\x12\x04\xad\x1c\x02\x12\x1ap\x20(optional\x20URL\
    \x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20\
    to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x20\
    1.\n\n\x0e\n\x06\x04\x81\x01\x02\x01\x05\x12\x04\xad\x1c\x02\x08\n\x0e\n\
    \x06\x04\x81\x01\x02\x01\x01\x12\x04\xad\x1c\t\r\n\x0e\n\x06\x04\x81\x01\
    \x02\x01\x03\x12\x04\xad\x1c\x10\x11\nv\n\x05\x04\x81\x01\x02\x02\x12\
    \x04\xb0\x1c\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20nu\
    mber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x81\x01\x02\x02\
    \x05\x12\x04\xb0\x1c\x02\x08\n\x0e\n\x06\x04\x81\x01\x02\x02\x01\x12\x04\
    \xb0\x1c\t\x11\n\x0e\n\x06\x04\x81\x01\x02\x02\x03\x12\x04\xb0\x1c\x14\
    \x15\n$\n\x03\x04\x82\x01\x12\x06\xb4\x1c\0\xc2\x1c\x01\x1a\x15\x20PostS\
    earchesRequest\n\n\x0c\n\x04\x04\x82\x01\x01\x12\x04\xb4\x1c\x08\x1b\n6\
    \n\x05\x04\x82\x01\x02\0\x12\x04\xb6\x1c\x02,\x1a'\x20The\x20user_id\x20\
    and\x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\x82\x01\x02\0\
    \x06\x12\x04\xb6\x1c\x02\x1b\n\x0e\n\x06\x04\x82\x01\x02\0\x01\x12\x04\
    \xb6\x1c\x1c'\n\x0e\n\x06\x04\x82\x01\x02\0\x03\x12\x04\xb6\x1c*+\nk\n\
    \x05\x04\x82\x01\x02\x01\x12\x04\xba\x1c\x02$\x1a\\\x20The\x20query;\x20\
    this\x20specifies\x20how\x20the\x20data\x20to\x20be\x20searched\n\x20thi\
    s\x20will\x20be\x20replaced\x20by\x20\"Searches\"\n\n\x0e\n\x06\x04\x82\
    \x01\x02\x01\x06\x12\x04\xba\x1c\x02\x07\n\x0e\n\x06\x04\x82\x01\x02\x01\
    \x01\x12\x04\xba\x1c\x08\r\n\x0e\n\x06\x04\x82\x01\x02\x01\x03\x12\x04\
    \xba\x1c\x10\x11\n\x0e\n\x06\x04\x82\x01\x02\x01\x08\x12\x04\xba\x1c\x12\
    #\n\x0f\n\x07\x04\x82\x01\x02\x01\x08\x03\x12\x04\xba\x1c\x13\"\n\x85\
    \x01\n\x05\x04\x82\x01\x02\x02\x12\x04\xbe\x1c\x02\x1f\x1av\x20The\x20se\
    arched\x20to\x20be\x20executed\x20or\x20saved\n\x20Eventually\x20the\x20\
    request\x20level\x20fields\x20will\x20be\x20deprecated\x20in\x20favor\
    \x20of\x20this\x20object\n\n\x0e\n\x06\x04\x82\x01\x02\x02\x04\x12\x04\
    \xbe\x1c\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x02\x06\x12\x04\xbe\x1c\x0b\
    \x11\n\x0e\n\x06\x04\x82\x01\x02\x02\x01\x12\x04\xbe\x1c\x12\x1a\n\x0e\n\
    \x06\x04\x82\x01\x02\x02\x03\x12\x04\xbe\x1c\x1d\x1e\nO\n\x05\x04\x82\
    \x01\x02\x03\x12\x04\xc1\x1c\x02\x1c\x1a@\x20Pagination\x20information\
    \x20to\x20paginate\x20through\x20search\x20result\x20Hits.\n\n\x0e\n\x06\
    \x04\x82\x01\x02\x03\x06\x12\x04\xc1\x1c\x02\x0c\n\x0e\n\x06\x04\x82\x01\
    \x02\x03\x01\x12\x04\xc1\x1c\r\x17\n\x0e\n\x06\x04\x82\x01\x02\x03\x03\
    \x12\x04\xc1\x1c\x1a\x1b\n\r\n\x03\x04\x83\x01\x12\x06\xc4\x1c\0\xce\x1c\
    \x01\n\x0c\n\x04\x04\x83\x01\x01\x12\x04\xc4\x1c\x08\"\n6\n\x05\x04\x83\
    \x01\x02\0\x12\x04\xc6\x1c\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\
    \x20to\x20query\x20from.\n\n\x0e\n\x06\x04\x83\x01\x02\0\x06\x12\x04\xc6\
    \x1c\x02\x1b\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\xc6\x1c\x1c'\n\
    \x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xc6\x1c*+\n+\n\x05\x04\x83\x01\
    \x02\x01\x12\x04\xc9\x1c\x02\x1f\x1a\x1c\x20The\x20searches\x20to\x20be\
    \x20patched\n\n\x0e\n\x06\x04\x83\x01\x02\x01\x04\x12\x04\xc9\x1c\x02\n\
    \n\x0e\n\x06\x04\x83\x01\x02\x01\x06\x12\x04\xc9\x1c\x0b\x11\n\x0e\n\x06\
    \x04\x83\x01\x02\x01\x01\x12\x04\xc9\x1c\x12\x1a\n\x0e\n\x06\x04\x83\x01\
    \x02\x01\x03\x12\x04\xc9\x1c\x1d\x1e\nr\n\x05\x04\x83\x01\x02\x02\x12\
    \x04\xcd\x1c\x02\x14\x1ac\x20The\x20action\x20to\x20perform\x20on\x20the\
    \x20patched\x20Search\x20objects\n\x20For\x20now\x20only\x20action\x20'o\
    verwrite'\x20is\x20supported\n\n\x0e\n\x06\x04\x83\x01\x02\x02\x05\x12\
    \x04\xcd\x1c\x02\x08\n\x0e\n\x06\x04\x83\x01\x02\x02\x01\x12\x04\xcd\x1c\
    \t\x0f\n\x0e\n\x06\x04\x83\x01\x02\x02\x03\x12\x04\xcd\x1c\x12\x13\n\r\n\
    \x03\x04\x84\x01\x12\x06\xd0\x1c\0\xda\x1c\x01\n\x0c\n\x04\x04\x84\x01\
    \x01\x12\x04\xd0\x1c\x08'\n6\n\x05\x04\x84\x01\x02\0\x12\x04\xd2\x1c\x02\
    ,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20query\x20from.\n\n\
    \x0e\n\x06\x04\x84\x01\x02\0\x06\x12\x04\xd2\x1c\x02\x1b\n\x0e\n\x06\x04\
    \x84\x01\x02\0\x01\x12\x04\xd2\x1c\x1c'\n\x0e\n\x06\x04\x84\x01\x02\0\
    \x03\x12\x04\xd2\x1c*+\n+\n\x05\x04\x84\x01\x02\x01\x12\x04\xd5\x1c\x02\
    \x1f\x1a\x1c\x20The\x20searches\x20to\x20be\x20patched\n\n\x0e\n\x06\x04\
    \x84\x01\x02\x01\x04\x12\x04\xd5\x1c\x02\n\n\x0e\n\x06\x04\x84\x01\x02\
    \x01\x06\x12\x04\xd5\x1c\x0b\x11\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\x12\
    \x04\xd5\x1c\x12\x1a\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\xd5\x1c\
    \x1d\x1e\nr\n\x05\x04\x84\x01\x02\x02\x12\x04\xd9\x1c\x02\x14\x1ac\x20Th\
    e\x20action\x20to\x20perform\x20on\x20the\x20patched\x20Search\x20object\
    s\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20supported\n\
    \n\x0e\n\x06\x04\x84\x01\x02\x02\x05\x12\x04\xd9\x1c\x02\x08\n\x0e\n\x06\
    \x04\x84\x01\x02\x02\x01\x12\x04\xd9\x1c\t\x0f\n\x0e\n\x06\x04\x84\x01\
    \x02\x02\x03\x12\x04\xd9\x1c\x12\x13\n%\n\x03\x04\x85\x01\x12\x06\xdd\
    \x1c\0\xe7\x1c\x01\x1a\x16\x20PatchSearchesRequest\n\n\x0c\n\x04\x04\x85\
    \x01\x01\x12\x04\xdd\x1c\x08\x1c\n6\n\x05\x04\x85\x01\x02\0\x12\x04\xdf\
    \x1c\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20query\x20from\
    .\n\n\x0e\n\x06\x04\x85\x01\x02\0\x06\x12\x04\xdf\x1c\x02\x1b\n\x0e\n\
    \x06\x04\x85\x01\x02\0\x01\x12\x04\xdf\x1c\x1c'\n\x0e\n\x06\x04\x85\x01\
    \x02\0\x03\x12\x04\xdf\x1c*+\n+\n\x05\x04\x85\x01\x02\x01\x12\x04\xe2\
    \x1c\x02\x1f\x1a\x1c\x20The\x20searches\x20to\x20be\x20patched\n\n\x0e\n\
    \x06\x04\x85\x01\x02\x01\x04\x12\x04\xe2\x1c\x02\n\n\x0e\n\x06\x04\x85\
    \x01\x02\x01\x06\x12\x04\xe2\x1c\x0b\x11\n\x0e\n\x06\x04\x85\x01\x02\x01\
    \x01\x12\x04\xe2\x1c\x12\x1a\n\x0e\n\x06\x04\x85\x01\x02\x01\x03\x12\x04\
    \xe2\x1c\x1d\x1e\nr\n\x05\x04\x85\x01\x02\x02\x12\x04\xe6\x1c\x02\x14\
    \x1ac\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\x20Searc\
    h\x20objects\n\x20For\x20now\x20only\x20action\x20'overwrite'\x20is\x20s\
    upported\n\n\x0e\n\x06\x04\x85\x01\x02\x02\x05\x12\x04\xe6\x1c\x02\x08\n\
    \x0e\n\x06\x04\x85\x01\x02\x02\x01\x12\x04\xe6\x1c\t\x0f\n\x0e\n\x06\x04\
    \x85\x01\x02\x02\x03\x12\x04\xe6\x1c\x12\x13\n`\n\x03\x04\x86\x01\x12\
    \x06\xea\x1c\0\xf2\x1c\x01\x1aQ\x20PostSearchesByIDRequest\x20performs\
    \x20returns\x20results\x20of\x20a\x20saved\x20search\x20given\x20its\x20\
    ID\n\n\x0c\n\x04\x04\x86\x01\x01\x12\x04\xea\x1c\x08\x1f\n\r\n\x05\x04\
    \x86\x01\x02\0\x12\x04\xeb\x1c\x02,\n\x0e\n\x06\x04\x86\x01\x02\0\x06\
    \x12\x04\xeb\x1c\x02\x1b\n\x0e\n\x06\x04\x86\x01\x02\0\x01\x12\x04\xeb\
    \x1c\x1c'\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\x04\xeb\x1c*+\n3\n\x05\
    \x04\x86\x01\x02\x01\x12\x04\xee\x1c\x02\x10\x1a$\x20ID\x20for\x20saves\
    \x20search\x20to\x20be\x20executed\n\n\x0e\n\x06\x04\x86\x01\x02\x01\x05\
    \x12\x04\xee\x1c\x02\x08\n\x0e\n\x06\x04\x86\x01\x02\x01\x01\x12\x04\xee\
    \x1c\t\x0b\n\x0e\n\x06\x04\x86\x01\x02\x01\x03\x12\x04\xee\x1c\x0e\x0f\n\
    O\n\x05\x04\x86\x01\x02\x02\x12\x04\xf1\x1c\x02\x1c\x1a@\x20Pagination\
    \x20information\x20to\x20paginate\x20through\x20search\x20result\x20Hits\
    .\n\n\x0e\n\x06\x04\x86\x01\x02\x02\x06\x12\x04\xf1\x1c\x02\x0c\n\x0e\n\
    \x06\x04\x86\x01\x02\x02\x01\x12\x04\xf1\x1c\r\x17\n\x0e\n\x06\x04\x86\
    \x01\x02\x02\x03\x12\x04\xf1\x1c\x1a\x1b\n$\n\x03\x04\x87\x01\x12\x06\
    \xf5\x1c\0\xf8\x1c\x01\x1a\x15\x20DeleteSearchRequest\n\n\x0c\n\x04\x04\
    \x87\x01\x01\x12\x04\xf5\x1c\x08\x1b\n\r\n\x05\x04\x87\x01\x02\0\x12\x04\
    \xf6\x1c\x02,\n\x0e\n\x06\x04\x87\x01\x02\0\x06\x12\x04\xf6\x1c\x02\x1b\
    \n\x0e\n\x06\x04\x87\x01\x02\0\x01\x12\x04\xf6\x1c\x1c'\n\x0e\n\x06\x04\
    \x87\x01\x02\0\x03\x12\x04\xf6\x1c*+\n\r\n\x05\x04\x87\x01\x02\x01\x12\
    \x04\xf7\x1c\x02\x10\n\x0e\n\x06\x04\x87\x01\x02\x01\x05\x12\x04\xf7\x1c\
    \x02\x08\n\x0e\n\x06\x04\x87\x01\x02\x01\x01\x12\x04\xf7\x1c\t\x0b\n\x0e\
    \n\x06\x04\x87\x01\x02\x01\x03\x12\x04\xf7\x1c\x0e\x0f\n\x87\x01\n\x03\
    \x04\x88\x01\x12\x06\xfd\x1c\0\x86\x1d\x01\x1ax\x20Execute\x20a\x20new\
    \x20annotation\x20search\x20and\x20optionally\x20save\x20it\n\x20annotat\
    ion\x20search\x20over\x20annotations\x20using\x20rank\x20and\x20filter\
    \x20proto\n\n\x0c\n\x04\x04\x88\x01\x01\x12\x04\xfd\x1c\x08&\n6\n\x05\
    \x04\x88\x01\x02\0\x12\x04\xff\x1c\x02,\x1a'\x20The\x20user_id\x20and\
    \x20app_id\x20to\x20query\x20from.\n\n\x0e\n\x06\x04\x88\x01\x02\0\x06\
    \x12\x04\xff\x1c\x02\x1b\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\x04\xff\
    \x1c\x1c'\n\x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\xff\x1c*+\n5\n\x05\
    \x04\x88\x01\x02\x01\x12\x04\x82\x1d\x02\x1f\x1a&\x20The\x20searched\x20\
    to\x20be\x20executed\x20or\x20saved\n\n\x0e\n\x06\x04\x88\x01\x02\x01\
    \x04\x12\x04\x82\x1d\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x01\x06\x12\x04\
    \x82\x1d\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\x01\x01\x12\x04\x82\x1d\x12\
    \x1a\n\x0e\n\x06\x04\x88\x01\x02\x01\x03\x12\x04\x82\x1d\x1d\x1e\nO\n\
    \x05\x04\x88\x01\x02\x02\x12\x04\x85\x1d\x02\x1c\x1a@\x20Pagination\x20i\
    nformation\x20to\x20paginate\x20through\x20search\x20result\x20Hits.\n\n\
    \x0e\n\x06\x04\x88\x01\x02\x02\x06\x12\x04\x85\x1d\x02\x0c\n\x0e\n\x06\
    \x04\x88\x01\x02\x02\x01\x12\x04\x85\x1d\r\x17\n\x0e\n\x06\x04\x88\x01\
    \x02\x02\x03\x12\x04\x85\x1d\x1a\x1b\n5\n\x03\x04\x89\x01\x12\x06\x89\
    \x1d\0\x8c\x1d\x01\x1a&\x20DeleteAnnotationSearchMetricsRequest\n\n\x0c\
    \n\x04\x04\x89\x01\x01\x12\x04\x89\x1d\x08,\n\r\n\x05\x04\x89\x01\x02\0\
    \x12\x04\x8a\x1d\x02,\n\x0e\n\x06\x04\x89\x01\x02\0\x06\x12\x04\x8a\x1d\
    \x02\x1b\n\x0e\n\x06\x04\x89\x01\x02\0\x01\x12\x04\x8a\x1d\x1c'\n\x0e\n\
    \x06\x04\x89\x01\x02\0\x03\x12\x04\x8a\x1d*+\n\r\n\x05\x04\x89\x01\x02\
    \x01\x12\x04\x8b\x1d\x02\x10\n\x0e\n\x06\x04\x89\x01\x02\x01\x05\x12\x04\
    \x8b\x1d\x02\x08\n\x0e\n\x06\x04\x89\x01\x02\x01\x01\x12\x04\x8b\x1d\t\
    \x0b\n\x0e\n\x06\x04\x89\x01\x02\x01\x03\x12\x04\x8b\x1d\x0e\x0f\nB\n\
    \x03\x04\x8a\x01\x12\x06\x8f\x1d\0\x98\x1d\x01\x1a3\x20Execute\x20a\x20n\
    ew\x20input\x20search\x20and\x20optionally\x20save\x20it\n\n\x0c\n\x04\
    \x04\x8a\x01\x01\x12\x04\x8f\x1d\x08!\n6\n\x05\x04\x8a\x01\x02\0\x12\x04\
    \x91\x1d\x02,\x1a'\x20The\x20user_id\x20and\x20app_id\x20to\x20query\x20\
    from.\n\n\x0e\n\x06\x04\x8a\x01\x02\0\x06\x12\x04\x91\x1d\x02\x1b\n\x0e\
    \n\x06\x04\x8a\x01\x02\0\x01\x12\x04\x91\x1d\x1c'\n\x0e\n\x06\x04\x8a\
    \x01\x02\0\x03\x12\x04\x91\x1d*+\n5\n\x05\x04\x8a\x01\x02\x01\x12\x04\
    \x94\x1d\x02\x1f\x1a&\x20The\x20searched\x20to\x20be\x20executed\x20or\
    \x20saved\n\n\x0e\n\x06\x04\x8a\x01\x02\x01\x04\x12\x04\x94\x1d\x02\n\n\
    \x0e\n\x06\x04\x8a\x01\x02\x01\x06\x12\x04\x94\x1d\x0b\x11\n\x0e\n\x06\
    \x04\x8a\x01\x02\x01\x01\x12\x04\x94\x1d\x12\x1a\n\x0e\n\x06\x04\x8a\x01\
    \x02\x01\x03\x12\x04\x94\x1d\x1d\x1e\nO\n\x05\x04\x8a\x01\x02\x02\x12\
    \x04\x97\x1d\x02\x1c\x1a@\x20Pagination\x20information\x20to\x20paginate\
    \x20through\x20search\x20result\x20Hits.\n\n\x0e\n\x06\x04\x8a\x01\x02\
    \x02\x06\x12\x04\x97\x1d\x02\x0c\n\x0e\n\x06\x04\x8a\x01\x02\x02\x01\x12\
    \x04\x97\x1d\r\x17\n\x0e\n\x06\x04\x8a\x01\x02\x02\x03\x12\x04\x97\x1d\
    \x1a\x1b\nZ\n\x03\x04\x8b\x01\x12\x06\x9b\x1d\0\x9f\x1d\x01\x1aK\x20Sing\
    leSearchResponse\x20returns\x20saved\x20search\x20in\x20response\x20to\
    \x20GetSearchRequest\n\n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\x9b\x1d\x08\
    \x1c\n=\n\x05\x04\x8b\x01\x02\0\x12\x04\x9d\x1d\x02(\x1a.\x20Status\x20o\
    f\x20whether\x20the\x20search\x20was\x20successful.\n\n\x0e\n\x06\x04\
    \x8b\x01\x02\0\x06\x12\x04\x9d\x1d\x02\x1c\n\x0e\n\x06\x04\x8b\x01\x02\0\
    \x01\x12\x04\x9d\x1d\x1d#\n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\x9d\
    \x1d&'\n\r\n\x05\x04\x8b\x01\x02\x01\x12\x04\x9e\x1d\x02\x14\n\x0e\n\x06\
    \x04\x8b\x01\x02\x01\x06\x12\x04\x9e\x1d\x02\x08\n\x0e\n\x06\x04\x8b\x01\
    \x02\x01\x01\x12\x04\x9e\x1d\t\x0f\n\x0e\n\x06\x04\x8b\x01\x02\x01\x03\
    \x12\x04\x9e\x1d\x12\x13\n$\n\x03\x04\x8c\x01\x12\x06\xa2\x1d\0\xb1\x1d\
    \x01\x1a\x15\x20MultiSearchResponse\n\n\x0c\n\x04\x04\x8c\x01\x01\x12\
    \x04\xa2\x1d\x08\x1b\n=\n\x05\x04\x8c\x01\x02\0\x12\x04\xa4\x1d\x02(\x1a\
    .\x20Status\x20of\x20whether\x20the\x20search\x20was\x20successful.\n\n\
    \x0e\n\x06\x04\x8c\x01\x02\0\x06\x12\x04\xa4\x1d\x02\x1c\n\x0e\n\x06\x04\
    \x8c\x01\x02\0\x01\x12\x04\xa4\x1d\x1d#\n\x0e\n\x06\x04\x8c\x01\x02\0\
    \x03\x12\x04\xa4\x1d&'\n?\n\x05\x04\x8c\x01\x02\x01\x12\x04\xa7\x1d\x02\
    \x10\x1a0\x20A\x20unique\x20id\x20which\x20uniquely\x20identifies\x20a\
    \x20search\n\n\x0e\n\x06\x04\x8c\x01\x02\x01\x05\x12\x04\xa7\x1d\x02\x08\
    \n\x0e\n\x06\x04\x8c\x01\x02\x01\x01\x12\x04\xa7\x1d\t\x0b\n\x0e\n\x06\
    \x04\x8c\x01\x02\x01\x03\x12\x04\xa7\x1d\x0e\x0f\n0\n\x05\x04\x8c\x01\
    \x02\x02\x12\x04\xaa\x1d\x02G\x1a!\x20The\x20list\x20of\x20search\x20res\
    ult\x20Hits.\n\n\x0e\n\x06\x04\x8c\x01\x02\x02\x04\x12\x04\xaa\x1d\x02\n\
    \n\x0e\n\x06\x04\x8c\x01\x02\x02\x06\x12\x04\xaa\x1d\x0b\x0e\n\x0e\n\x06\
    \x04\x8c\x01\x02\x02\x01\x12\x04\xaa\x1d\x0f\x13\n\x0e\n\x06\x04\x8c\x01\
    \x02\x02\x03\x12\x04\xaa\x1d\x16\x17\n\x0e\n\x06\x04\x8c\x01\x02\x02\x08\
    \x12\x04\xaa\x1d\x18F\n\x11\n\t\x04\x8c\x01\x02\x02\x08\xd0\x86\x03\x12\
    \x04\xaa\x1d\x19E\n<\n\x05\x04\x8c\x01\x02\x03\x12\x04\xad\x1d\x02\x12\
    \x1a-\x20The\x20original\x20query\x20provided\x20in\x20the\x20request.\n\
    \n\x0e\n\x06\x04\x8c\x01\x02\x03\x06\x12\x04\xad\x1d\x02\x07\n\x0e\n\x06\
    \x04\x8c\x01\x02\x03\x01\x12\x04\xad\x1d\x08\r\n\x0e\n\x06\x04\x8c\x01\
    \x02\x03\x03\x12\x04\xad\x1d\x10\x11\n?\n\x05\x04\x8c\x01\x02\x04\x12\
    \x04\xb0\x1d\x02\x1f\x1a0\x20The\x20original\x20Searches\x20provided\x20\
    in\x20the\x20request.\n\n\x0e\n\x06\x04\x8c\x01\x02\x04\x04\x12\x04\xb0\
    \x1d\x02\n\n\x0e\n\x06\x04\x8c\x01\x02\x04\x06\x12\x04\xb0\x1d\x0b\x11\n\
    \x0e\n\x06\x04\x8c\x01\x02\x04\x01\x12\x04\xb0\x1d\x12\x1a\n\x0e\n\x06\
    \x04\x8c\x01\x02\x04\x03\x12\x04\xb0\x1d\x1d\x1e\n3\n\x03\x04\x8d\x01\
    \x12\x06\xb4\x1d\0\xc6\x1d\x01\x1a$\x20PostAnnotationSearchMetricsReques\
    t\n\n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\xb4\x1d\x08*\n\r\n\x05\x04\x8d\
    \x01\x02\0\x12\x04\xb5\x1d\x02,\n\x0e\n\x06\x04\x8d\x01\x02\0\x06\x12\
    \x04\xb5\x1d\x02\x1b\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xb5\x1d\
    \x1c'\n\x0e\n\x06\x04\x8d\x01\x02\0\x03\x12\x04\xb5\x1d*+\nJ\n\x05\x04\
    \x8d\x01\x02\x01\x12\x04\xb8\x1d\x02\x10\x1a;\x20A\x20unique\x20customer\
    \x20facing\x20id\x20to\x20identify\x20this\x20eval\x20request\n\n\x0e\n\
    \x06\x04\x8d\x01\x02\x01\x05\x12\x04\xb8\x1d\x02\x08\n\x0e\n\x06\x04\x8d\
    \x01\x02\x01\x01\x12\x04\xb8\x1d\t\x0b\n\x0e\n\x06\x04\x8d\x01\x02\x01\
    \x03\x12\x04\xb8\x1d\x0e\x0f\n;\n\x05\x04\x8d\x01\x02\x02\x12\x04\xbb\
    \x1d\x02'\x1a,\x20The\x20ground\x20truth\x20we\x20are\x20evaluating\x20a\
    gainst\n\n\x0e\n\x06\x04\x8d\x01\x02\x02\x06\x12\x04\xbb\x1d\x02\x15\n\
    \x0e\n\x06\x04\x8d\x01\x02\x02\x01\x12\x04\xbb\x1d\x16\"\n\x0e\n\x06\x04\
    \x8d\x01\x02\x02\x03\x12\x04\xbb\x1d%&\n*\n\x05\x04\x8d\x01\x02\x03\x12\
    \x04\xbe\x1d\x02)\x1a\x1b\x20The\x20set\x20we\x20are\x20evaluating\n\n\
    \x0e\n\x06\x04\x8d\x01\x02\x03\x06\x12\x04\xbe\x1d\x02\x15\n\x0e\n\x06\
    \x04\x8d\x01\x02\x03\x01\x12\x04\xbe\x1d\x16$\n\x0e\n\x06\x04\x8d\x01\
    \x02\x03\x03\x12\x04\xbe\x1d'(\ny\n\x05\x04\x8d\x01\x02\x04\x12\x04\xc2\
    \x1d\x02\x10\x1aj\x20List\x20of\x20concepts\x20to\x20evaluate\x20are\x20\
    expected\x20to\x20be\x20in\x20data.concepts\n\x20If\x20nil,\x20then\x20a\
    ll\x20app\x20concepts\x20are\x20used\n\n\x0e\n\x06\x04\x8d\x01\x02\x04\
    \x06\x12\x04\xc2\x1d\x02\x06\n\x0e\n\x06\x04\x8d\x01\x02\x04\x01\x12\x04\
    \xc2\x1d\x07\x0b\n\x0e\n\x06\x04\x8d\x01\x02\x04\x03\x12\x04\xc2\x1d\x0e\
    \x0f\n.\n\x05\x04\x8d\x01\x02\x05\x12\x04\xc5\x1d\x02%\x1a\x1f\x20The\
    \x20type\x20of\x20evaluation\x20to\x20use\n\n\x0e\n\x06\x04\x8d\x01\x02\
    \x05\x06\x12\x04\xc5\x1d\x02\x10\n\x0e\n\x06\x04\x8d\x01\x02\x05\x01\x12\
    \x04\xc5\x1d\x11\x20\n\x0e\n\x06\x04\x8d\x01\x02\x05\x03\x12\x04\xc5\x1d\
    #$\n2\n\x03\x04\x8e\x01\x12\x06\xc9\x1d\0\xce\x1d\x01\x1a#\x20GetAnnotat\
    ionSearchMetricsRequest\n\n\x0c\n\x04\x04\x8e\x01\x01\x12\x04\xc9\x1d\
    \x08)\n\r\n\x05\x04\x8e\x01\x02\0\x12\x04\xca\x1d\x02,\n\x0e\n\x06\x04\
    \x8e\x01\x02\0\x06\x12\x04\xca\x1d\x02\x1b\n\x0e\n\x06\x04\x8e\x01\x02\0\
    \x01\x12\x04\xca\x1d\x1c'\n\x0e\n\x06\x04\x8e\x01\x02\0\x03\x12\x04\xca\
    \x1d*+\nH\n\x05\x04\x8e\x01\x02\x01\x12\x04\xcd\x1d\x02\x10\x1a9\x20Uniq\
    ue\x20custom\x20facing\x20id\x20that\x20identifies\x20the\x20eval\x20to\
    \x20get\n\n\x0e\n\x06\x04\x8e\x01\x02\x01\x05\x12\x04\xcd\x1d\x02\x08\n\
    \x0e\n\x06\x04\x8e\x01\x02\x01\x01\x12\x04\xcd\x1d\t\x0b\n\x0e\n\x06\x04\
    \x8e\x01\x02\x01\x03\x12\x04\xcd\x1d\x0e\x0f\n3\n\x03\x04\x8f\x01\x12\
    \x06\xd1\x1d\0\xd3\x1d\x01\x1a$\x20ListAnnotationSearchMetricsRequest\n\
    \n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\xd1\x1d\x08*\n\r\n\x05\x04\x8f\x01\
    \x02\0\x12\x04\xd2\x1d\x02,\n\x0e\n\x06\x04\x8f\x01\x02\0\x06\x12\x04\
    \xd2\x1d\x02\x1b\n\x0e\n\x06\x04\x8f\x01\x02\0\x01\x12\x04\xd2\x1d\x1c'\
    \n\x0e\n\x06\x04\x8f\x01\x02\0\x03\x12\x04\xd2\x1d*+\n5\n\x03\x04\x90\
    \x01\x12\x06\xd6\x1d\0\xda\x1d\x01\x1a&\x20MultiAnnotationSearchMetricsR\
    esponse\n\n\x0c\n\x04\x04\x90\x01\x01\x12\x04\xd6\x1d\x08,\n&\n\x05\x04\
    \x90\x01\x02\0\x12\x04\xd8\x1d\x02(\x1a\x17\x20Status\x20of\x20the\x20re\
    quest\n\n\x0e\n\x06\x04\x90\x01\x02\0\x06\x12\x04\xd8\x1d\x02\x1c\n\x0e\
    \n\x06\x04\x90\x01\x02\0\x01\x12\x04\xd8\x1d\x1d#\n\x0e\n\x06\x04\x90\
    \x01\x02\0\x03\x12\x04\xd8\x1d&'\n\r\n\x05\x04\x90\x01\x02\x01\x12\x04\
    \xd9\x1d\x02A\n\x0e\n\x06\x04\x90\x01\x02\x01\x04\x12\x04\xd9\x1d\x02\n\
    \n\x0e\n\x06\x04\x90\x01\x02\x01\x06\x12\x04\xd9\x1d\x0b\"\n\x0e\n\x06\
    \x04\x90\x01\x02\x01\x01\x12\x04\xd9\x1d#<\n\x0e\n\x06\x04\x90\x01\x02\
    \x01\x03\x12\x04\xd9\x1d?@\n,\n\x03\x04\x91\x01\x12\x06\x92\x1e\0\x96\
    \x1e\x01\x1a\x1d\x20PostValidatePasswordRequest\n\n\x0c\n\x04\x04\x91\
    \x01\x01\x12\x04\x92\x1e\x08#\n\r\n\x05\x04\x91\x01\x02\0\x12\x04\x93\
    \x1e\x02,\n\x0e\n\x06\x04\x91\x01\x02\0\x06\x12\x04\x93\x1e\x02\x1b\n\
    \x0e\n\x06\x04\x91\x01\x02\0\x01\x12\x04\x93\x1e\x1c'\n\x0e\n\x06\x04\
    \x91\x01\x02\0\x03\x12\x04\x93\x1e*+\n)\n\x05\x04\x91\x01\x02\x01\x12\
    \x04\x95\x1e\x02\x18\x1a\x1a\x20password\x20to\x20be\x20validated\n\n\
    \x0e\n\x06\x04\x91\x01\x02\x01\x06\x12\x04\x95\x1e\x02\n\n\x0e\n\x06\x04\
    \x91\x01\x02\x01\x01\x12\x04\x95\x1e\x0b\x13\n\x0e\n\x06\x04\x91\x01\x02\
    \x01\x03\x12\x04\x95\x1e\x16\x17\n1\n\x03\x04\x92\x01\x12\x06\x99\x1e\0\
    \x9d\x1e\x01\x1a\"\x20SinglePasswordValidationResponse\n\n\x0c\n\x04\x04\
    \x92\x01\x01\x12\x04\x99\x1e\x08(\n.\n\x05\x04\x92\x01\x02\0\x12\x04\x9b\
    \x1e\x02(\x1a\x1f\x20Standard\x20clarifai\x20status\x20code\n\n\x0e\n\
    \x06\x04\x92\x01\x02\0\x06\x12\x04\x9b\x1e\x02\x1c\n\x0e\n\x06\x04\x92\
    \x01\x02\0\x01\x12\x04\x9b\x1e\x1d#\n\x0e\n\x06\x04\x92\x01\x02\0\x03\
    \x12\x04\x9b\x1e&'\n\r\n\x05\x04\x92\x01\x02\x01\x12\x04\x9c\x1e\x02-\n\
    \x0e\n\x06\x04\x92\x01\x02\x01\x06\x12\x04\x9c\x1e\x02\x14\n\x0e\n\x06\
    \x04\x92\x01\x02\x01\x01\x12\x04\x9c\x1e\x15(\n\x0e\n\x06\x04\x92\x01\
    \x02\x01\x03\x12\x04\x9c\x1e+,\n\x0c\n\x02\x05\0\x12\x06\xb5\x1e\0\xbc\
    \x1e\x01\n\x0b\n\x03\x05\0\x01\x12\x04\xb5\x1e\x05!\n\x0c\n\x04\x05\0\
    \x02\0\x12\x04\xb6\x1e\x02\x0e\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xb6\x1e\
    \x02\t\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xb6\x1e\x0c\r\n\x0c\n\x04\x05\0\
    \x02\x01\x12\x04\xb7\x1e\x02\x0e\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xb7\
    \x1e\x02\t\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xb7\x1e\x0c\r\n\x0c\n\x04\
    \x05\0\x02\x02\x12\x04\xb8\x1e\x02\x0f\n\r\n\x05\x05\0\x02\x02\x01\x12\
    \x04\xb8\x1e\x02\n\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xb8\x1e\r\x0e\n\
    \x0c\n\x04\x05\0\x02\x03\x12\x04\xb9\x1e\x02\x10\n\r\n\x05\x05\0\x02\x03\
    \x01\x12\x04\xb9\x1e\x02\x0b\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\xb9\x1e\
    \x0e\x0f\n\x0c\n\x04\x05\0\x02\x04\x12\x04\xba\x1e\x02\x0f\n\r\n\x05\x05\
    \0\x02\x04\x01\x12\x04\xba\x1e\x02\n\n\r\n\x05\x05\0\x02\x04\x02\x12\x04\
    \xba\x1e\r\x0e\n\x0c\n\x04\x05\0\x02\x05\x12\x04\xbb\x1e\x02\x0e\n\r\n\
    \x05\x05\0\x02\x05\x01\x12\x04\xbb\x1e\x02\t\n\r\n\x05\x05\0\x02\x05\x02\
    \x12\x04\xbb\x1e\x0c\r\n#\n\x03\x04\x93\x01\x12\x06\xf0\x1e\0\xff\x1e\
    \x01\x1a\x14\x20GetWorkflowRequest\n\n\x0c\n\x04\x04\x93\x01\x01\x12\x04\
    \xf0\x1e\x08\x1a\n\r\n\x05\x04\x93\x01\x02\0\x12\x04\xf1\x1e\x02,\n\x0e\
    \n\x06\x04\x93\x01\x02\0\x06\x12\x04\xf1\x1e\x02\x1b\n\x0e\n\x06\x04\x93\
    \x01\x02\0\x01\x12\x04\xf1\x1e\x1c'\n\x0e\n\x06\x04\x93\x01\x02\0\x03\
    \x12\x04\xf1\x1e*+\n\xc9\x01\n\x05\x04\x93\x01\x02\x01\x12\x04\xf6\x1e\
    \x02\x19\x1a\xb9\x01\x20Workflow\x20ID\x20to\x20retrieve\n\x20If\x20no\
    \x20ID\x20is\x20specified\x20we\x20return\x20default\x20workflow\x20of\
    \x20the\x20application\n\x20If\x20an\x20ID\x20is\x20specified\x20by\x20d\
    efault\x20we\x20first\x20looks\x20into\x20Clarifai\x20workflows\x20for\
    \x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\x93\x01\x02\x01\x05\x12\x04\
    \xf6\x1e\x02\x08\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\x04\xf6\x1e\t\
    \x14\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\xf6\x1e\x17\x18\n`\n\
    \x05\x04\x93\x01\x02\x02\x12\x04\xf9\x1e\x02$\x1aQ\x20Use\x20this\x20fla\
    g\x20to\x20look\x20into\x20clarifai\x20published\x20workflows\x20first\
    \x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\x93\x01\x02\x02\x05\x12\
    \x04\xf9\x1e\x02\x06\n\x0e\n\x06\x04\x93\x01\x02\x02\x01\x12\x04\xf9\x1e\
    \x07\x1f\n\x0e\n\x06\x04\x93\x01\x02\x02\x03\x12\x04\xf9\x1e\"#\n\x83\
    \x01\n\x05\x04\x93\x01\x02\x03\x12\x04\xfb\x1e\x02(\x1at\x20(optional\
    \x20URL\x20parameter)\x20List\x20of\x20additional\x20fields\x20to\x20be\
    \x20included\x20in\x20the\x20response.\x20Currently\x20supported:\x20all\
    ,\x20stars\n\n\x0e\n\x06\x04\x93\x01\x02\x03\x04\x12\x04\xfb\x1e\x02\n\n\
    \x0e\n\x06\x04\x93\x01\x02\x03\x05\x12\x04\xfb\x1e\x0b\x11\n\x0e\n\x06\
    \x04\x93\x01\x02\x03\x01\x12\x04\xfb\x1e\x12#\n\x0e\n\x06\x04\x93\x01\
    \x02\x03\x03\x12\x04\xfb\x1e&'\nE\n\x05\x04\x93\x01\x02\x04\x12\x04\xfe\
    \x1e\x02&\x1a6\x20if\x20true\x20will\x20not\x20expand\x20search\x20to\
    \x20clarifai\x20workflows\n\n\x0e\n\x06\x04\x93\x01\x02\x04\x05\x12\x04\
    \xfe\x1e\x02\x06\n\x0e\n\x06\x04\x93\x01\x02\x04\x01\x12\x04\xfe\x1e\x07\
    !\n\x0e\n\x06\x04\x93\x01\x02\x04\x03\x12\x04\xfe\x1e$%\n%\n\x03\x04\x94\
    \x01\x12\x06\x82\x1f\0\xa1\x1f\x01\x1a\x16\x20ListWorkflowsRequest\n\n\
    \x0c\n\x04\x04\x94\x01\x01\x12\x04\x82\x1f\x08\x1c\n\r\n\x05\x04\x94\x01\
    \x02\0\x12\x04\x83\x1f\x02,\n\x0e\n\x06\x04\x94\x01\x02\0\x06\x12\x04\
    \x83\x1f\x02\x1b\n\x0e\n\x06\x04\x94\x01\x02\0\x01\x12\x04\x83\x1f\x1c'\
    \n\x0e\n\x06\x04\x94\x01\x02\0\x03\x12\x04\x83\x1f*+\n\x7f\n\x05\x04\x94\
    \x01\x02\x01\x12\x04\x86\x1f\x02\x12\x1ap\x20(optional\x20URL\x20paramet\
    er)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\x94\x01\x02\x01\x05\x12\x04\x86\x1f\x02\x08\n\x0e\n\x06\x04\
    \x94\x01\x02\x01\x01\x12\x04\x86\x1f\t\r\n\x0e\n\x06\x04\x94\x01\x02\x01\
    \x03\x12\x04\x86\x1f\x10\x11\nv\n\x05\x04\x94\x01\x02\x02\x12\x04\x89\
    \x1f\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x94\x01\x02\x02\x05\x12\
    \x04\x89\x1f\x02\x08\n\x0e\n\x06\x04\x94\x01\x02\x02\x01\x12\x04\x89\x1f\
    \t\x11\n\x0e\n\x06\x04\x94\x01\x02\x02\x03\x12\x04\x89\x1f\x14\x15\np\n\
    \x05\x04\x94\x01\x02\x03\x12\x04\x8d\x1f\x02\x1a\x1aa\x20Sorting\x20opti\
    ons:\n\x20Whether\x20to\x20sort\x20in\x20ascending\x20order.\x20If\x20fa\
    lse,\x20will\x20order\x20in\x20descending\x20order.\n\n\x0e\n\x06\x04\
    \x94\x01\x02\x03\x05\x12\x04\x8d\x1f\x02\x06\n\x0e\n\x06\x04\x94\x01\x02\
    \x03\x01\x12\x04\x8d\x1f\x07\x15\n\x0e\n\x06\x04\x94\x01\x02\x03\x03\x12\
    \x04\x8d\x1f\x18\x19\n\x0f\n\x05\x04\x94\x01\x08\0\x12\x06\x8e\x1f\x02\
    \x94\x1f\x03\n\x0e\n\x06\x04\x94\x01\x08\0\x01\x12\x04\x8e\x1f\x08\x0f\n\
    -\n\x05\x04\x94\x01\x02\x04\x12\x04\x90\x1f\x04\x18\x1a\x1e\x20Whether\
    \x20to\x20order\x20by\x20the\x20name\n\n\x0e\n\x06\x04\x94\x01\x02\x04\
    \x05\x12\x04\x90\x1f\x04\x08\n\x0e\n\x06\x04\x94\x01\x02\x04\x01\x12\x04\
    \x90\x1f\t\x13\n\x0e\n\x06\x04\x94\x01\x02\x04\x03\x12\x04\x90\x1f\x16\
    \x17\n|\n\x05\x04\x94\x01\x02\x05\x12\x04\x93\x1f\x04!\x1am\x20Whether\
    \x20to\x20order\x20by\x20the\x20modified_at\x20time.\n\x20If\x20neither\
    \x20sort\x20option\x20is\x20set\x20to\x20true,\x20will\x20sort\x20by\x20\
    modified_at.\n\n\x0e\n\x06\x04\x94\x01\x02\x05\x05\x12\x04\x93\x1f\x04\
    \x08\n\x0e\n\x06\x04\x94\x01\x02\x05\x01\x12\x04\x93\x1f\t\x1c\n\x0e\n\
    \x06\x04\x94\x01\x02\x05\x03\x12\x04\x93\x1f\x1f\x20\nZ\n\x05\x04\x94\
    \x01\x02\x06\x12\x04\x97\x1f\x02\x13\x1aK\x20Query\x20various\x20text\
    \x20fields\x20that\x20can\x20contain\x20the\x20words\x20in\x20the\x20que\
    ry\x20string.\n\n\x0e\n\x06\x04\x94\x01\x02\x06\x05\x12\x04\x97\x1f\x02\
    \x08\n\x0e\n\x06\x04\x94\x01\x02\x06\x01\x12\x04\x97\x1f\t\x0e\n\x0e\n\
    \x06\x04\x94\x01\x02\x06\x03\x12\x04\x97\x1f\x11\x12\n\x9d\x01\n\x05\x04\
    \x94\x01\x02\x07\x12\x04\x9a\x1f\x02$\x1a\x8d\x01\x20Filter\x20by\x20the\
    \x20id\x20of\x20the\x20workflow.\x20This\x20supports\x20wilcard\x20queri\
    es\x20like\x20\"gen*\"\x20to\x20match\x20\"general\"\x20as\x20an\x20exam\
    ple.\n\x20Deprecated\x20in\x20favor\x20of\x20query\n\n\x0e\n\x06\x04\x94\
    \x01\x02\x07\x05\x12\x04\x9a\x1f\x02\x08\n\x0e\n\x06\x04\x94\x01\x02\x07\
    \x01\x12\x04\x9a\x1f\t\x0b\n\x0e\n\x06\x04\x94\x01\x02\x07\x03\x12\x04\
    \x9a\x1f\x0e\x0f\n\x0e\n\x06\x04\x94\x01\x02\x07\x08\x12\x04\x9a\x1f\x10\
    #\n\x0f\n\x07\x04\x94\x01\x02\x07\x08\x03\x12\x04\x9a\x1f\x11\"\nX\n\x05\
    \x04\x94\x01\x02\x08\x12\x04\x9c\x1f\x02\x19\x1aI\x20If\x20true,\x20we\
    \x20only\x20return\x20workflows\x20that\x20are\x20handpicked\x20by\x20cl\
    arifai\x20staff\n\n\x0e\n\x06\x04\x94\x01\x02\x08\x05\x12\x04\x9c\x1f\
    \x02\x06\n\x0e\n\x06\x04\x94\x01\x02\x08\x01\x12\x04\x9c\x1f\x07\x14\n\
    \x0e\n\x06\x04\x94\x01\x02\x08\x03\x12\x04\x9c\x1f\x17\x18\nZ\n\x05\x04\
    \x94\x01\x02\t\x12\x04\x9e\x1f\x02\x19\x1aK\x20If\x20true,\x20we\x20only\
    \x20return\x20workflows\x20that\x20are\x20starred\x20by\x20the\x20reques\
    ting\x20user\n\n\x0e\n\x06\x04\x94\x01\x02\t\x05\x12\x04\x9e\x1f\x02\x06\
    \n\x0e\n\x06\x04\x94\x01\x02\t\x01\x12\x04\x9e\x1f\x07\x13\n\x0e\n\x06\
    \x04\x94\x01\x02\t\x03\x12\x04\x9e\x1f\x16\x18\n\x83\x01\n\x05\x04\x94\
    \x01\x02\n\x12\x04\xa0\x1f\x02)\x1at\x20(optional\x20URL\x20parameter)\
    \x20List\x20of\x20additional\x20fields\x20to\x20be\x20included\x20in\x20\
    the\x20response.\x20Currently\x20supported:\x20all,\x20stars\n\n\x0e\n\
    \x06\x04\x94\x01\x02\n\x04\x12\x04\xa0\x1f\x02\n\n\x0e\n\x06\x04\x94\x01\
    \x02\n\x05\x12\x04\xa0\x1f\x0b\x11\n\x0e\n\x06\x04\x94\x01\x02\n\x01\x12\
    \x04\xa0\x1f\x12#\n\x0e\n\x06\x04\x94\x01\x02\n\x03\x12\x04\xa0\x1f&(\n%\
    \n\x03\x04\x95\x01\x12\x06\xa5\x1f\0\xa8\x1f\x01\x1a\x16\x20PostWorkflow\
    sRequest\n\n\x0c\n\x04\x04\x95\x01\x01\x12\x04\xa5\x1f\x08\x1c\n\r\n\x05\
    \x04\x95\x01\x02\0\x12\x04\xa6\x1f\x02,\n\x0e\n\x06\x04\x95\x01\x02\0\
    \x06\x12\x04\xa6\x1f\x02\x1b\n\x0e\n\x06\x04\x95\x01\x02\0\x01\x12\x04\
    \xa6\x1f\x1c'\n\x0e\n\x06\x04\x95\x01\x02\0\x03\x12\x04\xa6\x1f*+\n\r\n\
    \x05\x04\x95\x01\x02\x01\x12\x04\xa7\x1f\x02\"\n\x0e\n\x06\x04\x95\x01\
    \x02\x01\x04\x12\x04\xa7\x1f\x02\n\n\x0e\n\x06\x04\x95\x01\x02\x01\x06\
    \x12\x04\xa7\x1f\x0b\x13\n\x0e\n\x06\x04\x95\x01\x02\x01\x01\x12\x04\xa7\
    \x1f\x14\x1d\n\x0e\n\x06\x04\x95\x01\x02\x01\x03\x12\x04\xa7\x1f\x20!\n&\
    \n\x03\x04\x96\x01\x12\x06\xab\x1f\0\xb2\x1f\x01\x1a\x17\x20PatchWorkflo\
    wsRequest\n\n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xab\x1f\x08\x1d\n\r\n\
    \x05\x04\x96\x01\x02\0\x12\x04\xac\x1f\x02,\n\x0e\n\x06\x04\x96\x01\x02\
    \0\x06\x12\x04\xac\x1f\x02\x1b\n\x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\
    \xac\x1f\x1c'\n\x0e\n\x06\x04\x96\x01\x02\0\x03\x12\x04\xac\x1f*+\n\r\n\
    \x05\x04\x96\x01\x02\x01\x12\x04\xad\x1f\x02\"\n\x0e\n\x06\x04\x96\x01\
    \x02\x01\x04\x12\x04\xad\x1f\x02\n\n\x0e\n\x06\x04\x96\x01\x02\x01\x06\
    \x12\x04\xad\x1f\x0b\x13\n\x0e\n\x06\x04\x96\x01\x02\x01\x01\x12\x04\xad\
    \x1f\x14\x1d\n\x0e\n\x06\x04\x96\x01\x02\x01\x03\x12\x04\xad\x1f\x20!\n\
    \x7f\n\x05\x04\x96\x01\x02\x02\x12\x04\xb1\x1f\x02\x14\x1ap\x20The\x20ac\
    tion\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\
    \x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20sup\
    ported\n\n\x0e\n\x06\x04\x96\x01\x02\x02\x05\x12\x04\xb1\x1f\x02\x08\n\
    \x0e\n\x06\x04\x96\x01\x02\x02\x01\x12\x04\xb1\x1f\t\x0f\n\x0e\n\x06\x04\
    \x96\x01\x02\x02\x03\x12\x04\xb1\x1f\x12\x13\n&\n\x03\x04\x97\x01\x12\
    \x06\xb5\x1f\0\xb8\x1f\x01\x1a\x17\x20DeleteWorkflowRequest\n\n\x0c\n\
    \x04\x04\x97\x01\x01\x12\x04\xb5\x1f\x08\x1d\n\r\n\x05\x04\x97\x01\x02\0\
    \x12\x04\xb6\x1f\x02,\n\x0e\n\x06\x04\x97\x01\x02\0\x06\x12\x04\xb6\x1f\
    \x02\x1b\n\x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\xb6\x1f\x1c'\n\x0e\n\
    \x06\x04\x97\x01\x02\0\x03\x12\x04\xb6\x1f*+\n\r\n\x05\x04\x97\x01\x02\
    \x01\x12\x04\xb7\x1f\x02\x19\n\x0e\n\x06\x04\x97\x01\x02\x01\x05\x12\x04\
    \xb7\x1f\x02\x08\n\x0e\n\x06\x04\x97\x01\x02\x01\x01\x12\x04\xb7\x1f\t\
    \x14\n\x0e\n\x06\x04\x97\x01\x02\x01\x03\x12\x04\xb7\x1f\x17\x18\nE\n\
    \x03\x04\x98\x01\x12\x06\xbb\x1f\0\xbf\x1f\x01\x1a6\x20Request\x20to\x20\
    delete\x20several\x20things\x20by\x20the\x20list\x20of\x20ids.\n\n\x0c\n\
    \x04\x04\x98\x01\x01\x12\x04\xbb\x1f\x08\x1e\n\r\n\x05\x04\x98\x01\x02\0\
    \x12\x04\xbc\x1f\x02,\n\x0e\n\x06\x04\x98\x01\x02\0\x06\x12\x04\xbc\x1f\
    \x02\x1b\n\x0e\n\x06\x04\x98\x01\x02\0\x01\x12\x04\xbc\x1f\x1c'\n\x0e\n\
    \x06\x04\x98\x01\x02\0\x03\x12\x04\xbc\x1f*+\n\r\n\x05\x04\x98\x01\x02\
    \x01\x12\x04\xbd\x1f\x02\x1a\n\x0e\n\x06\x04\x98\x01\x02\x01\x04\x12\x04\
    \xbd\x1f\x02\n\n\x0e\n\x06\x04\x98\x01\x02\x01\x05\x12\x04\xbd\x1f\x0b\
    \x11\n\x0e\n\x06\x04\x98\x01\x02\x01\x01\x12\x04\xbd\x1f\x12\x15\n\x0e\n\
    \x06\x04\x98\x01\x02\x01\x03\x12\x04\xbd\x1f\x18\x19\n\r\n\x05\x04\x98\
    \x01\x02\x02\x12\x04\xbe\x1f\x02\x16\n\x0e\n\x06\x04\x98\x01\x02\x02\x05\
    \x12\x04\xbe\x1f\x02\x06\n\x0e\n\x06\x04\x98\x01\x02\x02\x01\x12\x04\xbe\
    \x1f\x07\x11\n\x0e\n\x06\x04\x98\x01\x02\x02\x03\x12\x04\xbe\x1f\x14\x15\
    \n'\n\x03\x04\x99\x01\x12\x06\xc2\x1f\0\xc5\x1f\x01\x1a\x18\x20SingleWor\
    kflowResponse\n\n\x0c\n\x04\x04\x99\x01\x01\x12\x04\xc2\x1f\x08\x1e\n\r\
    \n\x05\x04\x99\x01\x02\0\x12\x04\xc3\x1f\x02(\n\x0e\n\x06\x04\x99\x01\
    \x02\0\x06\x12\x04\xc3\x1f\x02\x1c\n\x0e\n\x06\x04\x99\x01\x02\0\x01\x12\
    \x04\xc3\x1f\x1d#\n\x0e\n\x06\x04\x99\x01\x02\0\x03\x12\x04\xc3\x1f&'\n\
    \r\n\x05\x04\x99\x01\x02\x01\x12\x04\xc4\x1f\x02\x18\n\x0e\n\x06\x04\x99\
    \x01\x02\x01\x06\x12\x04\xc4\x1f\x02\n\n\x0e\n\x06\x04\x99\x01\x02\x01\
    \x01\x12\x04\xc4\x1f\x0b\x13\n\x0e\n\x06\x04\x99\x01\x02\x01\x03\x12\x04\
    \xc4\x1f\x16\x17\n&\n\x03\x04\x9a\x01\x12\x06\xc8\x1f\0\xcb\x1f\x01\x1a\
    \x17\x20MultiWorkflowResponse\n\n\x0c\n\x04\x04\x9a\x01\x01\x12\x04\xc8\
    \x1f\x08\x1d\n\r\n\x05\x04\x9a\x01\x02\0\x12\x04\xc9\x1f\x02(\n\x0e\n\
    \x06\x04\x9a\x01\x02\0\x06\x12\x04\xc9\x1f\x02\x1c\n\x0e\n\x06\x04\x9a\
    \x01\x02\0\x01\x12\x04\xc9\x1f\x1d#\n\x0e\n\x06\x04\x9a\x01\x02\0\x03\
    \x12\x04\xc9\x1f&'\n\r\n\x05\x04\x9a\x01\x02\x01\x12\x04\xca\x1f\x02Q\n\
    \x0e\n\x06\x04\x9a\x01\x02\x01\x04\x12\x04\xca\x1f\x02\n\n\x0e\n\x06\x04\
    \x9a\x01\x02\x01\x06\x12\x04\xca\x1f\x0b\x13\n\x0e\n\x06\x04\x9a\x01\x02\
    \x01\x01\x12\x04\xca\x1f\x14\x1d\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\x12\
    \x04\xca\x1f\x20!\n\x0e\n\x06\x04\x9a\x01\x02\x01\x08\x12\x04\xca\x1f\"P\
    \n\x11\n\t\x04\x9a\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xca\x1f#O\n+\n\
    \x03\x04\x9b\x01\x12\x06\xce\x1f\0\xea\x1f\x01\x1a\x1c\x20PostWorkflowRe\
    sultsRequest\n\n\x0c\n\x04\x04\x9b\x01\x01\x12\x04\xce\x1f\x08\"\n\r\n\
    \x05\x04\x9b\x01\x02\0\x12\x04\xcf\x1f\x02,\n\x0e\n\x06\x04\x9b\x01\x02\
    \0\x06\x12\x04\xcf\x1f\x02\x1b\n\x0e\n\x06\x04\x9b\x01\x02\0\x01\x12\x04\
    \xcf\x1f\x1c'\n\x0e\n\x06\x04\x9b\x01\x02\0\x03\x12\x04\xcf\x1f*+\n\xc9\
    \x01\n\x05\x04\x9b\x01\x02\x01\x12\x04\xd4\x1f\x02\x19\x1a\xb9\x01\x20Wo\
    rkflow\x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\x20is\x20specified\
    \x20we\x20return\x20default\x20workflow\x20of\x20the\x20application\n\
    \x20If\x20an\x20ID\x20is\x20specified\x20by\x20default\x20we\x20first\
    \x20looks\x20into\x20Clarifai\x20workflows\x20for\x20a\x20Workflow\x20ID\
    \n\n\x0e\n\x06\x04\x9b\x01\x02\x01\x05\x12\x04\xd4\x1f\x02\x08\n\x0e\n\
    \x06\x04\x9b\x01\x02\x01\x01\x12\x04\xd4\x1f\t\x14\n\x0e\n\x06\x04\x9b\
    \x01\x02\x01\x03\x12\x04\xd4\x1f\x17\x18\nh\n\x05\x04\x9b\x01\x02\x02\
    \x12\x04\xd8\x1f\x02\x18\x1aY\x20Workflow\x20version\x20ID\x20to\x20retr\
    ieve\n\x20If\x20no\x20ID\x20is\x20specified,\x20latest\x20workflow\x20ve\
    rsion\x20is\x20used\n\n\x0e\n\x06\x04\x9b\x01\x02\x02\x05\x12\x04\xd8\
    \x1f\x02\x08\n\x0e\n\x06\x04\x9b\x01\x02\x02\x01\x12\x04\xd8\x1f\t\x13\n\
    \x0e\n\x06\x04\x9b\x01\x02\x02\x03\x12\x04\xd8\x1f\x16\x17\n\r\n\x05\x04\
    \x9b\x01\x02\x03\x12\x04\xda\x1f\x02\x1c\n\x0e\n\x06\x04\x9b\x01\x02\x03\
    \x04\x12\x04\xda\x1f\x02\n\n\x0e\n\x06\x04\x9b\x01\x02\x03\x06\x12\x04\
    \xda\x1f\x0b\x10\n\x0e\n\x06\x04\x9b\x01\x02\x03\x01\x12\x04\xda\x1f\x11\
    \x17\n\x0e\n\x06\x04\x9b\x01\x02\x03\x03\x12\x04\xda\x1f\x1a\x1b\n\xb4\
    \x04\n\x05\x04\x9b\x01\x02\x04\x12\x04\xe1\x1f\x02!\x1a\xa4\x04\x20FIXME\
    (zeiler):\x20the\x20request\x20for\x20post\x20workflows\x20is\x20using\
    \x20an\x20outputconfig\x20object\x20that\x20is\x20supposed\n\x20to\x20be\
    \x20within\x20models.\x20This\x20is\x20not\x20consistent\x20with\x20sett\
    ing\x20this\x20on\x20the\x20request\x20for\x20post\x20model\n\x20outputs\
    \x20where\x20it\x20is\x20inside\x20a\x20model\x20object.\x20To\x20make\
    \x20this\x20consistent\x20we\x20would\x20send\x20in\x20the\n\x20workflow\
    \x20object\x20so\x20that\x20each\x20model\x20can\x20have\x20it's\x20own\
    \x20output\x20config.\x20If\x20nobody\x20is\x20setting\n\x20this\x20Outp\
    utConfig\x20it\x20would\x20probably\x20be\x20easier\x20to\x20just\x20rem\
    ove\x20it\x20for\x20now\x20to\x20keep\x20things\x20simpler\n\x20and\x20t\
    hen\x20it's\x20more\x20consistent\x20we\x20just\x20don't\x20support\x20t\
    he\x20OutputConfig\x20on\x20workflows.\n\n\x0e\n\x06\x04\x9b\x01\x02\x04\
    \x06\x12\x04\xe1\x1f\x02\x0e\n\x0e\n\x06\x04\x9b\x01\x02\x04\x01\x12\x04\
    \xe1\x1f\x0f\x1c\n\x0e\n\x06\x04\x9b\x01\x02\x04\x03\x12\x04\xe1\x1f\x1f\
    \x20\n`\n\x05\x04\x9b\x01\x02\x05\x12\x04\xe4\x1f\x02$\x1aQ\x20Use\x20th\
    is\x20flag\x20to\x20look\x20into\x20clarifai\x20published\x20workflows\
    \x20first\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\x9b\x01\x02\
    \x05\x05\x12\x04\xe4\x1f\x02\x06\n\x0e\n\x06\x04\x9b\x01\x02\x05\x01\x12\
    \x04\xe4\x1f\x07\x1f\n\x0e\n\x06\x04\x9b\x01\x02\x05\x03\x12\x04\xe4\x1f\
    \"#\n\xf5\x01\n\x05\x04\x9b\x01\x02\x06\x12\x04\xe9\x1f\x02#\x1a\xe5\x01\
    \x20A\x20workflow\x20state\x20to\x20be\x20maintained\x20across\x20PostWo\
    rkflowResults\x20requests/responses.\n\x20If\x20it\x20is\x20not\x20sent\
    \x20in\x20the\x20initial\x20request\x20with\x20workflow_state.id\x20=\
    \x20\"init\"\x20then\x20no\n\x20state\x20will\x20be\x20saved\x20or\x20re\
    turned\x20in\x20PostWorkflowResultsResponse.\n\n\x0e\n\x06\x04\x9b\x01\
    \x02\x06\x06\x12\x04\xe9\x1f\x02\x0f\n\x0e\n\x06\x04\x9b\x01\x02\x06\x01\
    \x12\x04\xe9\x1f\x10\x1e\n\x0e\n\x06\x04\x9b\x01\x02\x06\x03\x12\x04\xe9\
    \x1f!\"\n,\n\x03\x04\x9c\x01\x12\x06\xed\x1f\0\xfa\x1f\x01\x1a\x1d\x20Po\
    stWorkflowResultsResponse\n\n\x0c\n\x04\x04\x9c\x01\x01\x12\x04\xed\x1f\
    \x08#\n+\n\x05\x04\x9c\x01\x02\0\x12\x04\xef\x1f\x02(\x1a\x1c\x20The\x20\
    status\x20of\x20the\x20request.\n\n\x0e\n\x06\x04\x9c\x01\x02\0\x06\x12\
    \x04\xef\x1f\x02\x1c\n\x0e\n\x06\x04\x9c\x01\x02\0\x01\x12\x04\xef\x1f\
    \x1d#\n\x0e\n\x06\x04\x9c\x01\x02\0\x03\x12\x04\xef\x1f&'\nS\n\x05\x04\
    \x9c\x01\x02\x01\x12\x04\xf1\x1f\x02\x18\x1aD\x20The\x20workflow\x20that\
    \x20was\x20used\x20in\x20predictions\x20with\x20PostWorkflowResults\n\n\
    \x0e\n\x06\x04\x9c\x01\x02\x01\x06\x12\x04\xf1\x1f\x02\n\n\x0e\n\x06\x04\
    \x9c\x01\x02\x01\x01\x12\x04\xf1\x1f\x0b\x13\n\x0e\n\x06\x04\x9c\x01\x02\
    \x01\x03\x12\x04\xf1\x1f\x16\x17\nI\n\x05\x04\x9c\x01\x02\x02\x12\x04\
    \xf3\x1f\x02&\x1a:\x20The\x20resulting\x20predictions\x20of\x20all\x20mo\
    dels\x20in\x20the\x20workflow.\n\n\x0e\n\x06\x04\x9c\x01\x02\x02\x04\x12\
    \x04\xf3\x1f\x02\n\n\x0e\n\x06\x04\x9c\x01\x02\x02\x06\x12\x04\xf3\x1f\
    \x0b\x19\n\x0e\n\x06\x04\x9c\x01\x02\x02\x01\x12\x04\xf3\x1f\x1a!\n\x0e\
    \n\x06\x04\x9c\x01\x02\x02\x03\x12\x04\xf3\x1f$%\n\xd3\x02\n\x05\x04\x9c\
    \x01\x02\x03\x12\x04\xf9\x1f\x02#\x1a\xc3\x02\x20A\x20workflow\x20state\
    \x20to\x20be\x20maintained\x20across\x20PostWorkflowResults\x20requests/\
    responses.\n\x20This\x20WorkflowState\x20should\x20be\x20passed\x20in\
    \x20to\x20subsequent\x20PostWorkflowResults\x20calls\n\x20if\x20you\x20w\
    ant\x20to\x20keep\x20track\x20of\x20state\x20across\x20requests.\n\x20If\
    \x20no\x20WorkflowState\x20was\x20initialized\x20in\x20a\x20request\x20t\
    hen\x20no\x20WorkflowState\x20will\x20be\x20returned\x20in\x20this\n\x20\
    response.\n\n\x0e\n\x06\x04\x9c\x01\x02\x03\x06\x12\x04\xf9\x1f\x02\x0f\
    \n\x0e\n\x06\x04\x9c\x01\x02\x03\x01\x12\x04\xf9\x1f\x10\x1e\n\x0e\n\x06\
    \x04\x9c\x01\x02\x03\x03\x12\x04\xf9\x1f!\"\n5\n\x03\x04\x9d\x01\x12\x06\
    \xfd\x1f\0\x8b\x20\x01\x1a&\x20PostWorkflowResultsSimilarityRequest\n\n\
    \x0c\n\x04\x04\x9d\x01\x01\x12\x04\xfd\x1f\x08,\n\r\n\x05\x04\x9d\x01\
    \x02\0\x12\x04\xfe\x1f\x02,\n\x0e\n\x06\x04\x9d\x01\x02\0\x06\x12\x04\
    \xfe\x1f\x02\x1b\n\x0e\n\x06\x04\x9d\x01\x02\0\x01\x12\x04\xfe\x1f\x1c'\
    \n\x0e\n\x06\x04\x9d\x01\x02\0\x03\x12\x04\xfe\x1f*+\n\r\n\x05\x04\x9d\
    \x01\x02\x01\x12\x04\xff\x1f\x02\x19\n\x0e\n\x06\x04\x9d\x01\x02\x01\x05\
    \x12\x04\xff\x1f\x02\x08\n\x0e\n\x06\x04\x9d\x01\x02\x01\x01\x12\x04\xff\
    \x1f\t\x14\n\x0e\n\x06\x04\x9d\x01\x02\x01\x03\x12\x04\xff\x1f\x17\x18\n\
    h\n\x05\x04\x9d\x01\x02\x02\x12\x04\x82\x20\x02\x18\x1aY\x20Workflow\x20\
    version\x20ID\x20to\x20retrieve\n\x20If\x20no\x20ID\x20is\x20specified,\
    \x20latest\x20workflow\x20version\x20is\x20used\n\n\x0e\n\x06\x04\x9d\
    \x01\x02\x02\x05\x12\x04\x82\x20\x02\x08\n\x0e\n\x06\x04\x9d\x01\x02\x02\
    \x01\x12\x04\x82\x20\t\x13\n\x0e\n\x06\x04\x9d\x01\x02\x02\x03\x12\x04\
    \x82\x20\x16\x17\nJ\n\x05\x04\x9d\x01\x02\x03\x12\x04\x84\x20\x02\x1e\
    \x1a;\x20The\x20specific\x20model\x20version\x20whose\x20outputs\x20we\
    \x20are\x20comparing\n\n\x0e\n\x06\x04\x9d\x01\x02\x03\x05\x12\x04\x84\
    \x20\x02\x08\n\x0e\n\x06\x04\x9d\x01\x02\x03\x01\x12\x04\x84\x20\t\x19\n\
    \x0e\n\x06\x04\x9d\x01\x02\x03\x03\x12\x04\x84\x20\x1c\x1d\n@\n\x05\x04\
    \x9d\x01\x02\x04\x12\x04\x86\x20\x02\"\x1a1\x20Each\x20probe\x20is\x20co\
    mpared\x20against\x20every\x20pool\x20input\n\n\x0e\n\x06\x04\x9d\x01\
    \x02\x04\x04\x12\x04\x86\x20\x02\n\n\x0e\n\x06\x04\x9d\x01\x02\x04\x06\
    \x12\x04\x86\x20\x0b\x10\n\x0e\n\x06\x04\x9d\x01\x02\x04\x01\x12\x04\x86\
    \x20\x11\x1d\n\x0e\n\x06\x04\x9d\x01\x02\x04\x03\x12\x04\x86\x20\x20!\nE\
    \n\x05\x04\x9d\x01\x02\x05\x12\x04\x88\x20\x02!\x1a6\x20Each\x20pool\x20\
    input\x20is\x20compared\x20against\x20ever\x20probe\x20input\n\n\x0e\n\
    \x06\x04\x9d\x01\x02\x05\x04\x12\x04\x88\x20\x02\n\n\x0e\n\x06\x04\x9d\
    \x01\x02\x05\x06\x12\x04\x88\x20\x0b\x10\n\x0e\n\x06\x04\x9d\x01\x02\x05\
    \x01\x12\x04\x88\x20\x11\x1c\n\x0e\n\x06\x04\x9d\x01\x02\x05\x03\x12\x04\
    \x88\x20\x1f\x20\n`\n\x05\x04\x9d\x01\x02\x06\x12\x04\x8a\x20\x02$\x1aQ\
    \x20Use\x20this\x20flag\x20to\x20look\x20into\x20clarifai\x20published\
    \x20workflows\x20first\x20for\x20a\x20Workflow\x20ID\n\n\x0e\n\x06\x04\
    \x9d\x01\x02\x06\x05\x12\x04\x8a\x20\x02\x06\n\x0e\n\x06\x04\x9d\x01\x02\
    \x06\x01\x12\x04\x8a\x20\x07\x1f\n\x0e\n\x06\x04\x9d\x01\x02\x06\x03\x12\
    \x04\x8a\x20\"#\n6\n\x03\x04\x9e\x01\x12\x06\x8e\x20\0\x91\x20\x01\x1a'\
    \x20PostWorkflowResultsSimilarityResponse\n\n\x0c\n\x04\x04\x9e\x01\x01\
    \x12\x04\x8e\x20\x08-\n\r\n\x05\x04\x9e\x01\x02\0\x12\x04\x8f\x20\x02(\n\
    \x0e\n\x06\x04\x9e\x01\x02\0\x06\x12\x04\x8f\x20\x02\x1c\n\x0e\n\x06\x04\
    \x9e\x01\x02\0\x01\x12\x04\x8f\x20\x1d#\n\x0e\n\x06\x04\x9e\x01\x02\0\
    \x03\x12\x04\x8f\x20&'\n\r\n\x05\x04\x9e\x01\x02\x01\x12\x04\x90\x20\x02\
    1\n\x0e\n\x06\x04\x9e\x01\x02\x01\x04\x12\x04\x90\x20\x02\n\n\x0e\n\x06\
    \x04\x9e\x01\x02\x01\x06\x12\x04\x90\x20\x0b$\n\x0e\n\x06\x04\x9e\x01\
    \x02\x01\x01\x12\x04\x90\x20%,\n\x0e\n\x06\x04\x9e\x01\x02\x01\x03\x12\
    \x04\x90\x20/0\n,\n\x03\x04\x9f\x01\x12\x06\x94\x20\0\x9e\x20\x01\x1a\
    \x1d\x20ListWorkflowVersionsRequest\n\n\x0c\n\x04\x04\x9f\x01\x01\x12\
    \x04\x94\x20\x08#\n\r\n\x05\x04\x9f\x01\x02\0\x12\x04\x95\x20\x02,\n\x0e\
    \n\x06\x04\x9f\x01\x02\0\x06\x12\x04\x95\x20\x02\x1b\n\x0e\n\x06\x04\x9f\
    \x01\x02\0\x01\x12\x04\x95\x20\x1c'\n\x0e\n\x06\x04\x9f\x01\x02\0\x03\
    \x12\x04\x95\x20*+\nE\n\x05\x04\x9f\x01\x02\x01\x12\x04\x97\x20\x02\x19\
    \x1a6\x20List\x20versions\x20for\x20the\x20workflow\x20identified\x20by\
    \x20this\x20id\n\n\x0e\n\x06\x04\x9f\x01\x02\x01\x05\x12\x04\x97\x20\x02\
    \x08\n\x0e\n\x06\x04\x9f\x01\x02\x01\x01\x12\x04\x97\x20\t\x14\n\x0e\n\
    \x06\x04\x9f\x01\x02\x01\x03\x12\x04\x97\x20\x17\x18\n\x7f\n\x05\x04\x9f\
    \x01\x02\x02\x12\x04\x9a\x20\x02\x12\x1ap\x20(optional\x20URL\x20paramet\
    er)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\
    \x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\
    \n\x06\x04\x9f\x01\x02\x02\x05\x12\x04\x9a\x20\x02\x08\n\x0e\n\x06\x04\
    \x9f\x01\x02\x02\x01\x12\x04\x9a\x20\t\r\n\x0e\n\x06\x04\x9f\x01\x02\x02\
    \x03\x12\x04\x9a\x20\x10\x11\nv\n\x05\x04\x9f\x01\x02\x03\x12\x04\x9d\
    \x20\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\x20\
    of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20page.\
    \x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\x9f\x01\x02\x03\x05\x12\
    \x04\x9d\x20\x02\x08\n\x0e\n\x06\x04\x9f\x01\x02\x03\x01\x12\x04\x9d\x20\
    \t\x11\n\x0e\n\x06\x04\x9f\x01\x02\x03\x03\x12\x04\x9d\x20\x14\x15\n*\n\
    \x03\x04\xa0\x01\x12\x06\xa1\x20\0\xa7\x20\x01\x1a\x1b\x20GetWorkflowVer\
    sionRequest\n\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\xa1\x20\x08!\n\r\n\x05\
    \x04\xa0\x01\x02\0\x12\x04\xa2\x20\x04.\n\x0e\n\x06\x04\xa0\x01\x02\0\
    \x06\x12\x04\xa2\x20\x04\x1d\n\x0e\n\x06\x04\xa0\x01\x02\0\x01\x12\x04\
    \xa2\x20\x1e)\n\x0e\n\x06\x04\xa0\x01\x02\0\x03\x12\x04\xa2\x20,-\nG\n\
    \x05\x04\xa0\x01\x02\x01\x12\x04\xa4\x20\x04\x1b\x1a8\x20The\x20id\x20of\
    \x20the\x20workflow\x20that\x20has\x20the\x20requested\x20version.\n\n\
    \x0e\n\x06\x04\xa0\x01\x02\x01\x05\x12\x04\xa4\x20\x04\n\n\x0e\n\x06\x04\
    \xa0\x01\x02\x01\x01\x12\x04\xa4\x20\x0b\x16\n\x0e\n\x06\x04\xa0\x01\x02\
    \x01\x03\x12\x04\xa4\x20\x19\x1a\n.\n\x05\x04\xa0\x01\x02\x02\x12\x04\
    \xa6\x20\x04#\x1a\x1f\x20Get\x20the\x20identified\x20by\x20this\x20id\n\
    \n\x0e\n\x06\x04\xa0\x01\x02\x02\x05\x12\x04\xa6\x20\x04\n\n\x0e\n\x06\
    \x04\xa0\x01\x02\x02\x01\x12\x04\xa6\x20\x0b\x1e\n\x0e\n\x06\x04\xa0\x01\
    \x02\x02\x03\x12\x04\xa6\x20!\"\n.\n\x03\x04\xa1\x01\x12\x06\xaa\x20\0\
    \xb0\x20\x01\x1a\x1f\x20DeleteWorkflowVersionsRequest\n\n\x0c\n\x04\x04\
    \xa1\x01\x01\x12\x04\xaa\x20\x08%\n\r\n\x05\x04\xa1\x01\x02\0\x12\x04\
    \xab\x20\x04.\n\x0e\n\x06\x04\xa1\x01\x02\0\x06\x12\x04\xab\x20\x04\x1d\
    \n\x0e\n\x06\x04\xa1\x01\x02\0\x01\x12\x04\xab\x20\x1e)\n\x0e\n\x06\x04\
    \xa1\x01\x02\0\x03\x12\x04\xab\x20,-\nR\n\x05\x04\xa1\x01\x02\x01\x12\
    \x04\xad\x20\x04\x1b\x1aC\x20The\x20id\x20of\x20the\x20workflow\x20that\
    \x20has\x20the\x20requested\x20versions\x20to\x20delete.\n\n\x0e\n\x06\
    \x04\xa1\x01\x02\x01\x05\x12\x04\xad\x20\x04\n\n\x0e\n\x06\x04\xa1\x01\
    \x02\x01\x01\x12\x04\xad\x20\x0b\x16\n\x0e\n\x06\x04\xa1\x01\x02\x01\x03\
    \x12\x04\xad\x20\x19\x1a\n<\n\x05\x04\xa1\x01\x02\x02\x12\x04\xaf\x20\
    \x04-\x1a-\x20Delete\x20the\x20versions\x20identified\x20by\x20these\x20\
    ids\n\n\x0e\n\x06\x04\xa1\x01\x02\x02\x04\x12\x04\xaf\x20\x04\x0c\n\x0e\
    \n\x06\x04\xa1\x01\x02\x02\x05\x12\x04\xaf\x20\r\x13\n\x0e\n\x06\x04\xa1\
    \x01\x02\x02\x01\x12\x04\xaf\x20\x14(\n\x0e\n\x06\x04\xa1\x01\x02\x02\
    \x03\x12\x04\xaf\x20+,\n-\n\x03\x04\xa2\x01\x12\x06\xb3\x20\0\xbc\x20\
    \x01\x1a\x1e\x20PatchWorkflowVersionsRequest\n\n\x0c\n\x04\x04\xa2\x01\
    \x01\x12\x04\xb3\x20\x08$\n\r\n\x05\x04\xa2\x01\x02\0\x12\x04\xb4\x20\
    \x04.\n\x0e\n\x06\x04\xa2\x01\x02\0\x06\x12\x04\xb4\x20\x04\x1d\n\x0e\n\
    \x06\x04\xa2\x01\x02\0\x01\x12\x04\xb4\x20\x1e)\n\x0e\n\x06\x04\xa2\x01\
    \x02\0\x03\x12\x04\xb4\x20,-\nQ\n\x05\x04\xa2\x01\x02\x01\x12\x04\xb6\
    \x20\x04\x1b\x1aB\x20The\x20id\x20of\x20the\x20workflow\x20that\x20has\
    \x20the\x20requested\x20versions\x20to\x20patch.\n\n\x0e\n\x06\x04\xa2\
    \x01\x02\x01\x05\x12\x04\xb6\x20\x04\n\n\x0e\n\x06\x04\xa2\x01\x02\x01\
    \x01\x12\x04\xb6\x20\x0b\x16\n\x0e\n\x06\x04\xa2\x01\x02\x01\x03\x12\x04\
    \xb6\x20\x19\x1a\n&\n\x05\x04\xa2\x01\x02\x02\x12\x04\xb8\x20\x043\x1a\
    \x17\x20Patch\x20these\x20versions.\n\n\x0e\n\x06\x04\xa2\x01\x02\x02\
    \x04\x12\x04\xb8\x20\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x02\x06\x12\x04\
    \xb8\x20\r\x1c\n\x0e\n\x06\x04\xa2\x01\x02\x02\x01\x12\x04\xb8\x20\x1d.\
    \n\x0e\n\x06\x04\xa2\x01\x02\x02\x03\x12\x04\xb8\x2012\n\x7f\n\x05\x04\
    \xa2\x01\x02\x03\x12\x04\xbb\x20\x04\x16\x1ap\x20The\x20action\x20to\x20\
    perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\x20actions\
    \x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20supported\n\n\
    \x0e\n\x06\x04\xa2\x01\x02\x03\x05\x12\x04\xbb\x20\x04\n\n\x0e\n\x06\x04\
    \xa2\x01\x02\x03\x01\x12\x04\xbb\x20\x0b\x11\n\x0e\n\x06\x04\xa2\x01\x02\
    \x03\x03\x12\x04\xbb\x20\x14\x15\n-\n\x03\x04\xa3\x01\x12\x06\xbf\x20\0\
    \xc2\x20\x01\x1a\x1e\x20MultiWorkflowVersionResponse\n\n\x0c\n\x04\x04\
    \xa3\x01\x01\x12\x04\xbf\x20\x08$\n\r\n\x05\x04\xa3\x01\x02\0\x12\x04\
    \xc0\x20\x04*\n\x0e\n\x06\x04\xa3\x01\x02\0\x06\x12\x04\xc0\x20\x04\x1e\
    \n\x0e\n\x06\x04\xa3\x01\x02\0\x01\x12\x04\xc0\x20\x1f%\n\x0e\n\x06\x04\
    \xa3\x01\x02\0\x03\x12\x04\xc0\x20()\n\r\n\x05\x04\xa3\x01\x02\x01\x12\
    \x04\xc1\x20\x04b\n\x0e\n\x06\x04\xa3\x01\x02\x01\x04\x12\x04\xc1\x20\
    \x04\x0c\n\x0e\n\x06\x04\xa3\x01\x02\x01\x06\x12\x04\xc1\x20\r\x1c\n\x0e\
    \n\x06\x04\xa3\x01\x02\x01\x01\x12\x04\xc1\x20\x1d.\n\x0e\n\x06\x04\xa3\
    \x01\x02\x01\x03\x12\x04\xc1\x2012\n\x0e\n\x06\x04\xa3\x01\x02\x01\x08\
    \x12\x04\xc1\x203a\n\x11\n\t\x04\xa3\x01\x02\x01\x08\xd0\x86\x03\x12\x04\
    \xc1\x204`\n.\n\x03\x04\xa4\x01\x12\x06\xc5\x20\0\xc8\x20\x01\x1a\x1f\
    \x20SingleWorkflowVersionResponse\n\n\x0c\n\x04\x04\xa4\x01\x01\x12\x04\
    \xc5\x20\x08%\n\r\n\x05\x04\xa4\x01\x02\0\x12\x04\xc6\x20\x04*\n\x0e\n\
    \x06\x04\xa4\x01\x02\0\x06\x12\x04\xc6\x20\x04\x1e\n\x0e\n\x06\x04\xa4\
    \x01\x02\0\x01\x12\x04\xc6\x20\x1f%\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\
    \x12\x04\xc6\x20()\n\r\n\x05\x04\xa4\x01\x02\x01\x12\x04\xc7\x20\x04)\n\
    \x0e\n\x06\x04\xa4\x01\x02\x01\x06\x12\x04\xc7\x20\x04\x13\n\x0e\n\x06\
    \x04\xa4\x01\x02\x01\x01\x12\x04\xc7\x20\x14$\n\x0e\n\x06\x04\xa4\x01\
    \x02\x01\x03\x12\x04\xc7\x20'(\n:\n\x03\x04\xa5\x01\x12\x06\xd3\x20\0\
    \xd6\x20\x01\x1a+Request\x20to\x20start\x20a\x20app\x20duplication\x20pr\
    ocess\n\n\x0c\n\x04\x04\xa5\x01\x01\x12\x04\xd3\x20\x08\"\n\r\n\x05\x04\
    \xa5\x01\x02\0\x12\x04\xd4\x20\x02,\n\x0e\n\x06\x04\xa5\x01\x02\0\x06\
    \x12\x04\xd4\x20\x02\x1b\n\x0e\n\x06\x04\xa5\x01\x02\0\x01\x12\x04\xd4\
    \x20\x1c'\n\x0e\n\x06\x04\xa5\x01\x02\0\x03\x12\x04\xd4\x20*+\n\r\n\x05\
    \x04\xa5\x01\x02\x01\x12\x04\xd5\x20\x02/\n\x0e\n\x06\x04\xa5\x01\x02\
    \x01\x04\x12\x04\xd5\x20\x02\n\n\x0e\n\x06\x04\xa5\x01\x02\x01\x06\x12\
    \x04\xd5\x20\x0b\x19\n\x0e\n\x06\x04\xa5\x01\x02\x01\x01\x12\x04\xd5\x20\
    \x1a*\n\x0e\n\x06\x04\xa5\x01\x02\x01\x03\x12\x04\xd5\x20-.\n7\n\x03\x04\
    \xa6\x01\x12\x06\xd9\x20\0\xdd\x20\x01\x1a(Request\x20to\x20check\x20app\
    \x20duplication\x20status\n\n\x0c\n\x04\x04\xa6\x01\x01\x12\x04\xd9\x20\
    \x08\x20\n\r\n\x05\x04\xa6\x01\x02\0\x12\x04\xda\x20\x02,\n\x0e\n\x06\
    \x04\xa6\x01\x02\0\x06\x12\x04\xda\x20\x02\x1b\n\x0e\n\x06\x04\xa6\x01\
    \x02\0\x01\x12\x04\xda\x20\x1c'\n\x0e\n\x06\x04\xa6\x01\x02\0\x03\x12\
    \x04\xda\x20*+\n&\n\x05\x04\xa6\x01\x02\x01\x12\x04\xdc\x20\x02\x20\x1a\
    \x17The\x20app\x20duplication\x20id\n\n\x0e\n\x06\x04\xa6\x01\x02\x01\
    \x05\x12\x04\xdc\x20\x02\x08\n\x0e\n\x06\x04\xa6\x01\x02\x01\x01\x12\x04\
    \xdc\x20\t\x1b\n\x0e\n\x06\x04\xa6\x01\x02\x01\x03\x12\x04\xdc\x20\x1e\
    \x1f\nL\n\x03\x04\xa7\x01\x12\x06\xe0\x20\0\xe8\x20\x01\x1a=Request\x20t\
    o\x20list\x20all\x20the\x20app\x20duplication\x20that\x20user\x20trigger\
    ed.\n\n\x0c\n\x04\x04\xa7\x01\x01\x12\x04\xe0\x20\x08\"\n\r\n\x05\x04\
    \xa7\x01\x02\0\x12\x04\xe1\x20\x02,\n\x0e\n\x06\x04\xa7\x01\x02\0\x06\
    \x12\x04\xe1\x20\x02\x1b\n\x0e\n\x06\x04\xa7\x01\x02\0\x01\x12\x04\xe1\
    \x20\x1c'\n\x0e\n\x06\x04\xa7\x01\x02\0\x03\x12\x04\xe1\x20*+\n\x7f\n\
    \x05\x04\xa7\x01\x02\x01\x12\x04\xe4\x20\x02\x12\x1ap\x20(optional\x20UR\
    L\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\
    \x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\
    \x201.\n\n\x0e\n\x06\x04\xa7\x01\x02\x01\x05\x12\x04\xe4\x20\x02\x08\n\
    \x0e\n\x06\x04\xa7\x01\x02\x01\x01\x12\x04\xe4\x20\t\r\n\x0e\n\x06\x04\
    \xa7\x01\x02\x01\x03\x12\x04\xe4\x20\x10\x11\nv\n\x05\x04\xa7\x01\x02\
    \x02\x12\x04\xe7\x20\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20T\
    he\x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\
    \x20each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xa7\x01\
    \x02\x02\x05\x12\x04\xe7\x20\x02\x08\n\x0e\n\x06\x04\xa7\x01\x02\x02\x01\
    \x12\x04\xe7\x20\t\x11\n\x0e\n\x06\x04\xa7\x01\x02\x02\x03\x12\x04\xe7\
    \x20\x14\x15\n-\n\x03\x04\xa8\x01\x12\x06\xeb\x20\0\xee\x20\x01\x1a\x1e\
    \x20MultiAppDuplicationsResponse\n\n\x0c\n\x04\x04\xa8\x01\x01\x12\x04\
    \xeb\x20\x08$\n\r\n\x05\x04\xa8\x01\x02\0\x12\x04\xec\x20\x02(\n\x0e\n\
    \x06\x04\xa8\x01\x02\0\x06\x12\x04\xec\x20\x02\x1c\n\x0e\n\x06\x04\xa8\
    \x01\x02\0\x01\x12\x04\xec\x20\x1d#\n\x0e\n\x06\x04\xa8\x01\x02\0\x03\
    \x12\x04\xec\x20&'\n\r\n\x05\x04\xa8\x01\x02\x01\x12\x04\xed\x20\x02/\n\
    \x0e\n\x06\x04\xa8\x01\x02\x01\x04\x12\x04\xed\x20\x02\n\n\x0e\n\x06\x04\
    \xa8\x01\x02\x01\x06\x12\x04\xed\x20\x0b\x19\n\x0e\n\x06\x04\xa8\x01\x02\
    \x01\x01\x12\x04\xed\x20\x1a*\n\x0e\n\x06\x04\xa8\x01\x02\x01\x03\x12\
    \x04\xed\x20-.\n-\n\x03\x04\xa9\x01\x12\x06\xf1\x20\0\xf4\x20\x01\x1a\
    \x1e\x20SingleAppDuplicationResponse\n\n\x0c\n\x04\x04\xa9\x01\x01\x12\
    \x04\xf1\x20\x08$\n\r\n\x05\x04\xa9\x01\x02\0\x12\x04\xf2\x20\x02(\n\x0e\
    \n\x06\x04\xa9\x01\x02\0\x06\x12\x04\xf2\x20\x02\x1c\n\x0e\n\x06\x04\xa9\
    \x01\x02\0\x01\x12\x04\xf2\x20\x1d#\n\x0e\n\x06\x04\xa9\x01\x02\0\x03\
    \x12\x04\xf2\x20&'\n\r\n\x05\x04\xa9\x01\x02\x01\x12\x04\xf3\x20\x02%\n\
    \x0e\n\x06\x04\xa9\x01\x02\x01\x06\x12\x04\xf3\x20\x02\x10\n\x0e\n\x06\
    \x04\xa9\x01\x02\x01\x01\x12\x04\xf3\x20\x11\x20\n\x0e\n\x06\x04\xa9\x01\
    \x02\x01\x03\x12\x04\xf3\x20#$\n)\n\x03\x04\xaa\x01\x12\x06\xf7\x20\0\
    \xfa\x20\x01\x1a\x1a\x20Request\x20to\x20create\x20Tasks.\n\n\x0c\n\x04\
    \x04\xaa\x01\x01\x12\x04\xf7\x20\x08\x18\n\r\n\x05\x04\xaa\x01\x02\0\x12\
    \x04\xf8\x20\x02,\n\x0e\n\x06\x04\xaa\x01\x02\0\x06\x12\x04\xf8\x20\x02\
    \x1b\n\x0e\n\x06\x04\xaa\x01\x02\0\x01\x12\x04\xf8\x20\x1c'\n\x0e\n\x06\
    \x04\xaa\x01\x02\0\x03\x12\x04\xf8\x20*+\n\r\n\x05\x04\xaa\x01\x02\x01\
    \x12\x04\xf9\x20\x02\x1a\n\x0e\n\x06\x04\xaa\x01\x02\x01\x04\x12\x04\xf9\
    \x20\x02\n\n\x0e\n\x06\x04\xaa\x01\x02\x01\x06\x12\x04\xf9\x20\x0b\x0f\n\
    \x0e\n\x06\x04\xaa\x01\x02\x01\x01\x12\x04\xf9\x20\x10\x15\n\x0e\n\x06\
    \x04\xaa\x01\x02\x01\x03\x12\x04\xf9\x20\x18\x19\n)\n\x03\x04\xab\x01\
    \x12\x06\xfd\x20\0\x80!\x01\x1a\x1a\x20Request\x20to\x20get\x20one\x20ta\
    sk.\n\n\x0c\n\x04\x04\xab\x01\x01\x12\x04\xfd\x20\x08\x16\n\r\n\x05\x04\
    \xab\x01\x02\0\x12\x04\xfe\x20\x02,\n\x0e\n\x06\x04\xab\x01\x02\0\x06\
    \x12\x04\xfe\x20\x02\x1b\n\x0e\n\x06\x04\xab\x01\x02\0\x01\x12\x04\xfe\
    \x20\x1c'\n\x0e\n\x06\x04\xab\x01\x02\0\x03\x12\x04\xfe\x20*+\n\r\n\x05\
    \x04\xab\x01\x02\x01\x12\x04\xff\x20\x02\x15\n\x0e\n\x06\x04\xab\x01\x02\
    \x01\x05\x12\x04\xff\x20\x02\x08\n\x0e\n\x06\x04\xab\x01\x02\x01\x01\x12\
    \x04\xff\x20\t\x10\n\x0e\n\x06\x04\xab\x01\x02\x01\x03\x12\x04\xff\x20\
    \x13\x14\n0\n\x03\x04\xac\x01\x12\x06\x83!\0\x91!\x01\x1a!\x20Request\
    \x20to\x20list\x20multiple\x20tasks.\n\n\x0c\n\x04\x04\xac\x01\x01\x12\
    \x04\x83!\x08\x18\n\r\n\x05\x04\xac\x01\x02\0\x12\x04\x84!\x02,\n\x0e\n\
    \x06\x04\xac\x01\x02\0\x06\x12\x04\x84!\x02\x1b\n\x0e\n\x06\x04\xac\x01\
    \x02\0\x01\x12\x04\x84!\x1c'\n\x0e\n\x06\x04\xac\x01\x02\0\x03\x12\x04\
    \x84!*+\n\x7f\n\x05\x04\xac\x01\x02\x01\x12\x04\x87!\x02\x12\x1ap\x20(op\
    tional\x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20i\
    s\x20used\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defau\
    lts\x20to\x201.\n\n\x0e\n\x06\x04\xac\x01\x02\x01\x05\x12\x04\x87!\x02\
    \x08\n\x0e\n\x06\x04\xac\x01\x02\x01\x01\x12\x04\x87!\t\r\n\x0e\n\x06\
    \x04\xac\x01\x02\x01\x03\x12\x04\x87!\x10\x11\nv\n\x05\x04\xac\x01\x02\
    \x02\x12\x04\x8a!\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\
    \x20number\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20\
    each\x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xac\x01\x02\
    \x02\x05\x12\x04\x8a!\x02\x08\n\x0e\n\x06\x04\xac\x01\x02\x02\x01\x12\
    \x04\x8a!\t\x11\n\x0e\n\x06\x04\xac\x01\x02\x02\x03\x12\x04\x8a!\x14\x15\
    \nP\n\x05\x04\xac\x01\x02\x03\x12\x04\x8c!\x02&\x1aA\x20Get\x20tasks\x20\
    that\x20have\x20ANY\x20user\x20from\x20this\x20list\x20assigned\x20as\
    \x20worker.\n\n\x0e\n\x06\x04\xac\x01\x02\x03\x04\x12\x04\x8c!\x02\n\n\
    \x0e\n\x06\x04\xac\x01\x02\x03\x05\x12\x04\x8c!\x0b\x11\n\x0e\n\x06\x04\
    \xac\x01\x02\x03\x01\x12\x04\x8c!\x12!\n\x0e\n\x06\x04\xac\x01\x02\x03\
    \x03\x12\x04\x8c!$%\nR\n\x05\x04\xac\x01\x02\x04\x12\x04\x8e!\x02&\x1aC\
    \x20Get\x20tasks\x20that\x20have\x20ANY\x20user\x20from\x20this\x20list\
    \x20assigned\x20as\x20reviewer.\n\n\x0e\n\x06\x04\xac\x01\x02\x04\x04\
    \x12\x04\x8e!\x02\n\n\x0e\n\x06\x04\xac\x01\x02\x04\x05\x12\x04\x8e!\x0b\
    \x11\n\x0e\n\x06\x04\xac\x01\x02\x04\x01\x12\x04\x8e!\x12!\n\x0e\n\x06\
    \x04\xac\x01\x02\x04\x03\x12\x04\x8e!$%\n.\n\x05\x04\xac\x01\x02\x05\x12\
    \x04\x90!\x02'\x1a\x1f\x20Get\x20label\x20order\x20tasks\x20as\x20well\n\
    \n\x0e\n\x06\x04\xac\x01\x02\x05\x05\x12\x04\x90!\x02\x06\n\x0e\n\x06\
    \x04\xac\x01\x02\x05\x01\x12\x04\x90!\x07\"\n\x0e\n\x06\x04\xac\x01\x02\
    \x05\x03\x12\x04\x90!%&\n2\n\x03\x04\xad\x01\x12\x06\x94!\0\x9a!\x01\x1a\
    #\x20Request\x20to\x20patch\x20a\x20list\x20of\x20tasks.\n\n\x0c\n\x04\
    \x04\xad\x01\x01\x12\x04\x94!\x08\x19\n\r\n\x05\x04\xad\x01\x02\0\x12\
    \x04\x95!\x02,\n\x0e\n\x06\x04\xad\x01\x02\0\x06\x12\x04\x95!\x02\x1b\n\
    \x0e\n\x06\x04\xad\x01\x02\0\x01\x12\x04\x95!\x1c'\n\x0e\n\x06\x04\xad\
    \x01\x02\0\x03\x12\x04\x95!*+\n\r\n\x05\x04\xad\x01\x02\x01\x12\x04\x96!\
    \x02\x1a\n\x0e\n\x06\x04\xad\x01\x02\x01\x04\x12\x04\x96!\x02\n\n\x0e\n\
    \x06\x04\xad\x01\x02\x01\x06\x12\x04\x96!\x0b\x0f\n\x0e\n\x06\x04\xad\
    \x01\x02\x01\x01\x12\x04\x96!\x10\x15\n\x0e\n\x06\x04\xad\x01\x02\x01\
    \x03\x12\x04\x96!\x18\x19\n\x7f\n\x05\x04\xad\x01\x02\x02\x12\x04\x99!\
    \x02\x14\x1ap\x20The\x20action\x20to\x20perform\x20on\x20the\x20patched\
    \x20objects\n\x20For\x20now\x20actions\x20'merge',\x20'overwrite',\x20an\
    d\x20'remove'\x20are\x20supported\n\n\x0e\n\x06\x04\xad\x01\x02\x02\x05\
    \x12\x04\x99!\x02\x08\n\x0e\n\x06\x04\xad\x01\x02\x02\x01\x12\x04\x99!\t\
    \x0f\n\x0e\n\x06\x04\xad\x01\x02\x02\x03\x12\x04\x99!\x12\x13\n3\n\x03\
    \x04\xae\x01\x12\x06\x9d!\0\xa0!\x01\x1a$\x20Request\x20to\x20delete\x20\
    a\x20list\x20of\x20tasks.\n\n\x0c\n\x04\x04\xae\x01\x01\x12\x04\x9d!\x08\
    \x1a\n\r\n\x05\x04\xae\x01\x02\0\x12\x04\x9e!\x02,\n\x0e\n\x06\x04\xae\
    \x01\x02\0\x06\x12\x04\x9e!\x02\x1b\n\x0e\n\x06\x04\xae\x01\x02\0\x01\
    \x12\x04\x9e!\x1c'\n\x0e\n\x06\x04\xae\x01\x02\0\x03\x12\x04\x9e!*+\n\r\
    \n\x05\x04\xae\x01\x02\x01\x12\x04\x9f!\x02\x1a\n\x0e\n\x06\x04\xae\x01\
    \x02\x01\x04\x12\x04\x9f!\x02\n\n\x0e\n\x06\x04\xae\x01\x02\x01\x05\x12\
    \x04\x9f!\x0b\x11\n\x0e\n\x06\x04\xae\x01\x02\x01\x01\x12\x04\x9f!\x12\
    \x15\n\x0e\n\x06\x04\xae\x01\x02\x01\x03\x12\x04\x9f!\x18\x19\n.\n\x03\
    \x04\xaf\x01\x12\x06\xa3!\0\xa6!\x01\x1a\x1f\x20Response\x20with\x20mult\
    iple\x20Tasks.\n\n\x0c\n\x04\x04\xaf\x01\x01\x12\x04\xa3!\x08\x19\n\r\n\
    \x05\x04\xaf\x01\x02\0\x12\x04\xa4!\x02(\n\x0e\n\x06\x04\xaf\x01\x02\0\
    \x06\x12\x04\xa4!\x02\x1c\n\x0e\n\x06\x04\xaf\x01\x02\0\x01\x12\x04\xa4!\
    \x1d#\n\x0e\n\x06\x04\xaf\x01\x02\0\x03\x12\x04\xa4!&'\n\r\n\x05\x04\xaf\
    \x01\x02\x01\x12\x04\xa5!\x02I\n\x0e\n\x06\x04\xaf\x01\x02\x01\x04\x12\
    \x04\xa5!\x02\n\n\x0e\n\x06\x04\xaf\x01\x02\x01\x06\x12\x04\xa5!\x0b\x0f\
    \n\x0e\n\x06\x04\xaf\x01\x02\x01\x01\x12\x04\xa5!\x10\x15\n\x0e\n\x06\
    \x04\xaf\x01\x02\x01\x03\x12\x04\xa5!\x18\x19\n\x0e\n\x06\x04\xaf\x01\
    \x02\x01\x08\x12\x04\xa5!\x1aH\n\x11\n\t\x04\xaf\x01\x02\x01\x08\xd0\x86\
    \x03\x12\x04\xa5!\x1bG\n-\n\x03\x04\xb0\x01\x12\x06\xa9!\0\xac!\x01\x1a\
    \x1e\x20Response\x20with\x20a\x20single\x20Task.\n\n\x0c\n\x04\x04\xb0\
    \x01\x01\x12\x04\xa9!\x08\x1a\n\r\n\x05\x04\xb0\x01\x02\0\x12\x04\xaa!\
    \x02(\n\x0e\n\x06\x04\xb0\x01\x02\0\x06\x12\x04\xaa!\x02\x1c\n\x0e\n\x06\
    \x04\xb0\x01\x02\0\x01\x12\x04\xaa!\x1d#\n\x0e\n\x06\x04\xb0\x01\x02\0\
    \x03\x12\x04\xaa!&'\n\r\n\x05\x04\xb0\x01\x02\x01\x12\x04\xab!\x02\x10\n\
    \x0e\n\x06\x04\xb0\x01\x02\x01\x06\x12\x04\xab!\x02\x06\n\x0e\n\x06\x04\
    \xb0\x01\x02\x01\x01\x12\x04\xab!\x07\x0b\n\x0e\n\x06\x04\xb0\x01\x02\
    \x01\x03\x12\x04\xab!\x0e\x0f\n\xae\x01\n\x03\x04\xb1\x01\x12\x06\xb1!\0\
    \xb9!\x01\x1a\x9e\x01\x20GetTaskCountRequest\x20can\x20be\x20used\x20for\
    \x20fetching\x20-\n\x201.\x20Task\x20annotation\x20count\x20per\x20user,\
    \x20per\x20status\n\x201.\x20Task\x20input\x20(anchor\x20annotations)\
    \x20count\x20per\x20user,\x20per\x20status\n\n\x0c\n\x04\x04\xb1\x01\x01\
    \x12\x04\xb1!\x08\x1b\n\r\n\x05\x04\xb1\x01\x02\0\x12\x04\xb2!\x02,\n\
    \x0e\n\x06\x04\xb1\x01\x02\0\x06\x12\x04\xb2!\x02\x1b\n\x0e\n\x06\x04\
    \xb1\x01\x02\0\x01\x12\x04\xb2!\x1c'\n\x0e\n\x06\x04\xb1\x01\x02\0\x03\
    \x12\x04\xb2!*+\nF\n\x05\x04\xb1\x01\x02\x01\x12\x04\xb5!\x02\x15\x1a7\
    \x20task_id\x20for\x20which\x20count\x20per\x20user\x20per\x20status\x20\
    is\x20needed\n\n\x0e\n\x06\x04\xb1\x01\x02\x01\x05\x12\x04\xb5!\x02\x08\
    \n\x0e\n\x06\x04\xb1\x01\x02\x01\x01\x12\x04\xb5!\t\x10\n\x0e\n\x06\x04\
    \xb1\x01\x02\x01\x03\x12\x04\xb5!\x13\x14\nD\n\x05\x04\xb1\x01\x02\x02\
    \x12\x04\xb8!\x02\x1e\x1a5\x20for\x20given\x20task_id,\x20user_ids\x20to\
    \x20filter\x20on\x20(optional)\n\n\x0e\n\x06\x04\xb1\x01\x02\x02\x04\x12\
    \x04\xb8!\x02\n\n\x0e\n\x06\x04\xb1\x01\x02\x02\x05\x12\x04\xb8!\x0b\x11\
    \n\x0e\n\x06\x04\xb1\x01\x02\x02\x01\x12\x04\xb8!\x12\x1a\n\x0e\n\x06\
    \x04\xb1\x01\x02\x02\x03\x12\x04\xb8!\x1c\x1d\n\x81\x01\n\x03\x04\xb2\
    \x01\x12\x06\xbe!\0\xc3!\x01\x1ar\x20SingleTaskCountResponse\x20represen\
    t\x20counts\x20of\x20annotations\x20or\x20inputs(anchor\x20annotations)\
    \x20for\x20labelers\x20in\x20given\x20task\n\n\x0c\n\x04\x04\xb2\x01\x01\
    \x12\x04\xbe!\x08\x1f\n\r\n\x05\x04\xb2\x01\x02\0\x12\x04\xbf!\x02(\n\
    \x0e\n\x06\x04\xb2\x01\x02\0\x06\x12\x04\xbf!\x02\x1c\n\x0e\n\x06\x04\
    \xb2\x01\x02\0\x01\x12\x04\xbf!\x1d#\n\x0e\n\x06\x04\xb2\x01\x02\0\x03\
    \x12\x04\xbf!&'\n\r\n\x05\x04\xb2\x01\x02\x01\x12\x04\xc0!\x02\x14\n\x0e\
    \n\x06\x04\xb2\x01\x02\x01\x05\x12\x04\xc0!\x02\x08\n\x0e\n\x06\x04\xb2\
    \x01\x02\x01\x01\x12\x04\xc0!\t\x0f\n\x0e\n\x06\x04\xb2\x01\x02\x01\x03\
    \x12\x04\xc0!\x12\x13\n\r\n\x05\x04\xb2\x01\x02\x02\x12\x04\xc1!\x02\x15\
    \n\x0e\n\x06\x04\xb2\x01\x02\x02\x05\x12\x04\xc1!\x02\x08\n\x0e\n\x06\
    \x04\xb2\x01\x02\x02\x01\x12\x04\xc1!\t\x10\n\x0e\n\x06\x04\xb2\x01\x02\
    \x02\x03\x12\x04\xc1!\x13\x14\n\r\n\x05\x04\xb2\x01\x02\x03\x12\x04\xc2!\
    \x02-\n\x0e\n\x06\x04\xb2\x01\x02\x03\x04\x12\x04\xc2!\x02\n\n\x0e\n\x06\
    \x04\xb2\x01\x02\x03\x06\x12\x04\xc2!\x0b!\n\x0e\n\x06\x04\xb2\x01\x02\
    \x03\x01\x12\x04\xc2!\"(\n\x0e\n\x06\x04\xb2\x01\x02\x03\x03\x12\x04\xc2\
    !+,\n0\n\x03\x04\xb3\x01\x12\x06\xc6!\0\xc9!\x01\x1a!\x20Request\x20to\
    \x20create\x20label\x20orders.\n\n\x0c\n\x04\x04\xb3\x01\x01\x12\x04\xc6\
    !\x08\x1e\n\r\n\x05\x04\xb3\x01\x02\0\x12\x04\xc7!\x02,\n\x0e\n\x06\x04\
    \xb3\x01\x02\0\x06\x12\x04\xc7!\x02\x1b\n\x0e\n\x06\x04\xb3\x01\x02\0\
    \x01\x12\x04\xc7!\x1c'\n\x0e\n\x06\x04\xb3\x01\x02\0\x03\x12\x04\xc7!*+\
    \n\r\n\x05\x04\xb3\x01\x02\x01\x12\x04\xc8!\x02'\n\x0e\n\x06\x04\xb3\x01\
    \x02\x01\x04\x12\x04\xc8!\x02\n\n\x0e\n\x06\x04\xb3\x01\x02\x01\x06\x12\
    \x04\xc8!\x0b\x15\n\x0e\n\x06\x04\xb3\x01\x02\x01\x01\x12\x04\xc8!\x16\"\
    \n\x0e\n\x06\x04\xb3\x01\x02\x01\x03\x12\x04\xc8!%&\n0\n\x03\x04\xb4\x01\
    \x12\x06\xcc!\0\xcf!\x01\x1a!\x20Request\x20to\x20get\x20one\x20label\
    \x20order.\n\n\x0c\n\x04\x04\xb4\x01\x01\x12\x04\xcc!\x08\x1c\n\r\n\x05\
    \x04\xb4\x01\x02\0\x12\x04\xcd!\x02,\n\x0e\n\x06\x04\xb4\x01\x02\0\x06\
    \x12\x04\xcd!\x02\x1b\n\x0e\n\x06\x04\xb4\x01\x02\0\x01\x12\x04\xcd!\x1c\
    '\n\x0e\n\x06\x04\xb4\x01\x02\0\x03\x12\x04\xcd!*+\n\r\n\x05\x04\xb4\x01\
    \x02\x01\x12\x04\xce!\x02\x1c\n\x0e\n\x06\x04\xb4\x01\x02\x01\x05\x12\
    \x04\xce!\x02\x08\n\x0e\n\x06\x04\xb4\x01\x02\x01\x01\x12\x04\xce!\t\x17\
    \n\x0e\n\x06\x04\xb4\x01\x02\x01\x03\x12\x04\xce!\x1a\x1b\n7\n\x03\x04\
    \xb5\x01\x12\x06\xd2!\0\xda!\x01\x1a(\x20Request\x20to\x20list\x20multip\
    le\x20label\x20orders.\n\n\x0c\n\x04\x04\xb5\x01\x01\x12\x04\xd2!\x08\
    \x1e\n\r\n\x05\x04\xb5\x01\x02\0\x12\x04\xd3!\x02,\n\x0e\n\x06\x04\xb5\
    \x01\x02\0\x06\x12\x04\xd3!\x02\x1b\n\x0e\n\x06\x04\xb5\x01\x02\0\x01\
    \x12\x04\xd3!\x1c'\n\x0e\n\x06\x04\xb5\x01\x02\0\x03\x12\x04\xd3!*+\n\
    \x7f\n\x05\x04\xb5\x01\x02\x01\x12\x04\xd6!\x02\x12\x1ap\x20(optional\
    \x20URL\x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20u\
    sed\x20to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\
    \x20to\x201.\n\n\x0e\n\x06\x04\xb5\x01\x02\x01\x05\x12\x04\xd6!\x02\x08\
    \n\x0e\n\x06\x04\xb5\x01\x02\x01\x01\x12\x04\xd6!\t\r\n\x0e\n\x06\x04\
    \xb5\x01\x02\x01\x03\x12\x04\xd6!\x10\x11\nv\n\x05\x04\xb5\x01\x02\x02\
    \x12\x04\xd9!\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20n\
    umber\x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\
    \x20page.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xb5\x01\x02\x02\
    \x05\x12\x04\xd9!\x02\x08\n\x0e\n\x06\x04\xb5\x01\x02\x02\x01\x12\x04\
    \xd9!\t\x11\n\x0e\n\x06\x04\xb5\x01\x02\x02\x03\x12\x04\xd9!\x14\x15\n9\
    \n\x03\x04\xb6\x01\x12\x06\xdd!\0\xe5!\x01\x1a*\x20Request\x20to\x20patc\
    h\x20a\x20list\x20of\x20label\x20orders.\n\n\x0c\n\x04\x04\xb6\x01\x01\
    \x12\x04\xdd!\x08\x1f\n\r\n\x05\x04\xb6\x01\x02\0\x12\x04\xde!\x02,\n\
    \x0e\n\x06\x04\xb6\x01\x02\0\x06\x12\x04\xde!\x02\x1b\n\x0e\n\x06\x04\
    \xb6\x01\x02\0\x01\x12\x04\xde!\x1c'\n\x0e\n\x06\x04\xb6\x01\x02\0\x03\
    \x12\x04\xde!*+\n\r\n\x05\x04\xb6\x01\x02\x01\x12\x04\xe0!\x02'\n\x0e\n\
    \x06\x04\xb6\x01\x02\x01\x04\x12\x04\xe0!\x02\n\n\x0e\n\x06\x04\xb6\x01\
    \x02\x01\x06\x12\x04\xe0!\x0b\x15\n\x0e\n\x06\x04\xb6\x01\x02\x01\x01\
    \x12\x04\xe0!\x16\"\n\x0e\n\x06\x04\xb6\x01\x02\x01\x03\x12\x04\xe0!%&\n\
    \x7f\n\x05\x04\xb6\x01\x02\x02\x12\x04\xe4!\x02\x14\x1ap\x20The\x20actio\
    n\x20to\x20perform\x20on\x20the\x20patched\x20objects\n\x20For\x20now\
    \x20actions\x20'merge',\x20'overwrite',\x20and\x20'remove'\x20are\x20sup\
    ported\n\n\x0e\n\x06\x04\xb6\x01\x02\x02\x05\x12\x04\xe4!\x02\x08\n\x0e\
    \n\x06\x04\xb6\x01\x02\x02\x01\x12\x04\xe4!\t\x0f\n\x0e\n\x06\x04\xb6\
    \x01\x02\x02\x03\x12\x04\xe4!\x12\x13\n3\n\x03\x04\xb7\x01\x12\x06\xe8!\
    \0\xeb!\x01\x1a$\x20Request\x20to\x20delete\x20a\x20list\x20of\x20tasks.\
    \n\n\x0c\n\x04\x04\xb7\x01\x01\x12\x04\xe8!\x08\x20\n\r\n\x05\x04\xb7\
    \x01\x02\0\x12\x04\xe9!\x02,\n\x0e\n\x06\x04\xb7\x01\x02\0\x06\x12\x04\
    \xe9!\x02\x1b\n\x0e\n\x06\x04\xb7\x01\x02\0\x01\x12\x04\xe9!\x1c'\n\x0e\
    \n\x06\x04\xb7\x01\x02\0\x03\x12\x04\xe9!*+\n\r\n\x05\x04\xb7\x01\x02\
    \x01\x12\x04\xea!\x02\x1a\n\x0e\n\x06\x04\xb7\x01\x02\x01\x04\x12\x04\
    \xea!\x02\n\n\x0e\n\x06\x04\xb7\x01\x02\x01\x05\x12\x04\xea!\x0b\x11\n\
    \x0e\n\x06\x04\xb7\x01\x02\x01\x01\x12\x04\xea!\x12\x15\n\x0e\n\x06\x04\
    \xb7\x01\x02\x01\x03\x12\x04\xea!\x18\x19\n4\n\x03\x04\xb8\x01\x12\x06\
    \xee!\0\xf1!\x01\x1a%\x20Response\x20with\x20multiple\x20label\x20order.\
    \n\n\x0c\n\x04\x04\xb8\x01\x01\x12\x04\xee!\x08\x1f\n\r\n\x05\x04\xb8\
    \x01\x02\0\x12\x04\xef!\x02(\n\x0e\n\x06\x04\xb8\x01\x02\0\x06\x12\x04\
    \xef!\x02\x1c\n\x0e\n\x06\x04\xb8\x01\x02\0\x01\x12\x04\xef!\x1d#\n\x0e\
    \n\x06\x04\xb8\x01\x02\0\x03\x12\x04\xef!&'\n\r\n\x05\x04\xb8\x01\x02\
    \x01\x12\x04\xf0!\x02V\n\x0e\n\x06\x04\xb8\x01\x02\x01\x04\x12\x04\xf0!\
    \x02\n\n\x0e\n\x06\x04\xb8\x01\x02\x01\x06\x12\x04\xf0!\x0b\x15\n\x0e\n\
    \x06\x04\xb8\x01\x02\x01\x01\x12\x04\xf0!\x16\"\n\x0e\n\x06\x04\xb8\x01\
    \x02\x01\x03\x12\x04\xf0!%&\n\x0e\n\x06\x04\xb8\x01\x02\x01\x08\x12\x04\
    \xf0!'U\n\x11\n\t\x04\xb8\x01\x02\x01\x08\xd0\x86\x03\x12\x04\xf0!(T\n-\
    \n\x03\x04\xb9\x01\x12\x06\xf4!\0\xf7!\x01\x1a\x1e\x20Response\x20with\
    \x20a\x20label\x20order.\n\n\x0c\n\x04\x04\xb9\x01\x01\x12\x04\xf4!\x08\
    \x20\n\r\n\x05\x04\xb9\x01\x02\0\x12\x04\xf5!\x02(\n\x0e\n\x06\x04\xb9\
    \x01\x02\0\x06\x12\x04\xf5!\x02\x1c\n\x0e\n\x06\x04\xb9\x01\x02\0\x01\
    \x12\x04\xf5!\x1d#\n\x0e\n\x06\x04\xb9\x01\x02\0\x03\x12\x04\xf5!&'\n\r\
    \n\x05\x04\xb9\x01\x02\x01\x12\x04\xf6!\x02\x1d\n\x0e\n\x06\x04\xb9\x01\
    \x02\x01\x06\x12\x04\xf6!\x02\x0c\n\x0e\n\x06\x04\xb9\x01\x02\x01\x01\
    \x12\x04\xf6!\r\x18\n\x0e\n\x06\x04\xb9\x01\x02\x01\x03\x12\x04\xf6!\x1b\
    \x1c\n.\n\x03\x04\xba\x01\x12\x06\xfa!\0\xfd!\x01\x1a\x1f\x20Request\x20\
    to\x20create\x20Collectors.\n\n\x0c\n\x04\x04\xba\x01\x01\x12\x04\xfa!\
    \x08\x1d\n\r\n\x05\x04\xba\x01\x02\0\x12\x04\xfb!\x02,\n\x0e\n\x06\x04\
    \xba\x01\x02\0\x06\x12\x04\xfb!\x02\x1b\n\x0e\n\x06\x04\xba\x01\x02\0\
    \x01\x12\x04\xfb!\x1c'\n\x0e\n\x06\x04\xba\x01\x02\0\x03\x12\x04\xfb!*+\
    \n\r\n\x05\x04\xba\x01\x02\x01\x12\x04\xfc!\x02$\n\x0e\n\x06\x04\xba\x01\
    \x02\x01\x04\x12\x04\xfc!\x02\n\n\x0e\n\x06\x04\xba\x01\x02\x01\x06\x12\
    \x04\xfc!\x0b\x14\n\x0e\n\x06\x04\xba\x01\x02\x01\x01\x12\x04\xfc!\x15\
    \x1f\n\x0e\n\x06\x04\xba\x01\x02\x01\x03\x12\x04\xfc!\"#\n'\n\x03\x04\
    \xbb\x01\x12\x06\x80\"\0\x88\"\x01\x1a\x18\x20PatchCollectorsRequest\n\n\
    \x0c\n\x04\x04\xbb\x01\x01\x12\x04\x80\"\x08\x1e\n\r\n\x05\x04\xbb\x01\
    \x02\0\x12\x04\x81\"\x02,\n\x0e\n\x06\x04\xbb\x01\x02\0\x06\x12\x04\x81\
    \"\x02\x1b\n\x0e\n\x06\x04\xbb\x01\x02\0\x01\x12\x04\x81\"\x1c'\n\x0e\n\
    \x06\x04\xbb\x01\x02\0\x03\x12\x04\x81\"*+\n\r\n\x05\x04\xbb\x01\x02\x01\
    \x12\x04\x83\"\x02$\n\x0e\n\x06\x04\xbb\x01\x02\x01\x04\x12\x04\x83\"\
    \x02\n\n\x0e\n\x06\x04\xbb\x01\x02\x01\x06\x12\x04\x83\"\x0b\x14\n\x0e\n\
    \x06\x04\xbb\x01\x02\x01\x01\x12\x04\x83\"\x15\x1f\n\x0e\n\x06\x04\xbb\
    \x01\x02\x01\x03\x12\x04\x83\"\"#\n\\\n\x05\x04\xbb\x01\x02\x02\x12\x04\
    \x87\"\x02\x14\x1aM\x20The\x20action\x20to\x20perform\x20on\x20the\x20pa\
    tched\x20objects\n\x20Only\x20'overwrite'\x20is\x20supported\n\n\x0e\n\
    \x06\x04\xbb\x01\x02\x02\x05\x12\x04\x87\"\x02\x08\n\x0e\n\x06\x04\xbb\
    \x01\x02\x02\x01\x12\x04\x87\"\t\x0f\n\x0e\n\x06\x04\xbb\x01\x02\x02\x03\
    \x12\x04\x87\"\x12\x13\nE\n\x03\x04\xbc\x01\x12\x06\x8b\"\0\x8f\"\x01\
    \x1a6\x20Request\x20to\x20delete\x20several\x20things\x20by\x20the\x20li\
    st\x20of\x20ids.\n\n\x0c\n\x04\x04\xbc\x01\x01\x12\x04\x8b\"\x08\x1f\n\r\
    \n\x05\x04\xbc\x01\x02\0\x12\x04\x8c\"\x02,\n\x0e\n\x06\x04\xbc\x01\x02\
    \0\x06\x12\x04\x8c\"\x02\x1b\n\x0e\n\x06\x04\xbc\x01\x02\0\x01\x12\x04\
    \x8c\"\x1c'\n\x0e\n\x06\x04\xbc\x01\x02\0\x03\x12\x04\x8c\"*+\n\r\n\x05\
    \x04\xbc\x01\x02\x01\x12\x04\x8d\"\x02\x1a\n\x0e\n\x06\x04\xbc\x01\x02\
    \x01\x04\x12\x04\x8d\"\x02\n\n\x0e\n\x06\x04\xbc\x01\x02\x01\x05\x12\x04\
    \x8d\"\x0b\x11\n\x0e\n\x06\x04\xbc\x01\x02\x01\x01\x12\x04\x8d\"\x12\x15\
    \n\x0e\n\x06\x04\xbc\x01\x02\x01\x03\x12\x04\x8d\"\x18\x19\n\r\n\x05\x04\
    \xbc\x01\x02\x02\x12\x04\x8e\"\x02\x16\n\x0e\n\x06\x04\xbc\x01\x02\x02\
    \x05\x12\x04\x8e\"\x02\x06\n\x0e\n\x06\x04\xbc\x01\x02\x02\x01\x12\x04\
    \x8e\"\x07\x11\n\x0e\n\x06\x04\xbc\x01\x02\x02\x03\x12\x04\x8e\"\x14\x15\
    \n3\n\x03\x04\xbd\x01\x12\x06\x92\"\0\x96\"\x01\x1a$\x20Request\x20to\
    \x20GET\x20a\x20single\x20Collector.\n\n\x0c\n\x04\x04\xbd\x01\x01\x12\
    \x04\x92\"\x08\x1b\n\r\n\x05\x04\xbd\x01\x02\0\x12\x04\x93\"\x02,\n\x0e\
    \n\x06\x04\xbd\x01\x02\0\x06\x12\x04\x93\"\x02\x1b\n\x0e\n\x06\x04\xbd\
    \x01\x02\0\x01\x12\x04\x93\"\x1c'\n\x0e\n\x06\x04\xbd\x01\x02\0\x03\x12\
    \x04\x93\"*+\n!\n\x05\x04\xbd\x01\x02\x01\x12\x04\x95\"\x02\x1a\x1a\x12T\
    he\x20collecgtor\x20id\n\n\x0e\n\x06\x04\xbd\x01\x02\x01\x05\x12\x04\x95\
    \"\x02\x08\n\x0e\n\x06\x04\xbd\x01\x02\x01\x01\x12\x04\x95\"\t\x15\n\x0e\
    \n\x06\x04\xbd\x01\x02\x01\x03\x12\x04\x95\"\x18\x19\n3\n\x03\x04\xbe\
    \x01\x12\x06\x99\"\0\xa1\"\x01\x1a$\x20Request\x20to\x20GET\x20all\x20th\
    e\x20Collectors.\n\n\x0c\n\x04\x04\xbe\x01\x01\x12\x04\x99\"\x08\x1d\n\r\
    \n\x05\x04\xbe\x01\x02\0\x12\x04\x9a\"\x02,\n\x0e\n\x06\x04\xbe\x01\x02\
    \0\x06\x12\x04\x9a\"\x02\x1b\n\x0e\n\x06\x04\xbe\x01\x02\0\x01\x12\x04\
    \x9a\"\x1c'\n\x0e\n\x06\x04\xbe\x01\x02\0\x03\x12\x04\x9a\"*+\n\x7f\n\
    \x05\x04\xbe\x01\x02\x01\x12\x04\x9d\"\x02\x12\x1ap\x20(optional\x20URL\
    \x20parameter)\x20The\x20page\x20number.\x20Pagination\x20is\x20used\x20\
    to\x20split\x20the\x20results\x20into\x20chunks.\n\x20Defaults\x20to\x20\
    1.\n\n\x0e\n\x06\x04\xbe\x01\x02\x01\x05\x12\x04\x9d\"\x02\x08\n\x0e\n\
    \x06\x04\xbe\x01\x02\x01\x01\x12\x04\x9d\"\t\r\n\x0e\n\x06\x04\xbe\x01\
    \x02\x01\x03\x12\x04\x9d\"\x10\x11\nv\n\x05\x04\xbe\x01\x02\x02\x12\x04\
    \xa0\"\x02\x16\x1ag\x20(optional\x20URL\x20parameter)\x20The\x20number\
    \x20of\x20results\x20that\x20will\x20be\x20contained\x20in\x20each\x20pa\
    ge.\x20Defaults\n\x20to\x20128.\n\n\x0e\n\x06\x04\xbe\x01\x02\x02\x05\
    \x12\x04\xa0\"\x02\x08\n\x0e\n\x06\x04\xbe\x01\x02\x02\x01\x12\x04\xa0\"\
    \t\x11\n\x0e\n\x06\x04\xbe\x01\x02\x02\x03\x12\x04\xa0\"\x14\x15\n3\n\
    \x03\x04\xbf\x01\x12\x06\xa4\"\0\xa7\"\x01\x1a$\x20Response\x20with\x20m\
    ultiple\x20Collectors.\n\n\x0c\n\x04\x04\xbf\x01\x01\x12\x04\xa4\"\x08\
    \x1e\n\r\n\x05\x04\xbf\x01\x02\0\x12\x04\xa5\"\x02(\n\x0e\n\x06\x04\xbf\
    \x01\x02\0\x06\x12\x04\xa5\"\x02\x1c\n\x0e\n\x06\x04\xbf\x01\x02\0\x01\
    \x12\x04\xa5\"\x1d#\n\x0e\n\x06\x04\xbf\x01\x02\0\x03\x12\x04\xa5\"&'\n\
    \r\n\x05\x04\xbf\x01\x02\x01\x12\x04\xa6\"\x02$\n\x0e\n\x06\x04\xbf\x01\
    \x02\x01\x04\x12\x04\xa6\"\x02\n\n\x0e\n\x06\x04\xbf\x01\x02\x01\x06\x12\
    \x04\xa6\"\x0b\x14\n\x0e\n\x06\x04\xbf\x01\x02\x01\x01\x12\x04\xa6\"\x15\
    \x1f\n\x0e\n\x06\x04\xbf\x01\x02\x01\x03\x12\x04\xa6\"\"#\n2\n\x03\x04\
    \xc0\x01\x12\x06\xaa\"\0\xad\"\x01\x1a#\x20Response\x20with\x20a\x20sing\
    le\x20Collector.\n\n\x0c\n\x04\x04\xc0\x01\x01\x12\x04\xaa\"\x08\x1f\n\r\
    \n\x05\x04\xc0\x01\x02\0\x12\x04\xab\"\x02(\n\x0e\n\x06\x04\xc0\x01\x02\
    \0\x06\x12\x04\xab\"\x02\x1c\n\x0e\n\x06\x04\xc0\x01\x02\0\x01\x12\x04\
    \xab\"\x1d#\n\x0e\n\x06\x04\xc0\x01\x02\0\x03\x12\x04\xab\"&'\n\r\n\x05\
    \x04\xc0\x01\x02\x01\x12\x04\xac\"\x02\x1a\n\x0e\n\x06\x04\xc0\x01\x02\
    \x01\x06\x12\x04\xac\"\x02\x0b\n\x0e\n\x06\x04\xc0\x01\x02\x01\x01\x12\
    \x04\xac\"\x0c\x15\n\x0e\n\x06\x04\xc0\x01\x02\x01\x03\x12\x04\xac\"\x18\
    \x19\n&\n\x03\x04\xc1\x01\x12\x06\xb0\"\0\xb5\"\x01\x1a\x17\x20PostStatV\
    aluesRequest\n\n\x0c\n\x04\x04\xc1\x01\x01\x12\x04\xb0\"\x08\x1d\n>\n\
    \x05\x04\xc1\x01\x02\0\x12\x04\xb2\"\x02,\x1a/\x20The\x20user\x20and\x20\
    app\x20information\x20for\x20the\x20request.\n\n\x0e\n\x06\x04\xc1\x01\
    \x02\0\x06\x12\x04\xb2\"\x02\x1b\n\x0e\n\x06\x04\xc1\x01\x02\0\x01\x12\
    \x04\xb2\"\x1c'\n\x0e\n\x06\x04\xc1\x01\x02\0\x03\x12\x04\xb2\"*+\nE\n\
    \x05\x04\xc1\x01\x02\x01\x12\x04\xb4\"\x02%\x1a6\x20The\x20stats\x20to\
    \x20post,\x20can\x20post\x20more\x20than\x20one\x20at\x20a\x20time.\n\n\
    \x0e\n\x06\x04\xc1\x01\x02\x01\x04\x12\x04\xb4\"\x02\n\n\x0e\n\x06\x04\
    \xc1\x01\x02\x01\x06\x12\x04\xb4\"\x0b\x14\n\x0e\n\x06\x04\xc1\x01\x02\
    \x01\x01\x12\x04\xb4\"\x15\x20\n\x0e\n\x06\x04\xc1\x01\x02\x01\x03\x12\
    \x04\xb4\"#$\n'\n\x03\x04\xc2\x01\x12\x06\xb8\"\0\xbd\"\x01\x1a\x18\x20M\
    ultiStatValueResponse\n\n\x0c\n\x04\x04\xc2\x01\x01\x12\x04\xb8\"\x08\
    \x1e\n%\n\x05\x04\xc2\x01\x02\0\x12\x04\xba\"\x02(\x1a\x16\x20The\x20res\
    ponse\x20status.\n\n\x0e\n\x06\x04\xc2\x01\x02\0\x06\x12\x04\xba\"\x02\
    \x1c\n\x0e\n\x06\x04\xc2\x01\x02\0\x01\x12\x04\xba\"\x1d#\n\x0e\n\x06\
    \x04\xc2\x01\x02\0\x03\x12\x04\xba\"&'\n+\n\x05\x04\xc2\x01\x02\x01\x12\
    \x04\xbc\"\x02T\x1a\x1c\x20The\x20returned\x20stats\x20values.\n\n\x0e\n\
    \x06\x04\xc2\x01\x02\x01\x04\x12\x04\xbc\"\x02\n\n\x0e\n\x06\x04\xc2\x01\
    \x02\x01\x06\x12\x04\xbc\"\x0b\x14\n\x0e\n\x06\x04\xc2\x01\x02\x01\x01\
    \x12\x04\xbc\"\x15\x20\n\x0e\n\x06\x04\xc2\x01\x02\x01\x03\x12\x04\xbc\"\
    #$\n\x0e\n\x06\x04\xc2\x01\x02\x01\x08\x12\x04\xbc\"%S\n\x11\n\t\x04\xc2\
    \x01\x02\x01\x08\xd0\x86\x03\x12\x04\xbc\"&R\n/\n\x03\x04\xc3\x01\x12\
    \x06\xc0\"\0\xc6\"\x01\x1a\x20\x20PostStatValuesAggregateRequest\n\n\x0c\
    \n\x04\x04\xc3\x01\x01\x12\x04\xc0\"\x08&\n7\n\x05\x04\xc3\x01\x02\0\x12\
    \x04\xc2\"\x02,\x1a(\x20Ids\x20present\x20in\x20the\x20url\x20of\x20the\
    \x20request.\n\n\x0e\n\x06\x04\xc3\x01\x02\0\x06\x12\x04\xc2\"\x02\x1b\n\
    \x0e\n\x06\x04\xc3\x01\x02\0\x01\x12\x04\xc2\"\x1c'\n\x0e\n\x06\x04\xc3\
    \x01\x02\0\x03\x12\x04\xc2\"*+\n4\n\x05\x04\xc3\x01\x02\x01\x12\x04\xc5\
    \"\x02D\x1a%\x20Query\x20to\x20retrieve\x20aggregate\x20values.\n\n\x0e\
    \n\x06\x04\xc3\x01\x02\x01\x04\x12\x04\xc5\"\x02\n\n\x0e\n\x06\x04\xc3\
    \x01\x02\x01\x06\x12\x04\xc5\"\x0b\"\n\x0e\n\x06\x04\xc3\x01\x02\x01\x01\
    \x12\x04\xc5\"#?\n\x0e\n\x06\x04\xc3\x01\x02\x01\x03\x12\x04\xc5\"BC\n0\
    \n\x03\x04\xc4\x01\x12\x06\xc9\"\0\xcf\"\x01\x1a!\x20MultiStatValueAggre\
    gateResponse\n\n\x0c\n\x04\x04\xc4\x01\x01\x12\x04\xc9\"\x08'\n%\n\x05\
    \x04\xc4\x01\x02\0\x12\x04\xcb\"\x02(\x1a\x16\x20The\x20response\x20stat\
    us.\n\n\x0e\n\x06\x04\xc4\x01\x02\0\x06\x12\x04\xcb\"\x02\x1c\n\x0e\n\
    \x06\x04\xc4\x01\x02\0\x01\x12\x04\xcb\"\x1d#\n\x0e\n\x06\x04\xc4\x01\
    \x02\0\x03\x12\x04\xcb\"&'\n?\n\x05\x04\xc4\x01\x02\x01\x12\x04\xce\"\
    \x02E\x1a0\x20The\x20aggregate\x20results\x20for\x20each\x20query\x20pas\
    sedin.\n\n\x0e\n\x06\x04\xc4\x01\x02\x01\x04\x12\x04\xce\"\x02\n\n\x0e\n\
    \x06\x04\xc4\x01\x02\x01\x06\x12\x04\xce\"\x0b#\n\x0e\n\x06\x04\xc4\x01\
    \x02\x01\x01\x12\x04\xce\"$@\n\x0e\n\x06\x04\xc4\x01\x02\x01\x03\x12\x04\
    \xce\"CD\n/\n\x03\x04\xc5\x01\x12\x06\xdb\"\0\xe2\"\x01\x1a\x20\x20PostT\
    rendingMetricsViewRequest\n\n\x0c\n\x04\x04\xc5\x01\x01\x12\x04\xdb\"\
    \x08&\n4\n\x05\x04\xc5\x01\x02\0\x12\x04\xdd\"\x02,\x1a%\x20The\x20user_\
    id\x20and\x20app_id\x20information.\n\n\x0e\n\x06\x04\xc5\x01\x02\0\x06\
    \x12\x04\xdd\"\x02\x1b\n\x0e\n\x06\x04\xc5\x01\x02\0\x01\x12\x04\xdd\"\
    \x1c'\n\x0e\n\x06\x04\xc5\x01\x02\0\x03\x12\x04\xdd\"*+\nT\n\x05\x04\xc5\
    \x01\x02\x01\x12\x04\xdf\"\x02\x17\x1aE\x20For\x20now\x20view\x20types\
    \x20'apps',\x20'workflows',\x20and\x20'models'\x20are\x20supported.\n\n\
    \x0e\n\x06\x04\xc5\x01\x02\x01\x05\x12\x04\xdf\"\x02\x08\n\x0e\n\x06\x04\
    \xc5\x01\x02\x01\x01\x12\x04\xdf\"\t\x12\n\x0e\n\x06\x04\xc5\x01\x02\x01\
    \x03\x12\x04\xdf\"\x15\x16\n(\n\x05\x04\xc5\x01\x02\x02\x12\x04\xe1\"\
    \x02\x17\x1a\x19\x20ID\x20of\x20the\x20views\x20object.\n\n\x0e\n\x06\
    \x04\xc5\x01\x02\x02\x05\x12\x04\xe1\"\x02\x08\n\x0e\n\x06\x04\xc5\x01\
    \x02\x02\x01\x12\x04\xe1\"\t\x12\n\x0e\n\x06\x04\xc5\x01\x02\x02\x03\x12\
    \x04\xe1\"\x15\x16\n0\n\x03\x04\xc6\x01\x12\x06\xe5\"\0\xf0\"\x01\x1a!\
    \x20ListTrendingMetricsViewsRequest\n\n\x0c\n\x04\x04\xc6\x01\x01\x12\
    \x04\xe5\"\x08'\n4\n\x05\x04\xc6\x01\x02\0\x12\x04\xe7\"\x02,\x1a%\x20Th\
    e\x20user_id\x20and\x20app_id\x20information.\n\n\x0e\n\x06\x04\xc6\x01\
    \x02\0\x06\x12\x04\xe7\"\x02\x1b\n\x0e\n\x06\x04\xc6\x01\x02\0\x01\x12\
    \x04\xe7\"\x1c'\n\x0e\n\x06\x04\xc6\x01\x02\0\x03\x12\x04\xe7\"*+\nT\n\
    \x05\x04\xc6\x01\x02\x01\x12\x04\xe9\"\x02\x17\x1aE\x20For\x20now\x20vie\
    w\x20types\x20'apps',\x20'workflows',\x20and\x20'models'\x20are\x20suppo\
    rted.\n\n\x0e\n\x06\x04\xc6\x01\x02\x01\x05\x12\x04\xe9\"\x02\x08\n\x0e\
    \n\x06\x04\xc6\x01\x02\x01\x01\x12\x04\xe9\"\t\x12\n\x0e\n\x06\x04\xc6\
    \x01\x02\x01\x03\x12\x04\xe9\"\x15\x16\n\x7f\n\x05\x04\xc6\x01\x02\x02\
    \x12\x04\xec\"\x02\x12\x1ap\x20(optional\x20URL\x20parameter)\x20The\x20\
    page\x20number.\x20Pagination\x20is\x20used\x20to\x20split\x20the\x20res\
    ults\x20into\x20chunks.\n\x20Defaults\x20to\x201.\n\n\x0e\n\x06\x04\xc6\
    \x01\x02\x02\x05\x12\x04\xec\"\x02\x08\n\x0e\n\x06\x04\xc6\x01\x02\x02\
    \x01\x12\x04\xec\"\t\r\n\x0e\n\x06\x04\xc6\x01\x02\x02\x03\x12\x04\xec\"\
    \x10\x11\nv\n\x05\x04\xc6\x01\x02\x03\x12\x04\xef\"\x02\x16\x1ag\x20(opt\
    ional\x20URL\x20parameter)\x20The\x20number\x20of\x20results\x20that\x20\
    will\x20be\x20contained\x20in\x20each\x20page.\x20Defaults\n\x20to\x2012\
    8.\n\n\x0e\n\x06\x04\xc6\x01\x02\x03\x05\x12\x04\xef\"\x02\x08\n\x0e\n\
    \x06\x04\xc6\x01\x02\x03\x01\x12\x04\xef\"\t\x11\n\x0e\n\x06\x04\xc6\x01\
    \x02\x03\x03\x12\x04\xef\"\x14\x15\n1\n\x03\x04\xc7\x01\x12\x06\xf3\"\0\
    \xf6\"\x01\x1a\"\x20MultiTrendingMetricsViewResponse\n\n\x0c\n\x04\x04\
    \xc7\x01\x01\x12\x04\xf3\"\x08(\n\r\n\x05\x04\xc7\x01\x02\0\x12\x04\xf4\
    \"\x02(\n\x0e\n\x06\x04\xc7\x01\x02\0\x06\x12\x04\xf4\"\x02\x1c\n\x0e\n\
    \x06\x04\xc7\x01\x02\0\x01\x12\x04\xf4\"\x1d#\n\x0e\n\x06\x04\xc7\x01\
    \x02\0\x03\x12\x04\xf4\"&'\n\r\n\x05\x04\xc7\x01\x02\x01\x12\x04\xf5\"\
    \x02&\n\x0e\n\x06\x04\xc7\x01\x02\x01\x04\x12\x04\xf5\"\x02\n\n\x0e\n\
    \x06\x04\xc7\x01\x02\x01\x06\x12\x04\xf5\"\x0b\x19\n\x0e\n\x06\x04\xc7\
    \x01\x02\x01\x01\x12\x04\xf5\"\x1a!\n\x0e\n\x06\x04\xc7\x01\x02\x01\x03\
    \x12\x04\xf5\"$%b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
